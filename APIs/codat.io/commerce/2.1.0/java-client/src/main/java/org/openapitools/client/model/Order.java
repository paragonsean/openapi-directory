/*
 * Commerce API
 * Codat's Commerce API allows you to access standardised data from over 11 commerce and POS systems.  Standardize how you connect to your customersâ€™ payment, PoS, and eCommerce systems. Retrieve orders, payouts, payments, and product data in the same way for all the leading commerce platforms.  [Read more...](https://docs.codat.io/commerce-api/overview)  [See our OpenAPI spec](https://github.com/codatio/oas) 
 *
 * The version of the OpenAPI document: 2.1.0
 * Contact: support@codat.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CustomerRef;
import org.openapitools.client.model.LocationRef;
import org.openapitools.client.model.OrderAllOfCurrency;
import org.openapitools.client.model.OrderLineItem;
import org.openapitools.client.model.PaymentRef;
import org.openapitools.client.model.ServiceCharge;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Orders contain the transaction details for all products sold by the company, and include details of any payments, service charges, or refunds related to each order. You can use data from the Orders endpoints to calculate key metrics, such as gross sales values and monthly recurring revenue (MRR).  Explore our [data coverage](https://knowledge.codat.io/supported-features/commerce?view&#x3D;tab-by-data-type&amp;dataType&#x3D;commerce-orders) for this data type. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:18:00.334932-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Order {
  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private String createdDate;

  public static final String SERIALIZED_NAME_MODIFIED_DATE = "modifiedDate";
  @SerializedName(SERIALIZED_NAME_MODIFIED_DATE)
  private String modifiedDate;

  public static final String SERIALIZED_NAME_SOURCE_MODIFIED_DATE = "sourceModifiedDate";
  @SerializedName(SERIALIZED_NAME_SOURCE_MODIFIED_DATE)
  private String sourceModifiedDate;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_CLOSED_DATE = "closedDate";
  @SerializedName(SERIALIZED_NAME_CLOSED_DATE)
  private String closedDate;

  public static final String SERIALIZED_NAME_COUNTRY = "country";
  @SerializedName(SERIALIZED_NAME_COUNTRY)
  private String country;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private OrderAllOfCurrency currency;

  public static final String SERIALIZED_NAME_CUSTOMER_REF = "customerRef";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_REF)
  private CustomerRef customerRef;

  public static final String SERIALIZED_NAME_LOCATION_REF = "locationRef";
  @SerializedName(SERIALIZED_NAME_LOCATION_REF)
  private LocationRef locationRef;

  public static final String SERIALIZED_NAME_ORDER_LINE_ITEMS = "orderLineItems";
  @SerializedName(SERIALIZED_NAME_ORDER_LINE_ITEMS)
  private List<OrderLineItem> orderLineItems = new ArrayList<>();

  public static final String SERIALIZED_NAME_ORDER_NUMBER = "orderNumber";
  @SerializedName(SERIALIZED_NAME_ORDER_NUMBER)
  private String orderNumber;

  public static final String SERIALIZED_NAME_PAYMENTS = "payments";
  @SerializedName(SERIALIZED_NAME_PAYMENTS)
  private List<PaymentRef> payments = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE_CHARGES = "serviceCharges";
  @SerializedName(SERIALIZED_NAME_SERVICE_CHARGES)
  private List<ServiceCharge> serviceCharges = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOTAL_AMOUNT = "totalAmount";
  @SerializedName(SERIALIZED_NAME_TOTAL_AMOUNT)
  private String totalAmount;

  public static final String SERIALIZED_NAME_TOTAL_DISCOUNT = "totalDiscount";
  @SerializedName(SERIALIZED_NAME_TOTAL_DISCOUNT)
  private String totalDiscount;

  public static final String SERIALIZED_NAME_TOTAL_GRATUITY = "totalGratuity";
  @SerializedName(SERIALIZED_NAME_TOTAL_GRATUITY)
  private String totalGratuity;

  public static final String SERIALIZED_NAME_TOTAL_REFUND = "totalRefund";
  @SerializedName(SERIALIZED_NAME_TOTAL_REFUND)
  private String totalRefund;

  public static final String SERIALIZED_NAME_TOTAL_TAX_AMOUNT = "totalTaxAmount";
  @SerializedName(SERIALIZED_NAME_TOTAL_TAX_AMOUNT)
  private String totalTaxAmount;

  public Order() {
  }

  public Order createdDate(String createdDate) {
    this.createdDate = createdDate;
    return this;
  }

  /**
   * In Codat&#39;s data model, dates and times are represented using the &lt;a class&#x3D;\&quot;external\&quot; href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:  &#x60;&#x60;&#x60; 2020-10-08T22:40:50Z 2021-01-01T00:00:00 &#x60;&#x60;&#x60;    When syncing data that contains &#x60;DateTime&#x60; fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): &#x60;2021-11-15T06:00:00Z&#x60; - Unqualified local time: &#x60;2021-11-15T01:00:00&#x60; - UTC time offsets: &#x60;2021-11-15T01:00:00-05:00&#x60;  &gt; Time zones &gt;  &gt; Not all dates from Codat will contain information about time zones.   &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
   * @return createdDate
   */
  @javax.annotation.Nullable
  public String getCreatedDate() {
    return createdDate;
  }

  public void setCreatedDate(String createdDate) {
    this.createdDate = createdDate;
  }


  public Order modifiedDate(String modifiedDate) {
    this.modifiedDate = modifiedDate;
    return this;
  }

  /**
   * In Codat&#39;s data model, dates and times are represented using the &lt;a class&#x3D;\&quot;external\&quot; href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:  &#x60;&#x60;&#x60; 2020-10-08T22:40:50Z 2021-01-01T00:00:00 &#x60;&#x60;&#x60;    When syncing data that contains &#x60;DateTime&#x60; fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): &#x60;2021-11-15T06:00:00Z&#x60; - Unqualified local time: &#x60;2021-11-15T01:00:00&#x60; - UTC time offsets: &#x60;2021-11-15T01:00:00-05:00&#x60;  &gt; Time zones &gt;  &gt; Not all dates from Codat will contain information about time zones.   &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
   * @return modifiedDate
   */
  @javax.annotation.Nullable
  public String getModifiedDate() {
    return modifiedDate;
  }

  public void setModifiedDate(String modifiedDate) {
    this.modifiedDate = modifiedDate;
  }


  public Order sourceModifiedDate(String sourceModifiedDate) {
    this.sourceModifiedDate = sourceModifiedDate;
    return this;
  }

  /**
   * In Codat&#39;s data model, dates and times are represented using the &lt;a class&#x3D;\&quot;external\&quot; href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:  &#x60;&#x60;&#x60; 2020-10-08T22:40:50Z 2021-01-01T00:00:00 &#x60;&#x60;&#x60;    When syncing data that contains &#x60;DateTime&#x60; fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): &#x60;2021-11-15T06:00:00Z&#x60; - Unqualified local time: &#x60;2021-11-15T01:00:00&#x60; - UTC time offsets: &#x60;2021-11-15T01:00:00-05:00&#x60;  &gt; Time zones &gt;  &gt; Not all dates from Codat will contain information about time zones.   &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
   * @return sourceModifiedDate
   */
  @javax.annotation.Nullable
  public String getSourceModifiedDate() {
    return sourceModifiedDate;
  }

  public void setSourceModifiedDate(String sourceModifiedDate) {
    this.sourceModifiedDate = sourceModifiedDate;
  }


  public Order id(String id) {
    this.id = id;
    return this;
  }

  /**
   * A unique, persistent identifier for this record
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Order closedDate(String closedDate) {
    this.closedDate = closedDate;
    return this;
  }

  /**
   * In Codat&#39;s data model, dates and times are represented using the &lt;a class&#x3D;\&quot;external\&quot; href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:  &#x60;&#x60;&#x60; 2020-10-08T22:40:50Z 2021-01-01T00:00:00 &#x60;&#x60;&#x60;    When syncing data that contains &#x60;DateTime&#x60; fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): &#x60;2021-11-15T06:00:00Z&#x60; - Unqualified local time: &#x60;2021-11-15T01:00:00&#x60; - UTC time offsets: &#x60;2021-11-15T01:00:00-05:00&#x60;  &gt; Time zones &gt;  &gt; Not all dates from Codat will contain information about time zones.   &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
   * @return closedDate
   */
  @javax.annotation.Nullable
  public String getClosedDate() {
    return closedDate;
  }

  public void setClosedDate(String closedDate) {
    this.closedDate = closedDate;
  }


  public Order country(String country) {
    this.country = country;
    return this;
  }

  /**
   * The Codat country property is returned as it was provided in the underlying platform by the company without any formatting on our part.  Depending on the platform the value of this property will either be an &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO 3166&lt;/a&gt; code (2-alpha or 3-alpha) or free-form text returned as a string name in our model.   For POST operations against platforms that demand a specific format for the country code, we have documented accepted values in the [options](https://docs.codat.io/codat-api#/operations/get-companies-companyId-connections-connectionId-push) endpoint.
   * @return country
   */
  @javax.annotation.Nullable
  public String getCountry() {
    return country;
  }

  public void setCountry(String country) {
    this.country = country;
  }


  public Order currency(OrderAllOfCurrency currency) {
    this.currency = currency;
    return this;
  }

  /**
   * Get currency
   * @return currency
   */
  @javax.annotation.Nullable
  public OrderAllOfCurrency getCurrency() {
    return currency;
  }

  public void setCurrency(OrderAllOfCurrency currency) {
    this.currency = currency;
  }


  public Order customerRef(CustomerRef customerRef) {
    this.customerRef = customerRef;
    return this;
  }

  /**
   * Get customerRef
   * @return customerRef
   */
  @javax.annotation.Nullable
  public CustomerRef getCustomerRef() {
    return customerRef;
  }

  public void setCustomerRef(CustomerRef customerRef) {
    this.customerRef = customerRef;
  }


  public Order locationRef(LocationRef locationRef) {
    this.locationRef = locationRef;
    return this;
  }

  /**
   * Get locationRef
   * @return locationRef
   */
  @javax.annotation.Nullable
  public LocationRef getLocationRef() {
    return locationRef;
  }

  public void setLocationRef(LocationRef locationRef) {
    this.locationRef = locationRef;
  }


  public Order orderLineItems(List<OrderLineItem> orderLineItems) {
    this.orderLineItems = orderLineItems;
    return this;
  }

  public Order addOrderLineItemsItem(OrderLineItem orderLineItemsItem) {
    if (this.orderLineItems == null) {
      this.orderLineItems = new ArrayList<>();
    }
    this.orderLineItems.add(orderLineItemsItem);
    return this;
  }

  /**
   * Get orderLineItems
   * @return orderLineItems
   */
  @javax.annotation.Nullable
  public List<OrderLineItem> getOrderLineItems() {
    return orderLineItems;
  }

  public void setOrderLineItems(List<OrderLineItem> orderLineItems) {
    this.orderLineItems = orderLineItems;
  }


  public Order orderNumber(String orderNumber) {
    this.orderNumber = orderNumber;
    return this;
  }

  /**
   * Friendly reference for the order in the commerce or point of sale platform.
   * @return orderNumber
   */
  @javax.annotation.Nullable
  public String getOrderNumber() {
    return orderNumber;
  }

  public void setOrderNumber(String orderNumber) {
    this.orderNumber = orderNumber;
  }


  public Order payments(List<PaymentRef> payments) {
    this.payments = payments;
    return this;
  }

  public Order addPaymentsItem(PaymentRef paymentsItem) {
    if (this.payments == null) {
      this.payments = new ArrayList<>();
    }
    this.payments.add(paymentsItem);
    return this;
  }

  /**
   * Get payments
   * @return payments
   */
  @javax.annotation.Nullable
  public List<PaymentRef> getPayments() {
    return payments;
  }

  public void setPayments(List<PaymentRef> payments) {
    this.payments = payments;
  }


  public Order serviceCharges(List<ServiceCharge> serviceCharges) {
    this.serviceCharges = serviceCharges;
    return this;
  }

  public Order addServiceChargesItem(ServiceCharge serviceChargesItem) {
    if (this.serviceCharges == null) {
      this.serviceCharges = new ArrayList<>();
    }
    this.serviceCharges.add(serviceChargesItem);
    return this;
  }

  /**
   * Get serviceCharges
   * @return serviceCharges
   */
  @javax.annotation.Nullable
  public List<ServiceCharge> getServiceCharges() {
    return serviceCharges;
  }

  public void setServiceCharges(List<ServiceCharge> serviceCharges) {
    this.serviceCharges = serviceCharges;
  }


  public Order totalAmount(String totalAmount) {
    this.totalAmount = totalAmount;
    return this;
  }

  /**
   * Total amount of the order, including tax, net of any discounts and refunds.
   * @return totalAmount
   */
  @javax.annotation.Nullable
  public String getTotalAmount() {
    return totalAmount;
  }

  public void setTotalAmount(String totalAmount) {
    this.totalAmount = totalAmount;
  }


  public Order totalDiscount(String totalDiscount) {
    this.totalDiscount = totalDiscount;
    return this;
  }

  /**
   * Total amount of discount applied to the order.
   * @return totalDiscount
   */
  @javax.annotation.Nullable
  public String getTotalDiscount() {
    return totalDiscount;
  }

  public void setTotalDiscount(String totalDiscount) {
    this.totalDiscount = totalDiscount;
  }


  public Order totalGratuity(String totalGratuity) {
    this.totalGratuity = totalGratuity;
    return this;
  }

  /**
   * Extra amount added to a bill.
   * @return totalGratuity
   */
  @javax.annotation.Nullable
  public String getTotalGratuity() {
    return totalGratuity;
  }

  public void setTotalGratuity(String totalGratuity) {
    this.totalGratuity = totalGratuity;
  }


  public Order totalRefund(String totalRefund) {
    this.totalRefund = totalRefund;
    return this;
  }

  /**
   * Total amount refunded issued by a merchant on an order (always a negative value).
   * @return totalRefund
   */
  @javax.annotation.Nullable
  public String getTotalRefund() {
    return totalRefund;
  }

  public void setTotalRefund(String totalRefund) {
    this.totalRefund = totalRefund;
  }


  public Order totalTaxAmount(String totalTaxAmount) {
    this.totalTaxAmount = totalTaxAmount;
    return this;
  }

  /**
   * Total amount of tax applied to the order.
   * @return totalTaxAmount
   */
  @javax.annotation.Nullable
  public String getTotalTaxAmount() {
    return totalTaxAmount;
  }

  public void setTotalTaxAmount(String totalTaxAmount) {
    this.totalTaxAmount = totalTaxAmount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Order order = (Order) o;
    return Objects.equals(this.createdDate, order.createdDate) &&
        Objects.equals(this.modifiedDate, order.modifiedDate) &&
        Objects.equals(this.sourceModifiedDate, order.sourceModifiedDate) &&
        Objects.equals(this.id, order.id) &&
        Objects.equals(this.closedDate, order.closedDate) &&
        Objects.equals(this.country, order.country) &&
        Objects.equals(this.currency, order.currency) &&
        Objects.equals(this.customerRef, order.customerRef) &&
        Objects.equals(this.locationRef, order.locationRef) &&
        Objects.equals(this.orderLineItems, order.orderLineItems) &&
        Objects.equals(this.orderNumber, order.orderNumber) &&
        Objects.equals(this.payments, order.payments) &&
        Objects.equals(this.serviceCharges, order.serviceCharges) &&
        Objects.equals(this.totalAmount, order.totalAmount) &&
        Objects.equals(this.totalDiscount, order.totalDiscount) &&
        Objects.equals(this.totalGratuity, order.totalGratuity) &&
        Objects.equals(this.totalRefund, order.totalRefund) &&
        Objects.equals(this.totalTaxAmount, order.totalTaxAmount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createdDate, modifiedDate, sourceModifiedDate, id, closedDate, country, currency, customerRef, locationRef, orderLineItems, orderNumber, payments, serviceCharges, totalAmount, totalDiscount, totalGratuity, totalRefund, totalTaxAmount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Order {\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    modifiedDate: ").append(toIndentedString(modifiedDate)).append("\n");
    sb.append("    sourceModifiedDate: ").append(toIndentedString(sourceModifiedDate)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    closedDate: ").append(toIndentedString(closedDate)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    customerRef: ").append(toIndentedString(customerRef)).append("\n");
    sb.append("    locationRef: ").append(toIndentedString(locationRef)).append("\n");
    sb.append("    orderLineItems: ").append(toIndentedString(orderLineItems)).append("\n");
    sb.append("    orderNumber: ").append(toIndentedString(orderNumber)).append("\n");
    sb.append("    payments: ").append(toIndentedString(payments)).append("\n");
    sb.append("    serviceCharges: ").append(toIndentedString(serviceCharges)).append("\n");
    sb.append("    totalAmount: ").append(toIndentedString(totalAmount)).append("\n");
    sb.append("    totalDiscount: ").append(toIndentedString(totalDiscount)).append("\n");
    sb.append("    totalGratuity: ").append(toIndentedString(totalGratuity)).append("\n");
    sb.append("    totalRefund: ").append(toIndentedString(totalRefund)).append("\n");
    sb.append("    totalTaxAmount: ").append(toIndentedString(totalTaxAmount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("createdDate");
    openapiFields.add("modifiedDate");
    openapiFields.add("sourceModifiedDate");
    openapiFields.add("id");
    openapiFields.add("closedDate");
    openapiFields.add("country");
    openapiFields.add("currency");
    openapiFields.add("customerRef");
    openapiFields.add("locationRef");
    openapiFields.add("orderLineItems");
    openapiFields.add("orderNumber");
    openapiFields.add("payments");
    openapiFields.add("serviceCharges");
    openapiFields.add("totalAmount");
    openapiFields.add("totalDiscount");
    openapiFields.add("totalGratuity");
    openapiFields.add("totalRefund");
    openapiFields.add("totalTaxAmount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Order
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Order.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Order is not found in the empty JSON string", Order.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Order.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Order` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Order.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createdDate") != null && !jsonObj.get("createdDate").isJsonNull()) && !jsonObj.get("createdDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdDate").toString()));
      }
      if ((jsonObj.get("modifiedDate") != null && !jsonObj.get("modifiedDate").isJsonNull()) && !jsonObj.get("modifiedDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `modifiedDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("modifiedDate").toString()));
      }
      if ((jsonObj.get("sourceModifiedDate") != null && !jsonObj.get("sourceModifiedDate").isJsonNull()) && !jsonObj.get("sourceModifiedDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceModifiedDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceModifiedDate").toString()));
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("closedDate") != null && !jsonObj.get("closedDate").isJsonNull()) && !jsonObj.get("closedDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `closedDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("closedDate").toString()));
      }
      if ((jsonObj.get("country") != null && !jsonObj.get("country").isJsonNull()) && !jsonObj.get("country").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `country` to be a primitive type in the JSON string but got `%s`", jsonObj.get("country").toString()));
      }
      // validate the optional field `currency`
      if (jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) {
        OrderAllOfCurrency.validateJsonElement(jsonObj.get("currency"));
      }
      // validate the optional field `customerRef`
      if (jsonObj.get("customerRef") != null && !jsonObj.get("customerRef").isJsonNull()) {
        CustomerRef.validateJsonElement(jsonObj.get("customerRef"));
      }
      // validate the optional field `locationRef`
      if (jsonObj.get("locationRef") != null && !jsonObj.get("locationRef").isJsonNull()) {
        LocationRef.validateJsonElement(jsonObj.get("locationRef"));
      }
      if (jsonObj.get("orderLineItems") != null && !jsonObj.get("orderLineItems").isJsonNull()) {
        JsonArray jsonArrayorderLineItems = jsonObj.getAsJsonArray("orderLineItems");
        if (jsonArrayorderLineItems != null) {
          // ensure the json data is an array
          if (!jsonObj.get("orderLineItems").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `orderLineItems` to be an array in the JSON string but got `%s`", jsonObj.get("orderLineItems").toString()));
          }

          // validate the optional field `orderLineItems` (array)
          for (int i = 0; i < jsonArrayorderLineItems.size(); i++) {
            OrderLineItem.validateJsonElement(jsonArrayorderLineItems.get(i));
          };
        }
      }
      if ((jsonObj.get("orderNumber") != null && !jsonObj.get("orderNumber").isJsonNull()) && !jsonObj.get("orderNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderNumber").toString()));
      }
      if (jsonObj.get("payments") != null && !jsonObj.get("payments").isJsonNull()) {
        JsonArray jsonArraypayments = jsonObj.getAsJsonArray("payments");
        if (jsonArraypayments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("payments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `payments` to be an array in the JSON string but got `%s`", jsonObj.get("payments").toString()));
          }

          // validate the optional field `payments` (array)
          for (int i = 0; i < jsonArraypayments.size(); i++) {
            PaymentRef.validateJsonElement(jsonArraypayments.get(i));
          };
        }
      }
      if (jsonObj.get("serviceCharges") != null && !jsonObj.get("serviceCharges").isJsonNull()) {
        JsonArray jsonArrayserviceCharges = jsonObj.getAsJsonArray("serviceCharges");
        if (jsonArrayserviceCharges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("serviceCharges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `serviceCharges` to be an array in the JSON string but got `%s`", jsonObj.get("serviceCharges").toString()));
          }

          // validate the optional field `serviceCharges` (array)
          for (int i = 0; i < jsonArrayserviceCharges.size(); i++) {
            ServiceCharge.validateJsonElement(jsonArrayserviceCharges.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Order.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Order' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Order> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Order.class));

       return (TypeAdapter<T>) new TypeAdapter<Order>() {
           @Override
           public void write(JsonWriter out, Order value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Order read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Order given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Order
   * @throws IOException if the JSON string is invalid with respect to Order
   */
  public static Order fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Order.class);
  }

  /**
   * Convert an instance of Order to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

