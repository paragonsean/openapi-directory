# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.expense_transaction_line import ExpenseTransactionLine
from openapi_server import util


class ExpenseTransaction(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, currency: str=None, currency_rate: float=None, id: str=None, issue_date: str=None, lines: List[ExpenseTransactionLine]=None, merchant_name: str=None, notes: str=None, type: str=None):
        """ExpenseTransaction - a model defined in OpenAPI

        :param currency: The currency of this ExpenseTransaction.
        :param currency_rate: The currency_rate of this ExpenseTransaction.
        :param id: The id of this ExpenseTransaction.
        :param issue_date: The issue_date of this ExpenseTransaction.
        :param lines: The lines of this ExpenseTransaction.
        :param merchant_name: The merchant_name of this ExpenseTransaction.
        :param notes: The notes of this ExpenseTransaction.
        :param type: The type of this ExpenseTransaction.
        """
        self.openapi_types = {
            'currency': str,
            'currency_rate': float,
            'id': str,
            'issue_date': str,
            'lines': List[ExpenseTransactionLine],
            'merchant_name': str,
            'notes': str,
            'type': str
        }

        self.attribute_map = {
            'currency': 'currency',
            'currency_rate': 'currencyRate',
            'id': 'id',
            'issue_date': 'issueDate',
            'lines': 'lines',
            'merchant_name': 'merchantName',
            'notes': 'notes',
            'type': 'type'
        }

        self._currency = currency
        self._currency_rate = currency_rate
        self._id = id
        self._issue_date = issue_date
        self._lines = lines
        self._merchant_name = merchant_name
        self._notes = notes
        self._type = type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ExpenseTransaction':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ExpenseTransaction of this ExpenseTransaction.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def currency(self):
        """Gets the currency of this ExpenseTransaction.

        Currency the transaction was recorded in.

        :return: The currency of this ExpenseTransaction.
        :rtype: str
        """
        return self._currency

    @currency.setter
    def currency(self, currency):
        """Sets the currency of this ExpenseTransaction.

        Currency the transaction was recorded in.

        :param currency: The currency of this ExpenseTransaction.
        :type currency: str
        """
        if currency is None:
            raise ValueError("Invalid value for `currency`, must not be `None`")

        self._currency = currency

    @property
    def currency_rate(self):
        """Gets the currency_rate of this ExpenseTransaction.

        Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.  Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.    Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places).   For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.  ## Examples with base currency of GBP  | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) | | :--------------- | :------------- | :------------ | :------------------------- | | **USD**          | $20            | 0.781         | £15.62                     | | **EUR**          | €20            | 0.885         | £17.70                     | | **RUB**          | ₽20            | 0.011         | £0.22                      |  ## Examples with base currency of USD  | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) | | :--------------- | :------------- | :------------ | :------------------------- | | **GBP**          | £20            | 1.277         | $25.54                     | | **EUR**          | €20            | 1.134         | $22.68                     | | **RUB**          | ₽20            | 0.015         | $0.30                      |

        :return: The currency_rate of this ExpenseTransaction.
        :rtype: float
        """
        return self._currency_rate

    @currency_rate.setter
    def currency_rate(self, currency_rate):
        """Sets the currency_rate of this ExpenseTransaction.

        Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.  Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.    Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places).   For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.  ## Examples with base currency of GBP  | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) | | :--------------- | :------------- | :------------ | :------------------------- | | **USD**          | $20            | 0.781         | £15.62                     | | **EUR**          | €20            | 0.885         | £17.70                     | | **RUB**          | ₽20            | 0.011         | £0.22                      |  ## Examples with base currency of USD  | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) | | :--------------- | :------------- | :------------ | :------------------------- | | **GBP**          | £20            | 1.277         | $25.54                     | | **EUR**          | €20            | 1.134         | $22.68                     | | **RUB**          | ₽20            | 0.015         | $0.30                      |

        :param currency_rate: The currency_rate of this ExpenseTransaction.
        :type currency_rate: float
        """

        self._currency_rate = currency_rate

    @property
    def id(self):
        """Gets the id of this ExpenseTransaction.

        Your unique idenfier for the transaction.

        :return: The id of this ExpenseTransaction.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this ExpenseTransaction.

        Your unique idenfier for the transaction.

        :param id: The id of this ExpenseTransaction.
        :type id: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")

        self._id = id

    @property
    def issue_date(self):
        """Gets the issue_date of this ExpenseTransaction.

        In Codat's data model, dates and times are represented using the <a class=\"external\" href=\"https://en.wikipedia.org/wiki/ISO_8601\" target=\"_blank\">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:  ``` 2020-10-08T22:40:50Z 2021-01-01T00:00:00 ```    When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z` - Unqualified local time: `2021-11-15T01:00:00` - UTC time offsets: `2021-11-15T01:00:00-05:00`  > Time zones >  > Not all dates from Codat will contain information about time zones.   > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.

        :return: The issue_date of this ExpenseTransaction.
        :rtype: str
        """
        return self._issue_date

    @issue_date.setter
    def issue_date(self, issue_date):
        """Sets the issue_date of this ExpenseTransaction.

        In Codat's data model, dates and times are represented using the <a class=\"external\" href=\"https://en.wikipedia.org/wiki/ISO_8601\" target=\"_blank\">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:  ``` 2020-10-08T22:40:50Z 2021-01-01T00:00:00 ```    When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z` - Unqualified local time: `2021-11-15T01:00:00` - UTC time offsets: `2021-11-15T01:00:00-05:00`  > Time zones >  > Not all dates from Codat will contain information about time zones.   > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.

        :param issue_date: The issue_date of this ExpenseTransaction.
        :type issue_date: str
        """
        if issue_date is None:
            raise ValueError("Invalid value for `issue_date`, must not be `None`")

        self._issue_date = issue_date

    @property
    def lines(self):
        """Gets the lines of this ExpenseTransaction.

        Array of transaction lines.

        :return: The lines of this ExpenseTransaction.
        :rtype: List[ExpenseTransactionLine]
        """
        return self._lines

    @lines.setter
    def lines(self, lines):
        """Sets the lines of this ExpenseTransaction.

        Array of transaction lines.

        :param lines: The lines of this ExpenseTransaction.
        :type lines: List[ExpenseTransactionLine]
        """
        if lines is not None and len(lines) > 100:
            raise ValueError("Invalid value for `lines`, number of items must be less than or equal to `100`")
        if lines is not None and len(lines) < 1:
            raise ValueError("Invalid value for `lines`, number of items must be greater than or equal to `1`")

        self._lines = lines

    @property
    def merchant_name(self):
        """Gets the merchant_name of this ExpenseTransaction.

        Name of the merchant where the purchase took place

        :return: The merchant_name of this ExpenseTransaction.
        :rtype: str
        """
        return self._merchant_name

    @merchant_name.setter
    def merchant_name(self, merchant_name):
        """Sets the merchant_name of this ExpenseTransaction.

        Name of the merchant where the purchase took place

        :param merchant_name: The merchant_name of this ExpenseTransaction.
        :type merchant_name: str
        """

        self._merchant_name = merchant_name

    @property
    def notes(self):
        """Gets the notes of this ExpenseTransaction.

        Any private, company notes about the transaction.

        :return: The notes of this ExpenseTransaction.
        :rtype: str
        """
        return self._notes

    @notes.setter
    def notes(self, notes):
        """Sets the notes of this ExpenseTransaction.

        Any private, company notes about the transaction.

        :param notes: The notes of this ExpenseTransaction.
        :type notes: str
        """

        self._notes = notes

    @property
    def type(self):
        """Gets the type of this ExpenseTransaction.

        The type of transaction.

        :return: The type of this ExpenseTransaction.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this ExpenseTransaction.

        The type of transaction.

        :param type: The type of this ExpenseTransaction.
        :type type: str
        """
        allowed_values = ["Payment", "Refund", "Reward", "Chargeback", "TransferIn", "TransferOut", "AdjustmentIn", "AdjustmentOut"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"
                .format(type, allowed_values)
            )

        self._type = type
