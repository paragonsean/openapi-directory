/**
 * Codat Expense API
 * The API for Sync for Expenses. Sync for Expenses is an API and a set of supporting tools. It has been built to enable corporate card and expense management platforms to provide high-quality integrations with multiple accounting platforms through a standardized API.  [Read more...](https://docs.codat.io/sync-for-expenses/overview)  [See our OpenAPI spec](https://github.com/codatio/oas)
 *
 * The version of the OpenAPI document: prealpha
 * Contact: expenses@codat.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import DataConnectionError from './DataConnectionError';
import DataConnectionStatus from './DataConnectionStatus';

/**
 * The DataConnection model module.
 * @module model/DataConnection
 * @version prealpha
 */
class DataConnection {
    /**
     * Constructs a new <code>DataConnection</code>.
     * A connection represents the link between a &#x60;company&#x60; and a source of data.
     * @alias module:model/DataConnection
     * @param created {String} In Codat's data model, dates and times are represented using the <a class=\"external\" href=\"https://en.wikipedia.org/wiki/ISO_8601\" target=\"_blank\">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:  ``` 2020-10-08T22:40:50Z 2021-01-01T00:00:00 ```    When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z` - Unqualified local time: `2021-11-15T01:00:00` - UTC time offsets: `2021-11-15T01:00:00-05:00`  > Time zones >  > Not all dates from Codat will contain information about time zones.   > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     * @param id {String} Unique identifier for a company's data connection.
     * @param integrationId {String} A Codat ID representing the integration.
     * @param integrationKey {String} A unique four-character ID that identifies the platform of the company's data connection. This ensures continuity if the platform changes its name in the future.
     * @param linkUrl {String} 
     * @param platformName {String} 
     * @param sourceId {String} A source-specific ID used to distinguish between different sources originating from the same data connection. In general, a data connection is a single data source. However, for TrueLayer, `sourceId` is associated with a specific bank and has a many-to-one relationship with the `integrationId`.
     * @param sourceType {module:model/DataConnection.SourceTypeEnum} The type of platform of the connection.
     * @param status {module:model/DataConnectionStatus} 
     */
    constructor(created, id, integrationId, integrationKey, linkUrl, platformName, sourceId, sourceType, status) { 
        
        DataConnection.initialize(this, created, id, integrationId, integrationKey, linkUrl, platformName, sourceId, sourceType, status);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, created, id, integrationId, integrationKey, linkUrl, platformName, sourceId, sourceType, status) { 
        obj['created'] = created;
        obj['id'] = id;
        obj['integrationId'] = integrationId;
        obj['integrationKey'] = integrationKey;
        obj['linkUrl'] = linkUrl;
        obj['platformName'] = platformName;
        obj['sourceId'] = sourceId;
        obj['sourceType'] = sourceType;
        obj['status'] = status;
    }

    /**
     * Constructs a <code>DataConnection</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/DataConnection} obj Optional instance to populate.
     * @return {module:model/DataConnection} The populated <code>DataConnection</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new DataConnection();

            if (data.hasOwnProperty('additionalProperties')) {
                obj['additionalProperties'] = ApiClient.convertToType(data['additionalProperties'], Object);
            }
            if (data.hasOwnProperty('connectionInfo')) {
                obj['connectionInfo'] = ApiClient.convertToType(data['connectionInfo'], {'String': 'String'});
            }
            if (data.hasOwnProperty('created')) {
                obj['created'] = ApiClient.convertToType(data['created'], 'String');
            }
            if (data.hasOwnProperty('dataConnectionErrors')) {
                obj['dataConnectionErrors'] = ApiClient.convertToType(data['dataConnectionErrors'], [DataConnectionError]);
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('integrationId')) {
                obj['integrationId'] = ApiClient.convertToType(data['integrationId'], 'String');
            }
            if (data.hasOwnProperty('integrationKey')) {
                obj['integrationKey'] = ApiClient.convertToType(data['integrationKey'], 'String');
            }
            if (data.hasOwnProperty('lastSync')) {
                obj['lastSync'] = ApiClient.convertToType(data['lastSync'], 'String');
            }
            if (data.hasOwnProperty('linkUrl')) {
                obj['linkUrl'] = ApiClient.convertToType(data['linkUrl'], 'String');
            }
            if (data.hasOwnProperty('platformName')) {
                obj['platformName'] = ApiClient.convertToType(data['platformName'], 'String');
            }
            if (data.hasOwnProperty('sourceId')) {
                obj['sourceId'] = ApiClient.convertToType(data['sourceId'], 'String');
            }
            if (data.hasOwnProperty('sourceType')) {
                obj['sourceType'] = ApiClient.convertToType(data['sourceType'], 'String');
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = DataConnectionStatus.constructFromObject(data['status']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>DataConnection</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>DataConnection</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of DataConnection.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['created'] && !(typeof data['created'] === 'string' || data['created'] instanceof String)) {
            throw new Error("Expected the field `created` to be a primitive type in the JSON string but got " + data['created']);
        }
        if (data['dataConnectionErrors']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['dataConnectionErrors'])) {
                throw new Error("Expected the field `dataConnectionErrors` to be an array in the JSON data but got " + data['dataConnectionErrors']);
            }
            // validate the optional field `dataConnectionErrors` (array)
            for (const item of data['dataConnectionErrors']) {
                DataConnectionError.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['integrationId'] && !(typeof data['integrationId'] === 'string' || data['integrationId'] instanceof String)) {
            throw new Error("Expected the field `integrationId` to be a primitive type in the JSON string but got " + data['integrationId']);
        }
        // ensure the json data is a string
        if (data['integrationKey'] && !(typeof data['integrationKey'] === 'string' || data['integrationKey'] instanceof String)) {
            throw new Error("Expected the field `integrationKey` to be a primitive type in the JSON string but got " + data['integrationKey']);
        }
        // ensure the json data is a string
        if (data['lastSync'] && !(typeof data['lastSync'] === 'string' || data['lastSync'] instanceof String)) {
            throw new Error("Expected the field `lastSync` to be a primitive type in the JSON string but got " + data['lastSync']);
        }
        // ensure the json data is a string
        if (data['linkUrl'] && !(typeof data['linkUrl'] === 'string' || data['linkUrl'] instanceof String)) {
            throw new Error("Expected the field `linkUrl` to be a primitive type in the JSON string but got " + data['linkUrl']);
        }
        // ensure the json data is a string
        if (data['platformName'] && !(typeof data['platformName'] === 'string' || data['platformName'] instanceof String)) {
            throw new Error("Expected the field `platformName` to be a primitive type in the JSON string but got " + data['platformName']);
        }
        // ensure the json data is a string
        if (data['sourceId'] && !(typeof data['sourceId'] === 'string' || data['sourceId'] instanceof String)) {
            throw new Error("Expected the field `sourceId` to be a primitive type in the JSON string but got " + data['sourceId']);
        }
        // ensure the json data is a string
        if (data['sourceType'] && !(typeof data['sourceType'] === 'string' || data['sourceType'] instanceof String)) {
            throw new Error("Expected the field `sourceType` to be a primitive type in the JSON string but got " + data['sourceType']);
        }

        return true;
    }


}

DataConnection.RequiredProperties = ["created", "id", "integrationId", "integrationKey", "linkUrl", "platformName", "sourceId", "sourceType", "status"];

/**
 * @member {Object} additionalProperties
 */
DataConnection.prototype['additionalProperties'] = undefined;

/**
 * @member {Object.<String, String>} connectionInfo
 */
DataConnection.prototype['connectionInfo'] = undefined;

/**
 * In Codat's data model, dates and times are represented using the <a class=\"external\" href=\"https://en.wikipedia.org/wiki/ISO_8601\" target=\"_blank\">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:  ``` 2020-10-08T22:40:50Z 2021-01-01T00:00:00 ```    When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z` - Unqualified local time: `2021-11-15T01:00:00` - UTC time offsets: `2021-11-15T01:00:00-05:00`  > Time zones >  > Not all dates from Codat will contain information about time zones.   > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
 * @member {String} created
 */
DataConnection.prototype['created'] = undefined;

/**
 * @member {Array.<module:model/DataConnectionError>} dataConnectionErrors
 */
DataConnection.prototype['dataConnectionErrors'] = undefined;

/**
 * Unique identifier for a company's data connection.
 * @member {String} id
 */
DataConnection.prototype['id'] = undefined;

/**
 * A Codat ID representing the integration.
 * @member {String} integrationId
 */
DataConnection.prototype['integrationId'] = undefined;

/**
 * A unique four-character ID that identifies the platform of the company's data connection. This ensures continuity if the platform changes its name in the future.
 * @member {String} integrationKey
 */
DataConnection.prototype['integrationKey'] = undefined;

/**
 * In Codat's data model, dates and times are represented using the <a class=\"external\" href=\"https://en.wikipedia.org/wiki/ISO_8601\" target=\"_blank\">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:  ``` 2020-10-08T22:40:50Z 2021-01-01T00:00:00 ```    When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:  - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z` - Unqualified local time: `2021-11-15T01:00:00` - UTC time offsets: `2021-11-15T01:00:00-05:00`  > Time zones >  > Not all dates from Codat will contain information about time zones.   > Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
 * @member {String} lastSync
 */
DataConnection.prototype['lastSync'] = undefined;

/**
 * @member {String} linkUrl
 */
DataConnection.prototype['linkUrl'] = undefined;

/**
 * @member {String} platformName
 */
DataConnection.prototype['platformName'] = undefined;

/**
 * A source-specific ID used to distinguish between different sources originating from the same data connection. In general, a data connection is a single data source. However, for TrueLayer, `sourceId` is associated with a specific bank and has a many-to-one relationship with the `integrationId`.
 * @member {String} sourceId
 */
DataConnection.prototype['sourceId'] = undefined;

/**
 * The type of platform of the connection.
 * @member {module:model/DataConnection.SourceTypeEnum} sourceType
 */
DataConnection.prototype['sourceType'] = undefined;

/**
 * @member {module:model/DataConnectionStatus} status
 */
DataConnection.prototype['status'] = undefined;





/**
 * Allowed values for the <code>sourceType</code> property.
 * @enum {String}
 * @readonly
 */
DataConnection['SourceTypeEnum'] = {

    /**
     * value: "Accounting"
     * @const
     */
    "Accounting": "Accounting",

    /**
     * value: "Banking"
     * @const
     */
    "Banking": "Banking",

    /**
     * value: "Commerce"
     * @const
     */
    "Commerce": "Commerce",

    /**
     * value: "Other"
     * @const
     */
    "Other": "Other",

    /**
     * value: "Unknown"
     * @const
     */
    "Unknown": "Unknown"
};



export default DataConnection;

