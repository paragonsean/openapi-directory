/**
 * Wordnik
 * Wordnik is the worlds biggest online English dictionary, by number of words
 *
 * The version of the OpenAPI document: 4.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIScoredWord.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIScoredWord::OAIScoredWord(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIScoredWord::OAIScoredWord() {
    this->initializeModel();
}

OAIScoredWord::~OAIScoredWord() {}

void OAIScoredWord::initializeModel() {

    m_base_word_score_isSet = false;
    m_base_word_score_isValid = false;

    m_doc_term_count_isSet = false;
    m_doc_term_count_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_lemma_isSet = false;
    m_lemma_isValid = false;

    m_part_of_speech_isSet = false;
    m_part_of_speech_isValid = false;

    m_position_isSet = false;
    m_position_isValid = false;

    m_score_isSet = false;
    m_score_isValid = false;

    m_sentence_id_isSet = false;
    m_sentence_id_isValid = false;

    m_stopword_isSet = false;
    m_stopword_isValid = false;

    m_word_isSet = false;
    m_word_isValid = false;

    m_word_type_isSet = false;
    m_word_type_isValid = false;
}

void OAIScoredWord::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIScoredWord::fromJsonObject(QJsonObject json) {

    m_base_word_score_isValid = ::OpenAPI::fromJsonValue(m_base_word_score, json[QString("baseWordScore")]);
    m_base_word_score_isSet = !json[QString("baseWordScore")].isNull() && m_base_word_score_isValid;

    m_doc_term_count_isValid = ::OpenAPI::fromJsonValue(m_doc_term_count, json[QString("docTermCount")]);
    m_doc_term_count_isSet = !json[QString("docTermCount")].isNull() && m_doc_term_count_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_lemma_isValid = ::OpenAPI::fromJsonValue(m_lemma, json[QString("lemma")]);
    m_lemma_isSet = !json[QString("lemma")].isNull() && m_lemma_isValid;

    m_part_of_speech_isValid = ::OpenAPI::fromJsonValue(m_part_of_speech, json[QString("partOfSpeech")]);
    m_part_of_speech_isSet = !json[QString("partOfSpeech")].isNull() && m_part_of_speech_isValid;

    m_position_isValid = ::OpenAPI::fromJsonValue(m_position, json[QString("position")]);
    m_position_isSet = !json[QString("position")].isNull() && m_position_isValid;

    m_score_isValid = ::OpenAPI::fromJsonValue(m_score, json[QString("score")]);
    m_score_isSet = !json[QString("score")].isNull() && m_score_isValid;

    m_sentence_id_isValid = ::OpenAPI::fromJsonValue(m_sentence_id, json[QString("sentenceId")]);
    m_sentence_id_isSet = !json[QString("sentenceId")].isNull() && m_sentence_id_isValid;

    m_stopword_isValid = ::OpenAPI::fromJsonValue(m_stopword, json[QString("stopword")]);
    m_stopword_isSet = !json[QString("stopword")].isNull() && m_stopword_isValid;

    m_word_isValid = ::OpenAPI::fromJsonValue(m_word, json[QString("word")]);
    m_word_isSet = !json[QString("word")].isNull() && m_word_isValid;

    m_word_type_isValid = ::OpenAPI::fromJsonValue(m_word_type, json[QString("wordType")]);
    m_word_type_isSet = !json[QString("wordType")].isNull() && m_word_type_isValid;
}

QString OAIScoredWord::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIScoredWord::asJsonObject() const {
    QJsonObject obj;
    if (m_base_word_score_isSet) {
        obj.insert(QString("baseWordScore"), ::OpenAPI::toJsonValue(m_base_word_score));
    }
    if (m_doc_term_count_isSet) {
        obj.insert(QString("docTermCount"), ::OpenAPI::toJsonValue(m_doc_term_count));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_lemma_isSet) {
        obj.insert(QString("lemma"), ::OpenAPI::toJsonValue(m_lemma));
    }
    if (m_part_of_speech_isSet) {
        obj.insert(QString("partOfSpeech"), ::OpenAPI::toJsonValue(m_part_of_speech));
    }
    if (m_position_isSet) {
        obj.insert(QString("position"), ::OpenAPI::toJsonValue(m_position));
    }
    if (m_score_isSet) {
        obj.insert(QString("score"), ::OpenAPI::toJsonValue(m_score));
    }
    if (m_sentence_id_isSet) {
        obj.insert(QString("sentenceId"), ::OpenAPI::toJsonValue(m_sentence_id));
    }
    if (m_stopword_isSet) {
        obj.insert(QString("stopword"), ::OpenAPI::toJsonValue(m_stopword));
    }
    if (m_word_isSet) {
        obj.insert(QString("word"), ::OpenAPI::toJsonValue(m_word));
    }
    if (m_word_type_isSet) {
        obj.insert(QString("wordType"), ::OpenAPI::toJsonValue(m_word_type));
    }
    return obj;
}

double OAIScoredWord::getBaseWordScore() const {
    return m_base_word_score;
}
void OAIScoredWord::setBaseWordScore(const double &base_word_score) {
    m_base_word_score = base_word_score;
    m_base_word_score_isSet = true;
}

bool OAIScoredWord::is_base_word_score_Set() const{
    return m_base_word_score_isSet;
}

bool OAIScoredWord::is_base_word_score_Valid() const{
    return m_base_word_score_isValid;
}

qint32 OAIScoredWord::getDocTermCount() const {
    return m_doc_term_count;
}
void OAIScoredWord::setDocTermCount(const qint32 &doc_term_count) {
    m_doc_term_count = doc_term_count;
    m_doc_term_count_isSet = true;
}

bool OAIScoredWord::is_doc_term_count_Set() const{
    return m_doc_term_count_isSet;
}

bool OAIScoredWord::is_doc_term_count_Valid() const{
    return m_doc_term_count_isValid;
}

qint64 OAIScoredWord::getId() const {
    return m_id;
}
void OAIScoredWord::setId(const qint64 &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIScoredWord::is_id_Set() const{
    return m_id_isSet;
}

bool OAIScoredWord::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIScoredWord::getLemma() const {
    return m_lemma;
}
void OAIScoredWord::setLemma(const QString &lemma) {
    m_lemma = lemma;
    m_lemma_isSet = true;
}

bool OAIScoredWord::is_lemma_Set() const{
    return m_lemma_isSet;
}

bool OAIScoredWord::is_lemma_Valid() const{
    return m_lemma_isValid;
}

QString OAIScoredWord::getPartOfSpeech() const {
    return m_part_of_speech;
}
void OAIScoredWord::setPartOfSpeech(const QString &part_of_speech) {
    m_part_of_speech = part_of_speech;
    m_part_of_speech_isSet = true;
}

bool OAIScoredWord::is_part_of_speech_Set() const{
    return m_part_of_speech_isSet;
}

bool OAIScoredWord::is_part_of_speech_Valid() const{
    return m_part_of_speech_isValid;
}

qint32 OAIScoredWord::getPosition() const {
    return m_position;
}
void OAIScoredWord::setPosition(const qint32 &position) {
    m_position = position;
    m_position_isSet = true;
}

bool OAIScoredWord::is_position_Set() const{
    return m_position_isSet;
}

bool OAIScoredWord::is_position_Valid() const{
    return m_position_isValid;
}

float OAIScoredWord::getScore() const {
    return m_score;
}
void OAIScoredWord::setScore(const float &score) {
    m_score = score;
    m_score_isSet = true;
}

bool OAIScoredWord::is_score_Set() const{
    return m_score_isSet;
}

bool OAIScoredWord::is_score_Valid() const{
    return m_score_isValid;
}

qint64 OAIScoredWord::getSentenceId() const {
    return m_sentence_id;
}
void OAIScoredWord::setSentenceId(const qint64 &sentence_id) {
    m_sentence_id = sentence_id;
    m_sentence_id_isSet = true;
}

bool OAIScoredWord::is_sentence_id_Set() const{
    return m_sentence_id_isSet;
}

bool OAIScoredWord::is_sentence_id_Valid() const{
    return m_sentence_id_isValid;
}

bool OAIScoredWord::isStopword() const {
    return m_stopword;
}
void OAIScoredWord::setStopword(const bool &stopword) {
    m_stopword = stopword;
    m_stopword_isSet = true;
}

bool OAIScoredWord::is_stopword_Set() const{
    return m_stopword_isSet;
}

bool OAIScoredWord::is_stopword_Valid() const{
    return m_stopword_isValid;
}

QString OAIScoredWord::getWord() const {
    return m_word;
}
void OAIScoredWord::setWord(const QString &word) {
    m_word = word;
    m_word_isSet = true;
}

bool OAIScoredWord::is_word_Set() const{
    return m_word_isSet;
}

bool OAIScoredWord::is_word_Valid() const{
    return m_word_isValid;
}

QString OAIScoredWord::getWordType() const {
    return m_word_type;
}
void OAIScoredWord::setWordType(const QString &word_type) {
    m_word_type = word_type;
    m_word_type_isSet = true;
}

bool OAIScoredWord::is_word_type_Set() const{
    return m_word_type_isSet;
}

bool OAIScoredWord::is_word_type_Valid() const{
    return m_word_type_isValid;
}

bool OAIScoredWord::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_base_word_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_doc_term_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lemma_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_part_of_speech_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_position_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sentence_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stopword_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_word_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_word_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIScoredWord::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
