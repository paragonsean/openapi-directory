/**
 * Wordnik
 * Wordnik is the worlds biggest online English dictionary, by number of words
 *
 * The version of the OpenAPI document: 4.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRelated.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRelated::OAIRelated(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRelated::OAIRelated() {
    this->initializeModel();
}

OAIRelated::~OAIRelated() {}

void OAIRelated::initializeModel() {

    m_gram_isSet = false;
    m_gram_isValid = false;

    m_label1_isSet = false;
    m_label1_isValid = false;

    m_label2_isSet = false;
    m_label2_isValid = false;

    m_label3_isSet = false;
    m_label3_isValid = false;

    m_label4_isSet = false;
    m_label4_isValid = false;

    m_relationship_type_isSet = false;
    m_relationship_type_isValid = false;

    m_words_isSet = false;
    m_words_isValid = false;
}

void OAIRelated::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRelated::fromJsonObject(QJsonObject json) {

    m_gram_isValid = ::OpenAPI::fromJsonValue(m_gram, json[QString("gram")]);
    m_gram_isSet = !json[QString("gram")].isNull() && m_gram_isValid;

    m_label1_isValid = ::OpenAPI::fromJsonValue(m_label1, json[QString("label1")]);
    m_label1_isSet = !json[QString("label1")].isNull() && m_label1_isValid;

    m_label2_isValid = ::OpenAPI::fromJsonValue(m_label2, json[QString("label2")]);
    m_label2_isSet = !json[QString("label2")].isNull() && m_label2_isValid;

    m_label3_isValid = ::OpenAPI::fromJsonValue(m_label3, json[QString("label3")]);
    m_label3_isSet = !json[QString("label3")].isNull() && m_label3_isValid;

    m_label4_isValid = ::OpenAPI::fromJsonValue(m_label4, json[QString("label4")]);
    m_label4_isSet = !json[QString("label4")].isNull() && m_label4_isValid;

    m_relationship_type_isValid = ::OpenAPI::fromJsonValue(m_relationship_type, json[QString("relationshipType")]);
    m_relationship_type_isSet = !json[QString("relationshipType")].isNull() && m_relationship_type_isValid;

    m_words_isValid = ::OpenAPI::fromJsonValue(m_words, json[QString("words")]);
    m_words_isSet = !json[QString("words")].isNull() && m_words_isValid;
}

QString OAIRelated::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRelated::asJsonObject() const {
    QJsonObject obj;
    if (m_gram_isSet) {
        obj.insert(QString("gram"), ::OpenAPI::toJsonValue(m_gram));
    }
    if (m_label1_isSet) {
        obj.insert(QString("label1"), ::OpenAPI::toJsonValue(m_label1));
    }
    if (m_label2_isSet) {
        obj.insert(QString("label2"), ::OpenAPI::toJsonValue(m_label2));
    }
    if (m_label3_isSet) {
        obj.insert(QString("label3"), ::OpenAPI::toJsonValue(m_label3));
    }
    if (m_label4_isSet) {
        obj.insert(QString("label4"), ::OpenAPI::toJsonValue(m_label4));
    }
    if (m_relationship_type_isSet) {
        obj.insert(QString("relationshipType"), ::OpenAPI::toJsonValue(m_relationship_type));
    }
    if (m_words.size() > 0) {
        obj.insert(QString("words"), ::OpenAPI::toJsonValue(m_words));
    }
    return obj;
}

QString OAIRelated::getGram() const {
    return m_gram;
}
void OAIRelated::setGram(const QString &gram) {
    m_gram = gram;
    m_gram_isSet = true;
}

bool OAIRelated::is_gram_Set() const{
    return m_gram_isSet;
}

bool OAIRelated::is_gram_Valid() const{
    return m_gram_isValid;
}

QString OAIRelated::getLabel1() const {
    return m_label1;
}
void OAIRelated::setLabel1(const QString &label1) {
    m_label1 = label1;
    m_label1_isSet = true;
}

bool OAIRelated::is_label1_Set() const{
    return m_label1_isSet;
}

bool OAIRelated::is_label1_Valid() const{
    return m_label1_isValid;
}

QString OAIRelated::getLabel2() const {
    return m_label2;
}
void OAIRelated::setLabel2(const QString &label2) {
    m_label2 = label2;
    m_label2_isSet = true;
}

bool OAIRelated::is_label2_Set() const{
    return m_label2_isSet;
}

bool OAIRelated::is_label2_Valid() const{
    return m_label2_isValid;
}

QString OAIRelated::getLabel3() const {
    return m_label3;
}
void OAIRelated::setLabel3(const QString &label3) {
    m_label3 = label3;
    m_label3_isSet = true;
}

bool OAIRelated::is_label3_Set() const{
    return m_label3_isSet;
}

bool OAIRelated::is_label3_Valid() const{
    return m_label3_isValid;
}

QString OAIRelated::getLabel4() const {
    return m_label4;
}
void OAIRelated::setLabel4(const QString &label4) {
    m_label4 = label4;
    m_label4_isSet = true;
}

bool OAIRelated::is_label4_Set() const{
    return m_label4_isSet;
}

bool OAIRelated::is_label4_Valid() const{
    return m_label4_isValid;
}

QString OAIRelated::getRelationshipType() const {
    return m_relationship_type;
}
void OAIRelated::setRelationshipType(const QString &relationship_type) {
    m_relationship_type = relationship_type;
    m_relationship_type_isSet = true;
}

bool OAIRelated::is_relationship_type_Set() const{
    return m_relationship_type_isSet;
}

bool OAIRelated::is_relationship_type_Valid() const{
    return m_relationship_type_isValid;
}

QList<QString> OAIRelated::getWords() const {
    return m_words;
}
void OAIRelated::setWords(const QList<QString> &words) {
    m_words = words;
    m_words_isSet = true;
}

bool OAIRelated::is_words_Set() const{
    return m_words_isSet;
}

bool OAIRelated::is_words_Valid() const{
    return m_words_isValid;
}

bool OAIRelated::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_gram_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_label1_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_label2_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_label3_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_label4_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_relationship_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_words.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRelated::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
