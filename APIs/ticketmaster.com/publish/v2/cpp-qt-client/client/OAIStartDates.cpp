/**
 * ticketmaster publish api
 * Publish API
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIStartDates.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIStartDates::OAIStartDates(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIStartDates::OAIStartDates() {
    this->initializeModel();
}

OAIStartDates::~OAIStartDates() {}

void OAIStartDates::initializeModel() {

    m_date_tba_isSet = false;
    m_date_tba_isValid = false;

    m_date_tbd_isSet = false;
    m_date_tbd_isValid = false;

    m_date_time_isSet = false;
    m_date_time_isValid = false;

    m_local_date_isSet = false;
    m_local_date_isValid = false;

    m_local_time_isSet = false;
    m_local_time_isValid = false;

    m_no_specific_time_isSet = false;
    m_no_specific_time_isValid = false;

    m_time_tba_isSet = false;
    m_time_tba_isValid = false;
}

void OAIStartDates::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIStartDates::fromJsonObject(QJsonObject json) {

    m_date_tba_isValid = ::OpenAPI::fromJsonValue(m_date_tba, json[QString("dateTBA")]);
    m_date_tba_isSet = !json[QString("dateTBA")].isNull() && m_date_tba_isValid;

    m_date_tbd_isValid = ::OpenAPI::fromJsonValue(m_date_tbd, json[QString("dateTBD")]);
    m_date_tbd_isSet = !json[QString("dateTBD")].isNull() && m_date_tbd_isValid;

    m_date_time_isValid = ::OpenAPI::fromJsonValue(m_date_time, json[QString("dateTime")]);
    m_date_time_isSet = !json[QString("dateTime")].isNull() && m_date_time_isValid;

    m_local_date_isValid = ::OpenAPI::fromJsonValue(m_local_date, json[QString("localDate")]);
    m_local_date_isSet = !json[QString("localDate")].isNull() && m_local_date_isValid;

    m_local_time_isValid = ::OpenAPI::fromJsonValue(m_local_time, json[QString("localTime")]);
    m_local_time_isSet = !json[QString("localTime")].isNull() && m_local_time_isValid;

    m_no_specific_time_isValid = ::OpenAPI::fromJsonValue(m_no_specific_time, json[QString("noSpecificTime")]);
    m_no_specific_time_isSet = !json[QString("noSpecificTime")].isNull() && m_no_specific_time_isValid;

    m_time_tba_isValid = ::OpenAPI::fromJsonValue(m_time_tba, json[QString("timeTBA")]);
    m_time_tba_isSet = !json[QString("timeTBA")].isNull() && m_time_tba_isValid;
}

QString OAIStartDates::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIStartDates::asJsonObject() const {
    QJsonObject obj;
    if (m_date_tba_isSet) {
        obj.insert(QString("dateTBA"), ::OpenAPI::toJsonValue(m_date_tba));
    }
    if (m_date_tbd_isSet) {
        obj.insert(QString("dateTBD"), ::OpenAPI::toJsonValue(m_date_tbd));
    }
    if (m_date_time_isSet) {
        obj.insert(QString("dateTime"), ::OpenAPI::toJsonValue(m_date_time));
    }
    if (m_local_date_isSet) {
        obj.insert(QString("localDate"), ::OpenAPI::toJsonValue(m_local_date));
    }
    if (m_local_time.isSet()) {
        obj.insert(QString("localTime"), ::OpenAPI::toJsonValue(m_local_time));
    }
    if (m_no_specific_time_isSet) {
        obj.insert(QString("noSpecificTime"), ::OpenAPI::toJsonValue(m_no_specific_time));
    }
    if (m_time_tba_isSet) {
        obj.insert(QString("timeTBA"), ::OpenAPI::toJsonValue(m_time_tba));
    }
    return obj;
}

bool OAIStartDates::isDateTba() const {
    return m_date_tba;
}
void OAIStartDates::setDateTba(const bool &date_tba) {
    m_date_tba = date_tba;
    m_date_tba_isSet = true;
}

bool OAIStartDates::is_date_tba_Set() const{
    return m_date_tba_isSet;
}

bool OAIStartDates::is_date_tba_Valid() const{
    return m_date_tba_isValid;
}

bool OAIStartDates::isDateTbd() const {
    return m_date_tbd;
}
void OAIStartDates::setDateTbd(const bool &date_tbd) {
    m_date_tbd = date_tbd;
    m_date_tbd_isSet = true;
}

bool OAIStartDates::is_date_tbd_Set() const{
    return m_date_tbd_isSet;
}

bool OAIStartDates::is_date_tbd_Valid() const{
    return m_date_tbd_isValid;
}

QDateTime OAIStartDates::getDateTime() const {
    return m_date_time;
}
void OAIStartDates::setDateTime(const QDateTime &date_time) {
    m_date_time = date_time;
    m_date_time_isSet = true;
}

bool OAIStartDates::is_date_time_Set() const{
    return m_date_time_isSet;
}

bool OAIStartDates::is_date_time_Valid() const{
    return m_date_time_isValid;
}

QDate OAIStartDates::getLocalDate() const {
    return m_local_date;
}
void OAIStartDates::setLocalDate(const QDate &local_date) {
    m_local_date = local_date;
    m_local_date_isSet = true;
}

bool OAIStartDates::is_local_date_Set() const{
    return m_local_date_isSet;
}

bool OAIStartDates::is_local_date_Valid() const{
    return m_local_date_isValid;
}

OAILocalTime OAIStartDates::getLocalTime() const {
    return m_local_time;
}
void OAIStartDates::setLocalTime(const OAILocalTime &local_time) {
    m_local_time = local_time;
    m_local_time_isSet = true;
}

bool OAIStartDates::is_local_time_Set() const{
    return m_local_time_isSet;
}

bool OAIStartDates::is_local_time_Valid() const{
    return m_local_time_isValid;
}

bool OAIStartDates::isNoSpecificTime() const {
    return m_no_specific_time;
}
void OAIStartDates::setNoSpecificTime(const bool &no_specific_time) {
    m_no_specific_time = no_specific_time;
    m_no_specific_time_isSet = true;
}

bool OAIStartDates::is_no_specific_time_Set() const{
    return m_no_specific_time_isSet;
}

bool OAIStartDates::is_no_specific_time_Valid() const{
    return m_no_specific_time_isValid;
}

bool OAIStartDates::isTimeTba() const {
    return m_time_tba;
}
void OAIStartDates::setTimeTba(const bool &time_tba) {
    m_time_tba = time_tba;
    m_time_tba_isSet = true;
}

bool OAIStartDates::is_time_tba_Set() const{
    return m_time_tba_isSet;
}

bool OAIStartDates::is_time_tba_Valid() const{
    return m_time_tba_isValid;
}

bool OAIStartDates::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_date_tba_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_tbd_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_local_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_local_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_no_specific_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_tba_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIStartDates::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
