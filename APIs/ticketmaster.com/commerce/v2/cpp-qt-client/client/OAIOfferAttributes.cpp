/**
 * Commerce API
 * Use the Ticketmaster Commerce API to look up available offers and products on various Ticketmaster platforms for North America markets. For formal partnerships and relationships, selected offers and products can be carted and transacted on through the cart, delivery, payment and purchase APIs â€“ These APIs require approved access from Ticketmaster.
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIOfferAttributes.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIOfferAttributes::OAIOfferAttributes(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIOfferAttributes::OAIOfferAttributes() {
    this->initializeModel();
}

OAIOfferAttributes::~OAIOfferAttributes() {}

void OAIOfferAttributes::initializeModel() {

    m_currency_isSet = false;
    m_currency_isValid = false;

    m_description_isSet = false;
    m_description_isValid = false;

    m_end_isSet = false;
    m_end_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_offer_details_isSet = false;
    m_offer_details_isValid = false;

    m_offer_type_isSet = false;
    m_offer_type_isValid = false;

    m_prices_isSet = false;
    m_prices_isValid = false;

    m_rank_isSet = false;
    m_rank_isValid = false;

    m_start_isSet = false;
    m_start_isValid = false;
}

void OAIOfferAttributes::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIOfferAttributes::fromJsonObject(QJsonObject json) {

    m_currency_isValid = ::OpenAPI::fromJsonValue(m_currency, json[QString("currency")]);
    m_currency_isSet = !json[QString("currency")].isNull() && m_currency_isValid;

    m_description_isValid = ::OpenAPI::fromJsonValue(m_description, json[QString("description")]);
    m_description_isSet = !json[QString("description")].isNull() && m_description_isValid;

    m_end_isValid = ::OpenAPI::fromJsonValue(m_end, json[QString("end")]);
    m_end_isSet = !json[QString("end")].isNull() && m_end_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_offer_details_isValid = ::OpenAPI::fromJsonValue(m_offer_details, json[QString("offerDetails")]);
    m_offer_details_isSet = !json[QString("offerDetails")].isNull() && m_offer_details_isValid;

    m_offer_type_isValid = ::OpenAPI::fromJsonValue(m_offer_type, json[QString("offerType")]);
    m_offer_type_isSet = !json[QString("offerType")].isNull() && m_offer_type_isValid;

    m_prices_isValid = ::OpenAPI::fromJsonValue(m_prices, json[QString("prices")]);
    m_prices_isSet = !json[QString("prices")].isNull() && m_prices_isValid;

    m_rank_isValid = ::OpenAPI::fromJsonValue(m_rank, json[QString("rank")]);
    m_rank_isSet = !json[QString("rank")].isNull() && m_rank_isValid;

    m_start_isValid = ::OpenAPI::fromJsonValue(m_start, json[QString("start")]);
    m_start_isSet = !json[QString("start")].isNull() && m_start_isValid;
}

QString OAIOfferAttributes::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIOfferAttributes::asJsonObject() const {
    QJsonObject obj;
    if (m_currency_isSet) {
        obj.insert(QString("currency"), ::OpenAPI::toJsonValue(m_currency));
    }
    if (m_description_isSet) {
        obj.insert(QString("description"), ::OpenAPI::toJsonValue(m_description));
    }
    if (m_end_isSet) {
        obj.insert(QString("end"), ::OpenAPI::toJsonValue(m_end));
    }
    if (m_limit.isSet()) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_offer_details.isSet()) {
        obj.insert(QString("offerDetails"), ::OpenAPI::toJsonValue(m_offer_details));
    }
    if (m_offer_type_isSet) {
        obj.insert(QString("offerType"), ::OpenAPI::toJsonValue(m_offer_type));
    }
    if (m_prices.size() > 0) {
        obj.insert(QString("prices"), ::OpenAPI::toJsonValue(m_prices));
    }
    if (m_rank_isSet) {
        obj.insert(QString("rank"), ::OpenAPI::toJsonValue(m_rank));
    }
    if (m_start_isSet) {
        obj.insert(QString("start"), ::OpenAPI::toJsonValue(m_start));
    }
    return obj;
}

QString OAIOfferAttributes::getCurrency() const {
    return m_currency;
}
void OAIOfferAttributes::setCurrency(const QString &currency) {
    m_currency = currency;
    m_currency_isSet = true;
}

bool OAIOfferAttributes::is_currency_Set() const{
    return m_currency_isSet;
}

bool OAIOfferAttributes::is_currency_Valid() const{
    return m_currency_isValid;
}

QString OAIOfferAttributes::getDescription() const {
    return m_description;
}
void OAIOfferAttributes::setDescription(const QString &description) {
    m_description = description;
    m_description_isSet = true;
}

bool OAIOfferAttributes::is_description_Set() const{
    return m_description_isSet;
}

bool OAIOfferAttributes::is_description_Valid() const{
    return m_description_isValid;
}

QDateTime OAIOfferAttributes::getEnd() const {
    return m_end;
}
void OAIOfferAttributes::setEnd(const QDateTime &end) {
    m_end = end;
    m_end_isSet = true;
}

bool OAIOfferAttributes::is_end_Set() const{
    return m_end_isSet;
}

bool OAIOfferAttributes::is_end_Valid() const{
    return m_end_isValid;
}

OAILimit OAIOfferAttributes::getLimit() const {
    return m_limit;
}
void OAIOfferAttributes::setLimit(const OAILimit &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIOfferAttributes::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIOfferAttributes::is_limit_Valid() const{
    return m_limit_isValid;
}

QString OAIOfferAttributes::getName() const {
    return m_name;
}
void OAIOfferAttributes::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIOfferAttributes::is_name_Set() const{
    return m_name_isSet;
}

bool OAIOfferAttributes::is_name_Valid() const{
    return m_name_isValid;
}

OAIOfferDetails OAIOfferAttributes::getOfferDetails() const {
    return m_offer_details;
}
void OAIOfferAttributes::setOfferDetails(const OAIOfferDetails &offer_details) {
    m_offer_details = offer_details;
    m_offer_details_isSet = true;
}

bool OAIOfferAttributes::is_offer_details_Set() const{
    return m_offer_details_isSet;
}

bool OAIOfferAttributes::is_offer_details_Valid() const{
    return m_offer_details_isValid;
}

QString OAIOfferAttributes::getOfferType() const {
    return m_offer_type;
}
void OAIOfferAttributes::setOfferType(const QString &offer_type) {
    m_offer_type = offer_type;
    m_offer_type_isSet = true;
}

bool OAIOfferAttributes::is_offer_type_Set() const{
    return m_offer_type_isSet;
}

bool OAIOfferAttributes::is_offer_type_Valid() const{
    return m_offer_type_isValid;
}

QList<OAIOfferPrice> OAIOfferAttributes::getPrices() const {
    return m_prices;
}
void OAIOfferAttributes::setPrices(const QList<OAIOfferPrice> &prices) {
    m_prices = prices;
    m_prices_isSet = true;
}

bool OAIOfferAttributes::is_prices_Set() const{
    return m_prices_isSet;
}

bool OAIOfferAttributes::is_prices_Valid() const{
    return m_prices_isValid;
}

qint32 OAIOfferAttributes::getRank() const {
    return m_rank;
}
void OAIOfferAttributes::setRank(const qint32 &rank) {
    m_rank = rank;
    m_rank_isSet = true;
}

bool OAIOfferAttributes::is_rank_Set() const{
    return m_rank_isSet;
}

bool OAIOfferAttributes::is_rank_Valid() const{
    return m_rank_isValid;
}

QDateTime OAIOfferAttributes::getStart() const {
    return m_start;
}
void OAIOfferAttributes::setStart(const QDateTime &start) {
    m_start = start;
    m_start_isSet = true;
}

bool OAIOfferAttributes::is_start_Set() const{
    return m_start_isSet;
}

bool OAIOfferAttributes::is_start_Valid() const{
    return m_start_isValid;
}

bool OAIOfferAttributes::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_currency_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_offer_details.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_offer_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_prices.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_rank_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIOfferAttributes::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
