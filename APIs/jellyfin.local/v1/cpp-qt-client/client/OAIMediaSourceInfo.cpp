/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMediaSourceInfo.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMediaSourceInfo::OAIMediaSourceInfo(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMediaSourceInfo::OAIMediaSourceInfo() {
    this->initializeModel();
}

OAIMediaSourceInfo::~OAIMediaSourceInfo() {}

void OAIMediaSourceInfo::initializeModel() {

    m_analyze_duration_ms_isSet = false;
    m_analyze_duration_ms_isValid = false;

    m_bitrate_isSet = false;
    m_bitrate_isValid = false;

    m_buffer_ms_isSet = false;
    m_buffer_ms_isValid = false;

    m_container_isSet = false;
    m_container_isValid = false;

    m_default_audio_stream_index_isSet = false;
    m_default_audio_stream_index_isValid = false;

    m_default_subtitle_stream_index_isSet = false;
    m_default_subtitle_stream_index_isValid = false;

    m_e_tag_isSet = false;
    m_e_tag_isValid = false;

    m_encoder_path_isSet = false;
    m_encoder_path_isValid = false;

    m_encoder_protocol_isSet = false;
    m_encoder_protocol_isValid = false;

    m_formats_isSet = false;
    m_formats_isValid = false;

    m_gen_pts_input_isSet = false;
    m_gen_pts_input_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_ignore_dts_isSet = false;
    m_ignore_dts_isValid = false;

    m_ignore_index_isSet = false;
    m_ignore_index_isValid = false;

    m_is_infinite_stream_isSet = false;
    m_is_infinite_stream_isValid = false;

    m_is_remote_isSet = false;
    m_is_remote_isValid = false;

    m_iso_type_isSet = false;
    m_iso_type_isValid = false;

    m_live_stream_id_isSet = false;
    m_live_stream_id_isValid = false;

    m_media_attachments_isSet = false;
    m_media_attachments_isValid = false;

    m_media_streams_isSet = false;
    m_media_streams_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_open_token_isSet = false;
    m_open_token_isValid = false;

    m_path_isSet = false;
    m_path_isValid = false;

    m_protocol_isSet = false;
    m_protocol_isValid = false;

    m_read_at_native_framerate_isSet = false;
    m_read_at_native_framerate_isValid = false;

    m_required_http_headers_isSet = false;
    m_required_http_headers_isValid = false;

    m_requires_closing_isSet = false;
    m_requires_closing_isValid = false;

    m_requires_looping_isSet = false;
    m_requires_looping_isValid = false;

    m_requires_opening_isSet = false;
    m_requires_opening_isValid = false;

    m_run_time_ticks_isSet = false;
    m_run_time_ticks_isValid = false;

    m_size_isSet = false;
    m_size_isValid = false;

    m_supports_direct_play_isSet = false;
    m_supports_direct_play_isValid = false;

    m_supports_direct_stream_isSet = false;
    m_supports_direct_stream_isValid = false;

    m_supports_probing_isSet = false;
    m_supports_probing_isValid = false;

    m_supports_transcoding_isSet = false;
    m_supports_transcoding_isValid = false;

    m_timestamp_isSet = false;
    m_timestamp_isValid = false;

    m_transcoding_container_isSet = false;
    m_transcoding_container_isValid = false;

    m_transcoding_sub_protocol_isSet = false;
    m_transcoding_sub_protocol_isValid = false;

    m_transcoding_url_isSet = false;
    m_transcoding_url_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_video3_d_format_isSet = false;
    m_video3_d_format_isValid = false;

    m_video_type_isSet = false;
    m_video_type_isValid = false;
}

void OAIMediaSourceInfo::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMediaSourceInfo::fromJsonObject(QJsonObject json) {

    m_analyze_duration_ms_isValid = ::OpenAPI::fromJsonValue(m_analyze_duration_ms, json[QString("AnalyzeDurationMs")]);
    m_analyze_duration_ms_isSet = !json[QString("AnalyzeDurationMs")].isNull() && m_analyze_duration_ms_isValid;

    m_bitrate_isValid = ::OpenAPI::fromJsonValue(m_bitrate, json[QString("Bitrate")]);
    m_bitrate_isSet = !json[QString("Bitrate")].isNull() && m_bitrate_isValid;

    m_buffer_ms_isValid = ::OpenAPI::fromJsonValue(m_buffer_ms, json[QString("BufferMs")]);
    m_buffer_ms_isSet = !json[QString("BufferMs")].isNull() && m_buffer_ms_isValid;

    m_container_isValid = ::OpenAPI::fromJsonValue(m_container, json[QString("Container")]);
    m_container_isSet = !json[QString("Container")].isNull() && m_container_isValid;

    m_default_audio_stream_index_isValid = ::OpenAPI::fromJsonValue(m_default_audio_stream_index, json[QString("DefaultAudioStreamIndex")]);
    m_default_audio_stream_index_isSet = !json[QString("DefaultAudioStreamIndex")].isNull() && m_default_audio_stream_index_isValid;

    m_default_subtitle_stream_index_isValid = ::OpenAPI::fromJsonValue(m_default_subtitle_stream_index, json[QString("DefaultSubtitleStreamIndex")]);
    m_default_subtitle_stream_index_isSet = !json[QString("DefaultSubtitleStreamIndex")].isNull() && m_default_subtitle_stream_index_isValid;

    m_e_tag_isValid = ::OpenAPI::fromJsonValue(m_e_tag, json[QString("ETag")]);
    m_e_tag_isSet = !json[QString("ETag")].isNull() && m_e_tag_isValid;

    m_encoder_path_isValid = ::OpenAPI::fromJsonValue(m_encoder_path, json[QString("EncoderPath")]);
    m_encoder_path_isSet = !json[QString("EncoderPath")].isNull() && m_encoder_path_isValid;

    m_encoder_protocol_isValid = ::OpenAPI::fromJsonValue(m_encoder_protocol, json[QString("EncoderProtocol")]);
    m_encoder_protocol_isSet = !json[QString("EncoderProtocol")].isNull() && m_encoder_protocol_isValid;

    m_formats_isValid = ::OpenAPI::fromJsonValue(m_formats, json[QString("Formats")]);
    m_formats_isSet = !json[QString("Formats")].isNull() && m_formats_isValid;

    m_gen_pts_input_isValid = ::OpenAPI::fromJsonValue(m_gen_pts_input, json[QString("GenPtsInput")]);
    m_gen_pts_input_isSet = !json[QString("GenPtsInput")].isNull() && m_gen_pts_input_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("Id")]);
    m_id_isSet = !json[QString("Id")].isNull() && m_id_isValid;

    m_ignore_dts_isValid = ::OpenAPI::fromJsonValue(m_ignore_dts, json[QString("IgnoreDts")]);
    m_ignore_dts_isSet = !json[QString("IgnoreDts")].isNull() && m_ignore_dts_isValid;

    m_ignore_index_isValid = ::OpenAPI::fromJsonValue(m_ignore_index, json[QString("IgnoreIndex")]);
    m_ignore_index_isSet = !json[QString("IgnoreIndex")].isNull() && m_ignore_index_isValid;

    m_is_infinite_stream_isValid = ::OpenAPI::fromJsonValue(m_is_infinite_stream, json[QString("IsInfiniteStream")]);
    m_is_infinite_stream_isSet = !json[QString("IsInfiniteStream")].isNull() && m_is_infinite_stream_isValid;

    m_is_remote_isValid = ::OpenAPI::fromJsonValue(m_is_remote, json[QString("IsRemote")]);
    m_is_remote_isSet = !json[QString("IsRemote")].isNull() && m_is_remote_isValid;

    m_iso_type_isValid = ::OpenAPI::fromJsonValue(m_iso_type, json[QString("IsoType")]);
    m_iso_type_isSet = !json[QString("IsoType")].isNull() && m_iso_type_isValid;

    m_live_stream_id_isValid = ::OpenAPI::fromJsonValue(m_live_stream_id, json[QString("LiveStreamId")]);
    m_live_stream_id_isSet = !json[QString("LiveStreamId")].isNull() && m_live_stream_id_isValid;

    m_media_attachments_isValid = ::OpenAPI::fromJsonValue(m_media_attachments, json[QString("MediaAttachments")]);
    m_media_attachments_isSet = !json[QString("MediaAttachments")].isNull() && m_media_attachments_isValid;

    m_media_streams_isValid = ::OpenAPI::fromJsonValue(m_media_streams, json[QString("MediaStreams")]);
    m_media_streams_isSet = !json[QString("MediaStreams")].isNull() && m_media_streams_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("Name")]);
    m_name_isSet = !json[QString("Name")].isNull() && m_name_isValid;

    m_open_token_isValid = ::OpenAPI::fromJsonValue(m_open_token, json[QString("OpenToken")]);
    m_open_token_isSet = !json[QString("OpenToken")].isNull() && m_open_token_isValid;

    m_path_isValid = ::OpenAPI::fromJsonValue(m_path, json[QString("Path")]);
    m_path_isSet = !json[QString("Path")].isNull() && m_path_isValid;

    m_protocol_isValid = ::OpenAPI::fromJsonValue(m_protocol, json[QString("Protocol")]);
    m_protocol_isSet = !json[QString("Protocol")].isNull() && m_protocol_isValid;

    m_read_at_native_framerate_isValid = ::OpenAPI::fromJsonValue(m_read_at_native_framerate, json[QString("ReadAtNativeFramerate")]);
    m_read_at_native_framerate_isSet = !json[QString("ReadAtNativeFramerate")].isNull() && m_read_at_native_framerate_isValid;

    m_required_http_headers_isValid = ::OpenAPI::fromJsonValue(m_required_http_headers, json[QString("RequiredHttpHeaders")]);
    m_required_http_headers_isSet = !json[QString("RequiredHttpHeaders")].isNull() && m_required_http_headers_isValid;

    m_requires_closing_isValid = ::OpenAPI::fromJsonValue(m_requires_closing, json[QString("RequiresClosing")]);
    m_requires_closing_isSet = !json[QString("RequiresClosing")].isNull() && m_requires_closing_isValid;

    m_requires_looping_isValid = ::OpenAPI::fromJsonValue(m_requires_looping, json[QString("RequiresLooping")]);
    m_requires_looping_isSet = !json[QString("RequiresLooping")].isNull() && m_requires_looping_isValid;

    m_requires_opening_isValid = ::OpenAPI::fromJsonValue(m_requires_opening, json[QString("RequiresOpening")]);
    m_requires_opening_isSet = !json[QString("RequiresOpening")].isNull() && m_requires_opening_isValid;

    m_run_time_ticks_isValid = ::OpenAPI::fromJsonValue(m_run_time_ticks, json[QString("RunTimeTicks")]);
    m_run_time_ticks_isSet = !json[QString("RunTimeTicks")].isNull() && m_run_time_ticks_isValid;

    m_size_isValid = ::OpenAPI::fromJsonValue(m_size, json[QString("Size")]);
    m_size_isSet = !json[QString("Size")].isNull() && m_size_isValid;

    m_supports_direct_play_isValid = ::OpenAPI::fromJsonValue(m_supports_direct_play, json[QString("SupportsDirectPlay")]);
    m_supports_direct_play_isSet = !json[QString("SupportsDirectPlay")].isNull() && m_supports_direct_play_isValid;

    m_supports_direct_stream_isValid = ::OpenAPI::fromJsonValue(m_supports_direct_stream, json[QString("SupportsDirectStream")]);
    m_supports_direct_stream_isSet = !json[QString("SupportsDirectStream")].isNull() && m_supports_direct_stream_isValid;

    m_supports_probing_isValid = ::OpenAPI::fromJsonValue(m_supports_probing, json[QString("SupportsProbing")]);
    m_supports_probing_isSet = !json[QString("SupportsProbing")].isNull() && m_supports_probing_isValid;

    m_supports_transcoding_isValid = ::OpenAPI::fromJsonValue(m_supports_transcoding, json[QString("SupportsTranscoding")]);
    m_supports_transcoding_isSet = !json[QString("SupportsTranscoding")].isNull() && m_supports_transcoding_isValid;

    m_timestamp_isValid = ::OpenAPI::fromJsonValue(m_timestamp, json[QString("Timestamp")]);
    m_timestamp_isSet = !json[QString("Timestamp")].isNull() && m_timestamp_isValid;

    m_transcoding_container_isValid = ::OpenAPI::fromJsonValue(m_transcoding_container, json[QString("TranscodingContainer")]);
    m_transcoding_container_isSet = !json[QString("TranscodingContainer")].isNull() && m_transcoding_container_isValid;

    m_transcoding_sub_protocol_isValid = ::OpenAPI::fromJsonValue(m_transcoding_sub_protocol, json[QString("TranscodingSubProtocol")]);
    m_transcoding_sub_protocol_isSet = !json[QString("TranscodingSubProtocol")].isNull() && m_transcoding_sub_protocol_isValid;

    m_transcoding_url_isValid = ::OpenAPI::fromJsonValue(m_transcoding_url, json[QString("TranscodingUrl")]);
    m_transcoding_url_isSet = !json[QString("TranscodingUrl")].isNull() && m_transcoding_url_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("Type")]);
    m_type_isSet = !json[QString("Type")].isNull() && m_type_isValid;

    m_video3_d_format_isValid = ::OpenAPI::fromJsonValue(m_video3_d_format, json[QString("Video3DFormat")]);
    m_video3_d_format_isSet = !json[QString("Video3DFormat")].isNull() && m_video3_d_format_isValid;

    m_video_type_isValid = ::OpenAPI::fromJsonValue(m_video_type, json[QString("VideoType")]);
    m_video_type_isSet = !json[QString("VideoType")].isNull() && m_video_type_isValid;
}

QString OAIMediaSourceInfo::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMediaSourceInfo::asJsonObject() const {
    QJsonObject obj;
    if (m_analyze_duration_ms_isSet) {
        obj.insert(QString("AnalyzeDurationMs"), ::OpenAPI::toJsonValue(m_analyze_duration_ms));
    }
    if (m_bitrate_isSet) {
        obj.insert(QString("Bitrate"), ::OpenAPI::toJsonValue(m_bitrate));
    }
    if (m_buffer_ms_isSet) {
        obj.insert(QString("BufferMs"), ::OpenAPI::toJsonValue(m_buffer_ms));
    }
    if (m_container_isSet) {
        obj.insert(QString("Container"), ::OpenAPI::toJsonValue(m_container));
    }
    if (m_default_audio_stream_index_isSet) {
        obj.insert(QString("DefaultAudioStreamIndex"), ::OpenAPI::toJsonValue(m_default_audio_stream_index));
    }
    if (m_default_subtitle_stream_index_isSet) {
        obj.insert(QString("DefaultSubtitleStreamIndex"), ::OpenAPI::toJsonValue(m_default_subtitle_stream_index));
    }
    if (m_e_tag_isSet) {
        obj.insert(QString("ETag"), ::OpenAPI::toJsonValue(m_e_tag));
    }
    if (m_encoder_path_isSet) {
        obj.insert(QString("EncoderPath"), ::OpenAPI::toJsonValue(m_encoder_path));
    }
    if (m_encoder_protocol.isSet()) {
        obj.insert(QString("EncoderProtocol"), ::OpenAPI::toJsonValue(m_encoder_protocol));
    }
    if (m_formats.size() > 0) {
        obj.insert(QString("Formats"), ::OpenAPI::toJsonValue(m_formats));
    }
    if (m_gen_pts_input_isSet) {
        obj.insert(QString("GenPtsInput"), ::OpenAPI::toJsonValue(m_gen_pts_input));
    }
    if (m_id_isSet) {
        obj.insert(QString("Id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_ignore_dts_isSet) {
        obj.insert(QString("IgnoreDts"), ::OpenAPI::toJsonValue(m_ignore_dts));
    }
    if (m_ignore_index_isSet) {
        obj.insert(QString("IgnoreIndex"), ::OpenAPI::toJsonValue(m_ignore_index));
    }
    if (m_is_infinite_stream_isSet) {
        obj.insert(QString("IsInfiniteStream"), ::OpenAPI::toJsonValue(m_is_infinite_stream));
    }
    if (m_is_remote_isSet) {
        obj.insert(QString("IsRemote"), ::OpenAPI::toJsonValue(m_is_remote));
    }
    if (m_iso_type.isSet()) {
        obj.insert(QString("IsoType"), ::OpenAPI::toJsonValue(m_iso_type));
    }
    if (m_live_stream_id_isSet) {
        obj.insert(QString("LiveStreamId"), ::OpenAPI::toJsonValue(m_live_stream_id));
    }
    if (m_media_attachments.size() > 0) {
        obj.insert(QString("MediaAttachments"), ::OpenAPI::toJsonValue(m_media_attachments));
    }
    if (m_media_streams.size() > 0) {
        obj.insert(QString("MediaStreams"), ::OpenAPI::toJsonValue(m_media_streams));
    }
    if (m_name_isSet) {
        obj.insert(QString("Name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_open_token_isSet) {
        obj.insert(QString("OpenToken"), ::OpenAPI::toJsonValue(m_open_token));
    }
    if (m_path_isSet) {
        obj.insert(QString("Path"), ::OpenAPI::toJsonValue(m_path));
    }
    if (m_protocol.isSet()) {
        obj.insert(QString("Protocol"), ::OpenAPI::toJsonValue(m_protocol));
    }
    if (m_read_at_native_framerate_isSet) {
        obj.insert(QString("ReadAtNativeFramerate"), ::OpenAPI::toJsonValue(m_read_at_native_framerate));
    }
    if (m_required_http_headers.size() > 0) {
        obj.insert(QString("RequiredHttpHeaders"), ::OpenAPI::toJsonValue(m_required_http_headers));
    }
    if (m_requires_closing_isSet) {
        obj.insert(QString("RequiresClosing"), ::OpenAPI::toJsonValue(m_requires_closing));
    }
    if (m_requires_looping_isSet) {
        obj.insert(QString("RequiresLooping"), ::OpenAPI::toJsonValue(m_requires_looping));
    }
    if (m_requires_opening_isSet) {
        obj.insert(QString("RequiresOpening"), ::OpenAPI::toJsonValue(m_requires_opening));
    }
    if (m_run_time_ticks_isSet) {
        obj.insert(QString("RunTimeTicks"), ::OpenAPI::toJsonValue(m_run_time_ticks));
    }
    if (m_size_isSet) {
        obj.insert(QString("Size"), ::OpenAPI::toJsonValue(m_size));
    }
    if (m_supports_direct_play_isSet) {
        obj.insert(QString("SupportsDirectPlay"), ::OpenAPI::toJsonValue(m_supports_direct_play));
    }
    if (m_supports_direct_stream_isSet) {
        obj.insert(QString("SupportsDirectStream"), ::OpenAPI::toJsonValue(m_supports_direct_stream));
    }
    if (m_supports_probing_isSet) {
        obj.insert(QString("SupportsProbing"), ::OpenAPI::toJsonValue(m_supports_probing));
    }
    if (m_supports_transcoding_isSet) {
        obj.insert(QString("SupportsTranscoding"), ::OpenAPI::toJsonValue(m_supports_transcoding));
    }
    if (m_timestamp.isSet()) {
        obj.insert(QString("Timestamp"), ::OpenAPI::toJsonValue(m_timestamp));
    }
    if (m_transcoding_container_isSet) {
        obj.insert(QString("TranscodingContainer"), ::OpenAPI::toJsonValue(m_transcoding_container));
    }
    if (m_transcoding_sub_protocol_isSet) {
        obj.insert(QString("TranscodingSubProtocol"), ::OpenAPI::toJsonValue(m_transcoding_sub_protocol));
    }
    if (m_transcoding_url_isSet) {
        obj.insert(QString("TranscodingUrl"), ::OpenAPI::toJsonValue(m_transcoding_url));
    }
    if (m_type.isSet()) {
        obj.insert(QString("Type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_video3_d_format.isSet()) {
        obj.insert(QString("Video3DFormat"), ::OpenAPI::toJsonValue(m_video3_d_format));
    }
    if (m_video_type.isSet()) {
        obj.insert(QString("VideoType"), ::OpenAPI::toJsonValue(m_video_type));
    }
    return obj;
}

qint32 OAIMediaSourceInfo::getAnalyzeDurationMs() const {
    return m_analyze_duration_ms;
}
void OAIMediaSourceInfo::setAnalyzeDurationMs(const qint32 &analyze_duration_ms) {
    m_analyze_duration_ms = analyze_duration_ms;
    m_analyze_duration_ms_isSet = true;
}

bool OAIMediaSourceInfo::is_analyze_duration_ms_Set() const{
    return m_analyze_duration_ms_isSet;
}

bool OAIMediaSourceInfo::is_analyze_duration_ms_Valid() const{
    return m_analyze_duration_ms_isValid;
}

qint32 OAIMediaSourceInfo::getBitrate() const {
    return m_bitrate;
}
void OAIMediaSourceInfo::setBitrate(const qint32 &bitrate) {
    m_bitrate = bitrate;
    m_bitrate_isSet = true;
}

bool OAIMediaSourceInfo::is_bitrate_Set() const{
    return m_bitrate_isSet;
}

bool OAIMediaSourceInfo::is_bitrate_Valid() const{
    return m_bitrate_isValid;
}

qint32 OAIMediaSourceInfo::getBufferMs() const {
    return m_buffer_ms;
}
void OAIMediaSourceInfo::setBufferMs(const qint32 &buffer_ms) {
    m_buffer_ms = buffer_ms;
    m_buffer_ms_isSet = true;
}

bool OAIMediaSourceInfo::is_buffer_ms_Set() const{
    return m_buffer_ms_isSet;
}

bool OAIMediaSourceInfo::is_buffer_ms_Valid() const{
    return m_buffer_ms_isValid;
}

QString OAIMediaSourceInfo::getContainer() const {
    return m_container;
}
void OAIMediaSourceInfo::setContainer(const QString &container) {
    m_container = container;
    m_container_isSet = true;
}

bool OAIMediaSourceInfo::is_container_Set() const{
    return m_container_isSet;
}

bool OAIMediaSourceInfo::is_container_Valid() const{
    return m_container_isValid;
}

qint32 OAIMediaSourceInfo::getDefaultAudioStreamIndex() const {
    return m_default_audio_stream_index;
}
void OAIMediaSourceInfo::setDefaultAudioStreamIndex(const qint32 &default_audio_stream_index) {
    m_default_audio_stream_index = default_audio_stream_index;
    m_default_audio_stream_index_isSet = true;
}

bool OAIMediaSourceInfo::is_default_audio_stream_index_Set() const{
    return m_default_audio_stream_index_isSet;
}

bool OAIMediaSourceInfo::is_default_audio_stream_index_Valid() const{
    return m_default_audio_stream_index_isValid;
}

qint32 OAIMediaSourceInfo::getDefaultSubtitleStreamIndex() const {
    return m_default_subtitle_stream_index;
}
void OAIMediaSourceInfo::setDefaultSubtitleStreamIndex(const qint32 &default_subtitle_stream_index) {
    m_default_subtitle_stream_index = default_subtitle_stream_index;
    m_default_subtitle_stream_index_isSet = true;
}

bool OAIMediaSourceInfo::is_default_subtitle_stream_index_Set() const{
    return m_default_subtitle_stream_index_isSet;
}

bool OAIMediaSourceInfo::is_default_subtitle_stream_index_Valid() const{
    return m_default_subtitle_stream_index_isValid;
}

QString OAIMediaSourceInfo::getETag() const {
    return m_e_tag;
}
void OAIMediaSourceInfo::setETag(const QString &e_tag) {
    m_e_tag = e_tag;
    m_e_tag_isSet = true;
}

bool OAIMediaSourceInfo::is_e_tag_Set() const{
    return m_e_tag_isSet;
}

bool OAIMediaSourceInfo::is_e_tag_Valid() const{
    return m_e_tag_isValid;
}

QString OAIMediaSourceInfo::getEncoderPath() const {
    return m_encoder_path;
}
void OAIMediaSourceInfo::setEncoderPath(const QString &encoder_path) {
    m_encoder_path = encoder_path;
    m_encoder_path_isSet = true;
}

bool OAIMediaSourceInfo::is_encoder_path_Set() const{
    return m_encoder_path_isSet;
}

bool OAIMediaSourceInfo::is_encoder_path_Valid() const{
    return m_encoder_path_isValid;
}

OAIMediaProtocol OAIMediaSourceInfo::getEncoderProtocol() const {
    return m_encoder_protocol;
}
void OAIMediaSourceInfo::setEncoderProtocol(const OAIMediaProtocol &encoder_protocol) {
    m_encoder_protocol = encoder_protocol;
    m_encoder_protocol_isSet = true;
}

bool OAIMediaSourceInfo::is_encoder_protocol_Set() const{
    return m_encoder_protocol_isSet;
}

bool OAIMediaSourceInfo::is_encoder_protocol_Valid() const{
    return m_encoder_protocol_isValid;
}

QList<QString> OAIMediaSourceInfo::getFormats() const {
    return m_formats;
}
void OAIMediaSourceInfo::setFormats(const QList<QString> &formats) {
    m_formats = formats;
    m_formats_isSet = true;
}

bool OAIMediaSourceInfo::is_formats_Set() const{
    return m_formats_isSet;
}

bool OAIMediaSourceInfo::is_formats_Valid() const{
    return m_formats_isValid;
}

bool OAIMediaSourceInfo::isGenPtsInput() const {
    return m_gen_pts_input;
}
void OAIMediaSourceInfo::setGenPtsInput(const bool &gen_pts_input) {
    m_gen_pts_input = gen_pts_input;
    m_gen_pts_input_isSet = true;
}

bool OAIMediaSourceInfo::is_gen_pts_input_Set() const{
    return m_gen_pts_input_isSet;
}

bool OAIMediaSourceInfo::is_gen_pts_input_Valid() const{
    return m_gen_pts_input_isValid;
}

QString OAIMediaSourceInfo::getId() const {
    return m_id;
}
void OAIMediaSourceInfo::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIMediaSourceInfo::is_id_Set() const{
    return m_id_isSet;
}

bool OAIMediaSourceInfo::is_id_Valid() const{
    return m_id_isValid;
}

bool OAIMediaSourceInfo::isIgnoreDts() const {
    return m_ignore_dts;
}
void OAIMediaSourceInfo::setIgnoreDts(const bool &ignore_dts) {
    m_ignore_dts = ignore_dts;
    m_ignore_dts_isSet = true;
}

bool OAIMediaSourceInfo::is_ignore_dts_Set() const{
    return m_ignore_dts_isSet;
}

bool OAIMediaSourceInfo::is_ignore_dts_Valid() const{
    return m_ignore_dts_isValid;
}

bool OAIMediaSourceInfo::isIgnoreIndex() const {
    return m_ignore_index;
}
void OAIMediaSourceInfo::setIgnoreIndex(const bool &ignore_index) {
    m_ignore_index = ignore_index;
    m_ignore_index_isSet = true;
}

bool OAIMediaSourceInfo::is_ignore_index_Set() const{
    return m_ignore_index_isSet;
}

bool OAIMediaSourceInfo::is_ignore_index_Valid() const{
    return m_ignore_index_isValid;
}

bool OAIMediaSourceInfo::isIsInfiniteStream() const {
    return m_is_infinite_stream;
}
void OAIMediaSourceInfo::setIsInfiniteStream(const bool &is_infinite_stream) {
    m_is_infinite_stream = is_infinite_stream;
    m_is_infinite_stream_isSet = true;
}

bool OAIMediaSourceInfo::is_is_infinite_stream_Set() const{
    return m_is_infinite_stream_isSet;
}

bool OAIMediaSourceInfo::is_is_infinite_stream_Valid() const{
    return m_is_infinite_stream_isValid;
}

bool OAIMediaSourceInfo::isIsRemote() const {
    return m_is_remote;
}
void OAIMediaSourceInfo::setIsRemote(const bool &is_remote) {
    m_is_remote = is_remote;
    m_is_remote_isSet = true;
}

bool OAIMediaSourceInfo::is_is_remote_Set() const{
    return m_is_remote_isSet;
}

bool OAIMediaSourceInfo::is_is_remote_Valid() const{
    return m_is_remote_isValid;
}

OAIIsoType OAIMediaSourceInfo::getIsoType() const {
    return m_iso_type;
}
void OAIMediaSourceInfo::setIsoType(const OAIIsoType &iso_type) {
    m_iso_type = iso_type;
    m_iso_type_isSet = true;
}

bool OAIMediaSourceInfo::is_iso_type_Set() const{
    return m_iso_type_isSet;
}

bool OAIMediaSourceInfo::is_iso_type_Valid() const{
    return m_iso_type_isValid;
}

QString OAIMediaSourceInfo::getLiveStreamId() const {
    return m_live_stream_id;
}
void OAIMediaSourceInfo::setLiveStreamId(const QString &live_stream_id) {
    m_live_stream_id = live_stream_id;
    m_live_stream_id_isSet = true;
}

bool OAIMediaSourceInfo::is_live_stream_id_Set() const{
    return m_live_stream_id_isSet;
}

bool OAIMediaSourceInfo::is_live_stream_id_Valid() const{
    return m_live_stream_id_isValid;
}

QList<OAIMediaAttachment> OAIMediaSourceInfo::getMediaAttachments() const {
    return m_media_attachments;
}
void OAIMediaSourceInfo::setMediaAttachments(const QList<OAIMediaAttachment> &media_attachments) {
    m_media_attachments = media_attachments;
    m_media_attachments_isSet = true;
}

bool OAIMediaSourceInfo::is_media_attachments_Set() const{
    return m_media_attachments_isSet;
}

bool OAIMediaSourceInfo::is_media_attachments_Valid() const{
    return m_media_attachments_isValid;
}

QList<OAIMediaStream> OAIMediaSourceInfo::getMediaStreams() const {
    return m_media_streams;
}
void OAIMediaSourceInfo::setMediaStreams(const QList<OAIMediaStream> &media_streams) {
    m_media_streams = media_streams;
    m_media_streams_isSet = true;
}

bool OAIMediaSourceInfo::is_media_streams_Set() const{
    return m_media_streams_isSet;
}

bool OAIMediaSourceInfo::is_media_streams_Valid() const{
    return m_media_streams_isValid;
}

QString OAIMediaSourceInfo::getName() const {
    return m_name;
}
void OAIMediaSourceInfo::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIMediaSourceInfo::is_name_Set() const{
    return m_name_isSet;
}

bool OAIMediaSourceInfo::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIMediaSourceInfo::getOpenToken() const {
    return m_open_token;
}
void OAIMediaSourceInfo::setOpenToken(const QString &open_token) {
    m_open_token = open_token;
    m_open_token_isSet = true;
}

bool OAIMediaSourceInfo::is_open_token_Set() const{
    return m_open_token_isSet;
}

bool OAIMediaSourceInfo::is_open_token_Valid() const{
    return m_open_token_isValid;
}

QString OAIMediaSourceInfo::getPath() const {
    return m_path;
}
void OAIMediaSourceInfo::setPath(const QString &path) {
    m_path = path;
    m_path_isSet = true;
}

bool OAIMediaSourceInfo::is_path_Set() const{
    return m_path_isSet;
}

bool OAIMediaSourceInfo::is_path_Valid() const{
    return m_path_isValid;
}

OAIMediaProtocol OAIMediaSourceInfo::getProtocol() const {
    return m_protocol;
}
void OAIMediaSourceInfo::setProtocol(const OAIMediaProtocol &protocol) {
    m_protocol = protocol;
    m_protocol_isSet = true;
}

bool OAIMediaSourceInfo::is_protocol_Set() const{
    return m_protocol_isSet;
}

bool OAIMediaSourceInfo::is_protocol_Valid() const{
    return m_protocol_isValid;
}

bool OAIMediaSourceInfo::isReadAtNativeFramerate() const {
    return m_read_at_native_framerate;
}
void OAIMediaSourceInfo::setReadAtNativeFramerate(const bool &read_at_native_framerate) {
    m_read_at_native_framerate = read_at_native_framerate;
    m_read_at_native_framerate_isSet = true;
}

bool OAIMediaSourceInfo::is_read_at_native_framerate_Set() const{
    return m_read_at_native_framerate_isSet;
}

bool OAIMediaSourceInfo::is_read_at_native_framerate_Valid() const{
    return m_read_at_native_framerate_isValid;
}

QMap<QString, QString> OAIMediaSourceInfo::getRequiredHttpHeaders() const {
    return m_required_http_headers;
}
void OAIMediaSourceInfo::setRequiredHttpHeaders(const QMap<QString, QString> &required_http_headers) {
    m_required_http_headers = required_http_headers;
    m_required_http_headers_isSet = true;
}

bool OAIMediaSourceInfo::is_required_http_headers_Set() const{
    return m_required_http_headers_isSet;
}

bool OAIMediaSourceInfo::is_required_http_headers_Valid() const{
    return m_required_http_headers_isValid;
}

bool OAIMediaSourceInfo::isRequiresClosing() const {
    return m_requires_closing;
}
void OAIMediaSourceInfo::setRequiresClosing(const bool &requires_closing) {
    m_requires_closing = requires_closing;
    m_requires_closing_isSet = true;
}

bool OAIMediaSourceInfo::is_requires_closing_Set() const{
    return m_requires_closing_isSet;
}

bool OAIMediaSourceInfo::is_requires_closing_Valid() const{
    return m_requires_closing_isValid;
}

bool OAIMediaSourceInfo::isRequiresLooping() const {
    return m_requires_looping;
}
void OAIMediaSourceInfo::setRequiresLooping(const bool &requires_looping) {
    m_requires_looping = requires_looping;
    m_requires_looping_isSet = true;
}

bool OAIMediaSourceInfo::is_requires_looping_Set() const{
    return m_requires_looping_isSet;
}

bool OAIMediaSourceInfo::is_requires_looping_Valid() const{
    return m_requires_looping_isValid;
}

bool OAIMediaSourceInfo::isRequiresOpening() const {
    return m_requires_opening;
}
void OAIMediaSourceInfo::setRequiresOpening(const bool &requires_opening) {
    m_requires_opening = requires_opening;
    m_requires_opening_isSet = true;
}

bool OAIMediaSourceInfo::is_requires_opening_Set() const{
    return m_requires_opening_isSet;
}

bool OAIMediaSourceInfo::is_requires_opening_Valid() const{
    return m_requires_opening_isValid;
}

qint64 OAIMediaSourceInfo::getRunTimeTicks() const {
    return m_run_time_ticks;
}
void OAIMediaSourceInfo::setRunTimeTicks(const qint64 &run_time_ticks) {
    m_run_time_ticks = run_time_ticks;
    m_run_time_ticks_isSet = true;
}

bool OAIMediaSourceInfo::is_run_time_ticks_Set() const{
    return m_run_time_ticks_isSet;
}

bool OAIMediaSourceInfo::is_run_time_ticks_Valid() const{
    return m_run_time_ticks_isValid;
}

qint64 OAIMediaSourceInfo::getSize() const {
    return m_size;
}
void OAIMediaSourceInfo::setSize(const qint64 &size) {
    m_size = size;
    m_size_isSet = true;
}

bool OAIMediaSourceInfo::is_size_Set() const{
    return m_size_isSet;
}

bool OAIMediaSourceInfo::is_size_Valid() const{
    return m_size_isValid;
}

bool OAIMediaSourceInfo::isSupportsDirectPlay() const {
    return m_supports_direct_play;
}
void OAIMediaSourceInfo::setSupportsDirectPlay(const bool &supports_direct_play) {
    m_supports_direct_play = supports_direct_play;
    m_supports_direct_play_isSet = true;
}

bool OAIMediaSourceInfo::is_supports_direct_play_Set() const{
    return m_supports_direct_play_isSet;
}

bool OAIMediaSourceInfo::is_supports_direct_play_Valid() const{
    return m_supports_direct_play_isValid;
}

bool OAIMediaSourceInfo::isSupportsDirectStream() const {
    return m_supports_direct_stream;
}
void OAIMediaSourceInfo::setSupportsDirectStream(const bool &supports_direct_stream) {
    m_supports_direct_stream = supports_direct_stream;
    m_supports_direct_stream_isSet = true;
}

bool OAIMediaSourceInfo::is_supports_direct_stream_Set() const{
    return m_supports_direct_stream_isSet;
}

bool OAIMediaSourceInfo::is_supports_direct_stream_Valid() const{
    return m_supports_direct_stream_isValid;
}

bool OAIMediaSourceInfo::isSupportsProbing() const {
    return m_supports_probing;
}
void OAIMediaSourceInfo::setSupportsProbing(const bool &supports_probing) {
    m_supports_probing = supports_probing;
    m_supports_probing_isSet = true;
}

bool OAIMediaSourceInfo::is_supports_probing_Set() const{
    return m_supports_probing_isSet;
}

bool OAIMediaSourceInfo::is_supports_probing_Valid() const{
    return m_supports_probing_isValid;
}

bool OAIMediaSourceInfo::isSupportsTranscoding() const {
    return m_supports_transcoding;
}
void OAIMediaSourceInfo::setSupportsTranscoding(const bool &supports_transcoding) {
    m_supports_transcoding = supports_transcoding;
    m_supports_transcoding_isSet = true;
}

bool OAIMediaSourceInfo::is_supports_transcoding_Set() const{
    return m_supports_transcoding_isSet;
}

bool OAIMediaSourceInfo::is_supports_transcoding_Valid() const{
    return m_supports_transcoding_isValid;
}

OAITransportStreamTimestamp OAIMediaSourceInfo::getTimestamp() const {
    return m_timestamp;
}
void OAIMediaSourceInfo::setTimestamp(const OAITransportStreamTimestamp &timestamp) {
    m_timestamp = timestamp;
    m_timestamp_isSet = true;
}

bool OAIMediaSourceInfo::is_timestamp_Set() const{
    return m_timestamp_isSet;
}

bool OAIMediaSourceInfo::is_timestamp_Valid() const{
    return m_timestamp_isValid;
}

QString OAIMediaSourceInfo::getTranscodingContainer() const {
    return m_transcoding_container;
}
void OAIMediaSourceInfo::setTranscodingContainer(const QString &transcoding_container) {
    m_transcoding_container = transcoding_container;
    m_transcoding_container_isSet = true;
}

bool OAIMediaSourceInfo::is_transcoding_container_Set() const{
    return m_transcoding_container_isSet;
}

bool OAIMediaSourceInfo::is_transcoding_container_Valid() const{
    return m_transcoding_container_isValid;
}

QString OAIMediaSourceInfo::getTranscodingSubProtocol() const {
    return m_transcoding_sub_protocol;
}
void OAIMediaSourceInfo::setTranscodingSubProtocol(const QString &transcoding_sub_protocol) {
    m_transcoding_sub_protocol = transcoding_sub_protocol;
    m_transcoding_sub_protocol_isSet = true;
}

bool OAIMediaSourceInfo::is_transcoding_sub_protocol_Set() const{
    return m_transcoding_sub_protocol_isSet;
}

bool OAIMediaSourceInfo::is_transcoding_sub_protocol_Valid() const{
    return m_transcoding_sub_protocol_isValid;
}

QString OAIMediaSourceInfo::getTranscodingUrl() const {
    return m_transcoding_url;
}
void OAIMediaSourceInfo::setTranscodingUrl(const QString &transcoding_url) {
    m_transcoding_url = transcoding_url;
    m_transcoding_url_isSet = true;
}

bool OAIMediaSourceInfo::is_transcoding_url_Set() const{
    return m_transcoding_url_isSet;
}

bool OAIMediaSourceInfo::is_transcoding_url_Valid() const{
    return m_transcoding_url_isValid;
}

OAIMediaSourceType OAIMediaSourceInfo::getType() const {
    return m_type;
}
void OAIMediaSourceInfo::setType(const OAIMediaSourceType &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIMediaSourceInfo::is_type_Set() const{
    return m_type_isSet;
}

bool OAIMediaSourceInfo::is_type_Valid() const{
    return m_type_isValid;
}

OAIVideo3DFormat OAIMediaSourceInfo::getVideo3DFormat() const {
    return m_video3_d_format;
}
void OAIMediaSourceInfo::setVideo3DFormat(const OAIVideo3DFormat &video3_d_format) {
    m_video3_d_format = video3_d_format;
    m_video3_d_format_isSet = true;
}

bool OAIMediaSourceInfo::is_video3_d_format_Set() const{
    return m_video3_d_format_isSet;
}

bool OAIMediaSourceInfo::is_video3_d_format_Valid() const{
    return m_video3_d_format_isValid;
}

OAIVideoType OAIMediaSourceInfo::getVideoType() const {
    return m_video_type;
}
void OAIMediaSourceInfo::setVideoType(const OAIVideoType &video_type) {
    m_video_type = video_type;
    m_video_type_isSet = true;
}

bool OAIMediaSourceInfo::is_video_type_Set() const{
    return m_video_type_isSet;
}

bool OAIMediaSourceInfo::is_video_type_Valid() const{
    return m_video_type_isValid;
}

bool OAIMediaSourceInfo::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_analyze_duration_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_buffer_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_container_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_audio_stream_index_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_subtitle_stream_index_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_e_tag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encoder_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encoder_protocol.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_formats.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_gen_pts_input_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ignore_dts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ignore_index_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_infinite_stream_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_remote_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_iso_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_live_stream_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_attachments.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_streams.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_open_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_at_native_framerate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_required_http_headers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_closing_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_looping_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_opening_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_run_time_ticks_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supports_direct_play_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supports_direct_stream_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supports_probing_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supports_transcoding_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timestamp.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_transcoding_container_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transcoding_sub_protocol_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transcoding_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_video3_d_format.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_video_type.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMediaSourceInfo::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
