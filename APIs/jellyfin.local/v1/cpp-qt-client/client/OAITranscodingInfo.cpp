/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITranscodingInfo.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITranscodingInfo::OAITranscodingInfo(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITranscodingInfo::OAITranscodingInfo() {
    this->initializeModel();
}

OAITranscodingInfo::~OAITranscodingInfo() {}

void OAITranscodingInfo::initializeModel() {

    m_audio_channels_isSet = false;
    m_audio_channels_isValid = false;

    m_audio_codec_isSet = false;
    m_audio_codec_isValid = false;

    m_bitrate_isSet = false;
    m_bitrate_isValid = false;

    m_completion_percentage_isSet = false;
    m_completion_percentage_isValid = false;

    m_container_isSet = false;
    m_container_isValid = false;

    m_framerate_isSet = false;
    m_framerate_isValid = false;

    m_height_isSet = false;
    m_height_isValid = false;

    m_is_audio_direct_isSet = false;
    m_is_audio_direct_isValid = false;

    m_is_video_direct_isSet = false;
    m_is_video_direct_isValid = false;

    m_transcode_reasons_isSet = false;
    m_transcode_reasons_isValid = false;

    m_video_codec_isSet = false;
    m_video_codec_isValid = false;

    m_width_isSet = false;
    m_width_isValid = false;
}

void OAITranscodingInfo::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITranscodingInfo::fromJsonObject(QJsonObject json) {

    m_audio_channels_isValid = ::OpenAPI::fromJsonValue(m_audio_channels, json[QString("AudioChannels")]);
    m_audio_channels_isSet = !json[QString("AudioChannels")].isNull() && m_audio_channels_isValid;

    m_audio_codec_isValid = ::OpenAPI::fromJsonValue(m_audio_codec, json[QString("AudioCodec")]);
    m_audio_codec_isSet = !json[QString("AudioCodec")].isNull() && m_audio_codec_isValid;

    m_bitrate_isValid = ::OpenAPI::fromJsonValue(m_bitrate, json[QString("Bitrate")]);
    m_bitrate_isSet = !json[QString("Bitrate")].isNull() && m_bitrate_isValid;

    m_completion_percentage_isValid = ::OpenAPI::fromJsonValue(m_completion_percentage, json[QString("CompletionPercentage")]);
    m_completion_percentage_isSet = !json[QString("CompletionPercentage")].isNull() && m_completion_percentage_isValid;

    m_container_isValid = ::OpenAPI::fromJsonValue(m_container, json[QString("Container")]);
    m_container_isSet = !json[QString("Container")].isNull() && m_container_isValid;

    m_framerate_isValid = ::OpenAPI::fromJsonValue(m_framerate, json[QString("Framerate")]);
    m_framerate_isSet = !json[QString("Framerate")].isNull() && m_framerate_isValid;

    m_height_isValid = ::OpenAPI::fromJsonValue(m_height, json[QString("Height")]);
    m_height_isSet = !json[QString("Height")].isNull() && m_height_isValid;

    m_is_audio_direct_isValid = ::OpenAPI::fromJsonValue(m_is_audio_direct, json[QString("IsAudioDirect")]);
    m_is_audio_direct_isSet = !json[QString("IsAudioDirect")].isNull() && m_is_audio_direct_isValid;

    m_is_video_direct_isValid = ::OpenAPI::fromJsonValue(m_is_video_direct, json[QString("IsVideoDirect")]);
    m_is_video_direct_isSet = !json[QString("IsVideoDirect")].isNull() && m_is_video_direct_isValid;

    m_transcode_reasons_isValid = ::OpenAPI::fromJsonValue(m_transcode_reasons, json[QString("TranscodeReasons")]);
    m_transcode_reasons_isSet = !json[QString("TranscodeReasons")].isNull() && m_transcode_reasons_isValid;

    m_video_codec_isValid = ::OpenAPI::fromJsonValue(m_video_codec, json[QString("VideoCodec")]);
    m_video_codec_isSet = !json[QString("VideoCodec")].isNull() && m_video_codec_isValid;

    m_width_isValid = ::OpenAPI::fromJsonValue(m_width, json[QString("Width")]);
    m_width_isSet = !json[QString("Width")].isNull() && m_width_isValid;
}

QString OAITranscodingInfo::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITranscodingInfo::asJsonObject() const {
    QJsonObject obj;
    if (m_audio_channels_isSet) {
        obj.insert(QString("AudioChannels"), ::OpenAPI::toJsonValue(m_audio_channels));
    }
    if (m_audio_codec_isSet) {
        obj.insert(QString("AudioCodec"), ::OpenAPI::toJsonValue(m_audio_codec));
    }
    if (m_bitrate_isSet) {
        obj.insert(QString("Bitrate"), ::OpenAPI::toJsonValue(m_bitrate));
    }
    if (m_completion_percentage_isSet) {
        obj.insert(QString("CompletionPercentage"), ::OpenAPI::toJsonValue(m_completion_percentage));
    }
    if (m_container_isSet) {
        obj.insert(QString("Container"), ::OpenAPI::toJsonValue(m_container));
    }
    if (m_framerate_isSet) {
        obj.insert(QString("Framerate"), ::OpenAPI::toJsonValue(m_framerate));
    }
    if (m_height_isSet) {
        obj.insert(QString("Height"), ::OpenAPI::toJsonValue(m_height));
    }
    if (m_is_audio_direct_isSet) {
        obj.insert(QString("IsAudioDirect"), ::OpenAPI::toJsonValue(m_is_audio_direct));
    }
    if (m_is_video_direct_isSet) {
        obj.insert(QString("IsVideoDirect"), ::OpenAPI::toJsonValue(m_is_video_direct));
    }
    if (m_transcode_reasons.size() > 0) {
        obj.insert(QString("TranscodeReasons"), ::OpenAPI::toJsonValue(m_transcode_reasons));
    }
    if (m_video_codec_isSet) {
        obj.insert(QString("VideoCodec"), ::OpenAPI::toJsonValue(m_video_codec));
    }
    if (m_width_isSet) {
        obj.insert(QString("Width"), ::OpenAPI::toJsonValue(m_width));
    }
    return obj;
}

qint32 OAITranscodingInfo::getAudioChannels() const {
    return m_audio_channels;
}
void OAITranscodingInfo::setAudioChannels(const qint32 &audio_channels) {
    m_audio_channels = audio_channels;
    m_audio_channels_isSet = true;
}

bool OAITranscodingInfo::is_audio_channels_Set() const{
    return m_audio_channels_isSet;
}

bool OAITranscodingInfo::is_audio_channels_Valid() const{
    return m_audio_channels_isValid;
}

QString OAITranscodingInfo::getAudioCodec() const {
    return m_audio_codec;
}
void OAITranscodingInfo::setAudioCodec(const QString &audio_codec) {
    m_audio_codec = audio_codec;
    m_audio_codec_isSet = true;
}

bool OAITranscodingInfo::is_audio_codec_Set() const{
    return m_audio_codec_isSet;
}

bool OAITranscodingInfo::is_audio_codec_Valid() const{
    return m_audio_codec_isValid;
}

qint32 OAITranscodingInfo::getBitrate() const {
    return m_bitrate;
}
void OAITranscodingInfo::setBitrate(const qint32 &bitrate) {
    m_bitrate = bitrate;
    m_bitrate_isSet = true;
}

bool OAITranscodingInfo::is_bitrate_Set() const{
    return m_bitrate_isSet;
}

bool OAITranscodingInfo::is_bitrate_Valid() const{
    return m_bitrate_isValid;
}

double OAITranscodingInfo::getCompletionPercentage() const {
    return m_completion_percentage;
}
void OAITranscodingInfo::setCompletionPercentage(const double &completion_percentage) {
    m_completion_percentage = completion_percentage;
    m_completion_percentage_isSet = true;
}

bool OAITranscodingInfo::is_completion_percentage_Set() const{
    return m_completion_percentage_isSet;
}

bool OAITranscodingInfo::is_completion_percentage_Valid() const{
    return m_completion_percentage_isValid;
}

QString OAITranscodingInfo::getContainer() const {
    return m_container;
}
void OAITranscodingInfo::setContainer(const QString &container) {
    m_container = container;
    m_container_isSet = true;
}

bool OAITranscodingInfo::is_container_Set() const{
    return m_container_isSet;
}

bool OAITranscodingInfo::is_container_Valid() const{
    return m_container_isValid;
}

float OAITranscodingInfo::getFramerate() const {
    return m_framerate;
}
void OAITranscodingInfo::setFramerate(const float &framerate) {
    m_framerate = framerate;
    m_framerate_isSet = true;
}

bool OAITranscodingInfo::is_framerate_Set() const{
    return m_framerate_isSet;
}

bool OAITranscodingInfo::is_framerate_Valid() const{
    return m_framerate_isValid;
}

qint32 OAITranscodingInfo::getHeight() const {
    return m_height;
}
void OAITranscodingInfo::setHeight(const qint32 &height) {
    m_height = height;
    m_height_isSet = true;
}

bool OAITranscodingInfo::is_height_Set() const{
    return m_height_isSet;
}

bool OAITranscodingInfo::is_height_Valid() const{
    return m_height_isValid;
}

bool OAITranscodingInfo::isIsAudioDirect() const {
    return m_is_audio_direct;
}
void OAITranscodingInfo::setIsAudioDirect(const bool &is_audio_direct) {
    m_is_audio_direct = is_audio_direct;
    m_is_audio_direct_isSet = true;
}

bool OAITranscodingInfo::is_is_audio_direct_Set() const{
    return m_is_audio_direct_isSet;
}

bool OAITranscodingInfo::is_is_audio_direct_Valid() const{
    return m_is_audio_direct_isValid;
}

bool OAITranscodingInfo::isIsVideoDirect() const {
    return m_is_video_direct;
}
void OAITranscodingInfo::setIsVideoDirect(const bool &is_video_direct) {
    m_is_video_direct = is_video_direct;
    m_is_video_direct_isSet = true;
}

bool OAITranscodingInfo::is_is_video_direct_Set() const{
    return m_is_video_direct_isSet;
}

bool OAITranscodingInfo::is_is_video_direct_Valid() const{
    return m_is_video_direct_isValid;
}

QList<OAITranscodeReason> OAITranscodingInfo::getTranscodeReasons() const {
    return m_transcode_reasons;
}
void OAITranscodingInfo::setTranscodeReasons(const QList<OAITranscodeReason> &transcode_reasons) {
    m_transcode_reasons = transcode_reasons;
    m_transcode_reasons_isSet = true;
}

bool OAITranscodingInfo::is_transcode_reasons_Set() const{
    return m_transcode_reasons_isSet;
}

bool OAITranscodingInfo::is_transcode_reasons_Valid() const{
    return m_transcode_reasons_isValid;
}

QString OAITranscodingInfo::getVideoCodec() const {
    return m_video_codec;
}
void OAITranscodingInfo::setVideoCodec(const QString &video_codec) {
    m_video_codec = video_codec;
    m_video_codec_isSet = true;
}

bool OAITranscodingInfo::is_video_codec_Set() const{
    return m_video_codec_isSet;
}

bool OAITranscodingInfo::is_video_codec_Valid() const{
    return m_video_codec_isValid;
}

qint32 OAITranscodingInfo::getWidth() const {
    return m_width;
}
void OAITranscodingInfo::setWidth(const qint32 &width) {
    m_width = width;
    m_width_isSet = true;
}

bool OAITranscodingInfo::is_width_Set() const{
    return m_width_isSet;
}

bool OAITranscodingInfo::is_width_Valid() const{
    return m_width_isValid;
}

bool OAITranscodingInfo::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_audio_channels_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_audio_codec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_completion_percentage_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_container_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_framerate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_height_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_audio_direct_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_video_direct_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transcode_reasons.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_video_codec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_width_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITranscodingInfo::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
