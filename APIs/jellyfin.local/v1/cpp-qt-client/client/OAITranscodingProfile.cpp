/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITranscodingProfile.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITranscodingProfile::OAITranscodingProfile(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITranscodingProfile::OAITranscodingProfile() {
    this->initializeModel();
}

OAITranscodingProfile::~OAITranscodingProfile() {}

void OAITranscodingProfile::initializeModel() {

    m_audio_codec_isSet = false;
    m_audio_codec_isValid = false;

    m_break_on_non_key_frames_isSet = false;
    m_break_on_non_key_frames_isValid = false;

    m_container_isSet = false;
    m_container_isValid = false;

    m_context_isSet = false;
    m_context_isValid = false;

    m_copy_timestamps_isSet = false;
    m_copy_timestamps_isValid = false;

    m_enable_mpegts_m2_ts_mode_isSet = false;
    m_enable_mpegts_m2_ts_mode_isValid = false;

    m_enable_subtitles_in_manifest_isSet = false;
    m_enable_subtitles_in_manifest_isValid = false;

    m_estimate_content_length_isSet = false;
    m_estimate_content_length_isValid = false;

    m_max_audio_channels_isSet = false;
    m_max_audio_channels_isValid = false;

    m_min_segments_isSet = false;
    m_min_segments_isValid = false;

    m_protocol_isSet = false;
    m_protocol_isValid = false;

    m_segment_length_isSet = false;
    m_segment_length_isValid = false;

    m_transcode_seek_info_isSet = false;
    m_transcode_seek_info_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_video_codec_isSet = false;
    m_video_codec_isValid = false;
}

void OAITranscodingProfile::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITranscodingProfile::fromJsonObject(QJsonObject json) {

    m_audio_codec_isValid = ::OpenAPI::fromJsonValue(m_audio_codec, json[QString("AudioCodec")]);
    m_audio_codec_isSet = !json[QString("AudioCodec")].isNull() && m_audio_codec_isValid;

    m_break_on_non_key_frames_isValid = ::OpenAPI::fromJsonValue(m_break_on_non_key_frames, json[QString("BreakOnNonKeyFrames")]);
    m_break_on_non_key_frames_isSet = !json[QString("BreakOnNonKeyFrames")].isNull() && m_break_on_non_key_frames_isValid;

    m_container_isValid = ::OpenAPI::fromJsonValue(m_container, json[QString("Container")]);
    m_container_isSet = !json[QString("Container")].isNull() && m_container_isValid;

    m_context_isValid = ::OpenAPI::fromJsonValue(m_context, json[QString("Context")]);
    m_context_isSet = !json[QString("Context")].isNull() && m_context_isValid;

    m_copy_timestamps_isValid = ::OpenAPI::fromJsonValue(m_copy_timestamps, json[QString("CopyTimestamps")]);
    m_copy_timestamps_isSet = !json[QString("CopyTimestamps")].isNull() && m_copy_timestamps_isValid;

    m_enable_mpegts_m2_ts_mode_isValid = ::OpenAPI::fromJsonValue(m_enable_mpegts_m2_ts_mode, json[QString("EnableMpegtsM2TsMode")]);
    m_enable_mpegts_m2_ts_mode_isSet = !json[QString("EnableMpegtsM2TsMode")].isNull() && m_enable_mpegts_m2_ts_mode_isValid;

    m_enable_subtitles_in_manifest_isValid = ::OpenAPI::fromJsonValue(m_enable_subtitles_in_manifest, json[QString("EnableSubtitlesInManifest")]);
    m_enable_subtitles_in_manifest_isSet = !json[QString("EnableSubtitlesInManifest")].isNull() && m_enable_subtitles_in_manifest_isValid;

    m_estimate_content_length_isValid = ::OpenAPI::fromJsonValue(m_estimate_content_length, json[QString("EstimateContentLength")]);
    m_estimate_content_length_isSet = !json[QString("EstimateContentLength")].isNull() && m_estimate_content_length_isValid;

    m_max_audio_channels_isValid = ::OpenAPI::fromJsonValue(m_max_audio_channels, json[QString("MaxAudioChannels")]);
    m_max_audio_channels_isSet = !json[QString("MaxAudioChannels")].isNull() && m_max_audio_channels_isValid;

    m_min_segments_isValid = ::OpenAPI::fromJsonValue(m_min_segments, json[QString("MinSegments")]);
    m_min_segments_isSet = !json[QString("MinSegments")].isNull() && m_min_segments_isValid;

    m_protocol_isValid = ::OpenAPI::fromJsonValue(m_protocol, json[QString("Protocol")]);
    m_protocol_isSet = !json[QString("Protocol")].isNull() && m_protocol_isValid;

    m_segment_length_isValid = ::OpenAPI::fromJsonValue(m_segment_length, json[QString("SegmentLength")]);
    m_segment_length_isSet = !json[QString("SegmentLength")].isNull() && m_segment_length_isValid;

    m_transcode_seek_info_isValid = ::OpenAPI::fromJsonValue(m_transcode_seek_info, json[QString("TranscodeSeekInfo")]);
    m_transcode_seek_info_isSet = !json[QString("TranscodeSeekInfo")].isNull() && m_transcode_seek_info_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("Type")]);
    m_type_isSet = !json[QString("Type")].isNull() && m_type_isValid;

    m_video_codec_isValid = ::OpenAPI::fromJsonValue(m_video_codec, json[QString("VideoCodec")]);
    m_video_codec_isSet = !json[QString("VideoCodec")].isNull() && m_video_codec_isValid;
}

QString OAITranscodingProfile::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITranscodingProfile::asJsonObject() const {
    QJsonObject obj;
    if (m_audio_codec_isSet) {
        obj.insert(QString("AudioCodec"), ::OpenAPI::toJsonValue(m_audio_codec));
    }
    if (m_break_on_non_key_frames_isSet) {
        obj.insert(QString("BreakOnNonKeyFrames"), ::OpenAPI::toJsonValue(m_break_on_non_key_frames));
    }
    if (m_container_isSet) {
        obj.insert(QString("Container"), ::OpenAPI::toJsonValue(m_container));
    }
    if (m_context.isSet()) {
        obj.insert(QString("Context"), ::OpenAPI::toJsonValue(m_context));
    }
    if (m_copy_timestamps_isSet) {
        obj.insert(QString("CopyTimestamps"), ::OpenAPI::toJsonValue(m_copy_timestamps));
    }
    if (m_enable_mpegts_m2_ts_mode_isSet) {
        obj.insert(QString("EnableMpegtsM2TsMode"), ::OpenAPI::toJsonValue(m_enable_mpegts_m2_ts_mode));
    }
    if (m_enable_subtitles_in_manifest_isSet) {
        obj.insert(QString("EnableSubtitlesInManifest"), ::OpenAPI::toJsonValue(m_enable_subtitles_in_manifest));
    }
    if (m_estimate_content_length_isSet) {
        obj.insert(QString("EstimateContentLength"), ::OpenAPI::toJsonValue(m_estimate_content_length));
    }
    if (m_max_audio_channels_isSet) {
        obj.insert(QString("MaxAudioChannels"), ::OpenAPI::toJsonValue(m_max_audio_channels));
    }
    if (m_min_segments_isSet) {
        obj.insert(QString("MinSegments"), ::OpenAPI::toJsonValue(m_min_segments));
    }
    if (m_protocol_isSet) {
        obj.insert(QString("Protocol"), ::OpenAPI::toJsonValue(m_protocol));
    }
    if (m_segment_length_isSet) {
        obj.insert(QString("SegmentLength"), ::OpenAPI::toJsonValue(m_segment_length));
    }
    if (m_transcode_seek_info.isSet()) {
        obj.insert(QString("TranscodeSeekInfo"), ::OpenAPI::toJsonValue(m_transcode_seek_info));
    }
    if (m_type.isSet()) {
        obj.insert(QString("Type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_video_codec_isSet) {
        obj.insert(QString("VideoCodec"), ::OpenAPI::toJsonValue(m_video_codec));
    }
    return obj;
}

QString OAITranscodingProfile::getAudioCodec() const {
    return m_audio_codec;
}
void OAITranscodingProfile::setAudioCodec(const QString &audio_codec) {
    m_audio_codec = audio_codec;
    m_audio_codec_isSet = true;
}

bool OAITranscodingProfile::is_audio_codec_Set() const{
    return m_audio_codec_isSet;
}

bool OAITranscodingProfile::is_audio_codec_Valid() const{
    return m_audio_codec_isValid;
}

bool OAITranscodingProfile::isBreakOnNonKeyFrames() const {
    return m_break_on_non_key_frames;
}
void OAITranscodingProfile::setBreakOnNonKeyFrames(const bool &break_on_non_key_frames) {
    m_break_on_non_key_frames = break_on_non_key_frames;
    m_break_on_non_key_frames_isSet = true;
}

bool OAITranscodingProfile::is_break_on_non_key_frames_Set() const{
    return m_break_on_non_key_frames_isSet;
}

bool OAITranscodingProfile::is_break_on_non_key_frames_Valid() const{
    return m_break_on_non_key_frames_isValid;
}

QString OAITranscodingProfile::getContainer() const {
    return m_container;
}
void OAITranscodingProfile::setContainer(const QString &container) {
    m_container = container;
    m_container_isSet = true;
}

bool OAITranscodingProfile::is_container_Set() const{
    return m_container_isSet;
}

bool OAITranscodingProfile::is_container_Valid() const{
    return m_container_isValid;
}

OAIEncodingContext OAITranscodingProfile::getContext() const {
    return m_context;
}
void OAITranscodingProfile::setContext(const OAIEncodingContext &context) {
    m_context = context;
    m_context_isSet = true;
}

bool OAITranscodingProfile::is_context_Set() const{
    return m_context_isSet;
}

bool OAITranscodingProfile::is_context_Valid() const{
    return m_context_isValid;
}

bool OAITranscodingProfile::isCopyTimestamps() const {
    return m_copy_timestamps;
}
void OAITranscodingProfile::setCopyTimestamps(const bool &copy_timestamps) {
    m_copy_timestamps = copy_timestamps;
    m_copy_timestamps_isSet = true;
}

bool OAITranscodingProfile::is_copy_timestamps_Set() const{
    return m_copy_timestamps_isSet;
}

bool OAITranscodingProfile::is_copy_timestamps_Valid() const{
    return m_copy_timestamps_isValid;
}

bool OAITranscodingProfile::isEnableMpegtsM2TsMode() const {
    return m_enable_mpegts_m2_ts_mode;
}
void OAITranscodingProfile::setEnableMpegtsM2TsMode(const bool &enable_mpegts_m2_ts_mode) {
    m_enable_mpegts_m2_ts_mode = enable_mpegts_m2_ts_mode;
    m_enable_mpegts_m2_ts_mode_isSet = true;
}

bool OAITranscodingProfile::is_enable_mpegts_m2_ts_mode_Set() const{
    return m_enable_mpegts_m2_ts_mode_isSet;
}

bool OAITranscodingProfile::is_enable_mpegts_m2_ts_mode_Valid() const{
    return m_enable_mpegts_m2_ts_mode_isValid;
}

bool OAITranscodingProfile::isEnableSubtitlesInManifest() const {
    return m_enable_subtitles_in_manifest;
}
void OAITranscodingProfile::setEnableSubtitlesInManifest(const bool &enable_subtitles_in_manifest) {
    m_enable_subtitles_in_manifest = enable_subtitles_in_manifest;
    m_enable_subtitles_in_manifest_isSet = true;
}

bool OAITranscodingProfile::is_enable_subtitles_in_manifest_Set() const{
    return m_enable_subtitles_in_manifest_isSet;
}

bool OAITranscodingProfile::is_enable_subtitles_in_manifest_Valid() const{
    return m_enable_subtitles_in_manifest_isValid;
}

bool OAITranscodingProfile::isEstimateContentLength() const {
    return m_estimate_content_length;
}
void OAITranscodingProfile::setEstimateContentLength(const bool &estimate_content_length) {
    m_estimate_content_length = estimate_content_length;
    m_estimate_content_length_isSet = true;
}

bool OAITranscodingProfile::is_estimate_content_length_Set() const{
    return m_estimate_content_length_isSet;
}

bool OAITranscodingProfile::is_estimate_content_length_Valid() const{
    return m_estimate_content_length_isValid;
}

QString OAITranscodingProfile::getMaxAudioChannels() const {
    return m_max_audio_channels;
}
void OAITranscodingProfile::setMaxAudioChannels(const QString &max_audio_channels) {
    m_max_audio_channels = max_audio_channels;
    m_max_audio_channels_isSet = true;
}

bool OAITranscodingProfile::is_max_audio_channels_Set() const{
    return m_max_audio_channels_isSet;
}

bool OAITranscodingProfile::is_max_audio_channels_Valid() const{
    return m_max_audio_channels_isValid;
}

qint32 OAITranscodingProfile::getMinSegments() const {
    return m_min_segments;
}
void OAITranscodingProfile::setMinSegments(const qint32 &min_segments) {
    m_min_segments = min_segments;
    m_min_segments_isSet = true;
}

bool OAITranscodingProfile::is_min_segments_Set() const{
    return m_min_segments_isSet;
}

bool OAITranscodingProfile::is_min_segments_Valid() const{
    return m_min_segments_isValid;
}

QString OAITranscodingProfile::getProtocol() const {
    return m_protocol;
}
void OAITranscodingProfile::setProtocol(const QString &protocol) {
    m_protocol = protocol;
    m_protocol_isSet = true;
}

bool OAITranscodingProfile::is_protocol_Set() const{
    return m_protocol_isSet;
}

bool OAITranscodingProfile::is_protocol_Valid() const{
    return m_protocol_isValid;
}

qint32 OAITranscodingProfile::getSegmentLength() const {
    return m_segment_length;
}
void OAITranscodingProfile::setSegmentLength(const qint32 &segment_length) {
    m_segment_length = segment_length;
    m_segment_length_isSet = true;
}

bool OAITranscodingProfile::is_segment_length_Set() const{
    return m_segment_length_isSet;
}

bool OAITranscodingProfile::is_segment_length_Valid() const{
    return m_segment_length_isValid;
}

OAITranscodeSeekInfo OAITranscodingProfile::getTranscodeSeekInfo() const {
    return m_transcode_seek_info;
}
void OAITranscodingProfile::setTranscodeSeekInfo(const OAITranscodeSeekInfo &transcode_seek_info) {
    m_transcode_seek_info = transcode_seek_info;
    m_transcode_seek_info_isSet = true;
}

bool OAITranscodingProfile::is_transcode_seek_info_Set() const{
    return m_transcode_seek_info_isSet;
}

bool OAITranscodingProfile::is_transcode_seek_info_Valid() const{
    return m_transcode_seek_info_isValid;
}

OAIDlnaProfileType OAITranscodingProfile::getType() const {
    return m_type;
}
void OAITranscodingProfile::setType(const OAIDlnaProfileType &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAITranscodingProfile::is_type_Set() const{
    return m_type_isSet;
}

bool OAITranscodingProfile::is_type_Valid() const{
    return m_type_isValid;
}

QString OAITranscodingProfile::getVideoCodec() const {
    return m_video_codec;
}
void OAITranscodingProfile::setVideoCodec(const QString &video_codec) {
    m_video_codec = video_codec;
    m_video_codec_isSet = true;
}

bool OAITranscodingProfile::is_video_codec_Set() const{
    return m_video_codec_isSet;
}

bool OAITranscodingProfile::is_video_codec_Valid() const{
    return m_video_codec_isValid;
}

bool OAITranscodingProfile::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_audio_codec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_break_on_non_key_frames_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_container_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_context.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_copy_timestamps_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_mpegts_m2_ts_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_subtitles_in_manifest_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_estimate_content_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_audio_channels_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_segments_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_segment_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transcode_seek_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_video_codec_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITranscodingProfile::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
