/*
 * trash nothing
 * This is the REST API for [trashnothing.com](https://trashnothing.com).  To learn more about the API or to register your app for use with the API visit the [trash nothing Developer page](https://trashnothing.com/developer).  NOTE: All date-time values are [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time) and are in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601) (eg. 2019-02-03T01:23:53). 
 *
 * The version of the OpenAPI document: 1.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UserFeedback
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:53:54.729444-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UserFeedback {
  public static final String SERIALIZED_NAME_PERCENT_POSITIVE = "percent_positive";
  @SerializedName(SERIALIZED_NAME_PERCENT_POSITIVE)
  private BigDecimal percentPositive;

  public static final String SERIALIZED_NAME_RESTRICTION = "restriction";
  @SerializedName(SERIALIZED_NAME_RESTRICTION)
  private String restriction;

  public static final String SERIALIZED_NAME_SCORE = "score";
  @SerializedName(SERIALIZED_NAME_SCORE)
  private Integer score;

  public UserFeedback() {
  }

  public UserFeedback percentPositive(BigDecimal percentPositive) {
    this.percentPositive = percentPositive;
    return this;
  }

  /**
   * The percent of feedback that this user has received in the last year that was positive. May be null if a user has not received enough feedback to calculate a percentage. 
   * minimum: 0
   * maximum: 100
   * @return percentPositive
   */
  @javax.annotation.Nullable
  public BigDecimal getPercentPositive() {
    return percentPositive;
  }

  public void setPercentPositive(BigDecimal percentPositive) {
    this.percentPositive = percentPositive;
  }


  public UserFeedback restriction(String restriction) {
    this.restriction = restriction;
    return this;
  }

  /**
   * If the current user can leave positive or negative feedback on this user then restriction is null. &lt;br /&gt;&lt;br /&gt; Otherwise, restriction is set to a string that explains why feedback is currently restricted and what type of feedback is restricted. The string will be one of the following:  no-recent-messages, negative-score, moderator, [days]-day-wait-for-negative &lt;br /&gt;&lt;br /&gt; - **no-recent-messages**: The current user has not received any messages from this user in the last 30 days. &lt;br /&gt; - **negative-score**: The current user has a negative feedback and will not be able to leave feedback until their score is &gt;&#x3D; 0. &lt;br /&gt; - **moderator**: The user is a moderator and leaving feedback on moderators is not currently supported. &lt;br /&gt; - **[days]-day-wait-for-negative**: Positive feedback is not restricted but the current user must wait   some number of days before they will be able to leave negative feedback on this user.  This string can    change depending on the number of days.  For example, when the current user must wait one day, the   string will be &#39;1-day-wait-for-negative&#39;.  A wait is necessary because a lot of negative feedback results   from communication issues that are resolved with more time. 
   * @return restriction
   */
  @javax.annotation.Nullable
  public String getRestriction() {
    return restriction;
  }

  public void setRestriction(String restriction) {
    this.restriction = restriction;
  }


  public UserFeedback score(Integer score) {
    this.score = score;
    return this;
  }

  /**
   * The feedback score of this user.  Higher scores are better.   Scores are calculated by substracting the total number of negative feedback from the total number of positive feedback that a user has received.  May be null if a user has not received enough feedback to calculate a score. 
   * @return score
   */
  @javax.annotation.Nullable
  public Integer getScore() {
    return score;
  }

  public void setScore(Integer score) {
    this.score = score;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UserFeedback userFeedback = (UserFeedback) o;
    return Objects.equals(this.percentPositive, userFeedback.percentPositive) &&
        Objects.equals(this.restriction, userFeedback.restriction) &&
        Objects.equals(this.score, userFeedback.score);
  }

  @Override
  public int hashCode() {
    return Objects.hash(percentPositive, restriction, score);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UserFeedback {\n");
    sb.append("    percentPositive: ").append(toIndentedString(percentPositive)).append("\n");
    sb.append("    restriction: ").append(toIndentedString(restriction)).append("\n");
    sb.append("    score: ").append(toIndentedString(score)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("percent_positive");
    openapiFields.add("restriction");
    openapiFields.add("score");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UserFeedback
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UserFeedback.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UserFeedback is not found in the empty JSON string", UserFeedback.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UserFeedback.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UserFeedback` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("restriction") != null && !jsonObj.get("restriction").isJsonNull()) && !jsonObj.get("restriction").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `restriction` to be a primitive type in the JSON string but got `%s`", jsonObj.get("restriction").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UserFeedback.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UserFeedback' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UserFeedback> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UserFeedback.class));

       return (TypeAdapter<T>) new TypeAdapter<UserFeedback>() {
           @Override
           public void write(JsonWriter out, UserFeedback value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UserFeedback read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UserFeedback given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UserFeedback
   * @throws IOException if the JSON string is invalid with respect to UserFeedback
   */
  public static UserFeedback fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UserFeedback.class);
  }

  /**
   * Convert an instance of UserFeedback to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

