/*
 * Microsoft.ResourceHealth
 * The Resource Health Client.
 *
 * The version of the OpenAPI document: 2018-07-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AvailabilityStatusPropertiesRecentlyResolved;
import org.openapitools.client.model.RecommendedAction;
import org.openapitools.client.model.ServiceImpactingEvent;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Properties of availability state.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:18:50.134798-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AvailabilityStatusProperties {
  /**
   * Availability status of the resource. When it is null, this availabilityStatus object represents an availability impacting event
   */
  @JsonAdapter(AvailabilityStateEnum.Adapter.class)
  public enum AvailabilityStateEnum {
    AVAILABLE("Available"),
    
    UNAVAILABLE("Unavailable"),
    
    DEGRADED("Degraded"),
    
    UNKNOWN("Unknown");

    private String value;

    AvailabilityStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AvailabilityStateEnum fromValue(String value) {
      for (AvailabilityStateEnum b : AvailabilityStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AvailabilityStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AvailabilityStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AvailabilityStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AvailabilityStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AvailabilityStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AVAILABILITY_STATE = "availabilityState";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_STATE)
  private AvailabilityStateEnum availabilityState;

  public static final String SERIALIZED_NAME_DETAILED_STATUS = "detailedStatus";
  @SerializedName(SERIALIZED_NAME_DETAILED_STATUS)
  private String detailedStatus;

  public static final String SERIALIZED_NAME_HEALTH_EVENT_CATEGORY = "healthEventCategory";
  @SerializedName(SERIALIZED_NAME_HEALTH_EVENT_CATEGORY)
  private String healthEventCategory;

  public static final String SERIALIZED_NAME_HEALTH_EVENT_CAUSE = "healthEventCause";
  @SerializedName(SERIALIZED_NAME_HEALTH_EVENT_CAUSE)
  private String healthEventCause;

  public static final String SERIALIZED_NAME_HEALTH_EVENT_ID = "healthEventId";
  @SerializedName(SERIALIZED_NAME_HEALTH_EVENT_ID)
  private String healthEventId;

  public static final String SERIALIZED_NAME_HEALTH_EVENT_TYPE = "healthEventType";
  @SerializedName(SERIALIZED_NAME_HEALTH_EVENT_TYPE)
  private String healthEventType;

  public static final String SERIALIZED_NAME_OCCURED_TIME = "occuredTime";
  @SerializedName(SERIALIZED_NAME_OCCURED_TIME)
  private OffsetDateTime occuredTime;

  /**
   * Chronicity of the availability transition.
   */
  @JsonAdapter(ReasonChronicityEnum.Adapter.class)
  public enum ReasonChronicityEnum {
    TRANSIENT("Transient"),
    
    PERSISTENT("Persistent");

    private String value;

    ReasonChronicityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReasonChronicityEnum fromValue(String value) {
      for (ReasonChronicityEnum b : ReasonChronicityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ReasonChronicityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReasonChronicityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReasonChronicityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ReasonChronicityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ReasonChronicityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REASON_CHRONICITY = "reasonChronicity";
  @SerializedName(SERIALIZED_NAME_REASON_CHRONICITY)
  private ReasonChronicityEnum reasonChronicity;

  public static final String SERIALIZED_NAME_REASON_TYPE = "reasonType";
  @SerializedName(SERIALIZED_NAME_REASON_TYPE)
  private String reasonType;

  public static final String SERIALIZED_NAME_RECENTLY_RESOLVED = "recentlyResolved";
  @SerializedName(SERIALIZED_NAME_RECENTLY_RESOLVED)
  private AvailabilityStatusPropertiesRecentlyResolved recentlyResolved;

  public static final String SERIALIZED_NAME_RECOMMENDED_ACTIONS = "recommendedActions";
  @SerializedName(SERIALIZED_NAME_RECOMMENDED_ACTIONS)
  private List<RecommendedAction> recommendedActions = new ArrayList<>();

  public static final String SERIALIZED_NAME_REPORTED_TIME = "reportedTime";
  @SerializedName(SERIALIZED_NAME_REPORTED_TIME)
  private OffsetDateTime reportedTime;

  public static final String SERIALIZED_NAME_RESOLUTION_E_T_A = "resolutionETA";
  @SerializedName(SERIALIZED_NAME_RESOLUTION_E_T_A)
  private OffsetDateTime resolutionETA;

  public static final String SERIALIZED_NAME_ROOT_CAUSE_ATTRIBUTION_TIME = "rootCauseAttributionTime";
  @SerializedName(SERIALIZED_NAME_ROOT_CAUSE_ATTRIBUTION_TIME)
  private OffsetDateTime rootCauseAttributionTime;

  public static final String SERIALIZED_NAME_SERVICE_IMPACTING_EVENTS = "serviceImpactingEvents";
  @SerializedName(SERIALIZED_NAME_SERVICE_IMPACTING_EVENTS)
  private List<ServiceImpactingEvent> serviceImpactingEvents = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUMMARY = "summary";
  @SerializedName(SERIALIZED_NAME_SUMMARY)
  private String summary;

  public AvailabilityStatusProperties() {
  }

  public AvailabilityStatusProperties availabilityState(AvailabilityStateEnum availabilityState) {
    this.availabilityState = availabilityState;
    return this;
  }

  /**
   * Availability status of the resource. When it is null, this availabilityStatus object represents an availability impacting event
   * @return availabilityState
   */
  @javax.annotation.Nullable
  public AvailabilityStateEnum getAvailabilityState() {
    return availabilityState;
  }

  public void setAvailabilityState(AvailabilityStateEnum availabilityState) {
    this.availabilityState = availabilityState;
  }


  public AvailabilityStatusProperties detailedStatus(String detailedStatus) {
    this.detailedStatus = detailedStatus;
    return this;
  }

  /**
   * Details of the availability status.
   * @return detailedStatus
   */
  @javax.annotation.Nullable
  public String getDetailedStatus() {
    return detailedStatus;
  }

  public void setDetailedStatus(String detailedStatus) {
    this.detailedStatus = detailedStatus;
  }


  public AvailabilityStatusProperties healthEventCategory(String healthEventCategory) {
    this.healthEventCategory = healthEventCategory;
    return this;
  }

  /**
   * In case of an availability impacting event, it describes the category of a PlatformInitiated health impacting event. Examples are Planned, Unplanned etc.
   * @return healthEventCategory
   */
  @javax.annotation.Nullable
  public String getHealthEventCategory() {
    return healthEventCategory;
  }

  public void setHealthEventCategory(String healthEventCategory) {
    this.healthEventCategory = healthEventCategory;
  }


  public AvailabilityStatusProperties healthEventCause(String healthEventCause) {
    this.healthEventCause = healthEventCause;
    return this;
  }

  /**
   * In case of an availability impacting event, it describes where the health impacting event was originated. Examples are PlatformInitiated, UserInitiated etc.
   * @return healthEventCause
   */
  @javax.annotation.Nullable
  public String getHealthEventCause() {
    return healthEventCause;
  }

  public void setHealthEventCause(String healthEventCause) {
    this.healthEventCause = healthEventCause;
  }


  public AvailabilityStatusProperties healthEventId(String healthEventId) {
    this.healthEventId = healthEventId;
    return this;
  }

  /**
   * It is a unique Id that identifies the event
   * @return healthEventId
   */
  @javax.annotation.Nullable
  public String getHealthEventId() {
    return healthEventId;
  }

  public void setHealthEventId(String healthEventId) {
    this.healthEventId = healthEventId;
  }


  public AvailabilityStatusProperties healthEventType(String healthEventType) {
    this.healthEventType = healthEventType;
    return this;
  }

  /**
   * In case of an availability impacting event, it describes when the health impacting event was originated. Examples are Lifecycle, Downtime, Fault Analysis etc.
   * @return healthEventType
   */
  @javax.annotation.Nullable
  public String getHealthEventType() {
    return healthEventType;
  }

  public void setHealthEventType(String healthEventType) {
    this.healthEventType = healthEventType;
  }


  public AvailabilityStatusProperties occuredTime(OffsetDateTime occuredTime) {
    this.occuredTime = occuredTime;
    return this;
  }

  /**
   * Timestamp for when last change in health status occurred.
   * @return occuredTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getOccuredTime() {
    return occuredTime;
  }

  public void setOccuredTime(OffsetDateTime occuredTime) {
    this.occuredTime = occuredTime;
  }


  public AvailabilityStatusProperties reasonChronicity(ReasonChronicityEnum reasonChronicity) {
    this.reasonChronicity = reasonChronicity;
    return this;
  }

  /**
   * Chronicity of the availability transition.
   * @return reasonChronicity
   */
  @javax.annotation.Nullable
  public ReasonChronicityEnum getReasonChronicity() {
    return reasonChronicity;
  }

  public void setReasonChronicity(ReasonChronicityEnum reasonChronicity) {
    this.reasonChronicity = reasonChronicity;
  }


  public AvailabilityStatusProperties reasonType(String reasonType) {
    this.reasonType = reasonType;
    return this;
  }

  /**
   * When the resource&#39;s availabilityState is Unavailable, it describes where the health impacting event was originated. Examples are planned, unplanned, user initiated or an outage etc.
   * @return reasonType
   */
  @javax.annotation.Nullable
  public String getReasonType() {
    return reasonType;
  }

  public void setReasonType(String reasonType) {
    this.reasonType = reasonType;
  }


  public AvailabilityStatusProperties recentlyResolved(AvailabilityStatusPropertiesRecentlyResolved recentlyResolved) {
    this.recentlyResolved = recentlyResolved;
    return this;
  }

  /**
   * Get recentlyResolved
   * @return recentlyResolved
   */
  @javax.annotation.Nullable
  public AvailabilityStatusPropertiesRecentlyResolved getRecentlyResolved() {
    return recentlyResolved;
  }

  public void setRecentlyResolved(AvailabilityStatusPropertiesRecentlyResolved recentlyResolved) {
    this.recentlyResolved = recentlyResolved;
  }


  public AvailabilityStatusProperties recommendedActions(List<RecommendedAction> recommendedActions) {
    this.recommendedActions = recommendedActions;
    return this;
  }

  public AvailabilityStatusProperties addRecommendedActionsItem(RecommendedAction recommendedActionsItem) {
    if (this.recommendedActions == null) {
      this.recommendedActions = new ArrayList<>();
    }
    this.recommendedActions.add(recommendedActionsItem);
    return this;
  }

  /**
   * Lists actions the user can take based on the current availabilityState of the resource.
   * @return recommendedActions
   */
  @javax.annotation.Nullable
  public List<RecommendedAction> getRecommendedActions() {
    return recommendedActions;
  }

  public void setRecommendedActions(List<RecommendedAction> recommendedActions) {
    this.recommendedActions = recommendedActions;
  }


  public AvailabilityStatusProperties reportedTime(OffsetDateTime reportedTime) {
    this.reportedTime = reportedTime;
    return this;
  }

  /**
   * Timestamp for when the health was last checked. 
   * @return reportedTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getReportedTime() {
    return reportedTime;
  }

  public void setReportedTime(OffsetDateTime reportedTime) {
    this.reportedTime = reportedTime;
  }


  public AvailabilityStatusProperties resolutionETA(OffsetDateTime resolutionETA) {
    this.resolutionETA = resolutionETA;
    return this;
  }

  /**
   * When the resource&#39;s availabilityState is Unavailable and the reasonType is not User Initiated, it provides the date and time for when the issue is expected to be resolved.
   * @return resolutionETA
   */
  @javax.annotation.Nullable
  public OffsetDateTime getResolutionETA() {
    return resolutionETA;
  }

  public void setResolutionETA(OffsetDateTime resolutionETA) {
    this.resolutionETA = resolutionETA;
  }


  public AvailabilityStatusProperties rootCauseAttributionTime(OffsetDateTime rootCauseAttributionTime) {
    this.rootCauseAttributionTime = rootCauseAttributionTime;
    return this;
  }

  /**
   * When the resource&#39;s availabilityState is Unavailable, it provides the Timestamp for when the health impacting event was received.
   * @return rootCauseAttributionTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRootCauseAttributionTime() {
    return rootCauseAttributionTime;
  }

  public void setRootCauseAttributionTime(OffsetDateTime rootCauseAttributionTime) {
    this.rootCauseAttributionTime = rootCauseAttributionTime;
  }


  public AvailabilityStatusProperties serviceImpactingEvents(List<ServiceImpactingEvent> serviceImpactingEvents) {
    this.serviceImpactingEvents = serviceImpactingEvents;
    return this;
  }

  public AvailabilityStatusProperties addServiceImpactingEventsItem(ServiceImpactingEvent serviceImpactingEventsItem) {
    if (this.serviceImpactingEvents == null) {
      this.serviceImpactingEvents = new ArrayList<>();
    }
    this.serviceImpactingEvents.add(serviceImpactingEventsItem);
    return this;
  }

  /**
   * Lists the service impacting events that may be affecting the health of the resource.
   * @return serviceImpactingEvents
   */
  @javax.annotation.Nullable
  public List<ServiceImpactingEvent> getServiceImpactingEvents() {
    return serviceImpactingEvents;
  }

  public void setServiceImpactingEvents(List<ServiceImpactingEvent> serviceImpactingEvents) {
    this.serviceImpactingEvents = serviceImpactingEvents;
  }


  public AvailabilityStatusProperties summary(String summary) {
    this.summary = summary;
    return this;
  }

  /**
   * Summary description of the availability status.
   * @return summary
   */
  @javax.annotation.Nullable
  public String getSummary() {
    return summary;
  }

  public void setSummary(String summary) {
    this.summary = summary;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AvailabilityStatusProperties availabilityStatusProperties = (AvailabilityStatusProperties) o;
    return Objects.equals(this.availabilityState, availabilityStatusProperties.availabilityState) &&
        Objects.equals(this.detailedStatus, availabilityStatusProperties.detailedStatus) &&
        Objects.equals(this.healthEventCategory, availabilityStatusProperties.healthEventCategory) &&
        Objects.equals(this.healthEventCause, availabilityStatusProperties.healthEventCause) &&
        Objects.equals(this.healthEventId, availabilityStatusProperties.healthEventId) &&
        Objects.equals(this.healthEventType, availabilityStatusProperties.healthEventType) &&
        Objects.equals(this.occuredTime, availabilityStatusProperties.occuredTime) &&
        Objects.equals(this.reasonChronicity, availabilityStatusProperties.reasonChronicity) &&
        Objects.equals(this.reasonType, availabilityStatusProperties.reasonType) &&
        Objects.equals(this.recentlyResolved, availabilityStatusProperties.recentlyResolved) &&
        Objects.equals(this.recommendedActions, availabilityStatusProperties.recommendedActions) &&
        Objects.equals(this.reportedTime, availabilityStatusProperties.reportedTime) &&
        Objects.equals(this.resolutionETA, availabilityStatusProperties.resolutionETA) &&
        Objects.equals(this.rootCauseAttributionTime, availabilityStatusProperties.rootCauseAttributionTime) &&
        Objects.equals(this.serviceImpactingEvents, availabilityStatusProperties.serviceImpactingEvents) &&
        Objects.equals(this.summary, availabilityStatusProperties.summary);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availabilityState, detailedStatus, healthEventCategory, healthEventCause, healthEventId, healthEventType, occuredTime, reasonChronicity, reasonType, recentlyResolved, recommendedActions, reportedTime, resolutionETA, rootCauseAttributionTime, serviceImpactingEvents, summary);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AvailabilityStatusProperties {\n");
    sb.append("    availabilityState: ").append(toIndentedString(availabilityState)).append("\n");
    sb.append("    detailedStatus: ").append(toIndentedString(detailedStatus)).append("\n");
    sb.append("    healthEventCategory: ").append(toIndentedString(healthEventCategory)).append("\n");
    sb.append("    healthEventCause: ").append(toIndentedString(healthEventCause)).append("\n");
    sb.append("    healthEventId: ").append(toIndentedString(healthEventId)).append("\n");
    sb.append("    healthEventType: ").append(toIndentedString(healthEventType)).append("\n");
    sb.append("    occuredTime: ").append(toIndentedString(occuredTime)).append("\n");
    sb.append("    reasonChronicity: ").append(toIndentedString(reasonChronicity)).append("\n");
    sb.append("    reasonType: ").append(toIndentedString(reasonType)).append("\n");
    sb.append("    recentlyResolved: ").append(toIndentedString(recentlyResolved)).append("\n");
    sb.append("    recommendedActions: ").append(toIndentedString(recommendedActions)).append("\n");
    sb.append("    reportedTime: ").append(toIndentedString(reportedTime)).append("\n");
    sb.append("    resolutionETA: ").append(toIndentedString(resolutionETA)).append("\n");
    sb.append("    rootCauseAttributionTime: ").append(toIndentedString(rootCauseAttributionTime)).append("\n");
    sb.append("    serviceImpactingEvents: ").append(toIndentedString(serviceImpactingEvents)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("availabilityState");
    openapiFields.add("detailedStatus");
    openapiFields.add("healthEventCategory");
    openapiFields.add("healthEventCause");
    openapiFields.add("healthEventId");
    openapiFields.add("healthEventType");
    openapiFields.add("occuredTime");
    openapiFields.add("reasonChronicity");
    openapiFields.add("reasonType");
    openapiFields.add("recentlyResolved");
    openapiFields.add("recommendedActions");
    openapiFields.add("reportedTime");
    openapiFields.add("resolutionETA");
    openapiFields.add("rootCauseAttributionTime");
    openapiFields.add("serviceImpactingEvents");
    openapiFields.add("summary");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AvailabilityStatusProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AvailabilityStatusProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AvailabilityStatusProperties is not found in the empty JSON string", AvailabilityStatusProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AvailabilityStatusProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AvailabilityStatusProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("availabilityState") != null && !jsonObj.get("availabilityState").isJsonNull()) && !jsonObj.get("availabilityState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availabilityState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availabilityState").toString()));
      }
      // validate the optional field `availabilityState`
      if (jsonObj.get("availabilityState") != null && !jsonObj.get("availabilityState").isJsonNull()) {
        AvailabilityStateEnum.validateJsonElement(jsonObj.get("availabilityState"));
      }
      if ((jsonObj.get("detailedStatus") != null && !jsonObj.get("detailedStatus").isJsonNull()) && !jsonObj.get("detailedStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `detailedStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("detailedStatus").toString()));
      }
      if ((jsonObj.get("healthEventCategory") != null && !jsonObj.get("healthEventCategory").isJsonNull()) && !jsonObj.get("healthEventCategory").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `healthEventCategory` to be a primitive type in the JSON string but got `%s`", jsonObj.get("healthEventCategory").toString()));
      }
      if ((jsonObj.get("healthEventCause") != null && !jsonObj.get("healthEventCause").isJsonNull()) && !jsonObj.get("healthEventCause").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `healthEventCause` to be a primitive type in the JSON string but got `%s`", jsonObj.get("healthEventCause").toString()));
      }
      if ((jsonObj.get("healthEventId") != null && !jsonObj.get("healthEventId").isJsonNull()) && !jsonObj.get("healthEventId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `healthEventId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("healthEventId").toString()));
      }
      if ((jsonObj.get("healthEventType") != null && !jsonObj.get("healthEventType").isJsonNull()) && !jsonObj.get("healthEventType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `healthEventType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("healthEventType").toString()));
      }
      if ((jsonObj.get("reasonChronicity") != null && !jsonObj.get("reasonChronicity").isJsonNull()) && !jsonObj.get("reasonChronicity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reasonChronicity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reasonChronicity").toString()));
      }
      // validate the optional field `reasonChronicity`
      if (jsonObj.get("reasonChronicity") != null && !jsonObj.get("reasonChronicity").isJsonNull()) {
        ReasonChronicityEnum.validateJsonElement(jsonObj.get("reasonChronicity"));
      }
      if ((jsonObj.get("reasonType") != null && !jsonObj.get("reasonType").isJsonNull()) && !jsonObj.get("reasonType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reasonType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reasonType").toString()));
      }
      // validate the optional field `recentlyResolved`
      if (jsonObj.get("recentlyResolved") != null && !jsonObj.get("recentlyResolved").isJsonNull()) {
        AvailabilityStatusPropertiesRecentlyResolved.validateJsonElement(jsonObj.get("recentlyResolved"));
      }
      if (jsonObj.get("recommendedActions") != null && !jsonObj.get("recommendedActions").isJsonNull()) {
        JsonArray jsonArrayrecommendedActions = jsonObj.getAsJsonArray("recommendedActions");
        if (jsonArrayrecommendedActions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("recommendedActions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `recommendedActions` to be an array in the JSON string but got `%s`", jsonObj.get("recommendedActions").toString()));
          }

          // validate the optional field `recommendedActions` (array)
          for (int i = 0; i < jsonArrayrecommendedActions.size(); i++) {
            RecommendedAction.validateJsonElement(jsonArrayrecommendedActions.get(i));
          };
        }
      }
      if (jsonObj.get("serviceImpactingEvents") != null && !jsonObj.get("serviceImpactingEvents").isJsonNull()) {
        JsonArray jsonArrayserviceImpactingEvents = jsonObj.getAsJsonArray("serviceImpactingEvents");
        if (jsonArrayserviceImpactingEvents != null) {
          // ensure the json data is an array
          if (!jsonObj.get("serviceImpactingEvents").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `serviceImpactingEvents` to be an array in the JSON string but got `%s`", jsonObj.get("serviceImpactingEvents").toString()));
          }

          // validate the optional field `serviceImpactingEvents` (array)
          for (int i = 0; i < jsonArrayserviceImpactingEvents.size(); i++) {
            ServiceImpactingEvent.validateJsonElement(jsonArrayserviceImpactingEvents.get(i));
          };
        }
      }
      if ((jsonObj.get("summary") != null && !jsonObj.get("summary").isJsonNull()) && !jsonObj.get("summary").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `summary` to be a primitive type in the JSON string but got `%s`", jsonObj.get("summary").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AvailabilityStatusProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AvailabilityStatusProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AvailabilityStatusProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AvailabilityStatusProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<AvailabilityStatusProperties>() {
           @Override
           public void write(JsonWriter out, AvailabilityStatusProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AvailabilityStatusProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AvailabilityStatusProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AvailabilityStatusProperties
   * @throws IOException if the JSON string is invalid with respect to AvailabilityStatusProperties
   */
  public static AvailabilityStatusProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AvailabilityStatusProperties.class);
  }

  /**
   * Convert an instance of AvailabilityStatusProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

