# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class ImportRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, database_name: str=None, edition: str=None, max_size_bytes: str=None, service_objective_name: str=None, administrator_login: str=None, administrator_login_password: str=None, authentication_type: str='SQL', storage_key: str=None, storage_key_type: str=None, storage_uri: str=None):
        """ImportRequest - a model defined in OpenAPI

        :param database_name: The database_name of this ImportRequest.
        :param edition: The edition of this ImportRequest.
        :param max_size_bytes: The max_size_bytes of this ImportRequest.
        :param service_objective_name: The service_objective_name of this ImportRequest.
        :param administrator_login: The administrator_login of this ImportRequest.
        :param administrator_login_password: The administrator_login_password of this ImportRequest.
        :param authentication_type: The authentication_type of this ImportRequest.
        :param storage_key: The storage_key of this ImportRequest.
        :param storage_key_type: The storage_key_type of this ImportRequest.
        :param storage_uri: The storage_uri of this ImportRequest.
        """
        self.openapi_types = {
            'database_name': str,
            'edition': str,
            'max_size_bytes': str,
            'service_objective_name': str,
            'administrator_login': str,
            'administrator_login_password': str,
            'authentication_type': str,
            'storage_key': str,
            'storage_key_type': str,
            'storage_uri': str
        }

        self.attribute_map = {
            'database_name': 'databaseName',
            'edition': 'edition',
            'max_size_bytes': 'maxSizeBytes',
            'service_objective_name': 'serviceObjectiveName',
            'administrator_login': 'administratorLogin',
            'administrator_login_password': 'administratorLoginPassword',
            'authentication_type': 'authenticationType',
            'storage_key': 'storageKey',
            'storage_key_type': 'storageKeyType',
            'storage_uri': 'storageUri'
        }

        self._database_name = database_name
        self._edition = edition
        self._max_size_bytes = max_size_bytes
        self._service_objective_name = service_objective_name
        self._administrator_login = administrator_login
        self._administrator_login_password = administrator_login_password
        self._authentication_type = authentication_type
        self._storage_key = storage_key
        self._storage_key_type = storage_key_type
        self._storage_uri = storage_uri

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ImportRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ImportRequest of this ImportRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def database_name(self):
        """Gets the database_name of this ImportRequest.

        The name of the database to import.

        :return: The database_name of this ImportRequest.
        :rtype: str
        """
        return self._database_name

    @database_name.setter
    def database_name(self, database_name):
        """Sets the database_name of this ImportRequest.

        The name of the database to import.

        :param database_name: The database_name of this ImportRequest.
        :type database_name: str
        """
        if database_name is None:
            raise ValueError("Invalid value for `database_name`, must not be `None`")

        self._database_name = database_name

    @property
    def edition(self):
        """Gets the edition of this ImportRequest.

        The edition for the database being created.    The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API or one of the following commands:    ```azurecli  az sql db list-editions -l <location> -o table  ````    ```powershell  Get-AzSqlServerServiceObjective -Location <location>  ````  

        :return: The edition of this ImportRequest.
        :rtype: str
        """
        return self._edition

    @edition.setter
    def edition(self, edition):
        """Sets the edition of this ImportRequest.

        The edition for the database being created.    The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API or one of the following commands:    ```azurecli  az sql db list-editions -l <location> -o table  ````    ```powershell  Get-AzSqlServerServiceObjective -Location <location>  ````  

        :param edition: The edition of this ImportRequest.
        :type edition: str
        """
        allowed_values = ["Web", "Business", "Basic", "Standard", "Premium", "PremiumRS", "Free", "Stretch", "DataWarehouse", "System", "System2", "GeneralPurpose", "BusinessCritical", "Hyperscale"]  # noqa: E501
        if edition not in allowed_values:
            raise ValueError(
                "Invalid value for `edition` ({0}), must be one of {1}"
                .format(edition, allowed_values)
            )

        self._edition = edition

    @property
    def max_size_bytes(self):
        """Gets the max_size_bytes of this ImportRequest.

        The maximum size for the newly imported database.

        :return: The max_size_bytes of this ImportRequest.
        :rtype: str
        """
        return self._max_size_bytes

    @max_size_bytes.setter
    def max_size_bytes(self, max_size_bytes):
        """Sets the max_size_bytes of this ImportRequest.

        The maximum size for the newly imported database.

        :param max_size_bytes: The max_size_bytes of this ImportRequest.
        :type max_size_bytes: str
        """
        if max_size_bytes is None:
            raise ValueError("Invalid value for `max_size_bytes`, must not be `None`")

        self._max_size_bytes = max_size_bytes

    @property
    def service_objective_name(self):
        """Gets the service_objective_name of this ImportRequest.

        The name of the service objective to assign to the database.

        :return: The service_objective_name of this ImportRequest.
        :rtype: str
        """
        return self._service_objective_name

    @service_objective_name.setter
    def service_objective_name(self, service_objective_name):
        """Sets the service_objective_name of this ImportRequest.

        The name of the service objective to assign to the database.

        :param service_objective_name: The service_objective_name of this ImportRequest.
        :type service_objective_name: str
        """
        allowed_values = ["System", "System0", "System1", "System2", "System3", "System4", "System2L", "System3L", "System4L", "Free", "Basic", "S0", "S1", "S2", "S3", "S4", "S6", "S7", "S9", "S12", "P1", "P2", "P3", "P4", "P6", "P11", "P15", "PRS1", "PRS2", "PRS4", "PRS6", "DW100", "DW200", "DW300", "DW400", "DW500", "DW600", "DW1000", "DW1200", "DW1000c", "DW1500", "DW1500c", "DW2000", "DW2000c", "DW3000", "DW2500c", "DW3000c", "DW6000", "DW5000c", "DW6000c", "DW7500c", "DW10000c", "DW15000c", "DW30000c", "DS100", "DS200", "DS300", "DS400", "DS500", "DS600", "DS1000", "DS1200", "DS1500", "DS2000", "ElasticPool"]  # noqa: E501
        if service_objective_name not in allowed_values:
            raise ValueError(
                "Invalid value for `service_objective_name` ({0}), must be one of {1}"
                .format(service_objective_name, allowed_values)
            )

        self._service_objective_name = service_objective_name

    @property
    def administrator_login(self):
        """Gets the administrator_login of this ImportRequest.

        The name of the SQL administrator.

        :return: The administrator_login of this ImportRequest.
        :rtype: str
        """
        return self._administrator_login

    @administrator_login.setter
    def administrator_login(self, administrator_login):
        """Sets the administrator_login of this ImportRequest.

        The name of the SQL administrator.

        :param administrator_login: The administrator_login of this ImportRequest.
        :type administrator_login: str
        """
        if administrator_login is None:
            raise ValueError("Invalid value for `administrator_login`, must not be `None`")

        self._administrator_login = administrator_login

    @property
    def administrator_login_password(self):
        """Gets the administrator_login_password of this ImportRequest.

        The password of the SQL administrator.

        :return: The administrator_login_password of this ImportRequest.
        :rtype: str
        """
        return self._administrator_login_password

    @administrator_login_password.setter
    def administrator_login_password(self, administrator_login_password):
        """Sets the administrator_login_password of this ImportRequest.

        The password of the SQL administrator.

        :param administrator_login_password: The administrator_login_password of this ImportRequest.
        :type administrator_login_password: str
        """
        if administrator_login_password is None:
            raise ValueError("Invalid value for `administrator_login_password`, must not be `None`")

        self._administrator_login_password = administrator_login_password

    @property
    def authentication_type(self):
        """Gets the authentication_type of this ImportRequest.

        The authentication type.

        :return: The authentication_type of this ImportRequest.
        :rtype: str
        """
        return self._authentication_type

    @authentication_type.setter
    def authentication_type(self, authentication_type):
        """Sets the authentication_type of this ImportRequest.

        The authentication type.

        :param authentication_type: The authentication_type of this ImportRequest.
        :type authentication_type: str
        """
        allowed_values = ["SQL", "ADPassword"]  # noqa: E501
        if authentication_type not in allowed_values:
            raise ValueError(
                "Invalid value for `authentication_type` ({0}), must be one of {1}"
                .format(authentication_type, allowed_values)
            )

        self._authentication_type = authentication_type

    @property
    def storage_key(self):
        """Gets the storage_key of this ImportRequest.

        The storage key to use.  If storage key type is SharedAccessKey, it must be preceded with a \"?.\"

        :return: The storage_key of this ImportRequest.
        :rtype: str
        """
        return self._storage_key

    @storage_key.setter
    def storage_key(self, storage_key):
        """Sets the storage_key of this ImportRequest.

        The storage key to use.  If storage key type is SharedAccessKey, it must be preceded with a \"?.\"

        :param storage_key: The storage_key of this ImportRequest.
        :type storage_key: str
        """
        if storage_key is None:
            raise ValueError("Invalid value for `storage_key`, must not be `None`")

        self._storage_key = storage_key

    @property
    def storage_key_type(self):
        """Gets the storage_key_type of this ImportRequest.

        The type of the storage key to use.

        :return: The storage_key_type of this ImportRequest.
        :rtype: str
        """
        return self._storage_key_type

    @storage_key_type.setter
    def storage_key_type(self, storage_key_type):
        """Sets the storage_key_type of this ImportRequest.

        The type of the storage key to use.

        :param storage_key_type: The storage_key_type of this ImportRequest.
        :type storage_key_type: str
        """
        allowed_values = ["StorageAccessKey", "SharedAccessKey"]  # noqa: E501
        if storage_key_type not in allowed_values:
            raise ValueError(
                "Invalid value for `storage_key_type` ({0}), must be one of {1}"
                .format(storage_key_type, allowed_values)
            )

        self._storage_key_type = storage_key_type

    @property
    def storage_uri(self):
        """Gets the storage_uri of this ImportRequest.

        The storage uri to use.

        :return: The storage_uri of this ImportRequest.
        :rtype: str
        """
        return self._storage_uri

    @storage_uri.setter
    def storage_uri(self, storage_uri):
        """Sets the storage_uri of this ImportRequest.

        The storage uri to use.

        :param storage_uri: The storage_uri of this ImportRequest.
        :type storage_uri: str
        """
        if storage_uri is None:
            raise ValueError("Invalid value for `storage_uri`, must not be `None`")

        self._storage_uri = storage_uri
