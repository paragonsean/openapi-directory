# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.transform import Transform
from openapi_server import util


class RulesEngineMatchCondition(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, negate_condition: bool=None, rules_engine_match_value: List[str]=None, rules_engine_match_variable: str=None, rules_engine_operator: str=None, selector: str=None, transforms: List[Transform]=None):
        """RulesEngineMatchCondition - a model defined in OpenAPI

        :param negate_condition: The negate_condition of this RulesEngineMatchCondition.
        :param rules_engine_match_value: The rules_engine_match_value of this RulesEngineMatchCondition.
        :param rules_engine_match_variable: The rules_engine_match_variable of this RulesEngineMatchCondition.
        :param rules_engine_operator: The rules_engine_operator of this RulesEngineMatchCondition.
        :param selector: The selector of this RulesEngineMatchCondition.
        :param transforms: The transforms of this RulesEngineMatchCondition.
        """
        self.openapi_types = {
            'negate_condition': bool,
            'rules_engine_match_value': List[str],
            'rules_engine_match_variable': str,
            'rules_engine_operator': str,
            'selector': str,
            'transforms': List[Transform]
        }

        self.attribute_map = {
            'negate_condition': 'negateCondition',
            'rules_engine_match_value': 'rulesEngineMatchValue',
            'rules_engine_match_variable': 'rulesEngineMatchVariable',
            'rules_engine_operator': 'rulesEngineOperator',
            'selector': 'selector',
            'transforms': 'transforms'
        }

        self._negate_condition = negate_condition
        self._rules_engine_match_value = rules_engine_match_value
        self._rules_engine_match_variable = rules_engine_match_variable
        self._rules_engine_operator = rules_engine_operator
        self._selector = selector
        self._transforms = transforms

    @classmethod
    def from_dict(cls, dikt: dict) -> 'RulesEngineMatchCondition':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The RulesEngineMatchCondition of this RulesEngineMatchCondition.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def negate_condition(self):
        """Gets the negate_condition of this RulesEngineMatchCondition.

        Describes if this is negate condition or not

        :return: The negate_condition of this RulesEngineMatchCondition.
        :rtype: bool
        """
        return self._negate_condition

    @negate_condition.setter
    def negate_condition(self, negate_condition):
        """Sets the negate_condition of this RulesEngineMatchCondition.

        Describes if this is negate condition or not

        :param negate_condition: The negate_condition of this RulesEngineMatchCondition.
        :type negate_condition: bool
        """

        self._negate_condition = negate_condition

    @property
    def rules_engine_match_value(self):
        """Gets the rules_engine_match_value of this RulesEngineMatchCondition.

        Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.

        :return: The rules_engine_match_value of this RulesEngineMatchCondition.
        :rtype: List[str]
        """
        return self._rules_engine_match_value

    @rules_engine_match_value.setter
    def rules_engine_match_value(self, rules_engine_match_value):
        """Sets the rules_engine_match_value of this RulesEngineMatchCondition.

        Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.

        :param rules_engine_match_value: The rules_engine_match_value of this RulesEngineMatchCondition.
        :type rules_engine_match_value: List[str]
        """
        if rules_engine_match_value is None:
            raise ValueError("Invalid value for `rules_engine_match_value`, must not be `None`")

        self._rules_engine_match_value = rules_engine_match_value

    @property
    def rules_engine_match_variable(self):
        """Gets the rules_engine_match_variable of this RulesEngineMatchCondition.

        Match Variable

        :return: The rules_engine_match_variable of this RulesEngineMatchCondition.
        :rtype: str
        """
        return self._rules_engine_match_variable

    @rules_engine_match_variable.setter
    def rules_engine_match_variable(self, rules_engine_match_variable):
        """Sets the rules_engine_match_variable of this RulesEngineMatchCondition.

        Match Variable

        :param rules_engine_match_variable: The rules_engine_match_variable of this RulesEngineMatchCondition.
        :type rules_engine_match_variable: str
        """
        allowed_values = ["IsMobile", "RemoteAddr", "RequestMethod", "QueryString", "PostArgs", "RequestUri", "RequestPath", "RequestFilename", "RequestFilenameExtension", "RequestHeader", "RequestBody", "RequestScheme"]  # noqa: E501
        if rules_engine_match_variable not in allowed_values:
            raise ValueError(
                "Invalid value for `rules_engine_match_variable` ({0}), must be one of {1}"
                .format(rules_engine_match_variable, allowed_values)
            )

        self._rules_engine_match_variable = rules_engine_match_variable

    @property
    def rules_engine_operator(self):
        """Gets the rules_engine_operator of this RulesEngineMatchCondition.

        Describes operator to apply to the match condition.

        :return: The rules_engine_operator of this RulesEngineMatchCondition.
        :rtype: str
        """
        return self._rules_engine_operator

    @rules_engine_operator.setter
    def rules_engine_operator(self, rules_engine_operator):
        """Sets the rules_engine_operator of this RulesEngineMatchCondition.

        Describes operator to apply to the match condition.

        :param rules_engine_operator: The rules_engine_operator of this RulesEngineMatchCondition.
        :type rules_engine_operator: str
        """
        allowed_values = ["Any", "IPMatch", "GeoMatch", "Equal", "Contains", "LessThan", "GreaterThan", "LessThanOrEqual", "GreaterThanOrEqual", "BeginsWith", "EndsWith"]  # noqa: E501
        if rules_engine_operator not in allowed_values:
            raise ValueError(
                "Invalid value for `rules_engine_operator` ({0}), must be one of {1}"
                .format(rules_engine_operator, allowed_values)
            )

        self._rules_engine_operator = rules_engine_operator

    @property
    def selector(self):
        """Gets the selector of this RulesEngineMatchCondition.

        Name of selector in RequestHeader or RequestBody to be matched

        :return: The selector of this RulesEngineMatchCondition.
        :rtype: str
        """
        return self._selector

    @selector.setter
    def selector(self, selector):
        """Sets the selector of this RulesEngineMatchCondition.

        Name of selector in RequestHeader or RequestBody to be matched

        :param selector: The selector of this RulesEngineMatchCondition.
        :type selector: str
        """

        self._selector = selector

    @property
    def transforms(self):
        """Gets the transforms of this RulesEngineMatchCondition.

        List of transforms

        :return: The transforms of this RulesEngineMatchCondition.
        :rtype: List[Transform]
        """
        return self._transforms

    @transforms.setter
    def transforms(self, transforms):
        """Sets the transforms of this RulesEngineMatchCondition.

        List of transforms

        :param transforms: The transforms of this RulesEngineMatchCondition.
        :type transforms: List[Transform]
        """

        self._transforms = transforms
