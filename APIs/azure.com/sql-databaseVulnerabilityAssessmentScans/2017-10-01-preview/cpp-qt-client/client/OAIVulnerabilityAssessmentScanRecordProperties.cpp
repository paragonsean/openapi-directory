/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2017-10-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVulnerabilityAssessmentScanRecordProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVulnerabilityAssessmentScanRecordProperties::OAIVulnerabilityAssessmentScanRecordProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVulnerabilityAssessmentScanRecordProperties::OAIVulnerabilityAssessmentScanRecordProperties() {
    this->initializeModel();
}

OAIVulnerabilityAssessmentScanRecordProperties::~OAIVulnerabilityAssessmentScanRecordProperties() {}

void OAIVulnerabilityAssessmentScanRecordProperties::initializeModel() {

    m_end_time_isSet = false;
    m_end_time_isValid = false;

    m_errors_isSet = false;
    m_errors_isValid = false;

    m_number_of_failed_security_checks_isSet = false;
    m_number_of_failed_security_checks_isValid = false;

    m_scan_id_isSet = false;
    m_scan_id_isValid = false;

    m_start_time_isSet = false;
    m_start_time_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_storage_container_path_isSet = false;
    m_storage_container_path_isValid = false;

    m_trigger_type_isSet = false;
    m_trigger_type_isValid = false;
}

void OAIVulnerabilityAssessmentScanRecordProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVulnerabilityAssessmentScanRecordProperties::fromJsonObject(QJsonObject json) {

    m_end_time_isValid = ::OpenAPI::fromJsonValue(m_end_time, json[QString("endTime")]);
    m_end_time_isSet = !json[QString("endTime")].isNull() && m_end_time_isValid;

    m_errors_isValid = ::OpenAPI::fromJsonValue(m_errors, json[QString("errors")]);
    m_errors_isSet = !json[QString("errors")].isNull() && m_errors_isValid;

    m_number_of_failed_security_checks_isValid = ::OpenAPI::fromJsonValue(m_number_of_failed_security_checks, json[QString("numberOfFailedSecurityChecks")]);
    m_number_of_failed_security_checks_isSet = !json[QString("numberOfFailedSecurityChecks")].isNull() && m_number_of_failed_security_checks_isValid;

    m_scan_id_isValid = ::OpenAPI::fromJsonValue(m_scan_id, json[QString("scanId")]);
    m_scan_id_isSet = !json[QString("scanId")].isNull() && m_scan_id_isValid;

    m_start_time_isValid = ::OpenAPI::fromJsonValue(m_start_time, json[QString("startTime")]);
    m_start_time_isSet = !json[QString("startTime")].isNull() && m_start_time_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_storage_container_path_isValid = ::OpenAPI::fromJsonValue(m_storage_container_path, json[QString("storageContainerPath")]);
    m_storage_container_path_isSet = !json[QString("storageContainerPath")].isNull() && m_storage_container_path_isValid;

    m_trigger_type_isValid = ::OpenAPI::fromJsonValue(m_trigger_type, json[QString("triggerType")]);
    m_trigger_type_isSet = !json[QString("triggerType")].isNull() && m_trigger_type_isValid;
}

QString OAIVulnerabilityAssessmentScanRecordProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVulnerabilityAssessmentScanRecordProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_end_time_isSet) {
        obj.insert(QString("endTime"), ::OpenAPI::toJsonValue(m_end_time));
    }
    if (m_errors.size() > 0) {
        obj.insert(QString("errors"), ::OpenAPI::toJsonValue(m_errors));
    }
    if (m_number_of_failed_security_checks_isSet) {
        obj.insert(QString("numberOfFailedSecurityChecks"), ::OpenAPI::toJsonValue(m_number_of_failed_security_checks));
    }
    if (m_scan_id_isSet) {
        obj.insert(QString("scanId"), ::OpenAPI::toJsonValue(m_scan_id));
    }
    if (m_start_time_isSet) {
        obj.insert(QString("startTime"), ::OpenAPI::toJsonValue(m_start_time));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_storage_container_path_isSet) {
        obj.insert(QString("storageContainerPath"), ::OpenAPI::toJsonValue(m_storage_container_path));
    }
    if (m_trigger_type_isSet) {
        obj.insert(QString("triggerType"), ::OpenAPI::toJsonValue(m_trigger_type));
    }
    return obj;
}

QDateTime OAIVulnerabilityAssessmentScanRecordProperties::getEndTime() const {
    return m_end_time;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setEndTime(const QDateTime &end_time) {
    m_end_time = end_time;
    m_end_time_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_end_time_Set() const{
    return m_end_time_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_end_time_Valid() const{
    return m_end_time_isValid;
}

QList<OAIVulnerabilityAssessmentScanError> OAIVulnerabilityAssessmentScanRecordProperties::getErrors() const {
    return m_errors;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setErrors(const QList<OAIVulnerabilityAssessmentScanError> &errors) {
    m_errors = errors;
    m_errors_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_errors_Set() const{
    return m_errors_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_errors_Valid() const{
    return m_errors_isValid;
}

qint32 OAIVulnerabilityAssessmentScanRecordProperties::getNumberOfFailedSecurityChecks() const {
    return m_number_of_failed_security_checks;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setNumberOfFailedSecurityChecks(const qint32 &number_of_failed_security_checks) {
    m_number_of_failed_security_checks = number_of_failed_security_checks;
    m_number_of_failed_security_checks_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_number_of_failed_security_checks_Set() const{
    return m_number_of_failed_security_checks_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_number_of_failed_security_checks_Valid() const{
    return m_number_of_failed_security_checks_isValid;
}

QString OAIVulnerabilityAssessmentScanRecordProperties::getScanId() const {
    return m_scan_id;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setScanId(const QString &scan_id) {
    m_scan_id = scan_id;
    m_scan_id_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_scan_id_Set() const{
    return m_scan_id_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_scan_id_Valid() const{
    return m_scan_id_isValid;
}

QDateTime OAIVulnerabilityAssessmentScanRecordProperties::getStartTime() const {
    return m_start_time;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setStartTime(const QDateTime &start_time) {
    m_start_time = start_time;
    m_start_time_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_start_time_Set() const{
    return m_start_time_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_start_time_Valid() const{
    return m_start_time_isValid;
}

QString OAIVulnerabilityAssessmentScanRecordProperties::getState() const {
    return m_state;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_state_Set() const{
    return m_state_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_state_Valid() const{
    return m_state_isValid;
}

QString OAIVulnerabilityAssessmentScanRecordProperties::getStorageContainerPath() const {
    return m_storage_container_path;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setStorageContainerPath(const QString &storage_container_path) {
    m_storage_container_path = storage_container_path;
    m_storage_container_path_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_storage_container_path_Set() const{
    return m_storage_container_path_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_storage_container_path_Valid() const{
    return m_storage_container_path_isValid;
}

QString OAIVulnerabilityAssessmentScanRecordProperties::getTriggerType() const {
    return m_trigger_type;
}
void OAIVulnerabilityAssessmentScanRecordProperties::setTriggerType(const QString &trigger_type) {
    m_trigger_type = trigger_type;
    m_trigger_type_isSet = true;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_trigger_type_Set() const{
    return m_trigger_type_isSet;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::is_trigger_type_Valid() const{
    return m_trigger_type_isValid;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_end_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_errors.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_number_of_failed_security_checks_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scan_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_storage_container_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_trigger_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVulnerabilityAssessmentScanRecordProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
