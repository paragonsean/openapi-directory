/**
 * ConsumptionManagementClient
 * Consumption management client provides access to consumption resources for Azure Enterprise Subscriptions.
 *
 * The version of the OpenAPI document: 2019-04-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIReservationRecommendationProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIReservationRecommendationProperties::OAIReservationRecommendationProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIReservationRecommendationProperties::OAIReservationRecommendationProperties() {
    this->initializeModel();
}

OAIReservationRecommendationProperties::~OAIReservationRecommendationProperties() {}

void OAIReservationRecommendationProperties::initializeModel() {

    m_cost_with_no_reserved_instances_isSet = false;
    m_cost_with_no_reserved_instances_isValid = false;

    m_first_usage_date_isSet = false;
    m_first_usage_date_isValid = false;

    m_look_back_period_isSet = false;
    m_look_back_period_isValid = false;

    m_meter_id_isSet = false;
    m_meter_id_isValid = false;

    m_net_savings_isSet = false;
    m_net_savings_isValid = false;

    m_recommended_quantity_isSet = false;
    m_recommended_quantity_isValid = false;

    m_scope_isSet = false;
    m_scope_isValid = false;

    m_term_isSet = false;
    m_term_isValid = false;

    m_total_cost_with_reserved_instances_isSet = false;
    m_total_cost_with_reserved_instances_isValid = false;
}

void OAIReservationRecommendationProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIReservationRecommendationProperties::fromJsonObject(QJsonObject json) {

    m_cost_with_no_reserved_instances_isValid = ::OpenAPI::fromJsonValue(m_cost_with_no_reserved_instances, json[QString("costWithNoReservedInstances")]);
    m_cost_with_no_reserved_instances_isSet = !json[QString("costWithNoReservedInstances")].isNull() && m_cost_with_no_reserved_instances_isValid;

    m_first_usage_date_isValid = ::OpenAPI::fromJsonValue(m_first_usage_date, json[QString("firstUsageDate")]);
    m_first_usage_date_isSet = !json[QString("firstUsageDate")].isNull() && m_first_usage_date_isValid;

    m_look_back_period_isValid = ::OpenAPI::fromJsonValue(m_look_back_period, json[QString("lookBackPeriod")]);
    m_look_back_period_isSet = !json[QString("lookBackPeriod")].isNull() && m_look_back_period_isValid;

    m_meter_id_isValid = ::OpenAPI::fromJsonValue(m_meter_id, json[QString("meterId")]);
    m_meter_id_isSet = !json[QString("meterId")].isNull() && m_meter_id_isValid;

    m_net_savings_isValid = ::OpenAPI::fromJsonValue(m_net_savings, json[QString("netSavings")]);
    m_net_savings_isSet = !json[QString("netSavings")].isNull() && m_net_savings_isValid;

    m_recommended_quantity_isValid = ::OpenAPI::fromJsonValue(m_recommended_quantity, json[QString("recommendedQuantity")]);
    m_recommended_quantity_isSet = !json[QString("recommendedQuantity")].isNull() && m_recommended_quantity_isValid;

    m_scope_isValid = ::OpenAPI::fromJsonValue(m_scope, json[QString("scope")]);
    m_scope_isSet = !json[QString("scope")].isNull() && m_scope_isValid;

    m_term_isValid = ::OpenAPI::fromJsonValue(m_term, json[QString("term")]);
    m_term_isSet = !json[QString("term")].isNull() && m_term_isValid;

    m_total_cost_with_reserved_instances_isValid = ::OpenAPI::fromJsonValue(m_total_cost_with_reserved_instances, json[QString("totalCostWithReservedInstances")]);
    m_total_cost_with_reserved_instances_isSet = !json[QString("totalCostWithReservedInstances")].isNull() && m_total_cost_with_reserved_instances_isValid;
}

QString OAIReservationRecommendationProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIReservationRecommendationProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_cost_with_no_reserved_instances_isSet) {
        obj.insert(QString("costWithNoReservedInstances"), ::OpenAPI::toJsonValue(m_cost_with_no_reserved_instances));
    }
    if (m_first_usage_date_isSet) {
        obj.insert(QString("firstUsageDate"), ::OpenAPI::toJsonValue(m_first_usage_date));
    }
    if (m_look_back_period_isSet) {
        obj.insert(QString("lookBackPeriod"), ::OpenAPI::toJsonValue(m_look_back_period));
    }
    if (m_meter_id_isSet) {
        obj.insert(QString("meterId"), ::OpenAPI::toJsonValue(m_meter_id));
    }
    if (m_net_savings_isSet) {
        obj.insert(QString("netSavings"), ::OpenAPI::toJsonValue(m_net_savings));
    }
    if (m_recommended_quantity_isSet) {
        obj.insert(QString("recommendedQuantity"), ::OpenAPI::toJsonValue(m_recommended_quantity));
    }
    if (m_scope_isSet) {
        obj.insert(QString("scope"), ::OpenAPI::toJsonValue(m_scope));
    }
    if (m_term_isSet) {
        obj.insert(QString("term"), ::OpenAPI::toJsonValue(m_term));
    }
    if (m_total_cost_with_reserved_instances_isSet) {
        obj.insert(QString("totalCostWithReservedInstances"), ::OpenAPI::toJsonValue(m_total_cost_with_reserved_instances));
    }
    return obj;
}

double OAIReservationRecommendationProperties::getCostWithNoReservedInstances() const {
    return m_cost_with_no_reserved_instances;
}
void OAIReservationRecommendationProperties::setCostWithNoReservedInstances(const double &cost_with_no_reserved_instances) {
    m_cost_with_no_reserved_instances = cost_with_no_reserved_instances;
    m_cost_with_no_reserved_instances_isSet = true;
}

bool OAIReservationRecommendationProperties::is_cost_with_no_reserved_instances_Set() const{
    return m_cost_with_no_reserved_instances_isSet;
}

bool OAIReservationRecommendationProperties::is_cost_with_no_reserved_instances_Valid() const{
    return m_cost_with_no_reserved_instances_isValid;
}

QDateTime OAIReservationRecommendationProperties::getFirstUsageDate() const {
    return m_first_usage_date;
}
void OAIReservationRecommendationProperties::setFirstUsageDate(const QDateTime &first_usage_date) {
    m_first_usage_date = first_usage_date;
    m_first_usage_date_isSet = true;
}

bool OAIReservationRecommendationProperties::is_first_usage_date_Set() const{
    return m_first_usage_date_isSet;
}

bool OAIReservationRecommendationProperties::is_first_usage_date_Valid() const{
    return m_first_usage_date_isValid;
}

QString OAIReservationRecommendationProperties::getLookBackPeriod() const {
    return m_look_back_period;
}
void OAIReservationRecommendationProperties::setLookBackPeriod(const QString &look_back_period) {
    m_look_back_period = look_back_period;
    m_look_back_period_isSet = true;
}

bool OAIReservationRecommendationProperties::is_look_back_period_Set() const{
    return m_look_back_period_isSet;
}

bool OAIReservationRecommendationProperties::is_look_back_period_Valid() const{
    return m_look_back_period_isValid;
}

QString OAIReservationRecommendationProperties::getMeterId() const {
    return m_meter_id;
}
void OAIReservationRecommendationProperties::setMeterId(const QString &meter_id) {
    m_meter_id = meter_id;
    m_meter_id_isSet = true;
}

bool OAIReservationRecommendationProperties::is_meter_id_Set() const{
    return m_meter_id_isSet;
}

bool OAIReservationRecommendationProperties::is_meter_id_Valid() const{
    return m_meter_id_isValid;
}

double OAIReservationRecommendationProperties::getNetSavings() const {
    return m_net_savings;
}
void OAIReservationRecommendationProperties::setNetSavings(const double &net_savings) {
    m_net_savings = net_savings;
    m_net_savings_isSet = true;
}

bool OAIReservationRecommendationProperties::is_net_savings_Set() const{
    return m_net_savings_isSet;
}

bool OAIReservationRecommendationProperties::is_net_savings_Valid() const{
    return m_net_savings_isValid;
}

double OAIReservationRecommendationProperties::getRecommendedQuantity() const {
    return m_recommended_quantity;
}
void OAIReservationRecommendationProperties::setRecommendedQuantity(const double &recommended_quantity) {
    m_recommended_quantity = recommended_quantity;
    m_recommended_quantity_isSet = true;
}

bool OAIReservationRecommendationProperties::is_recommended_quantity_Set() const{
    return m_recommended_quantity_isSet;
}

bool OAIReservationRecommendationProperties::is_recommended_quantity_Valid() const{
    return m_recommended_quantity_isValid;
}

QString OAIReservationRecommendationProperties::getScope() const {
    return m_scope;
}
void OAIReservationRecommendationProperties::setScope(const QString &scope) {
    m_scope = scope;
    m_scope_isSet = true;
}

bool OAIReservationRecommendationProperties::is_scope_Set() const{
    return m_scope_isSet;
}

bool OAIReservationRecommendationProperties::is_scope_Valid() const{
    return m_scope_isValid;
}

QString OAIReservationRecommendationProperties::getTerm() const {
    return m_term;
}
void OAIReservationRecommendationProperties::setTerm(const QString &term) {
    m_term = term;
    m_term_isSet = true;
}

bool OAIReservationRecommendationProperties::is_term_Set() const{
    return m_term_isSet;
}

bool OAIReservationRecommendationProperties::is_term_Valid() const{
    return m_term_isValid;
}

double OAIReservationRecommendationProperties::getTotalCostWithReservedInstances() const {
    return m_total_cost_with_reserved_instances;
}
void OAIReservationRecommendationProperties::setTotalCostWithReservedInstances(const double &total_cost_with_reserved_instances) {
    m_total_cost_with_reserved_instances = total_cost_with_reserved_instances;
    m_total_cost_with_reserved_instances_isSet = true;
}

bool OAIReservationRecommendationProperties::is_total_cost_with_reserved_instances_Set() const{
    return m_total_cost_with_reserved_instances_isSet;
}

bool OAIReservationRecommendationProperties::is_total_cost_with_reserved_instances_Valid() const{
    return m_total_cost_with_reserved_instances_isValid;
}

bool OAIReservationRecommendationProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cost_with_no_reserved_instances_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_first_usage_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_look_back_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_meter_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_net_savings_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_recommended_quantity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scope_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_term_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_cost_with_reserved_instances_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIReservationRecommendationProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
