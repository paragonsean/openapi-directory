/*
 * BatchService
 * A client for issuing REST requests to the Azure Batch service.
 *
 * The version of the OpenAPI document: 2018-12-01.8.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ResourceFile
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:36:31.436898-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ResourceFile {
  public static final String SERIALIZED_NAME_AUTO_STORAGE_CONTAINER_NAME = "autoStorageContainerName";
  @SerializedName(SERIALIZED_NAME_AUTO_STORAGE_CONTAINER_NAME)
  private String autoStorageContainerName;

  public static final String SERIALIZED_NAME_BLOB_PREFIX = "blobPrefix";
  @SerializedName(SERIALIZED_NAME_BLOB_PREFIX)
  private String blobPrefix;

  public static final String SERIALIZED_NAME_FILE_MODE = "fileMode";
  @SerializedName(SERIALIZED_NAME_FILE_MODE)
  private String fileMode;

  public static final String SERIALIZED_NAME_FILE_PATH = "filePath";
  @SerializedName(SERIALIZED_NAME_FILE_PATH)
  private String filePath;

  public static final String SERIALIZED_NAME_HTTP_URL = "httpUrl";
  @SerializedName(SERIALIZED_NAME_HTTP_URL)
  private String httpUrl;

  public static final String SERIALIZED_NAME_STORAGE_CONTAINER_URL = "storageContainerUrl";
  @SerializedName(SERIALIZED_NAME_STORAGE_CONTAINER_URL)
  private String storageContainerUrl;

  public ResourceFile() {
  }

  public ResourceFile autoStorageContainerName(String autoStorageContainerName) {
    this.autoStorageContainerName = autoStorageContainerName;
    return this;
  }

  /**
   * The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified.
   * @return autoStorageContainerName
   */
  @javax.annotation.Nullable
  public String getAutoStorageContainerName() {
    return autoStorageContainerName;
  }

  public void setAutoStorageContainerName(String autoStorageContainerName) {
    this.autoStorageContainerName = autoStorageContainerName;
  }


  public ResourceFile blobPrefix(String blobPrefix) {
    this.blobPrefix = blobPrefix;
    return this;
  }

  /**
   * The property is valid only when autoStorageContainerName or storageContainerUrl is used. This prefix can be a partial filename or a subdirectory. If a prefix is not specified, all the files in the container will be downloaded.
   * @return blobPrefix
   */
  @javax.annotation.Nullable
  public String getBlobPrefix() {
    return blobPrefix;
  }

  public void setBlobPrefix(String blobPrefix) {
    this.blobPrefix = blobPrefix;
  }


  public ResourceFile fileMode(String fileMode) {
    this.fileMode = fileMode;
    return this;
  }

  /**
   * This property applies only to files being downloaded to Linux compute nodes. It will be ignored if it is specified for a resourceFile which will be downloaded to a Windows node. If this property is not specified for a Linux node, then a default value of 0770 is applied to the file.
   * @return fileMode
   */
  @javax.annotation.Nullable
  public String getFileMode() {
    return fileMode;
  }

  public void setFileMode(String fileMode) {
    this.fileMode = fileMode;
  }


  public ResourceFile filePath(String filePath) {
    this.filePath = filePath;
    return this;
  }

  /**
   * If the httpUrl property is specified, the filePath is required and describes the path which the file will be downloaded to, including the filename. Otherwise, if the autoStorageContainerName or storageContainerUrl property is specified, filePath is optional and is the directory to download the files to. In the case where filePath is used as a directory, any directory structure already associated with the input data will be retained in full and appended to the specified filePath directory. The specified relative path cannot break out of the task&#39;s working directory (for example by using &#39;..&#39;).
   * @return filePath
   */
  @javax.annotation.Nullable
  public String getFilePath() {
    return filePath;
  }

  public void setFilePath(String filePath) {
    this.filePath = filePath;
  }


  public ResourceFile httpUrl(String httpUrl) {
    this.httpUrl = httpUrl;
    return this;
  }

  /**
   * The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified. If the URL points to Azure Blob Storage, it must be readable using anonymous access; that is, the Batch service does not present any credentials when downloading the blob. There are two ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read permissions on the blob, or set the ACL for the blob or its container to allow public access.
   * @return httpUrl
   */
  @javax.annotation.Nullable
  public String getHttpUrl() {
    return httpUrl;
  }

  public void setHttpUrl(String httpUrl) {
    this.httpUrl = httpUrl;
  }


  public ResourceFile storageContainerUrl(String storageContainerUrl) {
    this.storageContainerUrl = storageContainerUrl;
    return this;
  }

  /**
   * The autoStorageContainerName, storageContainerUrl and httpUrl properties are mutually exclusive and one of them must be specified. This URL must be readable and listable using anonymous access; that is, the Batch service does not present any credentials when downloading blobs from the container. There are two ways to get such a URL for a container in Azure storage: include a Shared Access Signature (SAS) granting read and list permissions on the container, or set the ACL for the container to allow public access.
   * @return storageContainerUrl
   */
  @javax.annotation.Nullable
  public String getStorageContainerUrl() {
    return storageContainerUrl;
  }

  public void setStorageContainerUrl(String storageContainerUrl) {
    this.storageContainerUrl = storageContainerUrl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResourceFile resourceFile = (ResourceFile) o;
    return Objects.equals(this.autoStorageContainerName, resourceFile.autoStorageContainerName) &&
        Objects.equals(this.blobPrefix, resourceFile.blobPrefix) &&
        Objects.equals(this.fileMode, resourceFile.fileMode) &&
        Objects.equals(this.filePath, resourceFile.filePath) &&
        Objects.equals(this.httpUrl, resourceFile.httpUrl) &&
        Objects.equals(this.storageContainerUrl, resourceFile.storageContainerUrl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoStorageContainerName, blobPrefix, fileMode, filePath, httpUrl, storageContainerUrl);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResourceFile {\n");
    sb.append("    autoStorageContainerName: ").append(toIndentedString(autoStorageContainerName)).append("\n");
    sb.append("    blobPrefix: ").append(toIndentedString(blobPrefix)).append("\n");
    sb.append("    fileMode: ").append(toIndentedString(fileMode)).append("\n");
    sb.append("    filePath: ").append(toIndentedString(filePath)).append("\n");
    sb.append("    httpUrl: ").append(toIndentedString(httpUrl)).append("\n");
    sb.append("    storageContainerUrl: ").append(toIndentedString(storageContainerUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoStorageContainerName");
    openapiFields.add("blobPrefix");
    openapiFields.add("fileMode");
    openapiFields.add("filePath");
    openapiFields.add("httpUrl");
    openapiFields.add("storageContainerUrl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ResourceFile
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ResourceFile.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ResourceFile is not found in the empty JSON string", ResourceFile.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ResourceFile.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ResourceFile` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("autoStorageContainerName") != null && !jsonObj.get("autoStorageContainerName").isJsonNull()) && !jsonObj.get("autoStorageContainerName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoStorageContainerName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoStorageContainerName").toString()));
      }
      if ((jsonObj.get("blobPrefix") != null && !jsonObj.get("blobPrefix").isJsonNull()) && !jsonObj.get("blobPrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `blobPrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("blobPrefix").toString()));
      }
      if ((jsonObj.get("fileMode") != null && !jsonObj.get("fileMode").isJsonNull()) && !jsonObj.get("fileMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileMode").toString()));
      }
      if ((jsonObj.get("filePath") != null && !jsonObj.get("filePath").isJsonNull()) && !jsonObj.get("filePath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filePath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filePath").toString()));
      }
      if ((jsonObj.get("httpUrl") != null && !jsonObj.get("httpUrl").isJsonNull()) && !jsonObj.get("httpUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `httpUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("httpUrl").toString()));
      }
      if ((jsonObj.get("storageContainerUrl") != null && !jsonObj.get("storageContainerUrl").isJsonNull()) && !jsonObj.get("storageContainerUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageContainerUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageContainerUrl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ResourceFile.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ResourceFile' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ResourceFile> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ResourceFile.class));

       return (TypeAdapter<T>) new TypeAdapter<ResourceFile>() {
           @Override
           public void write(JsonWriter out, ResourceFile value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ResourceFile read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ResourceFile given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ResourceFile
   * @throws IOException if the JSON string is invalid with respect to ResourceFile
   */
  public static ResourceFile fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ResourceFile.class);
  }

  /**
   * Convert an instance of ResourceFile to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

