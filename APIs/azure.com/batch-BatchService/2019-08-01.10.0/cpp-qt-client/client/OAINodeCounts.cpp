/**
 * BatchService
 * A client for issuing REST requests to the Azure Batch service.
 *
 * The version of the OpenAPI document: 2019-08-01.10.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINodeCounts.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINodeCounts::OAINodeCounts(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINodeCounts::OAINodeCounts() {
    this->initializeModel();
}

OAINodeCounts::~OAINodeCounts() {}

void OAINodeCounts::initializeModel() {

    m_creating_isSet = false;
    m_creating_isValid = false;

    m_idle_isSet = false;
    m_idle_isValid = false;

    m_leaving_pool_isSet = false;
    m_leaving_pool_isValid = false;

    m_offline_isSet = false;
    m_offline_isValid = false;

    m_preempted_isSet = false;
    m_preempted_isValid = false;

    m_rebooting_isSet = false;
    m_rebooting_isValid = false;

    m_reimaging_isSet = false;
    m_reimaging_isValid = false;

    m_running_isSet = false;
    m_running_isValid = false;

    m_start_task_failed_isSet = false;
    m_start_task_failed_isValid = false;

    m_starting_isSet = false;
    m_starting_isValid = false;

    m_total_isSet = false;
    m_total_isValid = false;

    m_unknown_isSet = false;
    m_unknown_isValid = false;

    m_unusable_isSet = false;
    m_unusable_isValid = false;

    m_waiting_for_start_task_isSet = false;
    m_waiting_for_start_task_isValid = false;
}

void OAINodeCounts::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINodeCounts::fromJsonObject(QJsonObject json) {

    m_creating_isValid = ::OpenAPI::fromJsonValue(m_creating, json[QString("creating")]);
    m_creating_isSet = !json[QString("creating")].isNull() && m_creating_isValid;

    m_idle_isValid = ::OpenAPI::fromJsonValue(m_idle, json[QString("idle")]);
    m_idle_isSet = !json[QString("idle")].isNull() && m_idle_isValid;

    m_leaving_pool_isValid = ::OpenAPI::fromJsonValue(m_leaving_pool, json[QString("leavingPool")]);
    m_leaving_pool_isSet = !json[QString("leavingPool")].isNull() && m_leaving_pool_isValid;

    m_offline_isValid = ::OpenAPI::fromJsonValue(m_offline, json[QString("offline")]);
    m_offline_isSet = !json[QString("offline")].isNull() && m_offline_isValid;

    m_preempted_isValid = ::OpenAPI::fromJsonValue(m_preempted, json[QString("preempted")]);
    m_preempted_isSet = !json[QString("preempted")].isNull() && m_preempted_isValid;

    m_rebooting_isValid = ::OpenAPI::fromJsonValue(m_rebooting, json[QString("rebooting")]);
    m_rebooting_isSet = !json[QString("rebooting")].isNull() && m_rebooting_isValid;

    m_reimaging_isValid = ::OpenAPI::fromJsonValue(m_reimaging, json[QString("reimaging")]);
    m_reimaging_isSet = !json[QString("reimaging")].isNull() && m_reimaging_isValid;

    m_running_isValid = ::OpenAPI::fromJsonValue(m_running, json[QString("running")]);
    m_running_isSet = !json[QString("running")].isNull() && m_running_isValid;

    m_start_task_failed_isValid = ::OpenAPI::fromJsonValue(m_start_task_failed, json[QString("startTaskFailed")]);
    m_start_task_failed_isSet = !json[QString("startTaskFailed")].isNull() && m_start_task_failed_isValid;

    m_starting_isValid = ::OpenAPI::fromJsonValue(m_starting, json[QString("starting")]);
    m_starting_isSet = !json[QString("starting")].isNull() && m_starting_isValid;

    m_total_isValid = ::OpenAPI::fromJsonValue(m_total, json[QString("total")]);
    m_total_isSet = !json[QString("total")].isNull() && m_total_isValid;

    m_unknown_isValid = ::OpenAPI::fromJsonValue(m_unknown, json[QString("unknown")]);
    m_unknown_isSet = !json[QString("unknown")].isNull() && m_unknown_isValid;

    m_unusable_isValid = ::OpenAPI::fromJsonValue(m_unusable, json[QString("unusable")]);
    m_unusable_isSet = !json[QString("unusable")].isNull() && m_unusable_isValid;

    m_waiting_for_start_task_isValid = ::OpenAPI::fromJsonValue(m_waiting_for_start_task, json[QString("waitingForStartTask")]);
    m_waiting_for_start_task_isSet = !json[QString("waitingForStartTask")].isNull() && m_waiting_for_start_task_isValid;
}

QString OAINodeCounts::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINodeCounts::asJsonObject() const {
    QJsonObject obj;
    if (m_creating_isSet) {
        obj.insert(QString("creating"), ::OpenAPI::toJsonValue(m_creating));
    }
    if (m_idle_isSet) {
        obj.insert(QString("idle"), ::OpenAPI::toJsonValue(m_idle));
    }
    if (m_leaving_pool_isSet) {
        obj.insert(QString("leavingPool"), ::OpenAPI::toJsonValue(m_leaving_pool));
    }
    if (m_offline_isSet) {
        obj.insert(QString("offline"), ::OpenAPI::toJsonValue(m_offline));
    }
    if (m_preempted_isSet) {
        obj.insert(QString("preempted"), ::OpenAPI::toJsonValue(m_preempted));
    }
    if (m_rebooting_isSet) {
        obj.insert(QString("rebooting"), ::OpenAPI::toJsonValue(m_rebooting));
    }
    if (m_reimaging_isSet) {
        obj.insert(QString("reimaging"), ::OpenAPI::toJsonValue(m_reimaging));
    }
    if (m_running_isSet) {
        obj.insert(QString("running"), ::OpenAPI::toJsonValue(m_running));
    }
    if (m_start_task_failed_isSet) {
        obj.insert(QString("startTaskFailed"), ::OpenAPI::toJsonValue(m_start_task_failed));
    }
    if (m_starting_isSet) {
        obj.insert(QString("starting"), ::OpenAPI::toJsonValue(m_starting));
    }
    if (m_total_isSet) {
        obj.insert(QString("total"), ::OpenAPI::toJsonValue(m_total));
    }
    if (m_unknown_isSet) {
        obj.insert(QString("unknown"), ::OpenAPI::toJsonValue(m_unknown));
    }
    if (m_unusable_isSet) {
        obj.insert(QString("unusable"), ::OpenAPI::toJsonValue(m_unusable));
    }
    if (m_waiting_for_start_task_isSet) {
        obj.insert(QString("waitingForStartTask"), ::OpenAPI::toJsonValue(m_waiting_for_start_task));
    }
    return obj;
}

qint32 OAINodeCounts::getCreating() const {
    return m_creating;
}
void OAINodeCounts::setCreating(const qint32 &creating) {
    m_creating = creating;
    m_creating_isSet = true;
}

bool OAINodeCounts::is_creating_Set() const{
    return m_creating_isSet;
}

bool OAINodeCounts::is_creating_Valid() const{
    return m_creating_isValid;
}

qint32 OAINodeCounts::getIdle() const {
    return m_idle;
}
void OAINodeCounts::setIdle(const qint32 &idle) {
    m_idle = idle;
    m_idle_isSet = true;
}

bool OAINodeCounts::is_idle_Set() const{
    return m_idle_isSet;
}

bool OAINodeCounts::is_idle_Valid() const{
    return m_idle_isValid;
}

qint32 OAINodeCounts::getLeavingPool() const {
    return m_leaving_pool;
}
void OAINodeCounts::setLeavingPool(const qint32 &leaving_pool) {
    m_leaving_pool = leaving_pool;
    m_leaving_pool_isSet = true;
}

bool OAINodeCounts::is_leaving_pool_Set() const{
    return m_leaving_pool_isSet;
}

bool OAINodeCounts::is_leaving_pool_Valid() const{
    return m_leaving_pool_isValid;
}

qint32 OAINodeCounts::getOffline() const {
    return m_offline;
}
void OAINodeCounts::setOffline(const qint32 &offline) {
    m_offline = offline;
    m_offline_isSet = true;
}

bool OAINodeCounts::is_offline_Set() const{
    return m_offline_isSet;
}

bool OAINodeCounts::is_offline_Valid() const{
    return m_offline_isValid;
}

qint32 OAINodeCounts::getPreempted() const {
    return m_preempted;
}
void OAINodeCounts::setPreempted(const qint32 &preempted) {
    m_preempted = preempted;
    m_preempted_isSet = true;
}

bool OAINodeCounts::is_preempted_Set() const{
    return m_preempted_isSet;
}

bool OAINodeCounts::is_preempted_Valid() const{
    return m_preempted_isValid;
}

qint32 OAINodeCounts::getRebooting() const {
    return m_rebooting;
}
void OAINodeCounts::setRebooting(const qint32 &rebooting) {
    m_rebooting = rebooting;
    m_rebooting_isSet = true;
}

bool OAINodeCounts::is_rebooting_Set() const{
    return m_rebooting_isSet;
}

bool OAINodeCounts::is_rebooting_Valid() const{
    return m_rebooting_isValid;
}

qint32 OAINodeCounts::getReimaging() const {
    return m_reimaging;
}
void OAINodeCounts::setReimaging(const qint32 &reimaging) {
    m_reimaging = reimaging;
    m_reimaging_isSet = true;
}

bool OAINodeCounts::is_reimaging_Set() const{
    return m_reimaging_isSet;
}

bool OAINodeCounts::is_reimaging_Valid() const{
    return m_reimaging_isValid;
}

qint32 OAINodeCounts::getRunning() const {
    return m_running;
}
void OAINodeCounts::setRunning(const qint32 &running) {
    m_running = running;
    m_running_isSet = true;
}

bool OAINodeCounts::is_running_Set() const{
    return m_running_isSet;
}

bool OAINodeCounts::is_running_Valid() const{
    return m_running_isValid;
}

qint32 OAINodeCounts::getStartTaskFailed() const {
    return m_start_task_failed;
}
void OAINodeCounts::setStartTaskFailed(const qint32 &start_task_failed) {
    m_start_task_failed = start_task_failed;
    m_start_task_failed_isSet = true;
}

bool OAINodeCounts::is_start_task_failed_Set() const{
    return m_start_task_failed_isSet;
}

bool OAINodeCounts::is_start_task_failed_Valid() const{
    return m_start_task_failed_isValid;
}

qint32 OAINodeCounts::getStarting() const {
    return m_starting;
}
void OAINodeCounts::setStarting(const qint32 &starting) {
    m_starting = starting;
    m_starting_isSet = true;
}

bool OAINodeCounts::is_starting_Set() const{
    return m_starting_isSet;
}

bool OAINodeCounts::is_starting_Valid() const{
    return m_starting_isValid;
}

qint32 OAINodeCounts::getTotal() const {
    return m_total;
}
void OAINodeCounts::setTotal(const qint32 &total) {
    m_total = total;
    m_total_isSet = true;
}

bool OAINodeCounts::is_total_Set() const{
    return m_total_isSet;
}

bool OAINodeCounts::is_total_Valid() const{
    return m_total_isValid;
}

qint32 OAINodeCounts::getUnknown() const {
    return m_unknown;
}
void OAINodeCounts::setUnknown(const qint32 &unknown) {
    m_unknown = unknown;
    m_unknown_isSet = true;
}

bool OAINodeCounts::is_unknown_Set() const{
    return m_unknown_isSet;
}

bool OAINodeCounts::is_unknown_Valid() const{
    return m_unknown_isValid;
}

qint32 OAINodeCounts::getUnusable() const {
    return m_unusable;
}
void OAINodeCounts::setUnusable(const qint32 &unusable) {
    m_unusable = unusable;
    m_unusable_isSet = true;
}

bool OAINodeCounts::is_unusable_Set() const{
    return m_unusable_isSet;
}

bool OAINodeCounts::is_unusable_Valid() const{
    return m_unusable_isValid;
}

qint32 OAINodeCounts::getWaitingForStartTask() const {
    return m_waiting_for_start_task;
}
void OAINodeCounts::setWaitingForStartTask(const qint32 &waiting_for_start_task) {
    m_waiting_for_start_task = waiting_for_start_task;
    m_waiting_for_start_task_isSet = true;
}

bool OAINodeCounts::is_waiting_for_start_task_Set() const{
    return m_waiting_for_start_task_isSet;
}

bool OAINodeCounts::is_waiting_for_start_task_Valid() const{
    return m_waiting_for_start_task_isValid;
}

bool OAINodeCounts::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_creating_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_idle_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_leaving_pool_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_offline_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_preempted_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rebooting_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reimaging_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_running_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_task_failed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_starting_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unknown_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unusable_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_waiting_for_start_task_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINodeCounts::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_creating_isValid && m_idle_isValid && m_leaving_pool_isValid && m_offline_isValid && m_preempted_isValid && m_rebooting_isValid && m_reimaging_isValid && m_running_isValid && m_start_task_failed_isValid && m_starting_isValid && m_total_isValid && m_unknown_isValid && m_unusable_isValid && m_waiting_for_start_task_isValid && true;
}

} // namespace OpenAPI
