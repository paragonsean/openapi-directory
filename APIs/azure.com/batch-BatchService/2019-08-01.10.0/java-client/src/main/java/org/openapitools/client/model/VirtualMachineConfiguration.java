/*
 * BatchService
 * A client for issuing REST requests to the Azure Batch service.
 *
 * The version of the OpenAPI document: 2019-08-01.10.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ContainerConfiguration;
import org.openapitools.client.model.DataDisk;
import org.openapitools.client.model.ImageReference;
import org.openapitools.client.model.WindowsConfiguration;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * VirtualMachineConfiguration
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:36:32.540737-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VirtualMachineConfiguration {
  public static final String SERIALIZED_NAME_CONTAINER_CONFIGURATION = "containerConfiguration";
  @SerializedName(SERIALIZED_NAME_CONTAINER_CONFIGURATION)
  private ContainerConfiguration containerConfiguration;

  public static final String SERIALIZED_NAME_DATA_DISKS = "dataDisks";
  @SerializedName(SERIALIZED_NAME_DATA_DISKS)
  private List<DataDisk> dataDisks = new ArrayList<>();

  public static final String SERIALIZED_NAME_IMAGE_REFERENCE = "imageReference";
  @SerializedName(SERIALIZED_NAME_IMAGE_REFERENCE)
  private ImageReference imageReference;

  public static final String SERIALIZED_NAME_LICENSE_TYPE = "licenseType";
  @SerializedName(SERIALIZED_NAME_LICENSE_TYPE)
  private String licenseType;

  public static final String SERIALIZED_NAME_NODE_AGENT_S_K_U_ID = "nodeAgentSKUId";
  @SerializedName(SERIALIZED_NAME_NODE_AGENT_S_K_U_ID)
  private String nodeAgentSKUId;

  public static final String SERIALIZED_NAME_WINDOWS_CONFIGURATION = "windowsConfiguration";
  @SerializedName(SERIALIZED_NAME_WINDOWS_CONFIGURATION)
  private WindowsConfiguration windowsConfiguration;

  public VirtualMachineConfiguration() {
  }

  public VirtualMachineConfiguration containerConfiguration(ContainerConfiguration containerConfiguration) {
    this.containerConfiguration = containerConfiguration;
    return this;
  }

  /**
   * Get containerConfiguration
   * @return containerConfiguration
   */
  @javax.annotation.Nullable
  public ContainerConfiguration getContainerConfiguration() {
    return containerConfiguration;
  }

  public void setContainerConfiguration(ContainerConfiguration containerConfiguration) {
    this.containerConfiguration = containerConfiguration;
  }


  public VirtualMachineConfiguration dataDisks(List<DataDisk> dataDisks) {
    this.dataDisks = dataDisks;
    return this;
  }

  public VirtualMachineConfiguration addDataDisksItem(DataDisk dataDisksItem) {
    if (this.dataDisks == null) {
      this.dataDisks = new ArrayList<>();
    }
    this.dataDisks.add(dataDisksItem);
    return this;
  }

  /**
   * This property must be specified if the Compute Nodes in the Pool need to have empty data disks attached to them. This cannot be updated. Each Compute Node gets its own disk (the disk is not a file share). Existing disks cannot be attached, each attached disk is empty. When the Compute Node is removed from the Pool, the disk and all data associated with it is also deleted. The disk is not formatted after being attached, it must be formatted before use - for more information see https://docs.microsoft.com/en-us/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux and https://docs.microsoft.com/en-us/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
   * @return dataDisks
   */
  @javax.annotation.Nullable
  public List<DataDisk> getDataDisks() {
    return dataDisks;
  }

  public void setDataDisks(List<DataDisk> dataDisks) {
    this.dataDisks = dataDisks;
  }


  public VirtualMachineConfiguration imageReference(ImageReference imageReference) {
    this.imageReference = imageReference;
    return this;
  }

  /**
   * Get imageReference
   * @return imageReference
   */
  @javax.annotation.Nonnull
  public ImageReference getImageReference() {
    return imageReference;
  }

  public void setImageReference(ImageReference imageReference) {
    this.imageReference = imageReference;
  }


  public VirtualMachineConfiguration licenseType(String licenseType) {
    this.licenseType = licenseType;
    return this;
  }

  /**
   * This only applies to Images that contain the Windows operating system, and should only be used when you hold valid on-premises licenses for the Compute Nodes which will be deployed. If omitted, no on-premises licensing discount is applied. Values are:   Windows_Server - The on-premises license is for Windows Server.  Windows_Client - The on-premises license is for Windows Client. 
   * @return licenseType
   */
  @javax.annotation.Nullable
  public String getLicenseType() {
    return licenseType;
  }

  public void setLicenseType(String licenseType) {
    this.licenseType = licenseType;
  }


  public VirtualMachineConfiguration nodeAgentSKUId(String nodeAgentSKUId) {
    this.nodeAgentSKUId = nodeAgentSKUId;
    return this;
  }

  /**
   * The Batch Compute Node agent is a program that runs on each Compute Node in the Pool, and provides the command-and-control interface between the Compute Node and the Batch service. There are different implementations of the Compute Node agent, known as SKUs, for different operating systems. You must specify a Compute Node agent SKU which matches the selected Image reference. To get the list of supported Compute Node agent SKUs along with their list of verified Image references, see the &#39;List supported Compute Node agent SKUs&#39; operation.
   * @return nodeAgentSKUId
   */
  @javax.annotation.Nonnull
  public String getNodeAgentSKUId() {
    return nodeAgentSKUId;
  }

  public void setNodeAgentSKUId(String nodeAgentSKUId) {
    this.nodeAgentSKUId = nodeAgentSKUId;
  }


  public VirtualMachineConfiguration windowsConfiguration(WindowsConfiguration windowsConfiguration) {
    this.windowsConfiguration = windowsConfiguration;
    return this;
  }

  /**
   * Get windowsConfiguration
   * @return windowsConfiguration
   */
  @javax.annotation.Nullable
  public WindowsConfiguration getWindowsConfiguration() {
    return windowsConfiguration;
  }

  public void setWindowsConfiguration(WindowsConfiguration windowsConfiguration) {
    this.windowsConfiguration = windowsConfiguration;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VirtualMachineConfiguration virtualMachineConfiguration = (VirtualMachineConfiguration) o;
    return Objects.equals(this.containerConfiguration, virtualMachineConfiguration.containerConfiguration) &&
        Objects.equals(this.dataDisks, virtualMachineConfiguration.dataDisks) &&
        Objects.equals(this.imageReference, virtualMachineConfiguration.imageReference) &&
        Objects.equals(this.licenseType, virtualMachineConfiguration.licenseType) &&
        Objects.equals(this.nodeAgentSKUId, virtualMachineConfiguration.nodeAgentSKUId) &&
        Objects.equals(this.windowsConfiguration, virtualMachineConfiguration.windowsConfiguration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(containerConfiguration, dataDisks, imageReference, licenseType, nodeAgentSKUId, windowsConfiguration);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VirtualMachineConfiguration {\n");
    sb.append("    containerConfiguration: ").append(toIndentedString(containerConfiguration)).append("\n");
    sb.append("    dataDisks: ").append(toIndentedString(dataDisks)).append("\n");
    sb.append("    imageReference: ").append(toIndentedString(imageReference)).append("\n");
    sb.append("    licenseType: ").append(toIndentedString(licenseType)).append("\n");
    sb.append("    nodeAgentSKUId: ").append(toIndentedString(nodeAgentSKUId)).append("\n");
    sb.append("    windowsConfiguration: ").append(toIndentedString(windowsConfiguration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("containerConfiguration");
    openapiFields.add("dataDisks");
    openapiFields.add("imageReference");
    openapiFields.add("licenseType");
    openapiFields.add("nodeAgentSKUId");
    openapiFields.add("windowsConfiguration");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("imageReference");
    openapiRequiredFields.add("nodeAgentSKUId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VirtualMachineConfiguration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VirtualMachineConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VirtualMachineConfiguration is not found in the empty JSON string", VirtualMachineConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VirtualMachineConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VirtualMachineConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : VirtualMachineConfiguration.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `containerConfiguration`
      if (jsonObj.get("containerConfiguration") != null && !jsonObj.get("containerConfiguration").isJsonNull()) {
        ContainerConfiguration.validateJsonElement(jsonObj.get("containerConfiguration"));
      }
      if (jsonObj.get("dataDisks") != null && !jsonObj.get("dataDisks").isJsonNull()) {
        JsonArray jsonArraydataDisks = jsonObj.getAsJsonArray("dataDisks");
        if (jsonArraydataDisks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dataDisks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dataDisks` to be an array in the JSON string but got `%s`", jsonObj.get("dataDisks").toString()));
          }

          // validate the optional field `dataDisks` (array)
          for (int i = 0; i < jsonArraydataDisks.size(); i++) {
            DataDisk.validateJsonElement(jsonArraydataDisks.get(i));
          };
        }
      }
      // validate the required field `imageReference`
      ImageReference.validateJsonElement(jsonObj.get("imageReference"));
      if ((jsonObj.get("licenseType") != null && !jsonObj.get("licenseType").isJsonNull()) && !jsonObj.get("licenseType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `licenseType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("licenseType").toString()));
      }
      if (!jsonObj.get("nodeAgentSKUId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nodeAgentSKUId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nodeAgentSKUId").toString()));
      }
      // validate the optional field `windowsConfiguration`
      if (jsonObj.get("windowsConfiguration") != null && !jsonObj.get("windowsConfiguration").isJsonNull()) {
        WindowsConfiguration.validateJsonElement(jsonObj.get("windowsConfiguration"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VirtualMachineConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VirtualMachineConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VirtualMachineConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VirtualMachineConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<VirtualMachineConfiguration>() {
           @Override
           public void write(JsonWriter out, VirtualMachineConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VirtualMachineConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VirtualMachineConfiguration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VirtualMachineConfiguration
   * @throws IOException if the JSON string is invalid with respect to VirtualMachineConfiguration
   */
  public static VirtualMachineConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VirtualMachineConfiguration.class);
  }

  /**
   * Convert an instance of VirtualMachineConfiguration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

