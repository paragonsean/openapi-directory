# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class ReliableCollectionsRef(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, do_not_persist_state: bool=None, name: str=None):
        """ReliableCollectionsRef - a model defined in OpenAPI

        :param do_not_persist_state: The do_not_persist_state of this ReliableCollectionsRef.
        :param name: The name of this ReliableCollectionsRef.
        """
        self.openapi_types = {
            'do_not_persist_state': bool,
            'name': str
        }

        self.attribute_map = {
            'do_not_persist_state': 'doNotPersistState',
            'name': 'name'
        }

        self._do_not_persist_state = do_not_persist_state
        self._name = name

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ReliableCollectionsRef':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ReliableCollectionsRef of this ReliableCollectionsRef.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def do_not_persist_state(self):
        """Gets the do_not_persist_state of this ReliableCollectionsRef.

        False (the default) if ReliableCollections state is persisted to disk as usual. True if you do not want to persist state, in which case replication is still enabled and you can use ReliableCollections as distributed cache.

        :return: The do_not_persist_state of this ReliableCollectionsRef.
        :rtype: bool
        """
        return self._do_not_persist_state

    @do_not_persist_state.setter
    def do_not_persist_state(self, do_not_persist_state):
        """Sets the do_not_persist_state of this ReliableCollectionsRef.

        False (the default) if ReliableCollections state is persisted to disk as usual. True if you do not want to persist state, in which case replication is still enabled and you can use ReliableCollections as distributed cache.

        :param do_not_persist_state: The do_not_persist_state of this ReliableCollectionsRef.
        :type do_not_persist_state: bool
        """

        self._do_not_persist_state = do_not_persist_state

    @property
    def name(self):
        """Gets the name of this ReliableCollectionsRef.

        Name of ReliableCollection resource. Right now it's not used and you can use any string.

        :return: The name of this ReliableCollectionsRef.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this ReliableCollectionsRef.

        Name of ReliableCollection resource. Right now it's not used and you can use any string.

        :param name: The name of this ReliableCollectionsRef.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")

        self._name = name
