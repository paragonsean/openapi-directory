/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.3.0.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.Chaos;
import org.openapitools.client.model.ChaosEventsSegment;
import org.openapitools.client.model.ChaosParameters;
import org.openapitools.client.model.ChaosScheduleDescription;
import org.openapitools.client.model.FabricError;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for ChaosApi
 */
@Disabled
public class ChaosApiTest {

    private final ChaosApi api = new ChaosApi();

    /**
     * Get the status of Chaos.
     *
     * Get the status of Chaos indicating whether or not Chaos is running, the Chaos parameters used for running Chaos and the status of the Chaos Schedule.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChaosTest() throws ApiException {
        String apiVersion = null;
        Long timeout = null;
        Chaos response = api.getChaos(apiVersion, timeout);
        // TODO: test validations
    }

    /**
     * Gets the next segment of the Chaos events based on the continuation token or the time range.
     *
     * To get the next segment of the Chaos events, you can specify the ContinuationToken. To get the start of a new segment of Chaos events, you can specify the time range through StartTimeUtc and EndTimeUtc. You cannot specify both the ContinuationToken and the time range in the same call. When there are more than 100 Chaos events, the Chaos events are returned in multiple segments where a segment contains no more than 100 Chaos events and to get the next segment you make a call to this API with the continuation token.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChaosEventsTest() throws ApiException {
        String apiVersion = null;
        String continuationToken = null;
        String startTimeUtc = null;
        String endTimeUtc = null;
        Long maxResults = null;
        Long timeout = null;
        ChaosEventsSegment response = api.getChaosEvents(apiVersion, continuationToken, startTimeUtc, endTimeUtc, maxResults, timeout);
        // TODO: test validations
    }

    /**
     * Get the Chaos Schedule defining when and how to run Chaos.
     *
     * Gets the version of the Chaos Schedule in use and the Chaos Schedule that defines when and how to run Chaos.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChaosScheduleTest() throws ApiException {
        String apiVersion = null;
        Long timeout = null;
        ChaosScheduleDescription response = api.getChaosSchedule(apiVersion, timeout);
        // TODO: test validations
    }

    /**
     * Set the schedule used by Chaos.
     *
     * Chaos will automatically schedule runs based on the Chaos Schedule. The Chaos Schedule will be updated if the provided version matches the version on the server. When updating the Chaos Schedule, the version on the server is incremented by 1. The version on the server will wrap back to 0 after reaching a large number. If Chaos is running when this call is made, the call will fail.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void postChaosScheduleTest() throws ApiException {
        String apiVersion = null;
        ChaosScheduleDescription chaosSchedule = null;
        Long timeout = null;
        api.postChaosSchedule(apiVersion, chaosSchedule, timeout);
        // TODO: test validations
    }

    /**
     * Starts Chaos in the cluster.
     *
     * If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters. If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING. Refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/azure/service-fabric/service-fabric-controlled-chaos) for more details.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void startChaosTest() throws ApiException {
        String apiVersion = null;
        ChaosParameters chaosParameters = null;
        Long timeout = null;
        api.startChaos(apiVersion, chaosParameters, timeout);
        // TODO: test validations
    }

    /**
     * Stops Chaos if it is running in the cluster and put the Chaos Schedule in a stopped state.
     *
     * Stops Chaos from executing new faults. In-flight faults will continue to execute until they are complete. The current Chaos Schedule is put into a stopped state. Once a schedule is stopped, it will stay in the stopped state and not be used to Chaos Schedule new runs of Chaos. A new Chaos Schedule must be set in order to resume scheduling.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void stopChaosTest() throws ApiException {
        String apiVersion = null;
        Long timeout = null;
        api.stopChaos(apiVersion, timeout);
        // TODO: test validations
    }

}
