/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.3.0.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ApplicationTypeHealthPolicyMapItem;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:56:48.965186-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ClusterHealthPolicy {
  public static final String SERIALIZED_NAME_APPLICATION_TYPE_HEALTH_POLICY_MAP = "ApplicationTypeHealthPolicyMap";
  @SerializedName(SERIALIZED_NAME_APPLICATION_TYPE_HEALTH_POLICY_MAP)
  private List<ApplicationTypeHealthPolicyMapItem> applicationTypeHealthPolicyMap = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONSIDER_WARNING_AS_ERROR = "ConsiderWarningAsError";
  @SerializedName(SERIALIZED_NAME_CONSIDER_WARNING_AS_ERROR)
  private Boolean considerWarningAsError = false;

  public static final String SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_APPLICATIONS = "MaxPercentUnhealthyApplications";
  @SerializedName(SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_APPLICATIONS)
  private Integer maxPercentUnhealthyApplications;

  public static final String SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_NODES = "MaxPercentUnhealthyNodes";
  @SerializedName(SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_NODES)
  private Integer maxPercentUnhealthyNodes;

  public ClusterHealthPolicy() {
  }

  public ClusterHealthPolicy applicationTypeHealthPolicyMap(List<ApplicationTypeHealthPolicyMapItem> applicationTypeHealthPolicyMap) {
    this.applicationTypeHealthPolicyMap = applicationTypeHealthPolicyMap;
    return this;
  }

  public ClusterHealthPolicy addApplicationTypeHealthPolicyMapItem(ApplicationTypeHealthPolicyMapItem applicationTypeHealthPolicyMapItem) {
    if (this.applicationTypeHealthPolicyMap == null) {
      this.applicationTypeHealthPolicyMap = new ArrayList<>();
    }
    this.applicationTypeHealthPolicyMap.add(applicationTypeHealthPolicyMapItem);
    return this;
  }

  /**
   * Defines a map with max percentage unhealthy applications for specific application types. Each entry specifies as key the application type name and as value an integer that represents the MaxPercentUnhealthyApplications percentage used to evaluate the applications of the specified application type.  The application type health policy map can be used during cluster health evaluation to describe special application types. The application types included in the map are evaluated against the percentage specified in the map, and not with the global MaxPercentUnhealthyApplications defined in the cluster health policy. The applications of application types specified in the map are not counted against the global pool of applications. For example, if some applications of a type are critical, the cluster administrator can add an entry to the map for that application type and assign it a value of 0% (that is, do not tolerate any failures). All other applications can be evaluated with MaxPercentUnhealthyApplications set to 20% to tolerate some failures out of the thousands of application instances. The application type health policy map is used only if the cluster manifest enables application type health evaluation using the configuration entry for HealthManager/EnableApplicationTypeHealthEvaluation.
   * @return applicationTypeHealthPolicyMap
   */
  @javax.annotation.Nullable
  public List<ApplicationTypeHealthPolicyMapItem> getApplicationTypeHealthPolicyMap() {
    return applicationTypeHealthPolicyMap;
  }

  public void setApplicationTypeHealthPolicyMap(List<ApplicationTypeHealthPolicyMapItem> applicationTypeHealthPolicyMap) {
    this.applicationTypeHealthPolicyMap = applicationTypeHealthPolicyMap;
  }


  public ClusterHealthPolicy considerWarningAsError(Boolean considerWarningAsError) {
    this.considerWarningAsError = considerWarningAsError;
    return this;
  }

  /**
   * Indicates whether warnings are treated with the same severity as errors.
   * @return considerWarningAsError
   */
  @javax.annotation.Nullable
  public Boolean getConsiderWarningAsError() {
    return considerWarningAsError;
  }

  public void setConsiderWarningAsError(Boolean considerWarningAsError) {
    this.considerWarningAsError = considerWarningAsError;
  }


  public ClusterHealthPolicy maxPercentUnhealthyApplications(Integer maxPercentUnhealthyApplications) {
    this.maxPercentUnhealthyApplications = maxPercentUnhealthyApplications;
    return this;
  }

  /**
   * The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.  The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error. If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning. This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap. The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero.
   * @return maxPercentUnhealthyApplications
   */
  @javax.annotation.Nullable
  public Integer getMaxPercentUnhealthyApplications() {
    return maxPercentUnhealthyApplications;
  }

  public void setMaxPercentUnhealthyApplications(Integer maxPercentUnhealthyApplications) {
    this.maxPercentUnhealthyApplications = maxPercentUnhealthyApplications;
  }


  public ClusterHealthPolicy maxPercentUnhealthyNodes(Integer maxPercentUnhealthyNodes) {
    this.maxPercentUnhealthyNodes = maxPercentUnhealthyNodes;
    return this;
  }

  /**
   * The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.  The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error. If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster. The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.  In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that.
   * @return maxPercentUnhealthyNodes
   */
  @javax.annotation.Nullable
  public Integer getMaxPercentUnhealthyNodes() {
    return maxPercentUnhealthyNodes;
  }

  public void setMaxPercentUnhealthyNodes(Integer maxPercentUnhealthyNodes) {
    this.maxPercentUnhealthyNodes = maxPercentUnhealthyNodes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClusterHealthPolicy clusterHealthPolicy = (ClusterHealthPolicy) o;
    return Objects.equals(this.applicationTypeHealthPolicyMap, clusterHealthPolicy.applicationTypeHealthPolicyMap) &&
        Objects.equals(this.considerWarningAsError, clusterHealthPolicy.considerWarningAsError) &&
        Objects.equals(this.maxPercentUnhealthyApplications, clusterHealthPolicy.maxPercentUnhealthyApplications) &&
        Objects.equals(this.maxPercentUnhealthyNodes, clusterHealthPolicy.maxPercentUnhealthyNodes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationTypeHealthPolicyMap, considerWarningAsError, maxPercentUnhealthyApplications, maxPercentUnhealthyNodes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClusterHealthPolicy {\n");
    sb.append("    applicationTypeHealthPolicyMap: ").append(toIndentedString(applicationTypeHealthPolicyMap)).append("\n");
    sb.append("    considerWarningAsError: ").append(toIndentedString(considerWarningAsError)).append("\n");
    sb.append("    maxPercentUnhealthyApplications: ").append(toIndentedString(maxPercentUnhealthyApplications)).append("\n");
    sb.append("    maxPercentUnhealthyNodes: ").append(toIndentedString(maxPercentUnhealthyNodes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ApplicationTypeHealthPolicyMap");
    openapiFields.add("ConsiderWarningAsError");
    openapiFields.add("MaxPercentUnhealthyApplications");
    openapiFields.add("MaxPercentUnhealthyNodes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ClusterHealthPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ClusterHealthPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ClusterHealthPolicy is not found in the empty JSON string", ClusterHealthPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ClusterHealthPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ClusterHealthPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("ApplicationTypeHealthPolicyMap") != null && !jsonObj.get("ApplicationTypeHealthPolicyMap").isJsonNull()) {
        JsonArray jsonArrayapplicationTypeHealthPolicyMap = jsonObj.getAsJsonArray("ApplicationTypeHealthPolicyMap");
        if (jsonArrayapplicationTypeHealthPolicyMap != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ApplicationTypeHealthPolicyMap").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ApplicationTypeHealthPolicyMap` to be an array in the JSON string but got `%s`", jsonObj.get("ApplicationTypeHealthPolicyMap").toString()));
          }

          // validate the optional field `ApplicationTypeHealthPolicyMap` (array)
          for (int i = 0; i < jsonArrayapplicationTypeHealthPolicyMap.size(); i++) {
            ApplicationTypeHealthPolicyMapItem.validateJsonElement(jsonArrayapplicationTypeHealthPolicyMap.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ClusterHealthPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ClusterHealthPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ClusterHealthPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ClusterHealthPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<ClusterHealthPolicy>() {
           @Override
           public void write(JsonWriter out, ClusterHealthPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ClusterHealthPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ClusterHealthPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ClusterHealthPolicy
   * @throws IOException if the JSON string is invalid with respect to ClusterHealthPolicy
   */
  public static ClusterHealthPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ClusterHealthPolicy.class);
  }

  /**
   * Convert an instance of ClusterHealthPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

