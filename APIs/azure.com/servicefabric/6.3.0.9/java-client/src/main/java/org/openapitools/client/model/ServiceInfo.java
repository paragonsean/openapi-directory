/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.3.0.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.HealthState;
import org.openapitools.client.model.ServiceKind;
import org.openapitools.client.model.ServiceStatus;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Information about a Service Fabric service.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:56:48.965186-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ServiceInfo {
  public static final String SERIALIZED_NAME_HEALTH_STATE = "HealthState";
  @SerializedName(SERIALIZED_NAME_HEALTH_STATE)
  private HealthState healthState;

  public static final String SERIALIZED_NAME_ID = "Id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IS_SERVICE_GROUP = "IsServiceGroup";
  @SerializedName(SERIALIZED_NAME_IS_SERVICE_GROUP)
  private Boolean isServiceGroup;

  public static final String SERIALIZED_NAME_MANIFEST_VERSION = "ManifestVersion";
  @SerializedName(SERIALIZED_NAME_MANIFEST_VERSION)
  private String manifestVersion;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SERVICE_KIND = "ServiceKind";
  @SerializedName(SERIALIZED_NAME_SERVICE_KIND)
  protected ServiceKind serviceKind;

  public static final String SERIALIZED_NAME_SERVICE_STATUS = "ServiceStatus";
  @SerializedName(SERIALIZED_NAME_SERVICE_STATUS)
  private ServiceStatus serviceStatus;

  public static final String SERIALIZED_NAME_TYPE_NAME = "TypeName";
  @SerializedName(SERIALIZED_NAME_TYPE_NAME)
  private String typeName;

  public ServiceInfo() {
    this.serviceKind = this.getClass().getSimpleName();
  }

  public ServiceInfo healthState(HealthState healthState) {
    this.healthState = healthState;
    return this;
  }

  /**
   * Get healthState
   * @return healthState
   */
  @javax.annotation.Nullable
  public HealthState getHealthState() {
    return healthState;
  }

  public void setHealthState(HealthState healthState) {
    this.healthState = healthState;
  }


  public ServiceInfo id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is used in the REST APIs to identify the service resource. Starting in version 6.0, hierarchical names are delimited with the \&quot;\\~\&quot; character. For example, if the service name is \&quot;fabric:/myapp/app1/svc1\&quot;, the service identity would be \&quot;myapp~app1\\~svc1\&quot; in 6.0+ and \&quot;myapp/app1/svc1\&quot; in previous versions.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public ServiceInfo isServiceGroup(Boolean isServiceGroup) {
    this.isServiceGroup = isServiceGroup;
    return this;
  }

  /**
   * Whether the service is in a service group.
   * @return isServiceGroup
   */
  @javax.annotation.Nullable
  public Boolean getIsServiceGroup() {
    return isServiceGroup;
  }

  public void setIsServiceGroup(Boolean isServiceGroup) {
    this.isServiceGroup = isServiceGroup;
  }


  public ServiceInfo manifestVersion(String manifestVersion) {
    this.manifestVersion = manifestVersion;
    return this;
  }

  /**
   * The version of the service manifest.
   * @return manifestVersion
   */
  @javax.annotation.Nullable
  public String getManifestVersion() {
    return manifestVersion;
  }

  public void setManifestVersion(String manifestVersion) {
    this.manifestVersion = manifestVersion;
  }


  public ServiceInfo name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The full name of the service with &#39;fabric:&#39; URI scheme.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ServiceInfo serviceKind(ServiceKind serviceKind) {
    this.serviceKind = serviceKind;
    return this;
  }

  /**
   * Get serviceKind
   * @return serviceKind
   */
  @javax.annotation.Nonnull
  public ServiceKind getServiceKind() {
    return serviceKind;
  }

  public void setServiceKind(ServiceKind serviceKind) {
    this.serviceKind = serviceKind;
  }


  public ServiceInfo serviceStatus(ServiceStatus serviceStatus) {
    this.serviceStatus = serviceStatus;
    return this;
  }

  /**
   * Get serviceStatus
   * @return serviceStatus
   */
  @javax.annotation.Nullable
  public ServiceStatus getServiceStatus() {
    return serviceStatus;
  }

  public void setServiceStatus(ServiceStatus serviceStatus) {
    this.serviceStatus = serviceStatus;
  }


  public ServiceInfo typeName(String typeName) {
    this.typeName = typeName;
    return this;
  }

  /**
   * Name of the service type as specified in the service manifest.
   * @return typeName
   */
  @javax.annotation.Nullable
  public String getTypeName() {
    return typeName;
  }

  public void setTypeName(String typeName) {
    this.typeName = typeName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServiceInfo serviceInfo = (ServiceInfo) o;
    return Objects.equals(this.healthState, serviceInfo.healthState) &&
        Objects.equals(this.id, serviceInfo.id) &&
        Objects.equals(this.isServiceGroup, serviceInfo.isServiceGroup) &&
        Objects.equals(this.manifestVersion, serviceInfo.manifestVersion) &&
        Objects.equals(this.name, serviceInfo.name) &&
        Objects.equals(this.serviceKind, serviceInfo.serviceKind) &&
        Objects.equals(this.serviceStatus, serviceInfo.serviceStatus) &&
        Objects.equals(this.typeName, serviceInfo.typeName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(healthState, id, isServiceGroup, manifestVersion, name, serviceKind, serviceStatus, typeName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServiceInfo {\n");
    sb.append("    healthState: ").append(toIndentedString(healthState)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    isServiceGroup: ").append(toIndentedString(isServiceGroup)).append("\n");
    sb.append("    manifestVersion: ").append(toIndentedString(manifestVersion)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    serviceKind: ").append(toIndentedString(serviceKind)).append("\n");
    sb.append("    serviceStatus: ").append(toIndentedString(serviceStatus)).append("\n");
    sb.append("    typeName: ").append(toIndentedString(typeName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("HealthState");
    openapiFields.add("Id");
    openapiFields.add("IsServiceGroup");
    openapiFields.add("ManifestVersion");
    openapiFields.add("Name");
    openapiFields.add("ServiceKind");
    openapiFields.add("ServiceStatus");
    openapiFields.add("TypeName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ServiceKind");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ServiceInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ServiceInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ServiceInfo is not found in the empty JSON string", ServiceInfo.openapiRequiredFields.toString()));
        }
      }

      String discriminatorValue = jsonElement.getAsJsonObject().get("ServiceKind").getAsString();
      switch (discriminatorValue) {
        case "StatefulServiceInfo":
          StatefulServiceInfo.validateJsonElement(jsonElement);
          break;
        case "StatelessServiceInfo":
          StatelessServiceInfo.validateJsonElement(jsonElement);
          break;
        default:
          throw new IllegalArgumentException(String.format("The value of the `ServiceKind` field `%s` does not match any key defined in the discriminator's mapping.", discriminatorValue));
      }
  }


  /**
   * Create an instance of ServiceInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ServiceInfo
   * @throws IOException if the JSON string is invalid with respect to ServiceInfo
   */
  public static ServiceInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ServiceInfo.class);
  }

  /**
   * Convert an instance of ServiceInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

