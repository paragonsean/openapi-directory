/**
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import HealthInformation from './HealthInformation';
import HealthState from './HealthState';

/**
 * The HealthEvent model module.
 * @module model/HealthEvent
 * @version 6.1.2
 */
class HealthEvent {
    /**
     * Constructs a new <code>HealthEvent</code>.
     * Represents health information reported on a health entity, such as cluster, application or node, with additional metadata added by the Health Manager. 
     * @alias module:model/HealthEvent
     * @implements module:model/HealthInformation
     * @param healthState {module:model/HealthState} 
     * @param property {String} The property of the health information. An entity can have health reports for different properties. The property is a string and not a fixed enumeration to allow the reporter flexibility to categorize the state condition that triggers the report. For example, a reporter with SourceId \"LocalWatchdog\" can monitor the state of the available disk on a node, so it can report \"AvailableDisk\" property on that node. The same reporter can monitor the node connectivity, so it can report a property \"Connectivity\" on the same node. In the health store, these reports are treated as separate health events for the specified node.  Together with the SourceId, the property uniquely identifies the health information. 
     * @param sourceId {String} The source name which identifies the client/watchdog/system component which generated the health information. 
     */
    constructor(healthState, property, sourceId) { 
        HealthInformation.initialize(this, healthState, property, sourceId);
        HealthEvent.initialize(this, healthState, property, sourceId);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, healthState, property, sourceId) { 
        obj['HealthState'] = healthState;
        obj['Property'] = property;
        obj['SourceId'] = sourceId;
    }

    /**
     * Constructs a <code>HealthEvent</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/HealthEvent} obj Optional instance to populate.
     * @return {module:model/HealthEvent} The populated <code>HealthEvent</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new HealthEvent();
            HealthInformation.constructFromObject(data, obj);

            if (data.hasOwnProperty('Description')) {
                obj['Description'] = ApiClient.convertToType(data['Description'], 'String');
            }
            if (data.hasOwnProperty('HealthState')) {
                obj['HealthState'] = HealthState.constructFromObject(data['HealthState']);
            }
            if (data.hasOwnProperty('Property')) {
                obj['Property'] = ApiClient.convertToType(data['Property'], 'String');
            }
            if (data.hasOwnProperty('RemoveWhenExpired')) {
                obj['RemoveWhenExpired'] = ApiClient.convertToType(data['RemoveWhenExpired'], 'Boolean');
            }
            if (data.hasOwnProperty('SequenceNumber')) {
                obj['SequenceNumber'] = ApiClient.convertToType(data['SequenceNumber'], 'String');
            }
            if (data.hasOwnProperty('SourceId')) {
                obj['SourceId'] = ApiClient.convertToType(data['SourceId'], 'String');
            }
            if (data.hasOwnProperty('TimeToLiveInMilliSeconds')) {
                obj['TimeToLiveInMilliSeconds'] = ApiClient.convertToType(data['TimeToLiveInMilliSeconds'], 'String');
            }
            if (data.hasOwnProperty('IsExpired')) {
                obj['IsExpired'] = ApiClient.convertToType(data['IsExpired'], 'Boolean');
            }
            if (data.hasOwnProperty('LastErrorTransitionAt')) {
                obj['LastErrorTransitionAt'] = ApiClient.convertToType(data['LastErrorTransitionAt'], 'Date');
            }
            if (data.hasOwnProperty('LastModifiedUtcTimestamp')) {
                obj['LastModifiedUtcTimestamp'] = ApiClient.convertToType(data['LastModifiedUtcTimestamp'], 'Date');
            }
            if (data.hasOwnProperty('LastOkTransitionAt')) {
                obj['LastOkTransitionAt'] = ApiClient.convertToType(data['LastOkTransitionAt'], 'Date');
            }
            if (data.hasOwnProperty('LastWarningTransitionAt')) {
                obj['LastWarningTransitionAt'] = ApiClient.convertToType(data['LastWarningTransitionAt'], 'Date');
            }
            if (data.hasOwnProperty('SourceUtcTimestamp')) {
                obj['SourceUtcTimestamp'] = ApiClient.convertToType(data['SourceUtcTimestamp'], 'Date');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>HealthEvent</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>HealthEvent</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of HealthEvent.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['Description'] && !(typeof data['Description'] === 'string' || data['Description'] instanceof String)) {
            throw new Error("Expected the field `Description` to be a primitive type in the JSON string but got " + data['Description']);
        }
        // ensure the json data is a string
        if (data['Property'] && !(typeof data['Property'] === 'string' || data['Property'] instanceof String)) {
            throw new Error("Expected the field `Property` to be a primitive type in the JSON string but got " + data['Property']);
        }
        // ensure the json data is a string
        if (data['SequenceNumber'] && !(typeof data['SequenceNumber'] === 'string' || data['SequenceNumber'] instanceof String)) {
            throw new Error("Expected the field `SequenceNumber` to be a primitive type in the JSON string but got " + data['SequenceNumber']);
        }
        // ensure the json data is a string
        if (data['SourceId'] && !(typeof data['SourceId'] === 'string' || data['SourceId'] instanceof String)) {
            throw new Error("Expected the field `SourceId` to be a primitive type in the JSON string but got " + data['SourceId']);
        }
        // ensure the json data is a string
        if (data['TimeToLiveInMilliSeconds'] && !(typeof data['TimeToLiveInMilliSeconds'] === 'string' || data['TimeToLiveInMilliSeconds'] instanceof String)) {
            throw new Error("Expected the field `TimeToLiveInMilliSeconds` to be a primitive type in the JSON string but got " + data['TimeToLiveInMilliSeconds']);
        }

        return true;
    }


}

HealthEvent.RequiredProperties = ["HealthState", "Property", "SourceId"];

/**
 * The description of the health information. It represents free text used to add human readable information about the report. The maximum string length for the description is 4096 characters. If the provided string is longer, it will be automatically truncated. When truncated, the last characters of the description contain a marker \"[Truncated]\", and total string size is 4096 characters. The presence of the marker indicates to users that truncation occurred. Note that when truncated, the description has less than 4096 characters from the original string. 
 * @member {String} Description
 */
HealthEvent.prototype['Description'] = undefined;

/**
 * @member {module:model/HealthState} HealthState
 */
HealthEvent.prototype['HealthState'] = undefined;

/**
 * The property of the health information. An entity can have health reports for different properties. The property is a string and not a fixed enumeration to allow the reporter flexibility to categorize the state condition that triggers the report. For example, a reporter with SourceId \"LocalWatchdog\" can monitor the state of the available disk on a node, so it can report \"AvailableDisk\" property on that node. The same reporter can monitor the node connectivity, so it can report a property \"Connectivity\" on the same node. In the health store, these reports are treated as separate health events for the specified node.  Together with the SourceId, the property uniquely identifies the health information. 
 * @member {String} Property
 */
HealthEvent.prototype['Property'] = undefined;

/**
 * Value that indicates whether the report is removed from health store when it expires. If set to true, the report is removed from the health store after it expires. If set to false, the report is treated as an error when expired. The value of this property is false by default. When clients report periodically, they should set RemoveWhenExpired false (default). This way, is the reporter has issues (eg. deadlock) and can't report, the entity is evaluated at error when the health report expires. This flags the entity as being in Error health state. 
 * @member {Boolean} RemoveWhenExpired
 */
HealthEvent.prototype['RemoveWhenExpired'] = undefined;

/**
 * The sequence number for this health report as a numeric string. The report sequence number is used by the health store to detect stale reports. If not specified, a sequence number is auto-generated by the health client when a report is added. 
 * @member {String} SequenceNumber
 */
HealthEvent.prototype['SequenceNumber'] = undefined;

/**
 * The source name which identifies the client/watchdog/system component which generated the health information. 
 * @member {String} SourceId
 */
HealthEvent.prototype['SourceId'] = undefined;

/**
 * The duration for which this health report is valid. This field is using ISO8601 format for specifying the duration. When clients report periodically, they should send reports with higher frequency than time to live. If clients report on transition, they can set the time to live to infinite. When time to live expires, the health event that contains the health information is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired false.  If not specified, time to live defaults to infinite value. 
 * @member {String} TimeToLiveInMilliSeconds
 */
HealthEvent.prototype['TimeToLiveInMilliSeconds'] = undefined;

/**
 * Returns true if the health event is expired, otherwise false.
 * @member {Boolean} IsExpired
 */
HealthEvent.prototype['IsExpired'] = undefined;

/**
 * If the current health state is 'Error', this property returns the time at which the health report was first reported with 'Error'. For periodic reporting, many reports with the same state may have been generated however, this property returns only the date and time at the first 'Error' health report was received.  If the current health state is 'Ok' or 'Warning', returns the date and time at which the health state was last in 'Error', before transitioning to a different state.  If the health state was never 'Error', the value will be zero date-time. 
 * @member {Date} LastErrorTransitionAt
 */
HealthEvent.prototype['LastErrorTransitionAt'] = undefined;

/**
 * The date and time when the health report was last modified by the health store.
 * @member {Date} LastModifiedUtcTimestamp
 */
HealthEvent.prototype['LastModifiedUtcTimestamp'] = undefined;

/**
 * If the current health state is 'Ok', this property returns the time at which the health report was first reported with 'Ok'. For periodic reporting, many reports with the same state may have been generated. This property returns the date and time when the first 'Ok' health report was received.  If the current health state is 'Error' or 'Warning', returns the date and time at which the health state was last in 'Ok', before transitioning to a different state.  If the health state was never 'Ok', the value will be zero date-time. 
 * @member {Date} LastOkTransitionAt
 */
HealthEvent.prototype['LastOkTransitionAt'] = undefined;

/**
 * If the current health state is 'Warning', this property returns the time at which the health report was first reported with 'Warning'. For periodic reporting, many reports with the same state may have been generated however, this property returns only the date and time at the first 'Warning' health report was received.  If the current health state is 'Ok' or 'Error', returns the date and time at which the health state was last in 'Warning', before transitioning to a different state.  If the health state was never 'Warning', the value will be zero date-time. 
 * @member {Date} LastWarningTransitionAt
 */
HealthEvent.prototype['LastWarningTransitionAt'] = undefined;

/**
 * The date and time when the health report was sent by the source.
 * @member {Date} SourceUtcTimestamp
 */
HealthEvent.prototype['SourceUtcTimestamp'] = undefined;


// Implement HealthInformation interface:
/**
 * The description of the health information. It represents free text used to add human readable information about the report. The maximum string length for the description is 4096 characters. If the provided string is longer, it will be automatically truncated. When truncated, the last characters of the description contain a marker \"[Truncated]\", and total string size is 4096 characters. The presence of the marker indicates to users that truncation occurred. Note that when truncated, the description has less than 4096 characters from the original string. 
 * @member {String} Description
 */
HealthInformation.prototype['Description'] = undefined;
/**
 * @member {module:model/HealthState} HealthState
 */
HealthInformation.prototype['HealthState'] = undefined;
/**
 * The property of the health information. An entity can have health reports for different properties. The property is a string and not a fixed enumeration to allow the reporter flexibility to categorize the state condition that triggers the report. For example, a reporter with SourceId \"LocalWatchdog\" can monitor the state of the available disk on a node, so it can report \"AvailableDisk\" property on that node. The same reporter can monitor the node connectivity, so it can report a property \"Connectivity\" on the same node. In the health store, these reports are treated as separate health events for the specified node.  Together with the SourceId, the property uniquely identifies the health information. 
 * @member {String} Property
 */
HealthInformation.prototype['Property'] = undefined;
/**
 * Value that indicates whether the report is removed from health store when it expires. If set to true, the report is removed from the health store after it expires. If set to false, the report is treated as an error when expired. The value of this property is false by default. When clients report periodically, they should set RemoveWhenExpired false (default). This way, is the reporter has issues (eg. deadlock) and can't report, the entity is evaluated at error when the health report expires. This flags the entity as being in Error health state. 
 * @member {Boolean} RemoveWhenExpired
 */
HealthInformation.prototype['RemoveWhenExpired'] = undefined;
/**
 * The sequence number for this health report as a numeric string. The report sequence number is used by the health store to detect stale reports. If not specified, a sequence number is auto-generated by the health client when a report is added. 
 * @member {String} SequenceNumber
 */
HealthInformation.prototype['SequenceNumber'] = undefined;
/**
 * The source name which identifies the client/watchdog/system component which generated the health information. 
 * @member {String} SourceId
 */
HealthInformation.prototype['SourceId'] = undefined;
/**
 * The duration for which this health report is valid. This field is using ISO8601 format for specifying the duration. When clients report periodically, they should send reports with higher frequency than time to live. If clients report on transition, they can set the time to live to infinite. When time to live expires, the health event that contains the health information is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired false.  If not specified, time to live defaults to infinite value. 
 * @member {String} TimeToLiveInMilliSeconds
 */
HealthInformation.prototype['TimeToLiveInMilliSeconds'] = undefined;




export default HealthEvent;

