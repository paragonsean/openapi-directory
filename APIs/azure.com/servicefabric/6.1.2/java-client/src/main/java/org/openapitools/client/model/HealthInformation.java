/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.HealthState;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents common health report information. It is included in all health reports sent to health store and in all health events returned by health queries. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:57:08.089721-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class HealthInformation {
  public static final String SERIALIZED_NAME_DESCRIPTION = "Description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_HEALTH_STATE = "HealthState";
  @SerializedName(SERIALIZED_NAME_HEALTH_STATE)
  private HealthState healthState;

  public static final String SERIALIZED_NAME_PROPERTY = "Property";
  @SerializedName(SERIALIZED_NAME_PROPERTY)
  private String property;

  public static final String SERIALIZED_NAME_REMOVE_WHEN_EXPIRED = "RemoveWhenExpired";
  @SerializedName(SERIALIZED_NAME_REMOVE_WHEN_EXPIRED)
  private Boolean removeWhenExpired;

  public static final String SERIALIZED_NAME_SEQUENCE_NUMBER = "SequenceNumber";
  @SerializedName(SERIALIZED_NAME_SEQUENCE_NUMBER)
  private String sequenceNumber;

  public static final String SERIALIZED_NAME_SOURCE_ID = "SourceId";
  @SerializedName(SERIALIZED_NAME_SOURCE_ID)
  private String sourceId;

  public static final String SERIALIZED_NAME_TIME_TO_LIVE_IN_MILLI_SECONDS = "TimeToLiveInMilliSeconds";
  @SerializedName(SERIALIZED_NAME_TIME_TO_LIVE_IN_MILLI_SECONDS)
  private String timeToLiveInMilliSeconds;

  public HealthInformation() {
  }

  public HealthInformation description(String description) {
    this.description = description;
    return this;
  }

  /**
   * The description of the health information. It represents free text used to add human readable information about the report. The maximum string length for the description is 4096 characters. If the provided string is longer, it will be automatically truncated. When truncated, the last characters of the description contain a marker \&quot;[Truncated]\&quot;, and total string size is 4096 characters. The presence of the marker indicates to users that truncation occurred. Note that when truncated, the description has less than 4096 characters from the original string. 
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public HealthInformation healthState(HealthState healthState) {
    this.healthState = healthState;
    return this;
  }

  /**
   * Get healthState
   * @return healthState
   */
  @javax.annotation.Nonnull
  public HealthState getHealthState() {
    return healthState;
  }

  public void setHealthState(HealthState healthState) {
    this.healthState = healthState;
  }


  public HealthInformation property(String property) {
    this.property = property;
    return this;
  }

  /**
   * The property of the health information. An entity can have health reports for different properties. The property is a string and not a fixed enumeration to allow the reporter flexibility to categorize the state condition that triggers the report. For example, a reporter with SourceId \&quot;LocalWatchdog\&quot; can monitor the state of the available disk on a node, so it can report \&quot;AvailableDisk\&quot; property on that node. The same reporter can monitor the node connectivity, so it can report a property \&quot;Connectivity\&quot; on the same node. In the health store, these reports are treated as separate health events for the specified node.  Together with the SourceId, the property uniquely identifies the health information. 
   * @return property
   */
  @javax.annotation.Nonnull
  public String getProperty() {
    return property;
  }

  public void setProperty(String property) {
    this.property = property;
  }


  public HealthInformation removeWhenExpired(Boolean removeWhenExpired) {
    this.removeWhenExpired = removeWhenExpired;
    return this;
  }

  /**
   * Value that indicates whether the report is removed from health store when it expires. If set to true, the report is removed from the health store after it expires. If set to false, the report is treated as an error when expired. The value of this property is false by default. When clients report periodically, they should set RemoveWhenExpired false (default). This way, is the reporter has issues (eg. deadlock) and can&#39;t report, the entity is evaluated at error when the health report expires. This flags the entity as being in Error health state. 
   * @return removeWhenExpired
   */
  @javax.annotation.Nullable
  public Boolean getRemoveWhenExpired() {
    return removeWhenExpired;
  }

  public void setRemoveWhenExpired(Boolean removeWhenExpired) {
    this.removeWhenExpired = removeWhenExpired;
  }


  public HealthInformation sequenceNumber(String sequenceNumber) {
    this.sequenceNumber = sequenceNumber;
    return this;
  }

  /**
   * The sequence number for this health report as a numeric string. The report sequence number is used by the health store to detect stale reports. If not specified, a sequence number is auto-generated by the health client when a report is added. 
   * @return sequenceNumber
   */
  @javax.annotation.Nullable
  public String getSequenceNumber() {
    return sequenceNumber;
  }

  public void setSequenceNumber(String sequenceNumber) {
    this.sequenceNumber = sequenceNumber;
  }


  public HealthInformation sourceId(String sourceId) {
    this.sourceId = sourceId;
    return this;
  }

  /**
   * The source name which identifies the client/watchdog/system component which generated the health information. 
   * @return sourceId
   */
  @javax.annotation.Nonnull
  public String getSourceId() {
    return sourceId;
  }

  public void setSourceId(String sourceId) {
    this.sourceId = sourceId;
  }


  public HealthInformation timeToLiveInMilliSeconds(String timeToLiveInMilliSeconds) {
    this.timeToLiveInMilliSeconds = timeToLiveInMilliSeconds;
    return this;
  }

  /**
   * The duration for which this health report is valid. This field is using ISO8601 format for specifying the duration. When clients report periodically, they should send reports with higher frequency than time to live. If clients report on transition, they can set the time to live to infinite. When time to live expires, the health event that contains the health information is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired false.  If not specified, time to live defaults to infinite value. 
   * @return timeToLiveInMilliSeconds
   */
  @javax.annotation.Nullable
  public String getTimeToLiveInMilliSeconds() {
    return timeToLiveInMilliSeconds;
  }

  public void setTimeToLiveInMilliSeconds(String timeToLiveInMilliSeconds) {
    this.timeToLiveInMilliSeconds = timeToLiveInMilliSeconds;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HealthInformation healthInformation = (HealthInformation) o;
    return Objects.equals(this.description, healthInformation.description) &&
        Objects.equals(this.healthState, healthInformation.healthState) &&
        Objects.equals(this.property, healthInformation.property) &&
        Objects.equals(this.removeWhenExpired, healthInformation.removeWhenExpired) &&
        Objects.equals(this.sequenceNumber, healthInformation.sequenceNumber) &&
        Objects.equals(this.sourceId, healthInformation.sourceId) &&
        Objects.equals(this.timeToLiveInMilliSeconds, healthInformation.timeToLiveInMilliSeconds);
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, healthState, property, removeWhenExpired, sequenceNumber, sourceId, timeToLiveInMilliSeconds);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HealthInformation {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    healthState: ").append(toIndentedString(healthState)).append("\n");
    sb.append("    property: ").append(toIndentedString(property)).append("\n");
    sb.append("    removeWhenExpired: ").append(toIndentedString(removeWhenExpired)).append("\n");
    sb.append("    sequenceNumber: ").append(toIndentedString(sequenceNumber)).append("\n");
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    timeToLiveInMilliSeconds: ").append(toIndentedString(timeToLiveInMilliSeconds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Description");
    openapiFields.add("HealthState");
    openapiFields.add("Property");
    openapiFields.add("RemoveWhenExpired");
    openapiFields.add("SequenceNumber");
    openapiFields.add("SourceId");
    openapiFields.add("TimeToLiveInMilliSeconds");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("HealthState");
    openapiRequiredFields.add("Property");
    openapiRequiredFields.add("SourceId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to HealthInformation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!HealthInformation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HealthInformation is not found in the empty JSON string", HealthInformation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!HealthInformation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `HealthInformation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : HealthInformation.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("Description") != null && !jsonObj.get("Description").isJsonNull()) && !jsonObj.get("Description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Description").toString()));
      }
      // validate the required field `HealthState`
      HealthState.validateJsonElement(jsonObj.get("HealthState"));
      if (!jsonObj.get("Property").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Property` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Property").toString()));
      }
      if ((jsonObj.get("SequenceNumber") != null && !jsonObj.get("SequenceNumber").isJsonNull()) && !jsonObj.get("SequenceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SequenceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SequenceNumber").toString()));
      }
      if (!jsonObj.get("SourceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SourceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SourceId").toString()));
      }
      if ((jsonObj.get("TimeToLiveInMilliSeconds") != null && !jsonObj.get("TimeToLiveInMilliSeconds").isJsonNull()) && !jsonObj.get("TimeToLiveInMilliSeconds").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TimeToLiveInMilliSeconds` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TimeToLiveInMilliSeconds").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HealthInformation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HealthInformation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HealthInformation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HealthInformation.class));

       return (TypeAdapter<T>) new TypeAdapter<HealthInformation>() {
           @Override
           public void write(JsonWriter out, HealthInformation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HealthInformation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of HealthInformation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of HealthInformation
   * @throws IOException if the JSON string is invalid with respect to HealthInformation
   */
  public static HealthInformation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HealthInformation.class);
  }

  /**
   * Convert an instance of HealthInformation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

