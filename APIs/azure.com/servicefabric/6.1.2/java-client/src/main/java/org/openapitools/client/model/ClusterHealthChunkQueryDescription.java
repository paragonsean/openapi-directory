/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ApplicationHealthPolicies;
import org.openapitools.client.model.ApplicationHealthStateFilter;
import org.openapitools.client.model.ClusterHealthPolicy;
import org.openapitools.client.model.NodeHealthStateFilter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The cluster health chunk query description, which can specify the health policies to evaluate cluster health and very expressive filters to select which cluster entities to include in response.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:57:08.089721-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ClusterHealthChunkQueryDescription {
  public static final String SERIALIZED_NAME_APPLICATION_FILTERS = "ApplicationFilters";
  @SerializedName(SERIALIZED_NAME_APPLICATION_FILTERS)
  private List<ApplicationHealthStateFilter> applicationFilters = new ArrayList<>();

  public static final String SERIALIZED_NAME_APPLICATION_HEALTH_POLICIES = "ApplicationHealthPolicies";
  @SerializedName(SERIALIZED_NAME_APPLICATION_HEALTH_POLICIES)
  private ApplicationHealthPolicies applicationHealthPolicies;

  public static final String SERIALIZED_NAME_CLUSTER_HEALTH_POLICY = "ClusterHealthPolicy";
  @SerializedName(SERIALIZED_NAME_CLUSTER_HEALTH_POLICY)
  private ClusterHealthPolicy clusterHealthPolicy;

  public static final String SERIALIZED_NAME_NODE_FILTERS = "NodeFilters";
  @SerializedName(SERIALIZED_NAME_NODE_FILTERS)
  private List<NodeHealthStateFilter> nodeFilters = new ArrayList<>();

  public ClusterHealthChunkQueryDescription() {
  }

  public ClusterHealthChunkQueryDescription applicationFilters(List<ApplicationHealthStateFilter> applicationFilters) {
    this.applicationFilters = applicationFilters;
    return this;
  }

  public ClusterHealthChunkQueryDescription addApplicationFiltersItem(ApplicationHealthStateFilter applicationFiltersItem) {
    if (this.applicationFilters == null) {
      this.applicationFilters = new ArrayList<>();
    }
    this.applicationFilters.add(applicationFiltersItem);
    return this;
  }

  /**
   * Defines a list of filters that specify which applications to be included in the returned cluster health chunk. If no filters are specified, no applications are returned. All the applications are used to evaluate the cluster&#39;s aggregated health state, regardless of the input filters. The cluster health chunk query may specify multiple application filters. For example, it can specify a filter to return all applications with health state Error and another filter to always include applications of a specified application type. 
   * @return applicationFilters
   */
  @javax.annotation.Nullable
  public List<ApplicationHealthStateFilter> getApplicationFilters() {
    return applicationFilters;
  }

  public void setApplicationFilters(List<ApplicationHealthStateFilter> applicationFilters) {
    this.applicationFilters = applicationFilters;
  }


  public ClusterHealthChunkQueryDescription applicationHealthPolicies(ApplicationHealthPolicies applicationHealthPolicies) {
    this.applicationHealthPolicies = applicationHealthPolicies;
    return this;
  }

  /**
   * Get applicationHealthPolicies
   * @return applicationHealthPolicies
   */
  @javax.annotation.Nullable
  public ApplicationHealthPolicies getApplicationHealthPolicies() {
    return applicationHealthPolicies;
  }

  public void setApplicationHealthPolicies(ApplicationHealthPolicies applicationHealthPolicies) {
    this.applicationHealthPolicies = applicationHealthPolicies;
  }


  public ClusterHealthChunkQueryDescription clusterHealthPolicy(ClusterHealthPolicy clusterHealthPolicy) {
    this.clusterHealthPolicy = clusterHealthPolicy;
    return this;
  }

  /**
   * Get clusterHealthPolicy
   * @return clusterHealthPolicy
   */
  @javax.annotation.Nullable
  public ClusterHealthPolicy getClusterHealthPolicy() {
    return clusterHealthPolicy;
  }

  public void setClusterHealthPolicy(ClusterHealthPolicy clusterHealthPolicy) {
    this.clusterHealthPolicy = clusterHealthPolicy;
  }


  public ClusterHealthChunkQueryDescription nodeFilters(List<NodeHealthStateFilter> nodeFilters) {
    this.nodeFilters = nodeFilters;
    return this;
  }

  public ClusterHealthChunkQueryDescription addNodeFiltersItem(NodeHealthStateFilter nodeFiltersItem) {
    if (this.nodeFilters == null) {
      this.nodeFilters = new ArrayList<>();
    }
    this.nodeFilters.add(nodeFiltersItem);
    return this;
  }

  /**
   * Defines a list of filters that specify which nodes to be included in the returned cluster health chunk. If no filters are specified, no nodes are returned. All the nodes are used to evaluate the cluster&#39;s aggregated health state, regardless of the input filters. The cluster health chunk query may specify multiple node filters. For example, it can specify a filter to return all nodes with health state Error and another filter to always include a node identified by its NodeName. 
   * @return nodeFilters
   */
  @javax.annotation.Nullable
  public List<NodeHealthStateFilter> getNodeFilters() {
    return nodeFilters;
  }

  public void setNodeFilters(List<NodeHealthStateFilter> nodeFilters) {
    this.nodeFilters = nodeFilters;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClusterHealthChunkQueryDescription clusterHealthChunkQueryDescription = (ClusterHealthChunkQueryDescription) o;
    return Objects.equals(this.applicationFilters, clusterHealthChunkQueryDescription.applicationFilters) &&
        Objects.equals(this.applicationHealthPolicies, clusterHealthChunkQueryDescription.applicationHealthPolicies) &&
        Objects.equals(this.clusterHealthPolicy, clusterHealthChunkQueryDescription.clusterHealthPolicy) &&
        Objects.equals(this.nodeFilters, clusterHealthChunkQueryDescription.nodeFilters);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationFilters, applicationHealthPolicies, clusterHealthPolicy, nodeFilters);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClusterHealthChunkQueryDescription {\n");
    sb.append("    applicationFilters: ").append(toIndentedString(applicationFilters)).append("\n");
    sb.append("    applicationHealthPolicies: ").append(toIndentedString(applicationHealthPolicies)).append("\n");
    sb.append("    clusterHealthPolicy: ").append(toIndentedString(clusterHealthPolicy)).append("\n");
    sb.append("    nodeFilters: ").append(toIndentedString(nodeFilters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ApplicationFilters");
    openapiFields.add("ApplicationHealthPolicies");
    openapiFields.add("ClusterHealthPolicy");
    openapiFields.add("NodeFilters");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ClusterHealthChunkQueryDescription
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ClusterHealthChunkQueryDescription.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ClusterHealthChunkQueryDescription is not found in the empty JSON string", ClusterHealthChunkQueryDescription.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ClusterHealthChunkQueryDescription.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ClusterHealthChunkQueryDescription` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("ApplicationFilters") != null && !jsonObj.get("ApplicationFilters").isJsonNull()) {
        JsonArray jsonArrayapplicationFilters = jsonObj.getAsJsonArray("ApplicationFilters");
        if (jsonArrayapplicationFilters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ApplicationFilters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ApplicationFilters` to be an array in the JSON string but got `%s`", jsonObj.get("ApplicationFilters").toString()));
          }

          // validate the optional field `ApplicationFilters` (array)
          for (int i = 0; i < jsonArrayapplicationFilters.size(); i++) {
            ApplicationHealthStateFilter.validateJsonElement(jsonArrayapplicationFilters.get(i));
          };
        }
      }
      // validate the optional field `ApplicationHealthPolicies`
      if (jsonObj.get("ApplicationHealthPolicies") != null && !jsonObj.get("ApplicationHealthPolicies").isJsonNull()) {
        ApplicationHealthPolicies.validateJsonElement(jsonObj.get("ApplicationHealthPolicies"));
      }
      // validate the optional field `ClusterHealthPolicy`
      if (jsonObj.get("ClusterHealthPolicy") != null && !jsonObj.get("ClusterHealthPolicy").isJsonNull()) {
        ClusterHealthPolicy.validateJsonElement(jsonObj.get("ClusterHealthPolicy"));
      }
      if (jsonObj.get("NodeFilters") != null && !jsonObj.get("NodeFilters").isJsonNull()) {
        JsonArray jsonArraynodeFilters = jsonObj.getAsJsonArray("NodeFilters");
        if (jsonArraynodeFilters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("NodeFilters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `NodeFilters` to be an array in the JSON string but got `%s`", jsonObj.get("NodeFilters").toString()));
          }

          // validate the optional field `NodeFilters` (array)
          for (int i = 0; i < jsonArraynodeFilters.size(); i++) {
            NodeHealthStateFilter.validateJsonElement(jsonArraynodeFilters.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ClusterHealthChunkQueryDescription.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ClusterHealthChunkQueryDescription' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ClusterHealthChunkQueryDescription> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ClusterHealthChunkQueryDescription.class));

       return (TypeAdapter<T>) new TypeAdapter<ClusterHealthChunkQueryDescription>() {
           @Override
           public void write(JsonWriter out, ClusterHealthChunkQueryDescription value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ClusterHealthChunkQueryDescription read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ClusterHealthChunkQueryDescription given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ClusterHealthChunkQueryDescription
   * @throws IOException if the JSON string is invalid with respect to ClusterHealthChunkQueryDescription
   */
  public static ClusterHealthChunkQueryDescription fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ClusterHealthChunkQueryDescription.class);
  }

  /**
   * Convert an instance of ClusterHealthChunkQueryDescription to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

