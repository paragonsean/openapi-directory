/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.HealthState;
import org.openapitools.client.model.NodeDeactivationInfo;
import org.openapitools.client.model.NodeId;
import org.openapitools.client.model.NodeStatus;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Information about a node in Service Fabric cluster.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:57:08.089721-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NodeInfo {
  public static final String SERIALIZED_NAME_CODE_VERSION = "CodeVersion";
  @SerializedName(SERIALIZED_NAME_CODE_VERSION)
  private String codeVersion;

  public static final String SERIALIZED_NAME_CONFIG_VERSION = "ConfigVersion";
  @SerializedName(SERIALIZED_NAME_CONFIG_VERSION)
  private String configVersion;

  public static final String SERIALIZED_NAME_FAULT_DOMAIN = "FaultDomain";
  @SerializedName(SERIALIZED_NAME_FAULT_DOMAIN)
  private String faultDomain;

  public static final String SERIALIZED_NAME_HEALTH_STATE = "HealthState";
  @SerializedName(SERIALIZED_NAME_HEALTH_STATE)
  private HealthState healthState;

  public static final String SERIALIZED_NAME_ID = "Id";
  @SerializedName(SERIALIZED_NAME_ID)
  private NodeId id;

  public static final String SERIALIZED_NAME_INSTANCE_ID = "InstanceId";
  @SerializedName(SERIALIZED_NAME_INSTANCE_ID)
  private String instanceId;

  public static final String SERIALIZED_NAME_IP_ADDRESS_OR_F_Q_D_N = "IpAddressOrFQDN";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESS_OR_F_Q_D_N)
  private String ipAddressOrFQDN;

  public static final String SERIALIZED_NAME_IS_SEED_NODE = "IsSeedNode";
  @SerializedName(SERIALIZED_NAME_IS_SEED_NODE)
  private Boolean isSeedNode;

  public static final String SERIALIZED_NAME_IS_STOPPED = "IsStopped";
  @SerializedName(SERIALIZED_NAME_IS_STOPPED)
  private Boolean isStopped;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NODE_DEACTIVATION_INFO = "NodeDeactivationInfo";
  @SerializedName(SERIALIZED_NAME_NODE_DEACTIVATION_INFO)
  private NodeDeactivationInfo nodeDeactivationInfo;

  public static final String SERIALIZED_NAME_NODE_DOWN_AT = "NodeDownAt";
  @SerializedName(SERIALIZED_NAME_NODE_DOWN_AT)
  private OffsetDateTime nodeDownAt;

  public static final String SERIALIZED_NAME_NODE_DOWN_TIME_IN_SECONDS = "NodeDownTimeInSeconds";
  @SerializedName(SERIALIZED_NAME_NODE_DOWN_TIME_IN_SECONDS)
  private String nodeDownTimeInSeconds;

  public static final String SERIALIZED_NAME_NODE_STATUS = "NodeStatus";
  @SerializedName(SERIALIZED_NAME_NODE_STATUS)
  private NodeStatus nodeStatus;

  public static final String SERIALIZED_NAME_NODE_UP_AT = "NodeUpAt";
  @SerializedName(SERIALIZED_NAME_NODE_UP_AT)
  private OffsetDateTime nodeUpAt;

  public static final String SERIALIZED_NAME_NODE_UP_TIME_IN_SECONDS = "NodeUpTimeInSeconds";
  @SerializedName(SERIALIZED_NAME_NODE_UP_TIME_IN_SECONDS)
  private String nodeUpTimeInSeconds;

  public static final String SERIALIZED_NAME_TYPE = "Type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_UPGRADE_DOMAIN = "UpgradeDomain";
  @SerializedName(SERIALIZED_NAME_UPGRADE_DOMAIN)
  private String upgradeDomain;

  public NodeInfo() {
  }

  public NodeInfo codeVersion(String codeVersion) {
    this.codeVersion = codeVersion;
    return this;
  }

  /**
   * The version of Service Fabric binaries that the node is running.
   * @return codeVersion
   */
  @javax.annotation.Nullable
  public String getCodeVersion() {
    return codeVersion;
  }

  public void setCodeVersion(String codeVersion) {
    this.codeVersion = codeVersion;
  }


  public NodeInfo configVersion(String configVersion) {
    this.configVersion = configVersion;
    return this;
  }

  /**
   * The version of Service Fabric cluster manifest that the node is using.
   * @return configVersion
   */
  @javax.annotation.Nullable
  public String getConfigVersion() {
    return configVersion;
  }

  public void setConfigVersion(String configVersion) {
    this.configVersion = configVersion;
  }


  public NodeInfo faultDomain(String faultDomain) {
    this.faultDomain = faultDomain;
    return this;
  }

  /**
   * The fault domain of the node.
   * @return faultDomain
   */
  @javax.annotation.Nullable
  public String getFaultDomain() {
    return faultDomain;
  }

  public void setFaultDomain(String faultDomain) {
    this.faultDomain = faultDomain;
  }


  public NodeInfo healthState(HealthState healthState) {
    this.healthState = healthState;
    return this;
  }

  /**
   * Get healthState
   * @return healthState
   */
  @javax.annotation.Nullable
  public HealthState getHealthState() {
    return healthState;
  }

  public void setHealthState(HealthState healthState) {
    this.healthState = healthState;
  }


  public NodeInfo id(NodeId id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   * @return id
   */
  @javax.annotation.Nullable
  public NodeId getId() {
    return id;
  }

  public void setId(NodeId id) {
    this.id = id;
  }


  public NodeInfo instanceId(String instanceId) {
    this.instanceId = instanceId;
    return this;
  }

  /**
   * The id representing the node instance. While the Id of the node is deterministically generated from the node name and remains same across restarts, the InstanceId changes every time node restarts.
   * @return instanceId
   */
  @javax.annotation.Nullable
  public String getInstanceId() {
    return instanceId;
  }

  public void setInstanceId(String instanceId) {
    this.instanceId = instanceId;
  }


  public NodeInfo ipAddressOrFQDN(String ipAddressOrFQDN) {
    this.ipAddressOrFQDN = ipAddressOrFQDN;
    return this;
  }

  /**
   * The IP address or fully qualified domain name of the node.
   * @return ipAddressOrFQDN
   */
  @javax.annotation.Nullable
  public String getIpAddressOrFQDN() {
    return ipAddressOrFQDN;
  }

  public void setIpAddressOrFQDN(String ipAddressOrFQDN) {
    this.ipAddressOrFQDN = ipAddressOrFQDN;
  }


  public NodeInfo isSeedNode(Boolean isSeedNode) {
    this.isSeedNode = isSeedNode;
    return this;
  }

  /**
   * Indicates if the node is a seed node or not. Returns true if the node is a seed node, otherwise false. A quorum of seed nodes are required for proper operation of Service Fabric cluster.
   * @return isSeedNode
   */
  @javax.annotation.Nullable
  public Boolean getIsSeedNode() {
    return isSeedNode;
  }

  public void setIsSeedNode(Boolean isSeedNode) {
    this.isSeedNode = isSeedNode;
  }


  public NodeInfo isStopped(Boolean isStopped) {
    this.isStopped = isStopped;
    return this;
  }

  /**
   * Indicates if the node is stopped by calling stop node API or not. Returns true if the node is stopped, otherwise false.
   * @return isStopped
   */
  @javax.annotation.Nullable
  public Boolean getIsStopped() {
    return isStopped;
  }

  public void setIsStopped(Boolean isStopped) {
    this.isStopped = isStopped;
  }


  public NodeInfo name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of a Service Fabric node.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public NodeInfo nodeDeactivationInfo(NodeDeactivationInfo nodeDeactivationInfo) {
    this.nodeDeactivationInfo = nodeDeactivationInfo;
    return this;
  }

  /**
   * Get nodeDeactivationInfo
   * @return nodeDeactivationInfo
   */
  @javax.annotation.Nullable
  public NodeDeactivationInfo getNodeDeactivationInfo() {
    return nodeDeactivationInfo;
  }

  public void setNodeDeactivationInfo(NodeDeactivationInfo nodeDeactivationInfo) {
    this.nodeDeactivationInfo = nodeDeactivationInfo;
  }


  public NodeInfo nodeDownAt(OffsetDateTime nodeDownAt) {
    this.nodeDownAt = nodeDownAt;
    return this;
  }

  /**
   * Date time in UTC when the node went down. If node has never been down then this value will be zero date time.
   * @return nodeDownAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getNodeDownAt() {
    return nodeDownAt;
  }

  public void setNodeDownAt(OffsetDateTime nodeDownAt) {
    this.nodeDownAt = nodeDownAt;
  }


  public NodeInfo nodeDownTimeInSeconds(String nodeDownTimeInSeconds) {
    this.nodeDownTimeInSeconds = nodeDownTimeInSeconds;
    return this;
  }

  /**
   * Time in seconds since the node has been in NodeStatus Down. Value zero indicates node is not NodeStatus Down.
   * @return nodeDownTimeInSeconds
   */
  @javax.annotation.Nullable
  public String getNodeDownTimeInSeconds() {
    return nodeDownTimeInSeconds;
  }

  public void setNodeDownTimeInSeconds(String nodeDownTimeInSeconds) {
    this.nodeDownTimeInSeconds = nodeDownTimeInSeconds;
  }


  public NodeInfo nodeStatus(NodeStatus nodeStatus) {
    this.nodeStatus = nodeStatus;
    return this;
  }

  /**
   * Get nodeStatus
   * @return nodeStatus
   */
  @javax.annotation.Nullable
  public NodeStatus getNodeStatus() {
    return nodeStatus;
  }

  public void setNodeStatus(NodeStatus nodeStatus) {
    this.nodeStatus = nodeStatus;
  }


  public NodeInfo nodeUpAt(OffsetDateTime nodeUpAt) {
    this.nodeUpAt = nodeUpAt;
    return this;
  }

  /**
   * Date time in UTC when the node came up. If the node has never been up then this value will be zero date time.
   * @return nodeUpAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getNodeUpAt() {
    return nodeUpAt;
  }

  public void setNodeUpAt(OffsetDateTime nodeUpAt) {
    this.nodeUpAt = nodeUpAt;
  }


  public NodeInfo nodeUpTimeInSeconds(String nodeUpTimeInSeconds) {
    this.nodeUpTimeInSeconds = nodeUpTimeInSeconds;
    return this;
  }

  /**
   * Time in seconds since the node has been in NodeStatus Up. Value zero indicates that the node is not Up.
   * @return nodeUpTimeInSeconds
   */
  @javax.annotation.Nullable
  public String getNodeUpTimeInSeconds() {
    return nodeUpTimeInSeconds;
  }

  public void setNodeUpTimeInSeconds(String nodeUpTimeInSeconds) {
    this.nodeUpTimeInSeconds = nodeUpTimeInSeconds;
  }


  public NodeInfo type(String type) {
    this.type = type;
    return this;
  }

  /**
   * The type of the node.
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  public NodeInfo upgradeDomain(String upgradeDomain) {
    this.upgradeDomain = upgradeDomain;
    return this;
  }

  /**
   * The upgrade domain of the node.
   * @return upgradeDomain
   */
  @javax.annotation.Nullable
  public String getUpgradeDomain() {
    return upgradeDomain;
  }

  public void setUpgradeDomain(String upgradeDomain) {
    this.upgradeDomain = upgradeDomain;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NodeInfo nodeInfo = (NodeInfo) o;
    return Objects.equals(this.codeVersion, nodeInfo.codeVersion) &&
        Objects.equals(this.configVersion, nodeInfo.configVersion) &&
        Objects.equals(this.faultDomain, nodeInfo.faultDomain) &&
        Objects.equals(this.healthState, nodeInfo.healthState) &&
        Objects.equals(this.id, nodeInfo.id) &&
        Objects.equals(this.instanceId, nodeInfo.instanceId) &&
        Objects.equals(this.ipAddressOrFQDN, nodeInfo.ipAddressOrFQDN) &&
        Objects.equals(this.isSeedNode, nodeInfo.isSeedNode) &&
        Objects.equals(this.isStopped, nodeInfo.isStopped) &&
        Objects.equals(this.name, nodeInfo.name) &&
        Objects.equals(this.nodeDeactivationInfo, nodeInfo.nodeDeactivationInfo) &&
        Objects.equals(this.nodeDownAt, nodeInfo.nodeDownAt) &&
        Objects.equals(this.nodeDownTimeInSeconds, nodeInfo.nodeDownTimeInSeconds) &&
        Objects.equals(this.nodeStatus, nodeInfo.nodeStatus) &&
        Objects.equals(this.nodeUpAt, nodeInfo.nodeUpAt) &&
        Objects.equals(this.nodeUpTimeInSeconds, nodeInfo.nodeUpTimeInSeconds) &&
        Objects.equals(this.type, nodeInfo.type) &&
        Objects.equals(this.upgradeDomain, nodeInfo.upgradeDomain);
  }

  @Override
  public int hashCode() {
    return Objects.hash(codeVersion, configVersion, faultDomain, healthState, id, instanceId, ipAddressOrFQDN, isSeedNode, isStopped, name, nodeDeactivationInfo, nodeDownAt, nodeDownTimeInSeconds, nodeStatus, nodeUpAt, nodeUpTimeInSeconds, type, upgradeDomain);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NodeInfo {\n");
    sb.append("    codeVersion: ").append(toIndentedString(codeVersion)).append("\n");
    sb.append("    configVersion: ").append(toIndentedString(configVersion)).append("\n");
    sb.append("    faultDomain: ").append(toIndentedString(faultDomain)).append("\n");
    sb.append("    healthState: ").append(toIndentedString(healthState)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    instanceId: ").append(toIndentedString(instanceId)).append("\n");
    sb.append("    ipAddressOrFQDN: ").append(toIndentedString(ipAddressOrFQDN)).append("\n");
    sb.append("    isSeedNode: ").append(toIndentedString(isSeedNode)).append("\n");
    sb.append("    isStopped: ").append(toIndentedString(isStopped)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nodeDeactivationInfo: ").append(toIndentedString(nodeDeactivationInfo)).append("\n");
    sb.append("    nodeDownAt: ").append(toIndentedString(nodeDownAt)).append("\n");
    sb.append("    nodeDownTimeInSeconds: ").append(toIndentedString(nodeDownTimeInSeconds)).append("\n");
    sb.append("    nodeStatus: ").append(toIndentedString(nodeStatus)).append("\n");
    sb.append("    nodeUpAt: ").append(toIndentedString(nodeUpAt)).append("\n");
    sb.append("    nodeUpTimeInSeconds: ").append(toIndentedString(nodeUpTimeInSeconds)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    upgradeDomain: ").append(toIndentedString(upgradeDomain)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("CodeVersion");
    openapiFields.add("ConfigVersion");
    openapiFields.add("FaultDomain");
    openapiFields.add("HealthState");
    openapiFields.add("Id");
    openapiFields.add("InstanceId");
    openapiFields.add("IpAddressOrFQDN");
    openapiFields.add("IsSeedNode");
    openapiFields.add("IsStopped");
    openapiFields.add("Name");
    openapiFields.add("NodeDeactivationInfo");
    openapiFields.add("NodeDownAt");
    openapiFields.add("NodeDownTimeInSeconds");
    openapiFields.add("NodeStatus");
    openapiFields.add("NodeUpAt");
    openapiFields.add("NodeUpTimeInSeconds");
    openapiFields.add("Type");
    openapiFields.add("UpgradeDomain");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NodeInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NodeInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NodeInfo is not found in the empty JSON string", NodeInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NodeInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NodeInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("CodeVersion") != null && !jsonObj.get("CodeVersion").isJsonNull()) && !jsonObj.get("CodeVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CodeVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CodeVersion").toString()));
      }
      if ((jsonObj.get("ConfigVersion") != null && !jsonObj.get("ConfigVersion").isJsonNull()) && !jsonObj.get("ConfigVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ConfigVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ConfigVersion").toString()));
      }
      if ((jsonObj.get("FaultDomain") != null && !jsonObj.get("FaultDomain").isJsonNull()) && !jsonObj.get("FaultDomain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `FaultDomain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("FaultDomain").toString()));
      }
      // validate the optional field `HealthState`
      if (jsonObj.get("HealthState") != null && !jsonObj.get("HealthState").isJsonNull()) {
        HealthState.validateJsonElement(jsonObj.get("HealthState"));
      }
      // validate the optional field `Id`
      if (jsonObj.get("Id") != null && !jsonObj.get("Id").isJsonNull()) {
        NodeId.validateJsonElement(jsonObj.get("Id"));
      }
      if ((jsonObj.get("InstanceId") != null && !jsonObj.get("InstanceId").isJsonNull()) && !jsonObj.get("InstanceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `InstanceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("InstanceId").toString()));
      }
      if ((jsonObj.get("IpAddressOrFQDN") != null && !jsonObj.get("IpAddressOrFQDN").isJsonNull()) && !jsonObj.get("IpAddressOrFQDN").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `IpAddressOrFQDN` to be a primitive type in the JSON string but got `%s`", jsonObj.get("IpAddressOrFQDN").toString()));
      }
      if ((jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) && !jsonObj.get("Name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Name").toString()));
      }
      // validate the optional field `NodeDeactivationInfo`
      if (jsonObj.get("NodeDeactivationInfo") != null && !jsonObj.get("NodeDeactivationInfo").isJsonNull()) {
        NodeDeactivationInfo.validateJsonElement(jsonObj.get("NodeDeactivationInfo"));
      }
      if ((jsonObj.get("NodeDownTimeInSeconds") != null && !jsonObj.get("NodeDownTimeInSeconds").isJsonNull()) && !jsonObj.get("NodeDownTimeInSeconds").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeDownTimeInSeconds` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeDownTimeInSeconds").toString()));
      }
      // validate the optional field `NodeStatus`
      if (jsonObj.get("NodeStatus") != null && !jsonObj.get("NodeStatus").isJsonNull()) {
        NodeStatus.validateJsonElement(jsonObj.get("NodeStatus"));
      }
      if ((jsonObj.get("NodeUpTimeInSeconds") != null && !jsonObj.get("NodeUpTimeInSeconds").isJsonNull()) && !jsonObj.get("NodeUpTimeInSeconds").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeUpTimeInSeconds` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeUpTimeInSeconds").toString()));
      }
      if ((jsonObj.get("Type") != null && !jsonObj.get("Type").isJsonNull()) && !jsonObj.get("Type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Type").toString()));
      }
      if ((jsonObj.get("UpgradeDomain") != null && !jsonObj.get("UpgradeDomain").isJsonNull()) && !jsonObj.get("UpgradeDomain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `UpgradeDomain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("UpgradeDomain").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NodeInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NodeInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NodeInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NodeInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<NodeInfo>() {
           @Override
           public void write(JsonWriter out, NodeInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NodeInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NodeInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NodeInfo
   * @throws IOException if the JSON string is invalid with respect to NodeInfo
   */
  public static NodeInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NodeInfo.class);
  }

  /**
   * Convert an instance of NodeInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

