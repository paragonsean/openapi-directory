/*
 * ServiceFabricManagementClient
 * Azure Service Fabric Resource Provider API Client
 *
 * The version of the OpenAPI document: 2017-07-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ServiceTypeHealthPolicy;
import org.openapitools.client.model.ServiceTypeHealthPolicyMapItem;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines a health policy used to evaluate the health of an application or one of its children entities. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:56:34.252324-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ApplicationHealthPolicy {
  public static final String SERIALIZED_NAME_CONSIDER_WARNING_AS_ERROR = "ConsiderWarningAsError";
  @SerializedName(SERIALIZED_NAME_CONSIDER_WARNING_AS_ERROR)
  private Boolean considerWarningAsError = false;

  public static final String SERIALIZED_NAME_DEFAULT_SERVICE_TYPE_HEALTH_POLICY = "DefaultServiceTypeHealthPolicy";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SERVICE_TYPE_HEALTH_POLICY)
  private ServiceTypeHealthPolicy defaultServiceTypeHealthPolicy;

  public static final String SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_DEPLOYED_APPLICATIONS = "MaxPercentUnhealthyDeployedApplications";
  @SerializedName(SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_DEPLOYED_APPLICATIONS)
  private Integer maxPercentUnhealthyDeployedApplications;

  public static final String SERIALIZED_NAME_SERVICE_TYPE_HEALTH_POLICY_MAP = "ServiceTypeHealthPolicyMap";
  @SerializedName(SERIALIZED_NAME_SERVICE_TYPE_HEALTH_POLICY_MAP)
  private List<ServiceTypeHealthPolicyMapItem> serviceTypeHealthPolicyMap = new ArrayList<>();

  public ApplicationHealthPolicy() {
  }

  public ApplicationHealthPolicy considerWarningAsError(Boolean considerWarningAsError) {
    this.considerWarningAsError = considerWarningAsError;
    return this;
  }

  /**
   * Indicates whether warnings are treated with the same severity as errors.
   * @return considerWarningAsError
   */
  @javax.annotation.Nullable
  public Boolean getConsiderWarningAsError() {
    return considerWarningAsError;
  }

  public void setConsiderWarningAsError(Boolean considerWarningAsError) {
    this.considerWarningAsError = considerWarningAsError;
  }


  public ApplicationHealthPolicy defaultServiceTypeHealthPolicy(ServiceTypeHealthPolicy defaultServiceTypeHealthPolicy) {
    this.defaultServiceTypeHealthPolicy = defaultServiceTypeHealthPolicy;
    return this;
  }

  /**
   * Get defaultServiceTypeHealthPolicy
   * @return defaultServiceTypeHealthPolicy
   */
  @javax.annotation.Nullable
  public ServiceTypeHealthPolicy getDefaultServiceTypeHealthPolicy() {
    return defaultServiceTypeHealthPolicy;
  }

  public void setDefaultServiceTypeHealthPolicy(ServiceTypeHealthPolicy defaultServiceTypeHealthPolicy) {
    this.defaultServiceTypeHealthPolicy = defaultServiceTypeHealthPolicy;
  }


  public ApplicationHealthPolicy maxPercentUnhealthyDeployedApplications(Integer maxPercentUnhealthyDeployedApplications) {
    this.maxPercentUnhealthyDeployedApplications = maxPercentUnhealthyDeployedApplications;
    return this;
  }

  /**
   * The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100. The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error. This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster. The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero. 
   * @return maxPercentUnhealthyDeployedApplications
   */
  @javax.annotation.Nullable
  public Integer getMaxPercentUnhealthyDeployedApplications() {
    return maxPercentUnhealthyDeployedApplications;
  }

  public void setMaxPercentUnhealthyDeployedApplications(Integer maxPercentUnhealthyDeployedApplications) {
    this.maxPercentUnhealthyDeployedApplications = maxPercentUnhealthyDeployedApplications;
  }


  public ApplicationHealthPolicy serviceTypeHealthPolicyMap(List<ServiceTypeHealthPolicyMapItem> serviceTypeHealthPolicyMap) {
    this.serviceTypeHealthPolicyMap = serviceTypeHealthPolicyMap;
    return this;
  }

  public ApplicationHealthPolicy addServiceTypeHealthPolicyMapItem(ServiceTypeHealthPolicyMapItem serviceTypeHealthPolicyMapItem) {
    if (this.serviceTypeHealthPolicyMap == null) {
      this.serviceTypeHealthPolicyMap = new ArrayList<>();
    }
    this.serviceTypeHealthPolicyMap.add(serviceTypeHealthPolicyMapItem);
    return this;
  }

  /**
   * Defines a ServiceTypeHealthPolicy per service type name.  The entries in the map replace the default service type health policy for each specified service type. For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently. With policy per service type, there&#39;s more granular control of the health of the service.  If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation. 
   * @return serviceTypeHealthPolicyMap
   */
  @javax.annotation.Nullable
  public List<ServiceTypeHealthPolicyMapItem> getServiceTypeHealthPolicyMap() {
    return serviceTypeHealthPolicyMap;
  }

  public void setServiceTypeHealthPolicyMap(List<ServiceTypeHealthPolicyMapItem> serviceTypeHealthPolicyMap) {
    this.serviceTypeHealthPolicyMap = serviceTypeHealthPolicyMap;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApplicationHealthPolicy applicationHealthPolicy = (ApplicationHealthPolicy) o;
    return Objects.equals(this.considerWarningAsError, applicationHealthPolicy.considerWarningAsError) &&
        Objects.equals(this.defaultServiceTypeHealthPolicy, applicationHealthPolicy.defaultServiceTypeHealthPolicy) &&
        Objects.equals(this.maxPercentUnhealthyDeployedApplications, applicationHealthPolicy.maxPercentUnhealthyDeployedApplications) &&
        Objects.equals(this.serviceTypeHealthPolicyMap, applicationHealthPolicy.serviceTypeHealthPolicyMap);
  }

  @Override
  public int hashCode() {
    return Objects.hash(considerWarningAsError, defaultServiceTypeHealthPolicy, maxPercentUnhealthyDeployedApplications, serviceTypeHealthPolicyMap);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApplicationHealthPolicy {\n");
    sb.append("    considerWarningAsError: ").append(toIndentedString(considerWarningAsError)).append("\n");
    sb.append("    defaultServiceTypeHealthPolicy: ").append(toIndentedString(defaultServiceTypeHealthPolicy)).append("\n");
    sb.append("    maxPercentUnhealthyDeployedApplications: ").append(toIndentedString(maxPercentUnhealthyDeployedApplications)).append("\n");
    sb.append("    serviceTypeHealthPolicyMap: ").append(toIndentedString(serviceTypeHealthPolicyMap)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ConsiderWarningAsError");
    openapiFields.add("DefaultServiceTypeHealthPolicy");
    openapiFields.add("MaxPercentUnhealthyDeployedApplications");
    openapiFields.add("ServiceTypeHealthPolicyMap");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ApplicationHealthPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ApplicationHealthPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApplicationHealthPolicy is not found in the empty JSON string", ApplicationHealthPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ApplicationHealthPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ApplicationHealthPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `DefaultServiceTypeHealthPolicy`
      if (jsonObj.get("DefaultServiceTypeHealthPolicy") != null && !jsonObj.get("DefaultServiceTypeHealthPolicy").isJsonNull()) {
        ServiceTypeHealthPolicy.validateJsonElement(jsonObj.get("DefaultServiceTypeHealthPolicy"));
      }
      if (jsonObj.get("ServiceTypeHealthPolicyMap") != null && !jsonObj.get("ServiceTypeHealthPolicyMap").isJsonNull()) {
        JsonArray jsonArrayserviceTypeHealthPolicyMap = jsonObj.getAsJsonArray("ServiceTypeHealthPolicyMap");
        if (jsonArrayserviceTypeHealthPolicyMap != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ServiceTypeHealthPolicyMap").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ServiceTypeHealthPolicyMap` to be an array in the JSON string but got `%s`", jsonObj.get("ServiceTypeHealthPolicyMap").toString()));
          }

          // validate the optional field `ServiceTypeHealthPolicyMap` (array)
          for (int i = 0; i < jsonArrayserviceTypeHealthPolicyMap.size(); i++) {
            ServiceTypeHealthPolicyMapItem.validateJsonElement(jsonArrayserviceTypeHealthPolicyMap.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApplicationHealthPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApplicationHealthPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApplicationHealthPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApplicationHealthPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<ApplicationHealthPolicy>() {
           @Override
           public void write(JsonWriter out, ApplicationHealthPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApplicationHealthPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ApplicationHealthPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ApplicationHealthPolicy
   * @throws IOException if the JSON string is invalid with respect to ApplicationHealthPolicy
   */
  public static ApplicationHealthPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApplicationHealthPolicy.class);
  }

  /**
   * Convert an instance of ApplicationHealthPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

