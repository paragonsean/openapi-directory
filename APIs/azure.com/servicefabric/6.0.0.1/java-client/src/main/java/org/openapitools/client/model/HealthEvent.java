/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 6.0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.HealthState;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents health information reported on a health entity, such as cluster, application or node, with additional metadata added by the Health Manager. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:56:33.392772-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class HealthEvent {
  public static final String SERIALIZED_NAME_DESCRIPTION = "Description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_HEALTH_STATE = "HealthState";
  @SerializedName(SERIALIZED_NAME_HEALTH_STATE)
  private HealthState healthState;

  public static final String SERIALIZED_NAME_PROPERTY = "Property";
  @SerializedName(SERIALIZED_NAME_PROPERTY)
  private String property;

  public static final String SERIALIZED_NAME_REMOVE_WHEN_EXPIRED = "RemoveWhenExpired";
  @SerializedName(SERIALIZED_NAME_REMOVE_WHEN_EXPIRED)
  private Boolean removeWhenExpired;

  public static final String SERIALIZED_NAME_SEQUENCE_NUMBER = "SequenceNumber";
  @SerializedName(SERIALIZED_NAME_SEQUENCE_NUMBER)
  private String sequenceNumber;

  public static final String SERIALIZED_NAME_SOURCE_ID = "SourceId";
  @SerializedName(SERIALIZED_NAME_SOURCE_ID)
  private String sourceId;

  public static final String SERIALIZED_NAME_TIME_TO_LIVE_IN_MILLI_SECONDS = "TimeToLiveInMilliSeconds";
  @SerializedName(SERIALIZED_NAME_TIME_TO_LIVE_IN_MILLI_SECONDS)
  private String timeToLiveInMilliSeconds;

  public static final String SERIALIZED_NAME_IS_EXPIRED = "IsExpired";
  @SerializedName(SERIALIZED_NAME_IS_EXPIRED)
  private Boolean isExpired;

  public static final String SERIALIZED_NAME_LAST_ERROR_TRANSITION_AT = "LastErrorTransitionAt";
  @SerializedName(SERIALIZED_NAME_LAST_ERROR_TRANSITION_AT)
  private OffsetDateTime lastErrorTransitionAt;

  public static final String SERIALIZED_NAME_LAST_MODIFIED_UTC_TIMESTAMP = "LastModifiedUtcTimestamp";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED_UTC_TIMESTAMP)
  private OffsetDateTime lastModifiedUtcTimestamp;

  public static final String SERIALIZED_NAME_LAST_OK_TRANSITION_AT = "LastOkTransitionAt";
  @SerializedName(SERIALIZED_NAME_LAST_OK_TRANSITION_AT)
  private OffsetDateTime lastOkTransitionAt;

  public static final String SERIALIZED_NAME_LAST_WARNING_TRANSITION_AT = "LastWarningTransitionAt";
  @SerializedName(SERIALIZED_NAME_LAST_WARNING_TRANSITION_AT)
  private OffsetDateTime lastWarningTransitionAt;

  public static final String SERIALIZED_NAME_SOURCE_UTC_TIMESTAMP = "SourceUtcTimestamp";
  @SerializedName(SERIALIZED_NAME_SOURCE_UTC_TIMESTAMP)
  private OffsetDateTime sourceUtcTimestamp;

  public HealthEvent() {
  }

  public HealthEvent description(String description) {
    this.description = description;
    return this;
  }

  /**
   * The description of the health information. It represents free text used to add human readable information about the report. The maximum string length for the description is 4096 characters. If the provided string is longer, it will be automatically truncated. When truncated, the last characters of the description contain a marker \&quot;[Truncated]\&quot;, and total string size is 4096 characters. The presence of the marker indicates to users that truncation occurred. Note that when truncated, the description has less than 4096 characters from the original string. 
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public HealthEvent healthState(HealthState healthState) {
    this.healthState = healthState;
    return this;
  }

  /**
   * Get healthState
   * @return healthState
   */
  @javax.annotation.Nonnull
  public HealthState getHealthState() {
    return healthState;
  }

  public void setHealthState(HealthState healthState) {
    this.healthState = healthState;
  }


  public HealthEvent property(String property) {
    this.property = property;
    return this;
  }

  /**
   * The property of the health information. An entity can have health reports for different properties. The property is a string and not a fixed enumeration to allow the reporter flexibility to categorize the state condition that triggers the report. For example, a reporter with SourceId \&quot;LocalWatchdog\&quot; can monitor the state of the available disk on a node, so it can report \&quot;AvailableDisk\&quot; property on that node. The same reporter can monitor the node connectivity, so it can report a property \&quot;Connectivity\&quot; on the same node. In the health store, these reports are treated as separate health events for the specified node.  Together with the SourceId, the property uniquely identifies the health information. 
   * @return property
   */
  @javax.annotation.Nonnull
  public String getProperty() {
    return property;
  }

  public void setProperty(String property) {
    this.property = property;
  }


  public HealthEvent removeWhenExpired(Boolean removeWhenExpired) {
    this.removeWhenExpired = removeWhenExpired;
    return this;
  }

  /**
   * Value that indicates whether the report is removed from health store when it expires. If set to true, the report is remopved from the health store after it expires. If set to false, the report is treated as an error when expired. The value of this property is false by default. When clients report periodically, they should set RemoveWhenExpired false (default). This way, is the reporter has issues (eg. deadlock) and can&#39;t report, the entity is evaluated at error when the health report expires. This flags the entity as being in Error health state. 
   * @return removeWhenExpired
   */
  @javax.annotation.Nullable
  public Boolean getRemoveWhenExpired() {
    return removeWhenExpired;
  }

  public void setRemoveWhenExpired(Boolean removeWhenExpired) {
    this.removeWhenExpired = removeWhenExpired;
  }


  public HealthEvent sequenceNumber(String sequenceNumber) {
    this.sequenceNumber = sequenceNumber;
    return this;
  }

  /**
   * The sequence number for this health report as a numeric string. The report sequence number is used by the health store to detect stale reports. If not specified, a sequence number is auto-generated by the health client when a report is added. 
   * @return sequenceNumber
   */
  @javax.annotation.Nullable
  public String getSequenceNumber() {
    return sequenceNumber;
  }

  public void setSequenceNumber(String sequenceNumber) {
    this.sequenceNumber = sequenceNumber;
  }


  public HealthEvent sourceId(String sourceId) {
    this.sourceId = sourceId;
    return this;
  }

  /**
   * The source name which identifies the client/watchdog/system component which generated the health information. 
   * @return sourceId
   */
  @javax.annotation.Nonnull
  public String getSourceId() {
    return sourceId;
  }

  public void setSourceId(String sourceId) {
    this.sourceId = sourceId;
  }


  public HealthEvent timeToLiveInMilliSeconds(String timeToLiveInMilliSeconds) {
    this.timeToLiveInMilliSeconds = timeToLiveInMilliSeconds;
    return this;
  }

  /**
   * The duration for which this health report is valid. This field is using ISO8601 format for specifying the duration. When clients report periodically, they should send reports with higher frequency than time to live. If clients report on transition, they can set the time to live to infinite. When time to live expires, the health event that contains the health information is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if RemoveWhenExpired false.  If not specified, time to live defaults to infinite value. 
   * @return timeToLiveInMilliSeconds
   */
  @javax.annotation.Nullable
  public String getTimeToLiveInMilliSeconds() {
    return timeToLiveInMilliSeconds;
  }

  public void setTimeToLiveInMilliSeconds(String timeToLiveInMilliSeconds) {
    this.timeToLiveInMilliSeconds = timeToLiveInMilliSeconds;
  }


  public HealthEvent isExpired(Boolean isExpired) {
    this.isExpired = isExpired;
    return this;
  }

  /**
   * Returns true if the health event is expired, otherwise false.
   * @return isExpired
   */
  @javax.annotation.Nullable
  public Boolean getIsExpired() {
    return isExpired;
  }

  public void setIsExpired(Boolean isExpired) {
    this.isExpired = isExpired;
  }


  public HealthEvent lastErrorTransitionAt(OffsetDateTime lastErrorTransitionAt) {
    this.lastErrorTransitionAt = lastErrorTransitionAt;
    return this;
  }

  /**
   * If the current health state is &#39;Error&#39;, this property returns the time at which the health report was first reported with &#39;Error&#39;. For periodic reporting, many reports with the same state may have been generated however, this property returns only the date and time at the first &#39;Error&#39; health report was received.  If the current health state is &#39;Ok&#39; or &#39;Warning&#39;, returns the date and time at which the health state was last in &#39;Error&#39;, before transitioning to a different state.  If the health state was never &#39;Error&#39;, the value will be zero date-time. 
   * @return lastErrorTransitionAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastErrorTransitionAt() {
    return lastErrorTransitionAt;
  }

  public void setLastErrorTransitionAt(OffsetDateTime lastErrorTransitionAt) {
    this.lastErrorTransitionAt = lastErrorTransitionAt;
  }


  public HealthEvent lastModifiedUtcTimestamp(OffsetDateTime lastModifiedUtcTimestamp) {
    this.lastModifiedUtcTimestamp = lastModifiedUtcTimestamp;
    return this;
  }

  /**
   * The date and time when the health report was last modified by the health store.
   * @return lastModifiedUtcTimestamp
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastModifiedUtcTimestamp() {
    return lastModifiedUtcTimestamp;
  }

  public void setLastModifiedUtcTimestamp(OffsetDateTime lastModifiedUtcTimestamp) {
    this.lastModifiedUtcTimestamp = lastModifiedUtcTimestamp;
  }


  public HealthEvent lastOkTransitionAt(OffsetDateTime lastOkTransitionAt) {
    this.lastOkTransitionAt = lastOkTransitionAt;
    return this;
  }

  /**
   * If the current health state is &#39;Ok&#39;, this property returns the time at which the health report was first reported with &#39;Ok&#39;. For periodic reporting, many reports with the same state may have been generated. This property returns the date and time when the first &#39;Ok&#39; health report was received.  If the current health state is &#39;Error&#39; or &#39;Warning&#39;, returns the date and time at which the health state was last in &#39;Ok&#39;, before transitioning to a different state.  If the health state was never &#39;Ok&#39;, the value will be zero date-time. 
   * @return lastOkTransitionAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastOkTransitionAt() {
    return lastOkTransitionAt;
  }

  public void setLastOkTransitionAt(OffsetDateTime lastOkTransitionAt) {
    this.lastOkTransitionAt = lastOkTransitionAt;
  }


  public HealthEvent lastWarningTransitionAt(OffsetDateTime lastWarningTransitionAt) {
    this.lastWarningTransitionAt = lastWarningTransitionAt;
    return this;
  }

  /**
   * If the current health state is &#39;Warning&#39;, this property returns the time at which the health report was first reported with &#39;Warning&#39;. For periodic reporting, many reports with the same state may have been generated however, this property returns only the date and time at the first &#39;Warning&#39; health report was received.  If the current health state is &#39;Ok&#39; or &#39;Error&#39;, returns the date and time at which the health state was last in &#39;Warning&#39;, before transitioning to a different state.  If the health state was never &#39;Warning&#39;, the value will be zero date-time. 
   * @return lastWarningTransitionAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastWarningTransitionAt() {
    return lastWarningTransitionAt;
  }

  public void setLastWarningTransitionAt(OffsetDateTime lastWarningTransitionAt) {
    this.lastWarningTransitionAt = lastWarningTransitionAt;
  }


  public HealthEvent sourceUtcTimestamp(OffsetDateTime sourceUtcTimestamp) {
    this.sourceUtcTimestamp = sourceUtcTimestamp;
    return this;
  }

  /**
   * The date and time when the health report was sent by the source.
   * @return sourceUtcTimestamp
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSourceUtcTimestamp() {
    return sourceUtcTimestamp;
  }

  public void setSourceUtcTimestamp(OffsetDateTime sourceUtcTimestamp) {
    this.sourceUtcTimestamp = sourceUtcTimestamp;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HealthEvent healthEvent = (HealthEvent) o;
    return Objects.equals(this.description, healthEvent.description) &&
        Objects.equals(this.healthState, healthEvent.healthState) &&
        Objects.equals(this.property, healthEvent.property) &&
        Objects.equals(this.removeWhenExpired, healthEvent.removeWhenExpired) &&
        Objects.equals(this.sequenceNumber, healthEvent.sequenceNumber) &&
        Objects.equals(this.sourceId, healthEvent.sourceId) &&
        Objects.equals(this.timeToLiveInMilliSeconds, healthEvent.timeToLiveInMilliSeconds) &&
        Objects.equals(this.isExpired, healthEvent.isExpired) &&
        Objects.equals(this.lastErrorTransitionAt, healthEvent.lastErrorTransitionAt) &&
        Objects.equals(this.lastModifiedUtcTimestamp, healthEvent.lastModifiedUtcTimestamp) &&
        Objects.equals(this.lastOkTransitionAt, healthEvent.lastOkTransitionAt) &&
        Objects.equals(this.lastWarningTransitionAt, healthEvent.lastWarningTransitionAt) &&
        Objects.equals(this.sourceUtcTimestamp, healthEvent.sourceUtcTimestamp);
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, healthState, property, removeWhenExpired, sequenceNumber, sourceId, timeToLiveInMilliSeconds, isExpired, lastErrorTransitionAt, lastModifiedUtcTimestamp, lastOkTransitionAt, lastWarningTransitionAt, sourceUtcTimestamp);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HealthEvent {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    healthState: ").append(toIndentedString(healthState)).append("\n");
    sb.append("    property: ").append(toIndentedString(property)).append("\n");
    sb.append("    removeWhenExpired: ").append(toIndentedString(removeWhenExpired)).append("\n");
    sb.append("    sequenceNumber: ").append(toIndentedString(sequenceNumber)).append("\n");
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    timeToLiveInMilliSeconds: ").append(toIndentedString(timeToLiveInMilliSeconds)).append("\n");
    sb.append("    isExpired: ").append(toIndentedString(isExpired)).append("\n");
    sb.append("    lastErrorTransitionAt: ").append(toIndentedString(lastErrorTransitionAt)).append("\n");
    sb.append("    lastModifiedUtcTimestamp: ").append(toIndentedString(lastModifiedUtcTimestamp)).append("\n");
    sb.append("    lastOkTransitionAt: ").append(toIndentedString(lastOkTransitionAt)).append("\n");
    sb.append("    lastWarningTransitionAt: ").append(toIndentedString(lastWarningTransitionAt)).append("\n");
    sb.append("    sourceUtcTimestamp: ").append(toIndentedString(sourceUtcTimestamp)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Description");
    openapiFields.add("HealthState");
    openapiFields.add("Property");
    openapiFields.add("RemoveWhenExpired");
    openapiFields.add("SequenceNumber");
    openapiFields.add("SourceId");
    openapiFields.add("TimeToLiveInMilliSeconds");
    openapiFields.add("IsExpired");
    openapiFields.add("LastErrorTransitionAt");
    openapiFields.add("LastModifiedUtcTimestamp");
    openapiFields.add("LastOkTransitionAt");
    openapiFields.add("LastWarningTransitionAt");
    openapiFields.add("SourceUtcTimestamp");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("HealthState");
    openapiRequiredFields.add("Property");
    openapiRequiredFields.add("SourceId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to HealthEvent
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!HealthEvent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HealthEvent is not found in the empty JSON string", HealthEvent.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!HealthEvent.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `HealthEvent` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : HealthEvent.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("Description") != null && !jsonObj.get("Description").isJsonNull()) && !jsonObj.get("Description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Description").toString()));
      }
      // validate the required field `HealthState`
      HealthState.validateJsonElement(jsonObj.get("HealthState"));
      if (!jsonObj.get("Property").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Property` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Property").toString()));
      }
      if ((jsonObj.get("SequenceNumber") != null && !jsonObj.get("SequenceNumber").isJsonNull()) && !jsonObj.get("SequenceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SequenceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SequenceNumber").toString()));
      }
      if (!jsonObj.get("SourceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SourceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SourceId").toString()));
      }
      if ((jsonObj.get("TimeToLiveInMilliSeconds") != null && !jsonObj.get("TimeToLiveInMilliSeconds").isJsonNull()) && !jsonObj.get("TimeToLiveInMilliSeconds").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TimeToLiveInMilliSeconds` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TimeToLiveInMilliSeconds").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HealthEvent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HealthEvent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HealthEvent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HealthEvent.class));

       return (TypeAdapter<T>) new TypeAdapter<HealthEvent>() {
           @Override
           public void write(JsonWriter out, HealthEvent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HealthEvent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of HealthEvent given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of HealthEvent
   * @throws IOException if the JSON string is invalid with respect to HealthEvent
   */
  public static HealthEvent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HealthEvent.class);
  }

  /**
   * Convert an instance of HealthEvent to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

