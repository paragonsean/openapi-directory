/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 7.0.0.42
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents data structure that contains load information for a certain metric on a node.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:56:34.135207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NodeLoadMetricInformation {
  public static final String SERIALIZED_NAME_BUFFERED_NODE_CAPACITY_REMAINING = "BufferedNodeCapacityRemaining";
  @SerializedName(SERIALIZED_NAME_BUFFERED_NODE_CAPACITY_REMAINING)
  private Double bufferedNodeCapacityRemaining;

  public static final String SERIALIZED_NAME_CURRENT_NODE_LOAD = "CurrentNodeLoad";
  @SerializedName(SERIALIZED_NAME_CURRENT_NODE_LOAD)
  private Double currentNodeLoad;

  public static final String SERIALIZED_NAME_IS_CAPACITY_VIOLATION = "IsCapacityViolation";
  @SerializedName(SERIALIZED_NAME_IS_CAPACITY_VIOLATION)
  private Boolean isCapacityViolation;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NODE_BUFFERED_CAPACITY = "NodeBufferedCapacity";
  @SerializedName(SERIALIZED_NAME_NODE_BUFFERED_CAPACITY)
  private String nodeBufferedCapacity;

  public static final String SERIALIZED_NAME_NODE_CAPACITY = "NodeCapacity";
  @SerializedName(SERIALIZED_NAME_NODE_CAPACITY)
  private String nodeCapacity;

  public static final String SERIALIZED_NAME_NODE_CAPACITY_REMAINING = "NodeCapacityRemaining";
  @SerializedName(SERIALIZED_NAME_NODE_CAPACITY_REMAINING)
  private Double nodeCapacityRemaining;

  public static final String SERIALIZED_NAME_NODE_LOAD = "NodeLoad";
  @SerializedName(SERIALIZED_NAME_NODE_LOAD)
  private String nodeLoad;

  public static final String SERIALIZED_NAME_NODE_REMAINING_BUFFERED_CAPACITY = "NodeRemainingBufferedCapacity";
  @SerializedName(SERIALIZED_NAME_NODE_REMAINING_BUFFERED_CAPACITY)
  private String nodeRemainingBufferedCapacity;

  public static final String SERIALIZED_NAME_NODE_REMAINING_CAPACITY = "NodeRemainingCapacity";
  @SerializedName(SERIALIZED_NAME_NODE_REMAINING_CAPACITY)
  private String nodeRemainingCapacity;

  public static final String SERIALIZED_NAME_PLANNED_NODE_LOAD_REMOVAL = "PlannedNodeLoadRemoval";
  @SerializedName(SERIALIZED_NAME_PLANNED_NODE_LOAD_REMOVAL)
  private Double plannedNodeLoadRemoval;

  public NodeLoadMetricInformation() {
  }

  public NodeLoadMetricInformation bufferedNodeCapacityRemaining(Double bufferedNodeCapacityRemaining) {
    this.bufferedNodeCapacityRemaining = bufferedNodeCapacityRemaining;
    return this;
  }

  /**
   * The remaining capacity which is not reserved by NodeBufferPercentage for this metric on the node.
   * @return bufferedNodeCapacityRemaining
   */
  @javax.annotation.Nullable
  public Double getBufferedNodeCapacityRemaining() {
    return bufferedNodeCapacityRemaining;
  }

  public void setBufferedNodeCapacityRemaining(Double bufferedNodeCapacityRemaining) {
    this.bufferedNodeCapacityRemaining = bufferedNodeCapacityRemaining;
  }


  public NodeLoadMetricInformation currentNodeLoad(Double currentNodeLoad) {
    this.currentNodeLoad = currentNodeLoad;
    return this;
  }

  /**
   * Current load on the node for this metric.
   * @return currentNodeLoad
   */
  @javax.annotation.Nullable
  public Double getCurrentNodeLoad() {
    return currentNodeLoad;
  }

  public void setCurrentNodeLoad(Double currentNodeLoad) {
    this.currentNodeLoad = currentNodeLoad;
  }


  public NodeLoadMetricInformation isCapacityViolation(Boolean isCapacityViolation) {
    this.isCapacityViolation = isCapacityViolation;
    return this;
  }

  /**
   * Indicates if there is a capacity violation for this metric on the node.
   * @return isCapacityViolation
   */
  @javax.annotation.Nullable
  public Boolean getIsCapacityViolation() {
    return isCapacityViolation;
  }

  public void setIsCapacityViolation(Boolean isCapacityViolation) {
    this.isCapacityViolation = isCapacityViolation;
  }


  public NodeLoadMetricInformation name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the metric for which this load information is provided.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public NodeLoadMetricInformation nodeBufferedCapacity(String nodeBufferedCapacity) {
    this.nodeBufferedCapacity = nodeBufferedCapacity;
    return this;
  }

  /**
   * The value that indicates the reserved capacity for this metric on the node.
   * @return nodeBufferedCapacity
   */
  @javax.annotation.Nullable
  public String getNodeBufferedCapacity() {
    return nodeBufferedCapacity;
  }

  public void setNodeBufferedCapacity(String nodeBufferedCapacity) {
    this.nodeBufferedCapacity = nodeBufferedCapacity;
  }


  public NodeLoadMetricInformation nodeCapacity(String nodeCapacity) {
    this.nodeCapacity = nodeCapacity;
    return this;
  }

  /**
   * Total capacity on the node for this metric.
   * @return nodeCapacity
   */
  @javax.annotation.Nullable
  public String getNodeCapacity() {
    return nodeCapacity;
  }

  public void setNodeCapacity(String nodeCapacity) {
    this.nodeCapacity = nodeCapacity;
  }


  public NodeLoadMetricInformation nodeCapacityRemaining(Double nodeCapacityRemaining) {
    this.nodeCapacityRemaining = nodeCapacityRemaining;
    return this;
  }

  /**
   * The remaining capacity on the node for the metric.
   * @return nodeCapacityRemaining
   */
  @javax.annotation.Nullable
  public Double getNodeCapacityRemaining() {
    return nodeCapacityRemaining;
  }

  public void setNodeCapacityRemaining(Double nodeCapacityRemaining) {
    this.nodeCapacityRemaining = nodeCapacityRemaining;
  }


  public NodeLoadMetricInformation nodeLoad(String nodeLoad) {
    this.nodeLoad = nodeLoad;
    return this;
  }

  /**
   * Current load on the node for this metric. In future releases of Service Fabric this parameter will be deprecated in favor of CurrentNodeLoad.
   * @return nodeLoad
   */
  @javax.annotation.Nullable
  public String getNodeLoad() {
    return nodeLoad;
  }

  public void setNodeLoad(String nodeLoad) {
    this.nodeLoad = nodeLoad;
  }


  public NodeLoadMetricInformation nodeRemainingBufferedCapacity(String nodeRemainingBufferedCapacity) {
    this.nodeRemainingBufferedCapacity = nodeRemainingBufferedCapacity;
    return this;
  }

  /**
   * The remaining reserved capacity for this metric on the node. In future releases of Service Fabric this parameter will be deprecated in favor of BufferedNodeCapacityRemaining.
   * @return nodeRemainingBufferedCapacity
   */
  @javax.annotation.Nullable
  public String getNodeRemainingBufferedCapacity() {
    return nodeRemainingBufferedCapacity;
  }

  public void setNodeRemainingBufferedCapacity(String nodeRemainingBufferedCapacity) {
    this.nodeRemainingBufferedCapacity = nodeRemainingBufferedCapacity;
  }


  public NodeLoadMetricInformation nodeRemainingCapacity(String nodeRemainingCapacity) {
    this.nodeRemainingCapacity = nodeRemainingCapacity;
    return this;
  }

  /**
   * The remaining capacity on the node for this metric. In future releases of Service Fabric this parameter will be deprecated in favor of NodeCapacityRemaining.
   * @return nodeRemainingCapacity
   */
  @javax.annotation.Nullable
  public String getNodeRemainingCapacity() {
    return nodeRemainingCapacity;
  }

  public void setNodeRemainingCapacity(String nodeRemainingCapacity) {
    this.nodeRemainingCapacity = nodeRemainingCapacity;
  }


  public NodeLoadMetricInformation plannedNodeLoadRemoval(Double plannedNodeLoadRemoval) {
    this.plannedNodeLoadRemoval = plannedNodeLoadRemoval;
    return this;
  }

  /**
   * This value represents the load of the replicas that are planned to be removed in the future. This kind of load is reported for replicas that are currently being moving to other nodes and for replicas that are currently being dropped but still use the load on the source node.
   * @return plannedNodeLoadRemoval
   */
  @javax.annotation.Nullable
  public Double getPlannedNodeLoadRemoval() {
    return plannedNodeLoadRemoval;
  }

  public void setPlannedNodeLoadRemoval(Double plannedNodeLoadRemoval) {
    this.plannedNodeLoadRemoval = plannedNodeLoadRemoval;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NodeLoadMetricInformation nodeLoadMetricInformation = (NodeLoadMetricInformation) o;
    return Objects.equals(this.bufferedNodeCapacityRemaining, nodeLoadMetricInformation.bufferedNodeCapacityRemaining) &&
        Objects.equals(this.currentNodeLoad, nodeLoadMetricInformation.currentNodeLoad) &&
        Objects.equals(this.isCapacityViolation, nodeLoadMetricInformation.isCapacityViolation) &&
        Objects.equals(this.name, nodeLoadMetricInformation.name) &&
        Objects.equals(this.nodeBufferedCapacity, nodeLoadMetricInformation.nodeBufferedCapacity) &&
        Objects.equals(this.nodeCapacity, nodeLoadMetricInformation.nodeCapacity) &&
        Objects.equals(this.nodeCapacityRemaining, nodeLoadMetricInformation.nodeCapacityRemaining) &&
        Objects.equals(this.nodeLoad, nodeLoadMetricInformation.nodeLoad) &&
        Objects.equals(this.nodeRemainingBufferedCapacity, nodeLoadMetricInformation.nodeRemainingBufferedCapacity) &&
        Objects.equals(this.nodeRemainingCapacity, nodeLoadMetricInformation.nodeRemainingCapacity) &&
        Objects.equals(this.plannedNodeLoadRemoval, nodeLoadMetricInformation.plannedNodeLoadRemoval);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bufferedNodeCapacityRemaining, currentNodeLoad, isCapacityViolation, name, nodeBufferedCapacity, nodeCapacity, nodeCapacityRemaining, nodeLoad, nodeRemainingBufferedCapacity, nodeRemainingCapacity, plannedNodeLoadRemoval);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NodeLoadMetricInformation {\n");
    sb.append("    bufferedNodeCapacityRemaining: ").append(toIndentedString(bufferedNodeCapacityRemaining)).append("\n");
    sb.append("    currentNodeLoad: ").append(toIndentedString(currentNodeLoad)).append("\n");
    sb.append("    isCapacityViolation: ").append(toIndentedString(isCapacityViolation)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nodeBufferedCapacity: ").append(toIndentedString(nodeBufferedCapacity)).append("\n");
    sb.append("    nodeCapacity: ").append(toIndentedString(nodeCapacity)).append("\n");
    sb.append("    nodeCapacityRemaining: ").append(toIndentedString(nodeCapacityRemaining)).append("\n");
    sb.append("    nodeLoad: ").append(toIndentedString(nodeLoad)).append("\n");
    sb.append("    nodeRemainingBufferedCapacity: ").append(toIndentedString(nodeRemainingBufferedCapacity)).append("\n");
    sb.append("    nodeRemainingCapacity: ").append(toIndentedString(nodeRemainingCapacity)).append("\n");
    sb.append("    plannedNodeLoadRemoval: ").append(toIndentedString(plannedNodeLoadRemoval)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("BufferedNodeCapacityRemaining");
    openapiFields.add("CurrentNodeLoad");
    openapiFields.add("IsCapacityViolation");
    openapiFields.add("Name");
    openapiFields.add("NodeBufferedCapacity");
    openapiFields.add("NodeCapacity");
    openapiFields.add("NodeCapacityRemaining");
    openapiFields.add("NodeLoad");
    openapiFields.add("NodeRemainingBufferedCapacity");
    openapiFields.add("NodeRemainingCapacity");
    openapiFields.add("PlannedNodeLoadRemoval");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NodeLoadMetricInformation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NodeLoadMetricInformation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NodeLoadMetricInformation is not found in the empty JSON string", NodeLoadMetricInformation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NodeLoadMetricInformation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NodeLoadMetricInformation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("BufferedNodeCapacityRemaining") != null && !jsonObj.get("BufferedNodeCapacityRemaining").isJsonNull()) && !jsonObj.get("BufferedNodeCapacityRemaining").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BufferedNodeCapacityRemaining` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BufferedNodeCapacityRemaining").toString()));
      }
      if ((jsonObj.get("CurrentNodeLoad") != null && !jsonObj.get("CurrentNodeLoad").isJsonNull()) && !jsonObj.get("CurrentNodeLoad").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentNodeLoad` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentNodeLoad").toString()));
      }
      if ((jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) && !jsonObj.get("Name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Name").toString()));
      }
      if ((jsonObj.get("NodeBufferedCapacity") != null && !jsonObj.get("NodeBufferedCapacity").isJsonNull()) && !jsonObj.get("NodeBufferedCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeBufferedCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeBufferedCapacity").toString()));
      }
      if ((jsonObj.get("NodeCapacity") != null && !jsonObj.get("NodeCapacity").isJsonNull()) && !jsonObj.get("NodeCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeCapacity").toString()));
      }
      if ((jsonObj.get("NodeCapacityRemaining") != null && !jsonObj.get("NodeCapacityRemaining").isJsonNull()) && !jsonObj.get("NodeCapacityRemaining").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeCapacityRemaining` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeCapacityRemaining").toString()));
      }
      if ((jsonObj.get("NodeLoad") != null && !jsonObj.get("NodeLoad").isJsonNull()) && !jsonObj.get("NodeLoad").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeLoad` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeLoad").toString()));
      }
      if ((jsonObj.get("NodeRemainingBufferedCapacity") != null && !jsonObj.get("NodeRemainingBufferedCapacity").isJsonNull()) && !jsonObj.get("NodeRemainingBufferedCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeRemainingBufferedCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeRemainingBufferedCapacity").toString()));
      }
      if ((jsonObj.get("NodeRemainingCapacity") != null && !jsonObj.get("NodeRemainingCapacity").isJsonNull()) && !jsonObj.get("NodeRemainingCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeRemainingCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeRemainingCapacity").toString()));
      }
      if ((jsonObj.get("PlannedNodeLoadRemoval") != null && !jsonObj.get("PlannedNodeLoadRemoval").isJsonNull()) && !jsonObj.get("PlannedNodeLoadRemoval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `PlannedNodeLoadRemoval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("PlannedNodeLoadRemoval").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NodeLoadMetricInformation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NodeLoadMetricInformation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NodeLoadMetricInformation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NodeLoadMetricInformation.class));

       return (TypeAdapter<T>) new TypeAdapter<NodeLoadMetricInformation>() {
           @Override
           public void write(JsonWriter out, NodeLoadMetricInformation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NodeLoadMetricInformation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NodeLoadMetricInformation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NodeLoadMetricInformation
   * @throws IOException if the JSON string is invalid with respect to NodeLoadMetricInformation
   */
  public static NodeLoadMetricInformation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NodeLoadMetricInformation.class);
  }

  /**
   * Convert an instance of NodeLoadMetricInformation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

