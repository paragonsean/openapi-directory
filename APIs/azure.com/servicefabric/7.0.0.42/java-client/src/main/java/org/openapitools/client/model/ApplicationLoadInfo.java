/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 7.0.0.42
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ApplicationMetricDescription;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Load Information about a Service Fabric application.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:56:34.135207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ApplicationLoadInfo {
  public static final String SERIALIZED_NAME_APPLICATION_LOAD_METRIC_INFORMATION = "ApplicationLoadMetricInformation";
  @SerializedName(SERIALIZED_NAME_APPLICATION_LOAD_METRIC_INFORMATION)
  private List<ApplicationMetricDescription> applicationLoadMetricInformation = new ArrayList<>();

  public static final String SERIALIZED_NAME_ID = "Id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_MAXIMUM_NODES = "MaximumNodes";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_NODES)
  private Long maximumNodes;

  public static final String SERIALIZED_NAME_MINIMUM_NODES = "MinimumNodes";
  @SerializedName(SERIALIZED_NAME_MINIMUM_NODES)
  private Long minimumNodes;

  public static final String SERIALIZED_NAME_NODE_COUNT = "NodeCount";
  @SerializedName(SERIALIZED_NAME_NODE_COUNT)
  private Long nodeCount;

  public ApplicationLoadInfo() {
  }

  public ApplicationLoadInfo applicationLoadMetricInformation(List<ApplicationMetricDescription> applicationLoadMetricInformation) {
    this.applicationLoadMetricInformation = applicationLoadMetricInformation;
    return this;
  }

  public ApplicationLoadInfo addApplicationLoadMetricInformationItem(ApplicationMetricDescription applicationLoadMetricInformationItem) {
    if (this.applicationLoadMetricInformation == null) {
      this.applicationLoadMetricInformation = new ArrayList<>();
    }
    this.applicationLoadMetricInformation.add(applicationLoadMetricInformationItem);
    return this;
  }

  /**
   * List of application capacity metric description.
   * @return applicationLoadMetricInformation
   */
  @javax.annotation.Nullable
  public List<ApplicationMetricDescription> getApplicationLoadMetricInformation() {
    return applicationLoadMetricInformation;
  }

  public void setApplicationLoadMetricInformation(List<ApplicationMetricDescription> applicationLoadMetricInformation) {
    this.applicationLoadMetricInformation = applicationLoadMetricInformation;
  }


  public ApplicationLoadInfo id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The identity of the application. This is an encoded representation of the application name. This is used in the REST APIs to identify the application resource. Starting in version 6.0, hierarchical names are delimited with the \&quot;\\~\&quot; character. For example, if the application name is \&quot;fabric:/myapp/app1\&quot;, the application identity would be \&quot;myapp\\~app1\&quot; in 6.0+ and \&quot;myapp/app1\&quot; in previous versions.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public ApplicationLoadInfo maximumNodes(Long maximumNodes) {
    this.maximumNodes = maximumNodes;
    return this;
  }

  /**
   * The maximum number of nodes where this application can be instantiated. It is the number of nodes this application is allowed to span. For applications that do not have application capacity defined this value will be zero.
   * @return maximumNodes
   */
  @javax.annotation.Nullable
  public Long getMaximumNodes() {
    return maximumNodes;
  }

  public void setMaximumNodes(Long maximumNodes) {
    this.maximumNodes = maximumNodes;
  }


  public ApplicationLoadInfo minimumNodes(Long minimumNodes) {
    this.minimumNodes = minimumNodes;
    return this;
  }

  /**
   * The minimum number of nodes for this application. It is the number of nodes where Service Fabric will reserve Capacity in the cluster which equals to ReservedLoad * MinimumNodes for this Application instance. For applications that do not have application capacity defined this value will be zero.
   * @return minimumNodes
   */
  @javax.annotation.Nullable
  public Long getMinimumNodes() {
    return minimumNodes;
  }

  public void setMinimumNodes(Long minimumNodes) {
    this.minimumNodes = minimumNodes;
  }


  public ApplicationLoadInfo nodeCount(Long nodeCount) {
    this.nodeCount = nodeCount;
    return this;
  }

  /**
   * The number of nodes on which this application is instantiated. For applications that do not have application capacity defined this value will be zero.
   * @return nodeCount
   */
  @javax.annotation.Nullable
  public Long getNodeCount() {
    return nodeCount;
  }

  public void setNodeCount(Long nodeCount) {
    this.nodeCount = nodeCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApplicationLoadInfo applicationLoadInfo = (ApplicationLoadInfo) o;
    return Objects.equals(this.applicationLoadMetricInformation, applicationLoadInfo.applicationLoadMetricInformation) &&
        Objects.equals(this.id, applicationLoadInfo.id) &&
        Objects.equals(this.maximumNodes, applicationLoadInfo.maximumNodes) &&
        Objects.equals(this.minimumNodes, applicationLoadInfo.minimumNodes) &&
        Objects.equals(this.nodeCount, applicationLoadInfo.nodeCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationLoadMetricInformation, id, maximumNodes, minimumNodes, nodeCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApplicationLoadInfo {\n");
    sb.append("    applicationLoadMetricInformation: ").append(toIndentedString(applicationLoadMetricInformation)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    maximumNodes: ").append(toIndentedString(maximumNodes)).append("\n");
    sb.append("    minimumNodes: ").append(toIndentedString(minimumNodes)).append("\n");
    sb.append("    nodeCount: ").append(toIndentedString(nodeCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ApplicationLoadMetricInformation");
    openapiFields.add("Id");
    openapiFields.add("MaximumNodes");
    openapiFields.add("MinimumNodes");
    openapiFields.add("NodeCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ApplicationLoadInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ApplicationLoadInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApplicationLoadInfo is not found in the empty JSON string", ApplicationLoadInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ApplicationLoadInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ApplicationLoadInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("ApplicationLoadMetricInformation") != null && !jsonObj.get("ApplicationLoadMetricInformation").isJsonNull()) {
        JsonArray jsonArrayapplicationLoadMetricInformation = jsonObj.getAsJsonArray("ApplicationLoadMetricInformation");
        if (jsonArrayapplicationLoadMetricInformation != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ApplicationLoadMetricInformation").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ApplicationLoadMetricInformation` to be an array in the JSON string but got `%s`", jsonObj.get("ApplicationLoadMetricInformation").toString()));
          }

          // validate the optional field `ApplicationLoadMetricInformation` (array)
          for (int i = 0; i < jsonArrayapplicationLoadMetricInformation.size(); i++) {
            ApplicationMetricDescription.validateJsonElement(jsonArrayapplicationLoadMetricInformation.get(i));
          };
        }
      }
      if ((jsonObj.get("Id") != null && !jsonObj.get("Id").isJsonNull()) && !jsonObj.get("Id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApplicationLoadInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApplicationLoadInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApplicationLoadInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApplicationLoadInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<ApplicationLoadInfo>() {
           @Override
           public void write(JsonWriter out, ApplicationLoadInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApplicationLoadInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ApplicationLoadInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ApplicationLoadInfo
   * @throws IOException if the JSON string is invalid with respect to ApplicationLoadInfo
   */
  public static ApplicationLoadInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApplicationLoadInfo.class);
  }

  /**
   * Convert an instance of ApplicationLoadInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

