/*
 * Service Fabric Client APIs
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * The version of the OpenAPI document: 7.0.0.42
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.NodeId;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents data structure that contains load information for a certain metric in a cluster.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:56:34.135207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LoadMetricInformation {
  public static final String SERIALIZED_NAME_ACTION = "Action";
  @SerializedName(SERIALIZED_NAME_ACTION)
  private String action;

  public static final String SERIALIZED_NAME_ACTIVITY_THRESHOLD = "ActivityThreshold";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_THRESHOLD)
  private Double activityThreshold;

  public static final String SERIALIZED_NAME_BALANCING_THRESHOLD = "BalancingThreshold";
  @SerializedName(SERIALIZED_NAME_BALANCING_THRESHOLD)
  private Double balancingThreshold;

  public static final String SERIALIZED_NAME_BUFFERED_CLUSTER_CAPACITY_REMAINING = "BufferedClusterCapacityRemaining";
  @SerializedName(SERIALIZED_NAME_BUFFERED_CLUSTER_CAPACITY_REMAINING)
  private Double bufferedClusterCapacityRemaining;

  public static final String SERIALIZED_NAME_CLUSTER_BUFFERED_CAPACITY = "ClusterBufferedCapacity";
  @SerializedName(SERIALIZED_NAME_CLUSTER_BUFFERED_CAPACITY)
  private String clusterBufferedCapacity;

  public static final String SERIALIZED_NAME_CLUSTER_CAPACITY = "ClusterCapacity";
  @SerializedName(SERIALIZED_NAME_CLUSTER_CAPACITY)
  private String clusterCapacity;

  public static final String SERIALIZED_NAME_CLUSTER_CAPACITY_REMAINING = "ClusterCapacityRemaining";
  @SerializedName(SERIALIZED_NAME_CLUSTER_CAPACITY_REMAINING)
  private String clusterCapacityRemaining;

  public static final String SERIALIZED_NAME_CLUSTER_LOAD = "ClusterLoad";
  @SerializedName(SERIALIZED_NAME_CLUSTER_LOAD)
  private String clusterLoad;

  public static final String SERIALIZED_NAME_CLUSTER_REMAINING_BUFFERED_CAPACITY = "ClusterRemainingBufferedCapacity";
  @SerializedName(SERIALIZED_NAME_CLUSTER_REMAINING_BUFFERED_CAPACITY)
  private String clusterRemainingBufferedCapacity;

  public static final String SERIALIZED_NAME_CLUSTER_REMAINING_CAPACITY = "ClusterRemainingCapacity";
  @SerializedName(SERIALIZED_NAME_CLUSTER_REMAINING_CAPACITY)
  private String clusterRemainingCapacity;

  public static final String SERIALIZED_NAME_CURRENT_CLUSTER_LOAD = "CurrentClusterLoad";
  @SerializedName(SERIALIZED_NAME_CURRENT_CLUSTER_LOAD)
  private Double currentClusterLoad;

  public static final String SERIALIZED_NAME_DEVIATION_AFTER = "DeviationAfter";
  @SerializedName(SERIALIZED_NAME_DEVIATION_AFTER)
  private Double deviationAfter;

  public static final String SERIALIZED_NAME_DEVIATION_BEFORE = "DeviationBefore";
  @SerializedName(SERIALIZED_NAME_DEVIATION_BEFORE)
  private Double deviationBefore;

  public static final String SERIALIZED_NAME_IS_BALANCED_AFTER = "IsBalancedAfter";
  @SerializedName(SERIALIZED_NAME_IS_BALANCED_AFTER)
  private Boolean isBalancedAfter;

  public static final String SERIALIZED_NAME_IS_BALANCED_BEFORE = "IsBalancedBefore";
  @SerializedName(SERIALIZED_NAME_IS_BALANCED_BEFORE)
  private Boolean isBalancedBefore;

  public static final String SERIALIZED_NAME_IS_CLUSTER_CAPACITY_VIOLATION = "IsClusterCapacityViolation";
  @SerializedName(SERIALIZED_NAME_IS_CLUSTER_CAPACITY_VIOLATION)
  private Boolean isClusterCapacityViolation;

  public static final String SERIALIZED_NAME_MAX_NODE_LOAD_NODE_ID = "MaxNodeLoadNodeId";
  @SerializedName(SERIALIZED_NAME_MAX_NODE_LOAD_NODE_ID)
  private NodeId maxNodeLoadNodeId;

  public static final String SERIALIZED_NAME_MAX_NODE_LOAD_VALUE = "MaxNodeLoadValue";
  @SerializedName(SERIALIZED_NAME_MAX_NODE_LOAD_VALUE)
  private String maxNodeLoadValue;

  public static final String SERIALIZED_NAME_MAXIMUM_NODE_LOAD = "MaximumNodeLoad";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_NODE_LOAD)
  private Double maximumNodeLoad;

  public static final String SERIALIZED_NAME_MIN_NODE_LOAD_NODE_ID = "MinNodeLoadNodeId";
  @SerializedName(SERIALIZED_NAME_MIN_NODE_LOAD_NODE_ID)
  private NodeId minNodeLoadNodeId;

  public static final String SERIALIZED_NAME_MIN_NODE_LOAD_VALUE = "MinNodeLoadValue";
  @SerializedName(SERIALIZED_NAME_MIN_NODE_LOAD_VALUE)
  private String minNodeLoadValue;

  public static final String SERIALIZED_NAME_MINIMUM_NODE_LOAD = "MinimumNodeLoad";
  @SerializedName(SERIALIZED_NAME_MINIMUM_NODE_LOAD)
  private Double minimumNodeLoad;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NODE_BUFFER_PERCENTAGE = "NodeBufferPercentage";
  @SerializedName(SERIALIZED_NAME_NODE_BUFFER_PERCENTAGE)
  private Double nodeBufferPercentage;

  public static final String SERIALIZED_NAME_PLANNED_LOAD_REMOVAL = "PlannedLoadRemoval";
  @SerializedName(SERIALIZED_NAME_PLANNED_LOAD_REMOVAL)
  private Double plannedLoadRemoval;

  public LoadMetricInformation() {
  }

  public LoadMetricInformation action(String action) {
    this.action = action;
    return this;
  }

  /**
   * The current action being taken with regard to this metric
   * @return action
   */
  @javax.annotation.Nullable
  public String getAction() {
    return action;
  }

  public void setAction(String action) {
    this.action = action;
  }


  public LoadMetricInformation activityThreshold(Double activityThreshold) {
    this.activityThreshold = activityThreshold;
    return this;
  }

  /**
   * The Activity Threshold specified for this metric in the system Cluster Manifest.
   * @return activityThreshold
   */
  @javax.annotation.Nullable
  public Double getActivityThreshold() {
    return activityThreshold;
  }

  public void setActivityThreshold(Double activityThreshold) {
    this.activityThreshold = activityThreshold;
  }


  public LoadMetricInformation balancingThreshold(Double balancingThreshold) {
    this.balancingThreshold = balancingThreshold;
    return this;
  }

  /**
   * The balancing threshold for a certain metric.
   * @return balancingThreshold
   */
  @javax.annotation.Nullable
  public Double getBalancingThreshold() {
    return balancingThreshold;
  }

  public void setBalancingThreshold(Double balancingThreshold) {
    this.balancingThreshold = balancingThreshold;
  }


  public LoadMetricInformation bufferedClusterCapacityRemaining(Double bufferedClusterCapacityRemaining) {
    this.bufferedClusterCapacityRemaining = bufferedClusterCapacityRemaining;
    return this;
  }

  /**
   * Remaining capacity in the cluster excluding the reserved space.
   * @return bufferedClusterCapacityRemaining
   */
  @javax.annotation.Nullable
  public Double getBufferedClusterCapacityRemaining() {
    return bufferedClusterCapacityRemaining;
  }

  public void setBufferedClusterCapacityRemaining(Double bufferedClusterCapacityRemaining) {
    this.bufferedClusterCapacityRemaining = bufferedClusterCapacityRemaining;
  }


  public LoadMetricInformation clusterBufferedCapacity(String clusterBufferedCapacity) {
    this.clusterBufferedCapacity = clusterBufferedCapacity;
    return this;
  }

  /**
   * Remaining capacity in the cluster excluding the reserved space. In future releases of Service Fabric this parameter will be deprecated in favor of BufferedClusterCapacityRemaining.
   * @return clusterBufferedCapacity
   */
  @javax.annotation.Nullable
  public String getClusterBufferedCapacity() {
    return clusterBufferedCapacity;
  }

  public void setClusterBufferedCapacity(String clusterBufferedCapacity) {
    this.clusterBufferedCapacity = clusterBufferedCapacity;
  }


  public LoadMetricInformation clusterCapacity(String clusterCapacity) {
    this.clusterCapacity = clusterCapacity;
    return this;
  }

  /**
   * The total cluster capacity for a given metric
   * @return clusterCapacity
   */
  @javax.annotation.Nullable
  public String getClusterCapacity() {
    return clusterCapacity;
  }

  public void setClusterCapacity(String clusterCapacity) {
    this.clusterCapacity = clusterCapacity;
  }


  public LoadMetricInformation clusterCapacityRemaining(String clusterCapacityRemaining) {
    this.clusterCapacityRemaining = clusterCapacityRemaining;
    return this;
  }

  /**
   * The remaining capacity for the metric in the cluster.
   * @return clusterCapacityRemaining
   */
  @javax.annotation.Nullable
  public String getClusterCapacityRemaining() {
    return clusterCapacityRemaining;
  }

  public void setClusterCapacityRemaining(String clusterCapacityRemaining) {
    this.clusterCapacityRemaining = clusterCapacityRemaining;
  }


  public LoadMetricInformation clusterLoad(String clusterLoad) {
    this.clusterLoad = clusterLoad;
    return this;
  }

  /**
   * The total cluster load. In future releases of Service Fabric this parameter will be deprecated in favor of CurrentClusterLoad.
   * @return clusterLoad
   */
  @javax.annotation.Nullable
  public String getClusterLoad() {
    return clusterLoad;
  }

  public void setClusterLoad(String clusterLoad) {
    this.clusterLoad = clusterLoad;
  }


  public LoadMetricInformation clusterRemainingBufferedCapacity(String clusterRemainingBufferedCapacity) {
    this.clusterRemainingBufferedCapacity = clusterRemainingBufferedCapacity;
    return this;
  }

  /**
   * The remaining percentage of cluster total capacity for this metric.
   * @return clusterRemainingBufferedCapacity
   */
  @javax.annotation.Nullable
  public String getClusterRemainingBufferedCapacity() {
    return clusterRemainingBufferedCapacity;
  }

  public void setClusterRemainingBufferedCapacity(String clusterRemainingBufferedCapacity) {
    this.clusterRemainingBufferedCapacity = clusterRemainingBufferedCapacity;
  }


  public LoadMetricInformation clusterRemainingCapacity(String clusterRemainingCapacity) {
    this.clusterRemainingCapacity = clusterRemainingCapacity;
    return this;
  }

  /**
   * The remaining capacity for the metric in the cluster. In future releases of Service Fabric this parameter will be deprecated in favor of ClusterCapacityRemaining.
   * @return clusterRemainingCapacity
   */
  @javax.annotation.Nullable
  public String getClusterRemainingCapacity() {
    return clusterRemainingCapacity;
  }

  public void setClusterRemainingCapacity(String clusterRemainingCapacity) {
    this.clusterRemainingCapacity = clusterRemainingCapacity;
  }


  public LoadMetricInformation currentClusterLoad(Double currentClusterLoad) {
    this.currentClusterLoad = currentClusterLoad;
    return this;
  }

  /**
   * The total cluster load.
   * @return currentClusterLoad
   */
  @javax.annotation.Nullable
  public Double getCurrentClusterLoad() {
    return currentClusterLoad;
  }

  public void setCurrentClusterLoad(Double currentClusterLoad) {
    this.currentClusterLoad = currentClusterLoad;
  }


  public LoadMetricInformation deviationAfter(Double deviationAfter) {
    this.deviationAfter = deviationAfter;
    return this;
  }

  /**
   * The standard average deviation of the metrics after resource balancer run.
   * @return deviationAfter
   */
  @javax.annotation.Nullable
  public Double getDeviationAfter() {
    return deviationAfter;
  }

  public void setDeviationAfter(Double deviationAfter) {
    this.deviationAfter = deviationAfter;
  }


  public LoadMetricInformation deviationBefore(Double deviationBefore) {
    this.deviationBefore = deviationBefore;
    return this;
  }

  /**
   * The standard average deviation of the metrics before resource balancer run.
   * @return deviationBefore
   */
  @javax.annotation.Nullable
  public Double getDeviationBefore() {
    return deviationBefore;
  }

  public void setDeviationBefore(Double deviationBefore) {
    this.deviationBefore = deviationBefore;
  }


  public LoadMetricInformation isBalancedAfter(Boolean isBalancedAfter) {
    this.isBalancedAfter = isBalancedAfter;
    return this;
  }

  /**
   * Value that indicates whether the metrics is balanced or not after resource balancer run.
   * @return isBalancedAfter
   */
  @javax.annotation.Nullable
  public Boolean getIsBalancedAfter() {
    return isBalancedAfter;
  }

  public void setIsBalancedAfter(Boolean isBalancedAfter) {
    this.isBalancedAfter = isBalancedAfter;
  }


  public LoadMetricInformation isBalancedBefore(Boolean isBalancedBefore) {
    this.isBalancedBefore = isBalancedBefore;
    return this;
  }

  /**
   * Value that indicates whether the metrics is balanced or not before resource balancer run
   * @return isBalancedBefore
   */
  @javax.annotation.Nullable
  public Boolean getIsBalancedBefore() {
    return isBalancedBefore;
  }

  public void setIsBalancedBefore(Boolean isBalancedBefore) {
    this.isBalancedBefore = isBalancedBefore;
  }


  public LoadMetricInformation isClusterCapacityViolation(Boolean isClusterCapacityViolation) {
    this.isClusterCapacityViolation = isClusterCapacityViolation;
    return this;
  }

  /**
   * Indicates that the metric is currently over capacity in the cluster.
   * @return isClusterCapacityViolation
   */
  @javax.annotation.Nullable
  public Boolean getIsClusterCapacityViolation() {
    return isClusterCapacityViolation;
  }

  public void setIsClusterCapacityViolation(Boolean isClusterCapacityViolation) {
    this.isClusterCapacityViolation = isClusterCapacityViolation;
  }


  public LoadMetricInformation maxNodeLoadNodeId(NodeId maxNodeLoadNodeId) {
    this.maxNodeLoadNodeId = maxNodeLoadNodeId;
    return this;
  }

  /**
   * Get maxNodeLoadNodeId
   * @return maxNodeLoadNodeId
   */
  @javax.annotation.Nullable
  public NodeId getMaxNodeLoadNodeId() {
    return maxNodeLoadNodeId;
  }

  public void setMaxNodeLoadNodeId(NodeId maxNodeLoadNodeId) {
    this.maxNodeLoadNodeId = maxNodeLoadNodeId;
  }


  public LoadMetricInformation maxNodeLoadValue(String maxNodeLoadValue) {
    this.maxNodeLoadValue = maxNodeLoadValue;
    return this;
  }

  /**
   * The maximum load on any node for this metric. In future releases of Service Fabric this parameter will be deprecated in favor of MaximumNodeLoad.
   * @return maxNodeLoadValue
   */
  @javax.annotation.Nullable
  public String getMaxNodeLoadValue() {
    return maxNodeLoadValue;
  }

  public void setMaxNodeLoadValue(String maxNodeLoadValue) {
    this.maxNodeLoadValue = maxNodeLoadValue;
  }


  public LoadMetricInformation maximumNodeLoad(Double maximumNodeLoad) {
    this.maximumNodeLoad = maximumNodeLoad;
    return this;
  }

  /**
   * The maximum load on any node for this metric.
   * @return maximumNodeLoad
   */
  @javax.annotation.Nullable
  public Double getMaximumNodeLoad() {
    return maximumNodeLoad;
  }

  public void setMaximumNodeLoad(Double maximumNodeLoad) {
    this.maximumNodeLoad = maximumNodeLoad;
  }


  public LoadMetricInformation minNodeLoadNodeId(NodeId minNodeLoadNodeId) {
    this.minNodeLoadNodeId = minNodeLoadNodeId;
    return this;
  }

  /**
   * Get minNodeLoadNodeId
   * @return minNodeLoadNodeId
   */
  @javax.annotation.Nullable
  public NodeId getMinNodeLoadNodeId() {
    return minNodeLoadNodeId;
  }

  public void setMinNodeLoadNodeId(NodeId minNodeLoadNodeId) {
    this.minNodeLoadNodeId = minNodeLoadNodeId;
  }


  public LoadMetricInformation minNodeLoadValue(String minNodeLoadValue) {
    this.minNodeLoadValue = minNodeLoadValue;
    return this;
  }

  /**
   * The minimum load on any node for this metric. In future releases of Service Fabric this parameter will be deprecated in favor of MinimumNodeLoad.
   * @return minNodeLoadValue
   */
  @javax.annotation.Nullable
  public String getMinNodeLoadValue() {
    return minNodeLoadValue;
  }

  public void setMinNodeLoadValue(String minNodeLoadValue) {
    this.minNodeLoadValue = minNodeLoadValue;
  }


  public LoadMetricInformation minimumNodeLoad(Double minimumNodeLoad) {
    this.minimumNodeLoad = minimumNodeLoad;
    return this;
  }

  /**
   * The minimum load on any node for this metric.
   * @return minimumNodeLoad
   */
  @javax.annotation.Nullable
  public Double getMinimumNodeLoad() {
    return minimumNodeLoad;
  }

  public void setMinimumNodeLoad(Double minimumNodeLoad) {
    this.minimumNodeLoad = minimumNodeLoad;
  }


  public LoadMetricInformation name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the metric for which this load information is provided.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public LoadMetricInformation nodeBufferPercentage(Double nodeBufferPercentage) {
    this.nodeBufferPercentage = nodeBufferPercentage;
    return this;
  }

  /**
   * The reserved percentage of total node capacity for this metric.
   * @return nodeBufferPercentage
   */
  @javax.annotation.Nullable
  public Double getNodeBufferPercentage() {
    return nodeBufferPercentage;
  }

  public void setNodeBufferPercentage(Double nodeBufferPercentage) {
    this.nodeBufferPercentage = nodeBufferPercentage;
  }


  public LoadMetricInformation plannedLoadRemoval(Double plannedLoadRemoval) {
    this.plannedLoadRemoval = plannedLoadRemoval;
    return this;
  }

  /**
   * This value represents the load of the replicas that are planned to be removed in the future within the cluster. This kind of load is reported for replicas that are currently being moving to other nodes and for replicas that are currently being dropped but still use the load on the source node.
   * @return plannedLoadRemoval
   */
  @javax.annotation.Nullable
  public Double getPlannedLoadRemoval() {
    return plannedLoadRemoval;
  }

  public void setPlannedLoadRemoval(Double plannedLoadRemoval) {
    this.plannedLoadRemoval = plannedLoadRemoval;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LoadMetricInformation loadMetricInformation = (LoadMetricInformation) o;
    return Objects.equals(this.action, loadMetricInformation.action) &&
        Objects.equals(this.activityThreshold, loadMetricInformation.activityThreshold) &&
        Objects.equals(this.balancingThreshold, loadMetricInformation.balancingThreshold) &&
        Objects.equals(this.bufferedClusterCapacityRemaining, loadMetricInformation.bufferedClusterCapacityRemaining) &&
        Objects.equals(this.clusterBufferedCapacity, loadMetricInformation.clusterBufferedCapacity) &&
        Objects.equals(this.clusterCapacity, loadMetricInformation.clusterCapacity) &&
        Objects.equals(this.clusterCapacityRemaining, loadMetricInformation.clusterCapacityRemaining) &&
        Objects.equals(this.clusterLoad, loadMetricInformation.clusterLoad) &&
        Objects.equals(this.clusterRemainingBufferedCapacity, loadMetricInformation.clusterRemainingBufferedCapacity) &&
        Objects.equals(this.clusterRemainingCapacity, loadMetricInformation.clusterRemainingCapacity) &&
        Objects.equals(this.currentClusterLoad, loadMetricInformation.currentClusterLoad) &&
        Objects.equals(this.deviationAfter, loadMetricInformation.deviationAfter) &&
        Objects.equals(this.deviationBefore, loadMetricInformation.deviationBefore) &&
        Objects.equals(this.isBalancedAfter, loadMetricInformation.isBalancedAfter) &&
        Objects.equals(this.isBalancedBefore, loadMetricInformation.isBalancedBefore) &&
        Objects.equals(this.isClusterCapacityViolation, loadMetricInformation.isClusterCapacityViolation) &&
        Objects.equals(this.maxNodeLoadNodeId, loadMetricInformation.maxNodeLoadNodeId) &&
        Objects.equals(this.maxNodeLoadValue, loadMetricInformation.maxNodeLoadValue) &&
        Objects.equals(this.maximumNodeLoad, loadMetricInformation.maximumNodeLoad) &&
        Objects.equals(this.minNodeLoadNodeId, loadMetricInformation.minNodeLoadNodeId) &&
        Objects.equals(this.minNodeLoadValue, loadMetricInformation.minNodeLoadValue) &&
        Objects.equals(this.minimumNodeLoad, loadMetricInformation.minimumNodeLoad) &&
        Objects.equals(this.name, loadMetricInformation.name) &&
        Objects.equals(this.nodeBufferPercentage, loadMetricInformation.nodeBufferPercentage) &&
        Objects.equals(this.plannedLoadRemoval, loadMetricInformation.plannedLoadRemoval);
  }

  @Override
  public int hashCode() {
    return Objects.hash(action, activityThreshold, balancingThreshold, bufferedClusterCapacityRemaining, clusterBufferedCapacity, clusterCapacity, clusterCapacityRemaining, clusterLoad, clusterRemainingBufferedCapacity, clusterRemainingCapacity, currentClusterLoad, deviationAfter, deviationBefore, isBalancedAfter, isBalancedBefore, isClusterCapacityViolation, maxNodeLoadNodeId, maxNodeLoadValue, maximumNodeLoad, minNodeLoadNodeId, minNodeLoadValue, minimumNodeLoad, name, nodeBufferPercentage, plannedLoadRemoval);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LoadMetricInformation {\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    activityThreshold: ").append(toIndentedString(activityThreshold)).append("\n");
    sb.append("    balancingThreshold: ").append(toIndentedString(balancingThreshold)).append("\n");
    sb.append("    bufferedClusterCapacityRemaining: ").append(toIndentedString(bufferedClusterCapacityRemaining)).append("\n");
    sb.append("    clusterBufferedCapacity: ").append(toIndentedString(clusterBufferedCapacity)).append("\n");
    sb.append("    clusterCapacity: ").append(toIndentedString(clusterCapacity)).append("\n");
    sb.append("    clusterCapacityRemaining: ").append(toIndentedString(clusterCapacityRemaining)).append("\n");
    sb.append("    clusterLoad: ").append(toIndentedString(clusterLoad)).append("\n");
    sb.append("    clusterRemainingBufferedCapacity: ").append(toIndentedString(clusterRemainingBufferedCapacity)).append("\n");
    sb.append("    clusterRemainingCapacity: ").append(toIndentedString(clusterRemainingCapacity)).append("\n");
    sb.append("    currentClusterLoad: ").append(toIndentedString(currentClusterLoad)).append("\n");
    sb.append("    deviationAfter: ").append(toIndentedString(deviationAfter)).append("\n");
    sb.append("    deviationBefore: ").append(toIndentedString(deviationBefore)).append("\n");
    sb.append("    isBalancedAfter: ").append(toIndentedString(isBalancedAfter)).append("\n");
    sb.append("    isBalancedBefore: ").append(toIndentedString(isBalancedBefore)).append("\n");
    sb.append("    isClusterCapacityViolation: ").append(toIndentedString(isClusterCapacityViolation)).append("\n");
    sb.append("    maxNodeLoadNodeId: ").append(toIndentedString(maxNodeLoadNodeId)).append("\n");
    sb.append("    maxNodeLoadValue: ").append(toIndentedString(maxNodeLoadValue)).append("\n");
    sb.append("    maximumNodeLoad: ").append(toIndentedString(maximumNodeLoad)).append("\n");
    sb.append("    minNodeLoadNodeId: ").append(toIndentedString(minNodeLoadNodeId)).append("\n");
    sb.append("    minNodeLoadValue: ").append(toIndentedString(minNodeLoadValue)).append("\n");
    sb.append("    minimumNodeLoad: ").append(toIndentedString(minimumNodeLoad)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nodeBufferPercentage: ").append(toIndentedString(nodeBufferPercentage)).append("\n");
    sb.append("    plannedLoadRemoval: ").append(toIndentedString(plannedLoadRemoval)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Action");
    openapiFields.add("ActivityThreshold");
    openapiFields.add("BalancingThreshold");
    openapiFields.add("BufferedClusterCapacityRemaining");
    openapiFields.add("ClusterBufferedCapacity");
    openapiFields.add("ClusterCapacity");
    openapiFields.add("ClusterCapacityRemaining");
    openapiFields.add("ClusterLoad");
    openapiFields.add("ClusterRemainingBufferedCapacity");
    openapiFields.add("ClusterRemainingCapacity");
    openapiFields.add("CurrentClusterLoad");
    openapiFields.add("DeviationAfter");
    openapiFields.add("DeviationBefore");
    openapiFields.add("IsBalancedAfter");
    openapiFields.add("IsBalancedBefore");
    openapiFields.add("IsClusterCapacityViolation");
    openapiFields.add("MaxNodeLoadNodeId");
    openapiFields.add("MaxNodeLoadValue");
    openapiFields.add("MaximumNodeLoad");
    openapiFields.add("MinNodeLoadNodeId");
    openapiFields.add("MinNodeLoadValue");
    openapiFields.add("MinimumNodeLoad");
    openapiFields.add("Name");
    openapiFields.add("NodeBufferPercentage");
    openapiFields.add("PlannedLoadRemoval");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LoadMetricInformation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LoadMetricInformation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LoadMetricInformation is not found in the empty JSON string", LoadMetricInformation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LoadMetricInformation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LoadMetricInformation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("Action") != null && !jsonObj.get("Action").isJsonNull()) && !jsonObj.get("Action").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Action` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Action").toString()));
      }
      if ((jsonObj.get("ActivityThreshold") != null && !jsonObj.get("ActivityThreshold").isJsonNull()) && !jsonObj.get("ActivityThreshold").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ActivityThreshold` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ActivityThreshold").toString()));
      }
      if ((jsonObj.get("BalancingThreshold") != null && !jsonObj.get("BalancingThreshold").isJsonNull()) && !jsonObj.get("BalancingThreshold").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BalancingThreshold` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BalancingThreshold").toString()));
      }
      if ((jsonObj.get("BufferedClusterCapacityRemaining") != null && !jsonObj.get("BufferedClusterCapacityRemaining").isJsonNull()) && !jsonObj.get("BufferedClusterCapacityRemaining").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `BufferedClusterCapacityRemaining` to be a primitive type in the JSON string but got `%s`", jsonObj.get("BufferedClusterCapacityRemaining").toString()));
      }
      if ((jsonObj.get("ClusterBufferedCapacity") != null && !jsonObj.get("ClusterBufferedCapacity").isJsonNull()) && !jsonObj.get("ClusterBufferedCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ClusterBufferedCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ClusterBufferedCapacity").toString()));
      }
      if ((jsonObj.get("ClusterCapacity") != null && !jsonObj.get("ClusterCapacity").isJsonNull()) && !jsonObj.get("ClusterCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ClusterCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ClusterCapacity").toString()));
      }
      if ((jsonObj.get("ClusterCapacityRemaining") != null && !jsonObj.get("ClusterCapacityRemaining").isJsonNull()) && !jsonObj.get("ClusterCapacityRemaining").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ClusterCapacityRemaining` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ClusterCapacityRemaining").toString()));
      }
      if ((jsonObj.get("ClusterLoad") != null && !jsonObj.get("ClusterLoad").isJsonNull()) && !jsonObj.get("ClusterLoad").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ClusterLoad` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ClusterLoad").toString()));
      }
      if ((jsonObj.get("ClusterRemainingBufferedCapacity") != null && !jsonObj.get("ClusterRemainingBufferedCapacity").isJsonNull()) && !jsonObj.get("ClusterRemainingBufferedCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ClusterRemainingBufferedCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ClusterRemainingBufferedCapacity").toString()));
      }
      if ((jsonObj.get("ClusterRemainingCapacity") != null && !jsonObj.get("ClusterRemainingCapacity").isJsonNull()) && !jsonObj.get("ClusterRemainingCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ClusterRemainingCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ClusterRemainingCapacity").toString()));
      }
      if ((jsonObj.get("CurrentClusterLoad") != null && !jsonObj.get("CurrentClusterLoad").isJsonNull()) && !jsonObj.get("CurrentClusterLoad").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentClusterLoad` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentClusterLoad").toString()));
      }
      if ((jsonObj.get("DeviationAfter") != null && !jsonObj.get("DeviationAfter").isJsonNull()) && !jsonObj.get("DeviationAfter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeviationAfter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DeviationAfter").toString()));
      }
      if ((jsonObj.get("DeviationBefore") != null && !jsonObj.get("DeviationBefore").isJsonNull()) && !jsonObj.get("DeviationBefore").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DeviationBefore` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DeviationBefore").toString()));
      }
      // validate the optional field `MaxNodeLoadNodeId`
      if (jsonObj.get("MaxNodeLoadNodeId") != null && !jsonObj.get("MaxNodeLoadNodeId").isJsonNull()) {
        NodeId.validateJsonElement(jsonObj.get("MaxNodeLoadNodeId"));
      }
      if ((jsonObj.get("MaxNodeLoadValue") != null && !jsonObj.get("MaxNodeLoadValue").isJsonNull()) && !jsonObj.get("MaxNodeLoadValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MaxNodeLoadValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MaxNodeLoadValue").toString()));
      }
      if ((jsonObj.get("MaximumNodeLoad") != null && !jsonObj.get("MaximumNodeLoad").isJsonNull()) && !jsonObj.get("MaximumNodeLoad").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MaximumNodeLoad` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MaximumNodeLoad").toString()));
      }
      // validate the optional field `MinNodeLoadNodeId`
      if (jsonObj.get("MinNodeLoadNodeId") != null && !jsonObj.get("MinNodeLoadNodeId").isJsonNull()) {
        NodeId.validateJsonElement(jsonObj.get("MinNodeLoadNodeId"));
      }
      if ((jsonObj.get("MinNodeLoadValue") != null && !jsonObj.get("MinNodeLoadValue").isJsonNull()) && !jsonObj.get("MinNodeLoadValue").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MinNodeLoadValue` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MinNodeLoadValue").toString()));
      }
      if ((jsonObj.get("MinimumNodeLoad") != null && !jsonObj.get("MinimumNodeLoad").isJsonNull()) && !jsonObj.get("MinimumNodeLoad").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MinimumNodeLoad` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MinimumNodeLoad").toString()));
      }
      if ((jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) && !jsonObj.get("Name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Name").toString()));
      }
      if ((jsonObj.get("NodeBufferPercentage") != null && !jsonObj.get("NodeBufferPercentage").isJsonNull()) && !jsonObj.get("NodeBufferPercentage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `NodeBufferPercentage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("NodeBufferPercentage").toString()));
      }
      if ((jsonObj.get("PlannedLoadRemoval") != null && !jsonObj.get("PlannedLoadRemoval").isJsonNull()) && !jsonObj.get("PlannedLoadRemoval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `PlannedLoadRemoval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("PlannedLoadRemoval").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LoadMetricInformation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LoadMetricInformation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LoadMetricInformation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LoadMetricInformation.class));

       return (TypeAdapter<T>) new TypeAdapter<LoadMetricInformation>() {
           @Override
           public void write(JsonWriter out, LoadMetricInformation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LoadMetricInformation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LoadMetricInformation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LoadMetricInformation
   * @throws IOException if the JSON string is invalid with respect to LoadMetricInformation
   */
  public static LoadMetricInformation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LoadMetricInformation.class);
  }

  /**
   * Convert an instance of LoadMetricInformation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

