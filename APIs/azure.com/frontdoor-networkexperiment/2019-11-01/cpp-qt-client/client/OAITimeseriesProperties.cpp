/**
 * NetworkExperiments
 * These are the Network Experiment APIs. 
 *
 * The version of the OpenAPI document: 2019-11-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITimeseriesProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITimeseriesProperties::OAITimeseriesProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITimeseriesProperties::OAITimeseriesProperties() {
    this->initializeModel();
}

OAITimeseriesProperties::~OAITimeseriesProperties() {}

void OAITimeseriesProperties::initializeModel() {

    m_aggregation_interval_isSet = false;
    m_aggregation_interval_isValid = false;

    m_country_isSet = false;
    m_country_isValid = false;

    m_end_date_time_utc_isSet = false;
    m_end_date_time_utc_isValid = false;

    m_endpoint_isSet = false;
    m_endpoint_isValid = false;

    m_start_date_time_utc_isSet = false;
    m_start_date_time_utc_isValid = false;

    m_timeseries_data_isSet = false;
    m_timeseries_data_isValid = false;

    m_timeseries_type_isSet = false;
    m_timeseries_type_isValid = false;
}

void OAITimeseriesProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITimeseriesProperties::fromJsonObject(QJsonObject json) {

    m_aggregation_interval_isValid = ::OpenAPI::fromJsonValue(m_aggregation_interval, json[QString("aggregationInterval")]);
    m_aggregation_interval_isSet = !json[QString("aggregationInterval")].isNull() && m_aggregation_interval_isValid;

    m_country_isValid = ::OpenAPI::fromJsonValue(m_country, json[QString("country")]);
    m_country_isSet = !json[QString("country")].isNull() && m_country_isValid;

    m_end_date_time_utc_isValid = ::OpenAPI::fromJsonValue(m_end_date_time_utc, json[QString("endDateTimeUTC")]);
    m_end_date_time_utc_isSet = !json[QString("endDateTimeUTC")].isNull() && m_end_date_time_utc_isValid;

    m_endpoint_isValid = ::OpenAPI::fromJsonValue(m_endpoint, json[QString("endpoint")]);
    m_endpoint_isSet = !json[QString("endpoint")].isNull() && m_endpoint_isValid;

    m_start_date_time_utc_isValid = ::OpenAPI::fromJsonValue(m_start_date_time_utc, json[QString("startDateTimeUTC")]);
    m_start_date_time_utc_isSet = !json[QString("startDateTimeUTC")].isNull() && m_start_date_time_utc_isValid;

    m_timeseries_data_isValid = ::OpenAPI::fromJsonValue(m_timeseries_data, json[QString("timeseriesData")]);
    m_timeseries_data_isSet = !json[QString("timeseriesData")].isNull() && m_timeseries_data_isValid;

    m_timeseries_type_isValid = ::OpenAPI::fromJsonValue(m_timeseries_type, json[QString("timeseriesType")]);
    m_timeseries_type_isSet = !json[QString("timeseriesType")].isNull() && m_timeseries_type_isValid;
}

QString OAITimeseriesProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITimeseriesProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_aggregation_interval_isSet) {
        obj.insert(QString("aggregationInterval"), ::OpenAPI::toJsonValue(m_aggregation_interval));
    }
    if (m_country_isSet) {
        obj.insert(QString("country"), ::OpenAPI::toJsonValue(m_country));
    }
    if (m_end_date_time_utc_isSet) {
        obj.insert(QString("endDateTimeUTC"), ::OpenAPI::toJsonValue(m_end_date_time_utc));
    }
    if (m_endpoint_isSet) {
        obj.insert(QString("endpoint"), ::OpenAPI::toJsonValue(m_endpoint));
    }
    if (m_start_date_time_utc_isSet) {
        obj.insert(QString("startDateTimeUTC"), ::OpenAPI::toJsonValue(m_start_date_time_utc));
    }
    if (m_timeseries_data.size() > 0) {
        obj.insert(QString("timeseriesData"), ::OpenAPI::toJsonValue(m_timeseries_data));
    }
    if (m_timeseries_type_isSet) {
        obj.insert(QString("timeseriesType"), ::OpenAPI::toJsonValue(m_timeseries_type));
    }
    return obj;
}

QString OAITimeseriesProperties::getAggregationInterval() const {
    return m_aggregation_interval;
}
void OAITimeseriesProperties::setAggregationInterval(const QString &aggregation_interval) {
    m_aggregation_interval = aggregation_interval;
    m_aggregation_interval_isSet = true;
}

bool OAITimeseriesProperties::is_aggregation_interval_Set() const{
    return m_aggregation_interval_isSet;
}

bool OAITimeseriesProperties::is_aggregation_interval_Valid() const{
    return m_aggregation_interval_isValid;
}

QString OAITimeseriesProperties::getCountry() const {
    return m_country;
}
void OAITimeseriesProperties::setCountry(const QString &country) {
    m_country = country;
    m_country_isSet = true;
}

bool OAITimeseriesProperties::is_country_Set() const{
    return m_country_isSet;
}

bool OAITimeseriesProperties::is_country_Valid() const{
    return m_country_isValid;
}

QString OAITimeseriesProperties::getEndDateTimeUtc() const {
    return m_end_date_time_utc;
}
void OAITimeseriesProperties::setEndDateTimeUtc(const QString &end_date_time_utc) {
    m_end_date_time_utc = end_date_time_utc;
    m_end_date_time_utc_isSet = true;
}

bool OAITimeseriesProperties::is_end_date_time_utc_Set() const{
    return m_end_date_time_utc_isSet;
}

bool OAITimeseriesProperties::is_end_date_time_utc_Valid() const{
    return m_end_date_time_utc_isValid;
}

QString OAITimeseriesProperties::getEndpoint() const {
    return m_endpoint;
}
void OAITimeseriesProperties::setEndpoint(const QString &endpoint) {
    m_endpoint = endpoint;
    m_endpoint_isSet = true;
}

bool OAITimeseriesProperties::is_endpoint_Set() const{
    return m_endpoint_isSet;
}

bool OAITimeseriesProperties::is_endpoint_Valid() const{
    return m_endpoint_isValid;
}

QString OAITimeseriesProperties::getStartDateTimeUtc() const {
    return m_start_date_time_utc;
}
void OAITimeseriesProperties::setStartDateTimeUtc(const QString &start_date_time_utc) {
    m_start_date_time_utc = start_date_time_utc;
    m_start_date_time_utc_isSet = true;
}

bool OAITimeseriesProperties::is_start_date_time_utc_Set() const{
    return m_start_date_time_utc_isSet;
}

bool OAITimeseriesProperties::is_start_date_time_utc_Valid() const{
    return m_start_date_time_utc_isValid;
}

QList<OAITimeseriesDataPoint> OAITimeseriesProperties::getTimeseriesData() const {
    return m_timeseries_data;
}
void OAITimeseriesProperties::setTimeseriesData(const QList<OAITimeseriesDataPoint> &timeseries_data) {
    m_timeseries_data = timeseries_data;
    m_timeseries_data_isSet = true;
}

bool OAITimeseriesProperties::is_timeseries_data_Set() const{
    return m_timeseries_data_isSet;
}

bool OAITimeseriesProperties::is_timeseries_data_Valid() const{
    return m_timeseries_data_isValid;
}

QString OAITimeseriesProperties::getTimeseriesType() const {
    return m_timeseries_type;
}
void OAITimeseriesProperties::setTimeseriesType(const QString &timeseries_type) {
    m_timeseries_type = timeseries_type;
    m_timeseries_type_isSet = true;
}

bool OAITimeseriesProperties::is_timeseries_type_Set() const{
    return m_timeseries_type_isSet;
}

bool OAITimeseriesProperties::is_timeseries_type_Valid() const{
    return m_timeseries_type_isValid;
}

bool OAITimeseriesProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_aggregation_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_country_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_end_date_time_utc_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_endpoint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_start_date_time_utc_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeseries_data.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_timeseries_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITimeseriesProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
