/**
 * ADHybridHealthService
 * REST APIs for Azure Active Directory Connect Health
 *
 * The version of the OpenAPI document: 2014-01-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPasswordManagementSettings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPasswordManagementSettings::OAIPasswordManagementSettings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPasswordManagementSettings::OAIPasswordManagementSettings() {
    this->initializeModel();
}

OAIPasswordManagementSettings::~OAIPasswordManagementSettings() {}

void OAIPasswordManagementSettings::initializeModel() {

    m_connect_to_isSet = false;
    m_connect_to_isValid = false;

    m_connection_timeout_isSet = false;
    m_connection_timeout_isValid = false;

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_extension_file_path_isSet = false;
    m_extension_file_path_isValid = false;

    m_maximum_retry_count_isSet = false;
    m_maximum_retry_count_isValid = false;

    m_requires_secure_connection_isSet = false;
    m_requires_secure_connection_isValid = false;

    m_retry_interval_in_seconds_isSet = false;
    m_retry_interval_in_seconds_isValid = false;

    m_supported_password_operations_isSet = false;
    m_supported_password_operations_isValid = false;

    m_unlock_account_isSet = false;
    m_unlock_account_isValid = false;

    m_user_isSet = false;
    m_user_isValid = false;
}

void OAIPasswordManagementSettings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPasswordManagementSettings::fromJsonObject(QJsonObject json) {

    m_connect_to_isValid = ::OpenAPI::fromJsonValue(m_connect_to, json[QString("connectTo")]);
    m_connect_to_isSet = !json[QString("connectTo")].isNull() && m_connect_to_isValid;

    m_connection_timeout_isValid = ::OpenAPI::fromJsonValue(m_connection_timeout, json[QString("connectionTimeout")]);
    m_connection_timeout_isSet = !json[QString("connectionTimeout")].isNull() && m_connection_timeout_isValid;

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("enabled")]);
    m_enabled_isSet = !json[QString("enabled")].isNull() && m_enabled_isValid;

    m_extension_file_path_isValid = ::OpenAPI::fromJsonValue(m_extension_file_path, json[QString("extensionFilePath")]);
    m_extension_file_path_isSet = !json[QString("extensionFilePath")].isNull() && m_extension_file_path_isValid;

    m_maximum_retry_count_isValid = ::OpenAPI::fromJsonValue(m_maximum_retry_count, json[QString("maximumRetryCount")]);
    m_maximum_retry_count_isSet = !json[QString("maximumRetryCount")].isNull() && m_maximum_retry_count_isValid;

    m_requires_secure_connection_isValid = ::OpenAPI::fromJsonValue(m_requires_secure_connection, json[QString("requiresSecureConnection")]);
    m_requires_secure_connection_isSet = !json[QString("requiresSecureConnection")].isNull() && m_requires_secure_connection_isValid;

    m_retry_interval_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_retry_interval_in_seconds, json[QString("retryIntervalInSeconds")]);
    m_retry_interval_in_seconds_isSet = !json[QString("retryIntervalInSeconds")].isNull() && m_retry_interval_in_seconds_isValid;

    m_supported_password_operations_isValid = ::OpenAPI::fromJsonValue(m_supported_password_operations, json[QString("supportedPasswordOperations")]);
    m_supported_password_operations_isSet = !json[QString("supportedPasswordOperations")].isNull() && m_supported_password_operations_isValid;

    m_unlock_account_isValid = ::OpenAPI::fromJsonValue(m_unlock_account, json[QString("unlockAccount")]);
    m_unlock_account_isSet = !json[QString("unlockAccount")].isNull() && m_unlock_account_isValid;

    m_user_isValid = ::OpenAPI::fromJsonValue(m_user, json[QString("user")]);
    m_user_isSet = !json[QString("user")].isNull() && m_user_isValid;
}

QString OAIPasswordManagementSettings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPasswordManagementSettings::asJsonObject() const {
    QJsonObject obj;
    if (m_connect_to_isSet) {
        obj.insert(QString("connectTo"), ::OpenAPI::toJsonValue(m_connect_to));
    }
    if (m_connection_timeout_isSet) {
        obj.insert(QString("connectionTimeout"), ::OpenAPI::toJsonValue(m_connection_timeout));
    }
    if (m_enabled_isSet) {
        obj.insert(QString("enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_extension_file_path_isSet) {
        obj.insert(QString("extensionFilePath"), ::OpenAPI::toJsonValue(m_extension_file_path));
    }
    if (m_maximum_retry_count_isSet) {
        obj.insert(QString("maximumRetryCount"), ::OpenAPI::toJsonValue(m_maximum_retry_count));
    }
    if (m_requires_secure_connection_isSet) {
        obj.insert(QString("requiresSecureConnection"), ::OpenAPI::toJsonValue(m_requires_secure_connection));
    }
    if (m_retry_interval_in_seconds_isSet) {
        obj.insert(QString("retryIntervalInSeconds"), ::OpenAPI::toJsonValue(m_retry_interval_in_seconds));
    }
    if (m_supported_password_operations_isSet) {
        obj.insert(QString("supportedPasswordOperations"), ::OpenAPI::toJsonValue(m_supported_password_operations));
    }
    if (m_unlock_account_isSet) {
        obj.insert(QString("unlockAccount"), ::OpenAPI::toJsonValue(m_unlock_account));
    }
    if (m_user_isSet) {
        obj.insert(QString("user"), ::OpenAPI::toJsonValue(m_user));
    }
    return obj;
}

QString OAIPasswordManagementSettings::getConnectTo() const {
    return m_connect_to;
}
void OAIPasswordManagementSettings::setConnectTo(const QString &connect_to) {
    m_connect_to = connect_to;
    m_connect_to_isSet = true;
}

bool OAIPasswordManagementSettings::is_connect_to_Set() const{
    return m_connect_to_isSet;
}

bool OAIPasswordManagementSettings::is_connect_to_Valid() const{
    return m_connect_to_isValid;
}

qint32 OAIPasswordManagementSettings::getConnectionTimeout() const {
    return m_connection_timeout;
}
void OAIPasswordManagementSettings::setConnectionTimeout(const qint32 &connection_timeout) {
    m_connection_timeout = connection_timeout;
    m_connection_timeout_isSet = true;
}

bool OAIPasswordManagementSettings::is_connection_timeout_Set() const{
    return m_connection_timeout_isSet;
}

bool OAIPasswordManagementSettings::is_connection_timeout_Valid() const{
    return m_connection_timeout_isValid;
}

bool OAIPasswordManagementSettings::isEnabled() const {
    return m_enabled;
}
void OAIPasswordManagementSettings::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAIPasswordManagementSettings::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAIPasswordManagementSettings::is_enabled_Valid() const{
    return m_enabled_isValid;
}

QString OAIPasswordManagementSettings::getExtensionFilePath() const {
    return m_extension_file_path;
}
void OAIPasswordManagementSettings::setExtensionFilePath(const QString &extension_file_path) {
    m_extension_file_path = extension_file_path;
    m_extension_file_path_isSet = true;
}

bool OAIPasswordManagementSettings::is_extension_file_path_Set() const{
    return m_extension_file_path_isSet;
}

bool OAIPasswordManagementSettings::is_extension_file_path_Valid() const{
    return m_extension_file_path_isValid;
}

qint32 OAIPasswordManagementSettings::getMaximumRetryCount() const {
    return m_maximum_retry_count;
}
void OAIPasswordManagementSettings::setMaximumRetryCount(const qint32 &maximum_retry_count) {
    m_maximum_retry_count = maximum_retry_count;
    m_maximum_retry_count_isSet = true;
}

bool OAIPasswordManagementSettings::is_maximum_retry_count_Set() const{
    return m_maximum_retry_count_isSet;
}

bool OAIPasswordManagementSettings::is_maximum_retry_count_Valid() const{
    return m_maximum_retry_count_isValid;
}

bool OAIPasswordManagementSettings::isRequiresSecureConnection() const {
    return m_requires_secure_connection;
}
void OAIPasswordManagementSettings::setRequiresSecureConnection(const bool &requires_secure_connection) {
    m_requires_secure_connection = requires_secure_connection;
    m_requires_secure_connection_isSet = true;
}

bool OAIPasswordManagementSettings::is_requires_secure_connection_Set() const{
    return m_requires_secure_connection_isSet;
}

bool OAIPasswordManagementSettings::is_requires_secure_connection_Valid() const{
    return m_requires_secure_connection_isValid;
}

qint32 OAIPasswordManagementSettings::getRetryIntervalInSeconds() const {
    return m_retry_interval_in_seconds;
}
void OAIPasswordManagementSettings::setRetryIntervalInSeconds(const qint32 &retry_interval_in_seconds) {
    m_retry_interval_in_seconds = retry_interval_in_seconds;
    m_retry_interval_in_seconds_isSet = true;
}

bool OAIPasswordManagementSettings::is_retry_interval_in_seconds_Set() const{
    return m_retry_interval_in_seconds_isSet;
}

bool OAIPasswordManagementSettings::is_retry_interval_in_seconds_Valid() const{
    return m_retry_interval_in_seconds_isValid;
}

QString OAIPasswordManagementSettings::getSupportedPasswordOperations() const {
    return m_supported_password_operations;
}
void OAIPasswordManagementSettings::setSupportedPasswordOperations(const QString &supported_password_operations) {
    m_supported_password_operations = supported_password_operations;
    m_supported_password_operations_isSet = true;
}

bool OAIPasswordManagementSettings::is_supported_password_operations_Set() const{
    return m_supported_password_operations_isSet;
}

bool OAIPasswordManagementSettings::is_supported_password_operations_Valid() const{
    return m_supported_password_operations_isValid;
}

bool OAIPasswordManagementSettings::isUnlockAccount() const {
    return m_unlock_account;
}
void OAIPasswordManagementSettings::setUnlockAccount(const bool &unlock_account) {
    m_unlock_account = unlock_account;
    m_unlock_account_isSet = true;
}

bool OAIPasswordManagementSettings::is_unlock_account_Set() const{
    return m_unlock_account_isSet;
}

bool OAIPasswordManagementSettings::is_unlock_account_Valid() const{
    return m_unlock_account_isValid;
}

QString OAIPasswordManagementSettings::getUser() const {
    return m_user;
}
void OAIPasswordManagementSettings::setUser(const QString &user) {
    m_user = user;
    m_user_isSet = true;
}

bool OAIPasswordManagementSettings::is_user_Set() const{
    return m_user_isSet;
}

bool OAIPasswordManagementSettings::is_user_Valid() const{
    return m_user_isValid;
}

bool OAIPasswordManagementSettings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_connect_to_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_connection_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_extension_file_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_retry_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_secure_connection_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_retry_interval_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_password_operations_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unlock_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPasswordManagementSettings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
