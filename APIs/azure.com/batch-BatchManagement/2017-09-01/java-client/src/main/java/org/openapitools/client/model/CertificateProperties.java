/*
 * BatchManagement
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2017-09-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.DeleteCertificateError;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Certificate properties.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:48:39.479442-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CertificateProperties {
  public static final String SERIALIZED_NAME_DELETE_CERTIFICATE_ERROR = "deleteCertificateError";
  @SerializedName(SERIALIZED_NAME_DELETE_CERTIFICATE_ERROR)
  private DeleteCertificateError deleteCertificateError;

  /**
   * The previous provisioned state of the resource
   */
  @JsonAdapter(PreviousProvisioningStateEnum.Adapter.class)
  public enum PreviousProvisioningStateEnum {
    SUCCEEDED("Succeeded"),
    
    DELETING("Deleting"),
    
    FAILED("Failed");

    private String value;

    PreviousProvisioningStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PreviousProvisioningStateEnum fromValue(String value) {
      for (PreviousProvisioningStateEnum b : PreviousProvisioningStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PreviousProvisioningStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PreviousProvisioningStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PreviousProvisioningStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PreviousProvisioningStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PreviousProvisioningStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PREVIOUS_PROVISIONING_STATE = "previousProvisioningState";
  @SerializedName(SERIALIZED_NAME_PREVIOUS_PROVISIONING_STATE)
  private PreviousProvisioningStateEnum previousProvisioningState;

  public static final String SERIALIZED_NAME_PREVIOUS_PROVISIONING_STATE_TRANSITION_TIME = "previousProvisioningStateTransitionTime";
  @SerializedName(SERIALIZED_NAME_PREVIOUS_PROVISIONING_STATE_TRANSITION_TIME)
  private OffsetDateTime previousProvisioningStateTransitionTime;

  /**
   * Values are:   Succeeded - The certificate is available for use in pools.  Deleting - The user has requested that the certificate be deleted, but the delete operation has not yet completed. You may not reference the certificate when creating or updating pools.  Failed - The user requested that the certificate be deleted, but there are pools that still have references to the certificate, or it is still installed on one or more compute nodes. (The latter can occur if the certificate has been removed from the pool, but the node has not yet restarted. Nodes refresh their certificates only when they restart.) You may use the cancel certificate delete operation to cancel the delete, or the delete certificate operation to retry the delete.
   */
  @JsonAdapter(ProvisioningStateEnum.Adapter.class)
  public enum ProvisioningStateEnum {
    SUCCEEDED("Succeeded"),
    
    DELETING("Deleting"),
    
    FAILED("Failed");

    private String value;

    ProvisioningStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProvisioningStateEnum fromValue(String value) {
      for (ProvisioningStateEnum b : ProvisioningStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProvisioningStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProvisioningStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProvisioningStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProvisioningStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProvisioningStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROVISIONING_STATE = "provisioningState";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE)
  private ProvisioningStateEnum provisioningState;

  public static final String SERIALIZED_NAME_PROVISIONING_STATE_TRANSITION_TIME = "provisioningStateTransitionTime";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE_TRANSITION_TIME)
  private OffsetDateTime provisioningStateTransitionTime;

  public static final String SERIALIZED_NAME_PUBLIC_DATA = "publicData";
  @SerializedName(SERIALIZED_NAME_PUBLIC_DATA)
  private String publicData;

  /**
   * The format of the certificate - either Pfx or Cer. If omitted, the default is Pfx.
   */
  @JsonAdapter(FormatEnum.Adapter.class)
  public enum FormatEnum {
    PFX("Pfx"),
    
    CER("Cer");

    private String value;

    FormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FormatEnum fromValue(String value) {
      for (FormatEnum b : FormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FormatEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FormatEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  private FormatEnum format;

  public static final String SERIALIZED_NAME_THUMBPRINT = "thumbprint";
  @SerializedName(SERIALIZED_NAME_THUMBPRINT)
  private String thumbprint;

  public static final String SERIALIZED_NAME_THUMBPRINT_ALGORITHM = "thumbprintAlgorithm";
  @SerializedName(SERIALIZED_NAME_THUMBPRINT_ALGORITHM)
  private String thumbprintAlgorithm;

  public CertificateProperties() {
  }

  public CertificateProperties(
     PreviousProvisioningStateEnum previousProvisioningState, 
     OffsetDateTime previousProvisioningStateTransitionTime, 
     ProvisioningStateEnum provisioningState, 
     OffsetDateTime provisioningStateTransitionTime, 
     String publicData
  ) {
    this();
    this.previousProvisioningState = previousProvisioningState;
    this.previousProvisioningStateTransitionTime = previousProvisioningStateTransitionTime;
    this.provisioningState = provisioningState;
    this.provisioningStateTransitionTime = provisioningStateTransitionTime;
    this.publicData = publicData;
  }

  public CertificateProperties deleteCertificateError(DeleteCertificateError deleteCertificateError) {
    this.deleteCertificateError = deleteCertificateError;
    return this;
  }

  /**
   * Get deleteCertificateError
   * @return deleteCertificateError
   */
  @javax.annotation.Nullable
  public DeleteCertificateError getDeleteCertificateError() {
    return deleteCertificateError;
  }

  public void setDeleteCertificateError(DeleteCertificateError deleteCertificateError) {
    this.deleteCertificateError = deleteCertificateError;
  }


  /**
   * The previous provisioned state of the resource
   * @return previousProvisioningState
   */
  @javax.annotation.Nullable
  public PreviousProvisioningStateEnum getPreviousProvisioningState() {
    return previousProvisioningState;
  }



  /**
   * Get previousProvisioningStateTransitionTime
   * @return previousProvisioningStateTransitionTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getPreviousProvisioningStateTransitionTime() {
    return previousProvisioningStateTransitionTime;
  }



  /**
   * Values are:   Succeeded - The certificate is available for use in pools.  Deleting - The user has requested that the certificate be deleted, but the delete operation has not yet completed. You may not reference the certificate when creating or updating pools.  Failed - The user requested that the certificate be deleted, but there are pools that still have references to the certificate, or it is still installed on one or more compute nodes. (The latter can occur if the certificate has been removed from the pool, but the node has not yet restarted. Nodes refresh their certificates only when they restart.) You may use the cancel certificate delete operation to cancel the delete, or the delete certificate operation to retry the delete.
   * @return provisioningState
   */
  @javax.annotation.Nullable
  public ProvisioningStateEnum getProvisioningState() {
    return provisioningState;
  }



  /**
   * Get provisioningStateTransitionTime
   * @return provisioningStateTransitionTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getProvisioningStateTransitionTime() {
    return provisioningStateTransitionTime;
  }



  /**
   * The public key of the certificate.
   * @return publicData
   */
  @javax.annotation.Nullable
  public String getPublicData() {
    return publicData;
  }



  public CertificateProperties format(FormatEnum format) {
    this.format = format;
    return this;
  }

  /**
   * The format of the certificate - either Pfx or Cer. If omitted, the default is Pfx.
   * @return format
   */
  @javax.annotation.Nullable
  public FormatEnum getFormat() {
    return format;
  }

  public void setFormat(FormatEnum format) {
    this.format = format;
  }


  public CertificateProperties thumbprint(String thumbprint) {
    this.thumbprint = thumbprint;
    return this;
  }

  /**
   * This must match the thumbprint from the name.
   * @return thumbprint
   */
  @javax.annotation.Nullable
  public String getThumbprint() {
    return thumbprint;
  }

  public void setThumbprint(String thumbprint) {
    this.thumbprint = thumbprint;
  }


  public CertificateProperties thumbprintAlgorithm(String thumbprintAlgorithm) {
    this.thumbprintAlgorithm = thumbprintAlgorithm;
    return this;
  }

  /**
   * This must match the first portion of the certificate name. Currently required to be &#39;SHA1&#39;.
   * @return thumbprintAlgorithm
   */
  @javax.annotation.Nullable
  public String getThumbprintAlgorithm() {
    return thumbprintAlgorithm;
  }

  public void setThumbprintAlgorithm(String thumbprintAlgorithm) {
    this.thumbprintAlgorithm = thumbprintAlgorithm;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CertificateProperties certificateProperties = (CertificateProperties) o;
    return Objects.equals(this.deleteCertificateError, certificateProperties.deleteCertificateError) &&
        Objects.equals(this.previousProvisioningState, certificateProperties.previousProvisioningState) &&
        Objects.equals(this.previousProvisioningStateTransitionTime, certificateProperties.previousProvisioningStateTransitionTime) &&
        Objects.equals(this.provisioningState, certificateProperties.provisioningState) &&
        Objects.equals(this.provisioningStateTransitionTime, certificateProperties.provisioningStateTransitionTime) &&
        Objects.equals(this.publicData, certificateProperties.publicData) &&
        Objects.equals(this.format, certificateProperties.format) &&
        Objects.equals(this.thumbprint, certificateProperties.thumbprint) &&
        Objects.equals(this.thumbprintAlgorithm, certificateProperties.thumbprintAlgorithm);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deleteCertificateError, previousProvisioningState, previousProvisioningStateTransitionTime, provisioningState, provisioningStateTransitionTime, publicData, format, thumbprint, thumbprintAlgorithm);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CertificateProperties {\n");
    sb.append("    deleteCertificateError: ").append(toIndentedString(deleteCertificateError)).append("\n");
    sb.append("    previousProvisioningState: ").append(toIndentedString(previousProvisioningState)).append("\n");
    sb.append("    previousProvisioningStateTransitionTime: ").append(toIndentedString(previousProvisioningStateTransitionTime)).append("\n");
    sb.append("    provisioningState: ").append(toIndentedString(provisioningState)).append("\n");
    sb.append("    provisioningStateTransitionTime: ").append(toIndentedString(provisioningStateTransitionTime)).append("\n");
    sb.append("    publicData: ").append(toIndentedString(publicData)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    thumbprint: ").append(toIndentedString(thumbprint)).append("\n");
    sb.append("    thumbprintAlgorithm: ").append(toIndentedString(thumbprintAlgorithm)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("format");
    openapiFields.add("thumbprint");
    openapiFields.add("thumbprintAlgorithm");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CertificateProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CertificateProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CertificateProperties is not found in the empty JSON string", CertificateProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CertificateProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CertificateProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `deleteCertificateError`
      if (jsonObj.get("deleteCertificateError") != null && !jsonObj.get("deleteCertificateError").isJsonNull()) {
        DeleteCertificateError.validateJsonElement(jsonObj.get("deleteCertificateError"));
      }
      if ((jsonObj.get("previousProvisioningState") != null && !jsonObj.get("previousProvisioningState").isJsonNull()) && !jsonObj.get("previousProvisioningState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `previousProvisioningState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("previousProvisioningState").toString()));
      }
      // validate the optional field `previousProvisioningState`
      if (jsonObj.get("previousProvisioningState") != null && !jsonObj.get("previousProvisioningState").isJsonNull()) {
        PreviousProvisioningStateEnum.validateJsonElement(jsonObj.get("previousProvisioningState"));
      }
      if ((jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) && !jsonObj.get("provisioningState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioningState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioningState").toString()));
      }
      // validate the optional field `provisioningState`
      if (jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) {
        ProvisioningStateEnum.validateJsonElement(jsonObj.get("provisioningState"));
      }
      if ((jsonObj.get("publicData") != null && !jsonObj.get("publicData").isJsonNull()) && !jsonObj.get("publicData").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publicData` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publicData").toString()));
      }
      if ((jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      // validate the optional field `format`
      if (jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) {
        FormatEnum.validateJsonElement(jsonObj.get("format"));
      }
      if ((jsonObj.get("thumbprint") != null && !jsonObj.get("thumbprint").isJsonNull()) && !jsonObj.get("thumbprint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `thumbprint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("thumbprint").toString()));
      }
      if ((jsonObj.get("thumbprintAlgorithm") != null && !jsonObj.get("thumbprintAlgorithm").isJsonNull()) && !jsonObj.get("thumbprintAlgorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `thumbprintAlgorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("thumbprintAlgorithm").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CertificateProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CertificateProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CertificateProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CertificateProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<CertificateProperties>() {
           @Override
           public void write(JsonWriter out, CertificateProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CertificateProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CertificateProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CertificateProperties
   * @throws IOException if the JSON string is invalid with respect to CertificateProperties
   */
  public static CertificateProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CertificateProperties.class);
  }

  /**
   * Convert an instance of CertificateProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

