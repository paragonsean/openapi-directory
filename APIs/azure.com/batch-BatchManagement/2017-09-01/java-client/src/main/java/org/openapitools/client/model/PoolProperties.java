/*
 * BatchManagement
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2017-09-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ApplicationPackageReference;
import org.openapitools.client.model.AutoScaleRun;
import org.openapitools.client.model.CertificateReference;
import org.openapitools.client.model.DeploymentConfiguration;
import org.openapitools.client.model.MetadataItem;
import org.openapitools.client.model.NetworkConfiguration;
import org.openapitools.client.model.ResizeOperationStatus;
import org.openapitools.client.model.ScaleSettings;
import org.openapitools.client.model.StartTask;
import org.openapitools.client.model.TaskSchedulingPolicy;
import org.openapitools.client.model.UserAccount;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Pool properties.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:48:39.479442-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PoolProperties {
  /**
   * Values are:   Steady - The pool is not resizing. There are no changes to the number of nodes in the pool in progress. A pool enters this state when it is created and when no operations are being performed on the pool to change the number of dedicated nodes.  Resizing - The pool is resizing; that is, compute nodes are being added to or removed from the pool.  Stopping - The pool was resizing, but the user has requested that the resize be stopped, but the stop request has not yet been completed.
   */
  @JsonAdapter(AllocationStateEnum.Adapter.class)
  public enum AllocationStateEnum {
    STEADY("Steady"),
    
    RESIZING("Resizing"),
    
    STOPPING("Stopping");

    private String value;

    AllocationStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AllocationStateEnum fromValue(String value) {
      for (AllocationStateEnum b : AllocationStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AllocationStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AllocationStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AllocationStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AllocationStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AllocationStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ALLOCATION_STATE = "allocationState";
  @SerializedName(SERIALIZED_NAME_ALLOCATION_STATE)
  private AllocationStateEnum allocationState;

  public static final String SERIALIZED_NAME_ALLOCATION_STATE_TRANSITION_TIME = "allocationStateTransitionTime";
  @SerializedName(SERIALIZED_NAME_ALLOCATION_STATE_TRANSITION_TIME)
  private OffsetDateTime allocationStateTransitionTime;

  public static final String SERIALIZED_NAME_APPLICATION_LICENSES = "applicationLicenses";
  @SerializedName(SERIALIZED_NAME_APPLICATION_LICENSES)
  private List<String> applicationLicenses = new ArrayList<>();

  public static final String SERIALIZED_NAME_APPLICATION_PACKAGES = "applicationPackages";
  @SerializedName(SERIALIZED_NAME_APPLICATION_PACKAGES)
  private List<ApplicationPackageReference> applicationPackages = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUTO_SCALE_RUN = "autoScaleRun";
  @SerializedName(SERIALIZED_NAME_AUTO_SCALE_RUN)
  private AutoScaleRun autoScaleRun;

  public static final String SERIALIZED_NAME_CERTIFICATES = "certificates";
  @SerializedName(SERIALIZED_NAME_CERTIFICATES)
  private List<CertificateReference> certificates = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATION_TIME = "creationTime";
  @SerializedName(SERIALIZED_NAME_CREATION_TIME)
  private OffsetDateTime creationTime;

  public static final String SERIALIZED_NAME_CURRENT_DEDICATED_NODES = "currentDedicatedNodes";
  @SerializedName(SERIALIZED_NAME_CURRENT_DEDICATED_NODES)
  private Integer currentDedicatedNodes;

  public static final String SERIALIZED_NAME_CURRENT_LOW_PRIORITY_NODES = "currentLowPriorityNodes";
  @SerializedName(SERIALIZED_NAME_CURRENT_LOW_PRIORITY_NODES)
  private Integer currentLowPriorityNodes;

  public static final String SERIALIZED_NAME_DEPLOYMENT_CONFIGURATION = "deploymentConfiguration";
  @SerializedName(SERIALIZED_NAME_DEPLOYMENT_CONFIGURATION)
  private DeploymentConfiguration deploymentConfiguration;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  /**
   * This imposes restrictions on which nodes can be assigned to the pool. Enabling this value can reduce the chance of the requested number of nodes to be allocated in the pool. If not specified, this value defaults to &#39;Disabled&#39;.
   */
  @JsonAdapter(InterNodeCommunicationEnum.Adapter.class)
  public enum InterNodeCommunicationEnum {
    ENABLED("Enabled"),
    
    DISABLED("Disabled");

    private String value;

    InterNodeCommunicationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InterNodeCommunicationEnum fromValue(String value) {
      for (InterNodeCommunicationEnum b : InterNodeCommunicationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InterNodeCommunicationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InterNodeCommunicationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InterNodeCommunicationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InterNodeCommunicationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InterNodeCommunicationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INTER_NODE_COMMUNICATION = "interNodeCommunication";
  @SerializedName(SERIALIZED_NAME_INTER_NODE_COMMUNICATION)
  private InterNodeCommunicationEnum interNodeCommunication;

  public static final String SERIALIZED_NAME_LAST_MODIFIED = "lastModified";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED)
  private OffsetDateTime lastModified;

  public static final String SERIALIZED_NAME_MAX_TASKS_PER_NODE = "maxTasksPerNode";
  @SerializedName(SERIALIZED_NAME_MAX_TASKS_PER_NODE)
  private Integer maxTasksPerNode;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private List<MetadataItem> metadata = new ArrayList<>();

  public static final String SERIALIZED_NAME_NETWORK_CONFIGURATION = "networkConfiguration";
  @SerializedName(SERIALIZED_NAME_NETWORK_CONFIGURATION)
  private NetworkConfiguration networkConfiguration;

  /**
   * Values are:   Succeeded - The pool is available to run tasks subject to the availability of compute nodes.  Deleting - The user has requested that the pool be deleted, but the delete operation has not yet completed.
   */
  @JsonAdapter(ProvisioningStateEnum.Adapter.class)
  public enum ProvisioningStateEnum {
    SUCCEEDED("Succeeded"),
    
    DELETING("Deleting");

    private String value;

    ProvisioningStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProvisioningStateEnum fromValue(String value) {
      for (ProvisioningStateEnum b : ProvisioningStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProvisioningStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProvisioningStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProvisioningStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProvisioningStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProvisioningStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROVISIONING_STATE = "provisioningState";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE)
  private ProvisioningStateEnum provisioningState;

  public static final String SERIALIZED_NAME_PROVISIONING_STATE_TRANSITION_TIME = "provisioningStateTransitionTime";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE_TRANSITION_TIME)
  private OffsetDateTime provisioningStateTransitionTime;

  public static final String SERIALIZED_NAME_RESIZE_OPERATION_STATUS = "resizeOperationStatus";
  @SerializedName(SERIALIZED_NAME_RESIZE_OPERATION_STATUS)
  private ResizeOperationStatus resizeOperationStatus;

  public static final String SERIALIZED_NAME_SCALE_SETTINGS = "scaleSettings";
  @SerializedName(SERIALIZED_NAME_SCALE_SETTINGS)
  private ScaleSettings scaleSettings;

  public static final String SERIALIZED_NAME_START_TASK = "startTask";
  @SerializedName(SERIALIZED_NAME_START_TASK)
  private StartTask startTask;

  public static final String SERIALIZED_NAME_TASK_SCHEDULING_POLICY = "taskSchedulingPolicy";
  @SerializedName(SERIALIZED_NAME_TASK_SCHEDULING_POLICY)
  private TaskSchedulingPolicy taskSchedulingPolicy;

  public static final String SERIALIZED_NAME_USER_ACCOUNTS = "userAccounts";
  @SerializedName(SERIALIZED_NAME_USER_ACCOUNTS)
  private List<UserAccount> userAccounts = new ArrayList<>();

  public static final String SERIALIZED_NAME_VM_SIZE = "vmSize";
  @SerializedName(SERIALIZED_NAME_VM_SIZE)
  private String vmSize;

  public PoolProperties() {
  }

  public PoolProperties(
     AllocationStateEnum allocationState, 
     OffsetDateTime allocationStateTransitionTime, 
     OffsetDateTime creationTime, 
     Integer currentDedicatedNodes, 
     Integer currentLowPriorityNodes, 
     OffsetDateTime lastModified, 
     ProvisioningStateEnum provisioningState, 
     OffsetDateTime provisioningStateTransitionTime
  ) {
    this();
    this.allocationState = allocationState;
    this.allocationStateTransitionTime = allocationStateTransitionTime;
    this.creationTime = creationTime;
    this.currentDedicatedNodes = currentDedicatedNodes;
    this.currentLowPriorityNodes = currentLowPriorityNodes;
    this.lastModified = lastModified;
    this.provisioningState = provisioningState;
    this.provisioningStateTransitionTime = provisioningStateTransitionTime;
  }

  /**
   * Values are:   Steady - The pool is not resizing. There are no changes to the number of nodes in the pool in progress. A pool enters this state when it is created and when no operations are being performed on the pool to change the number of dedicated nodes.  Resizing - The pool is resizing; that is, compute nodes are being added to or removed from the pool.  Stopping - The pool was resizing, but the user has requested that the resize be stopped, but the stop request has not yet been completed.
   * @return allocationState
   */
  @javax.annotation.Nullable
  public AllocationStateEnum getAllocationState() {
    return allocationState;
  }



  /**
   * Get allocationStateTransitionTime
   * @return allocationStateTransitionTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAllocationStateTransitionTime() {
    return allocationStateTransitionTime;
  }



  public PoolProperties applicationLicenses(List<String> applicationLicenses) {
    this.applicationLicenses = applicationLicenses;
    return this;
  }

  public PoolProperties addApplicationLicensesItem(String applicationLicensesItem) {
    if (this.applicationLicenses == null) {
      this.applicationLicenses = new ArrayList<>();
    }
    this.applicationLicenses.add(applicationLicensesItem);
    return this;
  }

  /**
   * The list of application licenses must be a subset of available Batch service application licenses. If a license is requested which is not supported, pool creation will fail.
   * @return applicationLicenses
   */
  @javax.annotation.Nullable
  public List<String> getApplicationLicenses() {
    return applicationLicenses;
  }

  public void setApplicationLicenses(List<String> applicationLicenses) {
    this.applicationLicenses = applicationLicenses;
  }


  public PoolProperties applicationPackages(List<ApplicationPackageReference> applicationPackages) {
    this.applicationPackages = applicationPackages;
    return this;
  }

  public PoolProperties addApplicationPackagesItem(ApplicationPackageReference applicationPackagesItem) {
    if (this.applicationPackages == null) {
      this.applicationPackages = new ArrayList<>();
    }
    this.applicationPackages.add(applicationPackagesItem);
    return this;
  }

  /**
   * Changes to application packages affect all new compute nodes joining the pool, but do not affect compute nodes that are already in the pool until they are rebooted or reimaged.
   * @return applicationPackages
   */
  @javax.annotation.Nullable
  public List<ApplicationPackageReference> getApplicationPackages() {
    return applicationPackages;
  }

  public void setApplicationPackages(List<ApplicationPackageReference> applicationPackages) {
    this.applicationPackages = applicationPackages;
  }


  public PoolProperties autoScaleRun(AutoScaleRun autoScaleRun) {
    this.autoScaleRun = autoScaleRun;
    return this;
  }

  /**
   * Get autoScaleRun
   * @return autoScaleRun
   */
  @javax.annotation.Nullable
  public AutoScaleRun getAutoScaleRun() {
    return autoScaleRun;
  }

  public void setAutoScaleRun(AutoScaleRun autoScaleRun) {
    this.autoScaleRun = autoScaleRun;
  }


  public PoolProperties certificates(List<CertificateReference> certificates) {
    this.certificates = certificates;
    return this;
  }

  public PoolProperties addCertificatesItem(CertificateReference certificatesItem) {
    if (this.certificates == null) {
      this.certificates = new ArrayList<>();
    }
    this.certificates.add(certificatesItem);
    return this;
  }

  /**
   * For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this location. For certificates with visibility of &#39;remoteUser&#39;, a &#39;certs&#39; directory is created in the user&#39;s home directory (e.g., /home/{user-name}/certs) and certificates are placed in that directory.
   * @return certificates
   */
  @javax.annotation.Nullable
  public List<CertificateReference> getCertificates() {
    return certificates;
  }

  public void setCertificates(List<CertificateReference> certificates) {
    this.certificates = certificates;
  }


  /**
   * Get creationTime
   * @return creationTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreationTime() {
    return creationTime;
  }



  /**
   * Get currentDedicatedNodes
   * @return currentDedicatedNodes
   */
  @javax.annotation.Nullable
  public Integer getCurrentDedicatedNodes() {
    return currentDedicatedNodes;
  }



  /**
   * Get currentLowPriorityNodes
   * @return currentLowPriorityNodes
   */
  @javax.annotation.Nullable
  public Integer getCurrentLowPriorityNodes() {
    return currentLowPriorityNodes;
  }



  public PoolProperties deploymentConfiguration(DeploymentConfiguration deploymentConfiguration) {
    this.deploymentConfiguration = deploymentConfiguration;
    return this;
  }

  /**
   * Get deploymentConfiguration
   * @return deploymentConfiguration
   */
  @javax.annotation.Nullable
  public DeploymentConfiguration getDeploymentConfiguration() {
    return deploymentConfiguration;
  }

  public void setDeploymentConfiguration(DeploymentConfiguration deploymentConfiguration) {
    this.deploymentConfiguration = deploymentConfiguration;
  }


  public PoolProperties displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * The display name need not be unique and can contain any Unicode characters up to a maximum length of 1024.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public PoolProperties interNodeCommunication(InterNodeCommunicationEnum interNodeCommunication) {
    this.interNodeCommunication = interNodeCommunication;
    return this;
  }

  /**
   * This imposes restrictions on which nodes can be assigned to the pool. Enabling this value can reduce the chance of the requested number of nodes to be allocated in the pool. If not specified, this value defaults to &#39;Disabled&#39;.
   * @return interNodeCommunication
   */
  @javax.annotation.Nullable
  public InterNodeCommunicationEnum getInterNodeCommunication() {
    return interNodeCommunication;
  }

  public void setInterNodeCommunication(InterNodeCommunicationEnum interNodeCommunication) {
    this.interNodeCommunication = interNodeCommunication;
  }


  /**
   * This is the last time at which the pool level data, such as the targetDedicatedNodes or autoScaleSettings, changed. It does not factor in node-level changes such as a compute node changing state.
   * @return lastModified
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastModified() {
    return lastModified;
  }



  public PoolProperties maxTasksPerNode(Integer maxTasksPerNode) {
    this.maxTasksPerNode = maxTasksPerNode;
    return this;
  }

  /**
   * Get maxTasksPerNode
   * @return maxTasksPerNode
   */
  @javax.annotation.Nullable
  public Integer getMaxTasksPerNode() {
    return maxTasksPerNode;
  }

  public void setMaxTasksPerNode(Integer maxTasksPerNode) {
    this.maxTasksPerNode = maxTasksPerNode;
  }


  public PoolProperties metadata(List<MetadataItem> metadata) {
    this.metadata = metadata;
    return this;
  }

  public PoolProperties addMetadataItem(MetadataItem metadataItem) {
    if (this.metadata == null) {
      this.metadata = new ArrayList<>();
    }
    this.metadata.add(metadataItem);
    return this;
  }

  /**
   * The Batch service does not assign any meaning to metadata; it is solely for the use of user code.
   * @return metadata
   */
  @javax.annotation.Nullable
  public List<MetadataItem> getMetadata() {
    return metadata;
  }

  public void setMetadata(List<MetadataItem> metadata) {
    this.metadata = metadata;
  }


  public PoolProperties networkConfiguration(NetworkConfiguration networkConfiguration) {
    this.networkConfiguration = networkConfiguration;
    return this;
  }

  /**
   * Get networkConfiguration
   * @return networkConfiguration
   */
  @javax.annotation.Nullable
  public NetworkConfiguration getNetworkConfiguration() {
    return networkConfiguration;
  }

  public void setNetworkConfiguration(NetworkConfiguration networkConfiguration) {
    this.networkConfiguration = networkConfiguration;
  }


  /**
   * Values are:   Succeeded - The pool is available to run tasks subject to the availability of compute nodes.  Deleting - The user has requested that the pool be deleted, but the delete operation has not yet completed.
   * @return provisioningState
   */
  @javax.annotation.Nullable
  public ProvisioningStateEnum getProvisioningState() {
    return provisioningState;
  }



  /**
   * Get provisioningStateTransitionTime
   * @return provisioningStateTransitionTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getProvisioningStateTransitionTime() {
    return provisioningStateTransitionTime;
  }



  public PoolProperties resizeOperationStatus(ResizeOperationStatus resizeOperationStatus) {
    this.resizeOperationStatus = resizeOperationStatus;
    return this;
  }

  /**
   * Get resizeOperationStatus
   * @return resizeOperationStatus
   */
  @javax.annotation.Nullable
  public ResizeOperationStatus getResizeOperationStatus() {
    return resizeOperationStatus;
  }

  public void setResizeOperationStatus(ResizeOperationStatus resizeOperationStatus) {
    this.resizeOperationStatus = resizeOperationStatus;
  }


  public PoolProperties scaleSettings(ScaleSettings scaleSettings) {
    this.scaleSettings = scaleSettings;
    return this;
  }

  /**
   * Get scaleSettings
   * @return scaleSettings
   */
  @javax.annotation.Nullable
  public ScaleSettings getScaleSettings() {
    return scaleSettings;
  }

  public void setScaleSettings(ScaleSettings scaleSettings) {
    this.scaleSettings = scaleSettings;
  }


  public PoolProperties startTask(StartTask startTask) {
    this.startTask = startTask;
    return this;
  }

  /**
   * Get startTask
   * @return startTask
   */
  @javax.annotation.Nullable
  public StartTask getStartTask() {
    return startTask;
  }

  public void setStartTask(StartTask startTask) {
    this.startTask = startTask;
  }


  public PoolProperties taskSchedulingPolicy(TaskSchedulingPolicy taskSchedulingPolicy) {
    this.taskSchedulingPolicy = taskSchedulingPolicy;
    return this;
  }

  /**
   * Get taskSchedulingPolicy
   * @return taskSchedulingPolicy
   */
  @javax.annotation.Nullable
  public TaskSchedulingPolicy getTaskSchedulingPolicy() {
    return taskSchedulingPolicy;
  }

  public void setTaskSchedulingPolicy(TaskSchedulingPolicy taskSchedulingPolicy) {
    this.taskSchedulingPolicy = taskSchedulingPolicy;
  }


  public PoolProperties userAccounts(List<UserAccount> userAccounts) {
    this.userAccounts = userAccounts;
    return this;
  }

  public PoolProperties addUserAccountsItem(UserAccount userAccountsItem) {
    if (this.userAccounts == null) {
      this.userAccounts = new ArrayList<>();
    }
    this.userAccounts.add(userAccountsItem);
    return this;
  }

  /**
   * Get userAccounts
   * @return userAccounts
   */
  @javax.annotation.Nullable
  public List<UserAccount> getUserAccounts() {
    return userAccounts;
  }

  public void setUserAccounts(List<UserAccount> userAccounts) {
    this.userAccounts = userAccounts;
  }


  public PoolProperties vmSize(String vmSize) {
    this.vmSize = vmSize;
    return this;
  }

  /**
   * For information about available sizes of virtual machines for Cloud Services pools (pools created with cloudServiceConfiguration), see Sizes for Cloud Services (https://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/). Batch supports all Cloud Services VM sizes except ExtraSmall. For information about available VM sizes for pools using images from the Virtual Machines Marketplace (pools created with virtualMachineConfiguration) see Sizes for Virtual Machines (Linux) (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/) or Sizes for Virtual Machines (Windows) (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/). Batch supports all Azure VM sizes except STANDARD_A0 and those with premium storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
   * @return vmSize
   */
  @javax.annotation.Nullable
  public String getVmSize() {
    return vmSize;
  }

  public void setVmSize(String vmSize) {
    this.vmSize = vmSize;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PoolProperties poolProperties = (PoolProperties) o;
    return Objects.equals(this.allocationState, poolProperties.allocationState) &&
        Objects.equals(this.allocationStateTransitionTime, poolProperties.allocationStateTransitionTime) &&
        Objects.equals(this.applicationLicenses, poolProperties.applicationLicenses) &&
        Objects.equals(this.applicationPackages, poolProperties.applicationPackages) &&
        Objects.equals(this.autoScaleRun, poolProperties.autoScaleRun) &&
        Objects.equals(this.certificates, poolProperties.certificates) &&
        Objects.equals(this.creationTime, poolProperties.creationTime) &&
        Objects.equals(this.currentDedicatedNodes, poolProperties.currentDedicatedNodes) &&
        Objects.equals(this.currentLowPriorityNodes, poolProperties.currentLowPriorityNodes) &&
        Objects.equals(this.deploymentConfiguration, poolProperties.deploymentConfiguration) &&
        Objects.equals(this.displayName, poolProperties.displayName) &&
        Objects.equals(this.interNodeCommunication, poolProperties.interNodeCommunication) &&
        Objects.equals(this.lastModified, poolProperties.lastModified) &&
        Objects.equals(this.maxTasksPerNode, poolProperties.maxTasksPerNode) &&
        Objects.equals(this.metadata, poolProperties.metadata) &&
        Objects.equals(this.networkConfiguration, poolProperties.networkConfiguration) &&
        Objects.equals(this.provisioningState, poolProperties.provisioningState) &&
        Objects.equals(this.provisioningStateTransitionTime, poolProperties.provisioningStateTransitionTime) &&
        Objects.equals(this.resizeOperationStatus, poolProperties.resizeOperationStatus) &&
        Objects.equals(this.scaleSettings, poolProperties.scaleSettings) &&
        Objects.equals(this.startTask, poolProperties.startTask) &&
        Objects.equals(this.taskSchedulingPolicy, poolProperties.taskSchedulingPolicy) &&
        Objects.equals(this.userAccounts, poolProperties.userAccounts) &&
        Objects.equals(this.vmSize, poolProperties.vmSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allocationState, allocationStateTransitionTime, applicationLicenses, applicationPackages, autoScaleRun, certificates, creationTime, currentDedicatedNodes, currentLowPriorityNodes, deploymentConfiguration, displayName, interNodeCommunication, lastModified, maxTasksPerNode, metadata, networkConfiguration, provisioningState, provisioningStateTransitionTime, resizeOperationStatus, scaleSettings, startTask, taskSchedulingPolicy, userAccounts, vmSize);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PoolProperties {\n");
    sb.append("    allocationState: ").append(toIndentedString(allocationState)).append("\n");
    sb.append("    allocationStateTransitionTime: ").append(toIndentedString(allocationStateTransitionTime)).append("\n");
    sb.append("    applicationLicenses: ").append(toIndentedString(applicationLicenses)).append("\n");
    sb.append("    applicationPackages: ").append(toIndentedString(applicationPackages)).append("\n");
    sb.append("    autoScaleRun: ").append(toIndentedString(autoScaleRun)).append("\n");
    sb.append("    certificates: ").append(toIndentedString(certificates)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    currentDedicatedNodes: ").append(toIndentedString(currentDedicatedNodes)).append("\n");
    sb.append("    currentLowPriorityNodes: ").append(toIndentedString(currentLowPriorityNodes)).append("\n");
    sb.append("    deploymentConfiguration: ").append(toIndentedString(deploymentConfiguration)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    interNodeCommunication: ").append(toIndentedString(interNodeCommunication)).append("\n");
    sb.append("    lastModified: ").append(toIndentedString(lastModified)).append("\n");
    sb.append("    maxTasksPerNode: ").append(toIndentedString(maxTasksPerNode)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    networkConfiguration: ").append(toIndentedString(networkConfiguration)).append("\n");
    sb.append("    provisioningState: ").append(toIndentedString(provisioningState)).append("\n");
    sb.append("    provisioningStateTransitionTime: ").append(toIndentedString(provisioningStateTransitionTime)).append("\n");
    sb.append("    resizeOperationStatus: ").append(toIndentedString(resizeOperationStatus)).append("\n");
    sb.append("    scaleSettings: ").append(toIndentedString(scaleSettings)).append("\n");
    sb.append("    startTask: ").append(toIndentedString(startTask)).append("\n");
    sb.append("    taskSchedulingPolicy: ").append(toIndentedString(taskSchedulingPolicy)).append("\n");
    sb.append("    userAccounts: ").append(toIndentedString(userAccounts)).append("\n");
    sb.append("    vmSize: ").append(toIndentedString(vmSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allocationState");
    openapiFields.add("allocationStateTransitionTime");
    openapiFields.add("applicationLicenses");
    openapiFields.add("applicationPackages");
    openapiFields.add("autoScaleRun");
    openapiFields.add("certificates");
    openapiFields.add("creationTime");
    openapiFields.add("currentDedicatedNodes");
    openapiFields.add("currentLowPriorityNodes");
    openapiFields.add("deploymentConfiguration");
    openapiFields.add("displayName");
    openapiFields.add("interNodeCommunication");
    openapiFields.add("lastModified");
    openapiFields.add("maxTasksPerNode");
    openapiFields.add("metadata");
    openapiFields.add("networkConfiguration");
    openapiFields.add("provisioningState");
    openapiFields.add("provisioningStateTransitionTime");
    openapiFields.add("resizeOperationStatus");
    openapiFields.add("scaleSettings");
    openapiFields.add("startTask");
    openapiFields.add("taskSchedulingPolicy");
    openapiFields.add("userAccounts");
    openapiFields.add("vmSize");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PoolProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PoolProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PoolProperties is not found in the empty JSON string", PoolProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PoolProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PoolProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("allocationState") != null && !jsonObj.get("allocationState").isJsonNull()) && !jsonObj.get("allocationState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allocationState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allocationState").toString()));
      }
      // validate the optional field `allocationState`
      if (jsonObj.get("allocationState") != null && !jsonObj.get("allocationState").isJsonNull()) {
        AllocationStateEnum.validateJsonElement(jsonObj.get("allocationState"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("applicationLicenses") != null && !jsonObj.get("applicationLicenses").isJsonNull() && !jsonObj.get("applicationLicenses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `applicationLicenses` to be an array in the JSON string but got `%s`", jsonObj.get("applicationLicenses").toString()));
      }
      if (jsonObj.get("applicationPackages") != null && !jsonObj.get("applicationPackages").isJsonNull()) {
        JsonArray jsonArrayapplicationPackages = jsonObj.getAsJsonArray("applicationPackages");
        if (jsonArrayapplicationPackages != null) {
          // ensure the json data is an array
          if (!jsonObj.get("applicationPackages").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `applicationPackages` to be an array in the JSON string but got `%s`", jsonObj.get("applicationPackages").toString()));
          }

          // validate the optional field `applicationPackages` (array)
          for (int i = 0; i < jsonArrayapplicationPackages.size(); i++) {
            ApplicationPackageReference.validateJsonElement(jsonArrayapplicationPackages.get(i));
          };
        }
      }
      // validate the optional field `autoScaleRun`
      if (jsonObj.get("autoScaleRun") != null && !jsonObj.get("autoScaleRun").isJsonNull()) {
        AutoScaleRun.validateJsonElement(jsonObj.get("autoScaleRun"));
      }
      if (jsonObj.get("certificates") != null && !jsonObj.get("certificates").isJsonNull()) {
        JsonArray jsonArraycertificates = jsonObj.getAsJsonArray("certificates");
        if (jsonArraycertificates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("certificates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `certificates` to be an array in the JSON string but got `%s`", jsonObj.get("certificates").toString()));
          }

          // validate the optional field `certificates` (array)
          for (int i = 0; i < jsonArraycertificates.size(); i++) {
            CertificateReference.validateJsonElement(jsonArraycertificates.get(i));
          };
        }
      }
      // validate the optional field `deploymentConfiguration`
      if (jsonObj.get("deploymentConfiguration") != null && !jsonObj.get("deploymentConfiguration").isJsonNull()) {
        DeploymentConfiguration.validateJsonElement(jsonObj.get("deploymentConfiguration"));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("interNodeCommunication") != null && !jsonObj.get("interNodeCommunication").isJsonNull()) && !jsonObj.get("interNodeCommunication").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interNodeCommunication` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interNodeCommunication").toString()));
      }
      // validate the optional field `interNodeCommunication`
      if (jsonObj.get("interNodeCommunication") != null && !jsonObj.get("interNodeCommunication").isJsonNull()) {
        InterNodeCommunicationEnum.validateJsonElement(jsonObj.get("interNodeCommunication"));
      }
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        JsonArray jsonArraymetadata = jsonObj.getAsJsonArray("metadata");
        if (jsonArraymetadata != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metadata").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metadata` to be an array in the JSON string but got `%s`", jsonObj.get("metadata").toString()));
          }

          // validate the optional field `metadata` (array)
          for (int i = 0; i < jsonArraymetadata.size(); i++) {
            MetadataItem.validateJsonElement(jsonArraymetadata.get(i));
          };
        }
      }
      // validate the optional field `networkConfiguration`
      if (jsonObj.get("networkConfiguration") != null && !jsonObj.get("networkConfiguration").isJsonNull()) {
        NetworkConfiguration.validateJsonElement(jsonObj.get("networkConfiguration"));
      }
      if ((jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) && !jsonObj.get("provisioningState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioningState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioningState").toString()));
      }
      // validate the optional field `provisioningState`
      if (jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) {
        ProvisioningStateEnum.validateJsonElement(jsonObj.get("provisioningState"));
      }
      // validate the optional field `resizeOperationStatus`
      if (jsonObj.get("resizeOperationStatus") != null && !jsonObj.get("resizeOperationStatus").isJsonNull()) {
        ResizeOperationStatus.validateJsonElement(jsonObj.get("resizeOperationStatus"));
      }
      // validate the optional field `scaleSettings`
      if (jsonObj.get("scaleSettings") != null && !jsonObj.get("scaleSettings").isJsonNull()) {
        ScaleSettings.validateJsonElement(jsonObj.get("scaleSettings"));
      }
      // validate the optional field `startTask`
      if (jsonObj.get("startTask") != null && !jsonObj.get("startTask").isJsonNull()) {
        StartTask.validateJsonElement(jsonObj.get("startTask"));
      }
      // validate the optional field `taskSchedulingPolicy`
      if (jsonObj.get("taskSchedulingPolicy") != null && !jsonObj.get("taskSchedulingPolicy").isJsonNull()) {
        TaskSchedulingPolicy.validateJsonElement(jsonObj.get("taskSchedulingPolicy"));
      }
      if (jsonObj.get("userAccounts") != null && !jsonObj.get("userAccounts").isJsonNull()) {
        JsonArray jsonArrayuserAccounts = jsonObj.getAsJsonArray("userAccounts");
        if (jsonArrayuserAccounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("userAccounts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `userAccounts` to be an array in the JSON string but got `%s`", jsonObj.get("userAccounts").toString()));
          }

          // validate the optional field `userAccounts` (array)
          for (int i = 0; i < jsonArrayuserAccounts.size(); i++) {
            UserAccount.validateJsonElement(jsonArrayuserAccounts.get(i));
          };
        }
      }
      if ((jsonObj.get("vmSize") != null && !jsonObj.get("vmSize").isJsonNull()) && !jsonObj.get("vmSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vmSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vmSize").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PoolProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PoolProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PoolProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PoolProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<PoolProperties>() {
           @Override
           public void write(JsonWriter out, PoolProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PoolProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PoolProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PoolProperties
   * @throws IOException if the JSON string is invalid with respect to PoolProperties
   */
  public static PoolProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PoolProperties.class);
  }

  /**
   * Convert an instance of PoolProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

