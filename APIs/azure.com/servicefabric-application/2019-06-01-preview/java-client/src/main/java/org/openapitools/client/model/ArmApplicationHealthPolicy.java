/*
 * ServiceFabricManagementClient
 * Azure Service Fabric Resource Provider API Client
 *
 * The version of the OpenAPI document: 2019-06-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.ArmServiceTypeHealthPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines a health policy used to evaluate the health of an application or one of its children entities. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:54:13.005460-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ArmApplicationHealthPolicy {
  public static final String SERIALIZED_NAME_CONSIDER_WARNING_AS_ERROR = "considerWarningAsError";
  @SerializedName(SERIALIZED_NAME_CONSIDER_WARNING_AS_ERROR)
  private Boolean considerWarningAsError = false;

  public static final String SERIALIZED_NAME_DEFAULT_SERVICE_TYPE_HEALTH_POLICY = "defaultServiceTypeHealthPolicy";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SERVICE_TYPE_HEALTH_POLICY)
  private ArmServiceTypeHealthPolicy defaultServiceTypeHealthPolicy;

  public static final String SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_DEPLOYED_APPLICATIONS = "maxPercentUnhealthyDeployedApplications";
  @SerializedName(SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_DEPLOYED_APPLICATIONS)
  private Integer maxPercentUnhealthyDeployedApplications;

  public static final String SERIALIZED_NAME_SERVICE_TYPE_HEALTH_POLICY_MAP = "serviceTypeHealthPolicyMap";
  @SerializedName(SERIALIZED_NAME_SERVICE_TYPE_HEALTH_POLICY_MAP)
  private Map<String, ArmServiceTypeHealthPolicy> serviceTypeHealthPolicyMap = new HashMap<>();

  public ArmApplicationHealthPolicy() {
  }

  public ArmApplicationHealthPolicy considerWarningAsError(Boolean considerWarningAsError) {
    this.considerWarningAsError = considerWarningAsError;
    return this;
  }

  /**
   * Indicates whether warnings are treated with the same severity as errors.
   * @return considerWarningAsError
   */
  @javax.annotation.Nullable
  public Boolean getConsiderWarningAsError() {
    return considerWarningAsError;
  }

  public void setConsiderWarningAsError(Boolean considerWarningAsError) {
    this.considerWarningAsError = considerWarningAsError;
  }


  public ArmApplicationHealthPolicy defaultServiceTypeHealthPolicy(ArmServiceTypeHealthPolicy defaultServiceTypeHealthPolicy) {
    this.defaultServiceTypeHealthPolicy = defaultServiceTypeHealthPolicy;
    return this;
  }

  /**
   * Get defaultServiceTypeHealthPolicy
   * @return defaultServiceTypeHealthPolicy
   */
  @javax.annotation.Nullable
  public ArmServiceTypeHealthPolicy getDefaultServiceTypeHealthPolicy() {
    return defaultServiceTypeHealthPolicy;
  }

  public void setDefaultServiceTypeHealthPolicy(ArmServiceTypeHealthPolicy defaultServiceTypeHealthPolicy) {
    this.defaultServiceTypeHealthPolicy = defaultServiceTypeHealthPolicy;
  }


  public ArmApplicationHealthPolicy maxPercentUnhealthyDeployedApplications(Integer maxPercentUnhealthyDeployedApplications) {
    this.maxPercentUnhealthyDeployedApplications = maxPercentUnhealthyDeployedApplications;
    return this;
  }

  /**
   * The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte values from zero to 100. The percentage represents the maximum tolerated percentage of deployed applications that can be unhealthy before the application is considered in error. This is calculated by dividing the number of unhealthy deployed applications over the number of nodes where the application is currently deployed on in the cluster. The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero. 
   * @return maxPercentUnhealthyDeployedApplications
   */
  @javax.annotation.Nullable
  public Integer getMaxPercentUnhealthyDeployedApplications() {
    return maxPercentUnhealthyDeployedApplications;
  }

  public void setMaxPercentUnhealthyDeployedApplications(Integer maxPercentUnhealthyDeployedApplications) {
    this.maxPercentUnhealthyDeployedApplications = maxPercentUnhealthyDeployedApplications;
  }


  public ArmApplicationHealthPolicy serviceTypeHealthPolicyMap(Map<String, ArmServiceTypeHealthPolicy> serviceTypeHealthPolicyMap) {
    this.serviceTypeHealthPolicyMap = serviceTypeHealthPolicyMap;
    return this;
  }

  public ArmApplicationHealthPolicy putServiceTypeHealthPolicyMapItem(String key, ArmServiceTypeHealthPolicy serviceTypeHealthPolicyMapItem) {
    if (this.serviceTypeHealthPolicyMap == null) {
      this.serviceTypeHealthPolicyMap = new HashMap<>();
    }
    this.serviceTypeHealthPolicyMap.put(key, serviceTypeHealthPolicyMapItem);
    return this;
  }

  /**
   * Defines a ServiceTypeHealthPolicy per service type name.  The entries in the map replace the default service type health policy for each specified service type. For example, in an application that contains both a stateless gateway service type and a stateful engine service type, the health policies for the stateless and stateful services can be configured differently. With policy per service type, there&#39;s more granular control of the health of the service.  If no policy is specified for a service type name, the DefaultServiceTypeHealthPolicy is used for evaluation. 
   * @return serviceTypeHealthPolicyMap
   */
  @javax.annotation.Nullable
  public Map<String, ArmServiceTypeHealthPolicy> getServiceTypeHealthPolicyMap() {
    return serviceTypeHealthPolicyMap;
  }

  public void setServiceTypeHealthPolicyMap(Map<String, ArmServiceTypeHealthPolicy> serviceTypeHealthPolicyMap) {
    this.serviceTypeHealthPolicyMap = serviceTypeHealthPolicyMap;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ArmApplicationHealthPolicy armApplicationHealthPolicy = (ArmApplicationHealthPolicy) o;
    return Objects.equals(this.considerWarningAsError, armApplicationHealthPolicy.considerWarningAsError) &&
        Objects.equals(this.defaultServiceTypeHealthPolicy, armApplicationHealthPolicy.defaultServiceTypeHealthPolicy) &&
        Objects.equals(this.maxPercentUnhealthyDeployedApplications, armApplicationHealthPolicy.maxPercentUnhealthyDeployedApplications) &&
        Objects.equals(this.serviceTypeHealthPolicyMap, armApplicationHealthPolicy.serviceTypeHealthPolicyMap);
  }

  @Override
  public int hashCode() {
    return Objects.hash(considerWarningAsError, defaultServiceTypeHealthPolicy, maxPercentUnhealthyDeployedApplications, serviceTypeHealthPolicyMap);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ArmApplicationHealthPolicy {\n");
    sb.append("    considerWarningAsError: ").append(toIndentedString(considerWarningAsError)).append("\n");
    sb.append("    defaultServiceTypeHealthPolicy: ").append(toIndentedString(defaultServiceTypeHealthPolicy)).append("\n");
    sb.append("    maxPercentUnhealthyDeployedApplications: ").append(toIndentedString(maxPercentUnhealthyDeployedApplications)).append("\n");
    sb.append("    serviceTypeHealthPolicyMap: ").append(toIndentedString(serviceTypeHealthPolicyMap)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("considerWarningAsError");
    openapiFields.add("defaultServiceTypeHealthPolicy");
    openapiFields.add("maxPercentUnhealthyDeployedApplications");
    openapiFields.add("serviceTypeHealthPolicyMap");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ArmApplicationHealthPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ArmApplicationHealthPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ArmApplicationHealthPolicy is not found in the empty JSON string", ArmApplicationHealthPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ArmApplicationHealthPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ArmApplicationHealthPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `defaultServiceTypeHealthPolicy`
      if (jsonObj.get("defaultServiceTypeHealthPolicy") != null && !jsonObj.get("defaultServiceTypeHealthPolicy").isJsonNull()) {
        ArmServiceTypeHealthPolicy.validateJsonElement(jsonObj.get("defaultServiceTypeHealthPolicy"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ArmApplicationHealthPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ArmApplicationHealthPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ArmApplicationHealthPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ArmApplicationHealthPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<ArmApplicationHealthPolicy>() {
           @Override
           public void write(JsonWriter out, ArmApplicationHealthPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ArmApplicationHealthPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ArmApplicationHealthPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ArmApplicationHealthPolicy
   * @throws IOException if the JSON string is invalid with respect to ArmApplicationHealthPolicy
   */
  public static ArmApplicationHealthPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ArmApplicationHealthPolicy.class);
  }

  /**
   * Convert an instance of ArmApplicationHealthPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

