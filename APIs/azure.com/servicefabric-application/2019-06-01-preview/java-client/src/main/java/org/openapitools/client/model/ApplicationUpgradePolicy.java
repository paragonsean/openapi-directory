/*
 * ServiceFabricManagementClient
 * Azure Service Fabric Resource Provider API Client
 *
 * The version of the OpenAPI document: 2019-06-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ArmApplicationHealthPolicy;
import org.openapitools.client.model.ArmRollingUpgradeMonitoringPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the policy for a monitored application upgrade.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:54:13.005460-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ApplicationUpgradePolicy {
  public static final String SERIALIZED_NAME_APPLICATION_HEALTH_POLICY = "applicationHealthPolicy";
  @SerializedName(SERIALIZED_NAME_APPLICATION_HEALTH_POLICY)
  private ArmApplicationHealthPolicy applicationHealthPolicy;

  public static final String SERIALIZED_NAME_FORCE_RESTART = "forceRestart";
  @SerializedName(SERIALIZED_NAME_FORCE_RESTART)
  private Boolean forceRestart = false;

  public static final String SERIALIZED_NAME_ROLLING_UPGRADE_MONITORING_POLICY = "rollingUpgradeMonitoringPolicy";
  @SerializedName(SERIALIZED_NAME_ROLLING_UPGRADE_MONITORING_POLICY)
  private ArmRollingUpgradeMonitoringPolicy rollingUpgradeMonitoringPolicy;

  public static final String SERIALIZED_NAME_UPGRADE_REPLICA_SET_CHECK_TIMEOUT = "upgradeReplicaSetCheckTimeout";
  @SerializedName(SERIALIZED_NAME_UPGRADE_REPLICA_SET_CHECK_TIMEOUT)
  private String upgradeReplicaSetCheckTimeout;

  public ApplicationUpgradePolicy() {
  }

  public ApplicationUpgradePolicy applicationHealthPolicy(ArmApplicationHealthPolicy applicationHealthPolicy) {
    this.applicationHealthPolicy = applicationHealthPolicy;
    return this;
  }

  /**
   * Get applicationHealthPolicy
   * @return applicationHealthPolicy
   */
  @javax.annotation.Nullable
  public ArmApplicationHealthPolicy getApplicationHealthPolicy() {
    return applicationHealthPolicy;
  }

  public void setApplicationHealthPolicy(ArmApplicationHealthPolicy applicationHealthPolicy) {
    this.applicationHealthPolicy = applicationHealthPolicy;
  }


  public ApplicationUpgradePolicy forceRestart(Boolean forceRestart) {
    this.forceRestart = forceRestart;
    return this;
  }

  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
   * @return forceRestart
   */
  @javax.annotation.Nullable
  public Boolean getForceRestart() {
    return forceRestart;
  }

  public void setForceRestart(Boolean forceRestart) {
    this.forceRestart = forceRestart;
  }


  public ApplicationUpgradePolicy rollingUpgradeMonitoringPolicy(ArmRollingUpgradeMonitoringPolicy rollingUpgradeMonitoringPolicy) {
    this.rollingUpgradeMonitoringPolicy = rollingUpgradeMonitoringPolicy;
    return this;
  }

  /**
   * Get rollingUpgradeMonitoringPolicy
   * @return rollingUpgradeMonitoringPolicy
   */
  @javax.annotation.Nullable
  public ArmRollingUpgradeMonitoringPolicy getRollingUpgradeMonitoringPolicy() {
    return rollingUpgradeMonitoringPolicy;
  }

  public void setRollingUpgradeMonitoringPolicy(ArmRollingUpgradeMonitoringPolicy rollingUpgradeMonitoringPolicy) {
    this.rollingUpgradeMonitoringPolicy = rollingUpgradeMonitoringPolicy;
  }


  public ApplicationUpgradePolicy upgradeReplicaSetCheckTimeout(String upgradeReplicaSetCheckTimeout) {
    this.upgradeReplicaSetCheckTimeout = upgradeReplicaSetCheckTimeout;
    return this;
  }

  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
   * @return upgradeReplicaSetCheckTimeout
   */
  @javax.annotation.Nullable
  public String getUpgradeReplicaSetCheckTimeout() {
    return upgradeReplicaSetCheckTimeout;
  }

  public void setUpgradeReplicaSetCheckTimeout(String upgradeReplicaSetCheckTimeout) {
    this.upgradeReplicaSetCheckTimeout = upgradeReplicaSetCheckTimeout;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApplicationUpgradePolicy applicationUpgradePolicy = (ApplicationUpgradePolicy) o;
    return Objects.equals(this.applicationHealthPolicy, applicationUpgradePolicy.applicationHealthPolicy) &&
        Objects.equals(this.forceRestart, applicationUpgradePolicy.forceRestart) &&
        Objects.equals(this.rollingUpgradeMonitoringPolicy, applicationUpgradePolicy.rollingUpgradeMonitoringPolicy) &&
        Objects.equals(this.upgradeReplicaSetCheckTimeout, applicationUpgradePolicy.upgradeReplicaSetCheckTimeout);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationHealthPolicy, forceRestart, rollingUpgradeMonitoringPolicy, upgradeReplicaSetCheckTimeout);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApplicationUpgradePolicy {\n");
    sb.append("    applicationHealthPolicy: ").append(toIndentedString(applicationHealthPolicy)).append("\n");
    sb.append("    forceRestart: ").append(toIndentedString(forceRestart)).append("\n");
    sb.append("    rollingUpgradeMonitoringPolicy: ").append(toIndentedString(rollingUpgradeMonitoringPolicy)).append("\n");
    sb.append("    upgradeReplicaSetCheckTimeout: ").append(toIndentedString(upgradeReplicaSetCheckTimeout)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("applicationHealthPolicy");
    openapiFields.add("forceRestart");
    openapiFields.add("rollingUpgradeMonitoringPolicy");
    openapiFields.add("upgradeReplicaSetCheckTimeout");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ApplicationUpgradePolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ApplicationUpgradePolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApplicationUpgradePolicy is not found in the empty JSON string", ApplicationUpgradePolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ApplicationUpgradePolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ApplicationUpgradePolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `applicationHealthPolicy`
      if (jsonObj.get("applicationHealthPolicy") != null && !jsonObj.get("applicationHealthPolicy").isJsonNull()) {
        ArmApplicationHealthPolicy.validateJsonElement(jsonObj.get("applicationHealthPolicy"));
      }
      // validate the optional field `rollingUpgradeMonitoringPolicy`
      if (jsonObj.get("rollingUpgradeMonitoringPolicy") != null && !jsonObj.get("rollingUpgradeMonitoringPolicy").isJsonNull()) {
        ArmRollingUpgradeMonitoringPolicy.validateJsonElement(jsonObj.get("rollingUpgradeMonitoringPolicy"));
      }
      if ((jsonObj.get("upgradeReplicaSetCheckTimeout") != null && !jsonObj.get("upgradeReplicaSetCheckTimeout").isJsonNull()) && !jsonObj.get("upgradeReplicaSetCheckTimeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `upgradeReplicaSetCheckTimeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("upgradeReplicaSetCheckTimeout").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApplicationUpgradePolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApplicationUpgradePolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApplicationUpgradePolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApplicationUpgradePolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<ApplicationUpgradePolicy>() {
           @Override
           public void write(JsonWriter out, ApplicationUpgradePolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApplicationUpgradePolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ApplicationUpgradePolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ApplicationUpgradePolicy
   * @throws IOException if the JSON string is invalid with respect to ApplicationUpgradePolicy
   */
  public static ApplicationUpgradePolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApplicationUpgradePolicy.class);
  }

  /**
   * Convert an instance of ApplicationUpgradePolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

