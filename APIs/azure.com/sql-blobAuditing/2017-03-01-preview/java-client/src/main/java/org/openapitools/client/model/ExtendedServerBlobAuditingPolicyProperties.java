/*
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2017-03-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Properties of an extended server blob auditing policy.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:18:48.886601-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExtendedServerBlobAuditingPolicyProperties {
  public static final String SERIALIZED_NAME_AUDIT_ACTIONS_AND_GROUPS = "auditActionsAndGroups";
  @SerializedName(SERIALIZED_NAME_AUDIT_ACTIONS_AND_GROUPS)
  private List<String> auditActionsAndGroups = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_AZURE_MONITOR_TARGET_ENABLED = "isAzureMonitorTargetEnabled";
  @SerializedName(SERIALIZED_NAME_IS_AZURE_MONITOR_TARGET_ENABLED)
  private Boolean isAzureMonitorTargetEnabled;

  public static final String SERIALIZED_NAME_IS_STORAGE_SECONDARY_KEY_IN_USE = "isStorageSecondaryKeyInUse";
  @SerializedName(SERIALIZED_NAME_IS_STORAGE_SECONDARY_KEY_IN_USE)
  private Boolean isStorageSecondaryKeyInUse;

  public static final String SERIALIZED_NAME_PREDICATE_EXPRESSION = "predicateExpression";
  @SerializedName(SERIALIZED_NAME_PREDICATE_EXPRESSION)
  private String predicateExpression;

  public static final String SERIALIZED_NAME_QUEUE_DELAY_MS = "queueDelayMs";
  @SerializedName(SERIALIZED_NAME_QUEUE_DELAY_MS)
  private Integer queueDelayMs;

  public static final String SERIALIZED_NAME_RETENTION_DAYS = "retentionDays";
  @SerializedName(SERIALIZED_NAME_RETENTION_DAYS)
  private Integer retentionDays;

  /**
   * Specifies the state of the policy. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    ENABLED("Enabled"),
    
    DISABLED("Disabled");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_STORAGE_ACCOUNT_ACCESS_KEY = "storageAccountAccessKey";
  @SerializedName(SERIALIZED_NAME_STORAGE_ACCOUNT_ACCESS_KEY)
  private String storageAccountAccessKey;

  public static final String SERIALIZED_NAME_STORAGE_ACCOUNT_SUBSCRIPTION_ID = "storageAccountSubscriptionId";
  @SerializedName(SERIALIZED_NAME_STORAGE_ACCOUNT_SUBSCRIPTION_ID)
  private UUID storageAccountSubscriptionId;

  public static final String SERIALIZED_NAME_STORAGE_ENDPOINT = "storageEndpoint";
  @SerializedName(SERIALIZED_NAME_STORAGE_ENDPOINT)
  private String storageEndpoint;

  public ExtendedServerBlobAuditingPolicyProperties() {
  }

  public ExtendedServerBlobAuditingPolicyProperties auditActionsAndGroups(List<String> auditActionsAndGroups) {
    this.auditActionsAndGroups = auditActionsAndGroups;
    return this;
  }

  public ExtendedServerBlobAuditingPolicyProperties addAuditActionsAndGroupsItem(String auditActionsAndGroupsItem) {
    if (this.auditActionsAndGroups == null) {
      this.auditActionsAndGroups = new ArrayList<>();
    }
    this.auditActionsAndGroups.add(auditActionsAndGroupsItem);
    return this;
  }

  /**
   * Specifies the Actions-Groups and Actions to audit.    The recommended set of action groups to use is the following combination - this will audit all the queries and stored procedures executed against the database, as well as successful and failed logins:    BATCH_COMPLETED_GROUP,  SUCCESSFUL_DATABASE_AUTHENTICATION_GROUP,  FAILED_DATABASE_AUTHENTICATION_GROUP.    This above combination is also the set that is configured by default when enabling auditing from the Azure portal.    The supported action groups to audit are (note: choose only specific groups that cover your auditing needs. Using unnecessary groups could lead to very large quantities of audit records):    APPLICATION_ROLE_CHANGE_PASSWORD_GROUP  BACKUP_RESTORE_GROUP  DATABASE_LOGOUT_GROUP  DATABASE_OBJECT_CHANGE_GROUP  DATABASE_OBJECT_OWNERSHIP_CHANGE_GROUP  DATABASE_OBJECT_PERMISSION_CHANGE_GROUP  DATABASE_OPERATION_GROUP  DATABASE_PERMISSION_CHANGE_GROUP  DATABASE_PRINCIPAL_CHANGE_GROUP  DATABASE_PRINCIPAL_IMPERSONATION_GROUP  DATABASE_ROLE_MEMBER_CHANGE_GROUP  FAILED_DATABASE_AUTHENTICATION_GROUP  SCHEMA_OBJECT_ACCESS_GROUP  SCHEMA_OBJECT_CHANGE_GROUP  SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP  SCHEMA_OBJECT_PERMISSION_CHANGE_GROUP  SUCCESSFUL_DATABASE_AUTHENTICATION_GROUP  USER_CHANGE_PASSWORD_GROUP  BATCH_STARTED_GROUP  BATCH_COMPLETED_GROUP    These are groups that cover all sql statements and stored procedures executed against the database, and should not be used in combination with other groups as this will result in duplicate audit logs.    For more information, see [Database-Level Audit Action Groups](https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-action-groups).    For Database auditing policy, specific Actions can also be specified (note that Actions cannot be specified for Server auditing policy). The supported actions to audit are:  SELECT  UPDATE  INSERT  DELETE  EXECUTE  RECEIVE  REFERENCES    The general form for defining an action to be audited is:  {action} ON {object} BY {principal}    Note that &lt;object&gt; in the above format can refer to an object like a table, view, or stored procedure, or an entire database or schema. For the latter cases, the forms DATABASE::{db_name} and SCHEMA::{schema_name} are used, respectively.    For example:  SELECT on dbo.myTable by public  SELECT on DATABASE::myDatabase by public  SELECT on SCHEMA::mySchema by public    For more information, see [Database-Level Audit Actions](https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions#database-level-audit-actions)
   * @return auditActionsAndGroups
   */
  @javax.annotation.Nullable
  public List<String> getAuditActionsAndGroups() {
    return auditActionsAndGroups;
  }

  public void setAuditActionsAndGroups(List<String> auditActionsAndGroups) {
    this.auditActionsAndGroups = auditActionsAndGroups;
  }


  public ExtendedServerBlobAuditingPolicyProperties isAzureMonitorTargetEnabled(Boolean isAzureMonitorTargetEnabled) {
    this.isAzureMonitorTargetEnabled = isAzureMonitorTargetEnabled;
    return this;
  }

  /**
   * Specifies whether audit events are sent to Azure Monitor.   In order to send the events to Azure Monitor, specify &#39;state&#39; as &#39;Enabled&#39; and &#39;isAzureMonitorTargetEnabled&#39; as true.    When using REST API to configure auditing, Diagnostic Settings with &#39;SQLSecurityAuditEvents&#39; diagnostic logs category on the database should be also created.  Note that for server level audit you should use the &#39;master&#39; database as {databaseName}.    Diagnostic Settings URI format:  PUT https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}/providers/microsoft.insights/diagnosticSettings/{settingsName}?api-version&#x3D;2017-05-01-preview    For more information, see [Diagnostic Settings REST API](https://go.microsoft.com/fwlink/?linkid&#x3D;2033207)  or [Diagnostic Settings PowerShell](https://go.microsoft.com/fwlink/?linkid&#x3D;2033043)  
   * @return isAzureMonitorTargetEnabled
   */
  @javax.annotation.Nullable
  public Boolean getIsAzureMonitorTargetEnabled() {
    return isAzureMonitorTargetEnabled;
  }

  public void setIsAzureMonitorTargetEnabled(Boolean isAzureMonitorTargetEnabled) {
    this.isAzureMonitorTargetEnabled = isAzureMonitorTargetEnabled;
  }


  public ExtendedServerBlobAuditingPolicyProperties isStorageSecondaryKeyInUse(Boolean isStorageSecondaryKeyInUse) {
    this.isStorageSecondaryKeyInUse = isStorageSecondaryKeyInUse;
    return this;
  }

  /**
   * Specifies whether storageAccountAccessKey value is the storage&#39;s secondary key.
   * @return isStorageSecondaryKeyInUse
   */
  @javax.annotation.Nullable
  public Boolean getIsStorageSecondaryKeyInUse() {
    return isStorageSecondaryKeyInUse;
  }

  public void setIsStorageSecondaryKeyInUse(Boolean isStorageSecondaryKeyInUse) {
    this.isStorageSecondaryKeyInUse = isStorageSecondaryKeyInUse;
  }


  public ExtendedServerBlobAuditingPolicyProperties predicateExpression(String predicateExpression) {
    this.predicateExpression = predicateExpression;
    return this;
  }

  /**
   * Specifies condition of where clause when creating an audit.
   * @return predicateExpression
   */
  @javax.annotation.Nullable
  public String getPredicateExpression() {
    return predicateExpression;
  }

  public void setPredicateExpression(String predicateExpression) {
    this.predicateExpression = predicateExpression;
  }


  public ExtendedServerBlobAuditingPolicyProperties queueDelayMs(Integer queueDelayMs) {
    this.queueDelayMs = queueDelayMs;
    return this;
  }

  /**
   * Specifies the amount of time in milliseconds that can elapse before audit actions are forced to be processed.  The default minimum value is 1000 (1 second). The maximum is 2,147,483,647.
   * @return queueDelayMs
   */
  @javax.annotation.Nullable
  public Integer getQueueDelayMs() {
    return queueDelayMs;
  }

  public void setQueueDelayMs(Integer queueDelayMs) {
    this.queueDelayMs = queueDelayMs;
  }


  public ExtendedServerBlobAuditingPolicyProperties retentionDays(Integer retentionDays) {
    this.retentionDays = retentionDays;
    return this;
  }

  /**
   * Specifies the number of days to keep in the audit logs in the storage account.
   * @return retentionDays
   */
  @javax.annotation.Nullable
  public Integer getRetentionDays() {
    return retentionDays;
  }

  public void setRetentionDays(Integer retentionDays) {
    this.retentionDays = retentionDays;
  }


  public ExtendedServerBlobAuditingPolicyProperties state(StateEnum state) {
    this.state = state;
    return this;
  }

  /**
   * Specifies the state of the policy. If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled are required.
   * @return state
   */
  @javax.annotation.Nonnull
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }


  public ExtendedServerBlobAuditingPolicyProperties storageAccountAccessKey(String storageAccountAccessKey) {
    this.storageAccountAccessKey = storageAccountAccessKey;
    return this;
  }

  /**
   * Specifies the identifier key of the auditing storage account. If state is Enabled and storageEndpoint is specified, storageAccountAccessKey is required.
   * @return storageAccountAccessKey
   */
  @javax.annotation.Nullable
  public String getStorageAccountAccessKey() {
    return storageAccountAccessKey;
  }

  public void setStorageAccountAccessKey(String storageAccountAccessKey) {
    this.storageAccountAccessKey = storageAccountAccessKey;
  }


  public ExtendedServerBlobAuditingPolicyProperties storageAccountSubscriptionId(UUID storageAccountSubscriptionId) {
    this.storageAccountSubscriptionId = storageAccountSubscriptionId;
    return this;
  }

  /**
   * Specifies the blob storage subscription Id.
   * @return storageAccountSubscriptionId
   */
  @javax.annotation.Nullable
  public UUID getStorageAccountSubscriptionId() {
    return storageAccountSubscriptionId;
  }

  public void setStorageAccountSubscriptionId(UUID storageAccountSubscriptionId) {
    this.storageAccountSubscriptionId = storageAccountSubscriptionId;
  }


  public ExtendedServerBlobAuditingPolicyProperties storageEndpoint(String storageEndpoint) {
    this.storageEndpoint = storageEndpoint;
    return this;
  }

  /**
   * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). If state is Enabled, storageEndpoint or isAzureMonitorTargetEnabled is required.
   * @return storageEndpoint
   */
  @javax.annotation.Nullable
  public String getStorageEndpoint() {
    return storageEndpoint;
  }

  public void setStorageEndpoint(String storageEndpoint) {
    this.storageEndpoint = storageEndpoint;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExtendedServerBlobAuditingPolicyProperties extendedServerBlobAuditingPolicyProperties = (ExtendedServerBlobAuditingPolicyProperties) o;
    return Objects.equals(this.auditActionsAndGroups, extendedServerBlobAuditingPolicyProperties.auditActionsAndGroups) &&
        Objects.equals(this.isAzureMonitorTargetEnabled, extendedServerBlobAuditingPolicyProperties.isAzureMonitorTargetEnabled) &&
        Objects.equals(this.isStorageSecondaryKeyInUse, extendedServerBlobAuditingPolicyProperties.isStorageSecondaryKeyInUse) &&
        Objects.equals(this.predicateExpression, extendedServerBlobAuditingPolicyProperties.predicateExpression) &&
        Objects.equals(this.queueDelayMs, extendedServerBlobAuditingPolicyProperties.queueDelayMs) &&
        Objects.equals(this.retentionDays, extendedServerBlobAuditingPolicyProperties.retentionDays) &&
        Objects.equals(this.state, extendedServerBlobAuditingPolicyProperties.state) &&
        Objects.equals(this.storageAccountAccessKey, extendedServerBlobAuditingPolicyProperties.storageAccountAccessKey) &&
        Objects.equals(this.storageAccountSubscriptionId, extendedServerBlobAuditingPolicyProperties.storageAccountSubscriptionId) &&
        Objects.equals(this.storageEndpoint, extendedServerBlobAuditingPolicyProperties.storageEndpoint);
  }

  @Override
  public int hashCode() {
    return Objects.hash(auditActionsAndGroups, isAzureMonitorTargetEnabled, isStorageSecondaryKeyInUse, predicateExpression, queueDelayMs, retentionDays, state, storageAccountAccessKey, storageAccountSubscriptionId, storageEndpoint);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExtendedServerBlobAuditingPolicyProperties {\n");
    sb.append("    auditActionsAndGroups: ").append(toIndentedString(auditActionsAndGroups)).append("\n");
    sb.append("    isAzureMonitorTargetEnabled: ").append(toIndentedString(isAzureMonitorTargetEnabled)).append("\n");
    sb.append("    isStorageSecondaryKeyInUse: ").append(toIndentedString(isStorageSecondaryKeyInUse)).append("\n");
    sb.append("    predicateExpression: ").append(toIndentedString(predicateExpression)).append("\n");
    sb.append("    queueDelayMs: ").append(toIndentedString(queueDelayMs)).append("\n");
    sb.append("    retentionDays: ").append(toIndentedString(retentionDays)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    storageAccountAccessKey: ").append(toIndentedString(storageAccountAccessKey)).append("\n");
    sb.append("    storageAccountSubscriptionId: ").append(toIndentedString(storageAccountSubscriptionId)).append("\n");
    sb.append("    storageEndpoint: ").append(toIndentedString(storageEndpoint)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("auditActionsAndGroups");
    openapiFields.add("isAzureMonitorTargetEnabled");
    openapiFields.add("isStorageSecondaryKeyInUse");
    openapiFields.add("predicateExpression");
    openapiFields.add("queueDelayMs");
    openapiFields.add("retentionDays");
    openapiFields.add("state");
    openapiFields.add("storageAccountAccessKey");
    openapiFields.add("storageAccountSubscriptionId");
    openapiFields.add("storageEndpoint");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("state");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExtendedServerBlobAuditingPolicyProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExtendedServerBlobAuditingPolicyProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExtendedServerBlobAuditingPolicyProperties is not found in the empty JSON string", ExtendedServerBlobAuditingPolicyProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExtendedServerBlobAuditingPolicyProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExtendedServerBlobAuditingPolicyProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ExtendedServerBlobAuditingPolicyProperties.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("auditActionsAndGroups") != null && !jsonObj.get("auditActionsAndGroups").isJsonNull() && !jsonObj.get("auditActionsAndGroups").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `auditActionsAndGroups` to be an array in the JSON string but got `%s`", jsonObj.get("auditActionsAndGroups").toString()));
      }
      if ((jsonObj.get("predicateExpression") != null && !jsonObj.get("predicateExpression").isJsonNull()) && !jsonObj.get("predicateExpression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `predicateExpression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("predicateExpression").toString()));
      }
      if (!jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the required field `state`
      StateEnum.validateJsonElement(jsonObj.get("state"));
      if ((jsonObj.get("storageAccountAccessKey") != null && !jsonObj.get("storageAccountAccessKey").isJsonNull()) && !jsonObj.get("storageAccountAccessKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageAccountAccessKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageAccountAccessKey").toString()));
      }
      if ((jsonObj.get("storageAccountSubscriptionId") != null && !jsonObj.get("storageAccountSubscriptionId").isJsonNull()) && !jsonObj.get("storageAccountSubscriptionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageAccountSubscriptionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageAccountSubscriptionId").toString()));
      }
      if ((jsonObj.get("storageEndpoint") != null && !jsonObj.get("storageEndpoint").isJsonNull()) && !jsonObj.get("storageEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageEndpoint").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExtendedServerBlobAuditingPolicyProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExtendedServerBlobAuditingPolicyProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExtendedServerBlobAuditingPolicyProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExtendedServerBlobAuditingPolicyProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<ExtendedServerBlobAuditingPolicyProperties>() {
           @Override
           public void write(JsonWriter out, ExtendedServerBlobAuditingPolicyProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExtendedServerBlobAuditingPolicyProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExtendedServerBlobAuditingPolicyProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExtendedServerBlobAuditingPolicyProperties
   * @throws IOException if the JSON string is invalid with respect to ExtendedServerBlobAuditingPolicyProperties
   */
  public static ExtendedServerBlobAuditingPolicyProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExtendedServerBlobAuditingPolicyProperties.class);
  }

  /**
   * Convert an instance of ExtendedServerBlobAuditingPolicyProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

