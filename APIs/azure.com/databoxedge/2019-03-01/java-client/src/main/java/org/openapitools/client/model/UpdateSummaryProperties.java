/*
 * DataBoxEdgeManagementClient
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2019-03-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The device update information summary.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:09:21.318256-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateSummaryProperties {
  public static final String SERIALIZED_NAME_DEVICE_LAST_SCANNED_DATE_TIME = "deviceLastScannedDateTime";
  @SerializedName(SERIALIZED_NAME_DEVICE_LAST_SCANNED_DATE_TIME)
  private OffsetDateTime deviceLastScannedDateTime;

  public static final String SERIALIZED_NAME_DEVICE_VERSION_NUMBER = "deviceVersionNumber";
  @SerializedName(SERIALIZED_NAME_DEVICE_VERSION_NUMBER)
  private String deviceVersionNumber;

  public static final String SERIALIZED_NAME_FRIENDLY_DEVICE_VERSION_NAME = "friendlyDeviceVersionName";
  @SerializedName(SERIALIZED_NAME_FRIENDLY_DEVICE_VERSION_NAME)
  private String friendlyDeviceVersionName;

  public static final String SERIALIZED_NAME_IN_PROGRESS_DOWNLOAD_JOB_ID = "inProgressDownloadJobId";
  @SerializedName(SERIALIZED_NAME_IN_PROGRESS_DOWNLOAD_JOB_ID)
  private String inProgressDownloadJobId;

  public static final String SERIALIZED_NAME_IN_PROGRESS_DOWNLOAD_JOB_STARTED_DATE_TIME = "inProgressDownloadJobStartedDateTime";
  @SerializedName(SERIALIZED_NAME_IN_PROGRESS_DOWNLOAD_JOB_STARTED_DATE_TIME)
  private OffsetDateTime inProgressDownloadJobStartedDateTime;

  public static final String SERIALIZED_NAME_IN_PROGRESS_INSTALL_JOB_ID = "inProgressInstallJobId";
  @SerializedName(SERIALIZED_NAME_IN_PROGRESS_INSTALL_JOB_ID)
  private String inProgressInstallJobId;

  public static final String SERIALIZED_NAME_IN_PROGRESS_INSTALL_JOB_STARTED_DATE_TIME = "inProgressInstallJobStartedDateTime";
  @SerializedName(SERIALIZED_NAME_IN_PROGRESS_INSTALL_JOB_STARTED_DATE_TIME)
  private OffsetDateTime inProgressInstallJobStartedDateTime;

  public static final String SERIALIZED_NAME_LAST_COMPLETED_DOWNLOAD_JOB_DATE_TIME = "lastCompletedDownloadJobDateTime";
  @SerializedName(SERIALIZED_NAME_LAST_COMPLETED_DOWNLOAD_JOB_DATE_TIME)
  private OffsetDateTime lastCompletedDownloadJobDateTime;

  public static final String SERIALIZED_NAME_LAST_COMPLETED_INSTALL_JOB_DATE_TIME = "lastCompletedInstallJobDateTime";
  @SerializedName(SERIALIZED_NAME_LAST_COMPLETED_INSTALL_JOB_DATE_TIME)
  private OffsetDateTime lastCompletedInstallJobDateTime;

  public static final String SERIALIZED_NAME_LAST_COMPLETED_SCAN_JOB_DATE_TIME = "lastCompletedScanJobDateTime";
  @SerializedName(SERIALIZED_NAME_LAST_COMPLETED_SCAN_JOB_DATE_TIME)
  private OffsetDateTime lastCompletedScanJobDateTime;

  /**
   * The current update operation.
   */
  @JsonAdapter(OngoingUpdateOperationEnum.Adapter.class)
  public enum OngoingUpdateOperationEnum {
    NONE("None"),
    
    SCAN("Scan"),
    
    DOWNLOAD("Download"),
    
    INSTALL("Install");

    private String value;

    OngoingUpdateOperationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OngoingUpdateOperationEnum fromValue(String value) {
      for (OngoingUpdateOperationEnum b : OngoingUpdateOperationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OngoingUpdateOperationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OngoingUpdateOperationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OngoingUpdateOperationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OngoingUpdateOperationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OngoingUpdateOperationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ONGOING_UPDATE_OPERATION = "ongoingUpdateOperation";
  @SerializedName(SERIALIZED_NAME_ONGOING_UPDATE_OPERATION)
  private OngoingUpdateOperationEnum ongoingUpdateOperation;

  /**
   * Indicates if updates are available and at least one of the updates needs a reboot.
   */
  @JsonAdapter(RebootBehaviorEnum.Adapter.class)
  public enum RebootBehaviorEnum {
    NEVER_REBOOTS("NeverReboots"),
    
    REQUIRES_REBOOT("RequiresReboot"),
    
    REQUEST_REBOOT("RequestReboot");

    private String value;

    RebootBehaviorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RebootBehaviorEnum fromValue(String value) {
      for (RebootBehaviorEnum b : RebootBehaviorEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RebootBehaviorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RebootBehaviorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RebootBehaviorEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RebootBehaviorEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RebootBehaviorEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REBOOT_BEHAVIOR = "rebootBehavior";
  @SerializedName(SERIALIZED_NAME_REBOOT_BEHAVIOR)
  private RebootBehaviorEnum rebootBehavior;

  public static final String SERIALIZED_NAME_TOTAL_NUMBER_OF_UPDATES_AVAILABLE = "totalNumberOfUpdatesAvailable";
  @SerializedName(SERIALIZED_NAME_TOTAL_NUMBER_OF_UPDATES_AVAILABLE)
  private Integer totalNumberOfUpdatesAvailable;

  public static final String SERIALIZED_NAME_TOTAL_NUMBER_OF_UPDATES_PENDING_DOWNLOAD = "totalNumberOfUpdatesPendingDownload";
  @SerializedName(SERIALIZED_NAME_TOTAL_NUMBER_OF_UPDATES_PENDING_DOWNLOAD)
  private Integer totalNumberOfUpdatesPendingDownload;

  public static final String SERIALIZED_NAME_TOTAL_NUMBER_OF_UPDATES_PENDING_INSTALL = "totalNumberOfUpdatesPendingInstall";
  @SerializedName(SERIALIZED_NAME_TOTAL_NUMBER_OF_UPDATES_PENDING_INSTALL)
  private Integer totalNumberOfUpdatesPendingInstall;

  public static final String SERIALIZED_NAME_TOTAL_UPDATE_SIZE_IN_BYTES = "totalUpdateSizeInBytes";
  @SerializedName(SERIALIZED_NAME_TOTAL_UPDATE_SIZE_IN_BYTES)
  private Double totalUpdateSizeInBytes;

  public static final String SERIALIZED_NAME_UPDATE_TITLES = "updateTitles";
  @SerializedName(SERIALIZED_NAME_UPDATE_TITLES)
  private List<String> updateTitles = new ArrayList<>();

  public UpdateSummaryProperties() {
  }

  public UpdateSummaryProperties(
     String inProgressDownloadJobId, 
     OffsetDateTime inProgressDownloadJobStartedDateTime, 
     String inProgressInstallJobId, 
     OffsetDateTime inProgressInstallJobStartedDateTime, 
     OffsetDateTime lastCompletedDownloadJobDateTime, 
     OffsetDateTime lastCompletedInstallJobDateTime, 
     OngoingUpdateOperationEnum ongoingUpdateOperation, 
     RebootBehaviorEnum rebootBehavior, 
     Integer totalNumberOfUpdatesAvailable, 
     Integer totalNumberOfUpdatesPendingDownload, 
     Integer totalNumberOfUpdatesPendingInstall, 
     Double totalUpdateSizeInBytes, 
     List<String> updateTitles
  ) {
    this();
    this.inProgressDownloadJobId = inProgressDownloadJobId;
    this.inProgressDownloadJobStartedDateTime = inProgressDownloadJobStartedDateTime;
    this.inProgressInstallJobId = inProgressInstallJobId;
    this.inProgressInstallJobStartedDateTime = inProgressInstallJobStartedDateTime;
    this.lastCompletedDownloadJobDateTime = lastCompletedDownloadJobDateTime;
    this.lastCompletedInstallJobDateTime = lastCompletedInstallJobDateTime;
    this.ongoingUpdateOperation = ongoingUpdateOperation;
    this.rebootBehavior = rebootBehavior;
    this.totalNumberOfUpdatesAvailable = totalNumberOfUpdatesAvailable;
    this.totalNumberOfUpdatesPendingDownload = totalNumberOfUpdatesPendingDownload;
    this.totalNumberOfUpdatesPendingInstall = totalNumberOfUpdatesPendingInstall;
    this.totalUpdateSizeInBytes = totalUpdateSizeInBytes;
    this.updateTitles = updateTitles;
  }

  public UpdateSummaryProperties deviceLastScannedDateTime(OffsetDateTime deviceLastScannedDateTime) {
    this.deviceLastScannedDateTime = deviceLastScannedDateTime;
    return this;
  }

  /**
   * The last time when a scan was done on the device.
   * @return deviceLastScannedDateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDeviceLastScannedDateTime() {
    return deviceLastScannedDateTime;
  }

  public void setDeviceLastScannedDateTime(OffsetDateTime deviceLastScannedDateTime) {
    this.deviceLastScannedDateTime = deviceLastScannedDateTime;
  }


  public UpdateSummaryProperties deviceVersionNumber(String deviceVersionNumber) {
    this.deviceVersionNumber = deviceVersionNumber;
    return this;
  }

  /**
   * The current version of the device in format: 1.2.17312.13.\&quot;,
   * @return deviceVersionNumber
   */
  @javax.annotation.Nullable
  public String getDeviceVersionNumber() {
    return deviceVersionNumber;
  }

  public void setDeviceVersionNumber(String deviceVersionNumber) {
    this.deviceVersionNumber = deviceVersionNumber;
  }


  public UpdateSummaryProperties friendlyDeviceVersionName(String friendlyDeviceVersionName) {
    this.friendlyDeviceVersionName = friendlyDeviceVersionName;
    return this;
  }

  /**
   * The current version of the device in text format.
   * @return friendlyDeviceVersionName
   */
  @javax.annotation.Nullable
  public String getFriendlyDeviceVersionName() {
    return friendlyDeviceVersionName;
  }

  public void setFriendlyDeviceVersionName(String friendlyDeviceVersionName) {
    this.friendlyDeviceVersionName = friendlyDeviceVersionName;
  }


  /**
   * The job ID of the download job in progress.
   * @return inProgressDownloadJobId
   */
  @javax.annotation.Nullable
  public String getInProgressDownloadJobId() {
    return inProgressDownloadJobId;
  }



  /**
   * The time when the currently running download (if any) started.
   * @return inProgressDownloadJobStartedDateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getInProgressDownloadJobStartedDateTime() {
    return inProgressDownloadJobStartedDateTime;
  }



  /**
   * The job ID of the install job in progress.
   * @return inProgressInstallJobId
   */
  @javax.annotation.Nullable
  public String getInProgressInstallJobId() {
    return inProgressInstallJobId;
  }



  /**
   * The time when the currently running install (if any) started.
   * @return inProgressInstallJobStartedDateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getInProgressInstallJobStartedDateTime() {
    return inProgressInstallJobStartedDateTime;
  }



  /**
   * The time when the last Download job was completed (success/cancelled/failed) on the appliance.
   * @return lastCompletedDownloadJobDateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastCompletedDownloadJobDateTime() {
    return lastCompletedDownloadJobDateTime;
  }



  /**
   * The time when the last Install job was completed (success/cancelled/failed) on the appliance.
   * @return lastCompletedInstallJobDateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastCompletedInstallJobDateTime() {
    return lastCompletedInstallJobDateTime;
  }



  public UpdateSummaryProperties lastCompletedScanJobDateTime(OffsetDateTime lastCompletedScanJobDateTime) {
    this.lastCompletedScanJobDateTime = lastCompletedScanJobDateTime;
    return this;
  }

  /**
   * The time when the last scan job was completed (success/cancelled/failed) on the appliance.
   * @return lastCompletedScanJobDateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastCompletedScanJobDateTime() {
    return lastCompletedScanJobDateTime;
  }

  public void setLastCompletedScanJobDateTime(OffsetDateTime lastCompletedScanJobDateTime) {
    this.lastCompletedScanJobDateTime = lastCompletedScanJobDateTime;
  }


  /**
   * The current update operation.
   * @return ongoingUpdateOperation
   */
  @javax.annotation.Nullable
  public OngoingUpdateOperationEnum getOngoingUpdateOperation() {
    return ongoingUpdateOperation;
  }



  /**
   * Indicates if updates are available and at least one of the updates needs a reboot.
   * @return rebootBehavior
   */
  @javax.annotation.Nullable
  public RebootBehaviorEnum getRebootBehavior() {
    return rebootBehavior;
  }



  /**
   * The number of updates available for the current device version as per the last device scan.
   * @return totalNumberOfUpdatesAvailable
   */
  @javax.annotation.Nullable
  public Integer getTotalNumberOfUpdatesAvailable() {
    return totalNumberOfUpdatesAvailable;
  }



  /**
   * The total number of items pending download.
   * @return totalNumberOfUpdatesPendingDownload
   */
  @javax.annotation.Nullable
  public Integer getTotalNumberOfUpdatesPendingDownload() {
    return totalNumberOfUpdatesPendingDownload;
  }



  /**
   * The total number of items pending install.
   * @return totalNumberOfUpdatesPendingInstall
   */
  @javax.annotation.Nullable
  public Integer getTotalNumberOfUpdatesPendingInstall() {
    return totalNumberOfUpdatesPendingInstall;
  }



  /**
   * The total size of updates available for download in bytes.
   * @return totalUpdateSizeInBytes
   */
  @javax.annotation.Nullable
  public Double getTotalUpdateSizeInBytes() {
    return totalUpdateSizeInBytes;
  }



  /**
   * The list of updates available for install.
   * @return updateTitles
   */
  @javax.annotation.Nullable
  public List<String> getUpdateTitles() {
    return updateTitles;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateSummaryProperties updateSummaryProperties = (UpdateSummaryProperties) o;
    return Objects.equals(this.deviceLastScannedDateTime, updateSummaryProperties.deviceLastScannedDateTime) &&
        Objects.equals(this.deviceVersionNumber, updateSummaryProperties.deviceVersionNumber) &&
        Objects.equals(this.friendlyDeviceVersionName, updateSummaryProperties.friendlyDeviceVersionName) &&
        Objects.equals(this.inProgressDownloadJobId, updateSummaryProperties.inProgressDownloadJobId) &&
        Objects.equals(this.inProgressDownloadJobStartedDateTime, updateSummaryProperties.inProgressDownloadJobStartedDateTime) &&
        Objects.equals(this.inProgressInstallJobId, updateSummaryProperties.inProgressInstallJobId) &&
        Objects.equals(this.inProgressInstallJobStartedDateTime, updateSummaryProperties.inProgressInstallJobStartedDateTime) &&
        Objects.equals(this.lastCompletedDownloadJobDateTime, updateSummaryProperties.lastCompletedDownloadJobDateTime) &&
        Objects.equals(this.lastCompletedInstallJobDateTime, updateSummaryProperties.lastCompletedInstallJobDateTime) &&
        Objects.equals(this.lastCompletedScanJobDateTime, updateSummaryProperties.lastCompletedScanJobDateTime) &&
        Objects.equals(this.ongoingUpdateOperation, updateSummaryProperties.ongoingUpdateOperation) &&
        Objects.equals(this.rebootBehavior, updateSummaryProperties.rebootBehavior) &&
        Objects.equals(this.totalNumberOfUpdatesAvailable, updateSummaryProperties.totalNumberOfUpdatesAvailable) &&
        Objects.equals(this.totalNumberOfUpdatesPendingDownload, updateSummaryProperties.totalNumberOfUpdatesPendingDownload) &&
        Objects.equals(this.totalNumberOfUpdatesPendingInstall, updateSummaryProperties.totalNumberOfUpdatesPendingInstall) &&
        Objects.equals(this.totalUpdateSizeInBytes, updateSummaryProperties.totalUpdateSizeInBytes) &&
        Objects.equals(this.updateTitles, updateSummaryProperties.updateTitles);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deviceLastScannedDateTime, deviceVersionNumber, friendlyDeviceVersionName, inProgressDownloadJobId, inProgressDownloadJobStartedDateTime, inProgressInstallJobId, inProgressInstallJobStartedDateTime, lastCompletedDownloadJobDateTime, lastCompletedInstallJobDateTime, lastCompletedScanJobDateTime, ongoingUpdateOperation, rebootBehavior, totalNumberOfUpdatesAvailable, totalNumberOfUpdatesPendingDownload, totalNumberOfUpdatesPendingInstall, totalUpdateSizeInBytes, updateTitles);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateSummaryProperties {\n");
    sb.append("    deviceLastScannedDateTime: ").append(toIndentedString(deviceLastScannedDateTime)).append("\n");
    sb.append("    deviceVersionNumber: ").append(toIndentedString(deviceVersionNumber)).append("\n");
    sb.append("    friendlyDeviceVersionName: ").append(toIndentedString(friendlyDeviceVersionName)).append("\n");
    sb.append("    inProgressDownloadJobId: ").append(toIndentedString(inProgressDownloadJobId)).append("\n");
    sb.append("    inProgressDownloadJobStartedDateTime: ").append(toIndentedString(inProgressDownloadJobStartedDateTime)).append("\n");
    sb.append("    inProgressInstallJobId: ").append(toIndentedString(inProgressInstallJobId)).append("\n");
    sb.append("    inProgressInstallJobStartedDateTime: ").append(toIndentedString(inProgressInstallJobStartedDateTime)).append("\n");
    sb.append("    lastCompletedDownloadJobDateTime: ").append(toIndentedString(lastCompletedDownloadJobDateTime)).append("\n");
    sb.append("    lastCompletedInstallJobDateTime: ").append(toIndentedString(lastCompletedInstallJobDateTime)).append("\n");
    sb.append("    lastCompletedScanJobDateTime: ").append(toIndentedString(lastCompletedScanJobDateTime)).append("\n");
    sb.append("    ongoingUpdateOperation: ").append(toIndentedString(ongoingUpdateOperation)).append("\n");
    sb.append("    rebootBehavior: ").append(toIndentedString(rebootBehavior)).append("\n");
    sb.append("    totalNumberOfUpdatesAvailable: ").append(toIndentedString(totalNumberOfUpdatesAvailable)).append("\n");
    sb.append("    totalNumberOfUpdatesPendingDownload: ").append(toIndentedString(totalNumberOfUpdatesPendingDownload)).append("\n");
    sb.append("    totalNumberOfUpdatesPendingInstall: ").append(toIndentedString(totalNumberOfUpdatesPendingInstall)).append("\n");
    sb.append("    totalUpdateSizeInBytes: ").append(toIndentedString(totalUpdateSizeInBytes)).append("\n");
    sb.append("    updateTitles: ").append(toIndentedString(updateTitles)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("deviceLastScannedDateTime");
    openapiFields.add("deviceVersionNumber");
    openapiFields.add("friendlyDeviceVersionName");
    openapiFields.add("inProgressDownloadJobId");
    openapiFields.add("inProgressDownloadJobStartedDateTime");
    openapiFields.add("inProgressInstallJobId");
    openapiFields.add("inProgressInstallJobStartedDateTime");
    openapiFields.add("lastCompletedDownloadJobDateTime");
    openapiFields.add("lastCompletedInstallJobDateTime");
    openapiFields.add("lastCompletedScanJobDateTime");
    openapiFields.add("ongoingUpdateOperation");
    openapiFields.add("rebootBehavior");
    openapiFields.add("totalNumberOfUpdatesAvailable");
    openapiFields.add("totalNumberOfUpdatesPendingDownload");
    openapiFields.add("totalNumberOfUpdatesPendingInstall");
    openapiFields.add("totalUpdateSizeInBytes");
    openapiFields.add("updateTitles");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateSummaryProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateSummaryProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateSummaryProperties is not found in the empty JSON string", UpdateSummaryProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateSummaryProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateSummaryProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("deviceVersionNumber") != null && !jsonObj.get("deviceVersionNumber").isJsonNull()) && !jsonObj.get("deviceVersionNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceVersionNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceVersionNumber").toString()));
      }
      if ((jsonObj.get("friendlyDeviceVersionName") != null && !jsonObj.get("friendlyDeviceVersionName").isJsonNull()) && !jsonObj.get("friendlyDeviceVersionName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `friendlyDeviceVersionName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("friendlyDeviceVersionName").toString()));
      }
      if ((jsonObj.get("inProgressDownloadJobId") != null && !jsonObj.get("inProgressDownloadJobId").isJsonNull()) && !jsonObj.get("inProgressDownloadJobId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inProgressDownloadJobId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inProgressDownloadJobId").toString()));
      }
      if ((jsonObj.get("inProgressInstallJobId") != null && !jsonObj.get("inProgressInstallJobId").isJsonNull()) && !jsonObj.get("inProgressInstallJobId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inProgressInstallJobId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inProgressInstallJobId").toString()));
      }
      if ((jsonObj.get("ongoingUpdateOperation") != null && !jsonObj.get("ongoingUpdateOperation").isJsonNull()) && !jsonObj.get("ongoingUpdateOperation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ongoingUpdateOperation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ongoingUpdateOperation").toString()));
      }
      // validate the optional field `ongoingUpdateOperation`
      if (jsonObj.get("ongoingUpdateOperation") != null && !jsonObj.get("ongoingUpdateOperation").isJsonNull()) {
        OngoingUpdateOperationEnum.validateJsonElement(jsonObj.get("ongoingUpdateOperation"));
      }
      if ((jsonObj.get("rebootBehavior") != null && !jsonObj.get("rebootBehavior").isJsonNull()) && !jsonObj.get("rebootBehavior").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rebootBehavior` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rebootBehavior").toString()));
      }
      // validate the optional field `rebootBehavior`
      if (jsonObj.get("rebootBehavior") != null && !jsonObj.get("rebootBehavior").isJsonNull()) {
        RebootBehaviorEnum.validateJsonElement(jsonObj.get("rebootBehavior"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("updateTitles") != null && !jsonObj.get("updateTitles").isJsonNull() && !jsonObj.get("updateTitles").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTitles` to be an array in the JSON string but got `%s`", jsonObj.get("updateTitles").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateSummaryProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateSummaryProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateSummaryProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateSummaryProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateSummaryProperties>() {
           @Override
           public void write(JsonWriter out, UpdateSummaryProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateSummaryProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateSummaryProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateSummaryProperties
   * @throws IOException if the JSON string is invalid with respect to UpdateSummaryProperties
   */
  public static UpdateSummaryProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateSummaryProperties.class);
  }

  /**
   * Convert an instance of UpdateSummaryProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

