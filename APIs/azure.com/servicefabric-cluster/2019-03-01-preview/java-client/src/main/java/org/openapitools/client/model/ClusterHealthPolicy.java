/*
 * ServiceFabricManagementClient
 * Azure Service Fabric Resource Provider API Client
 *
 * The version of the OpenAPI document: 2019-03-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.ApplicationHealthPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines a health policy used to evaluate the health of the cluster or of a cluster node. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:03:56.637978-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ClusterHealthPolicy {
  public static final String SERIALIZED_NAME_APPLICATION_HEALTH_POLICIES = "applicationHealthPolicies";
  @SerializedName(SERIALIZED_NAME_APPLICATION_HEALTH_POLICIES)
  private Map<String, ApplicationHealthPolicy> applicationHealthPolicies = new HashMap<>();

  public static final String SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_APPLICATIONS = "maxPercentUnhealthyApplications";
  @SerializedName(SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_APPLICATIONS)
  private Integer maxPercentUnhealthyApplications;

  public static final String SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_NODES = "maxPercentUnhealthyNodes";
  @SerializedName(SERIALIZED_NAME_MAX_PERCENT_UNHEALTHY_NODES)
  private Integer maxPercentUnhealthyNodes;

  public ClusterHealthPolicy() {
  }

  public ClusterHealthPolicy applicationHealthPolicies(Map<String, ApplicationHealthPolicy> applicationHealthPolicies) {
    this.applicationHealthPolicies = applicationHealthPolicies;
    return this;
  }

  public ClusterHealthPolicy putApplicationHealthPoliciesItem(String key, ApplicationHealthPolicy applicationHealthPoliciesItem) {
    if (this.applicationHealthPolicies == null) {
      this.applicationHealthPolicies = new HashMap<>();
    }
    this.applicationHealthPolicies.put(key, applicationHealthPoliciesItem);
    return this;
  }

  /**
   * Defines a map that contains specific application health policies for different applications. Each entry specifies as key the application name and as value an ApplicationHealthPolicy used to evaluate the application health. The application name should include the &#39;fabric:&#39; URI scheme. The map is empty by default. 
   * @return applicationHealthPolicies
   */
  @javax.annotation.Nullable
  public Map<String, ApplicationHealthPolicy> getApplicationHealthPolicies() {
    return applicationHealthPolicies;
  }

  public void setApplicationHealthPolicies(Map<String, ApplicationHealthPolicy> applicationHealthPolicies) {
    this.applicationHealthPolicies = applicationHealthPolicies;
  }


  public ClusterHealthPolicy maxPercentUnhealthyApplications(Integer maxPercentUnhealthyApplications) {
    this.maxPercentUnhealthyApplications = maxPercentUnhealthyApplications;
    return this;
  }

  /**
   * The maximum allowed percentage of unhealthy applications before reporting an error. For example, to allow 10% of applications to be unhealthy, this value would be 10.  The percentage represents the maximum tolerated percentage of applications that can be unhealthy before the cluster is considered in error. If the percentage is respected but there is at least one unhealthy application, the health is evaluated as Warning. This is calculated by dividing the number of unhealthy applications over the total number of application instances in the cluster, excluding applications of application types that are included in the ApplicationTypeHealthPolicyMap. The computation rounds up to tolerate one failure on small numbers of applications. Default percentage is zero. 
   * minimum: 0
   * maximum: 100
   * @return maxPercentUnhealthyApplications
   */
  @javax.annotation.Nullable
  public Integer getMaxPercentUnhealthyApplications() {
    return maxPercentUnhealthyApplications;
  }

  public void setMaxPercentUnhealthyApplications(Integer maxPercentUnhealthyApplications) {
    this.maxPercentUnhealthyApplications = maxPercentUnhealthyApplications;
  }


  public ClusterHealthPolicy maxPercentUnhealthyNodes(Integer maxPercentUnhealthyNodes) {
    this.maxPercentUnhealthyNodes = maxPercentUnhealthyNodes;
    return this;
  }

  /**
   * The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to allow 10% of nodes to be unhealthy, this value would be 10.  The percentage represents the maximum tolerated percentage of nodes that can be unhealthy before the cluster is considered in error. If the percentage is respected but there is at least one unhealthy node, the health is evaluated as Warning. The percentage is calculated by dividing the number of unhealthy nodes over the total number of nodes in the cluster. The computation rounds up to tolerate one failure on small numbers of nodes. Default percentage is zero.  In large clusters, some nodes will always be down or out for repairs, so this percentage should be configured to tolerate that. 
   * minimum: 0
   * maximum: 100
   * @return maxPercentUnhealthyNodes
   */
  @javax.annotation.Nullable
  public Integer getMaxPercentUnhealthyNodes() {
    return maxPercentUnhealthyNodes;
  }

  public void setMaxPercentUnhealthyNodes(Integer maxPercentUnhealthyNodes) {
    this.maxPercentUnhealthyNodes = maxPercentUnhealthyNodes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClusterHealthPolicy clusterHealthPolicy = (ClusterHealthPolicy) o;
    return Objects.equals(this.applicationHealthPolicies, clusterHealthPolicy.applicationHealthPolicies) &&
        Objects.equals(this.maxPercentUnhealthyApplications, clusterHealthPolicy.maxPercentUnhealthyApplications) &&
        Objects.equals(this.maxPercentUnhealthyNodes, clusterHealthPolicy.maxPercentUnhealthyNodes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationHealthPolicies, maxPercentUnhealthyApplications, maxPercentUnhealthyNodes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClusterHealthPolicy {\n");
    sb.append("    applicationHealthPolicies: ").append(toIndentedString(applicationHealthPolicies)).append("\n");
    sb.append("    maxPercentUnhealthyApplications: ").append(toIndentedString(maxPercentUnhealthyApplications)).append("\n");
    sb.append("    maxPercentUnhealthyNodes: ").append(toIndentedString(maxPercentUnhealthyNodes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("applicationHealthPolicies");
    openapiFields.add("maxPercentUnhealthyApplications");
    openapiFields.add("maxPercentUnhealthyNodes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ClusterHealthPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ClusterHealthPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ClusterHealthPolicy is not found in the empty JSON string", ClusterHealthPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ClusterHealthPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ClusterHealthPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ClusterHealthPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ClusterHealthPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ClusterHealthPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ClusterHealthPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<ClusterHealthPolicy>() {
           @Override
           public void write(JsonWriter out, ClusterHealthPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ClusterHealthPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ClusterHealthPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ClusterHealthPolicy
   * @throws IOException if the JSON string is invalid with respect to ClusterHealthPolicy
   */
  public static ClusterHealthPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ClusterHealthPolicy.class);
  }

  /**
   * Convert an instance of ClusterHealthPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

