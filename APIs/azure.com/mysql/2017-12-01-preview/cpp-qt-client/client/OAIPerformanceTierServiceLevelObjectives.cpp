/**
 * MySQLManagementClient
 * The Microsoft Azure management API provides create, read, update, and delete functionality for Azure MySQL resources including servers, databases, firewall rules, VNET rules, log files and configurations with new business model.
 *
 * The version of the OpenAPI document: 2017-12-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPerformanceTierServiceLevelObjectives.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPerformanceTierServiceLevelObjectives::OAIPerformanceTierServiceLevelObjectives(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPerformanceTierServiceLevelObjectives::OAIPerformanceTierServiceLevelObjectives() {
    this->initializeModel();
}

OAIPerformanceTierServiceLevelObjectives::~OAIPerformanceTierServiceLevelObjectives() {}

void OAIPerformanceTierServiceLevelObjectives::initializeModel() {

    m_edition_isSet = false;
    m_edition_isValid = false;

    m_hardware_generation_isSet = false;
    m_hardware_generation_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_max_backup_retention_days_isSet = false;
    m_max_backup_retention_days_isValid = false;

    m_max_storage_mb_isSet = false;
    m_max_storage_mb_isValid = false;

    m_min_backup_retention_days_isSet = false;
    m_min_backup_retention_days_isValid = false;

    m_min_storage_mb_isSet = false;
    m_min_storage_mb_isValid = false;

    m_v_core_isSet = false;
    m_v_core_isValid = false;
}

void OAIPerformanceTierServiceLevelObjectives::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPerformanceTierServiceLevelObjectives::fromJsonObject(QJsonObject json) {

    m_edition_isValid = ::OpenAPI::fromJsonValue(m_edition, json[QString("edition")]);
    m_edition_isSet = !json[QString("edition")].isNull() && m_edition_isValid;

    m_hardware_generation_isValid = ::OpenAPI::fromJsonValue(m_hardware_generation, json[QString("hardwareGeneration")]);
    m_hardware_generation_isSet = !json[QString("hardwareGeneration")].isNull() && m_hardware_generation_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_max_backup_retention_days_isValid = ::OpenAPI::fromJsonValue(m_max_backup_retention_days, json[QString("maxBackupRetentionDays")]);
    m_max_backup_retention_days_isSet = !json[QString("maxBackupRetentionDays")].isNull() && m_max_backup_retention_days_isValid;

    m_max_storage_mb_isValid = ::OpenAPI::fromJsonValue(m_max_storage_mb, json[QString("maxStorageMB")]);
    m_max_storage_mb_isSet = !json[QString("maxStorageMB")].isNull() && m_max_storage_mb_isValid;

    m_min_backup_retention_days_isValid = ::OpenAPI::fromJsonValue(m_min_backup_retention_days, json[QString("minBackupRetentionDays")]);
    m_min_backup_retention_days_isSet = !json[QString("minBackupRetentionDays")].isNull() && m_min_backup_retention_days_isValid;

    m_min_storage_mb_isValid = ::OpenAPI::fromJsonValue(m_min_storage_mb, json[QString("minStorageMB")]);
    m_min_storage_mb_isSet = !json[QString("minStorageMB")].isNull() && m_min_storage_mb_isValid;

    m_v_core_isValid = ::OpenAPI::fromJsonValue(m_v_core, json[QString("vCore")]);
    m_v_core_isSet = !json[QString("vCore")].isNull() && m_v_core_isValid;
}

QString OAIPerformanceTierServiceLevelObjectives::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPerformanceTierServiceLevelObjectives::asJsonObject() const {
    QJsonObject obj;
    if (m_edition_isSet) {
        obj.insert(QString("edition"), ::OpenAPI::toJsonValue(m_edition));
    }
    if (m_hardware_generation_isSet) {
        obj.insert(QString("hardwareGeneration"), ::OpenAPI::toJsonValue(m_hardware_generation));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_max_backup_retention_days_isSet) {
        obj.insert(QString("maxBackupRetentionDays"), ::OpenAPI::toJsonValue(m_max_backup_retention_days));
    }
    if (m_max_storage_mb_isSet) {
        obj.insert(QString("maxStorageMB"), ::OpenAPI::toJsonValue(m_max_storage_mb));
    }
    if (m_min_backup_retention_days_isSet) {
        obj.insert(QString("minBackupRetentionDays"), ::OpenAPI::toJsonValue(m_min_backup_retention_days));
    }
    if (m_min_storage_mb_isSet) {
        obj.insert(QString("minStorageMB"), ::OpenAPI::toJsonValue(m_min_storage_mb));
    }
    if (m_v_core_isSet) {
        obj.insert(QString("vCore"), ::OpenAPI::toJsonValue(m_v_core));
    }
    return obj;
}

QString OAIPerformanceTierServiceLevelObjectives::getEdition() const {
    return m_edition;
}
void OAIPerformanceTierServiceLevelObjectives::setEdition(const QString &edition) {
    m_edition = edition;
    m_edition_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_edition_Set() const{
    return m_edition_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_edition_Valid() const{
    return m_edition_isValid;
}

QString OAIPerformanceTierServiceLevelObjectives::getHardwareGeneration() const {
    return m_hardware_generation;
}
void OAIPerformanceTierServiceLevelObjectives::setHardwareGeneration(const QString &hardware_generation) {
    m_hardware_generation = hardware_generation;
    m_hardware_generation_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_hardware_generation_Set() const{
    return m_hardware_generation_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_hardware_generation_Valid() const{
    return m_hardware_generation_isValid;
}

QString OAIPerformanceTierServiceLevelObjectives::getId() const {
    return m_id;
}
void OAIPerformanceTierServiceLevelObjectives::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_id_Set() const{
    return m_id_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_id_Valid() const{
    return m_id_isValid;
}

qint32 OAIPerformanceTierServiceLevelObjectives::getMaxBackupRetentionDays() const {
    return m_max_backup_retention_days;
}
void OAIPerformanceTierServiceLevelObjectives::setMaxBackupRetentionDays(const qint32 &max_backup_retention_days) {
    m_max_backup_retention_days = max_backup_retention_days;
    m_max_backup_retention_days_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_max_backup_retention_days_Set() const{
    return m_max_backup_retention_days_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_max_backup_retention_days_Valid() const{
    return m_max_backup_retention_days_isValid;
}

qint32 OAIPerformanceTierServiceLevelObjectives::getMaxStorageMb() const {
    return m_max_storage_mb;
}
void OAIPerformanceTierServiceLevelObjectives::setMaxStorageMb(const qint32 &max_storage_mb) {
    m_max_storage_mb = max_storage_mb;
    m_max_storage_mb_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_max_storage_mb_Set() const{
    return m_max_storage_mb_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_max_storage_mb_Valid() const{
    return m_max_storage_mb_isValid;
}

qint32 OAIPerformanceTierServiceLevelObjectives::getMinBackupRetentionDays() const {
    return m_min_backup_retention_days;
}
void OAIPerformanceTierServiceLevelObjectives::setMinBackupRetentionDays(const qint32 &min_backup_retention_days) {
    m_min_backup_retention_days = min_backup_retention_days;
    m_min_backup_retention_days_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_min_backup_retention_days_Set() const{
    return m_min_backup_retention_days_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_min_backup_retention_days_Valid() const{
    return m_min_backup_retention_days_isValid;
}

qint32 OAIPerformanceTierServiceLevelObjectives::getMinStorageMb() const {
    return m_min_storage_mb;
}
void OAIPerformanceTierServiceLevelObjectives::setMinStorageMb(const qint32 &min_storage_mb) {
    m_min_storage_mb = min_storage_mb;
    m_min_storage_mb_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_min_storage_mb_Set() const{
    return m_min_storage_mb_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_min_storage_mb_Valid() const{
    return m_min_storage_mb_isValid;
}

qint32 OAIPerformanceTierServiceLevelObjectives::getVCore() const {
    return m_v_core;
}
void OAIPerformanceTierServiceLevelObjectives::setVCore(const qint32 &v_core) {
    m_v_core = v_core;
    m_v_core_isSet = true;
}

bool OAIPerformanceTierServiceLevelObjectives::is_v_core_Set() const{
    return m_v_core_isSet;
}

bool OAIPerformanceTierServiceLevelObjectives::is_v_core_Valid() const{
    return m_v_core_isValid;
}

bool OAIPerformanceTierServiceLevelObjectives::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_edition_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hardware_generation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_backup_retention_days_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_storage_mb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_backup_retention_days_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_storage_mb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_v_core_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPerformanceTierServiceLevelObjectives::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
