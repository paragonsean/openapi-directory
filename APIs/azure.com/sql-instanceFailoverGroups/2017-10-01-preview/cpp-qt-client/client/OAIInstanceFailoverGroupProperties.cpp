/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2017-10-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIInstanceFailoverGroupProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIInstanceFailoverGroupProperties::OAIInstanceFailoverGroupProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIInstanceFailoverGroupProperties::OAIInstanceFailoverGroupProperties() {
    this->initializeModel();
}

OAIInstanceFailoverGroupProperties::~OAIInstanceFailoverGroupProperties() {}

void OAIInstanceFailoverGroupProperties::initializeModel() {

    m_managed_instance_pairs_isSet = false;
    m_managed_instance_pairs_isValid = false;

    m_partner_regions_isSet = false;
    m_partner_regions_isValid = false;

    m_read_only_endpoint_isSet = false;
    m_read_only_endpoint_isValid = false;

    m_read_write_endpoint_isSet = false;
    m_read_write_endpoint_isValid = false;

    m_replication_role_isSet = false;
    m_replication_role_isValid = false;

    m_replication_state_isSet = false;
    m_replication_state_isValid = false;
}

void OAIInstanceFailoverGroupProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIInstanceFailoverGroupProperties::fromJsonObject(QJsonObject json) {

    m_managed_instance_pairs_isValid = ::OpenAPI::fromJsonValue(m_managed_instance_pairs, json[QString("managedInstancePairs")]);
    m_managed_instance_pairs_isSet = !json[QString("managedInstancePairs")].isNull() && m_managed_instance_pairs_isValid;

    m_partner_regions_isValid = ::OpenAPI::fromJsonValue(m_partner_regions, json[QString("partnerRegions")]);
    m_partner_regions_isSet = !json[QString("partnerRegions")].isNull() && m_partner_regions_isValid;

    m_read_only_endpoint_isValid = ::OpenAPI::fromJsonValue(m_read_only_endpoint, json[QString("readOnlyEndpoint")]);
    m_read_only_endpoint_isSet = !json[QString("readOnlyEndpoint")].isNull() && m_read_only_endpoint_isValid;

    m_read_write_endpoint_isValid = ::OpenAPI::fromJsonValue(m_read_write_endpoint, json[QString("readWriteEndpoint")]);
    m_read_write_endpoint_isSet = !json[QString("readWriteEndpoint")].isNull() && m_read_write_endpoint_isValid;

    m_replication_role_isValid = ::OpenAPI::fromJsonValue(m_replication_role, json[QString("replicationRole")]);
    m_replication_role_isSet = !json[QString("replicationRole")].isNull() && m_replication_role_isValid;

    m_replication_state_isValid = ::OpenAPI::fromJsonValue(m_replication_state, json[QString("replicationState")]);
    m_replication_state_isSet = !json[QString("replicationState")].isNull() && m_replication_state_isValid;
}

QString OAIInstanceFailoverGroupProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIInstanceFailoverGroupProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_managed_instance_pairs.size() > 0) {
        obj.insert(QString("managedInstancePairs"), ::OpenAPI::toJsonValue(m_managed_instance_pairs));
    }
    if (m_partner_regions.size() > 0) {
        obj.insert(QString("partnerRegions"), ::OpenAPI::toJsonValue(m_partner_regions));
    }
    if (m_read_only_endpoint.isSet()) {
        obj.insert(QString("readOnlyEndpoint"), ::OpenAPI::toJsonValue(m_read_only_endpoint));
    }
    if (m_read_write_endpoint.isSet()) {
        obj.insert(QString("readWriteEndpoint"), ::OpenAPI::toJsonValue(m_read_write_endpoint));
    }
    if (m_replication_role_isSet) {
        obj.insert(QString("replicationRole"), ::OpenAPI::toJsonValue(m_replication_role));
    }
    if (m_replication_state_isSet) {
        obj.insert(QString("replicationState"), ::OpenAPI::toJsonValue(m_replication_state));
    }
    return obj;
}

QList<OAIManagedInstancePairInfo> OAIInstanceFailoverGroupProperties::getManagedInstancePairs() const {
    return m_managed_instance_pairs;
}
void OAIInstanceFailoverGroupProperties::setManagedInstancePairs(const QList<OAIManagedInstancePairInfo> &managed_instance_pairs) {
    m_managed_instance_pairs = managed_instance_pairs;
    m_managed_instance_pairs_isSet = true;
}

bool OAIInstanceFailoverGroupProperties::is_managed_instance_pairs_Set() const{
    return m_managed_instance_pairs_isSet;
}

bool OAIInstanceFailoverGroupProperties::is_managed_instance_pairs_Valid() const{
    return m_managed_instance_pairs_isValid;
}

QList<OAIPartnerRegionInfo> OAIInstanceFailoverGroupProperties::getPartnerRegions() const {
    return m_partner_regions;
}
void OAIInstanceFailoverGroupProperties::setPartnerRegions(const QList<OAIPartnerRegionInfo> &partner_regions) {
    m_partner_regions = partner_regions;
    m_partner_regions_isSet = true;
}

bool OAIInstanceFailoverGroupProperties::is_partner_regions_Set() const{
    return m_partner_regions_isSet;
}

bool OAIInstanceFailoverGroupProperties::is_partner_regions_Valid() const{
    return m_partner_regions_isValid;
}

OAIInstanceFailoverGroupReadOnlyEndpoint OAIInstanceFailoverGroupProperties::getReadOnlyEndpoint() const {
    return m_read_only_endpoint;
}
void OAIInstanceFailoverGroupProperties::setReadOnlyEndpoint(const OAIInstanceFailoverGroupReadOnlyEndpoint &read_only_endpoint) {
    m_read_only_endpoint = read_only_endpoint;
    m_read_only_endpoint_isSet = true;
}

bool OAIInstanceFailoverGroupProperties::is_read_only_endpoint_Set() const{
    return m_read_only_endpoint_isSet;
}

bool OAIInstanceFailoverGroupProperties::is_read_only_endpoint_Valid() const{
    return m_read_only_endpoint_isValid;
}

OAIInstanceFailoverGroupReadWriteEndpoint OAIInstanceFailoverGroupProperties::getReadWriteEndpoint() const {
    return m_read_write_endpoint;
}
void OAIInstanceFailoverGroupProperties::setReadWriteEndpoint(const OAIInstanceFailoverGroupReadWriteEndpoint &read_write_endpoint) {
    m_read_write_endpoint = read_write_endpoint;
    m_read_write_endpoint_isSet = true;
}

bool OAIInstanceFailoverGroupProperties::is_read_write_endpoint_Set() const{
    return m_read_write_endpoint_isSet;
}

bool OAIInstanceFailoverGroupProperties::is_read_write_endpoint_Valid() const{
    return m_read_write_endpoint_isValid;
}

QString OAIInstanceFailoverGroupProperties::getReplicationRole() const {
    return m_replication_role;
}
void OAIInstanceFailoverGroupProperties::setReplicationRole(const QString &replication_role) {
    m_replication_role = replication_role;
    m_replication_role_isSet = true;
}

bool OAIInstanceFailoverGroupProperties::is_replication_role_Set() const{
    return m_replication_role_isSet;
}

bool OAIInstanceFailoverGroupProperties::is_replication_role_Valid() const{
    return m_replication_role_isValid;
}

QString OAIInstanceFailoverGroupProperties::getReplicationState() const {
    return m_replication_state;
}
void OAIInstanceFailoverGroupProperties::setReplicationState(const QString &replication_state) {
    m_replication_state = replication_state;
    m_replication_state_isSet = true;
}

bool OAIInstanceFailoverGroupProperties::is_replication_state_Set() const{
    return m_replication_state_isSet;
}

bool OAIInstanceFailoverGroupProperties::is_replication_state_Valid() const{
    return m_replication_state_isValid;
}

bool OAIInstanceFailoverGroupProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_managed_instance_pairs.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_partner_regions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_only_endpoint.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_write_endpoint.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_replication_role_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_replication_state_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIInstanceFailoverGroupProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_managed_instance_pairs_isValid && m_partner_regions_isValid && m_read_write_endpoint_isValid && true;
}

} // namespace OpenAPI
