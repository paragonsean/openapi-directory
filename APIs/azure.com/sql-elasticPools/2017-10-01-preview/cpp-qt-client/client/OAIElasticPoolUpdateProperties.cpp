/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2017-10-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIElasticPoolUpdateProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIElasticPoolUpdateProperties::OAIElasticPoolUpdateProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIElasticPoolUpdateProperties::OAIElasticPoolUpdateProperties() {
    this->initializeModel();
}

OAIElasticPoolUpdateProperties::~OAIElasticPoolUpdateProperties() {}

void OAIElasticPoolUpdateProperties::initializeModel() {

    m_license_type_isSet = false;
    m_license_type_isValid = false;

    m_max_size_bytes_isSet = false;
    m_max_size_bytes_isValid = false;

    m_per_database_settings_isSet = false;
    m_per_database_settings_isValid = false;

    m_zone_redundant_isSet = false;
    m_zone_redundant_isValid = false;
}

void OAIElasticPoolUpdateProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIElasticPoolUpdateProperties::fromJsonObject(QJsonObject json) {

    m_license_type_isValid = ::OpenAPI::fromJsonValue(m_license_type, json[QString("licenseType")]);
    m_license_type_isSet = !json[QString("licenseType")].isNull() && m_license_type_isValid;

    m_max_size_bytes_isValid = ::OpenAPI::fromJsonValue(m_max_size_bytes, json[QString("maxSizeBytes")]);
    m_max_size_bytes_isSet = !json[QString("maxSizeBytes")].isNull() && m_max_size_bytes_isValid;

    m_per_database_settings_isValid = ::OpenAPI::fromJsonValue(m_per_database_settings, json[QString("perDatabaseSettings")]);
    m_per_database_settings_isSet = !json[QString("perDatabaseSettings")].isNull() && m_per_database_settings_isValid;

    m_zone_redundant_isValid = ::OpenAPI::fromJsonValue(m_zone_redundant, json[QString("zoneRedundant")]);
    m_zone_redundant_isSet = !json[QString("zoneRedundant")].isNull() && m_zone_redundant_isValid;
}

QString OAIElasticPoolUpdateProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIElasticPoolUpdateProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_license_type_isSet) {
        obj.insert(QString("licenseType"), ::OpenAPI::toJsonValue(m_license_type));
    }
    if (m_max_size_bytes_isSet) {
        obj.insert(QString("maxSizeBytes"), ::OpenAPI::toJsonValue(m_max_size_bytes));
    }
    if (m_per_database_settings.isSet()) {
        obj.insert(QString("perDatabaseSettings"), ::OpenAPI::toJsonValue(m_per_database_settings));
    }
    if (m_zone_redundant_isSet) {
        obj.insert(QString("zoneRedundant"), ::OpenAPI::toJsonValue(m_zone_redundant));
    }
    return obj;
}

QString OAIElasticPoolUpdateProperties::getLicenseType() const {
    return m_license_type;
}
void OAIElasticPoolUpdateProperties::setLicenseType(const QString &license_type) {
    m_license_type = license_type;
    m_license_type_isSet = true;
}

bool OAIElasticPoolUpdateProperties::is_license_type_Set() const{
    return m_license_type_isSet;
}

bool OAIElasticPoolUpdateProperties::is_license_type_Valid() const{
    return m_license_type_isValid;
}

qint64 OAIElasticPoolUpdateProperties::getMaxSizeBytes() const {
    return m_max_size_bytes;
}
void OAIElasticPoolUpdateProperties::setMaxSizeBytes(const qint64 &max_size_bytes) {
    m_max_size_bytes = max_size_bytes;
    m_max_size_bytes_isSet = true;
}

bool OAIElasticPoolUpdateProperties::is_max_size_bytes_Set() const{
    return m_max_size_bytes_isSet;
}

bool OAIElasticPoolUpdateProperties::is_max_size_bytes_Valid() const{
    return m_max_size_bytes_isValid;
}

OAIElasticPoolPerDatabaseSettings OAIElasticPoolUpdateProperties::getPerDatabaseSettings() const {
    return m_per_database_settings;
}
void OAIElasticPoolUpdateProperties::setPerDatabaseSettings(const OAIElasticPoolPerDatabaseSettings &per_database_settings) {
    m_per_database_settings = per_database_settings;
    m_per_database_settings_isSet = true;
}

bool OAIElasticPoolUpdateProperties::is_per_database_settings_Set() const{
    return m_per_database_settings_isSet;
}

bool OAIElasticPoolUpdateProperties::is_per_database_settings_Valid() const{
    return m_per_database_settings_isValid;
}

bool OAIElasticPoolUpdateProperties::isZoneRedundant() const {
    return m_zone_redundant;
}
void OAIElasticPoolUpdateProperties::setZoneRedundant(const bool &zone_redundant) {
    m_zone_redundant = zone_redundant;
    m_zone_redundant_isSet = true;
}

bool OAIElasticPoolUpdateProperties::is_zone_redundant_Set() const{
    return m_zone_redundant_isSet;
}

bool OAIElasticPoolUpdateProperties::is_zone_redundant_Valid() const{
    return m_zone_redundant_isValid;
}

bool OAIElasticPoolUpdateProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_license_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_size_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_per_database_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_zone_redundant_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIElasticPoolUpdateProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
