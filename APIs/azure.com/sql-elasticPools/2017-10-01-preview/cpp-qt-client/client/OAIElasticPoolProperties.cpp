/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2017-10-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIElasticPoolProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIElasticPoolProperties::OAIElasticPoolProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIElasticPoolProperties::OAIElasticPoolProperties() {
    this->initializeModel();
}

OAIElasticPoolProperties::~OAIElasticPoolProperties() {}

void OAIElasticPoolProperties::initializeModel() {

    m_creation_date_isSet = false;
    m_creation_date_isValid = false;

    m_license_type_isSet = false;
    m_license_type_isValid = false;

    m_max_size_bytes_isSet = false;
    m_max_size_bytes_isValid = false;

    m_per_database_settings_isSet = false;
    m_per_database_settings_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_zone_redundant_isSet = false;
    m_zone_redundant_isValid = false;
}

void OAIElasticPoolProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIElasticPoolProperties::fromJsonObject(QJsonObject json) {

    m_creation_date_isValid = ::OpenAPI::fromJsonValue(m_creation_date, json[QString("creationDate")]);
    m_creation_date_isSet = !json[QString("creationDate")].isNull() && m_creation_date_isValid;

    m_license_type_isValid = ::OpenAPI::fromJsonValue(m_license_type, json[QString("licenseType")]);
    m_license_type_isSet = !json[QString("licenseType")].isNull() && m_license_type_isValid;

    m_max_size_bytes_isValid = ::OpenAPI::fromJsonValue(m_max_size_bytes, json[QString("maxSizeBytes")]);
    m_max_size_bytes_isSet = !json[QString("maxSizeBytes")].isNull() && m_max_size_bytes_isValid;

    m_per_database_settings_isValid = ::OpenAPI::fromJsonValue(m_per_database_settings, json[QString("perDatabaseSettings")]);
    m_per_database_settings_isSet = !json[QString("perDatabaseSettings")].isNull() && m_per_database_settings_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_zone_redundant_isValid = ::OpenAPI::fromJsonValue(m_zone_redundant, json[QString("zoneRedundant")]);
    m_zone_redundant_isSet = !json[QString("zoneRedundant")].isNull() && m_zone_redundant_isValid;
}

QString OAIElasticPoolProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIElasticPoolProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_creation_date_isSet) {
        obj.insert(QString("creationDate"), ::OpenAPI::toJsonValue(m_creation_date));
    }
    if (m_license_type_isSet) {
        obj.insert(QString("licenseType"), ::OpenAPI::toJsonValue(m_license_type));
    }
    if (m_max_size_bytes_isSet) {
        obj.insert(QString("maxSizeBytes"), ::OpenAPI::toJsonValue(m_max_size_bytes));
    }
    if (m_per_database_settings.isSet()) {
        obj.insert(QString("perDatabaseSettings"), ::OpenAPI::toJsonValue(m_per_database_settings));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_zone_redundant_isSet) {
        obj.insert(QString("zoneRedundant"), ::OpenAPI::toJsonValue(m_zone_redundant));
    }
    return obj;
}

QDateTime OAIElasticPoolProperties::getCreationDate() const {
    return m_creation_date;
}
void OAIElasticPoolProperties::setCreationDate(const QDateTime &creation_date) {
    m_creation_date = creation_date;
    m_creation_date_isSet = true;
}

bool OAIElasticPoolProperties::is_creation_date_Set() const{
    return m_creation_date_isSet;
}

bool OAIElasticPoolProperties::is_creation_date_Valid() const{
    return m_creation_date_isValid;
}

QString OAIElasticPoolProperties::getLicenseType() const {
    return m_license_type;
}
void OAIElasticPoolProperties::setLicenseType(const QString &license_type) {
    m_license_type = license_type;
    m_license_type_isSet = true;
}

bool OAIElasticPoolProperties::is_license_type_Set() const{
    return m_license_type_isSet;
}

bool OAIElasticPoolProperties::is_license_type_Valid() const{
    return m_license_type_isValid;
}

qint64 OAIElasticPoolProperties::getMaxSizeBytes() const {
    return m_max_size_bytes;
}
void OAIElasticPoolProperties::setMaxSizeBytes(const qint64 &max_size_bytes) {
    m_max_size_bytes = max_size_bytes;
    m_max_size_bytes_isSet = true;
}

bool OAIElasticPoolProperties::is_max_size_bytes_Set() const{
    return m_max_size_bytes_isSet;
}

bool OAIElasticPoolProperties::is_max_size_bytes_Valid() const{
    return m_max_size_bytes_isValid;
}

OAIElasticPoolPerDatabaseSettings OAIElasticPoolProperties::getPerDatabaseSettings() const {
    return m_per_database_settings;
}
void OAIElasticPoolProperties::setPerDatabaseSettings(const OAIElasticPoolPerDatabaseSettings &per_database_settings) {
    m_per_database_settings = per_database_settings;
    m_per_database_settings_isSet = true;
}

bool OAIElasticPoolProperties::is_per_database_settings_Set() const{
    return m_per_database_settings_isSet;
}

bool OAIElasticPoolProperties::is_per_database_settings_Valid() const{
    return m_per_database_settings_isValid;
}

QString OAIElasticPoolProperties::getState() const {
    return m_state;
}
void OAIElasticPoolProperties::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIElasticPoolProperties::is_state_Set() const{
    return m_state_isSet;
}

bool OAIElasticPoolProperties::is_state_Valid() const{
    return m_state_isValid;
}

bool OAIElasticPoolProperties::isZoneRedundant() const {
    return m_zone_redundant;
}
void OAIElasticPoolProperties::setZoneRedundant(const bool &zone_redundant) {
    m_zone_redundant = zone_redundant;
    m_zone_redundant_isSet = true;
}

bool OAIElasticPoolProperties::is_zone_redundant_Set() const{
    return m_zone_redundant_isSet;
}

bool OAIElasticPoolProperties::is_zone_redundant_Valid() const{
    return m_zone_redundant_isValid;
}

bool OAIElasticPoolProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_creation_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_license_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_size_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_per_database_settings.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_zone_redundant_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIElasticPoolProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
