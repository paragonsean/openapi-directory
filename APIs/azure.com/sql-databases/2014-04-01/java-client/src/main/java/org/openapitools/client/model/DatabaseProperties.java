/*
 * Azure SQL Database
 * Provides create, read, update and delete functionality for Azure SQL Databases.
 *
 * The version of the OpenAPI document: 2014-04-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.openapitools.client.model.DatabasePropertiesRecommendedIndexInner;
import org.openapitools.client.model.DatabasePropertiesServiceTierAdvisorsInner;
import org.openapitools.client.model.DatabasePropertiesTransparentDataEncryptionInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the properties of a database.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:37:11.908779-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DatabaseProperties {
  public static final String SERIALIZED_NAME_COLLATION = "collation";
  @SerializedName(SERIALIZED_NAME_COLLATION)
  private String collation;

  public static final String SERIALIZED_NAME_CONTAINMENT_STATE = "containmentState";
  @SerializedName(SERIALIZED_NAME_CONTAINMENT_STATE)
  private Long containmentState;

  /**
   * Specifies the mode of database creation.  Default: regular database creation.  Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.  OnlineSecondary/NonReadableSecondary: creates a database as a (readable or nonreadable) secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.  PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.  Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.  Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database&#39;s original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.  RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.  Copy, NonReadableSecondary, OnlineSecondary and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
   */
  @JsonAdapter(CreateModeEnum.Adapter.class)
  public enum CreateModeEnum {
    COPY("Copy"),
    
    DEFAULT("Default"),
    
    NON_READABLE_SECONDARY("NonReadableSecondary"),
    
    ONLINE_SECONDARY("OnlineSecondary"),
    
    POINT_IN_TIME_RESTORE("PointInTimeRestore"),
    
    RECOVERY("Recovery"),
    
    RESTORE("Restore"),
    
    RESTORE_LONG_TERM_RETENTION_BACKUP("RestoreLongTermRetentionBackup");

    private String value;

    CreateModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CreateModeEnum fromValue(String value) {
      for (CreateModeEnum b : CreateModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CreateModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CreateModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CreateModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CreateModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CreateModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CREATE_MODE = "createMode";
  @SerializedName(SERIALIZED_NAME_CREATE_MODE)
  private CreateModeEnum createMode;

  public static final String SERIALIZED_NAME_CREATION_DATE = "creationDate";
  @SerializedName(SERIALIZED_NAME_CREATION_DATE)
  private OffsetDateTime creationDate;

  public static final String SERIALIZED_NAME_CURRENT_SERVICE_OBJECTIVE_ID = "currentServiceObjectiveId";
  @SerializedName(SERIALIZED_NAME_CURRENT_SERVICE_OBJECTIVE_ID)
  private UUID currentServiceObjectiveId;

  public static final String SERIALIZED_NAME_DATABASE_ID = "databaseId";
  @SerializedName(SERIALIZED_NAME_DATABASE_ID)
  private UUID databaseId;

  public static final String SERIALIZED_NAME_DEFAULT_SECONDARY_LOCATION = "defaultSecondaryLocation";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SECONDARY_LOCATION)
  private String defaultSecondaryLocation;

  public static final String SERIALIZED_NAME_EARLIEST_RESTORE_DATE = "earliestRestoreDate";
  @SerializedName(SERIALIZED_NAME_EARLIEST_RESTORE_DATE)
  private OffsetDateTime earliestRestoreDate;

  /**
   * The edition of the database. The DatabaseEditions enumeration contains all the valid editions. If createMode is NonReadableSecondary or OnlineSecondary, this value is ignored.    The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the &#x60;Capabilities_ListByLocation&#x60; REST API or one of the following commands:    &#x60;&#x60;&#x60;azurecli  az sql db list-editions -l &lt;location&gt; -o table  &#x60;&#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;powershell  Get-AzSqlServerServiceObjective -Location &lt;location&gt;  &#x60;&#x60;&#x60;&#x60;  
   */
  @JsonAdapter(EditionEnum.Adapter.class)
  public enum EditionEnum {
    WEB("Web"),
    
    BUSINESS("Business"),
    
    BASIC("Basic"),
    
    STANDARD("Standard"),
    
    PREMIUM("Premium"),
    
    PREMIUM_RS("PremiumRS"),
    
    FREE("Free"),
    
    STRETCH("Stretch"),
    
    DATA_WAREHOUSE("DataWarehouse"),
    
    SYSTEM("System"),
    
    SYSTEM2("System2"),
    
    GENERAL_PURPOSE("GeneralPurpose"),
    
    BUSINESS_CRITICAL("BusinessCritical"),
    
    HYPERSCALE("Hyperscale");

    private String value;

    EditionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EditionEnum fromValue(String value) {
      for (EditionEnum b : EditionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EditionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EditionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EditionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EditionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EditionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EDITION = "edition";
  @SerializedName(SERIALIZED_NAME_EDITION)
  private EditionEnum edition;

  public static final String SERIALIZED_NAME_ELASTIC_POOL_NAME = "elasticPoolName";
  @SerializedName(SERIALIZED_NAME_ELASTIC_POOL_NAME)
  private String elasticPoolName;

  public static final String SERIALIZED_NAME_FAILOVER_GROUP_ID = "failoverGroupId";
  @SerializedName(SERIALIZED_NAME_FAILOVER_GROUP_ID)
  private String failoverGroupId;

  public static final String SERIALIZED_NAME_MAX_SIZE_BYTES = "maxSizeBytes";
  @SerializedName(SERIALIZED_NAME_MAX_SIZE_BYTES)
  private String maxSizeBytes;

  /**
   * Conditional. If the database is a geo-secondary, readScale indicates whether read-only connections are allowed to this database or not. Not supported for DataWarehouse edition.
   */
  @JsonAdapter(ReadScaleEnum.Adapter.class)
  public enum ReadScaleEnum {
    ENABLED("Enabled"),
    
    DISABLED("Disabled");

    private String value;

    ReadScaleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReadScaleEnum fromValue(String value) {
      for (ReadScaleEnum b : ReadScaleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ReadScaleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReadScaleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReadScaleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ReadScaleEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ReadScaleEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_READ_SCALE = "readScale";
  @SerializedName(SERIALIZED_NAME_READ_SCALE)
  private ReadScaleEnum readScale;

  public static final String SERIALIZED_NAME_RECOMMENDED_INDEX = "recommendedIndex";
  @SerializedName(SERIALIZED_NAME_RECOMMENDED_INDEX)
  private List<DatabasePropertiesRecommendedIndexInner> recommendedIndex = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECOVERY_SERVICES_RECOVERY_POINT_RESOURCE_ID = "recoveryServicesRecoveryPointResourceId";
  @SerializedName(SERIALIZED_NAME_RECOVERY_SERVICES_RECOVERY_POINT_RESOURCE_ID)
  private String recoveryServicesRecoveryPointResourceId;

  public static final String SERIALIZED_NAME_REQUESTED_SERVICE_OBJECTIVE_ID = "requestedServiceObjectiveId";
  @SerializedName(SERIALIZED_NAME_REQUESTED_SERVICE_OBJECTIVE_ID)
  private UUID requestedServiceObjectiveId;

  /**
   * The name of the configured service level objective of the database. This is the service level objective that is in the process of being applied to the database. Once successfully updated, it will match the value of serviceLevelObjective property.     The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the &#x60;Capabilities_ListByLocation&#x60; REST API or one of the following commands:    &#x60;&#x60;&#x60;azurecli  az sql db list-editions -l &lt;location&gt; -o table  &#x60;&#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;powershell  Get-AzSqlServerServiceObjective -Location &lt;location&gt;  &#x60;&#x60;&#x60;&#x60;  
   */
  @JsonAdapter(RequestedServiceObjectiveNameEnum.Adapter.class)
  public enum RequestedServiceObjectiveNameEnum {
    SYSTEM("System"),
    
    SYSTEM0("System0"),
    
    SYSTEM1("System1"),
    
    SYSTEM2("System2"),
    
    SYSTEM3("System3"),
    
    SYSTEM4("System4"),
    
    SYSTEM2_L("System2L"),
    
    SYSTEM3_L("System3L"),
    
    SYSTEM4_L("System4L"),
    
    FREE("Free"),
    
    BASIC("Basic"),
    
    S0("S0"),
    
    S1("S1"),
    
    S2("S2"),
    
    S3("S3"),
    
    S4("S4"),
    
    S6("S6"),
    
    S7("S7"),
    
    S9("S9"),
    
    S12("S12"),
    
    P1("P1"),
    
    P2("P2"),
    
    P3("P3"),
    
    P4("P4"),
    
    P6("P6"),
    
    P11("P11"),
    
    P15("P15"),
    
    PRS1("PRS1"),
    
    PRS2("PRS2"),
    
    PRS4("PRS4"),
    
    PRS6("PRS6"),
    
    DW100("DW100"),
    
    DW200("DW200"),
    
    DW300("DW300"),
    
    DW400("DW400"),
    
    DW500("DW500"),
    
    DW600("DW600"),
    
    DW1000("DW1000"),
    
    DW1200("DW1200"),
    
    DW1000C("DW1000c"),
    
    DW1500("DW1500"),
    
    DW1500C("DW1500c"),
    
    DW2000("DW2000"),
    
    DW2000C("DW2000c"),
    
    DW3000("DW3000"),
    
    DW2500C("DW2500c"),
    
    DW3000C("DW3000c"),
    
    DW6000("DW6000"),
    
    DW5000C("DW5000c"),
    
    DW6000C("DW6000c"),
    
    DW7500C("DW7500c"),
    
    DW10000C("DW10000c"),
    
    DW15000C("DW15000c"),
    
    DW30000C("DW30000c"),
    
    DS100("DS100"),
    
    DS200("DS200"),
    
    DS300("DS300"),
    
    DS400("DS400"),
    
    DS500("DS500"),
    
    DS600("DS600"),
    
    DS1000("DS1000"),
    
    DS1200("DS1200"),
    
    DS1500("DS1500"),
    
    DS2000("DS2000"),
    
    ELASTIC_POOL("ElasticPool");

    private String value;

    RequestedServiceObjectiveNameEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RequestedServiceObjectiveNameEnum fromValue(String value) {
      for (RequestedServiceObjectiveNameEnum b : RequestedServiceObjectiveNameEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RequestedServiceObjectiveNameEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RequestedServiceObjectiveNameEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RequestedServiceObjectiveNameEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RequestedServiceObjectiveNameEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RequestedServiceObjectiveNameEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REQUESTED_SERVICE_OBJECTIVE_NAME = "requestedServiceObjectiveName";
  @SerializedName(SERIALIZED_NAME_REQUESTED_SERVICE_OBJECTIVE_NAME)
  private RequestedServiceObjectiveNameEnum requestedServiceObjectiveName;

  public static final String SERIALIZED_NAME_RESTORE_POINT_IN_TIME = "restorePointInTime";
  @SerializedName(SERIALIZED_NAME_RESTORE_POINT_IN_TIME)
  private OffsetDateTime restorePointInTime;

  /**
   * Indicates the name of the sample schema to apply when creating this database. If createMode is not Default, this value is ignored. Not supported for DataWarehouse edition.
   */
  @JsonAdapter(SampleNameEnum.Adapter.class)
  public enum SampleNameEnum {
    ADVENTURE_WORKS_LT("AdventureWorksLT");

    private String value;

    SampleNameEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SampleNameEnum fromValue(String value) {
      for (SampleNameEnum b : SampleNameEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SampleNameEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SampleNameEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SampleNameEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SampleNameEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SampleNameEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SAMPLE_NAME = "sampleName";
  @SerializedName(SERIALIZED_NAME_SAMPLE_NAME)
  private SampleNameEnum sampleName;

  /**
   * The current service level objective of the database.
   */
  @JsonAdapter(ServiceLevelObjectiveEnum.Adapter.class)
  public enum ServiceLevelObjectiveEnum {
    SYSTEM("System"),
    
    SYSTEM0("System0"),
    
    SYSTEM1("System1"),
    
    SYSTEM2("System2"),
    
    SYSTEM3("System3"),
    
    SYSTEM4("System4"),
    
    SYSTEM2_L("System2L"),
    
    SYSTEM3_L("System3L"),
    
    SYSTEM4_L("System4L"),
    
    FREE("Free"),
    
    BASIC("Basic"),
    
    S0("S0"),
    
    S1("S1"),
    
    S2("S2"),
    
    S3("S3"),
    
    S4("S4"),
    
    S6("S6"),
    
    S7("S7"),
    
    S9("S9"),
    
    S12("S12"),
    
    P1("P1"),
    
    P2("P2"),
    
    P3("P3"),
    
    P4("P4"),
    
    P6("P6"),
    
    P11("P11"),
    
    P15("P15"),
    
    PRS1("PRS1"),
    
    PRS2("PRS2"),
    
    PRS4("PRS4"),
    
    PRS6("PRS6"),
    
    DW100("DW100"),
    
    DW200("DW200"),
    
    DW300("DW300"),
    
    DW400("DW400"),
    
    DW500("DW500"),
    
    DW600("DW600"),
    
    DW1000("DW1000"),
    
    DW1200("DW1200"),
    
    DW1000C("DW1000c"),
    
    DW1500("DW1500"),
    
    DW1500C("DW1500c"),
    
    DW2000("DW2000"),
    
    DW2000C("DW2000c"),
    
    DW3000("DW3000"),
    
    DW2500C("DW2500c"),
    
    DW3000C("DW3000c"),
    
    DW6000("DW6000"),
    
    DW5000C("DW5000c"),
    
    DW6000C("DW6000c"),
    
    DW7500C("DW7500c"),
    
    DW10000C("DW10000c"),
    
    DW15000C("DW15000c"),
    
    DW30000C("DW30000c"),
    
    DS100("DS100"),
    
    DS200("DS200"),
    
    DS300("DS300"),
    
    DS400("DS400"),
    
    DS500("DS500"),
    
    DS600("DS600"),
    
    DS1000("DS1000"),
    
    DS1200("DS1200"),
    
    DS1500("DS1500"),
    
    DS2000("DS2000"),
    
    ELASTIC_POOL("ElasticPool");

    private String value;

    ServiceLevelObjectiveEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ServiceLevelObjectiveEnum fromValue(String value) {
      for (ServiceLevelObjectiveEnum b : ServiceLevelObjectiveEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ServiceLevelObjectiveEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ServiceLevelObjectiveEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ServiceLevelObjectiveEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ServiceLevelObjectiveEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ServiceLevelObjectiveEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SERVICE_LEVEL_OBJECTIVE = "serviceLevelObjective";
  @SerializedName(SERIALIZED_NAME_SERVICE_LEVEL_OBJECTIVE)
  private ServiceLevelObjectiveEnum serviceLevelObjective;

  public static final String SERIALIZED_NAME_SERVICE_TIER_ADVISORS = "serviceTierAdvisors";
  @SerializedName(SERIALIZED_NAME_SERVICE_TIER_ADVISORS)
  private List<DatabasePropertiesServiceTierAdvisorsInner> serviceTierAdvisors = new ArrayList<>();

  public static final String SERIALIZED_NAME_SOURCE_DATABASE_DELETION_DATE = "sourceDatabaseDeletionDate";
  @SerializedName(SERIALIZED_NAME_SOURCE_DATABASE_DELETION_DATE)
  private OffsetDateTime sourceDatabaseDeletionDate;

  public static final String SERIALIZED_NAME_SOURCE_DATABASE_ID = "sourceDatabaseId";
  @SerializedName(SERIALIZED_NAME_SOURCE_DATABASE_ID)
  private String sourceDatabaseId;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_TRANSPARENT_DATA_ENCRYPTION = "transparentDataEncryption";
  @SerializedName(SERIALIZED_NAME_TRANSPARENT_DATA_ENCRYPTION)
  private List<DatabasePropertiesTransparentDataEncryptionInner> transparentDataEncryption = new ArrayList<>();

  public static final String SERIALIZED_NAME_ZONE_REDUNDANT = "zoneRedundant";
  @SerializedName(SERIALIZED_NAME_ZONE_REDUNDANT)
  private Boolean zoneRedundant;

  public DatabaseProperties() {
  }

  public DatabaseProperties(
     Long containmentState, 
     OffsetDateTime creationDate, 
     UUID currentServiceObjectiveId, 
     UUID databaseId, 
     String defaultSecondaryLocation, 
     OffsetDateTime earliestRestoreDate, 
     String failoverGroupId, 
     List<DatabasePropertiesRecommendedIndexInner> recommendedIndex, 
     ServiceLevelObjectiveEnum serviceLevelObjective, 
     List<DatabasePropertiesServiceTierAdvisorsInner> serviceTierAdvisors, 
     String status, 
     List<DatabasePropertiesTransparentDataEncryptionInner> transparentDataEncryption
  ) {
    this();
    this.containmentState = containmentState;
    this.creationDate = creationDate;
    this.currentServiceObjectiveId = currentServiceObjectiveId;
    this.databaseId = databaseId;
    this.defaultSecondaryLocation = defaultSecondaryLocation;
    this.earliestRestoreDate = earliestRestoreDate;
    this.failoverGroupId = failoverGroupId;
    this.recommendedIndex = recommendedIndex;
    this.serviceLevelObjective = serviceLevelObjective;
    this.serviceTierAdvisors = serviceTierAdvisors;
    this.status = status;
    this.transparentDataEncryption = transparentDataEncryption;
  }

  public DatabaseProperties collation(String collation) {
    this.collation = collation;
    return this;
  }

  /**
   * The collation of the database. If createMode is not Default, this value is ignored.
   * @return collation
   */
  @javax.annotation.Nullable
  public String getCollation() {
    return collation;
  }

  public void setCollation(String collation) {
    this.collation = collation;
  }


  /**
   * The containment state of the database.
   * @return containmentState
   */
  @javax.annotation.Nullable
  public Long getContainmentState() {
    return containmentState;
  }



  public DatabaseProperties createMode(CreateModeEnum createMode) {
    this.createMode = createMode;
    return this;
  }

  /**
   * Specifies the mode of database creation.  Default: regular database creation.  Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.  OnlineSecondary/NonReadableSecondary: creates a database as a (readable or nonreadable) secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.  PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.  Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.  Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database&#39;s original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.  RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.  Copy, NonReadableSecondary, OnlineSecondary and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
   * @return createMode
   */
  @javax.annotation.Nullable
  public CreateModeEnum getCreateMode() {
    return createMode;
  }

  public void setCreateMode(CreateModeEnum createMode) {
    this.createMode = createMode;
  }


  /**
   * The creation date of the database (ISO8601 format).
   * @return creationDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreationDate() {
    return creationDate;
  }



  /**
   * The current service level objective ID of the database. This is the ID of the service level objective that is currently active.
   * @return currentServiceObjectiveId
   */
  @javax.annotation.Nullable
  public UUID getCurrentServiceObjectiveId() {
    return currentServiceObjectiveId;
  }



  /**
   * The ID of the database.
   * @return databaseId
   */
  @javax.annotation.Nullable
  public UUID getDatabaseId() {
    return databaseId;
  }



  /**
   * The default secondary region for this database.
   * @return defaultSecondaryLocation
   */
  @javax.annotation.Nullable
  public String getDefaultSecondaryLocation() {
    return defaultSecondaryLocation;
  }



  /**
   * This records the earliest start date and time that restore is available for this database (ISO8601 format).
   * @return earliestRestoreDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEarliestRestoreDate() {
    return earliestRestoreDate;
  }



  public DatabaseProperties edition(EditionEnum edition) {
    this.edition = edition;
    return this;
  }

  /**
   * The edition of the database. The DatabaseEditions enumeration contains all the valid editions. If createMode is NonReadableSecondary or OnlineSecondary, this value is ignored.    The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the &#x60;Capabilities_ListByLocation&#x60; REST API or one of the following commands:    &#x60;&#x60;&#x60;azurecli  az sql db list-editions -l &lt;location&gt; -o table  &#x60;&#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;powershell  Get-AzSqlServerServiceObjective -Location &lt;location&gt;  &#x60;&#x60;&#x60;&#x60;  
   * @return edition
   */
  @javax.annotation.Nullable
  public EditionEnum getEdition() {
    return edition;
  }

  public void setEdition(EditionEnum edition) {
    this.edition = edition;
  }


  public DatabaseProperties elasticPoolName(String elasticPoolName) {
    this.elasticPoolName = elasticPoolName;
    return this;
  }

  /**
   * The name of the elastic pool the database is in. If elasticPoolName and requestedServiceObjectiveName are both updated, the value of requestedServiceObjectiveName is ignored. Not supported for DataWarehouse edition.
   * @return elasticPoolName
   */
  @javax.annotation.Nullable
  public String getElasticPoolName() {
    return elasticPoolName;
  }

  public void setElasticPoolName(String elasticPoolName) {
    this.elasticPoolName = elasticPoolName;
  }


  /**
   * The resource identifier of the failover group containing this database.
   * @return failoverGroupId
   */
  @javax.annotation.Nullable
  public String getFailoverGroupId() {
    return failoverGroupId;
  }



  public DatabaseProperties maxSizeBytes(String maxSizeBytes) {
    this.maxSizeBytes = maxSizeBytes;
    return this;
  }

  /**
   * The max size of the database expressed in bytes. If createMode is not Default, this value is ignored. To see possible values, query the capabilities API (/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationID}/capabilities) referred to by operationId: \&quot;Capabilities_ListByLocation.\&quot;
   * @return maxSizeBytes
   */
  @javax.annotation.Nullable
  public String getMaxSizeBytes() {
    return maxSizeBytes;
  }

  public void setMaxSizeBytes(String maxSizeBytes) {
    this.maxSizeBytes = maxSizeBytes;
  }


  public DatabaseProperties readScale(ReadScaleEnum readScale) {
    this.readScale = readScale;
    return this;
  }

  /**
   * Conditional. If the database is a geo-secondary, readScale indicates whether read-only connections are allowed to this database or not. Not supported for DataWarehouse edition.
   * @return readScale
   */
  @javax.annotation.Nullable
  public ReadScaleEnum getReadScale() {
    return readScale;
  }

  public void setReadScale(ReadScaleEnum readScale) {
    this.readScale = readScale;
  }


  /**
   * The recommended indices for this database.
   * @return recommendedIndex
   */
  @javax.annotation.Nullable
  public List<DatabasePropertiesRecommendedIndexInner> getRecommendedIndex() {
    return recommendedIndex;
  }



  public DatabaseProperties recoveryServicesRecoveryPointResourceId(String recoveryServicesRecoveryPointResourceId) {
    this.recoveryServicesRecoveryPointResourceId = recoveryServicesRecoveryPointResourceId;
    return this;
  }

  /**
   * Conditional. If createMode is RestoreLongTermRetentionBackup, then this value is required. Specifies the resource ID of the recovery point to restore from.
   * @return recoveryServicesRecoveryPointResourceId
   */
  @javax.annotation.Nullable
  public String getRecoveryServicesRecoveryPointResourceId() {
    return recoveryServicesRecoveryPointResourceId;
  }

  public void setRecoveryServicesRecoveryPointResourceId(String recoveryServicesRecoveryPointResourceId) {
    this.recoveryServicesRecoveryPointResourceId = recoveryServicesRecoveryPointResourceId;
  }


  public DatabaseProperties requestedServiceObjectiveId(UUID requestedServiceObjectiveId) {
    this.requestedServiceObjectiveId = requestedServiceObjectiveId;
    return this;
  }

  /**
   * The configured service level objective ID of the database. This is the service level objective that is in the process of being applied to the database. Once successfully updated, it will match the value of currentServiceObjectiveId property. If requestedServiceObjectiveId and requestedServiceObjectiveName are both updated, the value of requestedServiceObjectiveId overrides the value of requestedServiceObjectiveName.    The list of SKUs may vary by region and support offer. To determine the service objective ids that are available to your subscription in an Azure region, use the &#x60;Capabilities_ListByLocation&#x60; REST API.
   * @return requestedServiceObjectiveId
   */
  @javax.annotation.Nullable
  public UUID getRequestedServiceObjectiveId() {
    return requestedServiceObjectiveId;
  }

  public void setRequestedServiceObjectiveId(UUID requestedServiceObjectiveId) {
    this.requestedServiceObjectiveId = requestedServiceObjectiveId;
  }


  public DatabaseProperties requestedServiceObjectiveName(RequestedServiceObjectiveNameEnum requestedServiceObjectiveName) {
    this.requestedServiceObjectiveName = requestedServiceObjectiveName;
    return this;
  }

  /**
   * The name of the configured service level objective of the database. This is the service level objective that is in the process of being applied to the database. Once successfully updated, it will match the value of serviceLevelObjective property.     The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the &#x60;Capabilities_ListByLocation&#x60; REST API or one of the following commands:    &#x60;&#x60;&#x60;azurecli  az sql db list-editions -l &lt;location&gt; -o table  &#x60;&#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;powershell  Get-AzSqlServerServiceObjective -Location &lt;location&gt;  &#x60;&#x60;&#x60;&#x60;  
   * @return requestedServiceObjectiveName
   */
  @javax.annotation.Nullable
  public RequestedServiceObjectiveNameEnum getRequestedServiceObjectiveName() {
    return requestedServiceObjectiveName;
  }

  public void setRequestedServiceObjectiveName(RequestedServiceObjectiveNameEnum requestedServiceObjectiveName) {
    this.requestedServiceObjectiveName = requestedServiceObjectiveName;
  }


  public DatabaseProperties restorePointInTime(OffsetDateTime restorePointInTime) {
    this.restorePointInTime = restorePointInTime;
    return this;
  }

  /**
   * Conditional. If createMode is PointInTimeRestore, this value is required. If createMode is Restore, this value is optional. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database. Must be greater than or equal to the source database&#39;s earliestRestoreDate value.
   * @return restorePointInTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRestorePointInTime() {
    return restorePointInTime;
  }

  public void setRestorePointInTime(OffsetDateTime restorePointInTime) {
    this.restorePointInTime = restorePointInTime;
  }


  public DatabaseProperties sampleName(SampleNameEnum sampleName) {
    this.sampleName = sampleName;
    return this;
  }

  /**
   * Indicates the name of the sample schema to apply when creating this database. If createMode is not Default, this value is ignored. Not supported for DataWarehouse edition.
   * @return sampleName
   */
  @javax.annotation.Nullable
  public SampleNameEnum getSampleName() {
    return sampleName;
  }

  public void setSampleName(SampleNameEnum sampleName) {
    this.sampleName = sampleName;
  }


  /**
   * The current service level objective of the database.
   * @return serviceLevelObjective
   */
  @javax.annotation.Nullable
  public ServiceLevelObjectiveEnum getServiceLevelObjective() {
    return serviceLevelObjective;
  }



  /**
   * The list of service tier advisors for this database. Expanded property
   * @return serviceTierAdvisors
   */
  @javax.annotation.Nullable
  public List<DatabasePropertiesServiceTierAdvisorsInner> getServiceTierAdvisors() {
    return serviceTierAdvisors;
  }



  public DatabaseProperties sourceDatabaseDeletionDate(OffsetDateTime sourceDatabaseDeletionDate) {
    this.sourceDatabaseDeletionDate = sourceDatabaseDeletionDate;
    return this;
  }

  /**
   * Conditional. If createMode is Restore and sourceDatabaseId is the deleted database&#39;s original resource id when it existed (as opposed to its current restorable dropped database id), then this value is required. Specifies the time that the database was deleted.
   * @return sourceDatabaseDeletionDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSourceDatabaseDeletionDate() {
    return sourceDatabaseDeletionDate;
  }

  public void setSourceDatabaseDeletionDate(OffsetDateTime sourceDatabaseDeletionDate) {
    this.sourceDatabaseDeletionDate = sourceDatabaseDeletionDate;
  }


  public DatabaseProperties sourceDatabaseId(String sourceDatabaseId) {
    this.sourceDatabaseId = sourceDatabaseId;
    return this;
  }

  /**
   * Conditional. If createMode is Copy, NonReadableSecondary, OnlineSecondary, PointInTimeRestore, Recovery, or Restore, then this value is required. Specifies the resource ID of the source database. If createMode is NonReadableSecondary or OnlineSecondary, the name of the source database must be the same as the new database being created.
   * @return sourceDatabaseId
   */
  @javax.annotation.Nullable
  public String getSourceDatabaseId() {
    return sourceDatabaseId;
  }

  public void setSourceDatabaseId(String sourceDatabaseId) {
    this.sourceDatabaseId = sourceDatabaseId;
  }


  /**
   * The status of the database.
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }



  /**
   * The transparent data encryption info for this database.
   * @return transparentDataEncryption
   */
  @javax.annotation.Nullable
  public List<DatabasePropertiesTransparentDataEncryptionInner> getTransparentDataEncryption() {
    return transparentDataEncryption;
  }



  public DatabaseProperties zoneRedundant(Boolean zoneRedundant) {
    this.zoneRedundant = zoneRedundant;
    return this;
  }

  /**
   * Whether or not this database is zone redundant, which means the replicas of this database will be spread across multiple availability zones.
   * @return zoneRedundant
   */
  @javax.annotation.Nullable
  public Boolean getZoneRedundant() {
    return zoneRedundant;
  }

  public void setZoneRedundant(Boolean zoneRedundant) {
    this.zoneRedundant = zoneRedundant;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DatabaseProperties databaseProperties = (DatabaseProperties) o;
    return Objects.equals(this.collation, databaseProperties.collation) &&
        Objects.equals(this.containmentState, databaseProperties.containmentState) &&
        Objects.equals(this.createMode, databaseProperties.createMode) &&
        Objects.equals(this.creationDate, databaseProperties.creationDate) &&
        Objects.equals(this.currentServiceObjectiveId, databaseProperties.currentServiceObjectiveId) &&
        Objects.equals(this.databaseId, databaseProperties.databaseId) &&
        Objects.equals(this.defaultSecondaryLocation, databaseProperties.defaultSecondaryLocation) &&
        Objects.equals(this.earliestRestoreDate, databaseProperties.earliestRestoreDate) &&
        Objects.equals(this.edition, databaseProperties.edition) &&
        Objects.equals(this.elasticPoolName, databaseProperties.elasticPoolName) &&
        Objects.equals(this.failoverGroupId, databaseProperties.failoverGroupId) &&
        Objects.equals(this.maxSizeBytes, databaseProperties.maxSizeBytes) &&
        Objects.equals(this.readScale, databaseProperties.readScale) &&
        Objects.equals(this.recommendedIndex, databaseProperties.recommendedIndex) &&
        Objects.equals(this.recoveryServicesRecoveryPointResourceId, databaseProperties.recoveryServicesRecoveryPointResourceId) &&
        Objects.equals(this.requestedServiceObjectiveId, databaseProperties.requestedServiceObjectiveId) &&
        Objects.equals(this.requestedServiceObjectiveName, databaseProperties.requestedServiceObjectiveName) &&
        Objects.equals(this.restorePointInTime, databaseProperties.restorePointInTime) &&
        Objects.equals(this.sampleName, databaseProperties.sampleName) &&
        Objects.equals(this.serviceLevelObjective, databaseProperties.serviceLevelObjective) &&
        Objects.equals(this.serviceTierAdvisors, databaseProperties.serviceTierAdvisors) &&
        Objects.equals(this.sourceDatabaseDeletionDate, databaseProperties.sourceDatabaseDeletionDate) &&
        Objects.equals(this.sourceDatabaseId, databaseProperties.sourceDatabaseId) &&
        Objects.equals(this.status, databaseProperties.status) &&
        Objects.equals(this.transparentDataEncryption, databaseProperties.transparentDataEncryption) &&
        Objects.equals(this.zoneRedundant, databaseProperties.zoneRedundant);
  }

  @Override
  public int hashCode() {
    return Objects.hash(collation, containmentState, createMode, creationDate, currentServiceObjectiveId, databaseId, defaultSecondaryLocation, earliestRestoreDate, edition, elasticPoolName, failoverGroupId, maxSizeBytes, readScale, recommendedIndex, recoveryServicesRecoveryPointResourceId, requestedServiceObjectiveId, requestedServiceObjectiveName, restorePointInTime, sampleName, serviceLevelObjective, serviceTierAdvisors, sourceDatabaseDeletionDate, sourceDatabaseId, status, transparentDataEncryption, zoneRedundant);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DatabaseProperties {\n");
    sb.append("    collation: ").append(toIndentedString(collation)).append("\n");
    sb.append("    containmentState: ").append(toIndentedString(containmentState)).append("\n");
    sb.append("    createMode: ").append(toIndentedString(createMode)).append("\n");
    sb.append("    creationDate: ").append(toIndentedString(creationDate)).append("\n");
    sb.append("    currentServiceObjectiveId: ").append(toIndentedString(currentServiceObjectiveId)).append("\n");
    sb.append("    databaseId: ").append(toIndentedString(databaseId)).append("\n");
    sb.append("    defaultSecondaryLocation: ").append(toIndentedString(defaultSecondaryLocation)).append("\n");
    sb.append("    earliestRestoreDate: ").append(toIndentedString(earliestRestoreDate)).append("\n");
    sb.append("    edition: ").append(toIndentedString(edition)).append("\n");
    sb.append("    elasticPoolName: ").append(toIndentedString(elasticPoolName)).append("\n");
    sb.append("    failoverGroupId: ").append(toIndentedString(failoverGroupId)).append("\n");
    sb.append("    maxSizeBytes: ").append(toIndentedString(maxSizeBytes)).append("\n");
    sb.append("    readScale: ").append(toIndentedString(readScale)).append("\n");
    sb.append("    recommendedIndex: ").append(toIndentedString(recommendedIndex)).append("\n");
    sb.append("    recoveryServicesRecoveryPointResourceId: ").append(toIndentedString(recoveryServicesRecoveryPointResourceId)).append("\n");
    sb.append("    requestedServiceObjectiveId: ").append(toIndentedString(requestedServiceObjectiveId)).append("\n");
    sb.append("    requestedServiceObjectiveName: ").append(toIndentedString(requestedServiceObjectiveName)).append("\n");
    sb.append("    restorePointInTime: ").append(toIndentedString(restorePointInTime)).append("\n");
    sb.append("    sampleName: ").append(toIndentedString(sampleName)).append("\n");
    sb.append("    serviceLevelObjective: ").append(toIndentedString(serviceLevelObjective)).append("\n");
    sb.append("    serviceTierAdvisors: ").append(toIndentedString(serviceTierAdvisors)).append("\n");
    sb.append("    sourceDatabaseDeletionDate: ").append(toIndentedString(sourceDatabaseDeletionDate)).append("\n");
    sb.append("    sourceDatabaseId: ").append(toIndentedString(sourceDatabaseId)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    transparentDataEncryption: ").append(toIndentedString(transparentDataEncryption)).append("\n");
    sb.append("    zoneRedundant: ").append(toIndentedString(zoneRedundant)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("collation");
    openapiFields.add("containmentState");
    openapiFields.add("createMode");
    openapiFields.add("creationDate");
    openapiFields.add("currentServiceObjectiveId");
    openapiFields.add("databaseId");
    openapiFields.add("defaultSecondaryLocation");
    openapiFields.add("earliestRestoreDate");
    openapiFields.add("edition");
    openapiFields.add("elasticPoolName");
    openapiFields.add("failoverGroupId");
    openapiFields.add("maxSizeBytes");
    openapiFields.add("readScale");
    openapiFields.add("recommendedIndex");
    openapiFields.add("recoveryServicesRecoveryPointResourceId");
    openapiFields.add("requestedServiceObjectiveId");
    openapiFields.add("requestedServiceObjectiveName");
    openapiFields.add("restorePointInTime");
    openapiFields.add("sampleName");
    openapiFields.add("serviceLevelObjective");
    openapiFields.add("serviceTierAdvisors");
    openapiFields.add("sourceDatabaseDeletionDate");
    openapiFields.add("sourceDatabaseId");
    openapiFields.add("status");
    openapiFields.add("transparentDataEncryption");
    openapiFields.add("zoneRedundant");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DatabaseProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DatabaseProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DatabaseProperties is not found in the empty JSON string", DatabaseProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DatabaseProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DatabaseProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("collation") != null && !jsonObj.get("collation").isJsonNull()) && !jsonObj.get("collation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `collation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("collation").toString()));
      }
      if ((jsonObj.get("createMode") != null && !jsonObj.get("createMode").isJsonNull()) && !jsonObj.get("createMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createMode").toString()));
      }
      // validate the optional field `createMode`
      if (jsonObj.get("createMode") != null && !jsonObj.get("createMode").isJsonNull()) {
        CreateModeEnum.validateJsonElement(jsonObj.get("createMode"));
      }
      if ((jsonObj.get("currentServiceObjectiveId") != null && !jsonObj.get("currentServiceObjectiveId").isJsonNull()) && !jsonObj.get("currentServiceObjectiveId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currentServiceObjectiveId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currentServiceObjectiveId").toString()));
      }
      if ((jsonObj.get("databaseId") != null && !jsonObj.get("databaseId").isJsonNull()) && !jsonObj.get("databaseId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseId").toString()));
      }
      if ((jsonObj.get("defaultSecondaryLocation") != null && !jsonObj.get("defaultSecondaryLocation").isJsonNull()) && !jsonObj.get("defaultSecondaryLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultSecondaryLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultSecondaryLocation").toString()));
      }
      if ((jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) && !jsonObj.get("edition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `edition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("edition").toString()));
      }
      // validate the optional field `edition`
      if (jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) {
        EditionEnum.validateJsonElement(jsonObj.get("edition"));
      }
      if ((jsonObj.get("elasticPoolName") != null && !jsonObj.get("elasticPoolName").isJsonNull()) && !jsonObj.get("elasticPoolName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `elasticPoolName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("elasticPoolName").toString()));
      }
      if ((jsonObj.get("failoverGroupId") != null && !jsonObj.get("failoverGroupId").isJsonNull()) && !jsonObj.get("failoverGroupId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `failoverGroupId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("failoverGroupId").toString()));
      }
      if ((jsonObj.get("maxSizeBytes") != null && !jsonObj.get("maxSizeBytes").isJsonNull()) && !jsonObj.get("maxSizeBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxSizeBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxSizeBytes").toString()));
      }
      if ((jsonObj.get("readScale") != null && !jsonObj.get("readScale").isJsonNull()) && !jsonObj.get("readScale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `readScale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("readScale").toString()));
      }
      // validate the optional field `readScale`
      if (jsonObj.get("readScale") != null && !jsonObj.get("readScale").isJsonNull()) {
        ReadScaleEnum.validateJsonElement(jsonObj.get("readScale"));
      }
      if (jsonObj.get("recommendedIndex") != null && !jsonObj.get("recommendedIndex").isJsonNull()) {
        JsonArray jsonArrayrecommendedIndex = jsonObj.getAsJsonArray("recommendedIndex");
        if (jsonArrayrecommendedIndex != null) {
          // ensure the json data is an array
          if (!jsonObj.get("recommendedIndex").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `recommendedIndex` to be an array in the JSON string but got `%s`", jsonObj.get("recommendedIndex").toString()));
          }

          // validate the optional field `recommendedIndex` (array)
          for (int i = 0; i < jsonArrayrecommendedIndex.size(); i++) {
            DatabasePropertiesRecommendedIndexInner.validateJsonElement(jsonArrayrecommendedIndex.get(i));
          };
        }
      }
      if ((jsonObj.get("recoveryServicesRecoveryPointResourceId") != null && !jsonObj.get("recoveryServicesRecoveryPointResourceId").isJsonNull()) && !jsonObj.get("recoveryServicesRecoveryPointResourceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recoveryServicesRecoveryPointResourceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recoveryServicesRecoveryPointResourceId").toString()));
      }
      if ((jsonObj.get("requestedServiceObjectiveId") != null && !jsonObj.get("requestedServiceObjectiveId").isJsonNull()) && !jsonObj.get("requestedServiceObjectiveId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedServiceObjectiveId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestedServiceObjectiveId").toString()));
      }
      if ((jsonObj.get("requestedServiceObjectiveName") != null && !jsonObj.get("requestedServiceObjectiveName").isJsonNull()) && !jsonObj.get("requestedServiceObjectiveName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedServiceObjectiveName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestedServiceObjectiveName").toString()));
      }
      // validate the optional field `requestedServiceObjectiveName`
      if (jsonObj.get("requestedServiceObjectiveName") != null && !jsonObj.get("requestedServiceObjectiveName").isJsonNull()) {
        RequestedServiceObjectiveNameEnum.validateJsonElement(jsonObj.get("requestedServiceObjectiveName"));
      }
      if ((jsonObj.get("sampleName") != null && !jsonObj.get("sampleName").isJsonNull()) && !jsonObj.get("sampleName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sampleName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sampleName").toString()));
      }
      // validate the optional field `sampleName`
      if (jsonObj.get("sampleName") != null && !jsonObj.get("sampleName").isJsonNull()) {
        SampleNameEnum.validateJsonElement(jsonObj.get("sampleName"));
      }
      if ((jsonObj.get("serviceLevelObjective") != null && !jsonObj.get("serviceLevelObjective").isJsonNull()) && !jsonObj.get("serviceLevelObjective").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceLevelObjective` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceLevelObjective").toString()));
      }
      // validate the optional field `serviceLevelObjective`
      if (jsonObj.get("serviceLevelObjective") != null && !jsonObj.get("serviceLevelObjective").isJsonNull()) {
        ServiceLevelObjectiveEnum.validateJsonElement(jsonObj.get("serviceLevelObjective"));
      }
      if (jsonObj.get("serviceTierAdvisors") != null && !jsonObj.get("serviceTierAdvisors").isJsonNull()) {
        JsonArray jsonArrayserviceTierAdvisors = jsonObj.getAsJsonArray("serviceTierAdvisors");
        if (jsonArrayserviceTierAdvisors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("serviceTierAdvisors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `serviceTierAdvisors` to be an array in the JSON string but got `%s`", jsonObj.get("serviceTierAdvisors").toString()));
          }

          // validate the optional field `serviceTierAdvisors` (array)
          for (int i = 0; i < jsonArrayserviceTierAdvisors.size(); i++) {
            DatabasePropertiesServiceTierAdvisorsInner.validateJsonElement(jsonArrayserviceTierAdvisors.get(i));
          };
        }
      }
      if ((jsonObj.get("sourceDatabaseId") != null && !jsonObj.get("sourceDatabaseId").isJsonNull()) && !jsonObj.get("sourceDatabaseId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceDatabaseId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceDatabaseId").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if (jsonObj.get("transparentDataEncryption") != null && !jsonObj.get("transparentDataEncryption").isJsonNull()) {
        JsonArray jsonArraytransparentDataEncryption = jsonObj.getAsJsonArray("transparentDataEncryption");
        if (jsonArraytransparentDataEncryption != null) {
          // ensure the json data is an array
          if (!jsonObj.get("transparentDataEncryption").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `transparentDataEncryption` to be an array in the JSON string but got `%s`", jsonObj.get("transparentDataEncryption").toString()));
          }

          // validate the optional field `transparentDataEncryption` (array)
          for (int i = 0; i < jsonArraytransparentDataEncryption.size(); i++) {
            DatabasePropertiesTransparentDataEncryptionInner.validateJsonElement(jsonArraytransparentDataEncryption.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DatabaseProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DatabaseProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DatabaseProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DatabaseProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<DatabaseProperties>() {
           @Override
           public void write(JsonWriter out, DatabaseProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DatabaseProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DatabaseProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DatabaseProperties
   * @throws IOException if the JSON string is invalid with respect to DatabaseProperties
   */
  public static DatabaseProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DatabaseProperties.class);
  }

  /**
   * Convert an instance of DatabaseProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

