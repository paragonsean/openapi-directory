/*
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2017-03-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains the information necessary to perform import/export operation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:37:15.897901-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ImportExportDatabaseDefinition {
  public static final String SERIALIZED_NAME_ADMINISTRATOR_LOGIN = "administratorLogin";
  @SerializedName(SERIALIZED_NAME_ADMINISTRATOR_LOGIN)
  private String administratorLogin;

  public static final String SERIALIZED_NAME_ADMINISTRATOR_LOGIN_PASSWORD = "administratorLoginPassword";
  @SerializedName(SERIALIZED_NAME_ADMINISTRATOR_LOGIN_PASSWORD)
  private String administratorLoginPassword;

  public static final String SERIALIZED_NAME_AUTHENTICATION_TYPE = "authenticationType";
  @SerializedName(SERIALIZED_NAME_AUTHENTICATION_TYPE)
  private String authenticationType;

  public static final String SERIALIZED_NAME_DATABASE_NAME = "databaseName";
  @SerializedName(SERIALIZED_NAME_DATABASE_NAME)
  private String databaseName;

  public static final String SERIALIZED_NAME_EDITION = "edition";
  @SerializedName(SERIALIZED_NAME_EDITION)
  private String edition;

  public static final String SERIALIZED_NAME_MAX_SIZE_BYTES = "maxSizeBytes";
  @SerializedName(SERIALIZED_NAME_MAX_SIZE_BYTES)
  private String maxSizeBytes;

  public static final String SERIALIZED_NAME_SERVICE_OBJECTIVE_NAME = "serviceObjectiveName";
  @SerializedName(SERIALIZED_NAME_SERVICE_OBJECTIVE_NAME)
  private String serviceObjectiveName;

  public static final String SERIALIZED_NAME_STORAGE_KEY = "storageKey";
  @SerializedName(SERIALIZED_NAME_STORAGE_KEY)
  private String storageKey;

  public static final String SERIALIZED_NAME_STORAGE_KEY_TYPE = "storageKeyType";
  @SerializedName(SERIALIZED_NAME_STORAGE_KEY_TYPE)
  private String storageKeyType;

  public static final String SERIALIZED_NAME_STORAGE_URI = "storageUri";
  @SerializedName(SERIALIZED_NAME_STORAGE_URI)
  private String storageUri;

  public ImportExportDatabaseDefinition() {
  }

  public ImportExportDatabaseDefinition administratorLogin(String administratorLogin) {
    this.administratorLogin = administratorLogin;
    return this;
  }

  /**
   * Administrator login name.
   * @return administratorLogin
   */
  @javax.annotation.Nonnull
  public String getAdministratorLogin() {
    return administratorLogin;
  }

  public void setAdministratorLogin(String administratorLogin) {
    this.administratorLogin = administratorLogin;
  }


  public ImportExportDatabaseDefinition administratorLoginPassword(String administratorLoginPassword) {
    this.administratorLoginPassword = administratorLoginPassword;
    return this;
  }

  /**
   * Administrator login password.
   * @return administratorLoginPassword
   */
  @javax.annotation.Nonnull
  public String getAdministratorLoginPassword() {
    return administratorLoginPassword;
  }

  public void setAdministratorLoginPassword(String administratorLoginPassword) {
    this.administratorLoginPassword = administratorLoginPassword;
  }


  public ImportExportDatabaseDefinition authenticationType(String authenticationType) {
    this.authenticationType = authenticationType;
    return this;
  }

  /**
   * Authentication type.
   * @return authenticationType
   */
  @javax.annotation.Nullable
  public String getAuthenticationType() {
    return authenticationType;
  }

  public void setAuthenticationType(String authenticationType) {
    this.authenticationType = authenticationType;
  }


  public ImportExportDatabaseDefinition databaseName(String databaseName) {
    this.databaseName = databaseName;
    return this;
  }

  /**
   * Name of the import database.
   * @return databaseName
   */
  @javax.annotation.Nullable
  public String getDatabaseName() {
    return databaseName;
  }

  public void setDatabaseName(String databaseName) {
    this.databaseName = databaseName;
  }


  public ImportExportDatabaseDefinition edition(String edition) {
    this.edition = edition;
    return this;
  }

  /**
   * Edition of the import database.
   * @return edition
   */
  @javax.annotation.Nullable
  public String getEdition() {
    return edition;
  }

  public void setEdition(String edition) {
    this.edition = edition;
  }


  public ImportExportDatabaseDefinition maxSizeBytes(String maxSizeBytes) {
    this.maxSizeBytes = maxSizeBytes;
    return this;
  }

  /**
   * Max size in bytes for the import database.
   * @return maxSizeBytes
   */
  @javax.annotation.Nullable
  public String getMaxSizeBytes() {
    return maxSizeBytes;
  }

  public void setMaxSizeBytes(String maxSizeBytes) {
    this.maxSizeBytes = maxSizeBytes;
  }


  public ImportExportDatabaseDefinition serviceObjectiveName(String serviceObjectiveName) {
    this.serviceObjectiveName = serviceObjectiveName;
    return this;
  }

  /**
   * Service level objective name of the import database.
   * @return serviceObjectiveName
   */
  @javax.annotation.Nullable
  public String getServiceObjectiveName() {
    return serviceObjectiveName;
  }

  public void setServiceObjectiveName(String serviceObjectiveName) {
    this.serviceObjectiveName = serviceObjectiveName;
  }


  public ImportExportDatabaseDefinition storageKey(String storageKey) {
    this.storageKey = storageKey;
    return this;
  }

  /**
   * Storage key.
   * @return storageKey
   */
  @javax.annotation.Nonnull
  public String getStorageKey() {
    return storageKey;
  }

  public void setStorageKey(String storageKey) {
    this.storageKey = storageKey;
  }


  public ImportExportDatabaseDefinition storageKeyType(String storageKeyType) {
    this.storageKeyType = storageKeyType;
    return this;
  }

  /**
   * Storage key type.
   * @return storageKeyType
   */
  @javax.annotation.Nonnull
  public String getStorageKeyType() {
    return storageKeyType;
  }

  public void setStorageKeyType(String storageKeyType) {
    this.storageKeyType = storageKeyType;
  }


  public ImportExportDatabaseDefinition storageUri(String storageUri) {
    this.storageUri = storageUri;
    return this;
  }

  /**
   * Storage Uri.
   * @return storageUri
   */
  @javax.annotation.Nonnull
  public String getStorageUri() {
    return storageUri;
  }

  public void setStorageUri(String storageUri) {
    this.storageUri = storageUri;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ImportExportDatabaseDefinition importExportDatabaseDefinition = (ImportExportDatabaseDefinition) o;
    return Objects.equals(this.administratorLogin, importExportDatabaseDefinition.administratorLogin) &&
        Objects.equals(this.administratorLoginPassword, importExportDatabaseDefinition.administratorLoginPassword) &&
        Objects.equals(this.authenticationType, importExportDatabaseDefinition.authenticationType) &&
        Objects.equals(this.databaseName, importExportDatabaseDefinition.databaseName) &&
        Objects.equals(this.edition, importExportDatabaseDefinition.edition) &&
        Objects.equals(this.maxSizeBytes, importExportDatabaseDefinition.maxSizeBytes) &&
        Objects.equals(this.serviceObjectiveName, importExportDatabaseDefinition.serviceObjectiveName) &&
        Objects.equals(this.storageKey, importExportDatabaseDefinition.storageKey) &&
        Objects.equals(this.storageKeyType, importExportDatabaseDefinition.storageKeyType) &&
        Objects.equals(this.storageUri, importExportDatabaseDefinition.storageUri);
  }

  @Override
  public int hashCode() {
    return Objects.hash(administratorLogin, administratorLoginPassword, authenticationType, databaseName, edition, maxSizeBytes, serviceObjectiveName, storageKey, storageKeyType, storageUri);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ImportExportDatabaseDefinition {\n");
    sb.append("    administratorLogin: ").append(toIndentedString(administratorLogin)).append("\n");
    sb.append("    administratorLoginPassword: ").append(toIndentedString(administratorLoginPassword)).append("\n");
    sb.append("    authenticationType: ").append(toIndentedString(authenticationType)).append("\n");
    sb.append("    databaseName: ").append(toIndentedString(databaseName)).append("\n");
    sb.append("    edition: ").append(toIndentedString(edition)).append("\n");
    sb.append("    maxSizeBytes: ").append(toIndentedString(maxSizeBytes)).append("\n");
    sb.append("    serviceObjectiveName: ").append(toIndentedString(serviceObjectiveName)).append("\n");
    sb.append("    storageKey: ").append(toIndentedString(storageKey)).append("\n");
    sb.append("    storageKeyType: ").append(toIndentedString(storageKeyType)).append("\n");
    sb.append("    storageUri: ").append(toIndentedString(storageUri)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("administratorLogin");
    openapiFields.add("administratorLoginPassword");
    openapiFields.add("authenticationType");
    openapiFields.add("databaseName");
    openapiFields.add("edition");
    openapiFields.add("maxSizeBytes");
    openapiFields.add("serviceObjectiveName");
    openapiFields.add("storageKey");
    openapiFields.add("storageKeyType");
    openapiFields.add("storageUri");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("administratorLogin");
    openapiRequiredFields.add("administratorLoginPassword");
    openapiRequiredFields.add("storageKey");
    openapiRequiredFields.add("storageKeyType");
    openapiRequiredFields.add("storageUri");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ImportExportDatabaseDefinition
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ImportExportDatabaseDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ImportExportDatabaseDefinition is not found in the empty JSON string", ImportExportDatabaseDefinition.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ImportExportDatabaseDefinition.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ImportExportDatabaseDefinition` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ImportExportDatabaseDefinition.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("administratorLogin").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `administratorLogin` to be a primitive type in the JSON string but got `%s`", jsonObj.get("administratorLogin").toString()));
      }
      if (!jsonObj.get("administratorLoginPassword").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `administratorLoginPassword` to be a primitive type in the JSON string but got `%s`", jsonObj.get("administratorLoginPassword").toString()));
      }
      if ((jsonObj.get("authenticationType") != null && !jsonObj.get("authenticationType").isJsonNull()) && !jsonObj.get("authenticationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authenticationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authenticationType").toString()));
      }
      if ((jsonObj.get("databaseName") != null && !jsonObj.get("databaseName").isJsonNull()) && !jsonObj.get("databaseName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseName").toString()));
      }
      if ((jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) && !jsonObj.get("edition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `edition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("edition").toString()));
      }
      if ((jsonObj.get("maxSizeBytes") != null && !jsonObj.get("maxSizeBytes").isJsonNull()) && !jsonObj.get("maxSizeBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxSizeBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxSizeBytes").toString()));
      }
      if ((jsonObj.get("serviceObjectiveName") != null && !jsonObj.get("serviceObjectiveName").isJsonNull()) && !jsonObj.get("serviceObjectiveName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceObjectiveName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceObjectiveName").toString()));
      }
      if (!jsonObj.get("storageKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageKey").toString()));
      }
      if (!jsonObj.get("storageKeyType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageKeyType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageKeyType").toString()));
      }
      if (!jsonObj.get("storageUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageUri").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ImportExportDatabaseDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ImportExportDatabaseDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ImportExportDatabaseDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ImportExportDatabaseDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<ImportExportDatabaseDefinition>() {
           @Override
           public void write(JsonWriter out, ImportExportDatabaseDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ImportExportDatabaseDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ImportExportDatabaseDefinition given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ImportExportDatabaseDefinition
   * @throws IOException if the JSON string is invalid with respect to ImportExportDatabaseDefinition
   */
  public static ImportExportDatabaseDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ImportExportDatabaseDefinition.class);
  }

  /**
   * Convert an instance of ImportExportDatabaseDefinition to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

