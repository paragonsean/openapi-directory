/**
 * Storage Cache Mgmt Client
 * A Storage Cache provides scalable caching service for NAS clients, serving data from either NFSv3 or Blob at-rest storage (referred to as \"Storage Targets\"). These operations allow you to manage caches.
 *
 * The version of the OpenAPI document: 2019-08-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICache_properties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICache_properties::OAICache_properties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICache_properties::OAICache_properties() {
    this->initializeModel();
}

OAICache_properties::~OAICache_properties() {}

void OAICache_properties::initializeModel() {

    m_cache_size_gb_isSet = false;
    m_cache_size_gb_isValid = false;

    m_health_isSet = false;
    m_health_isValid = false;

    m_mount_addresses_isSet = false;
    m_mount_addresses_isValid = false;

    m_provisioning_state_isSet = false;
    m_provisioning_state_isValid = false;

    m_subnet_isSet = false;
    m_subnet_isValid = false;

    m_upgrade_status_isSet = false;
    m_upgrade_status_isValid = false;
}

void OAICache_properties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICache_properties::fromJsonObject(QJsonObject json) {

    m_cache_size_gb_isValid = ::OpenAPI::fromJsonValue(m_cache_size_gb, json[QString("cacheSizeGB")]);
    m_cache_size_gb_isSet = !json[QString("cacheSizeGB")].isNull() && m_cache_size_gb_isValid;

    m_health_isValid = ::OpenAPI::fromJsonValue(m_health, json[QString("health")]);
    m_health_isSet = !json[QString("health")].isNull() && m_health_isValid;

    m_mount_addresses_isValid = ::OpenAPI::fromJsonValue(m_mount_addresses, json[QString("mountAddresses")]);
    m_mount_addresses_isSet = !json[QString("mountAddresses")].isNull() && m_mount_addresses_isValid;

    m_provisioning_state_isValid = ::OpenAPI::fromJsonValue(m_provisioning_state, json[QString("provisioningState")]);
    m_provisioning_state_isSet = !json[QString("provisioningState")].isNull() && m_provisioning_state_isValid;

    m_subnet_isValid = ::OpenAPI::fromJsonValue(m_subnet, json[QString("subnet")]);
    m_subnet_isSet = !json[QString("subnet")].isNull() && m_subnet_isValid;

    m_upgrade_status_isValid = ::OpenAPI::fromJsonValue(m_upgrade_status, json[QString("upgradeStatus")]);
    m_upgrade_status_isSet = !json[QString("upgradeStatus")].isNull() && m_upgrade_status_isValid;
}

QString OAICache_properties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICache_properties::asJsonObject() const {
    QJsonObject obj;
    if (m_cache_size_gb_isSet) {
        obj.insert(QString("cacheSizeGB"), ::OpenAPI::toJsonValue(m_cache_size_gb));
    }
    if (m_health.isSet()) {
        obj.insert(QString("health"), ::OpenAPI::toJsonValue(m_health));
    }
    if (m_mount_addresses.size() > 0) {
        obj.insert(QString("mountAddresses"), ::OpenAPI::toJsonValue(m_mount_addresses));
    }
    if (m_provisioning_state_isSet) {
        obj.insert(QString("provisioningState"), ::OpenAPI::toJsonValue(m_provisioning_state));
    }
    if (m_subnet_isSet) {
        obj.insert(QString("subnet"), ::OpenAPI::toJsonValue(m_subnet));
    }
    if (m_upgrade_status.isSet()) {
        obj.insert(QString("upgradeStatus"), ::OpenAPI::toJsonValue(m_upgrade_status));
    }
    return obj;
}

qint32 OAICache_properties::getCacheSizeGb() const {
    return m_cache_size_gb;
}
void OAICache_properties::setCacheSizeGb(const qint32 &cache_size_gb) {
    m_cache_size_gb = cache_size_gb;
    m_cache_size_gb_isSet = true;
}

bool OAICache_properties::is_cache_size_gb_Set() const{
    return m_cache_size_gb_isSet;
}

bool OAICache_properties::is_cache_size_gb_Valid() const{
    return m_cache_size_gb_isValid;
}

OAICacheHealth OAICache_properties::getHealth() const {
    return m_health;
}
void OAICache_properties::setHealth(const OAICacheHealth &health) {
    m_health = health;
    m_health_isSet = true;
}

bool OAICache_properties::is_health_Set() const{
    return m_health_isSet;
}

bool OAICache_properties::is_health_Valid() const{
    return m_health_isValid;
}

QList<QString> OAICache_properties::getMountAddresses() const {
    return m_mount_addresses;
}
void OAICache_properties::setMountAddresses(const QList<QString> &mount_addresses) {
    m_mount_addresses = mount_addresses;
    m_mount_addresses_isSet = true;
}

bool OAICache_properties::is_mount_addresses_Set() const{
    return m_mount_addresses_isSet;
}

bool OAICache_properties::is_mount_addresses_Valid() const{
    return m_mount_addresses_isValid;
}

QString OAICache_properties::getProvisioningState() const {
    return m_provisioning_state;
}
void OAICache_properties::setProvisioningState(const QString &provisioning_state) {
    m_provisioning_state = provisioning_state;
    m_provisioning_state_isSet = true;
}

bool OAICache_properties::is_provisioning_state_Set() const{
    return m_provisioning_state_isSet;
}

bool OAICache_properties::is_provisioning_state_Valid() const{
    return m_provisioning_state_isValid;
}

QString OAICache_properties::getSubnet() const {
    return m_subnet;
}
void OAICache_properties::setSubnet(const QString &subnet) {
    m_subnet = subnet;
    m_subnet_isSet = true;
}

bool OAICache_properties::is_subnet_Set() const{
    return m_subnet_isSet;
}

bool OAICache_properties::is_subnet_Valid() const{
    return m_subnet_isValid;
}

OAICacheUpgradeStatus OAICache_properties::getUpgradeStatus() const {
    return m_upgrade_status;
}
void OAICache_properties::setUpgradeStatus(const OAICacheUpgradeStatus &upgrade_status) {
    m_upgrade_status = upgrade_status;
    m_upgrade_status_isSet = true;
}

bool OAICache_properties::is_upgrade_status_Set() const{
    return m_upgrade_status_isSet;
}

bool OAICache_properties::is_upgrade_status_Valid() const{
    return m_upgrade_status_isValid;
}

bool OAICache_properties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cache_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_mount_addresses.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_provisioning_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_subnet_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_upgrade_status.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICache_properties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
