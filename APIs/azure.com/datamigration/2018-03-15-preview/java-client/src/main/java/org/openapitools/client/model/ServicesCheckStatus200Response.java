/*
 * Azure Data Migration Service Resource Provider
 * The Data Migration Service helps people migrate their data from on-premise database servers to Azure, or from older database software to newer software. The service manages one or more workers that are joined to a customer's virtual network, which is assumed to provide connectivity to their databases. To avoid frequent updates to the resource provider, data migration tasks are implemented by the resource provider in a generic way as task resources, each of which has a task type (which identifies the type of work to run), input, and output. The client is responsible for providing appropriate task type and inputs, which will be passed through unexamined to the machines that implement the functionality, and for understanding the output, which is passed back unexamined to the client.
 *
 * The version of the OpenAPI document: 2018-03-15-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Service health status
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:16:11.347572-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ServicesCheckStatus200Response {
  public static final String SERIALIZED_NAME_AGENT_VERSION = "agentVersion";
  @SerializedName(SERIALIZED_NAME_AGENT_VERSION)
  private String agentVersion;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_SUPPORTED_TASK_TYPES = "supportedTaskTypes";
  @SerializedName(SERIALIZED_NAME_SUPPORTED_TASK_TYPES)
  private List<String> supportedTaskTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_VM_SIZE = "vmSize";
  @SerializedName(SERIALIZED_NAME_VM_SIZE)
  private String vmSize;

  public ServicesCheckStatus200Response() {
  }

  public ServicesCheckStatus200Response agentVersion(String agentVersion) {
    this.agentVersion = agentVersion;
    return this;
  }

  /**
   * The DMS instance agent version
   * @return agentVersion
   */
  @javax.annotation.Nullable
  public String getAgentVersion() {
    return agentVersion;
  }

  public void setAgentVersion(String agentVersion) {
    this.agentVersion = agentVersion;
  }


  public ServicesCheckStatus200Response status(String status) {
    this.status = status;
    return this;
  }

  /**
   * The machine-readable status, such as &#39;Initializing&#39;, &#39;Offline&#39;, &#39;Online&#39;, &#39;Deploying&#39;, &#39;Deleting&#39;, &#39;Stopped&#39;, &#39;Stopping&#39;, &#39;Starting&#39;, &#39;FailedToStart&#39;, &#39;FailedToStop&#39; or &#39;Failed&#39;
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public ServicesCheckStatus200Response supportedTaskTypes(List<String> supportedTaskTypes) {
    this.supportedTaskTypes = supportedTaskTypes;
    return this;
  }

  public ServicesCheckStatus200Response addSupportedTaskTypesItem(String supportedTaskTypesItem) {
    if (this.supportedTaskTypes == null) {
      this.supportedTaskTypes = new ArrayList<>();
    }
    this.supportedTaskTypes.add(supportedTaskTypesItem);
    return this;
  }

  /**
   * The list of supported task types
   * @return supportedTaskTypes
   */
  @javax.annotation.Nullable
  public List<String> getSupportedTaskTypes() {
    return supportedTaskTypes;
  }

  public void setSupportedTaskTypes(List<String> supportedTaskTypes) {
    this.supportedTaskTypes = supportedTaskTypes;
  }


  public ServicesCheckStatus200Response vmSize(String vmSize) {
    this.vmSize = vmSize;
    return this;
  }

  /**
   * The services virtual machine size, such as &#39;Standard_D2_v2&#39;
   * @return vmSize
   */
  @javax.annotation.Nullable
  public String getVmSize() {
    return vmSize;
  }

  public void setVmSize(String vmSize) {
    this.vmSize = vmSize;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServicesCheckStatus200Response servicesCheckStatus200Response = (ServicesCheckStatus200Response) o;
    return Objects.equals(this.agentVersion, servicesCheckStatus200Response.agentVersion) &&
        Objects.equals(this.status, servicesCheckStatus200Response.status) &&
        Objects.equals(this.supportedTaskTypes, servicesCheckStatus200Response.supportedTaskTypes) &&
        Objects.equals(this.vmSize, servicesCheckStatus200Response.vmSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(agentVersion, status, supportedTaskTypes, vmSize);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServicesCheckStatus200Response {\n");
    sb.append("    agentVersion: ").append(toIndentedString(agentVersion)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    supportedTaskTypes: ").append(toIndentedString(supportedTaskTypes)).append("\n");
    sb.append("    vmSize: ").append(toIndentedString(vmSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("agentVersion");
    openapiFields.add("status");
    openapiFields.add("supportedTaskTypes");
    openapiFields.add("vmSize");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ServicesCheckStatus200Response
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ServicesCheckStatus200Response.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ServicesCheckStatus200Response is not found in the empty JSON string", ServicesCheckStatus200Response.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ServicesCheckStatus200Response.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ServicesCheckStatus200Response` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("agentVersion") != null && !jsonObj.get("agentVersion").isJsonNull()) && !jsonObj.get("agentVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `agentVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("agentVersion").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("supportedTaskTypes") != null && !jsonObj.get("supportedTaskTypes").isJsonNull() && !jsonObj.get("supportedTaskTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `supportedTaskTypes` to be an array in the JSON string but got `%s`", jsonObj.get("supportedTaskTypes").toString()));
      }
      if ((jsonObj.get("vmSize") != null && !jsonObj.get("vmSize").isJsonNull()) && !jsonObj.get("vmSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vmSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vmSize").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ServicesCheckStatus200Response.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ServicesCheckStatus200Response' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ServicesCheckStatus200Response> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ServicesCheckStatus200Response.class));

       return (TypeAdapter<T>) new TypeAdapter<ServicesCheckStatus200Response>() {
           @Override
           public void write(JsonWriter out, ServicesCheckStatus200Response value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ServicesCheckStatus200Response read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ServicesCheckStatus200Response given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ServicesCheckStatus200Response
   * @throws IOException if the JSON string is invalid with respect to ServicesCheckStatus200Response
   */
  public static ServicesCheckStatus200Response fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ServicesCheckStatus200Response.class);
  }

  /**
   * Convert an instance of ServicesCheckStatus200Response to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

