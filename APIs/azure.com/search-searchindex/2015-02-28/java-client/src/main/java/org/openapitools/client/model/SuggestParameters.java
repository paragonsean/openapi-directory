/*
 * SearchIndexClient
 * Client that can be used to query an Azure Search index and upload, merge, or delete documents.
 *
 * The version of the OpenAPI document: 2015-02-28
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters for filtering, sorting, fuzzy matching, and other suggestions query behaviors.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:12:16.514564-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SuggestParameters {
  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_HIGHLIGHT_POST_TAG = "highlightPostTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_POST_TAG)
  private String highlightPostTag;

  public static final String SERIALIZED_NAME_HIGHLIGHT_PRE_TAG = "highlightPreTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_PRE_TAG)
  private String highlightPreTag;

  public static final String SERIALIZED_NAME_MINIMUM_COVERAGE = "minimumCoverage";
  @SerializedName(SERIALIZED_NAME_MINIMUM_COVERAGE)
  private Double minimumCoverage;

  public static final String SERIALIZED_NAME_ORDER_BY = "orderBy";
  @SerializedName(SERIALIZED_NAME_ORDER_BY)
  private List<String> orderBy = new ArrayList<>();

  public static final String SERIALIZED_NAME_SEARCH_FIELDS = "searchFields";
  @SerializedName(SERIALIZED_NAME_SEARCH_FIELDS)
  private List<String> searchFields = new ArrayList<>();

  public static final String SERIALIZED_NAME_SELECT = "select";
  @SerializedName(SERIALIZED_NAME_SELECT)
  private List<String> select = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOP = "top";
  @SerializedName(SERIALIZED_NAME_TOP)
  private Integer top;

  public static final String SERIALIZED_NAME_USE_FUZZY_MATCHING = "useFuzzyMatching";
  @SerializedName(SERIALIZED_NAME_USE_FUZZY_MATCHING)
  private Boolean useFuzzyMatching;

  public SuggestParameters() {
  }

  public SuggestParameters filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * Gets or sets the OData $filter expression to apply to the suggestions query.
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public SuggestParameters highlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
    return this;
  }

  /**
   * Gets or sets a string tag that is appended to hit highlights. Must be set with HighlightPreTag. If omitted, hit highlighting of suggestions is disabled.
   * @return highlightPostTag
   */
  @javax.annotation.Nullable
  public String getHighlightPostTag() {
    return highlightPostTag;
  }

  public void setHighlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
  }


  public SuggestParameters highlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
    return this;
  }

  /**
   * Gets or sets a string tag that is prepended to hit highlights. Must be set with HighlightPostTag. If omitted, hit highlighting of suggestions is disabled.
   * @return highlightPreTag
   */
  @javax.annotation.Nullable
  public String getHighlightPreTag() {
    return highlightPreTag;
  }

  public void setHighlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
  }


  public SuggestParameters minimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
    return this;
  }

  /**
   * Gets or sets a number between 0 and 100 indicating the percentage of the index that must be covered by a suggestion query in order for the query to be reported as a success. This parameter can be useful for ensuring search availability even for services with only one replica. The default is 80.
   * @return minimumCoverage
   */
  @javax.annotation.Nullable
  public Double getMinimumCoverage() {
    return minimumCoverage;
  }

  public void setMinimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
  }


  public SuggestParameters orderBy(List<String> orderBy) {
    this.orderBy = orderBy;
    return this;
  }

  public SuggestParameters addOrderByItem(String orderByItem) {
    if (this.orderBy == null) {
      this.orderBy = new ArrayList<>();
    }
    this.orderBy.add(orderByItem);
    return this;
  }

  /**
   * Gets or sets the list of OData $orderby expressions by which to sort the results. Each expression can be either a field name or a call to the geo.distance() function. Each expression can be followed by asc to indicate ascending, and desc to indicate descending. The default is ascending order. Ties will be broken by the match scores of documents. If no OrderBy is specified, the default sort order is descending by document match score. There can be at most 32 Orderby clauses.
   * @return orderBy
   */
  @javax.annotation.Nullable
  public List<String> getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(List<String> orderBy) {
    this.orderBy = orderBy;
  }


  public SuggestParameters searchFields(List<String> searchFields) {
    this.searchFields = searchFields;
    return this;
  }

  public SuggestParameters addSearchFieldsItem(String searchFieldsItem) {
    if (this.searchFields == null) {
      this.searchFields = new ArrayList<>();
    }
    this.searchFields.add(searchFieldsItem);
    return this;
  }

  /**
   * Gets or sets the list of field names to consider when querying for suggestions.
   * @return searchFields
   */
  @javax.annotation.Nullable
  public List<String> getSearchFields() {
    return searchFields;
  }

  public void setSearchFields(List<String> searchFields) {
    this.searchFields = searchFields;
  }


  public SuggestParameters select(List<String> select) {
    this.select = select;
    return this;
  }

  public SuggestParameters addSelectItem(String selectItem) {
    if (this.select == null) {
      this.select = new ArrayList<>();
    }
    this.select.add(selectItem);
    return this;
  }

  /**
   * Gets or sets the list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema are included.
   * @return select
   */
  @javax.annotation.Nullable
  public List<String> getSelect() {
    return select;
  }

  public void setSelect(List<String> select) {
    this.select = select;
  }


  public SuggestParameters top(Integer top) {
    this.top = top;
    return this;
  }

  /**
   * Gets or sets the number of suggestions to retrieve. This must be a value between 1 and 100. The default is to 5.
   * @return top
   */
  @javax.annotation.Nullable
  public Integer getTop() {
    return top;
  }

  public void setTop(Integer top) {
    this.top = top;
  }


  public SuggestParameters useFuzzyMatching(Boolean useFuzzyMatching) {
    this.useFuzzyMatching = useFuzzyMatching;
    return this;
  }

  /**
   * Gets or sets a value indicating whether to use fuzzy matching for the suggestion query. Default is false. when set to true, the query will find suggestions even if there&#39;s a substituted or missing character in the search text. While this provides a better experience in some scenarios it comes at a performance cost as fuzzy suggestion searches are slower and consume more resources.
   * @return useFuzzyMatching
   */
  @javax.annotation.Nullable
  public Boolean getUseFuzzyMatching() {
    return useFuzzyMatching;
  }

  public void setUseFuzzyMatching(Boolean useFuzzyMatching) {
    this.useFuzzyMatching = useFuzzyMatching;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SuggestParameters suggestParameters = (SuggestParameters) o;
    return Objects.equals(this.filter, suggestParameters.filter) &&
        Objects.equals(this.highlightPostTag, suggestParameters.highlightPostTag) &&
        Objects.equals(this.highlightPreTag, suggestParameters.highlightPreTag) &&
        Objects.equals(this.minimumCoverage, suggestParameters.minimumCoverage) &&
        Objects.equals(this.orderBy, suggestParameters.orderBy) &&
        Objects.equals(this.searchFields, suggestParameters.searchFields) &&
        Objects.equals(this.select, suggestParameters.select) &&
        Objects.equals(this.top, suggestParameters.top) &&
        Objects.equals(this.useFuzzyMatching, suggestParameters.useFuzzyMatching);
  }

  @Override
  public int hashCode() {
    return Objects.hash(filter, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, searchFields, select, top, useFuzzyMatching);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SuggestParameters {\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    highlightPostTag: ").append(toIndentedString(highlightPostTag)).append("\n");
    sb.append("    highlightPreTag: ").append(toIndentedString(highlightPreTag)).append("\n");
    sb.append("    minimumCoverage: ").append(toIndentedString(minimumCoverage)).append("\n");
    sb.append("    orderBy: ").append(toIndentedString(orderBy)).append("\n");
    sb.append("    searchFields: ").append(toIndentedString(searchFields)).append("\n");
    sb.append("    select: ").append(toIndentedString(select)).append("\n");
    sb.append("    top: ").append(toIndentedString(top)).append("\n");
    sb.append("    useFuzzyMatching: ").append(toIndentedString(useFuzzyMatching)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("filter");
    openapiFields.add("highlightPostTag");
    openapiFields.add("highlightPreTag");
    openapiFields.add("minimumCoverage");
    openapiFields.add("orderBy");
    openapiFields.add("searchFields");
    openapiFields.add("select");
    openapiFields.add("top");
    openapiFields.add("useFuzzyMatching");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SuggestParameters
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SuggestParameters.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SuggestParameters is not found in the empty JSON string", SuggestParameters.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SuggestParameters.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SuggestParameters` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      if ((jsonObj.get("highlightPostTag") != null && !jsonObj.get("highlightPostTag").isJsonNull()) && !jsonObj.get("highlightPostTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPostTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPostTag").toString()));
      }
      if ((jsonObj.get("highlightPreTag") != null && !jsonObj.get("highlightPreTag").isJsonNull()) && !jsonObj.get("highlightPreTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPreTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPreTag").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("orderBy") != null && !jsonObj.get("orderBy").isJsonNull() && !jsonObj.get("orderBy").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderBy` to be an array in the JSON string but got `%s`", jsonObj.get("orderBy").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("searchFields") != null && !jsonObj.get("searchFields").isJsonNull() && !jsonObj.get("searchFields").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchFields` to be an array in the JSON string but got `%s`", jsonObj.get("searchFields").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("select") != null && !jsonObj.get("select").isJsonNull() && !jsonObj.get("select").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `select` to be an array in the JSON string but got `%s`", jsonObj.get("select").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SuggestParameters.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SuggestParameters' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SuggestParameters> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SuggestParameters.class));

       return (TypeAdapter<T>) new TypeAdapter<SuggestParameters>() {
           @Override
           public void write(JsonWriter out, SuggestParameters value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SuggestParameters read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SuggestParameters given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SuggestParameters
   * @throws IOException if the JSON string is invalid with respect to SuggestParameters
   */
  public static SuggestParameters fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SuggestParameters.class);
  }

  /**
   * Convert an instance of SuggestParameters to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

