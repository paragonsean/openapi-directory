/*
 * SearchIndexClient
 * Client that can be used to query an Azure Search index and upload, merge, or delete documents.
 *
 * The version of the OpenAPI document: 2015-02-28
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.QueryType;
import org.openapitools.client.model.SearchMode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters for filtering, sorting, faceting, paging, and other search query behaviors.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:12:16.514564-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SearchParameters {
  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_HIGHLIGHT_FIELDS = "highlightFields";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_FIELDS)
  private List<String> highlightFields = new ArrayList<>();

  public static final String SERIALIZED_NAME_HIGHLIGHT_POST_TAG = "highlightPostTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_POST_TAG)
  private String highlightPostTag;

  public static final String SERIALIZED_NAME_HIGHLIGHT_PRE_TAG = "highlightPreTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_PRE_TAG)
  private String highlightPreTag;

  public static final String SERIALIZED_NAME_INCLUDE_TOTAL_RESULT_COUNT = "includeTotalResultCount";
  @SerializedName(SERIALIZED_NAME_INCLUDE_TOTAL_RESULT_COUNT)
  private Boolean includeTotalResultCount;

  public static final String SERIALIZED_NAME_MINIMUM_COVERAGE = "minimumCoverage";
  @SerializedName(SERIALIZED_NAME_MINIMUM_COVERAGE)
  private Double minimumCoverage;

  public static final String SERIALIZED_NAME_ORDER_BY = "orderBy";
  @SerializedName(SERIALIZED_NAME_ORDER_BY)
  private List<String> orderBy = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUERY_TYPE = "queryType";
  @SerializedName(SERIALIZED_NAME_QUERY_TYPE)
  private QueryType queryType;

  public static final String SERIALIZED_NAME_SCORING_PARAMETERS = "scoringParameters";
  @SerializedName(SERIALIZED_NAME_SCORING_PARAMETERS)
  private List<String> scoringParameters = new ArrayList<>();

  public static final String SERIALIZED_NAME_SCORING_PROFILE = "scoringProfile";
  @SerializedName(SERIALIZED_NAME_SCORING_PROFILE)
  private String scoringProfile;

  public static final String SERIALIZED_NAME_SEARCH_FIELDS = "searchFields";
  @SerializedName(SERIALIZED_NAME_SEARCH_FIELDS)
  private List<String> searchFields = new ArrayList<>();

  public static final String SERIALIZED_NAME_SEARCH_MODE = "searchMode";
  @SerializedName(SERIALIZED_NAME_SEARCH_MODE)
  private SearchMode searchMode;

  public static final String SERIALIZED_NAME_SELECT = "select";
  @SerializedName(SERIALIZED_NAME_SELECT)
  private List<String> select = new ArrayList<>();

  public static final String SERIALIZED_NAME_SKIP = "skip";
  @SerializedName(SERIALIZED_NAME_SKIP)
  private Integer skip;

  public static final String SERIALIZED_NAME_TOP = "top";
  @SerializedName(SERIALIZED_NAME_TOP)
  private Integer top;

  public SearchParameters() {
  }

  public SearchParameters filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * Gets or sets the OData $filter expression to apply to the search query.
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public SearchParameters highlightFields(List<String> highlightFields) {
    this.highlightFields = highlightFields;
    return this;
  }

  public SearchParameters addHighlightFieldsItem(String highlightFieldsItem) {
    if (this.highlightFields == null) {
      this.highlightFields = new ArrayList<>();
    }
    this.highlightFields.add(highlightFieldsItem);
    return this;
  }

  /**
   * Gets or sets the list of field names to use for hit highlights. Only searchable fields can be used for hit highlighting.
   * @return highlightFields
   */
  @javax.annotation.Nullable
  public List<String> getHighlightFields() {
    return highlightFields;
  }

  public void setHighlightFields(List<String> highlightFields) {
    this.highlightFields = highlightFields;
  }


  public SearchParameters highlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
    return this;
  }

  /**
   * Gets or sets a string tag that is appended to hit highlights. Must be set with HighlightPreTag. Default is &amp;lt;/em&amp;gt;.
   * @return highlightPostTag
   */
  @javax.annotation.Nullable
  public String getHighlightPostTag() {
    return highlightPostTag;
  }

  public void setHighlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
  }


  public SearchParameters highlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
    return this;
  }

  /**
   * Gets or sets a string tag that is prepended to hit highlights. Must be set with HighlightPostTag. Default is &amp;lt;em&amp;gt;.
   * @return highlightPreTag
   */
  @javax.annotation.Nullable
  public String getHighlightPreTag() {
    return highlightPreTag;
  }

  public void setHighlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
  }


  public SearchParameters includeTotalResultCount(Boolean includeTotalResultCount) {
    this.includeTotalResultCount = includeTotalResultCount;
    return this;
  }

  /**
   * Gets or sets a value that specifies whether to fetch the total count of results. Default is false. Setting this value to true may have a performance impact. Note that the count returned is an approximation.
   * @return includeTotalResultCount
   */
  @javax.annotation.Nullable
  public Boolean getIncludeTotalResultCount() {
    return includeTotalResultCount;
  }

  public void setIncludeTotalResultCount(Boolean includeTotalResultCount) {
    this.includeTotalResultCount = includeTotalResultCount;
  }


  public SearchParameters minimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
    return this;
  }

  /**
   * Gets or sets a number between 0 and 100 indicating the percentage of the index that must be covered by a search query in order for the query to be reported as a success. This parameter can be useful for ensuring search availability even for services with only one replica. The default is 100.
   * @return minimumCoverage
   */
  @javax.annotation.Nullable
  public Double getMinimumCoverage() {
    return minimumCoverage;
  }

  public void setMinimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
  }


  public SearchParameters orderBy(List<String> orderBy) {
    this.orderBy = orderBy;
    return this;
  }

  public SearchParameters addOrderByItem(String orderByItem) {
    if (this.orderBy == null) {
      this.orderBy = new ArrayList<>();
    }
    this.orderBy.add(orderByItem);
    return this;
  }

  /**
   * Gets or sets the list of OData $orderby expressions by which to sort the results. Each expression can be either a field name or a call to the geo.distance() function. Each expression can be followed by asc to indicate ascending, and desc to indicate descending. The default is ascending order. Ties will be broken by the match scores of documents. If no OrderBy is specified, the default sort order is descending by document match score. There can be at most 32 Orderby clauses.
   * @return orderBy
   */
  @javax.annotation.Nullable
  public List<String> getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(List<String> orderBy) {
    this.orderBy = orderBy;
  }


  public SearchParameters queryType(QueryType queryType) {
    this.queryType = queryType;
    return this;
  }

  /**
   * Get queryType
   * @return queryType
   */
  @javax.annotation.Nullable
  public QueryType getQueryType() {
    return queryType;
  }

  public void setQueryType(QueryType queryType) {
    this.queryType = queryType;
  }


  public SearchParameters scoringParameters(List<String> scoringParameters) {
    this.scoringParameters = scoringParameters;
    return this;
  }

  public SearchParameters addScoringParametersItem(String scoringParametersItem) {
    if (this.scoringParameters == null) {
      this.scoringParameters = new ArrayList<>();
    }
    this.scoringParameters.add(scoringParametersItem);
    return this;
  }

  /**
   * Gets or sets the list of parameter values to be used in scoring functions (for example, referencePointParameter) using the format name:value. For example, if the scoring profile defines a function with a parameter called &#39;mylocation&#39; the parameter string would be \&quot;mylocation:-122.2,44.8\&quot;(without the quotes).
   * @return scoringParameters
   */
  @javax.annotation.Nullable
  public List<String> getScoringParameters() {
    return scoringParameters;
  }

  public void setScoringParameters(List<String> scoringParameters) {
    this.scoringParameters = scoringParameters;
  }


  public SearchParameters scoringProfile(String scoringProfile) {
    this.scoringProfile = scoringProfile;
    return this;
  }

  /**
   * Gets or sets the name of a scoring profile to evaluate match scores for matching documents in order to sort the results.
   * @return scoringProfile
   */
  @javax.annotation.Nullable
  public String getScoringProfile() {
    return scoringProfile;
  }

  public void setScoringProfile(String scoringProfile) {
    this.scoringProfile = scoringProfile;
  }


  public SearchParameters searchFields(List<String> searchFields) {
    this.searchFields = searchFields;
    return this;
  }

  public SearchParameters addSearchFieldsItem(String searchFieldsItem) {
    if (this.searchFields == null) {
      this.searchFields = new ArrayList<>();
    }
    this.searchFields.add(searchFieldsItem);
    return this;
  }

  /**
   * Gets or sets the list of field names to include in the full-text search.
   * @return searchFields
   */
  @javax.annotation.Nullable
  public List<String> getSearchFields() {
    return searchFields;
  }

  public void setSearchFields(List<String> searchFields) {
    this.searchFields = searchFields;
  }


  public SearchParameters searchMode(SearchMode searchMode) {
    this.searchMode = searchMode;
    return this;
  }

  /**
   * Get searchMode
   * @return searchMode
   */
  @javax.annotation.Nullable
  public SearchMode getSearchMode() {
    return searchMode;
  }

  public void setSearchMode(SearchMode searchMode) {
    this.searchMode = searchMode;
  }


  public SearchParameters select(List<String> select) {
    this.select = select;
    return this;
  }

  public SearchParameters addSelectItem(String selectItem) {
    if (this.select == null) {
      this.select = new ArrayList<>();
    }
    this.select.add(selectItem);
    return this;
  }

  /**
   * Gets or sets the list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema are included.
   * @return select
   */
  @javax.annotation.Nullable
  public List<String> getSelect() {
    return select;
  }

  public void setSelect(List<String> select) {
    this.select = select;
  }


  public SearchParameters skip(Integer skip) {
    this.skip = skip;
    return this;
  }

  /**
   * Gets or sets the number of search results to skip. This value cannot be greater than 100,000. If you need to scan documents in sequence, but cannot use Skip due to this limitation, consider using OrderBy on a totally-ordered key and Filter with a range query instead.
   * @return skip
   */
  @javax.annotation.Nullable
  public Integer getSkip() {
    return skip;
  }

  public void setSkip(Integer skip) {
    this.skip = skip;
  }


  public SearchParameters top(Integer top) {
    this.top = top;
    return this;
  }

  /**
   * Gets or sets the number of search results to retrieve. This can be used in conjunction with Skip to implement client-side paging of search results. If results are truncated due to server-side paging, the response will include a continuation token that can be passed to ContinueSearch to retrieve the next page of results. See DocumentSearchResponse.ContinuationToken for more information.
   * @return top
   */
  @javax.annotation.Nullable
  public Integer getTop() {
    return top;
  }

  public void setTop(Integer top) {
    this.top = top;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchParameters searchParameters = (SearchParameters) o;
    return Objects.equals(this.filter, searchParameters.filter) &&
        Objects.equals(this.highlightFields, searchParameters.highlightFields) &&
        Objects.equals(this.highlightPostTag, searchParameters.highlightPostTag) &&
        Objects.equals(this.highlightPreTag, searchParameters.highlightPreTag) &&
        Objects.equals(this.includeTotalResultCount, searchParameters.includeTotalResultCount) &&
        Objects.equals(this.minimumCoverage, searchParameters.minimumCoverage) &&
        Objects.equals(this.orderBy, searchParameters.orderBy) &&
        Objects.equals(this.queryType, searchParameters.queryType) &&
        Objects.equals(this.scoringParameters, searchParameters.scoringParameters) &&
        Objects.equals(this.scoringProfile, searchParameters.scoringProfile) &&
        Objects.equals(this.searchFields, searchParameters.searchFields) &&
        Objects.equals(this.searchMode, searchParameters.searchMode) &&
        Objects.equals(this.select, searchParameters.select) &&
        Objects.equals(this.skip, searchParameters.skip) &&
        Objects.equals(this.top, searchParameters.top);
  }

  @Override
  public int hashCode() {
    return Objects.hash(filter, highlightFields, highlightPostTag, highlightPreTag, includeTotalResultCount, minimumCoverage, orderBy, queryType, scoringParameters, scoringProfile, searchFields, searchMode, select, skip, top);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchParameters {\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    highlightFields: ").append(toIndentedString(highlightFields)).append("\n");
    sb.append("    highlightPostTag: ").append(toIndentedString(highlightPostTag)).append("\n");
    sb.append("    highlightPreTag: ").append(toIndentedString(highlightPreTag)).append("\n");
    sb.append("    includeTotalResultCount: ").append(toIndentedString(includeTotalResultCount)).append("\n");
    sb.append("    minimumCoverage: ").append(toIndentedString(minimumCoverage)).append("\n");
    sb.append("    orderBy: ").append(toIndentedString(orderBy)).append("\n");
    sb.append("    queryType: ").append(toIndentedString(queryType)).append("\n");
    sb.append("    scoringParameters: ").append(toIndentedString(scoringParameters)).append("\n");
    sb.append("    scoringProfile: ").append(toIndentedString(scoringProfile)).append("\n");
    sb.append("    searchFields: ").append(toIndentedString(searchFields)).append("\n");
    sb.append("    searchMode: ").append(toIndentedString(searchMode)).append("\n");
    sb.append("    select: ").append(toIndentedString(select)).append("\n");
    sb.append("    skip: ").append(toIndentedString(skip)).append("\n");
    sb.append("    top: ").append(toIndentedString(top)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("filter");
    openapiFields.add("highlightFields");
    openapiFields.add("highlightPostTag");
    openapiFields.add("highlightPreTag");
    openapiFields.add("includeTotalResultCount");
    openapiFields.add("minimumCoverage");
    openapiFields.add("orderBy");
    openapiFields.add("queryType");
    openapiFields.add("scoringParameters");
    openapiFields.add("scoringProfile");
    openapiFields.add("searchFields");
    openapiFields.add("searchMode");
    openapiFields.add("select");
    openapiFields.add("skip");
    openapiFields.add("top");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SearchParameters
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SearchParameters.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SearchParameters is not found in the empty JSON string", SearchParameters.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SearchParameters.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SearchParameters` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("highlightFields") != null && !jsonObj.get("highlightFields").isJsonNull() && !jsonObj.get("highlightFields").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightFields` to be an array in the JSON string but got `%s`", jsonObj.get("highlightFields").toString()));
      }
      if ((jsonObj.get("highlightPostTag") != null && !jsonObj.get("highlightPostTag").isJsonNull()) && !jsonObj.get("highlightPostTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPostTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPostTag").toString()));
      }
      if ((jsonObj.get("highlightPreTag") != null && !jsonObj.get("highlightPreTag").isJsonNull()) && !jsonObj.get("highlightPreTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPreTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPreTag").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("orderBy") != null && !jsonObj.get("orderBy").isJsonNull() && !jsonObj.get("orderBy").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderBy` to be an array in the JSON string but got `%s`", jsonObj.get("orderBy").toString()));
      }
      // validate the optional field `queryType`
      if (jsonObj.get("queryType") != null && !jsonObj.get("queryType").isJsonNull()) {
        QueryType.validateJsonElement(jsonObj.get("queryType"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("scoringParameters") != null && !jsonObj.get("scoringParameters").isJsonNull() && !jsonObj.get("scoringParameters").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `scoringParameters` to be an array in the JSON string but got `%s`", jsonObj.get("scoringParameters").toString()));
      }
      if ((jsonObj.get("scoringProfile") != null && !jsonObj.get("scoringProfile").isJsonNull()) && !jsonObj.get("scoringProfile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scoringProfile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scoringProfile").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("searchFields") != null && !jsonObj.get("searchFields").isJsonNull() && !jsonObj.get("searchFields").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchFields` to be an array in the JSON string but got `%s`", jsonObj.get("searchFields").toString()));
      }
      // validate the optional field `searchMode`
      if (jsonObj.get("searchMode") != null && !jsonObj.get("searchMode").isJsonNull()) {
        SearchMode.validateJsonElement(jsonObj.get("searchMode"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("select") != null && !jsonObj.get("select").isJsonNull() && !jsonObj.get("select").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `select` to be an array in the JSON string but got `%s`", jsonObj.get("select").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SearchParameters.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SearchParameters' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SearchParameters> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SearchParameters.class));

       return (TypeAdapter<T>) new TypeAdapter<SearchParameters>() {
           @Override
           public void write(JsonWriter out, SearchParameters value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SearchParameters read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SearchParameters given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SearchParameters
   * @throws IOException if the JSON string is invalid with respect to SearchParameters
   */
  public static SearchParameters fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SearchParameters.class);
  }

  /**
   * Convert an instance of SearchParameters to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

