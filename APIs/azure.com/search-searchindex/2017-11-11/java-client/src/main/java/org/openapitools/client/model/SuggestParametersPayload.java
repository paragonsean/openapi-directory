/*
 * SearchIndexClient
 * Client that can be used to query an Azure Search index and upload, merge, or delete documents.
 *
 * The version of the OpenAPI document: 2017-11-11
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters for filtering, sorting, fuzzy matching, and other suggestions query behaviors.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:12:21.758847-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SuggestParametersPayload {
  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_FUZZY = "fuzzy";
  @SerializedName(SERIALIZED_NAME_FUZZY)
  private Boolean fuzzy;

  public static final String SERIALIZED_NAME_HIGHLIGHT_POST_TAG = "highlightPostTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_POST_TAG)
  private String highlightPostTag;

  public static final String SERIALIZED_NAME_HIGHLIGHT_PRE_TAG = "highlightPreTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_PRE_TAG)
  private String highlightPreTag;

  public static final String SERIALIZED_NAME_MINIMUM_COVERAGE = "minimumCoverage";
  @SerializedName(SERIALIZED_NAME_MINIMUM_COVERAGE)
  private Double minimumCoverage;

  public static final String SERIALIZED_NAME_ORDERBY = "orderby";
  @SerializedName(SERIALIZED_NAME_ORDERBY)
  private String orderby;

  public static final String SERIALIZED_NAME_SEARCH = "search";
  @SerializedName(SERIALIZED_NAME_SEARCH)
  private String search;

  public static final String SERIALIZED_NAME_SEARCH_FIELDS = "searchFields";
  @SerializedName(SERIALIZED_NAME_SEARCH_FIELDS)
  private String searchFields;

  public static final String SERIALIZED_NAME_SELECT = "select";
  @SerializedName(SERIALIZED_NAME_SELECT)
  private String select;

  public static final String SERIALIZED_NAME_SUGGESTER_NAME = "suggesterName";
  @SerializedName(SERIALIZED_NAME_SUGGESTER_NAME)
  private String suggesterName;

  public static final String SERIALIZED_NAME_TOP = "top";
  @SerializedName(SERIALIZED_NAME_TOP)
  private Integer top;

  public SuggestParametersPayload() {
  }

  public SuggestParametersPayload filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * The OData $filter expression to apply to the suggestions query.
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public SuggestParametersPayload fuzzy(Boolean fuzzy) {
    this.fuzzy = fuzzy;
    return this;
  }

  /**
   * A value indicating whether to use fuzzy matching for the suggestion query. Default is false. when set to true, the query will find suggestions even if there&#39;s a substituted or missing character in the search text. While this provides a better experience in some scenarios it comes at a performance cost as fuzzy suggestion searches are slower and consume more resources.
   * @return fuzzy
   */
  @javax.annotation.Nullable
  public Boolean getFuzzy() {
    return fuzzy;
  }

  public void setFuzzy(Boolean fuzzy) {
    this.fuzzy = fuzzy;
  }


  public SuggestParametersPayload highlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
    return this;
  }

  /**
   * A string tag that is appended to hit highlights. Must be set with HighlightPreTag. If omitted, hit highlighting of suggestions is disabled.
   * @return highlightPostTag
   */
  @javax.annotation.Nullable
  public String getHighlightPostTag() {
    return highlightPostTag;
  }

  public void setHighlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
  }


  public SuggestParametersPayload highlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
    return this;
  }

  /**
   * A string tag that is prepended to hit highlights. Must be set with HighlightPostTag. If omitted, hit highlighting of suggestions is disabled.
   * @return highlightPreTag
   */
  @javax.annotation.Nullable
  public String getHighlightPreTag() {
    return highlightPreTag;
  }

  public void setHighlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
  }


  public SuggestParametersPayload minimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
    return this;
  }

  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by a suggestion query in order for the query to be reported as a success. This parameter can be useful for ensuring search availability even for services with only one replica. The default is 80.
   * @return minimumCoverage
   */
  @javax.annotation.Nullable
  public Double getMinimumCoverage() {
    return minimumCoverage;
  }

  public void setMinimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
  }


  public SuggestParametersPayload orderby(String orderby) {
    this.orderby = orderby;
    return this;
  }

  /**
   * The comma-separated list of OData $orderby expressions by which to sort the results. Each expression can be either a field name or a call to the geo.distance() function. Each expression can be followed by asc to indicate ascending, and desc to indicate descending. The default is ascending order. Ties will be broken by the match scores of documents. If no OrderBy is specified, the default sort order is descending by document match score. There can be at most 32 Orderby clauses.
   * @return orderby
   */
  @javax.annotation.Nullable
  public String getOrderby() {
    return orderby;
  }

  public void setOrderby(String orderby) {
    this.orderby = orderby;
  }


  public SuggestParametersPayload search(String search) {
    this.search = search;
    return this;
  }

  /**
   * The search text on which to base suggestions.
   * @return search
   */
  @javax.annotation.Nullable
  public String getSearch() {
    return search;
  }

  public void setSearch(String search) {
    this.search = search;
  }


  public SuggestParametersPayload searchFields(String searchFields) {
    this.searchFields = searchFields;
    return this;
  }

  /**
   * The comma-separated list of field names to consider when querying for suggestions.
   * @return searchFields
   */
  @javax.annotation.Nullable
  public String getSearchFields() {
    return searchFields;
  }

  public void setSearchFields(String searchFields) {
    this.searchFields = searchFields;
  }


  public SuggestParametersPayload select(String select) {
    this.select = select;
    return this;
  }

  /**
   * The comma-separated list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema are included.
   * @return select
   */
  @javax.annotation.Nullable
  public String getSelect() {
    return select;
  }

  public void setSelect(String select) {
    this.select = select;
  }


  public SuggestParametersPayload suggesterName(String suggesterName) {
    this.suggesterName = suggesterName;
    return this;
  }

  /**
   * The name of the suggester as specified in the suggesters collection that&#39;s part of the index definition.
   * @return suggesterName
   */
  @javax.annotation.Nullable
  public String getSuggesterName() {
    return suggesterName;
  }

  public void setSuggesterName(String suggesterName) {
    this.suggesterName = suggesterName;
  }


  public SuggestParametersPayload top(Integer top) {
    this.top = top;
    return this;
  }

  /**
   * The number of suggestions to retrieve. This must be a value between 1 and 100. The default is to 5.
   * @return top
   */
  @javax.annotation.Nullable
  public Integer getTop() {
    return top;
  }

  public void setTop(Integer top) {
    this.top = top;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SuggestParametersPayload suggestParametersPayload = (SuggestParametersPayload) o;
    return Objects.equals(this.filter, suggestParametersPayload.filter) &&
        Objects.equals(this.fuzzy, suggestParametersPayload.fuzzy) &&
        Objects.equals(this.highlightPostTag, suggestParametersPayload.highlightPostTag) &&
        Objects.equals(this.highlightPreTag, suggestParametersPayload.highlightPreTag) &&
        Objects.equals(this.minimumCoverage, suggestParametersPayload.minimumCoverage) &&
        Objects.equals(this.orderby, suggestParametersPayload.orderby) &&
        Objects.equals(this.search, suggestParametersPayload.search) &&
        Objects.equals(this.searchFields, suggestParametersPayload.searchFields) &&
        Objects.equals(this.select, suggestParametersPayload.select) &&
        Objects.equals(this.suggesterName, suggestParametersPayload.suggesterName) &&
        Objects.equals(this.top, suggestParametersPayload.top);
  }

  @Override
  public int hashCode() {
    return Objects.hash(filter, fuzzy, highlightPostTag, highlightPreTag, minimumCoverage, orderby, search, searchFields, select, suggesterName, top);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SuggestParametersPayload {\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    fuzzy: ").append(toIndentedString(fuzzy)).append("\n");
    sb.append("    highlightPostTag: ").append(toIndentedString(highlightPostTag)).append("\n");
    sb.append("    highlightPreTag: ").append(toIndentedString(highlightPreTag)).append("\n");
    sb.append("    minimumCoverage: ").append(toIndentedString(minimumCoverage)).append("\n");
    sb.append("    orderby: ").append(toIndentedString(orderby)).append("\n");
    sb.append("    search: ").append(toIndentedString(search)).append("\n");
    sb.append("    searchFields: ").append(toIndentedString(searchFields)).append("\n");
    sb.append("    select: ").append(toIndentedString(select)).append("\n");
    sb.append("    suggesterName: ").append(toIndentedString(suggesterName)).append("\n");
    sb.append("    top: ").append(toIndentedString(top)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("filter");
    openapiFields.add("fuzzy");
    openapiFields.add("highlightPostTag");
    openapiFields.add("highlightPreTag");
    openapiFields.add("minimumCoverage");
    openapiFields.add("orderby");
    openapiFields.add("search");
    openapiFields.add("searchFields");
    openapiFields.add("select");
    openapiFields.add("suggesterName");
    openapiFields.add("top");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SuggestParametersPayload
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SuggestParametersPayload.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SuggestParametersPayload is not found in the empty JSON string", SuggestParametersPayload.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SuggestParametersPayload.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SuggestParametersPayload` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      if ((jsonObj.get("highlightPostTag") != null && !jsonObj.get("highlightPostTag").isJsonNull()) && !jsonObj.get("highlightPostTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPostTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPostTag").toString()));
      }
      if ((jsonObj.get("highlightPreTag") != null && !jsonObj.get("highlightPreTag").isJsonNull()) && !jsonObj.get("highlightPreTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPreTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPreTag").toString()));
      }
      if ((jsonObj.get("orderby") != null && !jsonObj.get("orderby").isJsonNull()) && !jsonObj.get("orderby").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderby` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderby").toString()));
      }
      if ((jsonObj.get("search") != null && !jsonObj.get("search").isJsonNull()) && !jsonObj.get("search").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `search` to be a primitive type in the JSON string but got `%s`", jsonObj.get("search").toString()));
      }
      if ((jsonObj.get("searchFields") != null && !jsonObj.get("searchFields").isJsonNull()) && !jsonObj.get("searchFields").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchFields` to be a primitive type in the JSON string but got `%s`", jsonObj.get("searchFields").toString()));
      }
      if ((jsonObj.get("select") != null && !jsonObj.get("select").isJsonNull()) && !jsonObj.get("select").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `select` to be a primitive type in the JSON string but got `%s`", jsonObj.get("select").toString()));
      }
      if ((jsonObj.get("suggesterName") != null && !jsonObj.get("suggesterName").isJsonNull()) && !jsonObj.get("suggesterName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `suggesterName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("suggesterName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SuggestParametersPayload.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SuggestParametersPayload' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SuggestParametersPayload> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SuggestParametersPayload.class));

       return (TypeAdapter<T>) new TypeAdapter<SuggestParametersPayload>() {
           @Override
           public void write(JsonWriter out, SuggestParametersPayload value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SuggestParametersPayload read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SuggestParametersPayload given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SuggestParametersPayload
   * @throws IOException if the JSON string is invalid with respect to SuggestParametersPayload
   */
  public static SuggestParametersPayload fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SuggestParametersPayload.class);
  }

  /**
   * Convert an instance of SuggestParametersPayload to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

