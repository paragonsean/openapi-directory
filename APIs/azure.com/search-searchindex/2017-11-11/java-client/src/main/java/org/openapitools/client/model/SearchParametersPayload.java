/*
 * SearchIndexClient
 * Client that can be used to query an Azure Search index and upload, merge, or delete documents.
 *
 * The version of the OpenAPI document: 2017-11-11
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.QueryType;
import org.openapitools.client.model.SearchMode;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Parameters for filtering, sorting, faceting, paging, and other search query behaviors.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:12:21.758847-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SearchParametersPayload {
  public static final String SERIALIZED_NAME_COUNT = "count";
  @SerializedName(SERIALIZED_NAME_COUNT)
  private Boolean count;

  public static final String SERIALIZED_NAME_FACETS = "facets";
  @SerializedName(SERIALIZED_NAME_FACETS)
  private List<String> facets = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_HIGHLIGHT = "highlight";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT)
  private String highlight;

  public static final String SERIALIZED_NAME_HIGHLIGHT_POST_TAG = "highlightPostTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_POST_TAG)
  private String highlightPostTag;

  public static final String SERIALIZED_NAME_HIGHLIGHT_PRE_TAG = "highlightPreTag";
  @SerializedName(SERIALIZED_NAME_HIGHLIGHT_PRE_TAG)
  private String highlightPreTag;

  public static final String SERIALIZED_NAME_MINIMUM_COVERAGE = "minimumCoverage";
  @SerializedName(SERIALIZED_NAME_MINIMUM_COVERAGE)
  private Double minimumCoverage;

  public static final String SERIALIZED_NAME_ORDERBY = "orderby";
  @SerializedName(SERIALIZED_NAME_ORDERBY)
  private String orderby;

  public static final String SERIALIZED_NAME_QUERY_TYPE = "queryType";
  @SerializedName(SERIALIZED_NAME_QUERY_TYPE)
  private QueryType queryType;

  public static final String SERIALIZED_NAME_SCORING_PARAMETERS = "scoringParameters";
  @SerializedName(SERIALIZED_NAME_SCORING_PARAMETERS)
  private List<String> scoringParameters = new ArrayList<>();

  public static final String SERIALIZED_NAME_SCORING_PROFILE = "scoringProfile";
  @SerializedName(SERIALIZED_NAME_SCORING_PROFILE)
  private String scoringProfile;

  public static final String SERIALIZED_NAME_SEARCH = "search";
  @SerializedName(SERIALIZED_NAME_SEARCH)
  private String search;

  public static final String SERIALIZED_NAME_SEARCH_FIELDS = "searchFields";
  @SerializedName(SERIALIZED_NAME_SEARCH_FIELDS)
  private String searchFields;

  public static final String SERIALIZED_NAME_SEARCH_MODE = "searchMode";
  @SerializedName(SERIALIZED_NAME_SEARCH_MODE)
  private SearchMode searchMode;

  public static final String SERIALIZED_NAME_SELECT = "select";
  @SerializedName(SERIALIZED_NAME_SELECT)
  private String select;

  public static final String SERIALIZED_NAME_SKIP = "skip";
  @SerializedName(SERIALIZED_NAME_SKIP)
  private Integer skip;

  public static final String SERIALIZED_NAME_TOP = "top";
  @SerializedName(SERIALIZED_NAME_TOP)
  private Integer top;

  public SearchParametersPayload() {
  }

  public SearchParametersPayload count(Boolean count) {
    this.count = count;
    return this;
  }

  /**
   * A value that specifies whether to fetch the total count of results. Default is false. Setting this value to true may have a performance impact. Note that the count returned is an approximation.
   * @return count
   */
  @javax.annotation.Nullable
  public Boolean getCount() {
    return count;
  }

  public void setCount(Boolean count) {
    this.count = count;
  }


  public SearchParametersPayload facets(List<String> facets) {
    this.facets = facets;
    return this;
  }

  public SearchParametersPayload addFacetsItem(String facetsItem) {
    if (this.facets == null) {
      this.facets = new ArrayList<>();
    }
    this.facets.add(facetsItem);
    return this;
  }

  /**
   * The list of facet expressions to apply to the search query. Each facet expression contains a field name, optionally followed by a comma-separated list of name:value pairs.
   * @return facets
   */
  @javax.annotation.Nullable
  public List<String> getFacets() {
    return facets;
  }

  public void setFacets(List<String> facets) {
    this.facets = facets;
  }


  public SearchParametersPayload filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * The OData $filter expression to apply to the search query.
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public SearchParametersPayload highlight(String highlight) {
    this.highlight = highlight;
    return this;
  }

  /**
   * The comma-separated list of field names to use for hit highlights. Only searchable fields can be used for hit highlighting.
   * @return highlight
   */
  @javax.annotation.Nullable
  public String getHighlight() {
    return highlight;
  }

  public void setHighlight(String highlight) {
    this.highlight = highlight;
  }


  public SearchParametersPayload highlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
    return this;
  }

  /**
   * A string tag that is appended to hit highlights. Must be set with HighlightPreTag. Default is &amp;lt;/em&amp;gt;.
   * @return highlightPostTag
   */
  @javax.annotation.Nullable
  public String getHighlightPostTag() {
    return highlightPostTag;
  }

  public void setHighlightPostTag(String highlightPostTag) {
    this.highlightPostTag = highlightPostTag;
  }


  public SearchParametersPayload highlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
    return this;
  }

  /**
   * A string tag that is prepended to hit highlights. Must be set with HighlightPostTag. Default is &amp;lt;em&amp;gt;.
   * @return highlightPreTag
   */
  @javax.annotation.Nullable
  public String getHighlightPreTag() {
    return highlightPreTag;
  }

  public void setHighlightPreTag(String highlightPreTag) {
    this.highlightPreTag = highlightPreTag;
  }


  public SearchParametersPayload minimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
    return this;
  }

  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by a search query in order for the query to be reported as a success. This parameter can be useful for ensuring search availability even for services with only one replica. The default is 100.
   * @return minimumCoverage
   */
  @javax.annotation.Nullable
  public Double getMinimumCoverage() {
    return minimumCoverage;
  }

  public void setMinimumCoverage(Double minimumCoverage) {
    this.minimumCoverage = minimumCoverage;
  }


  public SearchParametersPayload orderby(String orderby) {
    this.orderby = orderby;
    return this;
  }

  /**
   * The comma-separated list of OData $orderby expressions by which to sort the results. Each expression can be either a field name or a call to the geo.distance() function. Each expression can be followed by asc to indicate ascending, and desc to indicate descending. The default is ascending order. Ties will be broken by the match scores of documents. If no OrderBy is specified, the default sort order is descending by document match score. There can be at most 32 Orderby clauses.
   * @return orderby
   */
  @javax.annotation.Nullable
  public String getOrderby() {
    return orderby;
  }

  public void setOrderby(String orderby) {
    this.orderby = orderby;
  }


  public SearchParametersPayload queryType(QueryType queryType) {
    this.queryType = queryType;
    return this;
  }

  /**
   * Get queryType
   * @return queryType
   */
  @javax.annotation.Nullable
  public QueryType getQueryType() {
    return queryType;
  }

  public void setQueryType(QueryType queryType) {
    this.queryType = queryType;
  }


  public SearchParametersPayload scoringParameters(List<String> scoringParameters) {
    this.scoringParameters = scoringParameters;
    return this;
  }

  public SearchParametersPayload addScoringParametersItem(String scoringParametersItem) {
    if (this.scoringParameters == null) {
      this.scoringParameters = new ArrayList<>();
    }
    this.scoringParameters.add(scoringParametersItem);
    return this;
  }

  /**
   * The list of parameter values to be used in scoring functions (for example, referencePointParameter) using the format name:value. For example, if the scoring profile defines a function with a parameter called &#39;mylocation&#39; the parameter string would be \&quot;mylocation:-122.2,44.8\&quot;(without the quotes).
   * @return scoringParameters
   */
  @javax.annotation.Nullable
  public List<String> getScoringParameters() {
    return scoringParameters;
  }

  public void setScoringParameters(List<String> scoringParameters) {
    this.scoringParameters = scoringParameters;
  }


  public SearchParametersPayload scoringProfile(String scoringProfile) {
    this.scoringProfile = scoringProfile;
    return this;
  }

  /**
   * The name of a scoring profile to evaluate match scores for matching documents in order to sort the results.
   * @return scoringProfile
   */
  @javax.annotation.Nullable
  public String getScoringProfile() {
    return scoringProfile;
  }

  public void setScoringProfile(String scoringProfile) {
    this.scoringProfile = scoringProfile;
  }


  public SearchParametersPayload search(String search) {
    this.search = search;
    return this;
  }

  /**
   * A full-text search query expression; Use null or \&quot;*\&quot; to match all documents.
   * @return search
   */
  @javax.annotation.Nullable
  public String getSearch() {
    return search;
  }

  public void setSearch(String search) {
    this.search = search;
  }


  public SearchParametersPayload searchFields(String searchFields) {
    this.searchFields = searchFields;
    return this;
  }

  /**
   * The comma-separated list of field names to include in the full-text search.
   * @return searchFields
   */
  @javax.annotation.Nullable
  public String getSearchFields() {
    return searchFields;
  }

  public void setSearchFields(String searchFields) {
    this.searchFields = searchFields;
  }


  public SearchParametersPayload searchMode(SearchMode searchMode) {
    this.searchMode = searchMode;
    return this;
  }

  /**
   * Get searchMode
   * @return searchMode
   */
  @javax.annotation.Nullable
  public SearchMode getSearchMode() {
    return searchMode;
  }

  public void setSearchMode(SearchMode searchMode) {
    this.searchMode = searchMode;
  }


  public SearchParametersPayload select(String select) {
    this.select = select;
    return this;
  }

  /**
   * The comma-separated list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema are included.
   * @return select
   */
  @javax.annotation.Nullable
  public String getSelect() {
    return select;
  }

  public void setSelect(String select) {
    this.select = select;
  }


  public SearchParametersPayload skip(Integer skip) {
    this.skip = skip;
    return this;
  }

  /**
   * The number of search results to skip. This value cannot be greater than 100,000. If you need to scan documents in sequence, but cannot use Skip due to this limitation, consider using OrderBy on a totally-ordered key and Filter with a range query instead.
   * @return skip
   */
  @javax.annotation.Nullable
  public Integer getSkip() {
    return skip;
  }

  public void setSkip(Integer skip) {
    this.skip = skip;
  }


  public SearchParametersPayload top(Integer top) {
    this.top = top;
    return this;
  }

  /**
   * The number of search results to retrieve. This can be used in conjunction with Skip to implement client-side paging of search results. If results are truncated due to server-side paging, the response will include a continuation token that can be passed to ContinueSearch to retrieve the next page of results. See DocumentSearchResponse.ContinuationToken for more information.
   * @return top
   */
  @javax.annotation.Nullable
  public Integer getTop() {
    return top;
  }

  public void setTop(Integer top) {
    this.top = top;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchParametersPayload searchParametersPayload = (SearchParametersPayload) o;
    return Objects.equals(this.count, searchParametersPayload.count) &&
        Objects.equals(this.facets, searchParametersPayload.facets) &&
        Objects.equals(this.filter, searchParametersPayload.filter) &&
        Objects.equals(this.highlight, searchParametersPayload.highlight) &&
        Objects.equals(this.highlightPostTag, searchParametersPayload.highlightPostTag) &&
        Objects.equals(this.highlightPreTag, searchParametersPayload.highlightPreTag) &&
        Objects.equals(this.minimumCoverage, searchParametersPayload.minimumCoverage) &&
        Objects.equals(this.orderby, searchParametersPayload.orderby) &&
        Objects.equals(this.queryType, searchParametersPayload.queryType) &&
        Objects.equals(this.scoringParameters, searchParametersPayload.scoringParameters) &&
        Objects.equals(this.scoringProfile, searchParametersPayload.scoringProfile) &&
        Objects.equals(this.search, searchParametersPayload.search) &&
        Objects.equals(this.searchFields, searchParametersPayload.searchFields) &&
        Objects.equals(this.searchMode, searchParametersPayload.searchMode) &&
        Objects.equals(this.select, searchParametersPayload.select) &&
        Objects.equals(this.skip, searchParametersPayload.skip) &&
        Objects.equals(this.top, searchParametersPayload.top);
  }

  @Override
  public int hashCode() {
    return Objects.hash(count, facets, filter, highlight, highlightPostTag, highlightPreTag, minimumCoverage, orderby, queryType, scoringParameters, scoringProfile, search, searchFields, searchMode, select, skip, top);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchParametersPayload {\n");
    sb.append("    count: ").append(toIndentedString(count)).append("\n");
    sb.append("    facets: ").append(toIndentedString(facets)).append("\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    highlight: ").append(toIndentedString(highlight)).append("\n");
    sb.append("    highlightPostTag: ").append(toIndentedString(highlightPostTag)).append("\n");
    sb.append("    highlightPreTag: ").append(toIndentedString(highlightPreTag)).append("\n");
    sb.append("    minimumCoverage: ").append(toIndentedString(minimumCoverage)).append("\n");
    sb.append("    orderby: ").append(toIndentedString(orderby)).append("\n");
    sb.append("    queryType: ").append(toIndentedString(queryType)).append("\n");
    sb.append("    scoringParameters: ").append(toIndentedString(scoringParameters)).append("\n");
    sb.append("    scoringProfile: ").append(toIndentedString(scoringProfile)).append("\n");
    sb.append("    search: ").append(toIndentedString(search)).append("\n");
    sb.append("    searchFields: ").append(toIndentedString(searchFields)).append("\n");
    sb.append("    searchMode: ").append(toIndentedString(searchMode)).append("\n");
    sb.append("    select: ").append(toIndentedString(select)).append("\n");
    sb.append("    skip: ").append(toIndentedString(skip)).append("\n");
    sb.append("    top: ").append(toIndentedString(top)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("count");
    openapiFields.add("facets");
    openapiFields.add("filter");
    openapiFields.add("highlight");
    openapiFields.add("highlightPostTag");
    openapiFields.add("highlightPreTag");
    openapiFields.add("minimumCoverage");
    openapiFields.add("orderby");
    openapiFields.add("queryType");
    openapiFields.add("scoringParameters");
    openapiFields.add("scoringProfile");
    openapiFields.add("search");
    openapiFields.add("searchFields");
    openapiFields.add("searchMode");
    openapiFields.add("select");
    openapiFields.add("skip");
    openapiFields.add("top");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SearchParametersPayload
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SearchParametersPayload.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SearchParametersPayload is not found in the empty JSON string", SearchParametersPayload.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SearchParametersPayload.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SearchParametersPayload` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("facets") != null && !jsonObj.get("facets").isJsonNull() && !jsonObj.get("facets").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `facets` to be an array in the JSON string but got `%s`", jsonObj.get("facets").toString()));
      }
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      if ((jsonObj.get("highlight") != null && !jsonObj.get("highlight").isJsonNull()) && !jsonObj.get("highlight").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlight` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlight").toString()));
      }
      if ((jsonObj.get("highlightPostTag") != null && !jsonObj.get("highlightPostTag").isJsonNull()) && !jsonObj.get("highlightPostTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPostTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPostTag").toString()));
      }
      if ((jsonObj.get("highlightPreTag") != null && !jsonObj.get("highlightPreTag").isJsonNull()) && !jsonObj.get("highlightPreTag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `highlightPreTag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("highlightPreTag").toString()));
      }
      if ((jsonObj.get("orderby") != null && !jsonObj.get("orderby").isJsonNull()) && !jsonObj.get("orderby").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderby` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderby").toString()));
      }
      // validate the optional field `queryType`
      if (jsonObj.get("queryType") != null && !jsonObj.get("queryType").isJsonNull()) {
        QueryType.validateJsonElement(jsonObj.get("queryType"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("scoringParameters") != null && !jsonObj.get("scoringParameters").isJsonNull() && !jsonObj.get("scoringParameters").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `scoringParameters` to be an array in the JSON string but got `%s`", jsonObj.get("scoringParameters").toString()));
      }
      if ((jsonObj.get("scoringProfile") != null && !jsonObj.get("scoringProfile").isJsonNull()) && !jsonObj.get("scoringProfile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scoringProfile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scoringProfile").toString()));
      }
      if ((jsonObj.get("search") != null && !jsonObj.get("search").isJsonNull()) && !jsonObj.get("search").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `search` to be a primitive type in the JSON string but got `%s`", jsonObj.get("search").toString()));
      }
      if ((jsonObj.get("searchFields") != null && !jsonObj.get("searchFields").isJsonNull()) && !jsonObj.get("searchFields").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchFields` to be a primitive type in the JSON string but got `%s`", jsonObj.get("searchFields").toString()));
      }
      // validate the optional field `searchMode`
      if (jsonObj.get("searchMode") != null && !jsonObj.get("searchMode").isJsonNull()) {
        SearchMode.validateJsonElement(jsonObj.get("searchMode"));
      }
      if ((jsonObj.get("select") != null && !jsonObj.get("select").isJsonNull()) && !jsonObj.get("select").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `select` to be a primitive type in the JSON string but got `%s`", jsonObj.get("select").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SearchParametersPayload.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SearchParametersPayload' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SearchParametersPayload> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SearchParametersPayload.class));

       return (TypeAdapter<T>) new TypeAdapter<SearchParametersPayload>() {
           @Override
           public void write(JsonWriter out, SearchParametersPayload value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SearchParametersPayload read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SearchParametersPayload given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SearchParametersPayload
   * @throws IOException if the JSON string is invalid with respect to SearchParametersPayload
   */
  public static SearchParametersPayload fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SearchParametersPayload.class);
  }

  /**
   * Convert an instance of SearchParametersPayload to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

