/*
 * DnsManagementClient
 * The DNS Management Client.
 *
 * The version of the OpenAPI document: 2017-09-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.CloudError;
import org.openapitools.client.model.RecordSet;
import org.openapitools.client.model.RecordSetListResult;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RecordSetsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public RecordSetsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RecordSetsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for recordSetsCreateOrUpdate
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA can be updated but not created (they are created when the DNS zone is created). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the CreateOrUpdate operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting any concurrent changes. (optional)
     * @param ifNoneMatch Set to &#39;*&#39; to allow a new record set to be created, but to prevent updating an existing record set. Other values will be ignored. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> The record set has been created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsCreateOrUpdateCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, String ifNoneMatch, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = parameters;

        // create path and map variables
        String localVarPath = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dnsZones/{zoneName}/{recordType}/{relativeRecordSetName}"
            .replace("{" + "resourceGroupName" + "}", localVarApiClient.escapeString(resourceGroupName.toString()))
            .replace("{" + "zoneName" + "}", localVarApiClient.escapeString(zoneName.toString()))
            .replace("{" + "relativeRecordSetName" + "}", localVarApiClient.escapeString(relativeRecordSetName.toString()))
            .replace("{" + "recordType" + "}", localVarApiClient.escapeString(recordType.toString()))
            .replace("{" + "subscriptionId" + "}", localVarApiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api-version", apiVersion));
        }

        if (ifMatch != null) {
            localVarHeaderParams.put("If-Match", localVarApiClient.parameterToString(ifMatch));
        }

        if (ifNoneMatch != null) {
            localVarHeaderParams.put("If-None-Match", localVarApiClient.parameterToString(ifNoneMatch));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call recordSetsCreateOrUpdateValidateBeforeCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, String ifNoneMatch, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceGroupName' is set
        if (resourceGroupName == null) {
            throw new ApiException("Missing the required parameter 'resourceGroupName' when calling recordSetsCreateOrUpdate(Async)");
        }

        // verify the required parameter 'zoneName' is set
        if (zoneName == null) {
            throw new ApiException("Missing the required parameter 'zoneName' when calling recordSetsCreateOrUpdate(Async)");
        }

        // verify the required parameter 'relativeRecordSetName' is set
        if (relativeRecordSetName == null) {
            throw new ApiException("Missing the required parameter 'relativeRecordSetName' when calling recordSetsCreateOrUpdate(Async)");
        }

        // verify the required parameter 'recordType' is set
        if (recordType == null) {
            throw new ApiException("Missing the required parameter 'recordType' when calling recordSetsCreateOrUpdate(Async)");
        }

        // verify the required parameter 'apiVersion' is set
        if (apiVersion == null) {
            throw new ApiException("Missing the required parameter 'apiVersion' when calling recordSetsCreateOrUpdate(Async)");
        }

        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling recordSetsCreateOrUpdate(Async)");
        }

        // verify the required parameter 'parameters' is set
        if (parameters == null) {
            throw new ApiException("Missing the required parameter 'parameters' when calling recordSetsCreateOrUpdate(Async)");
        }

        return recordSetsCreateOrUpdateCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch, ifNoneMatch, _callback);

    }

    /**
     * 
     * Creates or updates a record set within a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA can be updated but not created (they are created when the DNS zone is created). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the CreateOrUpdate operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting any concurrent changes. (optional)
     * @param ifNoneMatch Set to &#39;*&#39; to allow a new record set to be created, but to prevent updating an existing record set. Other values will be ignored. (optional)
     * @return RecordSet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> The record set has been created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public RecordSet recordSetsCreateOrUpdate(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, String ifNoneMatch) throws ApiException {
        ApiResponse<RecordSet> localVarResp = recordSetsCreateOrUpdateWithHttpInfo(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch, ifNoneMatch);
        return localVarResp.getData();
    }

    /**
     * 
     * Creates or updates a record set within a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA can be updated but not created (they are created when the DNS zone is created). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the CreateOrUpdate operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting any concurrent changes. (optional)
     * @param ifNoneMatch Set to &#39;*&#39; to allow a new record set to be created, but to prevent updating an existing record set. Other values will be ignored. (optional)
     * @return ApiResponse&lt;RecordSet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> The record set has been created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecordSet> recordSetsCreateOrUpdateWithHttpInfo(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, String ifNoneMatch) throws ApiException {
        okhttp3.Call localVarCall = recordSetsCreateOrUpdateValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch, ifNoneMatch, null);
        Type localVarReturnType = new TypeToken<RecordSet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Creates or updates a record set within a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA can be updated but not created (they are created when the DNS zone is created). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the CreateOrUpdate operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting any concurrent changes. (optional)
     * @param ifNoneMatch Set to &#39;*&#39; to allow a new record set to be created, but to prevent updating an existing record set. Other values will be ignored. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> The record set has been created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsCreateOrUpdateAsync(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, String ifNoneMatch, final ApiCallback<RecordSet> _callback) throws ApiException {

        okhttp3.Call localVarCall = recordSetsCreateOrUpdateValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch, ifNoneMatch, _callback);
        Type localVarReturnType = new TypeToken<RecordSet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for recordSetsDelete
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA cannot be deleted (they are deleted when the DNS zone is deleted). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param ifMatch The etag of the record set. Omit this value to always delete the current record set. Specify the last-seen etag value to prevent accidentally deleting any concurrent changes. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been deleted. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> The record set was not found. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsDeleteCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, String ifMatch, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dnsZones/{zoneName}/{recordType}/{relativeRecordSetName}"
            .replace("{" + "resourceGroupName" + "}", localVarApiClient.escapeString(resourceGroupName.toString()))
            .replace("{" + "zoneName" + "}", localVarApiClient.escapeString(zoneName.toString()))
            .replace("{" + "relativeRecordSetName" + "}", localVarApiClient.escapeString(relativeRecordSetName.toString()))
            .replace("{" + "recordType" + "}", localVarApiClient.escapeString(recordType.toString()))
            .replace("{" + "subscriptionId" + "}", localVarApiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api-version", apiVersion));
        }

        if (ifMatch != null) {
            localVarHeaderParams.put("If-Match", localVarApiClient.parameterToString(ifMatch));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call recordSetsDeleteValidateBeforeCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, String ifMatch, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceGroupName' is set
        if (resourceGroupName == null) {
            throw new ApiException("Missing the required parameter 'resourceGroupName' when calling recordSetsDelete(Async)");
        }

        // verify the required parameter 'zoneName' is set
        if (zoneName == null) {
            throw new ApiException("Missing the required parameter 'zoneName' when calling recordSetsDelete(Async)");
        }

        // verify the required parameter 'relativeRecordSetName' is set
        if (relativeRecordSetName == null) {
            throw new ApiException("Missing the required parameter 'relativeRecordSetName' when calling recordSetsDelete(Async)");
        }

        // verify the required parameter 'recordType' is set
        if (recordType == null) {
            throw new ApiException("Missing the required parameter 'recordType' when calling recordSetsDelete(Async)");
        }

        // verify the required parameter 'apiVersion' is set
        if (apiVersion == null) {
            throw new ApiException("Missing the required parameter 'apiVersion' when calling recordSetsDelete(Async)");
        }

        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling recordSetsDelete(Async)");
        }

        return recordSetsDeleteCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, ifMatch, _callback);

    }

    /**
     * 
     * Deletes a record set from a DNS zone. This operation cannot be undone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA cannot be deleted (they are deleted when the DNS zone is deleted). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param ifMatch The etag of the record set. Omit this value to always delete the current record set. Specify the last-seen etag value to prevent accidentally deleting any concurrent changes. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been deleted. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> The record set was not found. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public void recordSetsDelete(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, String ifMatch) throws ApiException {
        recordSetsDeleteWithHttpInfo(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, ifMatch);
    }

    /**
     * 
     * Deletes a record set from a DNS zone. This operation cannot be undone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA cannot be deleted (they are deleted when the DNS zone is deleted). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param ifMatch The etag of the record set. Omit this value to always delete the current record set. Specify the last-seen etag value to prevent accidentally deleting any concurrent changes. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been deleted. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> The record set was not found. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> recordSetsDeleteWithHttpInfo(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, String ifMatch) throws ApiException {
        okhttp3.Call localVarCall = recordSetsDeleteValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, ifMatch, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Deletes a record set from a DNS zone. This operation cannot be undone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. Record sets of type SOA cannot be deleted (they are deleted when the DNS zone is deleted). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param ifMatch The etag of the record set. Omit this value to always delete the current record set. Specify the last-seen etag value to prevent accidentally deleting any concurrent changes. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been deleted. </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> The record set was not found. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsDeleteAsync(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, String ifMatch, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = recordSetsDeleteValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, ifMatch, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for recordSetsGet
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsGetCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dnsZones/{zoneName}/{recordType}/{relativeRecordSetName}"
            .replace("{" + "resourceGroupName" + "}", localVarApiClient.escapeString(resourceGroupName.toString()))
            .replace("{" + "zoneName" + "}", localVarApiClient.escapeString(zoneName.toString()))
            .replace("{" + "relativeRecordSetName" + "}", localVarApiClient.escapeString(relativeRecordSetName.toString()))
            .replace("{" + "recordType" + "}", localVarApiClient.escapeString(recordType.toString()))
            .replace("{" + "subscriptionId" + "}", localVarApiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api-version", apiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call recordSetsGetValidateBeforeCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceGroupName' is set
        if (resourceGroupName == null) {
            throw new ApiException("Missing the required parameter 'resourceGroupName' when calling recordSetsGet(Async)");
        }

        // verify the required parameter 'zoneName' is set
        if (zoneName == null) {
            throw new ApiException("Missing the required parameter 'zoneName' when calling recordSetsGet(Async)");
        }

        // verify the required parameter 'relativeRecordSetName' is set
        if (relativeRecordSetName == null) {
            throw new ApiException("Missing the required parameter 'relativeRecordSetName' when calling recordSetsGet(Async)");
        }

        // verify the required parameter 'recordType' is set
        if (recordType == null) {
            throw new ApiException("Missing the required parameter 'recordType' when calling recordSetsGet(Async)");
        }

        // verify the required parameter 'apiVersion' is set
        if (apiVersion == null) {
            throw new ApiException("Missing the required parameter 'apiVersion' when calling recordSetsGet(Async)");
        }

        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling recordSetsGet(Async)");
        }

        return recordSetsGetCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, _callback);

    }

    /**
     * 
     * Gets a record set.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @return RecordSet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public RecordSet recordSetsGet(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId) throws ApiException {
        ApiResponse<RecordSet> localVarResp = recordSetsGetWithHttpInfo(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId);
        return localVarResp.getData();
    }

    /**
     * 
     * Gets a record set.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @return ApiResponse&lt;RecordSet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecordSet> recordSetsGetWithHttpInfo(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId) throws ApiException {
        okhttp3.Call localVarCall = recordSetsGetValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, null);
        Type localVarReturnType = new TypeToken<RecordSet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Gets a record set.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsGetAsync(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, final ApiCallback<RecordSet> _callback) throws ApiException {

        okhttp3.Call localVarCall = recordSetsGetValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, _callback);
        Type localVarReturnType = new TypeToken<RecordSet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for recordSetsListByDnsZone
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsListByDnsZoneCall(String resourceGroupName, String zoneName, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dnsZones/{zoneName}/recordsets"
            .replace("{" + "resourceGroupName" + "}", localVarApiClient.escapeString(resourceGroupName.toString()))
            .replace("{" + "zoneName" + "}", localVarApiClient.escapeString(zoneName.toString()))
            .replace("{" + "subscriptionId" + "}", localVarApiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if ($top != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("$top", $top));
        }

        if ($recordsetnamesuffix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("$recordsetnamesuffix", $recordsetnamesuffix));
        }

        if (apiVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api-version", apiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call recordSetsListByDnsZoneValidateBeforeCall(String resourceGroupName, String zoneName, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceGroupName' is set
        if (resourceGroupName == null) {
            throw new ApiException("Missing the required parameter 'resourceGroupName' when calling recordSetsListByDnsZone(Async)");
        }

        // verify the required parameter 'zoneName' is set
        if (zoneName == null) {
            throw new ApiException("Missing the required parameter 'zoneName' when calling recordSetsListByDnsZone(Async)");
        }

        // verify the required parameter 'apiVersion' is set
        if (apiVersion == null) {
            throw new ApiException("Missing the required parameter 'apiVersion' when calling recordSetsListByDnsZone(Async)");
        }

        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling recordSetsListByDnsZone(Async)");
        }

        return recordSetsListByDnsZoneCall(resourceGroupName, zoneName, apiVersion, subscriptionId, $top, $recordsetnamesuffix, _callback);

    }

    /**
     * 
     * Lists all record sets in a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @return RecordSetListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public RecordSetListResult recordSetsListByDnsZone(String resourceGroupName, String zoneName, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix) throws ApiException {
        ApiResponse<RecordSetListResult> localVarResp = recordSetsListByDnsZoneWithHttpInfo(resourceGroupName, zoneName, apiVersion, subscriptionId, $top, $recordsetnamesuffix);
        return localVarResp.getData();
    }

    /**
     * 
     * Lists all record sets in a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @return ApiResponse&lt;RecordSetListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecordSetListResult> recordSetsListByDnsZoneWithHttpInfo(String resourceGroupName, String zoneName, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix) throws ApiException {
        okhttp3.Call localVarCall = recordSetsListByDnsZoneValidateBeforeCall(resourceGroupName, zoneName, apiVersion, subscriptionId, $top, $recordsetnamesuffix, null);
        Type localVarReturnType = new TypeToken<RecordSetListResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Lists all record sets in a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsListByDnsZoneAsync(String resourceGroupName, String zoneName, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix, final ApiCallback<RecordSetListResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = recordSetsListByDnsZoneValidateBeforeCall(resourceGroupName, zoneName, apiVersion, subscriptionId, $top, $recordsetnamesuffix, _callback);
        Type localVarReturnType = new TypeToken<RecordSetListResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for recordSetsListByType
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param recordType The type of record sets to enumerate. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsListByTypeCall(String resourceGroupName, String zoneName, String recordType, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dnsZones/{zoneName}/{recordType}"
            .replace("{" + "resourceGroupName" + "}", localVarApiClient.escapeString(resourceGroupName.toString()))
            .replace("{" + "zoneName" + "}", localVarApiClient.escapeString(zoneName.toString()))
            .replace("{" + "recordType" + "}", localVarApiClient.escapeString(recordType.toString()))
            .replace("{" + "subscriptionId" + "}", localVarApiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if ($top != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("$top", $top));
        }

        if ($recordsetnamesuffix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("$recordsetnamesuffix", $recordsetnamesuffix));
        }

        if (apiVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api-version", apiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call recordSetsListByTypeValidateBeforeCall(String resourceGroupName, String zoneName, String recordType, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceGroupName' is set
        if (resourceGroupName == null) {
            throw new ApiException("Missing the required parameter 'resourceGroupName' when calling recordSetsListByType(Async)");
        }

        // verify the required parameter 'zoneName' is set
        if (zoneName == null) {
            throw new ApiException("Missing the required parameter 'zoneName' when calling recordSetsListByType(Async)");
        }

        // verify the required parameter 'recordType' is set
        if (recordType == null) {
            throw new ApiException("Missing the required parameter 'recordType' when calling recordSetsListByType(Async)");
        }

        // verify the required parameter 'apiVersion' is set
        if (apiVersion == null) {
            throw new ApiException("Missing the required parameter 'apiVersion' when calling recordSetsListByType(Async)");
        }

        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling recordSetsListByType(Async)");
        }

        return recordSetsListByTypeCall(resourceGroupName, zoneName, recordType, apiVersion, subscriptionId, $top, $recordsetnamesuffix, _callback);

    }

    /**
     * 
     * Lists the record sets of a specified type in a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param recordType The type of record sets to enumerate. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @return RecordSetListResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public RecordSetListResult recordSetsListByType(String resourceGroupName, String zoneName, String recordType, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix) throws ApiException {
        ApiResponse<RecordSetListResult> localVarResp = recordSetsListByTypeWithHttpInfo(resourceGroupName, zoneName, recordType, apiVersion, subscriptionId, $top, $recordsetnamesuffix);
        return localVarResp.getData();
    }

    /**
     * 
     * Lists the record sets of a specified type in a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param recordType The type of record sets to enumerate. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @return ApiResponse&lt;RecordSetListResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecordSetListResult> recordSetsListByTypeWithHttpInfo(String resourceGroupName, String zoneName, String recordType, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix) throws ApiException {
        okhttp3.Call localVarCall = recordSetsListByTypeValidateBeforeCall(resourceGroupName, zoneName, recordType, apiVersion, subscriptionId, $top, $recordsetnamesuffix, null);
        Type localVarReturnType = new TypeToken<RecordSetListResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Lists the record sets of a specified type in a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param recordType The type of record sets to enumerate. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param $top The maximum number of record sets to return. If not specified, returns up to 100 record sets. (optional)
     * @param $recordsetnamesuffix The suffix label of the record set name that has to be used to filter the record set enumerations. If this parameter is specified, Enumeration will return only records that end with .&lt;recordSetNameSuffix&gt; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsListByTypeAsync(String resourceGroupName, String zoneName, String recordType, String apiVersion, String subscriptionId, Integer $top, String $recordsetnamesuffix, final ApiCallback<RecordSetListResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = recordSetsListByTypeValidateBeforeCall(resourceGroupName, zoneName, recordType, apiVersion, subscriptionId, $top, $recordsetnamesuffix, _callback);
        Type localVarReturnType = new TypeToken<RecordSetListResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for recordSetsUpdate
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the Update operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting concurrent changes. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsUpdateCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = parameters;

        // create path and map variables
        String localVarPath = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dnsZones/{zoneName}/{recordType}/{relativeRecordSetName}"
            .replace("{" + "resourceGroupName" + "}", localVarApiClient.escapeString(resourceGroupName.toString()))
            .replace("{" + "zoneName" + "}", localVarApiClient.escapeString(zoneName.toString()))
            .replace("{" + "relativeRecordSetName" + "}", localVarApiClient.escapeString(relativeRecordSetName.toString()))
            .replace("{" + "recordType" + "}", localVarApiClient.escapeString(recordType.toString()))
            .replace("{" + "subscriptionId" + "}", localVarApiClient.escapeString(subscriptionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api-version", apiVersion));
        }

        if (ifMatch != null) {
            localVarHeaderParams.put("If-Match", localVarApiClient.parameterToString(ifMatch));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call recordSetsUpdateValidateBeforeCall(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'resourceGroupName' is set
        if (resourceGroupName == null) {
            throw new ApiException("Missing the required parameter 'resourceGroupName' when calling recordSetsUpdate(Async)");
        }

        // verify the required parameter 'zoneName' is set
        if (zoneName == null) {
            throw new ApiException("Missing the required parameter 'zoneName' when calling recordSetsUpdate(Async)");
        }

        // verify the required parameter 'relativeRecordSetName' is set
        if (relativeRecordSetName == null) {
            throw new ApiException("Missing the required parameter 'relativeRecordSetName' when calling recordSetsUpdate(Async)");
        }

        // verify the required parameter 'recordType' is set
        if (recordType == null) {
            throw new ApiException("Missing the required parameter 'recordType' when calling recordSetsUpdate(Async)");
        }

        // verify the required parameter 'apiVersion' is set
        if (apiVersion == null) {
            throw new ApiException("Missing the required parameter 'apiVersion' when calling recordSetsUpdate(Async)");
        }

        // verify the required parameter 'subscriptionId' is set
        if (subscriptionId == null) {
            throw new ApiException("Missing the required parameter 'subscriptionId' when calling recordSetsUpdate(Async)");
        }

        // verify the required parameter 'parameters' is set
        if (parameters == null) {
            throw new ApiException("Missing the required parameter 'parameters' when calling recordSetsUpdate(Async)");
        }

        return recordSetsUpdateCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch, _callback);

    }

    /**
     * 
     * Updates a record set within a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the Update operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting concurrent changes. (optional)
     * @return RecordSet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public RecordSet recordSetsUpdate(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch) throws ApiException {
        ApiResponse<RecordSet> localVarResp = recordSetsUpdateWithHttpInfo(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch);
        return localVarResp.getData();
    }

    /**
     * 
     * Updates a record set within a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the Update operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting concurrent changes. (optional)
     * @return ApiResponse&lt;RecordSet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecordSet> recordSetsUpdateWithHttpInfo(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch) throws ApiException {
        okhttp3.Call localVarCall = recordSetsUpdateValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch, null);
        Type localVarReturnType = new TypeToken<RecordSet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Updates a record set within a DNS zone.
     * @param resourceGroupName The name of the resource group. The name is case insensitive. (required)
     * @param zoneName The name of the DNS zone (without a terminating dot). (required)
     * @param relativeRecordSetName The name of the record set, relative to the name of the zone. (required)
     * @param recordType The type of DNS record in this record set. (required)
     * @param apiVersion The API version to use for this operation. (required)
     * @param subscriptionId The ID of the target subscription. (required)
     * @param parameters Parameters supplied to the Update operation. (required)
     * @param ifMatch The etag of the record set. Omit this value to always overwrite the current record set. Specify the last-seen etag value to prevent accidentally overwriting concurrent changes. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The record set has been updated. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Default response. It will be deserialized as per the Error definition. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call recordSetsUpdateAsync(String resourceGroupName, String zoneName, String relativeRecordSetName, String recordType, String apiVersion, String subscriptionId, RecordSet parameters, String ifMatch, final ApiCallback<RecordSet> _callback) throws ApiException {

        okhttp3.Call localVarCall = recordSetsUpdateValidateBeforeCall(resourceGroupName, zoneName, relativeRecordSetName, recordType, apiVersion, subscriptionId, parameters, ifMatch, _callback);
        Type localVarReturnType = new TypeToken<RecordSet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
