/*
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An object containing the properties of an point in the path of an ink stroke. The main properties are the x and y values. Other include tip pressure, x tilt etc. For the coordinate values, it is recommended to have a precision of 8 digits after the decimal to obtain most accurate recognition results. The origin (0,0) of the canvas is assumed to be at the top left corner of the canvas
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:13:17.580278-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class InkPoint {
  public static final String SERIALIZED_NAME_BARREL_PRESSURE = "barrelPressure";
  @SerializedName(SERIALIZED_NAME_BARREL_PRESSURE)
  private BigDecimal barrelPressure;

  public static final String SERIALIZED_NAME_BARREL_SWITCH = "barrelSwitch";
  @SerializedName(SERIALIZED_NAME_BARREL_SWITCH)
  private Boolean barrelSwitch;

  public static final String SERIALIZED_NAME_ERASER = "eraser";
  @SerializedName(SERIALIZED_NAME_ERASER)
  private Boolean eraser;

  public static final String SERIALIZED_NAME_HEIGHT = "height";
  @SerializedName(SERIALIZED_NAME_HEIGHT)
  private BigDecimal height;

  public static final String SERIALIZED_NAME_INVERTED = "inverted";
  @SerializedName(SERIALIZED_NAME_INVERTED)
  private Boolean inverted;

  public static final String SERIALIZED_NAME_SECONDARY_TIP = "secondaryTip";
  @SerializedName(SERIALIZED_NAME_SECONDARY_TIP)
  private Boolean secondaryTip;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private BigDecimal timestamp;

  public static final String SERIALIZED_NAME_TIP_PRESSURE = "tipPressure";
  @SerializedName(SERIALIZED_NAME_TIP_PRESSURE)
  private BigDecimal tipPressure;

  public static final String SERIALIZED_NAME_TIP_SWITCH = "tipSwitch";
  @SerializedName(SERIALIZED_NAME_TIP_SWITCH)
  private Boolean tipSwitch;

  public static final String SERIALIZED_NAME_WIDTH = "width";
  @SerializedName(SERIALIZED_NAME_WIDTH)
  private BigDecimal width;

  public static final String SERIALIZED_NAME_X = "x";
  @SerializedName(SERIALIZED_NAME_X)
  private BigDecimal x;

  public static final String SERIALIZED_NAME_X_TILT = "xTilt";
  @SerializedName(SERIALIZED_NAME_X_TILT)
  private BigDecimal xTilt;

  public static final String SERIALIZED_NAME_Y = "y";
  @SerializedName(SERIALIZED_NAME_Y)
  private BigDecimal y;

  public static final String SERIALIZED_NAME_Y_TILT = "yTilt";
  @SerializedName(SERIALIZED_NAME_Y_TILT)
  private BigDecimal yTilt;

  public static final String SERIALIZED_NAME_Z = "z";
  @SerializedName(SERIALIZED_NAME_Z)
  private BigDecimal z;

  public InkPoint() {
  }

  public InkPoint barrelPressure(BigDecimal barrelPressure) {
    this.barrelPressure = barrelPressure;
    return this;
  }

  /**
   * The force exerted directly by the user on a transducer sensor, such as a pressure-sensitive button on the barrel of a stylus. This may not be used for recognition.
   * @return barrelPressure
   */
  @javax.annotation.Nullable
  public BigDecimal getBarrelPressure() {
    return barrelPressure;
  }

  public void setBarrelPressure(BigDecimal barrelPressure) {
    this.barrelPressure = barrelPressure;
  }


  public InkPoint barrelSwitch(Boolean barrelSwitch) {
    this.barrelSwitch = barrelSwitch;
    return this;
  }

  /**
   * A non-tip button located on the barrel of a stylus. Its function is typically mapped to a system secondary button. This may not be used for recognition.
   * @return barrelSwitch
   */
  @javax.annotation.Nullable
  public Boolean getBarrelSwitch() {
    return barrelSwitch;
  }

  public void setBarrelSwitch(Boolean barrelSwitch) {
    this.barrelSwitch = barrelSwitch;
  }


  public InkPoint eraser(Boolean eraser) {
    this.eraser = eraser;
    return this;
  }

  /**
   * The control is used for erasing objects. It is typically located opposite the writing end of a stylus. This may not be used for recognition.
   * @return eraser
   */
  @javax.annotation.Nullable
  public Boolean getEraser() {
    return eraser;
  }

  public void setEraser(Boolean eraser) {
    this.eraser = eraser;
  }


  public InkPoint height(BigDecimal height) {
    this.height = height;
    return this;
  }

  /**
   * The height of the tip of the writing instrument. This is used by touch screen devices to report the height of the finger contact on the writing surface. This may not be used for recognition.
   * @return height
   */
  @javax.annotation.Nullable
  public BigDecimal getHeight() {
    return height;
  }

  public void setHeight(BigDecimal height) {
    this.height = height;
  }


  public InkPoint inverted(Boolean inverted) {
    this.inverted = inverted;
    return this;
  }

  /**
   * A value that indicates that the currently sensed position originates from the end of a stylus opposite the tip switch. This may not be used for recognition.
   * @return inverted
   */
  @javax.annotation.Nullable
  public Boolean getInverted() {
    return inverted;
  }

  public void setInverted(Boolean inverted) {
    this.inverted = inverted;
  }


  public InkPoint secondaryTip(Boolean secondaryTip) {
    this.secondaryTip = secondaryTip;
    return this;
  }

  /**
   * A secondary switch used in conjunction with the tip switch to indicate pressure above a certain threshold applied with the stylus. This may not be used for recognition.
   * @return secondaryTip
   */
  @javax.annotation.Nullable
  public Boolean getSecondaryTip() {
    return secondaryTip;
  }

  public void setSecondaryTip(Boolean secondaryTip) {
    this.secondaryTip = secondaryTip;
  }


  public InkPoint timestamp(BigDecimal timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * The time relative to the absolute time the transducer last became active. This may not be used for recognition.
   * @return timestamp
   */
  @javax.annotation.Nullable
  public BigDecimal getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(BigDecimal timestamp) {
    this.timestamp = timestamp;
  }


  public InkPoint tipPressure(BigDecimal tipPressure) {
    this.tipPressure = tipPressure;
    return this;
  }

  /**
   * The force exerted against the tablet surface by the transducer, typically a stylus. This may not be used for recognition.
   * @return tipPressure
   */
  @javax.annotation.Nullable
  public BigDecimal getTipPressure() {
    return tipPressure;
  }

  public void setTipPressure(BigDecimal tipPressure) {
    this.tipPressure = tipPressure;
  }


  public InkPoint tipSwitch(Boolean tipSwitch) {
    this.tipSwitch = tipSwitch;
    return this;
  }

  /**
   * A switch located on the tip of a stylus indicating contact of the stylus with a surface. This may not be used for recognition.
   * @return tipSwitch
   */
  @javax.annotation.Nullable
  public Boolean getTipSwitch() {
    return tipSwitch;
  }

  public void setTipSwitch(Boolean tipSwitch) {
    this.tipSwitch = tipSwitch;
  }


  public InkPoint width(BigDecimal width) {
    this.width = width;
    return this;
  }

  /**
   * The width of the tip of the writing instrument. This is used by touch screen devices to report the width of the finger contact on the writing surface. This may not be used for recognition.
   * @return width
   */
  @javax.annotation.Nullable
  public BigDecimal getWidth() {
    return width;
  }

  public void setWidth(BigDecimal width) {
    this.width = width;
  }


  public InkPoint x(BigDecimal x) {
    this.x = x;
    return this;
  }

  /**
   * The x coordinate of the pen location on the writing surface.
   * @return x
   */
  @javax.annotation.Nonnull
  public BigDecimal getX() {
    return x;
  }

  public void setX(BigDecimal x) {
    this.x = x;
  }


  public InkPoint xTilt(BigDecimal xTilt) {
    this.xTilt = xTilt;
    return this;
  }

  /**
   * The plane angle between the Y-Z plane and the plane containing the transducer axis and the Y axis. This may not be used for recognition.
   * @return xTilt
   */
  @javax.annotation.Nullable
  public BigDecimal getxTilt() {
    return xTilt;
  }

  public void setxTilt(BigDecimal xTilt) {
    this.xTilt = xTilt;
  }


  public InkPoint y(BigDecimal y) {
    this.y = y;
    return this;
  }

  /**
   * The y coordinate of the pen location on the writing surface.
   * @return y
   */
  @javax.annotation.Nonnull
  public BigDecimal getY() {
    return y;
  }

  public void setY(BigDecimal y) {
    this.y = y;
  }


  public InkPoint yTilt(BigDecimal yTilt) {
    this.yTilt = yTilt;
    return this;
  }

  /**
   * The angle between the X-Z and transducer-X planes. A positive Y Tilt is toward the user. This may not be used for recognition.
   * @return yTilt
   */
  @javax.annotation.Nullable
  public BigDecimal getyTilt() {
    return yTilt;
  }

  public void setyTilt(BigDecimal yTilt) {
    this.yTilt = yTilt;
  }


  public InkPoint z(BigDecimal z) {
    this.z = z;
    return this;
  }

  /**
   * The z coordinate of the pen location on the writing space. This may not be used for recognition.
   * @return z
   */
  @javax.annotation.Nullable
  public BigDecimal getZ() {
    return z;
  }

  public void setZ(BigDecimal z) {
    this.z = z;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InkPoint inkPoint = (InkPoint) o;
    return Objects.equals(this.barrelPressure, inkPoint.barrelPressure) &&
        Objects.equals(this.barrelSwitch, inkPoint.barrelSwitch) &&
        Objects.equals(this.eraser, inkPoint.eraser) &&
        Objects.equals(this.height, inkPoint.height) &&
        Objects.equals(this.inverted, inkPoint.inverted) &&
        Objects.equals(this.secondaryTip, inkPoint.secondaryTip) &&
        Objects.equals(this.timestamp, inkPoint.timestamp) &&
        Objects.equals(this.tipPressure, inkPoint.tipPressure) &&
        Objects.equals(this.tipSwitch, inkPoint.tipSwitch) &&
        Objects.equals(this.width, inkPoint.width) &&
        Objects.equals(this.x, inkPoint.x) &&
        Objects.equals(this.xTilt, inkPoint.xTilt) &&
        Objects.equals(this.y, inkPoint.y) &&
        Objects.equals(this.yTilt, inkPoint.yTilt) &&
        Objects.equals(this.z, inkPoint.z);
  }

  @Override
  public int hashCode() {
    return Objects.hash(barrelPressure, barrelSwitch, eraser, height, inverted, secondaryTip, timestamp, tipPressure, tipSwitch, width, x, xTilt, y, yTilt, z);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InkPoint {\n");
    sb.append("    barrelPressure: ").append(toIndentedString(barrelPressure)).append("\n");
    sb.append("    barrelSwitch: ").append(toIndentedString(barrelSwitch)).append("\n");
    sb.append("    eraser: ").append(toIndentedString(eraser)).append("\n");
    sb.append("    height: ").append(toIndentedString(height)).append("\n");
    sb.append("    inverted: ").append(toIndentedString(inverted)).append("\n");
    sb.append("    secondaryTip: ").append(toIndentedString(secondaryTip)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    tipPressure: ").append(toIndentedString(tipPressure)).append("\n");
    sb.append("    tipSwitch: ").append(toIndentedString(tipSwitch)).append("\n");
    sb.append("    width: ").append(toIndentedString(width)).append("\n");
    sb.append("    x: ").append(toIndentedString(x)).append("\n");
    sb.append("    xTilt: ").append(toIndentedString(xTilt)).append("\n");
    sb.append("    y: ").append(toIndentedString(y)).append("\n");
    sb.append("    yTilt: ").append(toIndentedString(yTilt)).append("\n");
    sb.append("    z: ").append(toIndentedString(z)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("barrelPressure");
    openapiFields.add("barrelSwitch");
    openapiFields.add("eraser");
    openapiFields.add("height");
    openapiFields.add("inverted");
    openapiFields.add("secondaryTip");
    openapiFields.add("timestamp");
    openapiFields.add("tipPressure");
    openapiFields.add("tipSwitch");
    openapiFields.add("width");
    openapiFields.add("x");
    openapiFields.add("xTilt");
    openapiFields.add("y");
    openapiFields.add("yTilt");
    openapiFields.add("z");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("x");
    openapiRequiredFields.add("y");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to InkPoint
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!InkPoint.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in InkPoint is not found in the empty JSON string", InkPoint.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!InkPoint.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `InkPoint` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : InkPoint.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!InkPoint.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'InkPoint' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<InkPoint> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(InkPoint.class));

       return (TypeAdapter<T>) new TypeAdapter<InkPoint>() {
           @Override
           public void write(JsonWriter out, InkPoint value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public InkPoint read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of InkPoint given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of InkPoint
   * @throws IOException if the JSON string is invalid with respect to InkPoint
   */
  public static InkPoint fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, InkPoint.class);
  }

  /**
   * Convert an instance of InkPoint to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

