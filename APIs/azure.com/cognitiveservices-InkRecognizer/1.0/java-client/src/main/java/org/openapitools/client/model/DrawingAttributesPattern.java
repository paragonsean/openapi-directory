/*
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;
import org.openapitools.client.model.DrawingAttributesPatternColor;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The properties to use when rendering ink
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:13:17.580278-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DrawingAttributesPattern {
  public static final String SERIALIZED_NAME_COLOR = "color";
  @SerializedName(SERIALIZED_NAME_COLOR)
  private DrawingAttributesPatternColor color;

  public static final String SERIALIZED_NAME_FIT_TO_CURVE = "fitToCurve";
  @SerializedName(SERIALIZED_NAME_FIT_TO_CURVE)
  private Boolean fitToCurve;

  public static final String SERIALIZED_NAME_HEIGHT = "height";
  @SerializedName(SERIALIZED_NAME_HEIGHT)
  private BigDecimal height;

  public static final String SERIALIZED_NAME_IGNORE_PRESSURE = "ignorePressure";
  @SerializedName(SERIALIZED_NAME_IGNORE_PRESSURE)
  private Boolean ignorePressure;

  /**
   * Gets or Sets rasterOp
   */
  @JsonAdapter(RasterOpEnum.Adapter.class)
  public enum RasterOpEnum {
    NO_OPERATION("noOperation"),
    
    COPY_PEN("copyPen"),
    
    MASK_PEN("maskPen");

    private String value;

    RasterOpEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RasterOpEnum fromValue(String value) {
      for (RasterOpEnum b : RasterOpEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RasterOpEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RasterOpEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RasterOpEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RasterOpEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RasterOpEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RASTER_OP = "rasterOp";
  @SerializedName(SERIALIZED_NAME_RASTER_OP)
  private RasterOpEnum rasterOp;

  /**
   * This specifies the tip to be used to draw a stroke
   */
  @JsonAdapter(TipEnum.Adapter.class)
  public enum TipEnum {
    ELLIPSE("ellipse"),
    
    RECTANGLE("rectangle");

    private String value;

    TipEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TipEnum fromValue(String value) {
      for (TipEnum b : TipEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TipEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TipEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TipEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TipEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TipEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TIP = "tip";
  @SerializedName(SERIALIZED_NAME_TIP)
  private TipEnum tip;

  public static final String SERIALIZED_NAME_WIDTH = "width";
  @SerializedName(SERIALIZED_NAME_WIDTH)
  private BigDecimal width;

  public DrawingAttributesPattern() {
  }

  public DrawingAttributesPattern color(DrawingAttributesPatternColor color) {
    this.color = color;
    return this;
  }

  /**
   * Get color
   * @return color
   */
  @javax.annotation.Nullable
  public DrawingAttributesPatternColor getColor() {
    return color;
  }

  public void setColor(DrawingAttributesPatternColor color) {
    this.color = color;
  }


  public DrawingAttributesPattern fitToCurve(Boolean fitToCurve) {
    this.fitToCurve = fitToCurve;
    return this;
  }

  /**
   *  This indicates whether Bezier smoothing is used to render the stroke
   * @return fitToCurve
   */
  @javax.annotation.Nullable
  public Boolean getFitToCurve() {
    return fitToCurve;
  }

  public void setFitToCurve(Boolean fitToCurve) {
    this.fitToCurve = fitToCurve;
  }


  public DrawingAttributesPattern height(BigDecimal height) {
    this.height = height;
    return this;
  }

  /**
   * The height of the stylus used to draw the stroke
   * @return height
   */
  @javax.annotation.Nullable
  public BigDecimal getHeight() {
    return height;
  }

  public void setHeight(BigDecimal height) {
    this.height = height;
  }


  public DrawingAttributesPattern ignorePressure(Boolean ignorePressure) {
    this.ignorePressure = ignorePressure;
    return this;
  }

  /**
   *  This indicates whether the thickness of a rendered Stroke changes according the amount of pressure applied.
   * @return ignorePressure
   */
  @javax.annotation.Nullable
  public Boolean getIgnorePressure() {
    return ignorePressure;
  }

  public void setIgnorePressure(Boolean ignorePressure) {
    this.ignorePressure = ignorePressure;
  }


  public DrawingAttributesPattern rasterOp(RasterOpEnum rasterOp) {
    this.rasterOp = rasterOp;
    return this;
  }

  /**
   * Get rasterOp
   * @return rasterOp
   */
  @javax.annotation.Nullable
  public RasterOpEnum getRasterOp() {
    return rasterOp;
  }

  public void setRasterOp(RasterOpEnum rasterOp) {
    this.rasterOp = rasterOp;
  }


  public DrawingAttributesPattern tip(TipEnum tip) {
    this.tip = tip;
    return this;
  }

  /**
   * This specifies the tip to be used to draw a stroke
   * @return tip
   */
  @javax.annotation.Nullable
  public TipEnum getTip() {
    return tip;
  }

  public void setTip(TipEnum tip) {
    this.tip = tip;
  }


  public DrawingAttributesPattern width(BigDecimal width) {
    this.width = width;
    return this;
  }

  /**
   * The width of the stylus used to draw the stroke
   * @return width
   */
  @javax.annotation.Nullable
  public BigDecimal getWidth() {
    return width;
  }

  public void setWidth(BigDecimal width) {
    this.width = width;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DrawingAttributesPattern drawingAttributesPattern = (DrawingAttributesPattern) o;
    return Objects.equals(this.color, drawingAttributesPattern.color) &&
        Objects.equals(this.fitToCurve, drawingAttributesPattern.fitToCurve) &&
        Objects.equals(this.height, drawingAttributesPattern.height) &&
        Objects.equals(this.ignorePressure, drawingAttributesPattern.ignorePressure) &&
        Objects.equals(this.rasterOp, drawingAttributesPattern.rasterOp) &&
        Objects.equals(this.tip, drawingAttributesPattern.tip) &&
        Objects.equals(this.width, drawingAttributesPattern.width);
  }

  @Override
  public int hashCode() {
    return Objects.hash(color, fitToCurve, height, ignorePressure, rasterOp, tip, width);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DrawingAttributesPattern {\n");
    sb.append("    color: ").append(toIndentedString(color)).append("\n");
    sb.append("    fitToCurve: ").append(toIndentedString(fitToCurve)).append("\n");
    sb.append("    height: ").append(toIndentedString(height)).append("\n");
    sb.append("    ignorePressure: ").append(toIndentedString(ignorePressure)).append("\n");
    sb.append("    rasterOp: ").append(toIndentedString(rasterOp)).append("\n");
    sb.append("    tip: ").append(toIndentedString(tip)).append("\n");
    sb.append("    width: ").append(toIndentedString(width)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("color");
    openapiFields.add("fitToCurve");
    openapiFields.add("height");
    openapiFields.add("ignorePressure");
    openapiFields.add("rasterOp");
    openapiFields.add("tip");
    openapiFields.add("width");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DrawingAttributesPattern
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DrawingAttributesPattern.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DrawingAttributesPattern is not found in the empty JSON string", DrawingAttributesPattern.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DrawingAttributesPattern.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DrawingAttributesPattern` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `color`
      if (jsonObj.get("color") != null && !jsonObj.get("color").isJsonNull()) {
        DrawingAttributesPatternColor.validateJsonElement(jsonObj.get("color"));
      }
      if ((jsonObj.get("rasterOp") != null && !jsonObj.get("rasterOp").isJsonNull()) && !jsonObj.get("rasterOp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rasterOp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rasterOp").toString()));
      }
      // validate the optional field `rasterOp`
      if (jsonObj.get("rasterOp") != null && !jsonObj.get("rasterOp").isJsonNull()) {
        RasterOpEnum.validateJsonElement(jsonObj.get("rasterOp"));
      }
      if ((jsonObj.get("tip") != null && !jsonObj.get("tip").isJsonNull()) && !jsonObj.get("tip").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tip` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tip").toString()));
      }
      // validate the optional field `tip`
      if (jsonObj.get("tip") != null && !jsonObj.get("tip").isJsonNull()) {
        TipEnum.validateJsonElement(jsonObj.get("tip"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DrawingAttributesPattern.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DrawingAttributesPattern' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DrawingAttributesPattern> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DrawingAttributesPattern.class));

       return (TypeAdapter<T>) new TypeAdapter<DrawingAttributesPattern>() {
           @Override
           public void write(JsonWriter out, DrawingAttributesPattern value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DrawingAttributesPattern read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DrawingAttributesPattern given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DrawingAttributesPattern
   * @throws IOException if the JSON string is invalid with respect to DrawingAttributesPattern
   */
  public static DrawingAttributesPattern fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DrawingAttributesPattern.class);
  }

  /**
   * Convert an instance of DrawingAttributesPattern to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

