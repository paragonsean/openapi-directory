/**
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDrawingAttributesPattern.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIDrawingAttributesPattern::OAIDrawingAttributesPattern(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIDrawingAttributesPattern::OAIDrawingAttributesPattern() {
    this->initializeModel();
}

OAIDrawingAttributesPattern::~OAIDrawingAttributesPattern() {}

void OAIDrawingAttributesPattern::initializeModel() {

    m_color_isSet = false;
    m_color_isValid = false;

    m_fit_to_curve_isSet = false;
    m_fit_to_curve_isValid = false;

    m_height_isSet = false;
    m_height_isValid = false;

    m_ignore_pressure_isSet = false;
    m_ignore_pressure_isValid = false;

    m_raster_op_isSet = false;
    m_raster_op_isValid = false;

    m_tip_isSet = false;
    m_tip_isValid = false;

    m_width_isSet = false;
    m_width_isValid = false;
}

void OAIDrawingAttributesPattern::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIDrawingAttributesPattern::fromJsonObject(QJsonObject json) {

    m_color_isValid = ::OpenAPI::fromJsonValue(m_color, json[QString("color")]);
    m_color_isSet = !json[QString("color")].isNull() && m_color_isValid;

    m_fit_to_curve_isValid = ::OpenAPI::fromJsonValue(m_fit_to_curve, json[QString("fitToCurve")]);
    m_fit_to_curve_isSet = !json[QString("fitToCurve")].isNull() && m_fit_to_curve_isValid;

    m_height_isValid = ::OpenAPI::fromJsonValue(m_height, json[QString("height")]);
    m_height_isSet = !json[QString("height")].isNull() && m_height_isValid;

    m_ignore_pressure_isValid = ::OpenAPI::fromJsonValue(m_ignore_pressure, json[QString("ignorePressure")]);
    m_ignore_pressure_isSet = !json[QString("ignorePressure")].isNull() && m_ignore_pressure_isValid;

    m_raster_op_isValid = ::OpenAPI::fromJsonValue(m_raster_op, json[QString("rasterOp")]);
    m_raster_op_isSet = !json[QString("rasterOp")].isNull() && m_raster_op_isValid;

    m_tip_isValid = ::OpenAPI::fromJsonValue(m_tip, json[QString("tip")]);
    m_tip_isSet = !json[QString("tip")].isNull() && m_tip_isValid;

    m_width_isValid = ::OpenAPI::fromJsonValue(m_width, json[QString("width")]);
    m_width_isSet = !json[QString("width")].isNull() && m_width_isValid;
}

QString OAIDrawingAttributesPattern::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIDrawingAttributesPattern::asJsonObject() const {
    QJsonObject obj;
    if (m_color.isSet()) {
        obj.insert(QString("color"), ::OpenAPI::toJsonValue(m_color));
    }
    if (m_fit_to_curve_isSet) {
        obj.insert(QString("fitToCurve"), ::OpenAPI::toJsonValue(m_fit_to_curve));
    }
    if (m_height_isSet) {
        obj.insert(QString("height"), ::OpenAPI::toJsonValue(m_height));
    }
    if (m_ignore_pressure_isSet) {
        obj.insert(QString("ignorePressure"), ::OpenAPI::toJsonValue(m_ignore_pressure));
    }
    if (m_raster_op_isSet) {
        obj.insert(QString("rasterOp"), ::OpenAPI::toJsonValue(m_raster_op));
    }
    if (m_tip_isSet) {
        obj.insert(QString("tip"), ::OpenAPI::toJsonValue(m_tip));
    }
    if (m_width_isSet) {
        obj.insert(QString("width"), ::OpenAPI::toJsonValue(m_width));
    }
    return obj;
}

OAIDrawingAttributesPattern_color OAIDrawingAttributesPattern::getColor() const {
    return m_color;
}
void OAIDrawingAttributesPattern::setColor(const OAIDrawingAttributesPattern_color &color) {
    m_color = color;
    m_color_isSet = true;
}

bool OAIDrawingAttributesPattern::is_color_Set() const{
    return m_color_isSet;
}

bool OAIDrawingAttributesPattern::is_color_Valid() const{
    return m_color_isValid;
}

bool OAIDrawingAttributesPattern::isFitToCurve() const {
    return m_fit_to_curve;
}
void OAIDrawingAttributesPattern::setFitToCurve(const bool &fit_to_curve) {
    m_fit_to_curve = fit_to_curve;
    m_fit_to_curve_isSet = true;
}

bool OAIDrawingAttributesPattern::is_fit_to_curve_Set() const{
    return m_fit_to_curve_isSet;
}

bool OAIDrawingAttributesPattern::is_fit_to_curve_Valid() const{
    return m_fit_to_curve_isValid;
}

double OAIDrawingAttributesPattern::getHeight() const {
    return m_height;
}
void OAIDrawingAttributesPattern::setHeight(const double &height) {
    m_height = height;
    m_height_isSet = true;
}

bool OAIDrawingAttributesPattern::is_height_Set() const{
    return m_height_isSet;
}

bool OAIDrawingAttributesPattern::is_height_Valid() const{
    return m_height_isValid;
}

bool OAIDrawingAttributesPattern::isIgnorePressure() const {
    return m_ignore_pressure;
}
void OAIDrawingAttributesPattern::setIgnorePressure(const bool &ignore_pressure) {
    m_ignore_pressure = ignore_pressure;
    m_ignore_pressure_isSet = true;
}

bool OAIDrawingAttributesPattern::is_ignore_pressure_Set() const{
    return m_ignore_pressure_isSet;
}

bool OAIDrawingAttributesPattern::is_ignore_pressure_Valid() const{
    return m_ignore_pressure_isValid;
}

QString OAIDrawingAttributesPattern::getRasterOp() const {
    return m_raster_op;
}
void OAIDrawingAttributesPattern::setRasterOp(const QString &raster_op) {
    m_raster_op = raster_op;
    m_raster_op_isSet = true;
}

bool OAIDrawingAttributesPattern::is_raster_op_Set() const{
    return m_raster_op_isSet;
}

bool OAIDrawingAttributesPattern::is_raster_op_Valid() const{
    return m_raster_op_isValid;
}

QString OAIDrawingAttributesPattern::getTip() const {
    return m_tip;
}
void OAIDrawingAttributesPattern::setTip(const QString &tip) {
    m_tip = tip;
    m_tip_isSet = true;
}

bool OAIDrawingAttributesPattern::is_tip_Set() const{
    return m_tip_isSet;
}

bool OAIDrawingAttributesPattern::is_tip_Valid() const{
    return m_tip_isValid;
}

double OAIDrawingAttributesPattern::getWidth() const {
    return m_width;
}
void OAIDrawingAttributesPattern::setWidth(const double &width) {
    m_width = width;
    m_width_isSet = true;
}

bool OAIDrawingAttributesPattern::is_width_Set() const{
    return m_width_isSet;
}

bool OAIDrawingAttributesPattern::is_width_Valid() const{
    return m_width_isValid;
}

bool OAIDrawingAttributesPattern::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_color.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_fit_to_curve_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_height_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ignore_pressure_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_raster_op_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_width_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIDrawingAttributesPattern::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
