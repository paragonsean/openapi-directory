/**
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAlternatePattern_inner.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAlternatePattern_inner::OAIAlternatePattern_inner(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAlternatePattern_inner::OAIAlternatePattern_inner() {
    this->initializeModel();
}

OAIAlternatePattern_inner::~OAIAlternatePattern_inner() {}

void OAIAlternatePattern_inner::initializeModel() {

    m_category_isSet = false;
    m_category_isValid = false;

    m_confidence_isSet = false;
    m_confidence_isValid = false;

    m_points_isSet = false;
    m_points_isValid = false;

    m_recognized_string_isSet = false;
    m_recognized_string_isValid = false;

    m_rotation_angle_isSet = false;
    m_rotation_angle_isValid = false;
}

void OAIAlternatePattern_inner::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAlternatePattern_inner::fromJsonObject(QJsonObject json) {

    m_category_isValid = ::OpenAPI::fromJsonValue(m_category, json[QString("category")]);
    m_category_isSet = !json[QString("category")].isNull() && m_category_isValid;

    m_confidence_isValid = ::OpenAPI::fromJsonValue(m_confidence, json[QString("confidence")]);
    m_confidence_isSet = !json[QString("confidence")].isNull() && m_confidence_isValid;

    m_points_isValid = ::OpenAPI::fromJsonValue(m_points, json[QString("points")]);
    m_points_isSet = !json[QString("points")].isNull() && m_points_isValid;

    m_recognized_string_isValid = ::OpenAPI::fromJsonValue(m_recognized_string, json[QString("recognizedString")]);
    m_recognized_string_isSet = !json[QString("recognizedString")].isNull() && m_recognized_string_isValid;

    m_rotation_angle_isValid = ::OpenAPI::fromJsonValue(m_rotation_angle, json[QString("rotationAngle")]);
    m_rotation_angle_isSet = !json[QString("rotationAngle")].isNull() && m_rotation_angle_isValid;
}

QString OAIAlternatePattern_inner::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAlternatePattern_inner::asJsonObject() const {
    QJsonObject obj;
    if (m_category.isSet()) {
        obj.insert(QString("category"), ::OpenAPI::toJsonValue(m_category));
    }
    if (m_confidence_isSet) {
        obj.insert(QString("confidence"), ::OpenAPI::toJsonValue(m_confidence));
    }
    if (m_points.size() > 0) {
        obj.insert(QString("points"), ::OpenAPI::toJsonValue(m_points));
    }
    if (m_recognized_string_isSet) {
        obj.insert(QString("recognizedString"), ::OpenAPI::toJsonValue(m_recognized_string));
    }
    if (m_rotation_angle_isSet) {
        obj.insert(QString("rotationAngle"), ::OpenAPI::toJsonValue(m_rotation_angle));
    }
    return obj;
}

OAILeafCategoryPattern OAIAlternatePattern_inner::getCategory() const {
    return m_category;
}
void OAIAlternatePattern_inner::setCategory(const OAILeafCategoryPattern &category) {
    m_category = category;
    m_category_isSet = true;
}

bool OAIAlternatePattern_inner::is_category_Set() const{
    return m_category_isSet;
}

bool OAIAlternatePattern_inner::is_category_Valid() const{
    return m_category_isValid;
}

double OAIAlternatePattern_inner::getConfidence() const {
    return m_confidence;
}
void OAIAlternatePattern_inner::setConfidence(const double &confidence) {
    m_confidence = confidence;
    m_confidence_isSet = true;
}

bool OAIAlternatePattern_inner::is_confidence_Set() const{
    return m_confidence_isSet;
}

bool OAIAlternatePattern_inner::is_confidence_Valid() const{
    return m_confidence_isValid;
}

QList<OAIPointDetailsPattern> OAIAlternatePattern_inner::getPoints() const {
    return m_points;
}
void OAIAlternatePattern_inner::setPoints(const QList<OAIPointDetailsPattern> &points) {
    m_points = points;
    m_points_isSet = true;
}

bool OAIAlternatePattern_inner::is_points_Set() const{
    return m_points_isSet;
}

bool OAIAlternatePattern_inner::is_points_Valid() const{
    return m_points_isValid;
}

QString OAIAlternatePattern_inner::getRecognizedString() const {
    return m_recognized_string;
}
void OAIAlternatePattern_inner::setRecognizedString(const QString &recognized_string) {
    m_recognized_string = recognized_string;
    m_recognized_string_isSet = true;
}

bool OAIAlternatePattern_inner::is_recognized_string_Set() const{
    return m_recognized_string_isSet;
}

bool OAIAlternatePattern_inner::is_recognized_string_Valid() const{
    return m_recognized_string_isValid;
}

double OAIAlternatePattern_inner::getRotationAngle() const {
    return m_rotation_angle;
}
void OAIAlternatePattern_inner::setRotationAngle(const double &rotation_angle) {
    m_rotation_angle = rotation_angle;
    m_rotation_angle_isSet = true;
}

bool OAIAlternatePattern_inner::is_rotation_angle_Set() const{
    return m_rotation_angle_isSet;
}

bool OAIAlternatePattern_inner::is_rotation_angle_Valid() const{
    return m_rotation_angle_isValid;
}

bool OAIAlternatePattern_inner::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_category.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_confidence_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_points.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_recognized_string_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rotation_angle_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAlternatePattern_inner::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_category_isValid && m_recognized_string_isValid && true;
}

} // namespace OpenAPI
