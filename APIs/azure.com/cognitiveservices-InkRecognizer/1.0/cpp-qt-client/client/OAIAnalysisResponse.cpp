/**
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAnalysisResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAnalysisResponse::OAIAnalysisResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAnalysisResponse::OAIAnalysisResponse() {
    this->initializeModel();
}

OAIAnalysisResponse::~OAIAnalysisResponse() {}

void OAIAnalysisResponse::initializeModel() {

    m_language_isSet = false;
    m_language_isValid = false;

    m_recognition_units_isSet = false;
    m_recognition_units_isValid = false;

    m_unit_isSet = false;
    m_unit_isValid = false;

    m_unit_multiple_isSet = false;
    m_unit_multiple_isValid = false;
}

void OAIAnalysisResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAnalysisResponse::fromJsonObject(QJsonObject json) {

    m_language_isValid = ::OpenAPI::fromJsonValue(m_language, json[QString("language")]);
    m_language_isSet = !json[QString("language")].isNull() && m_language_isValid;

    m_recognition_units_isValid = ::OpenAPI::fromJsonValue(m_recognition_units, json[QString("recognitionUnits")]);
    m_recognition_units_isSet = !json[QString("recognitionUnits")].isNull() && m_recognition_units_isValid;

    m_unit_isValid = ::OpenAPI::fromJsonValue(m_unit, json[QString("unit")]);
    m_unit_isSet = !json[QString("unit")].isNull() && m_unit_isValid;

    m_unit_multiple_isValid = ::OpenAPI::fromJsonValue(m_unit_multiple, json[QString("unitMultiple")]);
    m_unit_multiple_isSet = !json[QString("unitMultiple")].isNull() && m_unit_multiple_isValid;
}

QString OAIAnalysisResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAnalysisResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_language_isSet) {
        obj.insert(QString("language"), ::OpenAPI::toJsonValue(m_language));
    }
    if (m_recognition_units.size() > 0) {
        obj.insert(QString("recognitionUnits"), ::OpenAPI::toJsonValue(m_recognition_units));
    }
    if (m_unit_isSet) {
        obj.insert(QString("unit"), ::OpenAPI::toJsonValue(m_unit));
    }
    if (m_unit_multiple_isSet) {
        obj.insert(QString("unitMultiple"), ::OpenAPI::toJsonValue(m_unit_multiple));
    }
    return obj;
}

QString OAIAnalysisResponse::getLanguage() const {
    return m_language;
}
void OAIAnalysisResponse::setLanguage(const QString &language) {
    m_language = language;
    m_language_isSet = true;
}

bool OAIAnalysisResponse::is_language_Set() const{
    return m_language_isSet;
}

bool OAIAnalysisResponse::is_language_Valid() const{
    return m_language_isValid;
}

QList<OAIRecognitionUnit_inner> OAIAnalysisResponse::getRecognitionUnits() const {
    return m_recognition_units;
}
void OAIAnalysisResponse::setRecognitionUnits(const QList<OAIRecognitionUnit_inner> &recognition_units) {
    m_recognition_units = recognition_units;
    m_recognition_units_isSet = true;
}

bool OAIAnalysisResponse::is_recognition_units_Set() const{
    return m_recognition_units_isSet;
}

bool OAIAnalysisResponse::is_recognition_units_Valid() const{
    return m_recognition_units_isValid;
}

QString OAIAnalysisResponse::getUnit() const {
    return m_unit;
}
void OAIAnalysisResponse::setUnit(const QString &unit) {
    m_unit = unit;
    m_unit_isSet = true;
}

bool OAIAnalysisResponse::is_unit_Set() const{
    return m_unit_isSet;
}

bool OAIAnalysisResponse::is_unit_Valid() const{
    return m_unit_isValid;
}

double OAIAnalysisResponse::getUnitMultiple() const {
    return m_unit_multiple;
}
void OAIAnalysisResponse::setUnitMultiple(const double &unit_multiple) {
    m_unit_multiple = unit_multiple;
    m_unit_multiple_isSet = true;
}

bool OAIAnalysisResponse::is_unit_multiple_Set() const{
    return m_unit_multiple_isSet;
}

bool OAIAnalysisResponse::is_unit_multiple_Valid() const{
    return m_unit_multiple_isValid;
}

bool OAIAnalysisResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_language_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_recognition_units.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_unit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unit_multiple_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAnalysisResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_recognition_units_isValid && true;
}

} // namespace OpenAPI
