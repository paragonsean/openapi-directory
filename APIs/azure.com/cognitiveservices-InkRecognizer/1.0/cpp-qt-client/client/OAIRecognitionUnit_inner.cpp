/**
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRecognitionUnit_inner.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRecognitionUnit_inner::OAIRecognitionUnit_inner(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRecognitionUnit_inner::OAIRecognitionUnit_inner() {
    this->initializeModel();
}

OAIRecognitionUnit_inner::~OAIRecognitionUnit_inner() {}

void OAIRecognitionUnit_inner::initializeModel() {

    m_alternates_isSet = false;
    m_alternates_isValid = false;

    m_bounding_rectangle_isSet = false;
    m_bounding_rectangle_isValid = false;

    m_category_isSet = false;
    m_category_isValid = false;

    m_center_isSet = false;
    m_center_isValid = false;

    m_child_ids_isSet = false;
    m_child_ids_isValid = false;

    m_r_class_isSet = false;
    m_r_class_isValid = false;

    m_confidence_isSet = false;
    m_confidence_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_parent_id_isSet = false;
    m_parent_id_isValid = false;

    m_points_isSet = false;
    m_points_isValid = false;

    m_recognized_object_isSet = false;
    m_recognized_object_isValid = false;

    m_recognized_text_isSet = false;
    m_recognized_text_isValid = false;

    m_rotated_bounding_rectangle_isSet = false;
    m_rotated_bounding_rectangle_isValid = false;

    m_rotation_angle_isSet = false;
    m_rotation_angle_isValid = false;

    m_stroke_ids_isSet = false;
    m_stroke_ids_isValid = false;
}

void OAIRecognitionUnit_inner::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRecognitionUnit_inner::fromJsonObject(QJsonObject json) {

    m_alternates_isValid = ::OpenAPI::fromJsonValue(m_alternates, json[QString("alternates")]);
    m_alternates_isSet = !json[QString("alternates")].isNull() && m_alternates_isValid;

    m_bounding_rectangle_isValid = ::OpenAPI::fromJsonValue(m_bounding_rectangle, json[QString("boundingRectangle")]);
    m_bounding_rectangle_isSet = !json[QString("boundingRectangle")].isNull() && m_bounding_rectangle_isValid;

    m_category_isValid = ::OpenAPI::fromJsonValue(m_category, json[QString("category")]);
    m_category_isSet = !json[QString("category")].isNull() && m_category_isValid;

    m_center_isValid = ::OpenAPI::fromJsonValue(m_center, json[QString("center")]);
    m_center_isSet = !json[QString("center")].isNull() && m_center_isValid;

    m_child_ids_isValid = ::OpenAPI::fromJsonValue(m_child_ids, json[QString("childIds")]);
    m_child_ids_isSet = !json[QString("childIds")].isNull() && m_child_ids_isValid;

    m_r_class_isValid = ::OpenAPI::fromJsonValue(m_r_class, json[QString("class")]);
    m_r_class_isSet = !json[QString("class")].isNull() && m_r_class_isValid;

    m_confidence_isValid = ::OpenAPI::fromJsonValue(m_confidence, json[QString("confidence")]);
    m_confidence_isSet = !json[QString("confidence")].isNull() && m_confidence_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_parent_id_isValid = ::OpenAPI::fromJsonValue(m_parent_id, json[QString("parentId")]);
    m_parent_id_isSet = !json[QString("parentId")].isNull() && m_parent_id_isValid;

    m_points_isValid = ::OpenAPI::fromJsonValue(m_points, json[QString("points")]);
    m_points_isSet = !json[QString("points")].isNull() && m_points_isValid;

    m_recognized_object_isValid = ::OpenAPI::fromJsonValue(m_recognized_object, json[QString("recognizedObject")]);
    m_recognized_object_isSet = !json[QString("recognizedObject")].isNull() && m_recognized_object_isValid;

    m_recognized_text_isValid = ::OpenAPI::fromJsonValue(m_recognized_text, json[QString("recognizedText")]);
    m_recognized_text_isSet = !json[QString("recognizedText")].isNull() && m_recognized_text_isValid;

    m_rotated_bounding_rectangle_isValid = ::OpenAPI::fromJsonValue(m_rotated_bounding_rectangle, json[QString("rotatedBoundingRectangle")]);
    m_rotated_bounding_rectangle_isSet = !json[QString("rotatedBoundingRectangle")].isNull() && m_rotated_bounding_rectangle_isValid;

    m_rotation_angle_isValid = ::OpenAPI::fromJsonValue(m_rotation_angle, json[QString("rotationAngle")]);
    m_rotation_angle_isSet = !json[QString("rotationAngle")].isNull() && m_rotation_angle_isValid;

    m_stroke_ids_isValid = ::OpenAPI::fromJsonValue(m_stroke_ids, json[QString("strokeIds")]);
    m_stroke_ids_isSet = !json[QString("strokeIds")].isNull() && m_stroke_ids_isValid;
}

QString OAIRecognitionUnit_inner::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRecognitionUnit_inner::asJsonObject() const {
    QJsonObject obj;
    if (m_alternates.size() > 0) {
        obj.insert(QString("alternates"), ::OpenAPI::toJsonValue(m_alternates));
    }
    if (m_bounding_rectangle.isSet()) {
        obj.insert(QString("boundingRectangle"), ::OpenAPI::toJsonValue(m_bounding_rectangle));
    }
    if (m_category.isSet()) {
        obj.insert(QString("category"), ::OpenAPI::toJsonValue(m_category));
    }
    if (m_center.isSet()) {
        obj.insert(QString("center"), ::OpenAPI::toJsonValue(m_center));
    }
    if (m_child_ids.size() > 0) {
        obj.insert(QString("childIds"), ::OpenAPI::toJsonValue(m_child_ids));
    }
    if (m_r_class.isSet()) {
        obj.insert(QString("class"), ::OpenAPI::toJsonValue(m_r_class));
    }
    if (m_confidence_isSet) {
        obj.insert(QString("confidence"), ::OpenAPI::toJsonValue(m_confidence));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_parent_id_isSet) {
        obj.insert(QString("parentId"), ::OpenAPI::toJsonValue(m_parent_id));
    }
    if (m_points.size() > 0) {
        obj.insert(QString("points"), ::OpenAPI::toJsonValue(m_points));
    }
    if (m_recognized_object.isSet()) {
        obj.insert(QString("recognizedObject"), ::OpenAPI::toJsonValue(m_recognized_object));
    }
    if (m_recognized_text_isSet) {
        obj.insert(QString("recognizedText"), ::OpenAPI::toJsonValue(m_recognized_text));
    }
    if (m_rotated_bounding_rectangle.size() > 0) {
        obj.insert(QString("rotatedBoundingRectangle"), ::OpenAPI::toJsonValue(m_rotated_bounding_rectangle));
    }
    if (m_rotation_angle_isSet) {
        obj.insert(QString("rotationAngle"), ::OpenAPI::toJsonValue(m_rotation_angle));
    }
    if (m_stroke_ids.size() > 0) {
        obj.insert(QString("strokeIds"), ::OpenAPI::toJsonValue(m_stroke_ids));
    }
    return obj;
}

QList<OAIAlternatePattern_inner> OAIRecognitionUnit_inner::getAlternates() const {
    return m_alternates;
}
void OAIRecognitionUnit_inner::setAlternates(const QList<OAIAlternatePattern_inner> &alternates) {
    m_alternates = alternates;
    m_alternates_isSet = true;
}

bool OAIRecognitionUnit_inner::is_alternates_Set() const{
    return m_alternates_isSet;
}

bool OAIRecognitionUnit_inner::is_alternates_Valid() const{
    return m_alternates_isValid;
}

OAIRecognitionUnit_inner_boundingRectangle OAIRecognitionUnit_inner::getBoundingRectangle() const {
    return m_bounding_rectangle;
}
void OAIRecognitionUnit_inner::setBoundingRectangle(const OAIRecognitionUnit_inner_boundingRectangle &bounding_rectangle) {
    m_bounding_rectangle = bounding_rectangle;
    m_bounding_rectangle_isSet = true;
}

bool OAIRecognitionUnit_inner::is_bounding_rectangle_Set() const{
    return m_bounding_rectangle_isSet;
}

bool OAIRecognitionUnit_inner::is_bounding_rectangle_Valid() const{
    return m_bounding_rectangle_isValid;
}

OAICategoryPattern OAIRecognitionUnit_inner::getCategory() const {
    return m_category;
}
void OAIRecognitionUnit_inner::setCategory(const OAICategoryPattern &category) {
    m_category = category;
    m_category_isSet = true;
}

bool OAIRecognitionUnit_inner::is_category_Set() const{
    return m_category_isSet;
}

bool OAIRecognitionUnit_inner::is_category_Valid() const{
    return m_category_isValid;
}

OAIPointDetailsPattern OAIRecognitionUnit_inner::getCenter() const {
    return m_center;
}
void OAIRecognitionUnit_inner::setCenter(const OAIPointDetailsPattern &center) {
    m_center = center;
    m_center_isSet = true;
}

bool OAIRecognitionUnit_inner::is_center_Set() const{
    return m_center_isSet;
}

bool OAIRecognitionUnit_inner::is_center_Valid() const{
    return m_center_isValid;
}

QList<qint32> OAIRecognitionUnit_inner::getChildIds() const {
    return m_child_ids;
}
void OAIRecognitionUnit_inner::setChildIds(const QList<qint32> &child_ids) {
    m_child_ids = child_ids;
    m_child_ids_isSet = true;
}

bool OAIRecognitionUnit_inner::is_child_ids_Set() const{
    return m_child_ids_isSet;
}

bool OAIRecognitionUnit_inner::is_child_ids_Valid() const{
    return m_child_ids_isValid;
}

OAIClassPattern OAIRecognitionUnit_inner::getRClass() const {
    return m_r_class;
}
void OAIRecognitionUnit_inner::setRClass(const OAIClassPattern &r_class) {
    m_r_class = r_class;
    m_r_class_isSet = true;
}

bool OAIRecognitionUnit_inner::is_r_class_Set() const{
    return m_r_class_isSet;
}

bool OAIRecognitionUnit_inner::is_r_class_Valid() const{
    return m_r_class_isValid;
}

double OAIRecognitionUnit_inner::getConfidence() const {
    return m_confidence;
}
void OAIRecognitionUnit_inner::setConfidence(const double &confidence) {
    m_confidence = confidence;
    m_confidence_isSet = true;
}

bool OAIRecognitionUnit_inner::is_confidence_Set() const{
    return m_confidence_isSet;
}

bool OAIRecognitionUnit_inner::is_confidence_Valid() const{
    return m_confidence_isValid;
}

qint32 OAIRecognitionUnit_inner::getId() const {
    return m_id;
}
void OAIRecognitionUnit_inner::setId(const qint32 &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIRecognitionUnit_inner::is_id_Set() const{
    return m_id_isSet;
}

bool OAIRecognitionUnit_inner::is_id_Valid() const{
    return m_id_isValid;
}

qint32 OAIRecognitionUnit_inner::getParentId() const {
    return m_parent_id;
}
void OAIRecognitionUnit_inner::setParentId(const qint32 &parent_id) {
    m_parent_id = parent_id;
    m_parent_id_isSet = true;
}

bool OAIRecognitionUnit_inner::is_parent_id_Set() const{
    return m_parent_id_isSet;
}

bool OAIRecognitionUnit_inner::is_parent_id_Valid() const{
    return m_parent_id_isValid;
}

QList<OAIPointDetailsPattern> OAIRecognitionUnit_inner::getPoints() const {
    return m_points;
}
void OAIRecognitionUnit_inner::setPoints(const QList<OAIPointDetailsPattern> &points) {
    m_points = points;
    m_points_isSet = true;
}

bool OAIRecognitionUnit_inner::is_points_Set() const{
    return m_points_isSet;
}

bool OAIRecognitionUnit_inner::is_points_Valid() const{
    return m_points_isValid;
}

OAIShapePattern OAIRecognitionUnit_inner::getRecognizedObject() const {
    return m_recognized_object;
}
void OAIRecognitionUnit_inner::setRecognizedObject(const OAIShapePattern &recognized_object) {
    m_recognized_object = recognized_object;
    m_recognized_object_isSet = true;
}

bool OAIRecognitionUnit_inner::is_recognized_object_Set() const{
    return m_recognized_object_isSet;
}

bool OAIRecognitionUnit_inner::is_recognized_object_Valid() const{
    return m_recognized_object_isValid;
}

QString OAIRecognitionUnit_inner::getRecognizedText() const {
    return m_recognized_text;
}
void OAIRecognitionUnit_inner::setRecognizedText(const QString &recognized_text) {
    m_recognized_text = recognized_text;
    m_recognized_text_isSet = true;
}

bool OAIRecognitionUnit_inner::is_recognized_text_Set() const{
    return m_recognized_text_isSet;
}

bool OAIRecognitionUnit_inner::is_recognized_text_Valid() const{
    return m_recognized_text_isValid;
}

QList<OAIPointDetailsPattern> OAIRecognitionUnit_inner::getRotatedBoundingRectangle() const {
    return m_rotated_bounding_rectangle;
}
void OAIRecognitionUnit_inner::setRotatedBoundingRectangle(const QList<OAIPointDetailsPattern> &rotated_bounding_rectangle) {
    m_rotated_bounding_rectangle = rotated_bounding_rectangle;
    m_rotated_bounding_rectangle_isSet = true;
}

bool OAIRecognitionUnit_inner::is_rotated_bounding_rectangle_Set() const{
    return m_rotated_bounding_rectangle_isSet;
}

bool OAIRecognitionUnit_inner::is_rotated_bounding_rectangle_Valid() const{
    return m_rotated_bounding_rectangle_isValid;
}

double OAIRecognitionUnit_inner::getRotationAngle() const {
    return m_rotation_angle;
}
void OAIRecognitionUnit_inner::setRotationAngle(const double &rotation_angle) {
    m_rotation_angle = rotation_angle;
    m_rotation_angle_isSet = true;
}

bool OAIRecognitionUnit_inner::is_rotation_angle_Set() const{
    return m_rotation_angle_isSet;
}

bool OAIRecognitionUnit_inner::is_rotation_angle_Valid() const{
    return m_rotation_angle_isValid;
}

QList<qint32> OAIRecognitionUnit_inner::getStrokeIds() const {
    return m_stroke_ids;
}
void OAIRecognitionUnit_inner::setStrokeIds(const QList<qint32> &stroke_ids) {
    m_stroke_ids = stroke_ids;
    m_stroke_ids_isSet = true;
}

bool OAIRecognitionUnit_inner::is_stroke_ids_Set() const{
    return m_stroke_ids_isSet;
}

bool OAIRecognitionUnit_inner::is_stroke_ids_Valid() const{
    return m_stroke_ids_isValid;
}

bool OAIRecognitionUnit_inner::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alternates.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_bounding_rectangle.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_category.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_center.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_child_ids.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_class.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_confidence_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_parent_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_points.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_recognized_object.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_recognized_text_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rotated_bounding_rectangle.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_rotation_angle_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stroke_ids.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRecognitionUnit_inner::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_category_isValid && m_r_class_isValid && m_id_isValid && m_parent_id_isValid && m_stroke_ids_isValid && true;
}

} // namespace OpenAPI
