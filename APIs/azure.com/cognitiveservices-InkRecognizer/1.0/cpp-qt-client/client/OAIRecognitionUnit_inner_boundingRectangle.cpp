/**
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRecognitionUnit_inner_boundingRectangle.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRecognitionUnit_inner_boundingRectangle::OAIRecognitionUnit_inner_boundingRectangle(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRecognitionUnit_inner_boundingRectangle::OAIRecognitionUnit_inner_boundingRectangle() {
    this->initializeModel();
}

OAIRecognitionUnit_inner_boundingRectangle::~OAIRecognitionUnit_inner_boundingRectangle() {}

void OAIRecognitionUnit_inner_boundingRectangle::initializeModel() {

    m_height_isSet = false;
    m_height_isValid = false;

    m_top_x_isSet = false;
    m_top_x_isValid = false;

    m_top_y_isSet = false;
    m_top_y_isValid = false;

    m_width_isSet = false;
    m_width_isValid = false;
}

void OAIRecognitionUnit_inner_boundingRectangle::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRecognitionUnit_inner_boundingRectangle::fromJsonObject(QJsonObject json) {

    m_height_isValid = ::OpenAPI::fromJsonValue(m_height, json[QString("height")]);
    m_height_isSet = !json[QString("height")].isNull() && m_height_isValid;

    m_top_x_isValid = ::OpenAPI::fromJsonValue(m_top_x, json[QString("topX")]);
    m_top_x_isSet = !json[QString("topX")].isNull() && m_top_x_isValid;

    m_top_y_isValid = ::OpenAPI::fromJsonValue(m_top_y, json[QString("topY")]);
    m_top_y_isSet = !json[QString("topY")].isNull() && m_top_y_isValid;

    m_width_isValid = ::OpenAPI::fromJsonValue(m_width, json[QString("width")]);
    m_width_isSet = !json[QString("width")].isNull() && m_width_isValid;
}

QString OAIRecognitionUnit_inner_boundingRectangle::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRecognitionUnit_inner_boundingRectangle::asJsonObject() const {
    QJsonObject obj;
    if (m_height_isSet) {
        obj.insert(QString("height"), ::OpenAPI::toJsonValue(m_height));
    }
    if (m_top_x_isSet) {
        obj.insert(QString("topX"), ::OpenAPI::toJsonValue(m_top_x));
    }
    if (m_top_y_isSet) {
        obj.insert(QString("topY"), ::OpenAPI::toJsonValue(m_top_y));
    }
    if (m_width_isSet) {
        obj.insert(QString("width"), ::OpenAPI::toJsonValue(m_width));
    }
    return obj;
}

double OAIRecognitionUnit_inner_boundingRectangle::getHeight() const {
    return m_height;
}
void OAIRecognitionUnit_inner_boundingRectangle::setHeight(const double &height) {
    m_height = height;
    m_height_isSet = true;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_height_Set() const{
    return m_height_isSet;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_height_Valid() const{
    return m_height_isValid;
}

double OAIRecognitionUnit_inner_boundingRectangle::getTopX() const {
    return m_top_x;
}
void OAIRecognitionUnit_inner_boundingRectangle::setTopX(const double &top_x) {
    m_top_x = top_x;
    m_top_x_isSet = true;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_top_x_Set() const{
    return m_top_x_isSet;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_top_x_Valid() const{
    return m_top_x_isValid;
}

double OAIRecognitionUnit_inner_boundingRectangle::getTopY() const {
    return m_top_y;
}
void OAIRecognitionUnit_inner_boundingRectangle::setTopY(const double &top_y) {
    m_top_y = top_y;
    m_top_y_isSet = true;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_top_y_Set() const{
    return m_top_y_isSet;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_top_y_Valid() const{
    return m_top_y_isValid;
}

double OAIRecognitionUnit_inner_boundingRectangle::getWidth() const {
    return m_width;
}
void OAIRecognitionUnit_inner_boundingRectangle::setWidth(const double &width) {
    m_width = width;
    m_width_isSet = true;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_width_Set() const{
    return m_width_isSet;
}

bool OAIRecognitionUnit_inner_boundingRectangle::is_width_Valid() const{
    return m_width_isValid;
}

bool OAIRecognitionUnit_inner_boundingRectangle::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_height_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_top_x_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_top_y_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_width_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRecognitionUnit_inner_boundingRectangle::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
