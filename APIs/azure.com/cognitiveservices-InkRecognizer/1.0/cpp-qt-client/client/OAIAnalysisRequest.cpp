/**
 * Ink Recognizer Client
 * The service is used to perform ink layout and recognition of written words and shapes. Ink strokes passed to the service are recognized and organized into recognition results in the response
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAnalysisRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAnalysisRequest::OAIAnalysisRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAnalysisRequest::OAIAnalysisRequest() {
    this->initializeModel();
}

OAIAnalysisRequest::~OAIAnalysisRequest() {}

void OAIAnalysisRequest::initializeModel() {

    m_application_type_isSet = false;
    m_application_type_isValid = false;

    m_ink_point_value_attributes_isSet = false;
    m_ink_point_value_attributes_isValid = false;

    m_input_device_kind_isSet = false;
    m_input_device_kind_isValid = false;

    m_language_isSet = false;
    m_language_isValid = false;

    m_strokes_isSet = false;
    m_strokes_isValid = false;

    m_unit_isSet = false;
    m_unit_isValid = false;

    m_unit_multiple_isSet = false;
    m_unit_multiple_isValid = false;
}

void OAIAnalysisRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAnalysisRequest::fromJsonObject(QJsonObject json) {

    m_application_type_isValid = ::OpenAPI::fromJsonValue(m_application_type, json[QString("applicationType")]);
    m_application_type_isSet = !json[QString("applicationType")].isNull() && m_application_type_isValid;

    m_ink_point_value_attributes_isValid = ::OpenAPI::fromJsonValue(m_ink_point_value_attributes, json[QString("inkPointValueAttributes")]);
    m_ink_point_value_attributes_isSet = !json[QString("inkPointValueAttributes")].isNull() && m_ink_point_value_attributes_isValid;

    m_input_device_kind_isValid = ::OpenAPI::fromJsonValue(m_input_device_kind, json[QString("inputDeviceKind")]);
    m_input_device_kind_isSet = !json[QString("inputDeviceKind")].isNull() && m_input_device_kind_isValid;

    m_language_isValid = ::OpenAPI::fromJsonValue(m_language, json[QString("language")]);
    m_language_isSet = !json[QString("language")].isNull() && m_language_isValid;

    m_strokes_isValid = ::OpenAPI::fromJsonValue(m_strokes, json[QString("strokes")]);
    m_strokes_isSet = !json[QString("strokes")].isNull() && m_strokes_isValid;

    m_unit_isValid = ::OpenAPI::fromJsonValue(m_unit, json[QString("unit")]);
    m_unit_isSet = !json[QString("unit")].isNull() && m_unit_isValid;

    m_unit_multiple_isValid = ::OpenAPI::fromJsonValue(m_unit_multiple, json[QString("unitMultiple")]);
    m_unit_multiple_isSet = !json[QString("unitMultiple")].isNull() && m_unit_multiple_isValid;
}

QString OAIAnalysisRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAnalysisRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_application_type_isSet) {
        obj.insert(QString("applicationType"), ::OpenAPI::toJsonValue(m_application_type));
    }
    if (m_ink_point_value_attributes.size() > 0) {
        obj.insert(QString("inkPointValueAttributes"), ::OpenAPI::toJsonValue(m_ink_point_value_attributes));
    }
    if (m_input_device_kind_isSet) {
        obj.insert(QString("inputDeviceKind"), ::OpenAPI::toJsonValue(m_input_device_kind));
    }
    if (m_language_isSet) {
        obj.insert(QString("language"), ::OpenAPI::toJsonValue(m_language));
    }
    if (m_strokes.size() > 0) {
        obj.insert(QString("strokes"), ::OpenAPI::toJsonValue(m_strokes));
    }
    if (m_unit_isSet) {
        obj.insert(QString("unit"), ::OpenAPI::toJsonValue(m_unit));
    }
    if (m_unit_multiple_isSet) {
        obj.insert(QString("unitMultiple"), ::OpenAPI::toJsonValue(m_unit_multiple));
    }
    return obj;
}

QString OAIAnalysisRequest::getApplicationType() const {
    return m_application_type;
}
void OAIAnalysisRequest::setApplicationType(const QString &application_type) {
    m_application_type = application_type;
    m_application_type_isSet = true;
}

bool OAIAnalysisRequest::is_application_type_Set() const{
    return m_application_type_isSet;
}

bool OAIAnalysisRequest::is_application_type_Valid() const{
    return m_application_type_isValid;
}

QList<OAIInkPointValueAttribute> OAIAnalysisRequest::getInkPointValueAttributes() const {
    return m_ink_point_value_attributes;
}
void OAIAnalysisRequest::setInkPointValueAttributes(const QList<OAIInkPointValueAttribute> &ink_point_value_attributes) {
    m_ink_point_value_attributes = ink_point_value_attributes;
    m_ink_point_value_attributes_isSet = true;
}

bool OAIAnalysisRequest::is_ink_point_value_attributes_Set() const{
    return m_ink_point_value_attributes_isSet;
}

bool OAIAnalysisRequest::is_ink_point_value_attributes_Valid() const{
    return m_ink_point_value_attributes_isValid;
}

QString OAIAnalysisRequest::getInputDeviceKind() const {
    return m_input_device_kind;
}
void OAIAnalysisRequest::setInputDeviceKind(const QString &input_device_kind) {
    m_input_device_kind = input_device_kind;
    m_input_device_kind_isSet = true;
}

bool OAIAnalysisRequest::is_input_device_kind_Set() const{
    return m_input_device_kind_isSet;
}

bool OAIAnalysisRequest::is_input_device_kind_Valid() const{
    return m_input_device_kind_isValid;
}

QString OAIAnalysisRequest::getLanguage() const {
    return m_language;
}
void OAIAnalysisRequest::setLanguage(const QString &language) {
    m_language = language;
    m_language_isSet = true;
}

bool OAIAnalysisRequest::is_language_Set() const{
    return m_language_isSet;
}

bool OAIAnalysisRequest::is_language_Valid() const{
    return m_language_isValid;
}

QList<OAIStroke> OAIAnalysisRequest::getStrokes() const {
    return m_strokes;
}
void OAIAnalysisRequest::setStrokes(const QList<OAIStroke> &strokes) {
    m_strokes = strokes;
    m_strokes_isSet = true;
}

bool OAIAnalysisRequest::is_strokes_Set() const{
    return m_strokes_isSet;
}

bool OAIAnalysisRequest::is_strokes_Valid() const{
    return m_strokes_isValid;
}

QString OAIAnalysisRequest::getUnit() const {
    return m_unit;
}
void OAIAnalysisRequest::setUnit(const QString &unit) {
    m_unit = unit;
    m_unit_isSet = true;
}

bool OAIAnalysisRequest::is_unit_Set() const{
    return m_unit_isSet;
}

bool OAIAnalysisRequest::is_unit_Valid() const{
    return m_unit_isValid;
}

double OAIAnalysisRequest::getUnitMultiple() const {
    return m_unit_multiple;
}
void OAIAnalysisRequest::setUnitMultiple(const double &unit_multiple) {
    m_unit_multiple = unit_multiple;
    m_unit_multiple_isSet = true;
}

bool OAIAnalysisRequest::is_unit_multiple_Set() const{
    return m_unit_multiple_isSet;
}

bool OAIAnalysisRequest::is_unit_multiple_Valid() const{
    return m_unit_multiple_isValid;
}

bool OAIAnalysisRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_application_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ink_point_value_attributes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_input_device_kind_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_language_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_strokes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_unit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unit_multiple_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAnalysisRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_language_isValid && m_strokes_isValid && true;
}

} // namespace OpenAPI
