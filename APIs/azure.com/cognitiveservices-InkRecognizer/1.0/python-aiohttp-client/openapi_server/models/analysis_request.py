# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.ink_point_value_attribute import InkPointValueAttribute
from openapi_server.models.stroke import Stroke
from openapi_server import util


class AnalysisRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, application_type: str=None, ink_point_value_attributes: List[InkPointValueAttribute]=None, input_device_kind: str=None, language: str=None, strokes: List[Stroke]=None, unit: str=None, unit_multiple: float=None):
        """AnalysisRequest - a model defined in OpenAPI

        :param application_type: The application_type of this AnalysisRequest.
        :param ink_point_value_attributes: The ink_point_value_attributes of this AnalysisRequest.
        :param input_device_kind: The input_device_kind of this AnalysisRequest.
        :param language: The language of this AnalysisRequest.
        :param strokes: The strokes of this AnalysisRequest.
        :param unit: The unit of this AnalysisRequest.
        :param unit_multiple: The unit_multiple of this AnalysisRequest.
        """
        self.openapi_types = {
            'application_type': str,
            'ink_point_value_attributes': List[InkPointValueAttribute],
            'input_device_kind': str,
            'language': str,
            'strokes': List[Stroke],
            'unit': str,
            'unit_multiple': float
        }

        self.attribute_map = {
            'application_type': 'applicationType',
            'ink_point_value_attributes': 'inkPointValueAttributes',
            'input_device_kind': 'inputDeviceKind',
            'language': 'language',
            'strokes': 'strokes',
            'unit': 'unit',
            'unit_multiple': 'unitMultiple'
        }

        self._application_type = application_type
        self._ink_point_value_attributes = ink_point_value_attributes
        self._input_device_kind = input_device_kind
        self._language = language
        self._strokes = strokes
        self._unit = unit
        self._unit_multiple = unit_multiple

    @classmethod
    def from_dict(cls, dikt: dict) -> 'AnalysisRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The analysisRequest of this AnalysisRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def application_type(self):
        """Gets the application_type of this AnalysisRequest.

        This describes the domain of the client application

        :return: The application_type of this AnalysisRequest.
        :rtype: str
        """
        return self._application_type

    @application_type.setter
    def application_type(self, application_type):
        """Sets the application_type of this AnalysisRequest.

        This describes the domain of the client application

        :param application_type: The application_type of this AnalysisRequest.
        :type application_type: str
        """
        allowed_values = ["drawing", "writing", "mixed"]  # noqa: E501
        if application_type not in allowed_values:
            raise ValueError(
                "Invalid value for `application_type` ({0}), must be one of {1}"
                .format(application_type, allowed_values)
            )

        self._application_type = application_type

    @property
    def ink_point_value_attributes(self):
        """Gets the ink_point_value_attributes of this AnalysisRequest.


        :return: The ink_point_value_attributes of this AnalysisRequest.
        :rtype: List[InkPointValueAttribute]
        """
        return self._ink_point_value_attributes

    @ink_point_value_attributes.setter
    def ink_point_value_attributes(self, ink_point_value_attributes):
        """Sets the ink_point_value_attributes of this AnalysisRequest.


        :param ink_point_value_attributes: The ink_point_value_attributes of this AnalysisRequest.
        :type ink_point_value_attributes: List[InkPointValueAttribute]
        """

        self._ink_point_value_attributes = ink_point_value_attributes

    @property
    def input_device_kind(self):
        """Gets the input_device_kind of this AnalysisRequest.

        This identifies the kind of device used as the writing instrument

        :return: The input_device_kind of this AnalysisRequest.
        :rtype: str
        """
        return self._input_device_kind

    @input_device_kind.setter
    def input_device_kind(self, input_device_kind):
        """Sets the input_device_kind of this AnalysisRequest.

        This identifies the kind of device used as the writing instrument

        :param input_device_kind: The input_device_kind of this AnalysisRequest.
        :type input_device_kind: str
        """
        allowed_values = ["digitizer", "pen", "lightPen", "touchScreen", "touchPad", "whiteBoard", "3dDigitizer", "stereoPlotter", "articulatedArm", "armature"]  # noqa: E501
        if input_device_kind not in allowed_values:
            raise ValueError(
                "Invalid value for `input_device_kind` ({0}), must be one of {1}"
                .format(input_device_kind, allowed_values)
            )

        self._input_device_kind = input_device_kind

    @property
    def language(self):
        """Gets the language of this AnalysisRequest.

        The IETF BCP 47 language code (for ex. en-US, en-GB, hi-IN etc.) of the expected language for the handwritten content in the ink strokes. The response will include results from this language.

        :return: The language of this AnalysisRequest.
        :rtype: str
        """
        return self._language

    @language.setter
    def language(self, language):
        """Sets the language of this AnalysisRequest.

        The IETF BCP 47 language code (for ex. en-US, en-GB, hi-IN etc.) of the expected language for the handwritten content in the ink strokes. The response will include results from this language.

        :param language: The language of this AnalysisRequest.
        :type language: str
        """
        if language is None:
            raise ValueError("Invalid value for `language`, must not be `None`")

        self._language = language

    @property
    def strokes(self):
        """Gets the strokes of this AnalysisRequest.

        This is the array of strokes sent for recognition. Best results are produced when the order of strokes added in the array matches the order in which the user created them. Changing the stroke order may produce unexpected results.

        :return: The strokes of this AnalysisRequest.
        :rtype: List[Stroke]
        """
        return self._strokes

    @strokes.setter
    def strokes(self, strokes):
        """Sets the strokes of this AnalysisRequest.

        This is the array of strokes sent for recognition. Best results are produced when the order of strokes added in the array matches the order in which the user created them. Changing the stroke order may produce unexpected results.

        :param strokes: The strokes of this AnalysisRequest.
        :type strokes: List[Stroke]
        """
        if strokes is None:
            raise ValueError("Invalid value for `strokes`, must not be `None`")

        self._strokes = strokes

    @property
    def unit(self):
        """Gets the unit of this AnalysisRequest.

        This is the physical unit of the ink strokes. It is up to the application developer to decide how to convert the device specific units to physical units before calling the service. The conversion factor can be different based on the type of the device used.

        :return: The unit of this AnalysisRequest.
        :rtype: str
        """
        return self._unit

    @unit.setter
    def unit(self, unit):
        """Sets the unit of this AnalysisRequest.

        This is the physical unit of the ink strokes. It is up to the application developer to decide how to convert the device specific units to physical units before calling the service. The conversion factor can be different based on the type of the device used.

        :param unit: The unit of this AnalysisRequest.
        :type unit: str
        """
        allowed_values = ["mm", "cm", "in"]  # noqa: E501
        if unit not in allowed_values:
            raise ValueError(
                "Invalid value for `unit` ({0}), must be one of {1}"
                .format(unit, allowed_values)
            )

        self._unit = unit

    @property
    def unit_multiple(self):
        """Gets the unit_multiple of this AnalysisRequest.

         This is a scaling factor to be applied to the point coordinates when interpreting them in the physical units specified.

        :return: The unit_multiple of this AnalysisRequest.
        :rtype: float
        """
        return self._unit_multiple

    @unit_multiple.setter
    def unit_multiple(self, unit_multiple):
        """Sets the unit_multiple of this AnalysisRequest.

         This is a scaling factor to be applied to the point coordinates when interpreting them in the physical units specified.

        :param unit_multiple: The unit_multiple of this AnalysisRequest.
        :type unit_multiple: float
        """

        self._unit_multiple = unit_multiple
