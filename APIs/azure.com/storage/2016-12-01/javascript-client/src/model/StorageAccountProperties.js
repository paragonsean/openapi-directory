/**
 * StorageManagement
 * The Azure Storage Management API.
 *
 * The version of the OpenAPI document: 2016-12-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import CustomDomain from './CustomDomain';
import Encryption from './Encryption';
import Endpoints from './Endpoints';

/**
 * The StorageAccountProperties model module.
 * @module model/StorageAccountProperties
 * @version 2016-12-01
 */
class StorageAccountProperties {
    /**
     * Constructs a new <code>StorageAccountProperties</code>.
     * Properties of the storage account.
     * @alias module:model/StorageAccountProperties
     */
    constructor() { 
        
        StorageAccountProperties.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
        obj['supportsHttpsTrafficOnly'] = false;
    }

    /**
     * Constructs a <code>StorageAccountProperties</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/StorageAccountProperties} obj Optional instance to populate.
     * @return {module:model/StorageAccountProperties} The populated <code>StorageAccountProperties</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new StorageAccountProperties();

            if (data.hasOwnProperty('accessTier')) {
                obj['accessTier'] = ApiClient.convertToType(data['accessTier'], 'String');
            }
            if (data.hasOwnProperty('creationTime')) {
                obj['creationTime'] = ApiClient.convertToType(data['creationTime'], 'Date');
            }
            if (data.hasOwnProperty('customDomain')) {
                obj['customDomain'] = CustomDomain.constructFromObject(data['customDomain']);
            }
            if (data.hasOwnProperty('encryption')) {
                obj['encryption'] = Encryption.constructFromObject(data['encryption']);
            }
            if (data.hasOwnProperty('lastGeoFailoverTime')) {
                obj['lastGeoFailoverTime'] = ApiClient.convertToType(data['lastGeoFailoverTime'], 'Date');
            }
            if (data.hasOwnProperty('primaryEndpoints')) {
                obj['primaryEndpoints'] = Endpoints.constructFromObject(data['primaryEndpoints']);
            }
            if (data.hasOwnProperty('primaryLocation')) {
                obj['primaryLocation'] = ApiClient.convertToType(data['primaryLocation'], 'String');
            }
            if (data.hasOwnProperty('provisioningState')) {
                obj['provisioningState'] = ApiClient.convertToType(data['provisioningState'], 'String');
            }
            if (data.hasOwnProperty('secondaryEndpoints')) {
                obj['secondaryEndpoints'] = Endpoints.constructFromObject(data['secondaryEndpoints']);
            }
            if (data.hasOwnProperty('secondaryLocation')) {
                obj['secondaryLocation'] = ApiClient.convertToType(data['secondaryLocation'], 'String');
            }
            if (data.hasOwnProperty('statusOfPrimary')) {
                obj['statusOfPrimary'] = ApiClient.convertToType(data['statusOfPrimary'], 'String');
            }
            if (data.hasOwnProperty('statusOfSecondary')) {
                obj['statusOfSecondary'] = ApiClient.convertToType(data['statusOfSecondary'], 'String');
            }
            if (data.hasOwnProperty('supportsHttpsTrafficOnly')) {
                obj['supportsHttpsTrafficOnly'] = ApiClient.convertToType(data['supportsHttpsTrafficOnly'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>StorageAccountProperties</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>StorageAccountProperties</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['accessTier'] && !(typeof data['accessTier'] === 'string' || data['accessTier'] instanceof String)) {
            throw new Error("Expected the field `accessTier` to be a primitive type in the JSON string but got " + data['accessTier']);
        }
        // validate the optional field `customDomain`
        if (data['customDomain']) { // data not null
          CustomDomain.validateJSON(data['customDomain']);
        }
        // validate the optional field `encryption`
        if (data['encryption']) { // data not null
          Encryption.validateJSON(data['encryption']);
        }
        // validate the optional field `primaryEndpoints`
        if (data['primaryEndpoints']) { // data not null
          Endpoints.validateJSON(data['primaryEndpoints']);
        }
        // ensure the json data is a string
        if (data['primaryLocation'] && !(typeof data['primaryLocation'] === 'string' || data['primaryLocation'] instanceof String)) {
            throw new Error("Expected the field `primaryLocation` to be a primitive type in the JSON string but got " + data['primaryLocation']);
        }
        // ensure the json data is a string
        if (data['provisioningState'] && !(typeof data['provisioningState'] === 'string' || data['provisioningState'] instanceof String)) {
            throw new Error("Expected the field `provisioningState` to be a primitive type in the JSON string but got " + data['provisioningState']);
        }
        // validate the optional field `secondaryEndpoints`
        if (data['secondaryEndpoints']) { // data not null
          Endpoints.validateJSON(data['secondaryEndpoints']);
        }
        // ensure the json data is a string
        if (data['secondaryLocation'] && !(typeof data['secondaryLocation'] === 'string' || data['secondaryLocation'] instanceof String)) {
            throw new Error("Expected the field `secondaryLocation` to be a primitive type in the JSON string but got " + data['secondaryLocation']);
        }
        // ensure the json data is a string
        if (data['statusOfPrimary'] && !(typeof data['statusOfPrimary'] === 'string' || data['statusOfPrimary'] instanceof String)) {
            throw new Error("Expected the field `statusOfPrimary` to be a primitive type in the JSON string but got " + data['statusOfPrimary']);
        }
        // ensure the json data is a string
        if (data['statusOfSecondary'] && !(typeof data['statusOfSecondary'] === 'string' || data['statusOfSecondary'] instanceof String)) {
            throw new Error("Expected the field `statusOfSecondary` to be a primitive type in the JSON string but got " + data['statusOfSecondary']);
        }

        return true;
    }


}



/**
 * Required for storage accounts where kind = BlobStorage. The access tier used for billing.
 * @member {module:model/StorageAccountProperties.AccessTierEnum} accessTier
 */
StorageAccountProperties.prototype['accessTier'] = undefined;

/**
 * Gets the creation date and time of the storage account in UTC.
 * @member {Date} creationTime
 */
StorageAccountProperties.prototype['creationTime'] = undefined;

/**
 * @member {module:model/CustomDomain} customDomain
 */
StorageAccountProperties.prototype['customDomain'] = undefined;

/**
 * @member {module:model/Encryption} encryption
 */
StorageAccountProperties.prototype['encryption'] = undefined;

/**
 * Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
 * @member {Date} lastGeoFailoverTime
 */
StorageAccountProperties.prototype['lastGeoFailoverTime'] = undefined;

/**
 * @member {module:model/Endpoints} primaryEndpoints
 */
StorageAccountProperties.prototype['primaryEndpoints'] = undefined;

/**
 * Gets the location of the primary data center for the storage account.
 * @member {String} primaryLocation
 */
StorageAccountProperties.prototype['primaryLocation'] = undefined;

/**
 * Gets the status of the storage account at the time the operation was called.
 * @member {module:model/StorageAccountProperties.ProvisioningStateEnum} provisioningState
 */
StorageAccountProperties.prototype['provisioningState'] = undefined;

/**
 * @member {module:model/Endpoints} secondaryEndpoints
 */
StorageAccountProperties.prototype['secondaryEndpoints'] = undefined;

/**
 * Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
 * @member {String} secondaryLocation
 */
StorageAccountProperties.prototype['secondaryLocation'] = undefined;

/**
 * Gets the status indicating whether the primary location of the storage account is available or unavailable.
 * @member {module:model/StorageAccountProperties.StatusOfPrimaryEnum} statusOfPrimary
 */
StorageAccountProperties.prototype['statusOfPrimary'] = undefined;

/**
 * Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS.
 * @member {module:model/StorageAccountProperties.StatusOfSecondaryEnum} statusOfSecondary
 */
StorageAccountProperties.prototype['statusOfSecondary'] = undefined;

/**
 * Allows https traffic only to storage service if sets to true.
 * @member {Boolean} supportsHttpsTrafficOnly
 * @default false
 */
StorageAccountProperties.prototype['supportsHttpsTrafficOnly'] = false;





/**
 * Allowed values for the <code>accessTier</code> property.
 * @enum {String}
 * @readonly
 */
StorageAccountProperties['AccessTierEnum'] = {

    /**
     * value: "Hot"
     * @const
     */
    "Hot": "Hot",

    /**
     * value: "Cool"
     * @const
     */
    "Cool": "Cool"
};


/**
 * Allowed values for the <code>provisioningState</code> property.
 * @enum {String}
 * @readonly
 */
StorageAccountProperties['ProvisioningStateEnum'] = {

    /**
     * value: "Creating"
     * @const
     */
    "Creating": "Creating",

    /**
     * value: "ResolvingDNS"
     * @const
     */
    "ResolvingDNS": "ResolvingDNS",

    /**
     * value: "Succeeded"
     * @const
     */
    "Succeeded": "Succeeded"
};


/**
 * Allowed values for the <code>statusOfPrimary</code> property.
 * @enum {String}
 * @readonly
 */
StorageAccountProperties['StatusOfPrimaryEnum'] = {

    /**
     * value: "available"
     * @const
     */
    "available": "available",

    /**
     * value: "unavailable"
     * @const
     */
    "unavailable": "unavailable"
};


/**
 * Allowed values for the <code>statusOfSecondary</code> property.
 * @enum {String}
 * @readonly
 */
StorageAccountProperties['StatusOfSecondaryEnum'] = {

    /**
     * value: "available"
     * @const
     */
    "available": "available",

    /**
     * value: "unavailable"
     * @const
     */
    "unavailable": "unavailable"
};



export default StorageAccountProperties;

