/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2015-05-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFailoverGroupProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFailoverGroupProperties::OAIFailoverGroupProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFailoverGroupProperties::OAIFailoverGroupProperties() {
    this->initializeModel();
}

OAIFailoverGroupProperties::~OAIFailoverGroupProperties() {}

void OAIFailoverGroupProperties::initializeModel() {

    m_databases_isSet = false;
    m_databases_isValid = false;

    m_partner_servers_isSet = false;
    m_partner_servers_isValid = false;

    m_read_only_endpoint_isSet = false;
    m_read_only_endpoint_isValid = false;

    m_read_write_endpoint_isSet = false;
    m_read_write_endpoint_isValid = false;

    m_replication_role_isSet = false;
    m_replication_role_isValid = false;

    m_replication_state_isSet = false;
    m_replication_state_isValid = false;
}

void OAIFailoverGroupProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFailoverGroupProperties::fromJsonObject(QJsonObject json) {

    m_databases_isValid = ::OpenAPI::fromJsonValue(m_databases, json[QString("databases")]);
    m_databases_isSet = !json[QString("databases")].isNull() && m_databases_isValid;

    m_partner_servers_isValid = ::OpenAPI::fromJsonValue(m_partner_servers, json[QString("partnerServers")]);
    m_partner_servers_isSet = !json[QString("partnerServers")].isNull() && m_partner_servers_isValid;

    m_read_only_endpoint_isValid = ::OpenAPI::fromJsonValue(m_read_only_endpoint, json[QString("readOnlyEndpoint")]);
    m_read_only_endpoint_isSet = !json[QString("readOnlyEndpoint")].isNull() && m_read_only_endpoint_isValid;

    m_read_write_endpoint_isValid = ::OpenAPI::fromJsonValue(m_read_write_endpoint, json[QString("readWriteEndpoint")]);
    m_read_write_endpoint_isSet = !json[QString("readWriteEndpoint")].isNull() && m_read_write_endpoint_isValid;

    m_replication_role_isValid = ::OpenAPI::fromJsonValue(m_replication_role, json[QString("replicationRole")]);
    m_replication_role_isSet = !json[QString("replicationRole")].isNull() && m_replication_role_isValid;

    m_replication_state_isValid = ::OpenAPI::fromJsonValue(m_replication_state, json[QString("replicationState")]);
    m_replication_state_isSet = !json[QString("replicationState")].isNull() && m_replication_state_isValid;
}

QString OAIFailoverGroupProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFailoverGroupProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_databases.size() > 0) {
        obj.insert(QString("databases"), ::OpenAPI::toJsonValue(m_databases));
    }
    if (m_partner_servers.size() > 0) {
        obj.insert(QString("partnerServers"), ::OpenAPI::toJsonValue(m_partner_servers));
    }
    if (m_read_only_endpoint.isSet()) {
        obj.insert(QString("readOnlyEndpoint"), ::OpenAPI::toJsonValue(m_read_only_endpoint));
    }
    if (m_read_write_endpoint.isSet()) {
        obj.insert(QString("readWriteEndpoint"), ::OpenAPI::toJsonValue(m_read_write_endpoint));
    }
    if (m_replication_role_isSet) {
        obj.insert(QString("replicationRole"), ::OpenAPI::toJsonValue(m_replication_role));
    }
    if (m_replication_state_isSet) {
        obj.insert(QString("replicationState"), ::OpenAPI::toJsonValue(m_replication_state));
    }
    return obj;
}

QList<QString> OAIFailoverGroupProperties::getDatabases() const {
    return m_databases;
}
void OAIFailoverGroupProperties::setDatabases(const QList<QString> &databases) {
    m_databases = databases;
    m_databases_isSet = true;
}

bool OAIFailoverGroupProperties::is_databases_Set() const{
    return m_databases_isSet;
}

bool OAIFailoverGroupProperties::is_databases_Valid() const{
    return m_databases_isValid;
}

QList<OAIPartnerInfo> OAIFailoverGroupProperties::getPartnerServers() const {
    return m_partner_servers;
}
void OAIFailoverGroupProperties::setPartnerServers(const QList<OAIPartnerInfo> &partner_servers) {
    m_partner_servers = partner_servers;
    m_partner_servers_isSet = true;
}

bool OAIFailoverGroupProperties::is_partner_servers_Set() const{
    return m_partner_servers_isSet;
}

bool OAIFailoverGroupProperties::is_partner_servers_Valid() const{
    return m_partner_servers_isValid;
}

OAIFailoverGroupReadOnlyEndpoint OAIFailoverGroupProperties::getReadOnlyEndpoint() const {
    return m_read_only_endpoint;
}
void OAIFailoverGroupProperties::setReadOnlyEndpoint(const OAIFailoverGroupReadOnlyEndpoint &read_only_endpoint) {
    m_read_only_endpoint = read_only_endpoint;
    m_read_only_endpoint_isSet = true;
}

bool OAIFailoverGroupProperties::is_read_only_endpoint_Set() const{
    return m_read_only_endpoint_isSet;
}

bool OAIFailoverGroupProperties::is_read_only_endpoint_Valid() const{
    return m_read_only_endpoint_isValid;
}

OAIFailoverGroupReadWriteEndpoint OAIFailoverGroupProperties::getReadWriteEndpoint() const {
    return m_read_write_endpoint;
}
void OAIFailoverGroupProperties::setReadWriteEndpoint(const OAIFailoverGroupReadWriteEndpoint &read_write_endpoint) {
    m_read_write_endpoint = read_write_endpoint;
    m_read_write_endpoint_isSet = true;
}

bool OAIFailoverGroupProperties::is_read_write_endpoint_Set() const{
    return m_read_write_endpoint_isSet;
}

bool OAIFailoverGroupProperties::is_read_write_endpoint_Valid() const{
    return m_read_write_endpoint_isValid;
}

QString OAIFailoverGroupProperties::getReplicationRole() const {
    return m_replication_role;
}
void OAIFailoverGroupProperties::setReplicationRole(const QString &replication_role) {
    m_replication_role = replication_role;
    m_replication_role_isSet = true;
}

bool OAIFailoverGroupProperties::is_replication_role_Set() const{
    return m_replication_role_isSet;
}

bool OAIFailoverGroupProperties::is_replication_role_Valid() const{
    return m_replication_role_isValid;
}

QString OAIFailoverGroupProperties::getReplicationState() const {
    return m_replication_state;
}
void OAIFailoverGroupProperties::setReplicationState(const QString &replication_state) {
    m_replication_state = replication_state;
    m_replication_state_isSet = true;
}

bool OAIFailoverGroupProperties::is_replication_state_Set() const{
    return m_replication_state_isSet;
}

bool OAIFailoverGroupProperties::is_replication_state_Valid() const{
    return m_replication_state_isValid;
}

bool OAIFailoverGroupProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_databases.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_partner_servers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_only_endpoint.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_write_endpoint.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_replication_role_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_replication_state_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFailoverGroupProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_partner_servers_isValid && m_read_write_endpoint_isValid && true;
}

} // namespace OpenAPI
