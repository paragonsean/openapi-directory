/*
 * CustomerInsightsManagementClient
 * The Azure Customer Insights management API provides a RESTful set of web services that interact with Azure Customer Insights service to manage your resources. The API has entities that capture the relationship between an end user and the Azure Customer Insights service.
 *
 * The version of the OpenAPI document: 2017-01-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ConnectorMappingAvailability;
import org.openapitools.client.model.ConnectorMappingCompleteOperation;
import org.openapitools.client.model.ConnectorMappingErrorManagement;
import org.openapitools.client.model.ConnectorMappingFormat;
import org.openapitools.client.model.ConnectorMappingStructure;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The connector mapping properties.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:31:50.727819-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ConnectorMappingProperties {
  public static final String SERIALIZED_NAME_AVAILABILITY = "availability";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY)
  private ConnectorMappingAvailability availability;

  public static final String SERIALIZED_NAME_COMPLETE_OPERATION = "completeOperation";
  @SerializedName(SERIALIZED_NAME_COMPLETE_OPERATION)
  private ConnectorMappingCompleteOperation completeOperation;

  public static final String SERIALIZED_NAME_ERROR_MANAGEMENT = "errorManagement";
  @SerializedName(SERIALIZED_NAME_ERROR_MANAGEMENT)
  private ConnectorMappingErrorManagement errorManagement;

  public static final String SERIALIZED_NAME_FILE_FILTER = "fileFilter";
  @SerializedName(SERIALIZED_NAME_FILE_FILTER)
  private String fileFilter;

  public static final String SERIALIZED_NAME_FOLDER_PATH = "folderPath";
  @SerializedName(SERIALIZED_NAME_FOLDER_PATH)
  private String folderPath;

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  private ConnectorMappingFormat format;

  public static final String SERIALIZED_NAME_HAS_HEADER = "hasHeader";
  @SerializedName(SERIALIZED_NAME_HAS_HEADER)
  private Boolean hasHeader;

  public static final String SERIALIZED_NAME_STRUCTURE = "structure";
  @SerializedName(SERIALIZED_NAME_STRUCTURE)
  private List<ConnectorMappingStructure> structure = new ArrayList<>();

  public ConnectorMappingProperties() {
  }

  public ConnectorMappingProperties availability(ConnectorMappingAvailability availability) {
    this.availability = availability;
    return this;
  }

  /**
   * Get availability
   * @return availability
   */
  @javax.annotation.Nonnull
  public ConnectorMappingAvailability getAvailability() {
    return availability;
  }

  public void setAvailability(ConnectorMappingAvailability availability) {
    this.availability = availability;
  }


  public ConnectorMappingProperties completeOperation(ConnectorMappingCompleteOperation completeOperation) {
    this.completeOperation = completeOperation;
    return this;
  }

  /**
   * Get completeOperation
   * @return completeOperation
   */
  @javax.annotation.Nonnull
  public ConnectorMappingCompleteOperation getCompleteOperation() {
    return completeOperation;
  }

  public void setCompleteOperation(ConnectorMappingCompleteOperation completeOperation) {
    this.completeOperation = completeOperation;
  }


  public ConnectorMappingProperties errorManagement(ConnectorMappingErrorManagement errorManagement) {
    this.errorManagement = errorManagement;
    return this;
  }

  /**
   * Get errorManagement
   * @return errorManagement
   */
  @javax.annotation.Nonnull
  public ConnectorMappingErrorManagement getErrorManagement() {
    return errorManagement;
  }

  public void setErrorManagement(ConnectorMappingErrorManagement errorManagement) {
    this.errorManagement = errorManagement;
  }


  public ConnectorMappingProperties fileFilter(String fileFilter) {
    this.fileFilter = fileFilter;
    return this;
  }

  /**
   * The file filter for the mapping.
   * @return fileFilter
   */
  @javax.annotation.Nullable
  public String getFileFilter() {
    return fileFilter;
  }

  public void setFileFilter(String fileFilter) {
    this.fileFilter = fileFilter;
  }


  public ConnectorMappingProperties folderPath(String folderPath) {
    this.folderPath = folderPath;
    return this;
  }

  /**
   * The folder path for the mapping.
   * @return folderPath
   */
  @javax.annotation.Nullable
  public String getFolderPath() {
    return folderPath;
  }

  public void setFolderPath(String folderPath) {
    this.folderPath = folderPath;
  }


  public ConnectorMappingProperties format(ConnectorMappingFormat format) {
    this.format = format;
    return this;
  }

  /**
   * Get format
   * @return format
   */
  @javax.annotation.Nonnull
  public ConnectorMappingFormat getFormat() {
    return format;
  }

  public void setFormat(ConnectorMappingFormat format) {
    this.format = format;
  }


  public ConnectorMappingProperties hasHeader(Boolean hasHeader) {
    this.hasHeader = hasHeader;
    return this;
  }

  /**
   * If the file contains a header or not.
   * @return hasHeader
   */
  @javax.annotation.Nullable
  public Boolean getHasHeader() {
    return hasHeader;
  }

  public void setHasHeader(Boolean hasHeader) {
    this.hasHeader = hasHeader;
  }


  public ConnectorMappingProperties structure(List<ConnectorMappingStructure> structure) {
    this.structure = structure;
    return this;
  }

  public ConnectorMappingProperties addStructureItem(ConnectorMappingStructure structureItem) {
    if (this.structure == null) {
      this.structure = new ArrayList<>();
    }
    this.structure.add(structureItem);
    return this;
  }

  /**
   * Ingestion mapping information at property level.
   * @return structure
   */
  @javax.annotation.Nonnull
  public List<ConnectorMappingStructure> getStructure() {
    return structure;
  }

  public void setStructure(List<ConnectorMappingStructure> structure) {
    this.structure = structure;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConnectorMappingProperties connectorMappingProperties = (ConnectorMappingProperties) o;
    return Objects.equals(this.availability, connectorMappingProperties.availability) &&
        Objects.equals(this.completeOperation, connectorMappingProperties.completeOperation) &&
        Objects.equals(this.errorManagement, connectorMappingProperties.errorManagement) &&
        Objects.equals(this.fileFilter, connectorMappingProperties.fileFilter) &&
        Objects.equals(this.folderPath, connectorMappingProperties.folderPath) &&
        Objects.equals(this.format, connectorMappingProperties.format) &&
        Objects.equals(this.hasHeader, connectorMappingProperties.hasHeader) &&
        Objects.equals(this.structure, connectorMappingProperties.structure);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availability, completeOperation, errorManagement, fileFilter, folderPath, format, hasHeader, structure);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConnectorMappingProperties {\n");
    sb.append("    availability: ").append(toIndentedString(availability)).append("\n");
    sb.append("    completeOperation: ").append(toIndentedString(completeOperation)).append("\n");
    sb.append("    errorManagement: ").append(toIndentedString(errorManagement)).append("\n");
    sb.append("    fileFilter: ").append(toIndentedString(fileFilter)).append("\n");
    sb.append("    folderPath: ").append(toIndentedString(folderPath)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    hasHeader: ").append(toIndentedString(hasHeader)).append("\n");
    sb.append("    structure: ").append(toIndentedString(structure)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("availability");
    openapiFields.add("completeOperation");
    openapiFields.add("errorManagement");
    openapiFields.add("fileFilter");
    openapiFields.add("folderPath");
    openapiFields.add("format");
    openapiFields.add("hasHeader");
    openapiFields.add("structure");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("availability");
    openapiRequiredFields.add("completeOperation");
    openapiRequiredFields.add("errorManagement");
    openapiRequiredFields.add("format");
    openapiRequiredFields.add("structure");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ConnectorMappingProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConnectorMappingProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConnectorMappingProperties is not found in the empty JSON string", ConnectorMappingProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConnectorMappingProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConnectorMappingProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ConnectorMappingProperties.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `availability`
      ConnectorMappingAvailability.validateJsonElement(jsonObj.get("availability"));
      // validate the required field `completeOperation`
      ConnectorMappingCompleteOperation.validateJsonElement(jsonObj.get("completeOperation"));
      // validate the required field `errorManagement`
      ConnectorMappingErrorManagement.validateJsonElement(jsonObj.get("errorManagement"));
      if ((jsonObj.get("fileFilter") != null && !jsonObj.get("fileFilter").isJsonNull()) && !jsonObj.get("fileFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileFilter").toString()));
      }
      if ((jsonObj.get("folderPath") != null && !jsonObj.get("folderPath").isJsonNull()) && !jsonObj.get("folderPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `folderPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("folderPath").toString()));
      }
      // validate the required field `format`
      ConnectorMappingFormat.validateJsonElement(jsonObj.get("format"));
      // ensure the json data is an array
      if (!jsonObj.get("structure").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `structure` to be an array in the JSON string but got `%s`", jsonObj.get("structure").toString()));
      }

      JsonArray jsonArraystructure = jsonObj.getAsJsonArray("structure");
      // validate the required field `structure` (array)
      for (int i = 0; i < jsonArraystructure.size(); i++) {
        ConnectorMappingStructure.validateJsonElement(jsonArraystructure.get(i));
      };
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConnectorMappingProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConnectorMappingProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConnectorMappingProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConnectorMappingProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<ConnectorMappingProperties>() {
           @Override
           public void write(JsonWriter out, ConnectorMappingProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConnectorMappingProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ConnectorMappingProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ConnectorMappingProperties
   * @throws IOException if the JSON string is invalid with respect to ConnectorMappingProperties
   */
  public static ConnectorMappingProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConnectorMappingProperties.class);
  }

  /**
   * Convert an instance of ConnectorMappingProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

