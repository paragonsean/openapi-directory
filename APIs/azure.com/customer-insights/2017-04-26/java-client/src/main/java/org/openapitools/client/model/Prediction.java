/*
 * CustomerInsightsManagementClient
 * The Azure Customer Insights management API provides a RESTful set of web services that interact with Azure Customer Insights service to manage your resources. The API has entities that capture the relationship between an end user and the Azure Customer Insights service.
 *
 * The version of the OpenAPI document: 2017-04-26
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.PredictionGradesInner;
import org.openapitools.client.model.PredictionMappings;
import org.openapitools.client.model.PredictionSystemGeneratedEntities;
import org.openapitools.client.model.ProvisioningState;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The prediction definition.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:31:52.400724-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Prediction {
  public static final String SERIALIZED_NAME_AUTO_ANALYZE = "autoAnalyze";
  @SerializedName(SERIALIZED_NAME_AUTO_ANALYZE)
  private Boolean autoAnalyze;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private Map<String, String> description = new HashMap<>();

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private Map<String, String> displayName = new HashMap<>();

  public static final String SERIALIZED_NAME_GRADES = "grades";
  @SerializedName(SERIALIZED_NAME_GRADES)
  private List<PredictionGradesInner> grades = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVOLVED_INTERACTION_TYPES = "involvedInteractionTypes";
  @SerializedName(SERIALIZED_NAME_INVOLVED_INTERACTION_TYPES)
  private List<String> involvedInteractionTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVOLVED_KPI_TYPES = "involvedKpiTypes";
  @SerializedName(SERIALIZED_NAME_INVOLVED_KPI_TYPES)
  private List<String> involvedKpiTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVOLVED_RELATIONSHIPS = "involvedRelationships";
  @SerializedName(SERIALIZED_NAME_INVOLVED_RELATIONSHIPS)
  private List<String> involvedRelationships = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAPPINGS = "mappings";
  @SerializedName(SERIALIZED_NAME_MAPPINGS)
  private PredictionMappings mappings;

  public static final String SERIALIZED_NAME_NEGATIVE_OUTCOME_EXPRESSION = "negativeOutcomeExpression";
  @SerializedName(SERIALIZED_NAME_NEGATIVE_OUTCOME_EXPRESSION)
  private String negativeOutcomeExpression;

  public static final String SERIALIZED_NAME_POSITIVE_OUTCOME_EXPRESSION = "positiveOutcomeExpression";
  @SerializedName(SERIALIZED_NAME_POSITIVE_OUTCOME_EXPRESSION)
  private String positiveOutcomeExpression;

  public static final String SERIALIZED_NAME_PREDICTION_NAME = "predictionName";
  @SerializedName(SERIALIZED_NAME_PREDICTION_NAME)
  private String predictionName;

  public static final String SERIALIZED_NAME_PRIMARY_PROFILE_TYPE = "primaryProfileType";
  @SerializedName(SERIALIZED_NAME_PRIMARY_PROFILE_TYPE)
  private String primaryProfileType;

  public static final String SERIALIZED_NAME_PROVISIONING_STATE = "provisioningState";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE)
  private ProvisioningState provisioningState;

  public static final String SERIALIZED_NAME_SCOPE_EXPRESSION = "scopeExpression";
  @SerializedName(SERIALIZED_NAME_SCOPE_EXPRESSION)
  private String scopeExpression;

  public static final String SERIALIZED_NAME_SCORE_LABEL = "scoreLabel";
  @SerializedName(SERIALIZED_NAME_SCORE_LABEL)
  private String scoreLabel;

  public static final String SERIALIZED_NAME_SYSTEM_GENERATED_ENTITIES = "systemGeneratedEntities";
  @SerializedName(SERIALIZED_NAME_SYSTEM_GENERATED_ENTITIES)
  private PredictionSystemGeneratedEntities systemGeneratedEntities;

  public static final String SERIALIZED_NAME_TENANT_ID = "tenantId";
  @SerializedName(SERIALIZED_NAME_TENANT_ID)
  private String tenantId;

  public Prediction() {
  }

  public Prediction(
     String tenantId
  ) {
    this();
    this.tenantId = tenantId;
  }

  public Prediction autoAnalyze(Boolean autoAnalyze) {
    this.autoAnalyze = autoAnalyze;
    return this;
  }

  /**
   * Whether do auto analyze.
   * @return autoAnalyze
   */
  @javax.annotation.Nonnull
  public Boolean getAutoAnalyze() {
    return autoAnalyze;
  }

  public void setAutoAnalyze(Boolean autoAnalyze) {
    this.autoAnalyze = autoAnalyze;
  }


  public Prediction description(Map<String, String> description) {
    this.description = description;
    return this;
  }

  public Prediction putDescriptionItem(String key, String descriptionItem) {
    if (this.description == null) {
      this.description = new HashMap<>();
    }
    this.description.put(key, descriptionItem);
    return this;
  }

  /**
   * Description of the prediction.
   * @return description
   */
  @javax.annotation.Nullable
  public Map<String, String> getDescription() {
    return description;
  }

  public void setDescription(Map<String, String> description) {
    this.description = description;
  }


  public Prediction displayName(Map<String, String> displayName) {
    this.displayName = displayName;
    return this;
  }

  public Prediction putDisplayNameItem(String key, String displayNameItem) {
    if (this.displayName == null) {
      this.displayName = new HashMap<>();
    }
    this.displayName.put(key, displayNameItem);
    return this;
  }

  /**
   * Display name of the prediction.
   * @return displayName
   */
  @javax.annotation.Nullable
  public Map<String, String> getDisplayName() {
    return displayName;
  }

  public void setDisplayName(Map<String, String> displayName) {
    this.displayName = displayName;
  }


  public Prediction grades(List<PredictionGradesInner> grades) {
    this.grades = grades;
    return this;
  }

  public Prediction addGradesItem(PredictionGradesInner gradesItem) {
    if (this.grades == null) {
      this.grades = new ArrayList<>();
    }
    this.grades.add(gradesItem);
    return this;
  }

  /**
   * The prediction grades.
   * @return grades
   */
  @javax.annotation.Nullable
  public List<PredictionGradesInner> getGrades() {
    return grades;
  }

  public void setGrades(List<PredictionGradesInner> grades) {
    this.grades = grades;
  }


  public Prediction involvedInteractionTypes(List<String> involvedInteractionTypes) {
    this.involvedInteractionTypes = involvedInteractionTypes;
    return this;
  }

  public Prediction addInvolvedInteractionTypesItem(String involvedInteractionTypesItem) {
    if (this.involvedInteractionTypes == null) {
      this.involvedInteractionTypes = new ArrayList<>();
    }
    this.involvedInteractionTypes.add(involvedInteractionTypesItem);
    return this;
  }

  /**
   * Interaction types involved in the prediction.
   * @return involvedInteractionTypes
   */
  @javax.annotation.Nullable
  public List<String> getInvolvedInteractionTypes() {
    return involvedInteractionTypes;
  }

  public void setInvolvedInteractionTypes(List<String> involvedInteractionTypes) {
    this.involvedInteractionTypes = involvedInteractionTypes;
  }


  public Prediction involvedKpiTypes(List<String> involvedKpiTypes) {
    this.involvedKpiTypes = involvedKpiTypes;
    return this;
  }

  public Prediction addInvolvedKpiTypesItem(String involvedKpiTypesItem) {
    if (this.involvedKpiTypes == null) {
      this.involvedKpiTypes = new ArrayList<>();
    }
    this.involvedKpiTypes.add(involvedKpiTypesItem);
    return this;
  }

  /**
   * KPI types involved in the prediction.
   * @return involvedKpiTypes
   */
  @javax.annotation.Nullable
  public List<String> getInvolvedKpiTypes() {
    return involvedKpiTypes;
  }

  public void setInvolvedKpiTypes(List<String> involvedKpiTypes) {
    this.involvedKpiTypes = involvedKpiTypes;
  }


  public Prediction involvedRelationships(List<String> involvedRelationships) {
    this.involvedRelationships = involvedRelationships;
    return this;
  }

  public Prediction addInvolvedRelationshipsItem(String involvedRelationshipsItem) {
    if (this.involvedRelationships == null) {
      this.involvedRelationships = new ArrayList<>();
    }
    this.involvedRelationships.add(involvedRelationshipsItem);
    return this;
  }

  /**
   * Relationships involved in the prediction.
   * @return involvedRelationships
   */
  @javax.annotation.Nullable
  public List<String> getInvolvedRelationships() {
    return involvedRelationships;
  }

  public void setInvolvedRelationships(List<String> involvedRelationships) {
    this.involvedRelationships = involvedRelationships;
  }


  public Prediction mappings(PredictionMappings mappings) {
    this.mappings = mappings;
    return this;
  }

  /**
   * Get mappings
   * @return mappings
   */
  @javax.annotation.Nonnull
  public PredictionMappings getMappings() {
    return mappings;
  }

  public void setMappings(PredictionMappings mappings) {
    this.mappings = mappings;
  }


  public Prediction negativeOutcomeExpression(String negativeOutcomeExpression) {
    this.negativeOutcomeExpression = negativeOutcomeExpression;
    return this;
  }

  /**
   * Negative outcome expression.
   * @return negativeOutcomeExpression
   */
  @javax.annotation.Nonnull
  public String getNegativeOutcomeExpression() {
    return negativeOutcomeExpression;
  }

  public void setNegativeOutcomeExpression(String negativeOutcomeExpression) {
    this.negativeOutcomeExpression = negativeOutcomeExpression;
  }


  public Prediction positiveOutcomeExpression(String positiveOutcomeExpression) {
    this.positiveOutcomeExpression = positiveOutcomeExpression;
    return this;
  }

  /**
   * Positive outcome expression.
   * @return positiveOutcomeExpression
   */
  @javax.annotation.Nonnull
  public String getPositiveOutcomeExpression() {
    return positiveOutcomeExpression;
  }

  public void setPositiveOutcomeExpression(String positiveOutcomeExpression) {
    this.positiveOutcomeExpression = positiveOutcomeExpression;
  }


  public Prediction predictionName(String predictionName) {
    this.predictionName = predictionName;
    return this;
  }

  /**
   * Name of the prediction.
   * @return predictionName
   */
  @javax.annotation.Nullable
  public String getPredictionName() {
    return predictionName;
  }

  public void setPredictionName(String predictionName) {
    this.predictionName = predictionName;
  }


  public Prediction primaryProfileType(String primaryProfileType) {
    this.primaryProfileType = primaryProfileType;
    return this;
  }

  /**
   * Primary profile type.
   * @return primaryProfileType
   */
  @javax.annotation.Nonnull
  public String getPrimaryProfileType() {
    return primaryProfileType;
  }

  public void setPrimaryProfileType(String primaryProfileType) {
    this.primaryProfileType = primaryProfileType;
  }


  public Prediction provisioningState(ProvisioningState provisioningState) {
    this.provisioningState = provisioningState;
    return this;
  }

  /**
   * Get provisioningState
   * @return provisioningState
   */
  @javax.annotation.Nullable
  public ProvisioningState getProvisioningState() {
    return provisioningState;
  }

  public void setProvisioningState(ProvisioningState provisioningState) {
    this.provisioningState = provisioningState;
  }


  public Prediction scopeExpression(String scopeExpression) {
    this.scopeExpression = scopeExpression;
    return this;
  }

  /**
   * Scope expression.
   * @return scopeExpression
   */
  @javax.annotation.Nonnull
  public String getScopeExpression() {
    return scopeExpression;
  }

  public void setScopeExpression(String scopeExpression) {
    this.scopeExpression = scopeExpression;
  }


  public Prediction scoreLabel(String scoreLabel) {
    this.scoreLabel = scoreLabel;
    return this;
  }

  /**
   * Score label.
   * @return scoreLabel
   */
  @javax.annotation.Nonnull
  public String getScoreLabel() {
    return scoreLabel;
  }

  public void setScoreLabel(String scoreLabel) {
    this.scoreLabel = scoreLabel;
  }


  public Prediction systemGeneratedEntities(PredictionSystemGeneratedEntities systemGeneratedEntities) {
    this.systemGeneratedEntities = systemGeneratedEntities;
    return this;
  }

  /**
   * Get systemGeneratedEntities
   * @return systemGeneratedEntities
   */
  @javax.annotation.Nullable
  public PredictionSystemGeneratedEntities getSystemGeneratedEntities() {
    return systemGeneratedEntities;
  }

  public void setSystemGeneratedEntities(PredictionSystemGeneratedEntities systemGeneratedEntities) {
    this.systemGeneratedEntities = systemGeneratedEntities;
  }


  /**
   * The hub name.
   * @return tenantId
   */
  @javax.annotation.Nullable
  public String getTenantId() {
    return tenantId;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Prediction prediction = (Prediction) o;
    return Objects.equals(this.autoAnalyze, prediction.autoAnalyze) &&
        Objects.equals(this.description, prediction.description) &&
        Objects.equals(this.displayName, prediction.displayName) &&
        Objects.equals(this.grades, prediction.grades) &&
        Objects.equals(this.involvedInteractionTypes, prediction.involvedInteractionTypes) &&
        Objects.equals(this.involvedKpiTypes, prediction.involvedKpiTypes) &&
        Objects.equals(this.involvedRelationships, prediction.involvedRelationships) &&
        Objects.equals(this.mappings, prediction.mappings) &&
        Objects.equals(this.negativeOutcomeExpression, prediction.negativeOutcomeExpression) &&
        Objects.equals(this.positiveOutcomeExpression, prediction.positiveOutcomeExpression) &&
        Objects.equals(this.predictionName, prediction.predictionName) &&
        Objects.equals(this.primaryProfileType, prediction.primaryProfileType) &&
        Objects.equals(this.provisioningState, prediction.provisioningState) &&
        Objects.equals(this.scopeExpression, prediction.scopeExpression) &&
        Objects.equals(this.scoreLabel, prediction.scoreLabel) &&
        Objects.equals(this.systemGeneratedEntities, prediction.systemGeneratedEntities) &&
        Objects.equals(this.tenantId, prediction.tenantId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoAnalyze, description, displayName, grades, involvedInteractionTypes, involvedKpiTypes, involvedRelationships, mappings, negativeOutcomeExpression, positiveOutcomeExpression, predictionName, primaryProfileType, provisioningState, scopeExpression, scoreLabel, systemGeneratedEntities, tenantId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Prediction {\n");
    sb.append("    autoAnalyze: ").append(toIndentedString(autoAnalyze)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    grades: ").append(toIndentedString(grades)).append("\n");
    sb.append("    involvedInteractionTypes: ").append(toIndentedString(involvedInteractionTypes)).append("\n");
    sb.append("    involvedKpiTypes: ").append(toIndentedString(involvedKpiTypes)).append("\n");
    sb.append("    involvedRelationships: ").append(toIndentedString(involvedRelationships)).append("\n");
    sb.append("    mappings: ").append(toIndentedString(mappings)).append("\n");
    sb.append("    negativeOutcomeExpression: ").append(toIndentedString(negativeOutcomeExpression)).append("\n");
    sb.append("    positiveOutcomeExpression: ").append(toIndentedString(positiveOutcomeExpression)).append("\n");
    sb.append("    predictionName: ").append(toIndentedString(predictionName)).append("\n");
    sb.append("    primaryProfileType: ").append(toIndentedString(primaryProfileType)).append("\n");
    sb.append("    provisioningState: ").append(toIndentedString(provisioningState)).append("\n");
    sb.append("    scopeExpression: ").append(toIndentedString(scopeExpression)).append("\n");
    sb.append("    scoreLabel: ").append(toIndentedString(scoreLabel)).append("\n");
    sb.append("    systemGeneratedEntities: ").append(toIndentedString(systemGeneratedEntities)).append("\n");
    sb.append("    tenantId: ").append(toIndentedString(tenantId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoAnalyze");
    openapiFields.add("description");
    openapiFields.add("displayName");
    openapiFields.add("grades");
    openapiFields.add("involvedInteractionTypes");
    openapiFields.add("involvedKpiTypes");
    openapiFields.add("involvedRelationships");
    openapiFields.add("mappings");
    openapiFields.add("negativeOutcomeExpression");
    openapiFields.add("positiveOutcomeExpression");
    openapiFields.add("predictionName");
    openapiFields.add("primaryProfileType");
    openapiFields.add("provisioningState");
    openapiFields.add("scopeExpression");
    openapiFields.add("scoreLabel");
    openapiFields.add("systemGeneratedEntities");
    openapiFields.add("tenantId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("autoAnalyze");
    openapiRequiredFields.add("mappings");
    openapiRequiredFields.add("negativeOutcomeExpression");
    openapiRequiredFields.add("positiveOutcomeExpression");
    openapiRequiredFields.add("primaryProfileType");
    openapiRequiredFields.add("scopeExpression");
    openapiRequiredFields.add("scoreLabel");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Prediction
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Prediction.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Prediction is not found in the empty JSON string", Prediction.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Prediction.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Prediction` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Prediction.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("grades") != null && !jsonObj.get("grades").isJsonNull()) {
        JsonArray jsonArraygrades = jsonObj.getAsJsonArray("grades");
        if (jsonArraygrades != null) {
          // ensure the json data is an array
          if (!jsonObj.get("grades").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `grades` to be an array in the JSON string but got `%s`", jsonObj.get("grades").toString()));
          }

          // validate the optional field `grades` (array)
          for (int i = 0; i < jsonArraygrades.size(); i++) {
            PredictionGradesInner.validateJsonElement(jsonArraygrades.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("involvedInteractionTypes") != null && !jsonObj.get("involvedInteractionTypes").isJsonNull() && !jsonObj.get("involvedInteractionTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `involvedInteractionTypes` to be an array in the JSON string but got `%s`", jsonObj.get("involvedInteractionTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("involvedKpiTypes") != null && !jsonObj.get("involvedKpiTypes").isJsonNull() && !jsonObj.get("involvedKpiTypes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `involvedKpiTypes` to be an array in the JSON string but got `%s`", jsonObj.get("involvedKpiTypes").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("involvedRelationships") != null && !jsonObj.get("involvedRelationships").isJsonNull() && !jsonObj.get("involvedRelationships").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `involvedRelationships` to be an array in the JSON string but got `%s`", jsonObj.get("involvedRelationships").toString()));
      }
      // validate the required field `mappings`
      PredictionMappings.validateJsonElement(jsonObj.get("mappings"));
      if (!jsonObj.get("negativeOutcomeExpression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `negativeOutcomeExpression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("negativeOutcomeExpression").toString()));
      }
      if (!jsonObj.get("positiveOutcomeExpression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `positiveOutcomeExpression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("positiveOutcomeExpression").toString()));
      }
      if ((jsonObj.get("predictionName") != null && !jsonObj.get("predictionName").isJsonNull()) && !jsonObj.get("predictionName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `predictionName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("predictionName").toString()));
      }
      if (!jsonObj.get("primaryProfileType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `primaryProfileType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("primaryProfileType").toString()));
      }
      // validate the optional field `provisioningState`
      if (jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) {
        ProvisioningState.validateJsonElement(jsonObj.get("provisioningState"));
      }
      if (!jsonObj.get("scopeExpression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scopeExpression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scopeExpression").toString()));
      }
      if (!jsonObj.get("scoreLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scoreLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scoreLabel").toString()));
      }
      // validate the optional field `systemGeneratedEntities`
      if (jsonObj.get("systemGeneratedEntities") != null && !jsonObj.get("systemGeneratedEntities").isJsonNull()) {
        PredictionSystemGeneratedEntities.validateJsonElement(jsonObj.get("systemGeneratedEntities"));
      }
      if ((jsonObj.get("tenantId") != null && !jsonObj.get("tenantId").isJsonNull()) && !jsonObj.get("tenantId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tenantId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tenantId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Prediction.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Prediction' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Prediction> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Prediction.class));

       return (TypeAdapter<T>) new TypeAdapter<Prediction>() {
           @Override
           public void write(JsonWriter out, Prediction value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Prediction read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Prediction given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Prediction
   * @throws IOException if the JSON string is invalid with respect to Prediction
   */
  public static Prediction fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Prediction.class);
  }

  /**
   * Convert an instance of Prediction to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

