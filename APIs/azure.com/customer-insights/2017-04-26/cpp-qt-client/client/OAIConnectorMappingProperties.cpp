/**
 * CustomerInsightsManagementClient
 * The Azure Customer Insights management API provides a RESTful set of web services that interact with Azure Customer Insights service to manage your resources. The API has entities that capture the relationship between an end user and the Azure Customer Insights service.
 *
 * The version of the OpenAPI document: 2017-04-26
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIConnectorMappingProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIConnectorMappingProperties::OAIConnectorMappingProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIConnectorMappingProperties::OAIConnectorMappingProperties() {
    this->initializeModel();
}

OAIConnectorMappingProperties::~OAIConnectorMappingProperties() {}

void OAIConnectorMappingProperties::initializeModel() {

    m_availability_isSet = false;
    m_availability_isValid = false;

    m_complete_operation_isSet = false;
    m_complete_operation_isValid = false;

    m_error_management_isSet = false;
    m_error_management_isValid = false;

    m_file_filter_isSet = false;
    m_file_filter_isValid = false;

    m_folder_path_isSet = false;
    m_folder_path_isValid = false;

    m_format_isSet = false;
    m_format_isValid = false;

    m_has_header_isSet = false;
    m_has_header_isValid = false;

    m_structure_isSet = false;
    m_structure_isValid = false;
}

void OAIConnectorMappingProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIConnectorMappingProperties::fromJsonObject(QJsonObject json) {

    m_availability_isValid = ::OpenAPI::fromJsonValue(m_availability, json[QString("availability")]);
    m_availability_isSet = !json[QString("availability")].isNull() && m_availability_isValid;

    m_complete_operation_isValid = ::OpenAPI::fromJsonValue(m_complete_operation, json[QString("completeOperation")]);
    m_complete_operation_isSet = !json[QString("completeOperation")].isNull() && m_complete_operation_isValid;

    m_error_management_isValid = ::OpenAPI::fromJsonValue(m_error_management, json[QString("errorManagement")]);
    m_error_management_isSet = !json[QString("errorManagement")].isNull() && m_error_management_isValid;

    m_file_filter_isValid = ::OpenAPI::fromJsonValue(m_file_filter, json[QString("fileFilter")]);
    m_file_filter_isSet = !json[QString("fileFilter")].isNull() && m_file_filter_isValid;

    m_folder_path_isValid = ::OpenAPI::fromJsonValue(m_folder_path, json[QString("folderPath")]);
    m_folder_path_isSet = !json[QString("folderPath")].isNull() && m_folder_path_isValid;

    m_format_isValid = ::OpenAPI::fromJsonValue(m_format, json[QString("format")]);
    m_format_isSet = !json[QString("format")].isNull() && m_format_isValid;

    m_has_header_isValid = ::OpenAPI::fromJsonValue(m_has_header, json[QString("hasHeader")]);
    m_has_header_isSet = !json[QString("hasHeader")].isNull() && m_has_header_isValid;

    m_structure_isValid = ::OpenAPI::fromJsonValue(m_structure, json[QString("structure")]);
    m_structure_isSet = !json[QString("structure")].isNull() && m_structure_isValid;
}

QString OAIConnectorMappingProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIConnectorMappingProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_availability.isSet()) {
        obj.insert(QString("availability"), ::OpenAPI::toJsonValue(m_availability));
    }
    if (m_complete_operation.isSet()) {
        obj.insert(QString("completeOperation"), ::OpenAPI::toJsonValue(m_complete_operation));
    }
    if (m_error_management.isSet()) {
        obj.insert(QString("errorManagement"), ::OpenAPI::toJsonValue(m_error_management));
    }
    if (m_file_filter_isSet) {
        obj.insert(QString("fileFilter"), ::OpenAPI::toJsonValue(m_file_filter));
    }
    if (m_folder_path_isSet) {
        obj.insert(QString("folderPath"), ::OpenAPI::toJsonValue(m_folder_path));
    }
    if (m_format.isSet()) {
        obj.insert(QString("format"), ::OpenAPI::toJsonValue(m_format));
    }
    if (m_has_header_isSet) {
        obj.insert(QString("hasHeader"), ::OpenAPI::toJsonValue(m_has_header));
    }
    if (m_structure.size() > 0) {
        obj.insert(QString("structure"), ::OpenAPI::toJsonValue(m_structure));
    }
    return obj;
}

OAIConnectorMappingAvailability OAIConnectorMappingProperties::getAvailability() const {
    return m_availability;
}
void OAIConnectorMappingProperties::setAvailability(const OAIConnectorMappingAvailability &availability) {
    m_availability = availability;
    m_availability_isSet = true;
}

bool OAIConnectorMappingProperties::is_availability_Set() const{
    return m_availability_isSet;
}

bool OAIConnectorMappingProperties::is_availability_Valid() const{
    return m_availability_isValid;
}

OAIConnectorMappingCompleteOperation OAIConnectorMappingProperties::getCompleteOperation() const {
    return m_complete_operation;
}
void OAIConnectorMappingProperties::setCompleteOperation(const OAIConnectorMappingCompleteOperation &complete_operation) {
    m_complete_operation = complete_operation;
    m_complete_operation_isSet = true;
}

bool OAIConnectorMappingProperties::is_complete_operation_Set() const{
    return m_complete_operation_isSet;
}

bool OAIConnectorMappingProperties::is_complete_operation_Valid() const{
    return m_complete_operation_isValid;
}

OAIConnectorMappingErrorManagement OAIConnectorMappingProperties::getErrorManagement() const {
    return m_error_management;
}
void OAIConnectorMappingProperties::setErrorManagement(const OAIConnectorMappingErrorManagement &error_management) {
    m_error_management = error_management;
    m_error_management_isSet = true;
}

bool OAIConnectorMappingProperties::is_error_management_Set() const{
    return m_error_management_isSet;
}

bool OAIConnectorMappingProperties::is_error_management_Valid() const{
    return m_error_management_isValid;
}

QString OAIConnectorMappingProperties::getFileFilter() const {
    return m_file_filter;
}
void OAIConnectorMappingProperties::setFileFilter(const QString &file_filter) {
    m_file_filter = file_filter;
    m_file_filter_isSet = true;
}

bool OAIConnectorMappingProperties::is_file_filter_Set() const{
    return m_file_filter_isSet;
}

bool OAIConnectorMappingProperties::is_file_filter_Valid() const{
    return m_file_filter_isValid;
}

QString OAIConnectorMappingProperties::getFolderPath() const {
    return m_folder_path;
}
void OAIConnectorMappingProperties::setFolderPath(const QString &folder_path) {
    m_folder_path = folder_path;
    m_folder_path_isSet = true;
}

bool OAIConnectorMappingProperties::is_folder_path_Set() const{
    return m_folder_path_isSet;
}

bool OAIConnectorMappingProperties::is_folder_path_Valid() const{
    return m_folder_path_isValid;
}

OAIConnectorMappingFormat OAIConnectorMappingProperties::getFormat() const {
    return m_format;
}
void OAIConnectorMappingProperties::setFormat(const OAIConnectorMappingFormat &format) {
    m_format = format;
    m_format_isSet = true;
}

bool OAIConnectorMappingProperties::is_format_Set() const{
    return m_format_isSet;
}

bool OAIConnectorMappingProperties::is_format_Valid() const{
    return m_format_isValid;
}

bool OAIConnectorMappingProperties::isHasHeader() const {
    return m_has_header;
}
void OAIConnectorMappingProperties::setHasHeader(const bool &has_header) {
    m_has_header = has_header;
    m_has_header_isSet = true;
}

bool OAIConnectorMappingProperties::is_has_header_Set() const{
    return m_has_header_isSet;
}

bool OAIConnectorMappingProperties::is_has_header_Valid() const{
    return m_has_header_isValid;
}

QList<OAIConnectorMappingStructure> OAIConnectorMappingProperties::getStructure() const {
    return m_structure;
}
void OAIConnectorMappingProperties::setStructure(const QList<OAIConnectorMappingStructure> &structure) {
    m_structure = structure;
    m_structure_isSet = true;
}

bool OAIConnectorMappingProperties::is_structure_Set() const{
    return m_structure_isSet;
}

bool OAIConnectorMappingProperties::is_structure_Valid() const{
    return m_structure_isValid;
}

bool OAIConnectorMappingProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_availability.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_complete_operation.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_error_management.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_file_filter_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_folder_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_format.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_has_header_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_structure.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIConnectorMappingProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_availability_isValid && m_complete_operation_isValid && m_error_management_isValid && m_format_isValid && m_structure_isValid && true;
}

} // namespace OpenAPI
