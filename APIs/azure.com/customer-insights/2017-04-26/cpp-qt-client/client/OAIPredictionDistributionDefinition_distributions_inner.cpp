/**
 * CustomerInsightsManagementClient
 * The Azure Customer Insights management API provides a RESTful set of web services that interact with Azure Customer Insights service to manage your resources. The API has entities that capture the relationship between an end user and the Azure Customer Insights service.
 *
 * The version of the OpenAPI document: 2017-04-26
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPredictionDistributionDefinition_distributions_inner.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPredictionDistributionDefinition_distributions_inner::OAIPredictionDistributionDefinition_distributions_inner(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPredictionDistributionDefinition_distributions_inner::OAIPredictionDistributionDefinition_distributions_inner() {
    this->initializeModel();
}

OAIPredictionDistributionDefinition_distributions_inner::~OAIPredictionDistributionDefinition_distributions_inner() {}

void OAIPredictionDistributionDefinition_distributions_inner::initializeModel() {

    m_negatives_isSet = false;
    m_negatives_isValid = false;

    m_negatives_above_threshold_isSet = false;
    m_negatives_above_threshold_isValid = false;

    m_positives_isSet = false;
    m_positives_isValid = false;

    m_positives_above_threshold_isSet = false;
    m_positives_above_threshold_isValid = false;

    m_score_threshold_isSet = false;
    m_score_threshold_isValid = false;
}

void OAIPredictionDistributionDefinition_distributions_inner::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPredictionDistributionDefinition_distributions_inner::fromJsonObject(QJsonObject json) {

    m_negatives_isValid = ::OpenAPI::fromJsonValue(m_negatives, json[QString("negatives")]);
    m_negatives_isSet = !json[QString("negatives")].isNull() && m_negatives_isValid;

    m_negatives_above_threshold_isValid = ::OpenAPI::fromJsonValue(m_negatives_above_threshold, json[QString("negativesAboveThreshold")]);
    m_negatives_above_threshold_isSet = !json[QString("negativesAboveThreshold")].isNull() && m_negatives_above_threshold_isValid;

    m_positives_isValid = ::OpenAPI::fromJsonValue(m_positives, json[QString("positives")]);
    m_positives_isSet = !json[QString("positives")].isNull() && m_positives_isValid;

    m_positives_above_threshold_isValid = ::OpenAPI::fromJsonValue(m_positives_above_threshold, json[QString("positivesAboveThreshold")]);
    m_positives_above_threshold_isSet = !json[QString("positivesAboveThreshold")].isNull() && m_positives_above_threshold_isValid;

    m_score_threshold_isValid = ::OpenAPI::fromJsonValue(m_score_threshold, json[QString("scoreThreshold")]);
    m_score_threshold_isSet = !json[QString("scoreThreshold")].isNull() && m_score_threshold_isValid;
}

QString OAIPredictionDistributionDefinition_distributions_inner::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPredictionDistributionDefinition_distributions_inner::asJsonObject() const {
    QJsonObject obj;
    if (m_negatives_isSet) {
        obj.insert(QString("negatives"), ::OpenAPI::toJsonValue(m_negatives));
    }
    if (m_negatives_above_threshold_isSet) {
        obj.insert(QString("negativesAboveThreshold"), ::OpenAPI::toJsonValue(m_negatives_above_threshold));
    }
    if (m_positives_isSet) {
        obj.insert(QString("positives"), ::OpenAPI::toJsonValue(m_positives));
    }
    if (m_positives_above_threshold_isSet) {
        obj.insert(QString("positivesAboveThreshold"), ::OpenAPI::toJsonValue(m_positives_above_threshold));
    }
    if (m_score_threshold_isSet) {
        obj.insert(QString("scoreThreshold"), ::OpenAPI::toJsonValue(m_score_threshold));
    }
    return obj;
}

qint64 OAIPredictionDistributionDefinition_distributions_inner::getNegatives() const {
    return m_negatives;
}
void OAIPredictionDistributionDefinition_distributions_inner::setNegatives(const qint64 &negatives) {
    m_negatives = negatives;
    m_negatives_isSet = true;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_negatives_Set() const{
    return m_negatives_isSet;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_negatives_Valid() const{
    return m_negatives_isValid;
}

qint64 OAIPredictionDistributionDefinition_distributions_inner::getNegativesAboveThreshold() const {
    return m_negatives_above_threshold;
}
void OAIPredictionDistributionDefinition_distributions_inner::setNegativesAboveThreshold(const qint64 &negatives_above_threshold) {
    m_negatives_above_threshold = negatives_above_threshold;
    m_negatives_above_threshold_isSet = true;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_negatives_above_threshold_Set() const{
    return m_negatives_above_threshold_isSet;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_negatives_above_threshold_Valid() const{
    return m_negatives_above_threshold_isValid;
}

qint64 OAIPredictionDistributionDefinition_distributions_inner::getPositives() const {
    return m_positives;
}
void OAIPredictionDistributionDefinition_distributions_inner::setPositives(const qint64 &positives) {
    m_positives = positives;
    m_positives_isSet = true;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_positives_Set() const{
    return m_positives_isSet;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_positives_Valid() const{
    return m_positives_isValid;
}

qint64 OAIPredictionDistributionDefinition_distributions_inner::getPositivesAboveThreshold() const {
    return m_positives_above_threshold;
}
void OAIPredictionDistributionDefinition_distributions_inner::setPositivesAboveThreshold(const qint64 &positives_above_threshold) {
    m_positives_above_threshold = positives_above_threshold;
    m_positives_above_threshold_isSet = true;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_positives_above_threshold_Set() const{
    return m_positives_above_threshold_isSet;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_positives_above_threshold_Valid() const{
    return m_positives_above_threshold_isValid;
}

qint32 OAIPredictionDistributionDefinition_distributions_inner::getScoreThreshold() const {
    return m_score_threshold;
}
void OAIPredictionDistributionDefinition_distributions_inner::setScoreThreshold(const qint32 &score_threshold) {
    m_score_threshold = score_threshold;
    m_score_threshold_isSet = true;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_score_threshold_Set() const{
    return m_score_threshold_isSet;
}

bool OAIPredictionDistributionDefinition_distributions_inner::is_score_threshold_Valid() const{
    return m_score_threshold_isValid;
}

bool OAIPredictionDistributionDefinition_distributions_inner::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_negatives_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_negatives_above_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_positives_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_positives_above_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_score_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPredictionDistributionDefinition_distributions_inner::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
