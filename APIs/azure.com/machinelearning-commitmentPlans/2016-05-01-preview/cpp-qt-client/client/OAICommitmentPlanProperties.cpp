/**
 * Azure ML Commitment Plans Management Client
 * These APIs allow end users to operate on Azure Machine Learning Commitment Plans resources and their child Commitment Association resources. They support CRUD operations for commitment plans, get and list operations for commitment associations, moving commitment associations between commitment plans, and retrieving commitment plan usage history.
 *
 * The version of the OpenAPI document: 2016-05-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICommitmentPlanProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICommitmentPlanProperties::OAICommitmentPlanProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICommitmentPlanProperties::OAICommitmentPlanProperties() {
    this->initializeModel();
}

OAICommitmentPlanProperties::~OAICommitmentPlanProperties() {}

void OAICommitmentPlanProperties::initializeModel() {

    m_charge_for_overage_isSet = false;
    m_charge_for_overage_isValid = false;

    m_charge_for_plan_isSet = false;
    m_charge_for_plan_isValid = false;

    m_creation_date_isSet = false;
    m_creation_date_isValid = false;

    m_included_quantities_isSet = false;
    m_included_quantities_isValid = false;

    m_max_association_limit_isSet = false;
    m_max_association_limit_isValid = false;

    m_max_capacity_limit_isSet = false;
    m_max_capacity_limit_isValid = false;

    m_min_capacity_limit_isSet = false;
    m_min_capacity_limit_isValid = false;

    m_plan_meter_isSet = false;
    m_plan_meter_isValid = false;

    m_refill_frequency_in_days_isSet = false;
    m_refill_frequency_in_days_isValid = false;

    m_suspend_plan_on_overage_isSet = false;
    m_suspend_plan_on_overage_isValid = false;
}

void OAICommitmentPlanProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICommitmentPlanProperties::fromJsonObject(QJsonObject json) {

    m_charge_for_overage_isValid = ::OpenAPI::fromJsonValue(m_charge_for_overage, json[QString("chargeForOverage")]);
    m_charge_for_overage_isSet = !json[QString("chargeForOverage")].isNull() && m_charge_for_overage_isValid;

    m_charge_for_plan_isValid = ::OpenAPI::fromJsonValue(m_charge_for_plan, json[QString("chargeForPlan")]);
    m_charge_for_plan_isSet = !json[QString("chargeForPlan")].isNull() && m_charge_for_plan_isValid;

    m_creation_date_isValid = ::OpenAPI::fromJsonValue(m_creation_date, json[QString("creationDate")]);
    m_creation_date_isSet = !json[QString("creationDate")].isNull() && m_creation_date_isValid;

    m_included_quantities_isValid = ::OpenAPI::fromJsonValue(m_included_quantities, json[QString("includedQuantities")]);
    m_included_quantities_isSet = !json[QString("includedQuantities")].isNull() && m_included_quantities_isValid;

    m_max_association_limit_isValid = ::OpenAPI::fromJsonValue(m_max_association_limit, json[QString("maxAssociationLimit")]);
    m_max_association_limit_isSet = !json[QString("maxAssociationLimit")].isNull() && m_max_association_limit_isValid;

    m_max_capacity_limit_isValid = ::OpenAPI::fromJsonValue(m_max_capacity_limit, json[QString("maxCapacityLimit")]);
    m_max_capacity_limit_isSet = !json[QString("maxCapacityLimit")].isNull() && m_max_capacity_limit_isValid;

    m_min_capacity_limit_isValid = ::OpenAPI::fromJsonValue(m_min_capacity_limit, json[QString("minCapacityLimit")]);
    m_min_capacity_limit_isSet = !json[QString("minCapacityLimit")].isNull() && m_min_capacity_limit_isValid;

    m_plan_meter_isValid = ::OpenAPI::fromJsonValue(m_plan_meter, json[QString("planMeter")]);
    m_plan_meter_isSet = !json[QString("planMeter")].isNull() && m_plan_meter_isValid;

    m_refill_frequency_in_days_isValid = ::OpenAPI::fromJsonValue(m_refill_frequency_in_days, json[QString("refillFrequencyInDays")]);
    m_refill_frequency_in_days_isSet = !json[QString("refillFrequencyInDays")].isNull() && m_refill_frequency_in_days_isValid;

    m_suspend_plan_on_overage_isValid = ::OpenAPI::fromJsonValue(m_suspend_plan_on_overage, json[QString("suspendPlanOnOverage")]);
    m_suspend_plan_on_overage_isSet = !json[QString("suspendPlanOnOverage")].isNull() && m_suspend_plan_on_overage_isValid;
}

QString OAICommitmentPlanProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICommitmentPlanProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_charge_for_overage_isSet) {
        obj.insert(QString("chargeForOverage"), ::OpenAPI::toJsonValue(m_charge_for_overage));
    }
    if (m_charge_for_plan_isSet) {
        obj.insert(QString("chargeForPlan"), ::OpenAPI::toJsonValue(m_charge_for_plan));
    }
    if (m_creation_date_isSet) {
        obj.insert(QString("creationDate"), ::OpenAPI::toJsonValue(m_creation_date));
    }
    if (m_included_quantities.size() > 0) {
        obj.insert(QString("includedQuantities"), ::OpenAPI::toJsonValue(m_included_quantities));
    }
    if (m_max_association_limit_isSet) {
        obj.insert(QString("maxAssociationLimit"), ::OpenAPI::toJsonValue(m_max_association_limit));
    }
    if (m_max_capacity_limit_isSet) {
        obj.insert(QString("maxCapacityLimit"), ::OpenAPI::toJsonValue(m_max_capacity_limit));
    }
    if (m_min_capacity_limit_isSet) {
        obj.insert(QString("minCapacityLimit"), ::OpenAPI::toJsonValue(m_min_capacity_limit));
    }
    if (m_plan_meter_isSet) {
        obj.insert(QString("planMeter"), ::OpenAPI::toJsonValue(m_plan_meter));
    }
    if (m_refill_frequency_in_days_isSet) {
        obj.insert(QString("refillFrequencyInDays"), ::OpenAPI::toJsonValue(m_refill_frequency_in_days));
    }
    if (m_suspend_plan_on_overage_isSet) {
        obj.insert(QString("suspendPlanOnOverage"), ::OpenAPI::toJsonValue(m_suspend_plan_on_overage));
    }
    return obj;
}

bool OAICommitmentPlanProperties::isChargeForOverage() const {
    return m_charge_for_overage;
}
void OAICommitmentPlanProperties::setChargeForOverage(const bool &charge_for_overage) {
    m_charge_for_overage = charge_for_overage;
    m_charge_for_overage_isSet = true;
}

bool OAICommitmentPlanProperties::is_charge_for_overage_Set() const{
    return m_charge_for_overage_isSet;
}

bool OAICommitmentPlanProperties::is_charge_for_overage_Valid() const{
    return m_charge_for_overage_isValid;
}

bool OAICommitmentPlanProperties::isChargeForPlan() const {
    return m_charge_for_plan;
}
void OAICommitmentPlanProperties::setChargeForPlan(const bool &charge_for_plan) {
    m_charge_for_plan = charge_for_plan;
    m_charge_for_plan_isSet = true;
}

bool OAICommitmentPlanProperties::is_charge_for_plan_Set() const{
    return m_charge_for_plan_isSet;
}

bool OAICommitmentPlanProperties::is_charge_for_plan_Valid() const{
    return m_charge_for_plan_isValid;
}

QDateTime OAICommitmentPlanProperties::getCreationDate() const {
    return m_creation_date;
}
void OAICommitmentPlanProperties::setCreationDate(const QDateTime &creation_date) {
    m_creation_date = creation_date;
    m_creation_date_isSet = true;
}

bool OAICommitmentPlanProperties::is_creation_date_Set() const{
    return m_creation_date_isSet;
}

bool OAICommitmentPlanProperties::is_creation_date_Valid() const{
    return m_creation_date_isValid;
}

QMap<QString, OAIPlanQuantity> OAICommitmentPlanProperties::getIncludedQuantities() const {
    return m_included_quantities;
}
void OAICommitmentPlanProperties::setIncludedQuantities(const QMap<QString, OAIPlanQuantity> &included_quantities) {
    m_included_quantities = included_quantities;
    m_included_quantities_isSet = true;
}

bool OAICommitmentPlanProperties::is_included_quantities_Set() const{
    return m_included_quantities_isSet;
}

bool OAICommitmentPlanProperties::is_included_quantities_Valid() const{
    return m_included_quantities_isValid;
}

qint32 OAICommitmentPlanProperties::getMaxAssociationLimit() const {
    return m_max_association_limit;
}
void OAICommitmentPlanProperties::setMaxAssociationLimit(const qint32 &max_association_limit) {
    m_max_association_limit = max_association_limit;
    m_max_association_limit_isSet = true;
}

bool OAICommitmentPlanProperties::is_max_association_limit_Set() const{
    return m_max_association_limit_isSet;
}

bool OAICommitmentPlanProperties::is_max_association_limit_Valid() const{
    return m_max_association_limit_isValid;
}

qint32 OAICommitmentPlanProperties::getMaxCapacityLimit() const {
    return m_max_capacity_limit;
}
void OAICommitmentPlanProperties::setMaxCapacityLimit(const qint32 &max_capacity_limit) {
    m_max_capacity_limit = max_capacity_limit;
    m_max_capacity_limit_isSet = true;
}

bool OAICommitmentPlanProperties::is_max_capacity_limit_Set() const{
    return m_max_capacity_limit_isSet;
}

bool OAICommitmentPlanProperties::is_max_capacity_limit_Valid() const{
    return m_max_capacity_limit_isValid;
}

qint32 OAICommitmentPlanProperties::getMinCapacityLimit() const {
    return m_min_capacity_limit;
}
void OAICommitmentPlanProperties::setMinCapacityLimit(const qint32 &min_capacity_limit) {
    m_min_capacity_limit = min_capacity_limit;
    m_min_capacity_limit_isSet = true;
}

bool OAICommitmentPlanProperties::is_min_capacity_limit_Set() const{
    return m_min_capacity_limit_isSet;
}

bool OAICommitmentPlanProperties::is_min_capacity_limit_Valid() const{
    return m_min_capacity_limit_isValid;
}

QString OAICommitmentPlanProperties::getPlanMeter() const {
    return m_plan_meter;
}
void OAICommitmentPlanProperties::setPlanMeter(const QString &plan_meter) {
    m_plan_meter = plan_meter;
    m_plan_meter_isSet = true;
}

bool OAICommitmentPlanProperties::is_plan_meter_Set() const{
    return m_plan_meter_isSet;
}

bool OAICommitmentPlanProperties::is_plan_meter_Valid() const{
    return m_plan_meter_isValid;
}

qint32 OAICommitmentPlanProperties::getRefillFrequencyInDays() const {
    return m_refill_frequency_in_days;
}
void OAICommitmentPlanProperties::setRefillFrequencyInDays(const qint32 &refill_frequency_in_days) {
    m_refill_frequency_in_days = refill_frequency_in_days;
    m_refill_frequency_in_days_isSet = true;
}

bool OAICommitmentPlanProperties::is_refill_frequency_in_days_Set() const{
    return m_refill_frequency_in_days_isSet;
}

bool OAICommitmentPlanProperties::is_refill_frequency_in_days_Valid() const{
    return m_refill_frequency_in_days_isValid;
}

bool OAICommitmentPlanProperties::isSuspendPlanOnOverage() const {
    return m_suspend_plan_on_overage;
}
void OAICommitmentPlanProperties::setSuspendPlanOnOverage(const bool &suspend_plan_on_overage) {
    m_suspend_plan_on_overage = suspend_plan_on_overage;
    m_suspend_plan_on_overage_isSet = true;
}

bool OAICommitmentPlanProperties::is_suspend_plan_on_overage_Set() const{
    return m_suspend_plan_on_overage_isSet;
}

bool OAICommitmentPlanProperties::is_suspend_plan_on_overage_Valid() const{
    return m_suspend_plan_on_overage_isValid;
}

bool OAICommitmentPlanProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_charge_for_overage_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_charge_for_plan_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_creation_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_included_quantities.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_association_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_capacity_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_capacity_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_plan_meter_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_refill_frequency_in_days_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_suspend_plan_on_overage_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICommitmentPlanProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
