/**
 * Azure ML Commitment Plans Management Client
 * These APIs allow end users to operate on Azure Machine Learning Commitment Plans resources and their child Commitment Association resources. They support CRUD operations for commitment plans, get and list operations for commitment associations, moving commitment associations between commitment plans, and retrieving commitment plan usage history.
 *
 * The version of the OpenAPI document: 2016-05-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICatalogSku.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICatalogSku::OAICatalogSku(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICatalogSku::OAICatalogSku() {
    this->initializeModel();
}

OAICatalogSku::~OAICatalogSku() {}

void OAICatalogSku::initializeModel() {

    m_capabilities_isSet = false;
    m_capabilities_isValid = false;

    m_capacity_isSet = false;
    m_capacity_isValid = false;

    m_costs_isSet = false;
    m_costs_isValid = false;

    m_locations_isSet = false;
    m_locations_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_resource_type_isSet = false;
    m_resource_type_isValid = false;

    m_restrictions_isSet = false;
    m_restrictions_isValid = false;

    m_tier_isSet = false;
    m_tier_isValid = false;
}

void OAICatalogSku::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICatalogSku::fromJsonObject(QJsonObject json) {

    m_capabilities_isValid = ::OpenAPI::fromJsonValue(m_capabilities, json[QString("capabilities")]);
    m_capabilities_isSet = !json[QString("capabilities")].isNull() && m_capabilities_isValid;

    m_capacity_isValid = ::OpenAPI::fromJsonValue(m_capacity, json[QString("capacity")]);
    m_capacity_isSet = !json[QString("capacity")].isNull() && m_capacity_isValid;

    m_costs_isValid = ::OpenAPI::fromJsonValue(m_costs, json[QString("costs")]);
    m_costs_isSet = !json[QString("costs")].isNull() && m_costs_isValid;

    m_locations_isValid = ::OpenAPI::fromJsonValue(m_locations, json[QString("locations")]);
    m_locations_isSet = !json[QString("locations")].isNull() && m_locations_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_resource_type_isValid = ::OpenAPI::fromJsonValue(m_resource_type, json[QString("resourceType")]);
    m_resource_type_isSet = !json[QString("resourceType")].isNull() && m_resource_type_isValid;

    m_restrictions_isValid = ::OpenAPI::fromJsonValue(m_restrictions, json[QString("restrictions")]);
    m_restrictions_isSet = !json[QString("restrictions")].isNull() && m_restrictions_isValid;

    m_tier_isValid = ::OpenAPI::fromJsonValue(m_tier, json[QString("tier")]);
    m_tier_isSet = !json[QString("tier")].isNull() && m_tier_isValid;
}

QString OAICatalogSku::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICatalogSku::asJsonObject() const {
    QJsonObject obj;
    if (m_capabilities.size() > 0) {
        obj.insert(QString("capabilities"), ::OpenAPI::toJsonValue(m_capabilities));
    }
    if (m_capacity.isSet()) {
        obj.insert(QString("capacity"), ::OpenAPI::toJsonValue(m_capacity));
    }
    if (m_costs.size() > 0) {
        obj.insert(QString("costs"), ::OpenAPI::toJsonValue(m_costs));
    }
    if (m_locations.size() > 0) {
        obj.insert(QString("locations"), ::OpenAPI::toJsonValue(m_locations));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_resource_type_isSet) {
        obj.insert(QString("resourceType"), ::OpenAPI::toJsonValue(m_resource_type));
    }
    if (m_restrictions.size() > 0) {
        obj.insert(QString("restrictions"), ::OpenAPI::toJsonValue(m_restrictions));
    }
    if (m_tier_isSet) {
        obj.insert(QString("tier"), ::OpenAPI::toJsonValue(m_tier));
    }
    return obj;
}

QList<OAISkuCapability> OAICatalogSku::getCapabilities() const {
    return m_capabilities;
}
void OAICatalogSku::setCapabilities(const QList<OAISkuCapability> &capabilities) {
    m_capabilities = capabilities;
    m_capabilities_isSet = true;
}

bool OAICatalogSku::is_capabilities_Set() const{
    return m_capabilities_isSet;
}

bool OAICatalogSku::is_capabilities_Valid() const{
    return m_capabilities_isValid;
}

OAISkuCapacity OAICatalogSku::getCapacity() const {
    return m_capacity;
}
void OAICatalogSku::setCapacity(const OAISkuCapacity &capacity) {
    m_capacity = capacity;
    m_capacity_isSet = true;
}

bool OAICatalogSku::is_capacity_Set() const{
    return m_capacity_isSet;
}

bool OAICatalogSku::is_capacity_Valid() const{
    return m_capacity_isValid;
}

QList<OAISkuCost> OAICatalogSku::getCosts() const {
    return m_costs;
}
void OAICatalogSku::setCosts(const QList<OAISkuCost> &costs) {
    m_costs = costs;
    m_costs_isSet = true;
}

bool OAICatalogSku::is_costs_Set() const{
    return m_costs_isSet;
}

bool OAICatalogSku::is_costs_Valid() const{
    return m_costs_isValid;
}

QList<QString> OAICatalogSku::getLocations() const {
    return m_locations;
}
void OAICatalogSku::setLocations(const QList<QString> &locations) {
    m_locations = locations;
    m_locations_isSet = true;
}

bool OAICatalogSku::is_locations_Set() const{
    return m_locations_isSet;
}

bool OAICatalogSku::is_locations_Valid() const{
    return m_locations_isValid;
}

QString OAICatalogSku::getName() const {
    return m_name;
}
void OAICatalogSku::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAICatalogSku::is_name_Set() const{
    return m_name_isSet;
}

bool OAICatalogSku::is_name_Valid() const{
    return m_name_isValid;
}

QString OAICatalogSku::getResourceType() const {
    return m_resource_type;
}
void OAICatalogSku::setResourceType(const QString &resource_type) {
    m_resource_type = resource_type;
    m_resource_type_isSet = true;
}

bool OAICatalogSku::is_resource_type_Set() const{
    return m_resource_type_isSet;
}

bool OAICatalogSku::is_resource_type_Valid() const{
    return m_resource_type_isValid;
}

QList<OAISkuRestrictions> OAICatalogSku::getRestrictions() const {
    return m_restrictions;
}
void OAICatalogSku::setRestrictions(const QList<OAISkuRestrictions> &restrictions) {
    m_restrictions = restrictions;
    m_restrictions_isSet = true;
}

bool OAICatalogSku::is_restrictions_Set() const{
    return m_restrictions_isSet;
}

bool OAICatalogSku::is_restrictions_Valid() const{
    return m_restrictions_isValid;
}

QString OAICatalogSku::getTier() const {
    return m_tier;
}
void OAICatalogSku::setTier(const QString &tier) {
    m_tier = tier;
    m_tier_isSet = true;
}

bool OAICatalogSku::is_tier_Set() const{
    return m_tier_isSet;
}

bool OAICatalogSku::is_tier_Valid() const{
    return m_tier_isValid;
}

bool OAICatalogSku::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_capabilities.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_capacity.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_costs.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_locations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_resource_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_restrictions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_tier_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICatalogSku::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
