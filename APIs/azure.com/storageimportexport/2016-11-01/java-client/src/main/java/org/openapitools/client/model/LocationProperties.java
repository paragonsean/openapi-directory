/*
 * StorageImportExport
 * The Storage Import/Export Resource Provider API.
 *
 * The version of the OpenAPI document: 2016-11-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * location properties
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:44:33.992396-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LocationProperties {
  public static final String SERIALIZED_NAME_ALTERNATE_LOCATIONS = "alternateLocations";
  @SerializedName(SERIALIZED_NAME_ALTERNATE_LOCATIONS)
  private List<String> alternateLocations = new ArrayList<>();

  public static final String SERIALIZED_NAME_CITY = "city";
  @SerializedName(SERIALIZED_NAME_CITY)
  private String city;

  public static final String SERIALIZED_NAME_COUNTRY_OR_REGION = "countryOrRegion";
  @SerializedName(SERIALIZED_NAME_COUNTRY_OR_REGION)
  private String countryOrRegion;

  public static final String SERIALIZED_NAME_PHONE = "phone";
  @SerializedName(SERIALIZED_NAME_PHONE)
  private String phone;

  public static final String SERIALIZED_NAME_POSTAL_CODE = "postalCode";
  @SerializedName(SERIALIZED_NAME_POSTAL_CODE)
  private String postalCode;

  public static final String SERIALIZED_NAME_RECIPIENT_NAME = "recipientName";
  @SerializedName(SERIALIZED_NAME_RECIPIENT_NAME)
  private String recipientName;

  public static final String SERIALIZED_NAME_STATE_OR_PROVINCE = "stateOrProvince";
  @SerializedName(SERIALIZED_NAME_STATE_OR_PROVINCE)
  private String stateOrProvince;

  public static final String SERIALIZED_NAME_STREET_ADDRESS1 = "streetAddress1";
  @SerializedName(SERIALIZED_NAME_STREET_ADDRESS1)
  private String streetAddress1;

  public static final String SERIALIZED_NAME_STREET_ADDRESS2 = "streetAddress2";
  @SerializedName(SERIALIZED_NAME_STREET_ADDRESS2)
  private String streetAddress2;

  public static final String SERIALIZED_NAME_SUPPORTED_CARRIERS = "supportedCarriers";
  @SerializedName(SERIALIZED_NAME_SUPPORTED_CARRIERS)
  private List<String> supportedCarriers = new ArrayList<>();

  public LocationProperties() {
  }

  public LocationProperties alternateLocations(List<String> alternateLocations) {
    this.alternateLocations = alternateLocations;
    return this;
  }

  public LocationProperties addAlternateLocationsItem(String alternateLocationsItem) {
    if (this.alternateLocations == null) {
      this.alternateLocations = new ArrayList<>();
    }
    this.alternateLocations.add(alternateLocationsItem);
    return this;
  }

  /**
   * A list of location IDs that should be used to ship shipping drives to for jobs created against the current location. If the current location is active, it will be part of the list. If it is temporarily closed due to maintenance, this list may contain other locations. 
   * @return alternateLocations
   */
  @javax.annotation.Nullable
  public List<String> getAlternateLocations() {
    return alternateLocations;
  }

  public void setAlternateLocations(List<String> alternateLocations) {
    this.alternateLocations = alternateLocations;
  }


  public LocationProperties city(String city) {
    this.city = city;
    return this;
  }

  /**
   * The city name to use when shipping the drives to the Azure data center. 
   * @return city
   */
  @javax.annotation.Nullable
  public String getCity() {
    return city;
  }

  public void setCity(String city) {
    this.city = city;
  }


  public LocationProperties countryOrRegion(String countryOrRegion) {
    this.countryOrRegion = countryOrRegion;
    return this;
  }

  /**
   * The country or region to use when shipping the drives to the Azure data center. 
   * @return countryOrRegion
   */
  @javax.annotation.Nullable
  public String getCountryOrRegion() {
    return countryOrRegion;
  }

  public void setCountryOrRegion(String countryOrRegion) {
    this.countryOrRegion = countryOrRegion;
  }


  public LocationProperties phone(String phone) {
    this.phone = phone;
    return this;
  }

  /**
   * The phone number for the Azure data center. 
   * @return phone
   */
  @javax.annotation.Nullable
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }


  public LocationProperties postalCode(String postalCode) {
    this.postalCode = postalCode;
    return this;
  }

  /**
   * The postal code to use when shipping the drives to the Azure data center. 
   * @return postalCode
   */
  @javax.annotation.Nullable
  public String getPostalCode() {
    return postalCode;
  }

  public void setPostalCode(String postalCode) {
    this.postalCode = postalCode;
  }


  public LocationProperties recipientName(String recipientName) {
    this.recipientName = recipientName;
    return this;
  }

  /**
   * The recipient name to use when shipping the drives to the Azure data center. 
   * @return recipientName
   */
  @javax.annotation.Nullable
  public String getRecipientName() {
    return recipientName;
  }

  public void setRecipientName(String recipientName) {
    this.recipientName = recipientName;
  }


  public LocationProperties stateOrProvince(String stateOrProvince) {
    this.stateOrProvince = stateOrProvince;
    return this;
  }

  /**
   * The state or province to use when shipping the drives to the Azure data center. 
   * @return stateOrProvince
   */
  @javax.annotation.Nullable
  public String getStateOrProvince() {
    return stateOrProvince;
  }

  public void setStateOrProvince(String stateOrProvince) {
    this.stateOrProvince = stateOrProvince;
  }


  public LocationProperties streetAddress1(String streetAddress1) {
    this.streetAddress1 = streetAddress1;
    return this;
  }

  /**
   * The first line of the street address to use when shipping the drives to the Azure data center. 
   * @return streetAddress1
   */
  @javax.annotation.Nullable
  public String getStreetAddress1() {
    return streetAddress1;
  }

  public void setStreetAddress1(String streetAddress1) {
    this.streetAddress1 = streetAddress1;
  }


  public LocationProperties streetAddress2(String streetAddress2) {
    this.streetAddress2 = streetAddress2;
    return this;
  }

  /**
   * The second line of the street address to use when shipping the drives to the Azure data center. 
   * @return streetAddress2
   */
  @javax.annotation.Nullable
  public String getStreetAddress2() {
    return streetAddress2;
  }

  public void setStreetAddress2(String streetAddress2) {
    this.streetAddress2 = streetAddress2;
  }


  public LocationProperties supportedCarriers(List<String> supportedCarriers) {
    this.supportedCarriers = supportedCarriers;
    return this;
  }

  public LocationProperties addSupportedCarriersItem(String supportedCarriersItem) {
    if (this.supportedCarriers == null) {
      this.supportedCarriers = new ArrayList<>();
    }
    this.supportedCarriers.add(supportedCarriersItem);
    return this;
  }

  /**
   * A list of carriers that are supported at this location. 
   * @return supportedCarriers
   */
  @javax.annotation.Nullable
  public List<String> getSupportedCarriers() {
    return supportedCarriers;
  }

  public void setSupportedCarriers(List<String> supportedCarriers) {
    this.supportedCarriers = supportedCarriers;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LocationProperties locationProperties = (LocationProperties) o;
    return Objects.equals(this.alternateLocations, locationProperties.alternateLocations) &&
        Objects.equals(this.city, locationProperties.city) &&
        Objects.equals(this.countryOrRegion, locationProperties.countryOrRegion) &&
        Objects.equals(this.phone, locationProperties.phone) &&
        Objects.equals(this.postalCode, locationProperties.postalCode) &&
        Objects.equals(this.recipientName, locationProperties.recipientName) &&
        Objects.equals(this.stateOrProvince, locationProperties.stateOrProvince) &&
        Objects.equals(this.streetAddress1, locationProperties.streetAddress1) &&
        Objects.equals(this.streetAddress2, locationProperties.streetAddress2) &&
        Objects.equals(this.supportedCarriers, locationProperties.supportedCarriers);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alternateLocations, city, countryOrRegion, phone, postalCode, recipientName, stateOrProvince, streetAddress1, streetAddress2, supportedCarriers);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LocationProperties {\n");
    sb.append("    alternateLocations: ").append(toIndentedString(alternateLocations)).append("\n");
    sb.append("    city: ").append(toIndentedString(city)).append("\n");
    sb.append("    countryOrRegion: ").append(toIndentedString(countryOrRegion)).append("\n");
    sb.append("    phone: ").append(toIndentedString(phone)).append("\n");
    sb.append("    postalCode: ").append(toIndentedString(postalCode)).append("\n");
    sb.append("    recipientName: ").append(toIndentedString(recipientName)).append("\n");
    sb.append("    stateOrProvince: ").append(toIndentedString(stateOrProvince)).append("\n");
    sb.append("    streetAddress1: ").append(toIndentedString(streetAddress1)).append("\n");
    sb.append("    streetAddress2: ").append(toIndentedString(streetAddress2)).append("\n");
    sb.append("    supportedCarriers: ").append(toIndentedString(supportedCarriers)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alternateLocations");
    openapiFields.add("city");
    openapiFields.add("countryOrRegion");
    openapiFields.add("phone");
    openapiFields.add("postalCode");
    openapiFields.add("recipientName");
    openapiFields.add("stateOrProvince");
    openapiFields.add("streetAddress1");
    openapiFields.add("streetAddress2");
    openapiFields.add("supportedCarriers");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LocationProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LocationProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LocationProperties is not found in the empty JSON string", LocationProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LocationProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LocationProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("alternateLocations") != null && !jsonObj.get("alternateLocations").isJsonNull() && !jsonObj.get("alternateLocations").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `alternateLocations` to be an array in the JSON string but got `%s`", jsonObj.get("alternateLocations").toString()));
      }
      if ((jsonObj.get("city") != null && !jsonObj.get("city").isJsonNull()) && !jsonObj.get("city").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `city` to be a primitive type in the JSON string but got `%s`", jsonObj.get("city").toString()));
      }
      if ((jsonObj.get("countryOrRegion") != null && !jsonObj.get("countryOrRegion").isJsonNull()) && !jsonObj.get("countryOrRegion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countryOrRegion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countryOrRegion").toString()));
      }
      if ((jsonObj.get("phone") != null && !jsonObj.get("phone").isJsonNull()) && !jsonObj.get("phone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `phone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("phone").toString()));
      }
      if ((jsonObj.get("postalCode") != null && !jsonObj.get("postalCode").isJsonNull()) && !jsonObj.get("postalCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postalCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postalCode").toString()));
      }
      if ((jsonObj.get("recipientName") != null && !jsonObj.get("recipientName").isJsonNull()) && !jsonObj.get("recipientName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recipientName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recipientName").toString()));
      }
      if ((jsonObj.get("stateOrProvince") != null && !jsonObj.get("stateOrProvince").isJsonNull()) && !jsonObj.get("stateOrProvince").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stateOrProvince` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stateOrProvince").toString()));
      }
      if ((jsonObj.get("streetAddress1") != null && !jsonObj.get("streetAddress1").isJsonNull()) && !jsonObj.get("streetAddress1").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streetAddress1` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streetAddress1").toString()));
      }
      if ((jsonObj.get("streetAddress2") != null && !jsonObj.get("streetAddress2").isJsonNull()) && !jsonObj.get("streetAddress2").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streetAddress2` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streetAddress2").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("supportedCarriers") != null && !jsonObj.get("supportedCarriers").isJsonNull() && !jsonObj.get("supportedCarriers").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `supportedCarriers` to be an array in the JSON string but got `%s`", jsonObj.get("supportedCarriers").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LocationProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LocationProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LocationProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LocationProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<LocationProperties>() {
           @Override
           public void write(JsonWriter out, LocationProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LocationProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LocationProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LocationProperties
   * @throws IOException if the JSON string is invalid with respect to LocationProperties
   */
  public static LocationProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LocationProperties.class);
  }

  /**
   * Convert an instance of LocationProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

