/*
 * StorageImportExport
 * The Storage Import/Export Resource Provider API.
 *
 * The version of the OpenAPI document: 2016-11-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ExportBlobList;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A property containing information about the blobs to be exported for an export job. This property is required for export jobs, but must not be specified for import jobs.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:44:33.992396-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Export {
  public static final String SERIALIZED_NAME_BLOB_LIST = "blobList";
  @SerializedName(SERIALIZED_NAME_BLOB_LIST)
  private ExportBlobList blobList;

  public static final String SERIALIZED_NAME_BLOB_LISTBLOB_PATH = "blobListblobPath";
  @SerializedName(SERIALIZED_NAME_BLOB_LISTBLOB_PATH)
  private String blobListblobPath;

  public Export() {
  }

  public Export blobList(ExportBlobList blobList) {
    this.blobList = blobList;
    return this;
  }

  /**
   * Get blobList
   * @return blobList
   */
  @javax.annotation.Nullable
  public ExportBlobList getBlobList() {
    return blobList;
  }

  public void setBlobList(ExportBlobList blobList) {
    this.blobList = blobList;
  }


  public Export blobListblobPath(String blobListblobPath) {
    this.blobListblobPath = blobListblobPath;
    return this;
  }

  /**
   * The relative URI to the block blob that contains the list of blob paths or blob path prefixes as defined above, beginning with the container name. If the blob is in root container, the URI must begin with $root. 
   * @return blobListblobPath
   */
  @javax.annotation.Nullable
  public String getBlobListblobPath() {
    return blobListblobPath;
  }

  public void setBlobListblobPath(String blobListblobPath) {
    this.blobListblobPath = blobListblobPath;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Export export = (Export) o;
    return Objects.equals(this.blobList, export.blobList) &&
        Objects.equals(this.blobListblobPath, export.blobListblobPath);
  }

  @Override
  public int hashCode() {
    return Objects.hash(blobList, blobListblobPath);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Export {\n");
    sb.append("    blobList: ").append(toIndentedString(blobList)).append("\n");
    sb.append("    blobListblobPath: ").append(toIndentedString(blobListblobPath)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("blobList");
    openapiFields.add("blobListblobPath");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Export
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Export.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Export is not found in the empty JSON string", Export.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Export.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Export` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `blobList`
      if (jsonObj.get("blobList") != null && !jsonObj.get("blobList").isJsonNull()) {
        ExportBlobList.validateJsonElement(jsonObj.get("blobList"));
      }
      if ((jsonObj.get("blobListblobPath") != null && !jsonObj.get("blobListblobPath").isJsonNull()) && !jsonObj.get("blobListblobPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `blobListblobPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("blobListblobPath").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Export.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Export' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Export> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Export.class));

       return (TypeAdapter<T>) new TypeAdapter<Export>() {
           @Override
           public void write(JsonWriter out, Export value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Export read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Export given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Export
   * @throws IOException if the JSON string is invalid with respect to Export
   */
  public static Export fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Export.class);
  }

  /**
   * Convert an instance of Export to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

