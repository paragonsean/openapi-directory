/*
 * StorageManagementClient
 * The Admin Storage Management Client.
 *
 * The version of the OpenAPI document: 2015-12-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Settings of BLOB service.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:44:09.910124-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BlobServiceWritableSettings {
  public static final String SERIALIZED_NAME_BLOB_SVC_CONTAINER_GC_INTERVAL = "blobSvcContainerGcInterval";
  @SerializedName(SERIALIZED_NAME_BLOB_SVC_CONTAINER_GC_INTERVAL)
  private Integer blobSvcContainerGcInterval;

  public static final String SERIALIZED_NAME_BLOB_SVC_SHALLOW_GC_INTERVAL = "blobSvcShallowGcInterval";
  @SerializedName(SERIALIZED_NAME_BLOB_SVC_SHALLOW_GC_INTERVAL)
  private Integer blobSvcShallowGcInterval;

  public static final String SERIALIZED_NAME_BLOB_SVC_STREAM_MAP_MIN_CONTAINER_OCCUPANCY_PERCENT = "blobSvcStreamMapMinContainerOccupancyPercent";
  @SerializedName(SERIALIZED_NAME_BLOB_SVC_STREAM_MAP_MIN_CONTAINER_OCCUPANCY_PERCENT)
  private Integer blobSvcStreamMapMinContainerOccupancyPercent;

  public static final String SERIALIZED_NAME_FRONT_END_HTTP_LISTEN_PORT = "frontEndHttpListenPort";
  @SerializedName(SERIALIZED_NAME_FRONT_END_HTTP_LISTEN_PORT)
  private Integer frontEndHttpListenPort;

  public static final String SERIALIZED_NAME_FRONT_END_HTTPS_LISTEN_PORT = "frontEndHttpsListenPort";
  @SerializedName(SERIALIZED_NAME_FRONT_END_HTTPS_LISTEN_PORT)
  private Integer frontEndHttpsListenPort;

  public static final String SERIALIZED_NAME_FRONT_END_CALLBACK_THREADS_COUNT = "frontEndCallbackThreadsCount";
  @SerializedName(SERIALIZED_NAME_FRONT_END_CALLBACK_THREADS_COUNT)
  private Integer frontEndCallbackThreadsCount;

  public static final String SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_CPU_MONITOR_INTERVAL_IN_SECONDS = "frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds";
  @SerializedName(SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_CPU_MONITOR_INTERVAL_IN_SECONDS)
  private Integer frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds;

  public static final String SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_ENABLED = "frontEndCpuBasedKeepAliveThrottlingEnabled";
  @SerializedName(SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_ENABLED)
  private Boolean frontEndCpuBasedKeepAliveThrottlingEnabled;

  public static final String SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_PERCENT_CPU_THRESHOLD = "frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold";
  @SerializedName(SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_PERCENT_CPU_THRESHOLD)
  private Float frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold;

  public static final String SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_PERCENT_REQUESTS_TO_THROTTLE = "frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle";
  @SerializedName(SERIALIZED_NAME_FRONT_END_CPU_BASED_KEEP_ALIVE_THROTTLING_PERCENT_REQUESTS_TO_THROTTLE)
  private Float frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle;

  public static final String SERIALIZED_NAME_FRONT_END_MAX_MILLISECONDS_BETWEEN_MEMORY_SAMPLES = "frontEndMaxMillisecondsBetweenMemorySamples";
  @SerializedName(SERIALIZED_NAME_FRONT_END_MAX_MILLISECONDS_BETWEEN_MEMORY_SAMPLES)
  private Integer frontEndMaxMillisecondsBetweenMemorySamples;

  public static final String SERIALIZED_NAME_FRONT_END_MEMORY_THROTTLE_THRESHOLD_SETTINGS = "frontEndMemoryThrottleThresholdSettings";
  @SerializedName(SERIALIZED_NAME_FRONT_END_MEMORY_THROTTLE_THRESHOLD_SETTINGS)
  private String frontEndMemoryThrottleThresholdSettings;

  public static final String SERIALIZED_NAME_FRONT_END_MEMORY_THROTTLING_ENABLED = "frontEndMemoryThrottlingEnabled";
  @SerializedName(SERIALIZED_NAME_FRONT_END_MEMORY_THROTTLING_ENABLED)
  private Boolean frontEndMemoryThrottlingEnabled;

  public static final String SERIALIZED_NAME_FRONT_END_MIN_THREAD_POOL_THREADS = "frontEndMinThreadPoolThreads";
  @SerializedName(SERIALIZED_NAME_FRONT_END_MIN_THREAD_POOL_THREADS)
  private Integer frontEndMinThreadPoolThreads;

  public static final String SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_I_O_COMPLETION_THRESHOLD = "frontEndThreadPoolBasedKeepAliveIOCompletionThreshold";
  @SerializedName(SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_I_O_COMPLETION_THRESHOLD)
  private Integer frontEndThreadPoolBasedKeepAliveIOCompletionThreshold;

  public static final String SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_MONITOR_INTERVAL_IN_SECONDS = "frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds";
  @SerializedName(SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_MONITOR_INTERVAL_IN_SECONDS)
  private Integer frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds;

  public static final String SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_PERCENTAGE = "frontEndThreadPoolBasedKeepAlivePercentage";
  @SerializedName(SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_PERCENTAGE)
  private Float frontEndThreadPoolBasedKeepAlivePercentage;

  public static final String SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_WORKER_THREAD_THRESHOLD = "frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold";
  @SerializedName(SERIALIZED_NAME_FRONT_END_THREAD_POOL_BASED_KEEP_ALIVE_WORKER_THREAD_THRESHOLD)
  private Integer frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold;

  public static final String SERIALIZED_NAME_FRONT_END_USE_SLA_TIME_IN_AVAILABILITY = "frontEndUseSlaTimeInAvailability";
  @SerializedName(SERIALIZED_NAME_FRONT_END_USE_SLA_TIME_IN_AVAILABILITY)
  private Boolean frontEndUseSlaTimeInAvailability;

  public BlobServiceWritableSettings() {
  }

  public BlobServiceWritableSettings(
     Integer blobSvcContainerGcInterval, 
     Integer blobSvcShallowGcInterval, 
     Integer blobSvcStreamMapMinContainerOccupancyPercent
  ) {
    this();
    this.blobSvcContainerGcInterval = blobSvcContainerGcInterval;
    this.blobSvcShallowGcInterval = blobSvcShallowGcInterval;
    this.blobSvcStreamMapMinContainerOccupancyPercent = blobSvcStreamMapMinContainerOccupancyPercent;
  }

  /**
   * The interval, in seconds, of container garbage collection.
   * @return blobSvcContainerGcInterval
   */
  @javax.annotation.Nullable
  public Integer getBlobSvcContainerGcInterval() {
    return blobSvcContainerGcInterval;
  }



  /**
   * The interval ,in seconds, of shallow garbage collection.
   * @return blobSvcShallowGcInterval
   */
  @javax.annotation.Nullable
  public Integer getBlobSvcShallowGcInterval() {
    return blobSvcShallowGcInterval;
  }



  /**
   * The minimal container occupancy percent for stream mapping.
   * @return blobSvcStreamMapMinContainerOccupancyPercent
   */
  @javax.annotation.Nullable
  public Integer getBlobSvcStreamMapMinContainerOccupancyPercent() {
    return blobSvcStreamMapMinContainerOccupancyPercent;
  }



  public BlobServiceWritableSettings frontEndHttpListenPort(Integer frontEndHttpListenPort) {
    this.frontEndHttpListenPort = frontEndHttpListenPort;
    return this;
  }

  /**
   * The HTTP port of the storage service front end.
   * @return frontEndHttpListenPort
   */
  @javax.annotation.Nullable
  public Integer getFrontEndHttpListenPort() {
    return frontEndHttpListenPort;
  }

  public void setFrontEndHttpListenPort(Integer frontEndHttpListenPort) {
    this.frontEndHttpListenPort = frontEndHttpListenPort;
  }


  public BlobServiceWritableSettings frontEndHttpsListenPort(Integer frontEndHttpsListenPort) {
    this.frontEndHttpsListenPort = frontEndHttpsListenPort;
    return this;
  }

  /**
   * The HTTPs port of the storage service front end.
   * @return frontEndHttpsListenPort
   */
  @javax.annotation.Nullable
  public Integer getFrontEndHttpsListenPort() {
    return frontEndHttpsListenPort;
  }

  public void setFrontEndHttpsListenPort(Integer frontEndHttpsListenPort) {
    this.frontEndHttpsListenPort = frontEndHttpsListenPort;
  }


  public BlobServiceWritableSettings frontEndCallbackThreadsCount(Integer frontEndCallbackThreadsCount) {
    this.frontEndCallbackThreadsCount = frontEndCallbackThreadsCount;
    return this;
  }

  /**
   * Front end callback threads count.
   * @return frontEndCallbackThreadsCount
   */
  @javax.annotation.Nullable
  public Integer getFrontEndCallbackThreadsCount() {
    return frontEndCallbackThreadsCount;
  }

  public void setFrontEndCallbackThreadsCount(Integer frontEndCallbackThreadsCount) {
    this.frontEndCallbackThreadsCount = frontEndCallbackThreadsCount;
  }


  public BlobServiceWritableSettings frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds(Integer frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds) {
    this.frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds = frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds;
    return this;
  }

  /**
   * Interval (in second) of CPU monitor for front end CPU based keep-alive throttling.
   * @return frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds
   */
  @javax.annotation.Nullable
  public Integer getFrontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds() {
    return frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds;
  }

  public void setFrontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds(Integer frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds) {
    this.frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds = frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds;
  }


  public BlobServiceWritableSettings frontEndCpuBasedKeepAliveThrottlingEnabled(Boolean frontEndCpuBasedKeepAliveThrottlingEnabled) {
    this.frontEndCpuBasedKeepAliveThrottlingEnabled = frontEndCpuBasedKeepAliveThrottlingEnabled;
    return this;
  }

  /**
   * Switch of front end CPU based keep-alive throttling.
   * @return frontEndCpuBasedKeepAliveThrottlingEnabled
   */
  @javax.annotation.Nullable
  public Boolean getFrontEndCpuBasedKeepAliveThrottlingEnabled() {
    return frontEndCpuBasedKeepAliveThrottlingEnabled;
  }

  public void setFrontEndCpuBasedKeepAliveThrottlingEnabled(Boolean frontEndCpuBasedKeepAliveThrottlingEnabled) {
    this.frontEndCpuBasedKeepAliveThrottlingEnabled = frontEndCpuBasedKeepAliveThrottlingEnabled;
  }


  public BlobServiceWritableSettings frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold(Float frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold) {
    this.frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold = frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold;
    return this;
  }

  /**
   * Threshold (% percentage) of front end CPU based keep-alive throttling.
   * @return frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold
   */
  @javax.annotation.Nullable
  public Float getFrontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold() {
    return frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold;
  }

  public void setFrontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold(Float frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold) {
    this.frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold = frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold;
  }


  public BlobServiceWritableSettings frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle(Float frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle) {
    this.frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle = frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle;
    return this;
  }

  /**
   * Threshold (% percentage) of requests to throttle in front end CPU based keep-alive throttling.
   * @return frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle
   */
  @javax.annotation.Nullable
  public Float getFrontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle() {
    return frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle;
  }

  public void setFrontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle(Float frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle) {
    this.frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle = frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle;
  }


  public BlobServiceWritableSettings frontEndMaxMillisecondsBetweenMemorySamples(Integer frontEndMaxMillisecondsBetweenMemorySamples) {
    this.frontEndMaxMillisecondsBetweenMemorySamples = frontEndMaxMillisecondsBetweenMemorySamples;
    return this;
  }

  /**
   * Maximum interval (in millisecond) between memory samples of front end.
   * @return frontEndMaxMillisecondsBetweenMemorySamples
   */
  @javax.annotation.Nullable
  public Integer getFrontEndMaxMillisecondsBetweenMemorySamples() {
    return frontEndMaxMillisecondsBetweenMemorySamples;
  }

  public void setFrontEndMaxMillisecondsBetweenMemorySamples(Integer frontEndMaxMillisecondsBetweenMemorySamples) {
    this.frontEndMaxMillisecondsBetweenMemorySamples = frontEndMaxMillisecondsBetweenMemorySamples;
  }


  public BlobServiceWritableSettings frontEndMemoryThrottleThresholdSettings(String frontEndMemoryThrottleThresholdSettings) {
    this.frontEndMemoryThrottleThresholdSettings = frontEndMemoryThrottleThresholdSettings;
    return this;
  }

  /**
   * Front end memory throttle threshold settings.
   * @return frontEndMemoryThrottleThresholdSettings
   */
  @javax.annotation.Nullable
  public String getFrontEndMemoryThrottleThresholdSettings() {
    return frontEndMemoryThrottleThresholdSettings;
  }

  public void setFrontEndMemoryThrottleThresholdSettings(String frontEndMemoryThrottleThresholdSettings) {
    this.frontEndMemoryThrottleThresholdSettings = frontEndMemoryThrottleThresholdSettings;
  }


  public BlobServiceWritableSettings frontEndMemoryThrottlingEnabled(Boolean frontEndMemoryThrottlingEnabled) {
    this.frontEndMemoryThrottlingEnabled = frontEndMemoryThrottlingEnabled;
    return this;
  }

  /**
   * Switch of front end memory throttling.
   * @return frontEndMemoryThrottlingEnabled
   */
  @javax.annotation.Nullable
  public Boolean getFrontEndMemoryThrottlingEnabled() {
    return frontEndMemoryThrottlingEnabled;
  }

  public void setFrontEndMemoryThrottlingEnabled(Boolean frontEndMemoryThrottlingEnabled) {
    this.frontEndMemoryThrottlingEnabled = frontEndMemoryThrottlingEnabled;
  }


  public BlobServiceWritableSettings frontEndMinThreadPoolThreads(Integer frontEndMinThreadPoolThreads) {
    this.frontEndMinThreadPoolThreads = frontEndMinThreadPoolThreads;
    return this;
  }

  /**
   * Front end minimum number of threads in thread pool.
   * @return frontEndMinThreadPoolThreads
   */
  @javax.annotation.Nullable
  public Integer getFrontEndMinThreadPoolThreads() {
    return frontEndMinThreadPoolThreads;
  }

  public void setFrontEndMinThreadPoolThreads(Integer frontEndMinThreadPoolThreads) {
    this.frontEndMinThreadPoolThreads = frontEndMinThreadPoolThreads;
  }


  public BlobServiceWritableSettings frontEndThreadPoolBasedKeepAliveIOCompletionThreshold(Integer frontEndThreadPoolBasedKeepAliveIOCompletionThreshold) {
    this.frontEndThreadPoolBasedKeepAliveIOCompletionThreshold = frontEndThreadPoolBasedKeepAliveIOCompletionThreshold;
    return this;
  }

  /**
   * Threshold of front end thread pool based keep-alive IO completion.
   * @return frontEndThreadPoolBasedKeepAliveIOCompletionThreshold
   */
  @javax.annotation.Nullable
  public Integer getFrontEndThreadPoolBasedKeepAliveIOCompletionThreshold() {
    return frontEndThreadPoolBasedKeepAliveIOCompletionThreshold;
  }

  public void setFrontEndThreadPoolBasedKeepAliveIOCompletionThreshold(Integer frontEndThreadPoolBasedKeepAliveIOCompletionThreshold) {
    this.frontEndThreadPoolBasedKeepAliveIOCompletionThreshold = frontEndThreadPoolBasedKeepAliveIOCompletionThreshold;
  }


  public BlobServiceWritableSettings frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds(Integer frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds) {
    this.frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds = frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds;
    return this;
  }

  /**
   * Monitor interval (in seconds) of front end thread pool based keep-alive monitor.
   * @return frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds
   */
  @javax.annotation.Nullable
  public Integer getFrontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds() {
    return frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds;
  }

  public void setFrontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds(Integer frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds) {
    this.frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds = frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds;
  }


  public BlobServiceWritableSettings frontEndThreadPoolBasedKeepAlivePercentage(Float frontEndThreadPoolBasedKeepAlivePercentage) {
    this.frontEndThreadPoolBasedKeepAlivePercentage = frontEndThreadPoolBasedKeepAlivePercentage;
    return this;
  }

  /**
   * Percentage (%) of front end thread pool based keep-alive.
   * @return frontEndThreadPoolBasedKeepAlivePercentage
   */
  @javax.annotation.Nullable
  public Float getFrontEndThreadPoolBasedKeepAlivePercentage() {
    return frontEndThreadPoolBasedKeepAlivePercentage;
  }

  public void setFrontEndThreadPoolBasedKeepAlivePercentage(Float frontEndThreadPoolBasedKeepAlivePercentage) {
    this.frontEndThreadPoolBasedKeepAlivePercentage = frontEndThreadPoolBasedKeepAlivePercentage;
  }


  public BlobServiceWritableSettings frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold(Integer frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold) {
    this.frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold = frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold;
    return this;
  }

  /**
   * Threshold of front end thread pool based keep-alive worker thread.
   * @return frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold
   */
  @javax.annotation.Nullable
  public Integer getFrontEndThreadPoolBasedKeepAliveWorkerThreadThreshold() {
    return frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold;
  }

  public void setFrontEndThreadPoolBasedKeepAliveWorkerThreadThreshold(Integer frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold) {
    this.frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold = frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold;
  }


  public BlobServiceWritableSettings frontEndUseSlaTimeInAvailability(Boolean frontEndUseSlaTimeInAvailability) {
    this.frontEndUseSlaTimeInAvailability = frontEndUseSlaTimeInAvailability;
    return this;
  }

  /**
   * Switch of whether front end uses SLA time in availability.
   * @return frontEndUseSlaTimeInAvailability
   */
  @javax.annotation.Nullable
  public Boolean getFrontEndUseSlaTimeInAvailability() {
    return frontEndUseSlaTimeInAvailability;
  }

  public void setFrontEndUseSlaTimeInAvailability(Boolean frontEndUseSlaTimeInAvailability) {
    this.frontEndUseSlaTimeInAvailability = frontEndUseSlaTimeInAvailability;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BlobServiceWritableSettings blobServiceWritableSettings = (BlobServiceWritableSettings) o;
    return Objects.equals(this.blobSvcContainerGcInterval, blobServiceWritableSettings.blobSvcContainerGcInterval) &&
        Objects.equals(this.blobSvcShallowGcInterval, blobServiceWritableSettings.blobSvcShallowGcInterval) &&
        Objects.equals(this.blobSvcStreamMapMinContainerOccupancyPercent, blobServiceWritableSettings.blobSvcStreamMapMinContainerOccupancyPercent) &&
        Objects.equals(this.frontEndHttpListenPort, blobServiceWritableSettings.frontEndHttpListenPort) &&
        Objects.equals(this.frontEndHttpsListenPort, blobServiceWritableSettings.frontEndHttpsListenPort) &&
        Objects.equals(this.frontEndCallbackThreadsCount, blobServiceWritableSettings.frontEndCallbackThreadsCount) &&
        Objects.equals(this.frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds, blobServiceWritableSettings.frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds) &&
        Objects.equals(this.frontEndCpuBasedKeepAliveThrottlingEnabled, blobServiceWritableSettings.frontEndCpuBasedKeepAliveThrottlingEnabled) &&
        Objects.equals(this.frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold, blobServiceWritableSettings.frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold) &&
        Objects.equals(this.frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle, blobServiceWritableSettings.frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle) &&
        Objects.equals(this.frontEndMaxMillisecondsBetweenMemorySamples, blobServiceWritableSettings.frontEndMaxMillisecondsBetweenMemorySamples) &&
        Objects.equals(this.frontEndMemoryThrottleThresholdSettings, blobServiceWritableSettings.frontEndMemoryThrottleThresholdSettings) &&
        Objects.equals(this.frontEndMemoryThrottlingEnabled, blobServiceWritableSettings.frontEndMemoryThrottlingEnabled) &&
        Objects.equals(this.frontEndMinThreadPoolThreads, blobServiceWritableSettings.frontEndMinThreadPoolThreads) &&
        Objects.equals(this.frontEndThreadPoolBasedKeepAliveIOCompletionThreshold, blobServiceWritableSettings.frontEndThreadPoolBasedKeepAliveIOCompletionThreshold) &&
        Objects.equals(this.frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds, blobServiceWritableSettings.frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds) &&
        Objects.equals(this.frontEndThreadPoolBasedKeepAlivePercentage, blobServiceWritableSettings.frontEndThreadPoolBasedKeepAlivePercentage) &&
        Objects.equals(this.frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold, blobServiceWritableSettings.frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold) &&
        Objects.equals(this.frontEndUseSlaTimeInAvailability, blobServiceWritableSettings.frontEndUseSlaTimeInAvailability);
  }

  @Override
  public int hashCode() {
    return Objects.hash(blobSvcContainerGcInterval, blobSvcShallowGcInterval, blobSvcStreamMapMinContainerOccupancyPercent, frontEndHttpListenPort, frontEndHttpsListenPort, frontEndCallbackThreadsCount, frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds, frontEndCpuBasedKeepAliveThrottlingEnabled, frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold, frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle, frontEndMaxMillisecondsBetweenMemorySamples, frontEndMemoryThrottleThresholdSettings, frontEndMemoryThrottlingEnabled, frontEndMinThreadPoolThreads, frontEndThreadPoolBasedKeepAliveIOCompletionThreshold, frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds, frontEndThreadPoolBasedKeepAlivePercentage, frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold, frontEndUseSlaTimeInAvailability);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BlobServiceWritableSettings {\n");
    sb.append("    blobSvcContainerGcInterval: ").append(toIndentedString(blobSvcContainerGcInterval)).append("\n");
    sb.append("    blobSvcShallowGcInterval: ").append(toIndentedString(blobSvcShallowGcInterval)).append("\n");
    sb.append("    blobSvcStreamMapMinContainerOccupancyPercent: ").append(toIndentedString(blobSvcStreamMapMinContainerOccupancyPercent)).append("\n");
    sb.append("    frontEndHttpListenPort: ").append(toIndentedString(frontEndHttpListenPort)).append("\n");
    sb.append("    frontEndHttpsListenPort: ").append(toIndentedString(frontEndHttpsListenPort)).append("\n");
    sb.append("    frontEndCallbackThreadsCount: ").append(toIndentedString(frontEndCallbackThreadsCount)).append("\n");
    sb.append("    frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds: ").append(toIndentedString(frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds)).append("\n");
    sb.append("    frontEndCpuBasedKeepAliveThrottlingEnabled: ").append(toIndentedString(frontEndCpuBasedKeepAliveThrottlingEnabled)).append("\n");
    sb.append("    frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold: ").append(toIndentedString(frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold)).append("\n");
    sb.append("    frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle: ").append(toIndentedString(frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle)).append("\n");
    sb.append("    frontEndMaxMillisecondsBetweenMemorySamples: ").append(toIndentedString(frontEndMaxMillisecondsBetweenMemorySamples)).append("\n");
    sb.append("    frontEndMemoryThrottleThresholdSettings: ").append(toIndentedString(frontEndMemoryThrottleThresholdSettings)).append("\n");
    sb.append("    frontEndMemoryThrottlingEnabled: ").append(toIndentedString(frontEndMemoryThrottlingEnabled)).append("\n");
    sb.append("    frontEndMinThreadPoolThreads: ").append(toIndentedString(frontEndMinThreadPoolThreads)).append("\n");
    sb.append("    frontEndThreadPoolBasedKeepAliveIOCompletionThreshold: ").append(toIndentedString(frontEndThreadPoolBasedKeepAliveIOCompletionThreshold)).append("\n");
    sb.append("    frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds: ").append(toIndentedString(frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds)).append("\n");
    sb.append("    frontEndThreadPoolBasedKeepAlivePercentage: ").append(toIndentedString(frontEndThreadPoolBasedKeepAlivePercentage)).append("\n");
    sb.append("    frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold: ").append(toIndentedString(frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold)).append("\n");
    sb.append("    frontEndUseSlaTimeInAvailability: ").append(toIndentedString(frontEndUseSlaTimeInAvailability)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("frontEndHttpListenPort");
    openapiFields.add("frontEndHttpsListenPort");
    openapiFields.add("frontEndCallbackThreadsCount");
    openapiFields.add("frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds");
    openapiFields.add("frontEndCpuBasedKeepAliveThrottlingEnabled");
    openapiFields.add("frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold");
    openapiFields.add("frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle");
    openapiFields.add("frontEndMaxMillisecondsBetweenMemorySamples");
    openapiFields.add("frontEndMemoryThrottleThresholdSettings");
    openapiFields.add("frontEndMemoryThrottlingEnabled");
    openapiFields.add("frontEndMinThreadPoolThreads");
    openapiFields.add("frontEndThreadPoolBasedKeepAliveIOCompletionThreshold");
    openapiFields.add("frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds");
    openapiFields.add("frontEndThreadPoolBasedKeepAlivePercentage");
    openapiFields.add("frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold");
    openapiFields.add("frontEndUseSlaTimeInAvailability");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BlobServiceWritableSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BlobServiceWritableSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BlobServiceWritableSettings is not found in the empty JSON string", BlobServiceWritableSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BlobServiceWritableSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BlobServiceWritableSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("frontEndMemoryThrottleThresholdSettings") != null && !jsonObj.get("frontEndMemoryThrottleThresholdSettings").isJsonNull()) && !jsonObj.get("frontEndMemoryThrottleThresholdSettings").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `frontEndMemoryThrottleThresholdSettings` to be a primitive type in the JSON string but got `%s`", jsonObj.get("frontEndMemoryThrottleThresholdSettings").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BlobServiceWritableSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BlobServiceWritableSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BlobServiceWritableSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BlobServiceWritableSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<BlobServiceWritableSettings>() {
           @Override
           public void write(JsonWriter out, BlobServiceWritableSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BlobServiceWritableSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BlobServiceWritableSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BlobServiceWritableSettings
   * @throws IOException if the JSON string is invalid with respect to BlobServiceWritableSettings
   */
  public static BlobServiceWritableSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BlobServiceWritableSettings.class);
  }

  /**
   * Convert an instance of BlobServiceWritableSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

