/**
 * StorageManagementClient
 * The Admin Storage Management Client.
 *
 * The version of the OpenAPI document: 2015-12-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAIBlobServiceSettings.h
 *
 * Blob service settings.
 */

#ifndef OAIBlobServiceSettings_H
#define OAIBlobServiceSettings_H

#include <QJsonObject>

#include <QString>

#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {

class OAIBlobServiceSettings : public OAIObject {
public:
    OAIBlobServiceSettings();
    OAIBlobServiceSettings(QString json);
    ~OAIBlobServiceSettings() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    qint32 getBlobSvcContainerGcInterval() const;
    void setBlobSvcContainerGcInterval(const qint32 &blob_svc_container_gc_interval);
    bool is_blob_svc_container_gc_interval_Set() const;
    bool is_blob_svc_container_gc_interval_Valid() const;

    qint32 getBlobSvcShallowGcInterval() const;
    void setBlobSvcShallowGcInterval(const qint32 &blob_svc_shallow_gc_interval);
    bool is_blob_svc_shallow_gc_interval_Set() const;
    bool is_blob_svc_shallow_gc_interval_Valid() const;

    qint32 getBlobSvcStreamMapMinContainerOccupancyPercent() const;
    void setBlobSvcStreamMapMinContainerOccupancyPercent(const qint32 &blob_svc_stream_map_min_container_occupancy_percent);
    bool is_blob_svc_stream_map_min_container_occupancy_percent_Set() const;
    bool is_blob_svc_stream_map_min_container_occupancy_percent_Valid() const;

    qint32 getFrontEndHttpListenPort() const;
    void setFrontEndHttpListenPort(const qint32 &front_end_http_listen_port);
    bool is_front_end_http_listen_port_Set() const;
    bool is_front_end_http_listen_port_Valid() const;

    qint32 getFrontEndHttpsListenPort() const;
    void setFrontEndHttpsListenPort(const qint32 &front_end_https_listen_port);
    bool is_front_end_https_listen_port_Set() const;
    bool is_front_end_https_listen_port_Valid() const;

    qint32 getFrontEndCallbackThreadsCount() const;
    void setFrontEndCallbackThreadsCount(const qint32 &front_end_callback_threads_count);
    bool is_front_end_callback_threads_count_Set() const;
    bool is_front_end_callback_threads_count_Valid() const;

    qint32 getFrontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds() const;
    void setFrontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds(const qint32 &front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds);
    bool is_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_Set() const;
    bool is_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_Valid() const;

    bool isFrontEndCpuBasedKeepAliveThrottlingEnabled() const;
    void setFrontEndCpuBasedKeepAliveThrottlingEnabled(const bool &front_end_cpu_based_keep_alive_throttling_enabled);
    bool is_front_end_cpu_based_keep_alive_throttling_enabled_Set() const;
    bool is_front_end_cpu_based_keep_alive_throttling_enabled_Valid() const;

    float getFrontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold() const;
    void setFrontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold(const float &front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold);
    bool is_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_Set() const;
    bool is_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_Valid() const;

    float getFrontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle() const;
    void setFrontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle(const float &front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle);
    bool is_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_Set() const;
    bool is_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_Valid() const;

    qint32 getFrontEndMaxMillisecondsBetweenMemorySamples() const;
    void setFrontEndMaxMillisecondsBetweenMemorySamples(const qint32 &front_end_max_milliseconds_between_memory_samples);
    bool is_front_end_max_milliseconds_between_memory_samples_Set() const;
    bool is_front_end_max_milliseconds_between_memory_samples_Valid() const;

    QString getFrontEndMemoryThrottleThresholdSettings() const;
    void setFrontEndMemoryThrottleThresholdSettings(const QString &front_end_memory_throttle_threshold_settings);
    bool is_front_end_memory_throttle_threshold_settings_Set() const;
    bool is_front_end_memory_throttle_threshold_settings_Valid() const;

    bool isFrontEndMemoryThrottlingEnabled() const;
    void setFrontEndMemoryThrottlingEnabled(const bool &front_end_memory_throttling_enabled);
    bool is_front_end_memory_throttling_enabled_Set() const;
    bool is_front_end_memory_throttling_enabled_Valid() const;

    qint32 getFrontEndMinThreadPoolThreads() const;
    void setFrontEndMinThreadPoolThreads(const qint32 &front_end_min_thread_pool_threads);
    bool is_front_end_min_thread_pool_threads_Set() const;
    bool is_front_end_min_thread_pool_threads_Valid() const;

    qint32 getFrontEndThreadPoolBasedKeepAliveIoCompletionThreshold() const;
    void setFrontEndThreadPoolBasedKeepAliveIoCompletionThreshold(const qint32 &front_end_thread_pool_based_keep_alive_io_completion_threshold);
    bool is_front_end_thread_pool_based_keep_alive_io_completion_threshold_Set() const;
    bool is_front_end_thread_pool_based_keep_alive_io_completion_threshold_Valid() const;

    qint32 getFrontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds() const;
    void setFrontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds(const qint32 &front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds);
    bool is_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_Set() const;
    bool is_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_Valid() const;

    float getFrontEndThreadPoolBasedKeepAlivePercentage() const;
    void setFrontEndThreadPoolBasedKeepAlivePercentage(const float &front_end_thread_pool_based_keep_alive_percentage);
    bool is_front_end_thread_pool_based_keep_alive_percentage_Set() const;
    bool is_front_end_thread_pool_based_keep_alive_percentage_Valid() const;

    qint32 getFrontEndThreadPoolBasedKeepAliveWorkerThreadThreshold() const;
    void setFrontEndThreadPoolBasedKeepAliveWorkerThreadThreshold(const qint32 &front_end_thread_pool_based_keep_alive_worker_thread_threshold);
    bool is_front_end_thread_pool_based_keep_alive_worker_thread_threshold_Set() const;
    bool is_front_end_thread_pool_based_keep_alive_worker_thread_threshold_Valid() const;

    bool isFrontEndUseSlaTimeInAvailability() const;
    void setFrontEndUseSlaTimeInAvailability(const bool &front_end_use_sla_time_in_availability);
    bool is_front_end_use_sla_time_in_availability_Set() const;
    bool is_front_end_use_sla_time_in_availability_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    qint32 m_blob_svc_container_gc_interval;
    bool m_blob_svc_container_gc_interval_isSet;
    bool m_blob_svc_container_gc_interval_isValid;

    qint32 m_blob_svc_shallow_gc_interval;
    bool m_blob_svc_shallow_gc_interval_isSet;
    bool m_blob_svc_shallow_gc_interval_isValid;

    qint32 m_blob_svc_stream_map_min_container_occupancy_percent;
    bool m_blob_svc_stream_map_min_container_occupancy_percent_isSet;
    bool m_blob_svc_stream_map_min_container_occupancy_percent_isValid;

    qint32 m_front_end_http_listen_port;
    bool m_front_end_http_listen_port_isSet;
    bool m_front_end_http_listen_port_isValid;

    qint32 m_front_end_https_listen_port;
    bool m_front_end_https_listen_port_isSet;
    bool m_front_end_https_listen_port_isValid;

    qint32 m_front_end_callback_threads_count;
    bool m_front_end_callback_threads_count_isSet;
    bool m_front_end_callback_threads_count_isValid;

    qint32 m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds;
    bool m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isSet;
    bool m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isValid;

    bool m_front_end_cpu_based_keep_alive_throttling_enabled;
    bool m_front_end_cpu_based_keep_alive_throttling_enabled_isSet;
    bool m_front_end_cpu_based_keep_alive_throttling_enabled_isValid;

    float m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold;
    bool m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isSet;
    bool m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isValid;

    float m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle;
    bool m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isSet;
    bool m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isValid;

    qint32 m_front_end_max_milliseconds_between_memory_samples;
    bool m_front_end_max_milliseconds_between_memory_samples_isSet;
    bool m_front_end_max_milliseconds_between_memory_samples_isValid;

    QString m_front_end_memory_throttle_threshold_settings;
    bool m_front_end_memory_throttle_threshold_settings_isSet;
    bool m_front_end_memory_throttle_threshold_settings_isValid;

    bool m_front_end_memory_throttling_enabled;
    bool m_front_end_memory_throttling_enabled_isSet;
    bool m_front_end_memory_throttling_enabled_isValid;

    qint32 m_front_end_min_thread_pool_threads;
    bool m_front_end_min_thread_pool_threads_isSet;
    bool m_front_end_min_thread_pool_threads_isValid;

    qint32 m_front_end_thread_pool_based_keep_alive_io_completion_threshold;
    bool m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isSet;
    bool m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isValid;

    qint32 m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds;
    bool m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isSet;
    bool m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isValid;

    float m_front_end_thread_pool_based_keep_alive_percentage;
    bool m_front_end_thread_pool_based_keep_alive_percentage_isSet;
    bool m_front_end_thread_pool_based_keep_alive_percentage_isValid;

    qint32 m_front_end_thread_pool_based_keep_alive_worker_thread_threshold;
    bool m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isSet;
    bool m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isValid;

    bool m_front_end_use_sla_time_in_availability;
    bool m_front_end_use_sla_time_in_availability_isSet;
    bool m_front_end_use_sla_time_in_availability_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAIBlobServiceSettings)

#endif // OAIBlobServiceSettings_H
