/**
 * StorageManagementClient
 * The Admin Storage Management Client.
 *
 * The version of the OpenAPI document: 2015-12-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIBlobServiceWritableSettings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIBlobServiceWritableSettings::OAIBlobServiceWritableSettings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIBlobServiceWritableSettings::OAIBlobServiceWritableSettings() {
    this->initializeModel();
}

OAIBlobServiceWritableSettings::~OAIBlobServiceWritableSettings() {}

void OAIBlobServiceWritableSettings::initializeModel() {

    m_blob_svc_container_gc_interval_isSet = false;
    m_blob_svc_container_gc_interval_isValid = false;

    m_blob_svc_shallow_gc_interval_isSet = false;
    m_blob_svc_shallow_gc_interval_isValid = false;

    m_blob_svc_stream_map_min_container_occupancy_percent_isSet = false;
    m_blob_svc_stream_map_min_container_occupancy_percent_isValid = false;

    m_front_end_http_listen_port_isSet = false;
    m_front_end_http_listen_port_isValid = false;

    m_front_end_https_listen_port_isSet = false;
    m_front_end_https_listen_port_isValid = false;

    m_front_end_callback_threads_count_isSet = false;
    m_front_end_callback_threads_count_isValid = false;

    m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isSet = false;
    m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isValid = false;

    m_front_end_cpu_based_keep_alive_throttling_enabled_isSet = false;
    m_front_end_cpu_based_keep_alive_throttling_enabled_isValid = false;

    m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isSet = false;
    m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isValid = false;

    m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isSet = false;
    m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isValid = false;

    m_front_end_max_milliseconds_between_memory_samples_isSet = false;
    m_front_end_max_milliseconds_between_memory_samples_isValid = false;

    m_front_end_memory_throttle_threshold_settings_isSet = false;
    m_front_end_memory_throttle_threshold_settings_isValid = false;

    m_front_end_memory_throttling_enabled_isSet = false;
    m_front_end_memory_throttling_enabled_isValid = false;

    m_front_end_min_thread_pool_threads_isSet = false;
    m_front_end_min_thread_pool_threads_isValid = false;

    m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isSet = false;
    m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isValid = false;

    m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isSet = false;
    m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isValid = false;

    m_front_end_thread_pool_based_keep_alive_percentage_isSet = false;
    m_front_end_thread_pool_based_keep_alive_percentage_isValid = false;

    m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isSet = false;
    m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isValid = false;

    m_front_end_use_sla_time_in_availability_isSet = false;
    m_front_end_use_sla_time_in_availability_isValid = false;
}

void OAIBlobServiceWritableSettings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIBlobServiceWritableSettings::fromJsonObject(QJsonObject json) {

    m_blob_svc_container_gc_interval_isValid = ::OpenAPI::fromJsonValue(m_blob_svc_container_gc_interval, json[QString("blobSvcContainerGcInterval")]);
    m_blob_svc_container_gc_interval_isSet = !json[QString("blobSvcContainerGcInterval")].isNull() && m_blob_svc_container_gc_interval_isValid;

    m_blob_svc_shallow_gc_interval_isValid = ::OpenAPI::fromJsonValue(m_blob_svc_shallow_gc_interval, json[QString("blobSvcShallowGcInterval")]);
    m_blob_svc_shallow_gc_interval_isSet = !json[QString("blobSvcShallowGcInterval")].isNull() && m_blob_svc_shallow_gc_interval_isValid;

    m_blob_svc_stream_map_min_container_occupancy_percent_isValid = ::OpenAPI::fromJsonValue(m_blob_svc_stream_map_min_container_occupancy_percent, json[QString("blobSvcStreamMapMinContainerOccupancyPercent")]);
    m_blob_svc_stream_map_min_container_occupancy_percent_isSet = !json[QString("blobSvcStreamMapMinContainerOccupancyPercent")].isNull() && m_blob_svc_stream_map_min_container_occupancy_percent_isValid;

    m_front_end_http_listen_port_isValid = ::OpenAPI::fromJsonValue(m_front_end_http_listen_port, json[QString("frontEndHttpListenPort")]);
    m_front_end_http_listen_port_isSet = !json[QString("frontEndHttpListenPort")].isNull() && m_front_end_http_listen_port_isValid;

    m_front_end_https_listen_port_isValid = ::OpenAPI::fromJsonValue(m_front_end_https_listen_port, json[QString("frontEndHttpsListenPort")]);
    m_front_end_https_listen_port_isSet = !json[QString("frontEndHttpsListenPort")].isNull() && m_front_end_https_listen_port_isValid;

    m_front_end_callback_threads_count_isValid = ::OpenAPI::fromJsonValue(m_front_end_callback_threads_count, json[QString("frontEndCallbackThreadsCount")]);
    m_front_end_callback_threads_count_isSet = !json[QString("frontEndCallbackThreadsCount")].isNull() && m_front_end_callback_threads_count_isValid;

    m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds, json[QString("frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds")]);
    m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isSet = !json[QString("frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds")].isNull() && m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isValid;

    m_front_end_cpu_based_keep_alive_throttling_enabled_isValid = ::OpenAPI::fromJsonValue(m_front_end_cpu_based_keep_alive_throttling_enabled, json[QString("frontEndCpuBasedKeepAliveThrottlingEnabled")]);
    m_front_end_cpu_based_keep_alive_throttling_enabled_isSet = !json[QString("frontEndCpuBasedKeepAliveThrottlingEnabled")].isNull() && m_front_end_cpu_based_keep_alive_throttling_enabled_isValid;

    m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isValid = ::OpenAPI::fromJsonValue(m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold, json[QString("frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold")]);
    m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isSet = !json[QString("frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold")].isNull() && m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isValid;

    m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isValid = ::OpenAPI::fromJsonValue(m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle, json[QString("frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle")]);
    m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isSet = !json[QString("frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle")].isNull() && m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isValid;

    m_front_end_max_milliseconds_between_memory_samples_isValid = ::OpenAPI::fromJsonValue(m_front_end_max_milliseconds_between_memory_samples, json[QString("frontEndMaxMillisecondsBetweenMemorySamples")]);
    m_front_end_max_milliseconds_between_memory_samples_isSet = !json[QString("frontEndMaxMillisecondsBetweenMemorySamples")].isNull() && m_front_end_max_milliseconds_between_memory_samples_isValid;

    m_front_end_memory_throttle_threshold_settings_isValid = ::OpenAPI::fromJsonValue(m_front_end_memory_throttle_threshold_settings, json[QString("frontEndMemoryThrottleThresholdSettings")]);
    m_front_end_memory_throttle_threshold_settings_isSet = !json[QString("frontEndMemoryThrottleThresholdSettings")].isNull() && m_front_end_memory_throttle_threshold_settings_isValid;

    m_front_end_memory_throttling_enabled_isValid = ::OpenAPI::fromJsonValue(m_front_end_memory_throttling_enabled, json[QString("frontEndMemoryThrottlingEnabled")]);
    m_front_end_memory_throttling_enabled_isSet = !json[QString("frontEndMemoryThrottlingEnabled")].isNull() && m_front_end_memory_throttling_enabled_isValid;

    m_front_end_min_thread_pool_threads_isValid = ::OpenAPI::fromJsonValue(m_front_end_min_thread_pool_threads, json[QString("frontEndMinThreadPoolThreads")]);
    m_front_end_min_thread_pool_threads_isSet = !json[QString("frontEndMinThreadPoolThreads")].isNull() && m_front_end_min_thread_pool_threads_isValid;

    m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isValid = ::OpenAPI::fromJsonValue(m_front_end_thread_pool_based_keep_alive_io_completion_threshold, json[QString("frontEndThreadPoolBasedKeepAliveIOCompletionThreshold")]);
    m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isSet = !json[QString("frontEndThreadPoolBasedKeepAliveIOCompletionThreshold")].isNull() && m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isValid;

    m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds, json[QString("frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds")]);
    m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isSet = !json[QString("frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds")].isNull() && m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isValid;

    m_front_end_thread_pool_based_keep_alive_percentage_isValid = ::OpenAPI::fromJsonValue(m_front_end_thread_pool_based_keep_alive_percentage, json[QString("frontEndThreadPoolBasedKeepAlivePercentage")]);
    m_front_end_thread_pool_based_keep_alive_percentage_isSet = !json[QString("frontEndThreadPoolBasedKeepAlivePercentage")].isNull() && m_front_end_thread_pool_based_keep_alive_percentage_isValid;

    m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isValid = ::OpenAPI::fromJsonValue(m_front_end_thread_pool_based_keep_alive_worker_thread_threshold, json[QString("frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold")]);
    m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isSet = !json[QString("frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold")].isNull() && m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isValid;

    m_front_end_use_sla_time_in_availability_isValid = ::OpenAPI::fromJsonValue(m_front_end_use_sla_time_in_availability, json[QString("frontEndUseSlaTimeInAvailability")]);
    m_front_end_use_sla_time_in_availability_isSet = !json[QString("frontEndUseSlaTimeInAvailability")].isNull() && m_front_end_use_sla_time_in_availability_isValid;
}

QString OAIBlobServiceWritableSettings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIBlobServiceWritableSettings::asJsonObject() const {
    QJsonObject obj;
    if (m_blob_svc_container_gc_interval_isSet) {
        obj.insert(QString("blobSvcContainerGcInterval"), ::OpenAPI::toJsonValue(m_blob_svc_container_gc_interval));
    }
    if (m_blob_svc_shallow_gc_interval_isSet) {
        obj.insert(QString("blobSvcShallowGcInterval"), ::OpenAPI::toJsonValue(m_blob_svc_shallow_gc_interval));
    }
    if (m_blob_svc_stream_map_min_container_occupancy_percent_isSet) {
        obj.insert(QString("blobSvcStreamMapMinContainerOccupancyPercent"), ::OpenAPI::toJsonValue(m_blob_svc_stream_map_min_container_occupancy_percent));
    }
    if (m_front_end_http_listen_port_isSet) {
        obj.insert(QString("frontEndHttpListenPort"), ::OpenAPI::toJsonValue(m_front_end_http_listen_port));
    }
    if (m_front_end_https_listen_port_isSet) {
        obj.insert(QString("frontEndHttpsListenPort"), ::OpenAPI::toJsonValue(m_front_end_https_listen_port));
    }
    if (m_front_end_callback_threads_count_isSet) {
        obj.insert(QString("frontEndCallbackThreadsCount"), ::OpenAPI::toJsonValue(m_front_end_callback_threads_count));
    }
    if (m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isSet) {
        obj.insert(QString("frontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds"), ::OpenAPI::toJsonValue(m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds));
    }
    if (m_front_end_cpu_based_keep_alive_throttling_enabled_isSet) {
        obj.insert(QString("frontEndCpuBasedKeepAliveThrottlingEnabled"), ::OpenAPI::toJsonValue(m_front_end_cpu_based_keep_alive_throttling_enabled));
    }
    if (m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isSet) {
        obj.insert(QString("frontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold"), ::OpenAPI::toJsonValue(m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold));
    }
    if (m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isSet) {
        obj.insert(QString("frontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle"), ::OpenAPI::toJsonValue(m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle));
    }
    if (m_front_end_max_milliseconds_between_memory_samples_isSet) {
        obj.insert(QString("frontEndMaxMillisecondsBetweenMemorySamples"), ::OpenAPI::toJsonValue(m_front_end_max_milliseconds_between_memory_samples));
    }
    if (m_front_end_memory_throttle_threshold_settings_isSet) {
        obj.insert(QString("frontEndMemoryThrottleThresholdSettings"), ::OpenAPI::toJsonValue(m_front_end_memory_throttle_threshold_settings));
    }
    if (m_front_end_memory_throttling_enabled_isSet) {
        obj.insert(QString("frontEndMemoryThrottlingEnabled"), ::OpenAPI::toJsonValue(m_front_end_memory_throttling_enabled));
    }
    if (m_front_end_min_thread_pool_threads_isSet) {
        obj.insert(QString("frontEndMinThreadPoolThreads"), ::OpenAPI::toJsonValue(m_front_end_min_thread_pool_threads));
    }
    if (m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isSet) {
        obj.insert(QString("frontEndThreadPoolBasedKeepAliveIOCompletionThreshold"), ::OpenAPI::toJsonValue(m_front_end_thread_pool_based_keep_alive_io_completion_threshold));
    }
    if (m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isSet) {
        obj.insert(QString("frontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds"), ::OpenAPI::toJsonValue(m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds));
    }
    if (m_front_end_thread_pool_based_keep_alive_percentage_isSet) {
        obj.insert(QString("frontEndThreadPoolBasedKeepAlivePercentage"), ::OpenAPI::toJsonValue(m_front_end_thread_pool_based_keep_alive_percentage));
    }
    if (m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isSet) {
        obj.insert(QString("frontEndThreadPoolBasedKeepAliveWorkerThreadThreshold"), ::OpenAPI::toJsonValue(m_front_end_thread_pool_based_keep_alive_worker_thread_threshold));
    }
    if (m_front_end_use_sla_time_in_availability_isSet) {
        obj.insert(QString("frontEndUseSlaTimeInAvailability"), ::OpenAPI::toJsonValue(m_front_end_use_sla_time_in_availability));
    }
    return obj;
}

qint32 OAIBlobServiceWritableSettings::getBlobSvcContainerGcInterval() const {
    return m_blob_svc_container_gc_interval;
}
void OAIBlobServiceWritableSettings::setBlobSvcContainerGcInterval(const qint32 &blob_svc_container_gc_interval) {
    m_blob_svc_container_gc_interval = blob_svc_container_gc_interval;
    m_blob_svc_container_gc_interval_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_blob_svc_container_gc_interval_Set() const{
    return m_blob_svc_container_gc_interval_isSet;
}

bool OAIBlobServiceWritableSettings::is_blob_svc_container_gc_interval_Valid() const{
    return m_blob_svc_container_gc_interval_isValid;
}

qint32 OAIBlobServiceWritableSettings::getBlobSvcShallowGcInterval() const {
    return m_blob_svc_shallow_gc_interval;
}
void OAIBlobServiceWritableSettings::setBlobSvcShallowGcInterval(const qint32 &blob_svc_shallow_gc_interval) {
    m_blob_svc_shallow_gc_interval = blob_svc_shallow_gc_interval;
    m_blob_svc_shallow_gc_interval_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_blob_svc_shallow_gc_interval_Set() const{
    return m_blob_svc_shallow_gc_interval_isSet;
}

bool OAIBlobServiceWritableSettings::is_blob_svc_shallow_gc_interval_Valid() const{
    return m_blob_svc_shallow_gc_interval_isValid;
}

qint32 OAIBlobServiceWritableSettings::getBlobSvcStreamMapMinContainerOccupancyPercent() const {
    return m_blob_svc_stream_map_min_container_occupancy_percent;
}
void OAIBlobServiceWritableSettings::setBlobSvcStreamMapMinContainerOccupancyPercent(const qint32 &blob_svc_stream_map_min_container_occupancy_percent) {
    m_blob_svc_stream_map_min_container_occupancy_percent = blob_svc_stream_map_min_container_occupancy_percent;
    m_blob_svc_stream_map_min_container_occupancy_percent_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_blob_svc_stream_map_min_container_occupancy_percent_Set() const{
    return m_blob_svc_stream_map_min_container_occupancy_percent_isSet;
}

bool OAIBlobServiceWritableSettings::is_blob_svc_stream_map_min_container_occupancy_percent_Valid() const{
    return m_blob_svc_stream_map_min_container_occupancy_percent_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndHttpListenPort() const {
    return m_front_end_http_listen_port;
}
void OAIBlobServiceWritableSettings::setFrontEndHttpListenPort(const qint32 &front_end_http_listen_port) {
    m_front_end_http_listen_port = front_end_http_listen_port;
    m_front_end_http_listen_port_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_http_listen_port_Set() const{
    return m_front_end_http_listen_port_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_http_listen_port_Valid() const{
    return m_front_end_http_listen_port_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndHttpsListenPort() const {
    return m_front_end_https_listen_port;
}
void OAIBlobServiceWritableSettings::setFrontEndHttpsListenPort(const qint32 &front_end_https_listen_port) {
    m_front_end_https_listen_port = front_end_https_listen_port;
    m_front_end_https_listen_port_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_https_listen_port_Set() const{
    return m_front_end_https_listen_port_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_https_listen_port_Valid() const{
    return m_front_end_https_listen_port_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndCallbackThreadsCount() const {
    return m_front_end_callback_threads_count;
}
void OAIBlobServiceWritableSettings::setFrontEndCallbackThreadsCount(const qint32 &front_end_callback_threads_count) {
    m_front_end_callback_threads_count = front_end_callback_threads_count;
    m_front_end_callback_threads_count_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_callback_threads_count_Set() const{
    return m_front_end_callback_threads_count_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_callback_threads_count_Valid() const{
    return m_front_end_callback_threads_count_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds() const {
    return m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds;
}
void OAIBlobServiceWritableSettings::setFrontEndCpuBasedKeepAliveThrottlingCpuMonitorIntervalInSeconds(const qint32 &front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds) {
    m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds = front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds;
    m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_Set() const{
    return m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_Valid() const{
    return m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isValid;
}

bool OAIBlobServiceWritableSettings::isFrontEndCpuBasedKeepAliveThrottlingEnabled() const {
    return m_front_end_cpu_based_keep_alive_throttling_enabled;
}
void OAIBlobServiceWritableSettings::setFrontEndCpuBasedKeepAliveThrottlingEnabled(const bool &front_end_cpu_based_keep_alive_throttling_enabled) {
    m_front_end_cpu_based_keep_alive_throttling_enabled = front_end_cpu_based_keep_alive_throttling_enabled;
    m_front_end_cpu_based_keep_alive_throttling_enabled_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_enabled_Set() const{
    return m_front_end_cpu_based_keep_alive_throttling_enabled_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_enabled_Valid() const{
    return m_front_end_cpu_based_keep_alive_throttling_enabled_isValid;
}

float OAIBlobServiceWritableSettings::getFrontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold() const {
    return m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold;
}
void OAIBlobServiceWritableSettings::setFrontEndCpuBasedKeepAliveThrottlingPercentCpuThreshold(const float &front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold) {
    m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold = front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold;
    m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_Set() const{
    return m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_Valid() const{
    return m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isValid;
}

float OAIBlobServiceWritableSettings::getFrontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle() const {
    return m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle;
}
void OAIBlobServiceWritableSettings::setFrontEndCpuBasedKeepAliveThrottlingPercentRequestsToThrottle(const float &front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle) {
    m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle = front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle;
    m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_Set() const{
    return m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_Valid() const{
    return m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndMaxMillisecondsBetweenMemorySamples() const {
    return m_front_end_max_milliseconds_between_memory_samples;
}
void OAIBlobServiceWritableSettings::setFrontEndMaxMillisecondsBetweenMemorySamples(const qint32 &front_end_max_milliseconds_between_memory_samples) {
    m_front_end_max_milliseconds_between_memory_samples = front_end_max_milliseconds_between_memory_samples;
    m_front_end_max_milliseconds_between_memory_samples_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_max_milliseconds_between_memory_samples_Set() const{
    return m_front_end_max_milliseconds_between_memory_samples_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_max_milliseconds_between_memory_samples_Valid() const{
    return m_front_end_max_milliseconds_between_memory_samples_isValid;
}

QString OAIBlobServiceWritableSettings::getFrontEndMemoryThrottleThresholdSettings() const {
    return m_front_end_memory_throttle_threshold_settings;
}
void OAIBlobServiceWritableSettings::setFrontEndMemoryThrottleThresholdSettings(const QString &front_end_memory_throttle_threshold_settings) {
    m_front_end_memory_throttle_threshold_settings = front_end_memory_throttle_threshold_settings;
    m_front_end_memory_throttle_threshold_settings_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_memory_throttle_threshold_settings_Set() const{
    return m_front_end_memory_throttle_threshold_settings_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_memory_throttle_threshold_settings_Valid() const{
    return m_front_end_memory_throttle_threshold_settings_isValid;
}

bool OAIBlobServiceWritableSettings::isFrontEndMemoryThrottlingEnabled() const {
    return m_front_end_memory_throttling_enabled;
}
void OAIBlobServiceWritableSettings::setFrontEndMemoryThrottlingEnabled(const bool &front_end_memory_throttling_enabled) {
    m_front_end_memory_throttling_enabled = front_end_memory_throttling_enabled;
    m_front_end_memory_throttling_enabled_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_memory_throttling_enabled_Set() const{
    return m_front_end_memory_throttling_enabled_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_memory_throttling_enabled_Valid() const{
    return m_front_end_memory_throttling_enabled_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndMinThreadPoolThreads() const {
    return m_front_end_min_thread_pool_threads;
}
void OAIBlobServiceWritableSettings::setFrontEndMinThreadPoolThreads(const qint32 &front_end_min_thread_pool_threads) {
    m_front_end_min_thread_pool_threads = front_end_min_thread_pool_threads;
    m_front_end_min_thread_pool_threads_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_min_thread_pool_threads_Set() const{
    return m_front_end_min_thread_pool_threads_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_min_thread_pool_threads_Valid() const{
    return m_front_end_min_thread_pool_threads_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndThreadPoolBasedKeepAliveIoCompletionThreshold() const {
    return m_front_end_thread_pool_based_keep_alive_io_completion_threshold;
}
void OAIBlobServiceWritableSettings::setFrontEndThreadPoolBasedKeepAliveIoCompletionThreshold(const qint32 &front_end_thread_pool_based_keep_alive_io_completion_threshold) {
    m_front_end_thread_pool_based_keep_alive_io_completion_threshold = front_end_thread_pool_based_keep_alive_io_completion_threshold;
    m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_io_completion_threshold_Set() const{
    return m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_io_completion_threshold_Valid() const{
    return m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds() const {
    return m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds;
}
void OAIBlobServiceWritableSettings::setFrontEndThreadPoolBasedKeepAliveMonitorIntervalInSeconds(const qint32 &front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds) {
    m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds = front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds;
    m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_Set() const{
    return m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_Valid() const{
    return m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isValid;
}

float OAIBlobServiceWritableSettings::getFrontEndThreadPoolBasedKeepAlivePercentage() const {
    return m_front_end_thread_pool_based_keep_alive_percentage;
}
void OAIBlobServiceWritableSettings::setFrontEndThreadPoolBasedKeepAlivePercentage(const float &front_end_thread_pool_based_keep_alive_percentage) {
    m_front_end_thread_pool_based_keep_alive_percentage = front_end_thread_pool_based_keep_alive_percentage;
    m_front_end_thread_pool_based_keep_alive_percentage_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_percentage_Set() const{
    return m_front_end_thread_pool_based_keep_alive_percentage_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_percentage_Valid() const{
    return m_front_end_thread_pool_based_keep_alive_percentage_isValid;
}

qint32 OAIBlobServiceWritableSettings::getFrontEndThreadPoolBasedKeepAliveWorkerThreadThreshold() const {
    return m_front_end_thread_pool_based_keep_alive_worker_thread_threshold;
}
void OAIBlobServiceWritableSettings::setFrontEndThreadPoolBasedKeepAliveWorkerThreadThreshold(const qint32 &front_end_thread_pool_based_keep_alive_worker_thread_threshold) {
    m_front_end_thread_pool_based_keep_alive_worker_thread_threshold = front_end_thread_pool_based_keep_alive_worker_thread_threshold;
    m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_worker_thread_threshold_Set() const{
    return m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_thread_pool_based_keep_alive_worker_thread_threshold_Valid() const{
    return m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isValid;
}

bool OAIBlobServiceWritableSettings::isFrontEndUseSlaTimeInAvailability() const {
    return m_front_end_use_sla_time_in_availability;
}
void OAIBlobServiceWritableSettings::setFrontEndUseSlaTimeInAvailability(const bool &front_end_use_sla_time_in_availability) {
    m_front_end_use_sla_time_in_availability = front_end_use_sla_time_in_availability;
    m_front_end_use_sla_time_in_availability_isSet = true;
}

bool OAIBlobServiceWritableSettings::is_front_end_use_sla_time_in_availability_Set() const{
    return m_front_end_use_sla_time_in_availability_isSet;
}

bool OAIBlobServiceWritableSettings::is_front_end_use_sla_time_in_availability_Valid() const{
    return m_front_end_use_sla_time_in_availability_isValid;
}

bool OAIBlobServiceWritableSettings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_blob_svc_container_gc_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_blob_svc_shallow_gc_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_blob_svc_stream_map_min_container_occupancy_percent_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_http_listen_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_https_listen_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_callback_threads_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_cpu_based_keep_alive_throttling_cpu_monitor_interval_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_cpu_based_keep_alive_throttling_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_cpu_based_keep_alive_throttling_percent_cpu_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_cpu_based_keep_alive_throttling_percent_requests_to_throttle_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_max_milliseconds_between_memory_samples_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_memory_throttle_threshold_settings_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_memory_throttling_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_min_thread_pool_threads_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_thread_pool_based_keep_alive_io_completion_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_thread_pool_based_keep_alive_monitor_interval_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_thread_pool_based_keep_alive_percentage_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_thread_pool_based_keep_alive_worker_thread_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_front_end_use_sla_time_in_availability_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIBlobServiceWritableSettings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
