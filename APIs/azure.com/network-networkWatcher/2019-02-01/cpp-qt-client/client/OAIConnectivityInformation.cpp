/**
 * NetworkManagementClient
 * The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.
 *
 * The version of the OpenAPI document: 2019-02-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIConnectivityInformation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIConnectivityInformation::OAIConnectivityInformation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIConnectivityInformation::OAIConnectivityInformation() {
    this->initializeModel();
}

OAIConnectivityInformation::~OAIConnectivityInformation() {}

void OAIConnectivityInformation::initializeModel() {

    m_avg_latency_in_ms_isSet = false;
    m_avg_latency_in_ms_isValid = false;

    m_connection_status_isSet = false;
    m_connection_status_isValid = false;

    m_hops_isSet = false;
    m_hops_isValid = false;

    m_max_latency_in_ms_isSet = false;
    m_max_latency_in_ms_isValid = false;

    m_min_latency_in_ms_isSet = false;
    m_min_latency_in_ms_isValid = false;

    m_probes_failed_isSet = false;
    m_probes_failed_isValid = false;

    m_probes_sent_isSet = false;
    m_probes_sent_isValid = false;
}

void OAIConnectivityInformation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIConnectivityInformation::fromJsonObject(QJsonObject json) {

    m_avg_latency_in_ms_isValid = ::OpenAPI::fromJsonValue(m_avg_latency_in_ms, json[QString("avgLatencyInMs")]);
    m_avg_latency_in_ms_isSet = !json[QString("avgLatencyInMs")].isNull() && m_avg_latency_in_ms_isValid;

    m_connection_status_isValid = ::OpenAPI::fromJsonValue(m_connection_status, json[QString("connectionStatus")]);
    m_connection_status_isSet = !json[QString("connectionStatus")].isNull() && m_connection_status_isValid;

    m_hops_isValid = ::OpenAPI::fromJsonValue(m_hops, json[QString("hops")]);
    m_hops_isSet = !json[QString("hops")].isNull() && m_hops_isValid;

    m_max_latency_in_ms_isValid = ::OpenAPI::fromJsonValue(m_max_latency_in_ms, json[QString("maxLatencyInMs")]);
    m_max_latency_in_ms_isSet = !json[QString("maxLatencyInMs")].isNull() && m_max_latency_in_ms_isValid;

    m_min_latency_in_ms_isValid = ::OpenAPI::fromJsonValue(m_min_latency_in_ms, json[QString("minLatencyInMs")]);
    m_min_latency_in_ms_isSet = !json[QString("minLatencyInMs")].isNull() && m_min_latency_in_ms_isValid;

    m_probes_failed_isValid = ::OpenAPI::fromJsonValue(m_probes_failed, json[QString("probesFailed")]);
    m_probes_failed_isSet = !json[QString("probesFailed")].isNull() && m_probes_failed_isValid;

    m_probes_sent_isValid = ::OpenAPI::fromJsonValue(m_probes_sent, json[QString("probesSent")]);
    m_probes_sent_isSet = !json[QString("probesSent")].isNull() && m_probes_sent_isValid;
}

QString OAIConnectivityInformation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIConnectivityInformation::asJsonObject() const {
    QJsonObject obj;
    if (m_avg_latency_in_ms_isSet) {
        obj.insert(QString("avgLatencyInMs"), ::OpenAPI::toJsonValue(m_avg_latency_in_ms));
    }
    if (m_connection_status_isSet) {
        obj.insert(QString("connectionStatus"), ::OpenAPI::toJsonValue(m_connection_status));
    }
    if (m_hops.size() > 0) {
        obj.insert(QString("hops"), ::OpenAPI::toJsonValue(m_hops));
    }
    if (m_max_latency_in_ms_isSet) {
        obj.insert(QString("maxLatencyInMs"), ::OpenAPI::toJsonValue(m_max_latency_in_ms));
    }
    if (m_min_latency_in_ms_isSet) {
        obj.insert(QString("minLatencyInMs"), ::OpenAPI::toJsonValue(m_min_latency_in_ms));
    }
    if (m_probes_failed_isSet) {
        obj.insert(QString("probesFailed"), ::OpenAPI::toJsonValue(m_probes_failed));
    }
    if (m_probes_sent_isSet) {
        obj.insert(QString("probesSent"), ::OpenAPI::toJsonValue(m_probes_sent));
    }
    return obj;
}

qint32 OAIConnectivityInformation::getAvgLatencyInMs() const {
    return m_avg_latency_in_ms;
}
void OAIConnectivityInformation::setAvgLatencyInMs(const qint32 &avg_latency_in_ms) {
    m_avg_latency_in_ms = avg_latency_in_ms;
    m_avg_latency_in_ms_isSet = true;
}

bool OAIConnectivityInformation::is_avg_latency_in_ms_Set() const{
    return m_avg_latency_in_ms_isSet;
}

bool OAIConnectivityInformation::is_avg_latency_in_ms_Valid() const{
    return m_avg_latency_in_ms_isValid;
}

QString OAIConnectivityInformation::getConnectionStatus() const {
    return m_connection_status;
}
void OAIConnectivityInformation::setConnectionStatus(const QString &connection_status) {
    m_connection_status = connection_status;
    m_connection_status_isSet = true;
}

bool OAIConnectivityInformation::is_connection_status_Set() const{
    return m_connection_status_isSet;
}

bool OAIConnectivityInformation::is_connection_status_Valid() const{
    return m_connection_status_isValid;
}

QList<OAIConnectivityHop> OAIConnectivityInformation::getHops() const {
    return m_hops;
}
void OAIConnectivityInformation::setHops(const QList<OAIConnectivityHop> &hops) {
    m_hops = hops;
    m_hops_isSet = true;
}

bool OAIConnectivityInformation::is_hops_Set() const{
    return m_hops_isSet;
}

bool OAIConnectivityInformation::is_hops_Valid() const{
    return m_hops_isValid;
}

qint32 OAIConnectivityInformation::getMaxLatencyInMs() const {
    return m_max_latency_in_ms;
}
void OAIConnectivityInformation::setMaxLatencyInMs(const qint32 &max_latency_in_ms) {
    m_max_latency_in_ms = max_latency_in_ms;
    m_max_latency_in_ms_isSet = true;
}

bool OAIConnectivityInformation::is_max_latency_in_ms_Set() const{
    return m_max_latency_in_ms_isSet;
}

bool OAIConnectivityInformation::is_max_latency_in_ms_Valid() const{
    return m_max_latency_in_ms_isValid;
}

qint32 OAIConnectivityInformation::getMinLatencyInMs() const {
    return m_min_latency_in_ms;
}
void OAIConnectivityInformation::setMinLatencyInMs(const qint32 &min_latency_in_ms) {
    m_min_latency_in_ms = min_latency_in_ms;
    m_min_latency_in_ms_isSet = true;
}

bool OAIConnectivityInformation::is_min_latency_in_ms_Set() const{
    return m_min_latency_in_ms_isSet;
}

bool OAIConnectivityInformation::is_min_latency_in_ms_Valid() const{
    return m_min_latency_in_ms_isValid;
}

qint32 OAIConnectivityInformation::getProbesFailed() const {
    return m_probes_failed;
}
void OAIConnectivityInformation::setProbesFailed(const qint32 &probes_failed) {
    m_probes_failed = probes_failed;
    m_probes_failed_isSet = true;
}

bool OAIConnectivityInformation::is_probes_failed_Set() const{
    return m_probes_failed_isSet;
}

bool OAIConnectivityInformation::is_probes_failed_Valid() const{
    return m_probes_failed_isValid;
}

qint32 OAIConnectivityInformation::getProbesSent() const {
    return m_probes_sent;
}
void OAIConnectivityInformation::setProbesSent(const qint32 &probes_sent) {
    m_probes_sent = probes_sent;
    m_probes_sent_isSet = true;
}

bool OAIConnectivityInformation::is_probes_sent_Set() const{
    return m_probes_sent_isSet;
}

bool OAIConnectivityInformation::is_probes_sent_Valid() const{
    return m_probes_sent_isValid;
}

bool OAIConnectivityInformation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_avg_latency_in_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_connection_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hops.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_latency_in_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_latency_in_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_probes_failed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_probes_sent_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIConnectivityInformation::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
