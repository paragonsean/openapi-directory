/**
 * NetworkManagementClient
 * The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.
 *
 * The version of the OpenAPI document: 2019-11-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIConnectionMonitorHttpConfiguration.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIConnectionMonitorHttpConfiguration::OAIConnectionMonitorHttpConfiguration(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIConnectionMonitorHttpConfiguration::OAIConnectionMonitorHttpConfiguration() {
    this->initializeModel();
}

OAIConnectionMonitorHttpConfiguration::~OAIConnectionMonitorHttpConfiguration() {}

void OAIConnectionMonitorHttpConfiguration::initializeModel() {

    m_method_isSet = false;
    m_method_isValid = false;

    m_path_isSet = false;
    m_path_isValid = false;

    m_port_isSet = false;
    m_port_isValid = false;

    m_prefer_https_isSet = false;
    m_prefer_https_isValid = false;

    m_request_headers_isSet = false;
    m_request_headers_isValid = false;

    m_valid_status_code_ranges_isSet = false;
    m_valid_status_code_ranges_isValid = false;
}

void OAIConnectionMonitorHttpConfiguration::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIConnectionMonitorHttpConfiguration::fromJsonObject(QJsonObject json) {

    m_method_isValid = ::OpenAPI::fromJsonValue(m_method, json[QString("method")]);
    m_method_isSet = !json[QString("method")].isNull() && m_method_isValid;

    m_path_isValid = ::OpenAPI::fromJsonValue(m_path, json[QString("path")]);
    m_path_isSet = !json[QString("path")].isNull() && m_path_isValid;

    m_port_isValid = ::OpenAPI::fromJsonValue(m_port, json[QString("port")]);
    m_port_isSet = !json[QString("port")].isNull() && m_port_isValid;

    m_prefer_https_isValid = ::OpenAPI::fromJsonValue(m_prefer_https, json[QString("preferHTTPS")]);
    m_prefer_https_isSet = !json[QString("preferHTTPS")].isNull() && m_prefer_https_isValid;

    m_request_headers_isValid = ::OpenAPI::fromJsonValue(m_request_headers, json[QString("requestHeaders")]);
    m_request_headers_isSet = !json[QString("requestHeaders")].isNull() && m_request_headers_isValid;

    m_valid_status_code_ranges_isValid = ::OpenAPI::fromJsonValue(m_valid_status_code_ranges, json[QString("validStatusCodeRanges")]);
    m_valid_status_code_ranges_isSet = !json[QString("validStatusCodeRanges")].isNull() && m_valid_status_code_ranges_isValid;
}

QString OAIConnectionMonitorHttpConfiguration::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIConnectionMonitorHttpConfiguration::asJsonObject() const {
    QJsonObject obj;
    if (m_method_isSet) {
        obj.insert(QString("method"), ::OpenAPI::toJsonValue(m_method));
    }
    if (m_path_isSet) {
        obj.insert(QString("path"), ::OpenAPI::toJsonValue(m_path));
    }
    if (m_port_isSet) {
        obj.insert(QString("port"), ::OpenAPI::toJsonValue(m_port));
    }
    if (m_prefer_https_isSet) {
        obj.insert(QString("preferHTTPS"), ::OpenAPI::toJsonValue(m_prefer_https));
    }
    if (m_request_headers.size() > 0) {
        obj.insert(QString("requestHeaders"), ::OpenAPI::toJsonValue(m_request_headers));
    }
    if (m_valid_status_code_ranges.size() > 0) {
        obj.insert(QString("validStatusCodeRanges"), ::OpenAPI::toJsonValue(m_valid_status_code_ranges));
    }
    return obj;
}

QString OAIConnectionMonitorHttpConfiguration::getMethod() const {
    return m_method;
}
void OAIConnectionMonitorHttpConfiguration::setMethod(const QString &method) {
    m_method = method;
    m_method_isSet = true;
}

bool OAIConnectionMonitorHttpConfiguration::is_method_Set() const{
    return m_method_isSet;
}

bool OAIConnectionMonitorHttpConfiguration::is_method_Valid() const{
    return m_method_isValid;
}

QString OAIConnectionMonitorHttpConfiguration::getPath() const {
    return m_path;
}
void OAIConnectionMonitorHttpConfiguration::setPath(const QString &path) {
    m_path = path;
    m_path_isSet = true;
}

bool OAIConnectionMonitorHttpConfiguration::is_path_Set() const{
    return m_path_isSet;
}

bool OAIConnectionMonitorHttpConfiguration::is_path_Valid() const{
    return m_path_isValid;
}

qint32 OAIConnectionMonitorHttpConfiguration::getPort() const {
    return m_port;
}
void OAIConnectionMonitorHttpConfiguration::setPort(const qint32 &port) {
    m_port = port;
    m_port_isSet = true;
}

bool OAIConnectionMonitorHttpConfiguration::is_port_Set() const{
    return m_port_isSet;
}

bool OAIConnectionMonitorHttpConfiguration::is_port_Valid() const{
    return m_port_isValid;
}

bool OAIConnectionMonitorHttpConfiguration::isPreferHttps() const {
    return m_prefer_https;
}
void OAIConnectionMonitorHttpConfiguration::setPreferHttps(const bool &prefer_https) {
    m_prefer_https = prefer_https;
    m_prefer_https_isSet = true;
}

bool OAIConnectionMonitorHttpConfiguration::is_prefer_https_Set() const{
    return m_prefer_https_isSet;
}

bool OAIConnectionMonitorHttpConfiguration::is_prefer_https_Valid() const{
    return m_prefer_https_isValid;
}

QList<OAIHTTPHeader> OAIConnectionMonitorHttpConfiguration::getRequestHeaders() const {
    return m_request_headers;
}
void OAIConnectionMonitorHttpConfiguration::setRequestHeaders(const QList<OAIHTTPHeader> &request_headers) {
    m_request_headers = request_headers;
    m_request_headers_isSet = true;
}

bool OAIConnectionMonitorHttpConfiguration::is_request_headers_Set() const{
    return m_request_headers_isSet;
}

bool OAIConnectionMonitorHttpConfiguration::is_request_headers_Valid() const{
    return m_request_headers_isValid;
}

QList<QString> OAIConnectionMonitorHttpConfiguration::getValidStatusCodeRanges() const {
    return m_valid_status_code_ranges;
}
void OAIConnectionMonitorHttpConfiguration::setValidStatusCodeRanges(const QList<QString> &valid_status_code_ranges) {
    m_valid_status_code_ranges = valid_status_code_ranges;
    m_valid_status_code_ranges_isSet = true;
}

bool OAIConnectionMonitorHttpConfiguration::is_valid_status_code_ranges_Set() const{
    return m_valid_status_code_ranges_isSet;
}

bool OAIConnectionMonitorHttpConfiguration::is_valid_status_code_ranges_Valid() const{
    return m_valid_status_code_ranges_isValid;
}

bool OAIConnectionMonitorHttpConfiguration::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_prefer_https_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_headers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_valid_status_code_ranges.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIConnectionMonitorHttpConfiguration::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
