/**
 * NetworkManagementClient
 * The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.
 *
 * The version of the OpenAPI document: 2018-04-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIConnectionMonitorParameters.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIConnectionMonitorParameters::OAIConnectionMonitorParameters(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIConnectionMonitorParameters::OAIConnectionMonitorParameters() {
    this->initializeModel();
}

OAIConnectionMonitorParameters::~OAIConnectionMonitorParameters() {}

void OAIConnectionMonitorParameters::initializeModel() {

    m_auto_start_isSet = false;
    m_auto_start_isValid = false;

    m_destination_isSet = false;
    m_destination_isValid = false;

    m_monitoring_interval_in_seconds_isSet = false;
    m_monitoring_interval_in_seconds_isValid = false;

    m_source_isSet = false;
    m_source_isValid = false;
}

void OAIConnectionMonitorParameters::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIConnectionMonitorParameters::fromJsonObject(QJsonObject json) {

    m_auto_start_isValid = ::OpenAPI::fromJsonValue(m_auto_start, json[QString("autoStart")]);
    m_auto_start_isSet = !json[QString("autoStart")].isNull() && m_auto_start_isValid;

    m_destination_isValid = ::OpenAPI::fromJsonValue(m_destination, json[QString("destination")]);
    m_destination_isSet = !json[QString("destination")].isNull() && m_destination_isValid;

    m_monitoring_interval_in_seconds_isValid = ::OpenAPI::fromJsonValue(m_monitoring_interval_in_seconds, json[QString("monitoringIntervalInSeconds")]);
    m_monitoring_interval_in_seconds_isSet = !json[QString("monitoringIntervalInSeconds")].isNull() && m_monitoring_interval_in_seconds_isValid;

    m_source_isValid = ::OpenAPI::fromJsonValue(m_source, json[QString("source")]);
    m_source_isSet = !json[QString("source")].isNull() && m_source_isValid;
}

QString OAIConnectionMonitorParameters::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIConnectionMonitorParameters::asJsonObject() const {
    QJsonObject obj;
    if (m_auto_start_isSet) {
        obj.insert(QString("autoStart"), ::OpenAPI::toJsonValue(m_auto_start));
    }
    if (m_destination.isSet()) {
        obj.insert(QString("destination"), ::OpenAPI::toJsonValue(m_destination));
    }
    if (m_monitoring_interval_in_seconds_isSet) {
        obj.insert(QString("monitoringIntervalInSeconds"), ::OpenAPI::toJsonValue(m_monitoring_interval_in_seconds));
    }
    if (m_source.isSet()) {
        obj.insert(QString("source"), ::OpenAPI::toJsonValue(m_source));
    }
    return obj;
}

bool OAIConnectionMonitorParameters::isAutoStart() const {
    return m_auto_start;
}
void OAIConnectionMonitorParameters::setAutoStart(const bool &auto_start) {
    m_auto_start = auto_start;
    m_auto_start_isSet = true;
}

bool OAIConnectionMonitorParameters::is_auto_start_Set() const{
    return m_auto_start_isSet;
}

bool OAIConnectionMonitorParameters::is_auto_start_Valid() const{
    return m_auto_start_isValid;
}

OAIConnectionMonitorDestination OAIConnectionMonitorParameters::getDestination() const {
    return m_destination;
}
void OAIConnectionMonitorParameters::setDestination(const OAIConnectionMonitorDestination &destination) {
    m_destination = destination;
    m_destination_isSet = true;
}

bool OAIConnectionMonitorParameters::is_destination_Set() const{
    return m_destination_isSet;
}

bool OAIConnectionMonitorParameters::is_destination_Valid() const{
    return m_destination_isValid;
}

qint32 OAIConnectionMonitorParameters::getMonitoringIntervalInSeconds() const {
    return m_monitoring_interval_in_seconds;
}
void OAIConnectionMonitorParameters::setMonitoringIntervalInSeconds(const qint32 &monitoring_interval_in_seconds) {
    m_monitoring_interval_in_seconds = monitoring_interval_in_seconds;
    m_monitoring_interval_in_seconds_isSet = true;
}

bool OAIConnectionMonitorParameters::is_monitoring_interval_in_seconds_Set() const{
    return m_monitoring_interval_in_seconds_isSet;
}

bool OAIConnectionMonitorParameters::is_monitoring_interval_in_seconds_Valid() const{
    return m_monitoring_interval_in_seconds_isValid;
}

OAIConnectionMonitorSource OAIConnectionMonitorParameters::getSource() const {
    return m_source;
}
void OAIConnectionMonitorParameters::setSource(const OAIConnectionMonitorSource &source) {
    m_source = source;
    m_source_isSet = true;
}

bool OAIConnectionMonitorParameters::is_source_Set() const{
    return m_source_isSet;
}

bool OAIConnectionMonitorParameters::is_source_Valid() const{
    return m_source_isValid;
}

bool OAIConnectionMonitorParameters::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_auto_start_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_destination.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_monitoring_interval_in_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_source.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIConnectionMonitorParameters::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_destination_isValid && m_source_isValid && true;
}

} // namespace OpenAPI
