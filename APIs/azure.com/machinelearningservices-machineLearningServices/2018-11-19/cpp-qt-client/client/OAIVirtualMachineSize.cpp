/**
 * Azure Machine Learning Workspaces
 * These APIs allow end users to operate on Azure Machine Learning Workspace resources.
 *
 * The version of the OpenAPI document: 2018-11-19
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVirtualMachineSize.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVirtualMachineSize::OAIVirtualMachineSize(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVirtualMachineSize::OAIVirtualMachineSize() {
    this->initializeModel();
}

OAIVirtualMachineSize::~OAIVirtualMachineSize() {}

void OAIVirtualMachineSize::initializeModel() {

    m_family_isSet = false;
    m_family_isValid = false;

    m_low_priority_capable_isSet = false;
    m_low_priority_capable_isValid = false;

    m_max_resource_volume_mb_isSet = false;
    m_max_resource_volume_mb_isValid = false;

    m_memory_gb_isSet = false;
    m_memory_gb_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_os_vhd_size_mb_isSet = false;
    m_os_vhd_size_mb_isValid = false;

    m_premium_io_isSet = false;
    m_premium_io_isValid = false;

    m_v_cpus_isSet = false;
    m_v_cpus_isValid = false;
}

void OAIVirtualMachineSize::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVirtualMachineSize::fromJsonObject(QJsonObject json) {

    m_family_isValid = ::OpenAPI::fromJsonValue(m_family, json[QString("family")]);
    m_family_isSet = !json[QString("family")].isNull() && m_family_isValid;

    m_low_priority_capable_isValid = ::OpenAPI::fromJsonValue(m_low_priority_capable, json[QString("lowPriorityCapable")]);
    m_low_priority_capable_isSet = !json[QString("lowPriorityCapable")].isNull() && m_low_priority_capable_isValid;

    m_max_resource_volume_mb_isValid = ::OpenAPI::fromJsonValue(m_max_resource_volume_mb, json[QString("maxResourceVolumeMB")]);
    m_max_resource_volume_mb_isSet = !json[QString("maxResourceVolumeMB")].isNull() && m_max_resource_volume_mb_isValid;

    m_memory_gb_isValid = ::OpenAPI::fromJsonValue(m_memory_gb, json[QString("memoryGB")]);
    m_memory_gb_isSet = !json[QString("memoryGB")].isNull() && m_memory_gb_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_os_vhd_size_mb_isValid = ::OpenAPI::fromJsonValue(m_os_vhd_size_mb, json[QString("osVhdSizeMB")]);
    m_os_vhd_size_mb_isSet = !json[QString("osVhdSizeMB")].isNull() && m_os_vhd_size_mb_isValid;

    m_premium_io_isValid = ::OpenAPI::fromJsonValue(m_premium_io, json[QString("premiumIO")]);
    m_premium_io_isSet = !json[QString("premiumIO")].isNull() && m_premium_io_isValid;

    m_v_cpus_isValid = ::OpenAPI::fromJsonValue(m_v_cpus, json[QString("vCPUs")]);
    m_v_cpus_isSet = !json[QString("vCPUs")].isNull() && m_v_cpus_isValid;
}

QString OAIVirtualMachineSize::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVirtualMachineSize::asJsonObject() const {
    QJsonObject obj;
    if (m_family_isSet) {
        obj.insert(QString("family"), ::OpenAPI::toJsonValue(m_family));
    }
    if (m_low_priority_capable_isSet) {
        obj.insert(QString("lowPriorityCapable"), ::OpenAPI::toJsonValue(m_low_priority_capable));
    }
    if (m_max_resource_volume_mb_isSet) {
        obj.insert(QString("maxResourceVolumeMB"), ::OpenAPI::toJsonValue(m_max_resource_volume_mb));
    }
    if (m_memory_gb_isSet) {
        obj.insert(QString("memoryGB"), ::OpenAPI::toJsonValue(m_memory_gb));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_os_vhd_size_mb_isSet) {
        obj.insert(QString("osVhdSizeMB"), ::OpenAPI::toJsonValue(m_os_vhd_size_mb));
    }
    if (m_premium_io_isSet) {
        obj.insert(QString("premiumIO"), ::OpenAPI::toJsonValue(m_premium_io));
    }
    if (m_v_cpus_isSet) {
        obj.insert(QString("vCPUs"), ::OpenAPI::toJsonValue(m_v_cpus));
    }
    return obj;
}

QString OAIVirtualMachineSize::getFamily() const {
    return m_family;
}
void OAIVirtualMachineSize::setFamily(const QString &family) {
    m_family = family;
    m_family_isSet = true;
}

bool OAIVirtualMachineSize::is_family_Set() const{
    return m_family_isSet;
}

bool OAIVirtualMachineSize::is_family_Valid() const{
    return m_family_isValid;
}

bool OAIVirtualMachineSize::isLowPriorityCapable() const {
    return m_low_priority_capable;
}
void OAIVirtualMachineSize::setLowPriorityCapable(const bool &low_priority_capable) {
    m_low_priority_capable = low_priority_capable;
    m_low_priority_capable_isSet = true;
}

bool OAIVirtualMachineSize::is_low_priority_capable_Set() const{
    return m_low_priority_capable_isSet;
}

bool OAIVirtualMachineSize::is_low_priority_capable_Valid() const{
    return m_low_priority_capable_isValid;
}

qint32 OAIVirtualMachineSize::getMaxResourceVolumeMb() const {
    return m_max_resource_volume_mb;
}
void OAIVirtualMachineSize::setMaxResourceVolumeMb(const qint32 &max_resource_volume_mb) {
    m_max_resource_volume_mb = max_resource_volume_mb;
    m_max_resource_volume_mb_isSet = true;
}

bool OAIVirtualMachineSize::is_max_resource_volume_mb_Set() const{
    return m_max_resource_volume_mb_isSet;
}

bool OAIVirtualMachineSize::is_max_resource_volume_mb_Valid() const{
    return m_max_resource_volume_mb_isValid;
}

double OAIVirtualMachineSize::getMemoryGb() const {
    return m_memory_gb;
}
void OAIVirtualMachineSize::setMemoryGb(const double &memory_gb) {
    m_memory_gb = memory_gb;
    m_memory_gb_isSet = true;
}

bool OAIVirtualMachineSize::is_memory_gb_Set() const{
    return m_memory_gb_isSet;
}

bool OAIVirtualMachineSize::is_memory_gb_Valid() const{
    return m_memory_gb_isValid;
}

QString OAIVirtualMachineSize::getName() const {
    return m_name;
}
void OAIVirtualMachineSize::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIVirtualMachineSize::is_name_Set() const{
    return m_name_isSet;
}

bool OAIVirtualMachineSize::is_name_Valid() const{
    return m_name_isValid;
}

qint32 OAIVirtualMachineSize::getOsVhdSizeMb() const {
    return m_os_vhd_size_mb;
}
void OAIVirtualMachineSize::setOsVhdSizeMb(const qint32 &os_vhd_size_mb) {
    m_os_vhd_size_mb = os_vhd_size_mb;
    m_os_vhd_size_mb_isSet = true;
}

bool OAIVirtualMachineSize::is_os_vhd_size_mb_Set() const{
    return m_os_vhd_size_mb_isSet;
}

bool OAIVirtualMachineSize::is_os_vhd_size_mb_Valid() const{
    return m_os_vhd_size_mb_isValid;
}

bool OAIVirtualMachineSize::isPremiumIo() const {
    return m_premium_io;
}
void OAIVirtualMachineSize::setPremiumIo(const bool &premium_io) {
    m_premium_io = premium_io;
    m_premium_io_isSet = true;
}

bool OAIVirtualMachineSize::is_premium_io_Set() const{
    return m_premium_io_isSet;
}

bool OAIVirtualMachineSize::is_premium_io_Valid() const{
    return m_premium_io_isValid;
}

qint32 OAIVirtualMachineSize::getVCpus() const {
    return m_v_cpus;
}
void OAIVirtualMachineSize::setVCpus(const qint32 &v_cpus) {
    m_v_cpus = v_cpus;
    m_v_cpus_isSet = true;
}

bool OAIVirtualMachineSize::is_v_cpus_Set() const{
    return m_v_cpus_isSet;
}

bool OAIVirtualMachineSize::is_v_cpus_Valid() const{
    return m_v_cpus_isValid;
}

bool OAIVirtualMachineSize::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_family_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_low_priority_capable_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_resource_volume_mb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_memory_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_os_vhd_size_mb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_premium_io_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_v_cpus_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVirtualMachineSize::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
