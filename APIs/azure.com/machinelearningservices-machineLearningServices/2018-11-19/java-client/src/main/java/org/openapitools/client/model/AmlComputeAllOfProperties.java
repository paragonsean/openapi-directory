/*
 * Azure Machine Learning Workspaces
 * These APIs allow end users to operate on Azure Machine Learning Workspace resources.
 *
 * The version of the OpenAPI document: 2018-11-19
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.MachineLearningServiceError;
import org.openapitools.client.model.NodeStateCounts;
import org.openapitools.client.model.ResourceId;
import org.openapitools.client.model.ScaleSettings;
import org.openapitools.client.model.UserAccountCredentials;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * AML Compute properties
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:47:08.785121-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AmlComputeAllOfProperties {
  /**
   * Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
   */
  @JsonAdapter(AllocationStateEnum.Adapter.class)
  public enum AllocationStateEnum {
    STEADY("Steady"),
    
    RESIZING("Resizing");

    private String value;

    AllocationStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AllocationStateEnum fromValue(String value) {
      for (AllocationStateEnum b : AllocationStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AllocationStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AllocationStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AllocationStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AllocationStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AllocationStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ALLOCATION_STATE = "allocationState";
  @SerializedName(SERIALIZED_NAME_ALLOCATION_STATE)
  private AllocationStateEnum allocationState;

  public static final String SERIALIZED_NAME_ALLOCATION_STATE_TRANSITION_TIME = "allocationStateTransitionTime";
  @SerializedName(SERIALIZED_NAME_ALLOCATION_STATE_TRANSITION_TIME)
  private OffsetDateTime allocationStateTransitionTime;

  public static final String SERIALIZED_NAME_CURRENT_NODE_COUNT = "currentNodeCount";
  @SerializedName(SERIALIZED_NAME_CURRENT_NODE_COUNT)
  private Integer currentNodeCount;

  public static final String SERIALIZED_NAME_ERRORS = "errors";
  @SerializedName(SERIALIZED_NAME_ERRORS)
  private List<MachineLearningServiceError> errors = new ArrayList<>();

  public static final String SERIALIZED_NAME_NODE_STATE_COUNTS = "nodeStateCounts";
  @SerializedName(SERIALIZED_NAME_NODE_STATE_COUNTS)
  private NodeStateCounts nodeStateCounts;

  public static final String SERIALIZED_NAME_SCALE_SETTINGS = "scaleSettings";
  @SerializedName(SERIALIZED_NAME_SCALE_SETTINGS)
  private ScaleSettings scaleSettings;

  public static final String SERIALIZED_NAME_SUBNET = "subnet";
  @SerializedName(SERIALIZED_NAME_SUBNET)
  private ResourceId subnet;

  public static final String SERIALIZED_NAME_TARGET_NODE_COUNT = "targetNodeCount";
  @SerializedName(SERIALIZED_NAME_TARGET_NODE_COUNT)
  private Integer targetNodeCount;

  public static final String SERIALIZED_NAME_USER_ACCOUNT_CREDENTIALS = "userAccountCredentials";
  @SerializedName(SERIALIZED_NAME_USER_ACCOUNT_CREDENTIALS)
  private UserAccountCredentials userAccountCredentials;

  /**
   * Virtual Machine priority
   */
  @JsonAdapter(VmPriorityEnum.Adapter.class)
  public enum VmPriorityEnum {
    DEDICATED("Dedicated"),
    
    LOW_PRIORITY("LowPriority");

    private String value;

    VmPriorityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VmPriorityEnum fromValue(String value) {
      for (VmPriorityEnum b : VmPriorityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VmPriorityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VmPriorityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VmPriorityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VmPriorityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VmPriorityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VM_PRIORITY = "vmPriority";
  @SerializedName(SERIALIZED_NAME_VM_PRIORITY)
  private VmPriorityEnum vmPriority;

  public static final String SERIALIZED_NAME_VM_SIZE = "vmSize";
  @SerializedName(SERIALIZED_NAME_VM_SIZE)
  private String vmSize;

  public AmlComputeAllOfProperties() {
  }

  public AmlComputeAllOfProperties(
     AllocationStateEnum allocationState, 
     OffsetDateTime allocationStateTransitionTime, 
     Integer currentNodeCount, 
     List<MachineLearningServiceError> errors, 
     Integer targetNodeCount
  ) {
    this();
    this.allocationState = allocationState;
    this.allocationStateTransitionTime = allocationStateTransitionTime;
    this.currentNodeCount = currentNodeCount;
    this.errors = errors;
    this.targetNodeCount = targetNodeCount;
  }

  /**
   * Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
   * @return allocationState
   */
  @javax.annotation.Nullable
  public AllocationStateEnum getAllocationState() {
    return allocationState;
  }



  /**
   * The time at which the compute entered its current allocation state.
   * @return allocationStateTransitionTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAllocationStateTransitionTime() {
    return allocationStateTransitionTime;
  }



  /**
   * The number of compute nodes currently assigned to the compute.
   * @return currentNodeCount
   */
  @javax.annotation.Nullable
  public Integer getCurrentNodeCount() {
    return currentNodeCount;
  }



  /**
   * Collection of errors encountered by various compute nodes during node setup.
   * @return errors
   */
  @javax.annotation.Nullable
  public List<MachineLearningServiceError> getErrors() {
    return errors;
  }



  public AmlComputeAllOfProperties nodeStateCounts(NodeStateCounts nodeStateCounts) {
    this.nodeStateCounts = nodeStateCounts;
    return this;
  }

  /**
   * Get nodeStateCounts
   * @return nodeStateCounts
   */
  @javax.annotation.Nullable
  public NodeStateCounts getNodeStateCounts() {
    return nodeStateCounts;
  }

  public void setNodeStateCounts(NodeStateCounts nodeStateCounts) {
    this.nodeStateCounts = nodeStateCounts;
  }


  public AmlComputeAllOfProperties scaleSettings(ScaleSettings scaleSettings) {
    this.scaleSettings = scaleSettings;
    return this;
  }

  /**
   * Get scaleSettings
   * @return scaleSettings
   */
  @javax.annotation.Nullable
  public ScaleSettings getScaleSettings() {
    return scaleSettings;
  }

  public void setScaleSettings(ScaleSettings scaleSettings) {
    this.scaleSettings = scaleSettings;
  }


  public AmlComputeAllOfProperties subnet(ResourceId subnet) {
    this.subnet = subnet;
    return this;
  }

  /**
   * Get subnet
   * @return subnet
   */
  @javax.annotation.Nullable
  public ResourceId getSubnet() {
    return subnet;
  }

  public void setSubnet(ResourceId subnet) {
    this.subnet = subnet;
  }


  /**
   * The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
   * @return targetNodeCount
   */
  @javax.annotation.Nullable
  public Integer getTargetNodeCount() {
    return targetNodeCount;
  }



  public AmlComputeAllOfProperties userAccountCredentials(UserAccountCredentials userAccountCredentials) {
    this.userAccountCredentials = userAccountCredentials;
    return this;
  }

  /**
   * Get userAccountCredentials
   * @return userAccountCredentials
   */
  @javax.annotation.Nullable
  public UserAccountCredentials getUserAccountCredentials() {
    return userAccountCredentials;
  }

  public void setUserAccountCredentials(UserAccountCredentials userAccountCredentials) {
    this.userAccountCredentials = userAccountCredentials;
  }


  public AmlComputeAllOfProperties vmPriority(VmPriorityEnum vmPriority) {
    this.vmPriority = vmPriority;
    return this;
  }

  /**
   * Virtual Machine priority
   * @return vmPriority
   */
  @javax.annotation.Nullable
  public VmPriorityEnum getVmPriority() {
    return vmPriority;
  }

  public void setVmPriority(VmPriorityEnum vmPriority) {
    this.vmPriority = vmPriority;
  }


  public AmlComputeAllOfProperties vmSize(String vmSize) {
    this.vmSize = vmSize;
    return this;
  }

  /**
   * Virtual Machine Size
   * @return vmSize
   */
  @javax.annotation.Nullable
  public String getVmSize() {
    return vmSize;
  }

  public void setVmSize(String vmSize) {
    this.vmSize = vmSize;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AmlComputeAllOfProperties amlComputeAllOfProperties = (AmlComputeAllOfProperties) o;
    return Objects.equals(this.allocationState, amlComputeAllOfProperties.allocationState) &&
        Objects.equals(this.allocationStateTransitionTime, amlComputeAllOfProperties.allocationStateTransitionTime) &&
        Objects.equals(this.currentNodeCount, amlComputeAllOfProperties.currentNodeCount) &&
        Objects.equals(this.errors, amlComputeAllOfProperties.errors) &&
        Objects.equals(this.nodeStateCounts, amlComputeAllOfProperties.nodeStateCounts) &&
        Objects.equals(this.scaleSettings, amlComputeAllOfProperties.scaleSettings) &&
        Objects.equals(this.subnet, amlComputeAllOfProperties.subnet) &&
        Objects.equals(this.targetNodeCount, amlComputeAllOfProperties.targetNodeCount) &&
        Objects.equals(this.userAccountCredentials, amlComputeAllOfProperties.userAccountCredentials) &&
        Objects.equals(this.vmPriority, amlComputeAllOfProperties.vmPriority) &&
        Objects.equals(this.vmSize, amlComputeAllOfProperties.vmSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allocationState, allocationStateTransitionTime, currentNodeCount, errors, nodeStateCounts, scaleSettings, subnet, targetNodeCount, userAccountCredentials, vmPriority, vmSize);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AmlComputeAllOfProperties {\n");
    sb.append("    allocationState: ").append(toIndentedString(allocationState)).append("\n");
    sb.append("    allocationStateTransitionTime: ").append(toIndentedString(allocationStateTransitionTime)).append("\n");
    sb.append("    currentNodeCount: ").append(toIndentedString(currentNodeCount)).append("\n");
    sb.append("    errors: ").append(toIndentedString(errors)).append("\n");
    sb.append("    nodeStateCounts: ").append(toIndentedString(nodeStateCounts)).append("\n");
    sb.append("    scaleSettings: ").append(toIndentedString(scaleSettings)).append("\n");
    sb.append("    subnet: ").append(toIndentedString(subnet)).append("\n");
    sb.append("    targetNodeCount: ").append(toIndentedString(targetNodeCount)).append("\n");
    sb.append("    userAccountCredentials: ").append(toIndentedString(userAccountCredentials)).append("\n");
    sb.append("    vmPriority: ").append(toIndentedString(vmPriority)).append("\n");
    sb.append("    vmSize: ").append(toIndentedString(vmSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allocationState");
    openapiFields.add("allocationStateTransitionTime");
    openapiFields.add("currentNodeCount");
    openapiFields.add("errors");
    openapiFields.add("nodeStateCounts");
    openapiFields.add("scaleSettings");
    openapiFields.add("subnet");
    openapiFields.add("targetNodeCount");
    openapiFields.add("userAccountCredentials");
    openapiFields.add("vmPriority");
    openapiFields.add("vmSize");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AmlComputeAllOfProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AmlComputeAllOfProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AmlComputeAllOfProperties is not found in the empty JSON string", AmlComputeAllOfProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AmlComputeAllOfProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AmlComputeAllOfProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("allocationState") != null && !jsonObj.get("allocationState").isJsonNull()) && !jsonObj.get("allocationState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allocationState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allocationState").toString()));
      }
      // validate the optional field `allocationState`
      if (jsonObj.get("allocationState") != null && !jsonObj.get("allocationState").isJsonNull()) {
        AllocationStateEnum.validateJsonElement(jsonObj.get("allocationState"));
      }
      if (jsonObj.get("errors") != null && !jsonObj.get("errors").isJsonNull()) {
        JsonArray jsonArrayerrors = jsonObj.getAsJsonArray("errors");
        if (jsonArrayerrors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("errors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `errors` to be an array in the JSON string but got `%s`", jsonObj.get("errors").toString()));
          }

          // validate the optional field `errors` (array)
          for (int i = 0; i < jsonArrayerrors.size(); i++) {
            MachineLearningServiceError.validateJsonElement(jsonArrayerrors.get(i));
          };
        }
      }
      // validate the optional field `nodeStateCounts`
      if (jsonObj.get("nodeStateCounts") != null && !jsonObj.get("nodeStateCounts").isJsonNull()) {
        NodeStateCounts.validateJsonElement(jsonObj.get("nodeStateCounts"));
      }
      // validate the optional field `scaleSettings`
      if (jsonObj.get("scaleSettings") != null && !jsonObj.get("scaleSettings").isJsonNull()) {
        ScaleSettings.validateJsonElement(jsonObj.get("scaleSettings"));
      }
      // validate the optional field `subnet`
      if (jsonObj.get("subnet") != null && !jsonObj.get("subnet").isJsonNull()) {
        ResourceId.validateJsonElement(jsonObj.get("subnet"));
      }
      // validate the optional field `userAccountCredentials`
      if (jsonObj.get("userAccountCredentials") != null && !jsonObj.get("userAccountCredentials").isJsonNull()) {
        UserAccountCredentials.validateJsonElement(jsonObj.get("userAccountCredentials"));
      }
      if ((jsonObj.get("vmPriority") != null && !jsonObj.get("vmPriority").isJsonNull()) && !jsonObj.get("vmPriority").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vmPriority` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vmPriority").toString()));
      }
      // validate the optional field `vmPriority`
      if (jsonObj.get("vmPriority") != null && !jsonObj.get("vmPriority").isJsonNull()) {
        VmPriorityEnum.validateJsonElement(jsonObj.get("vmPriority"));
      }
      if ((jsonObj.get("vmSize") != null && !jsonObj.get("vmSize").isJsonNull()) && !jsonObj.get("vmSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vmSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vmSize").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AmlComputeAllOfProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AmlComputeAllOfProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AmlComputeAllOfProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AmlComputeAllOfProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<AmlComputeAllOfProperties>() {
           @Override
           public void write(JsonWriter out, AmlComputeAllOfProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AmlComputeAllOfProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AmlComputeAllOfProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AmlComputeAllOfProperties
   * @throws IOException if the JSON string is invalid with respect to AmlComputeAllOfProperties
   */
  public static AmlComputeAllOfProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AmlComputeAllOfProperties.class);
  }

  /**
   * Convert an instance of AmlComputeAllOfProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

