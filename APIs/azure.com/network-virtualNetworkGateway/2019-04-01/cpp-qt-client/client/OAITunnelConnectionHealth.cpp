/**
 * NetworkManagementClient
 * The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.
 *
 * The version of the OpenAPI document: 2019-04-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITunnelConnectionHealth.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITunnelConnectionHealth::OAITunnelConnectionHealth(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITunnelConnectionHealth::OAITunnelConnectionHealth() {
    this->initializeModel();
}

OAITunnelConnectionHealth::~OAITunnelConnectionHealth() {}

void OAITunnelConnectionHealth::initializeModel() {

    m_connection_status_isSet = false;
    m_connection_status_isValid = false;

    m_egress_bytes_transferred_isSet = false;
    m_egress_bytes_transferred_isValid = false;

    m_ingress_bytes_transferred_isSet = false;
    m_ingress_bytes_transferred_isValid = false;

    m_last_connection_established_utc_time_isSet = false;
    m_last_connection_established_utc_time_isValid = false;

    m_tunnel_isSet = false;
    m_tunnel_isValid = false;
}

void OAITunnelConnectionHealth::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITunnelConnectionHealth::fromJsonObject(QJsonObject json) {

    m_connection_status_isValid = ::OpenAPI::fromJsonValue(m_connection_status, json[QString("connectionStatus")]);
    m_connection_status_isSet = !json[QString("connectionStatus")].isNull() && m_connection_status_isValid;

    m_egress_bytes_transferred_isValid = ::OpenAPI::fromJsonValue(m_egress_bytes_transferred, json[QString("egressBytesTransferred")]);
    m_egress_bytes_transferred_isSet = !json[QString("egressBytesTransferred")].isNull() && m_egress_bytes_transferred_isValid;

    m_ingress_bytes_transferred_isValid = ::OpenAPI::fromJsonValue(m_ingress_bytes_transferred, json[QString("ingressBytesTransferred")]);
    m_ingress_bytes_transferred_isSet = !json[QString("ingressBytesTransferred")].isNull() && m_ingress_bytes_transferred_isValid;

    m_last_connection_established_utc_time_isValid = ::OpenAPI::fromJsonValue(m_last_connection_established_utc_time, json[QString("lastConnectionEstablishedUtcTime")]);
    m_last_connection_established_utc_time_isSet = !json[QString("lastConnectionEstablishedUtcTime")].isNull() && m_last_connection_established_utc_time_isValid;

    m_tunnel_isValid = ::OpenAPI::fromJsonValue(m_tunnel, json[QString("tunnel")]);
    m_tunnel_isSet = !json[QString("tunnel")].isNull() && m_tunnel_isValid;
}

QString OAITunnelConnectionHealth::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITunnelConnectionHealth::asJsonObject() const {
    QJsonObject obj;
    if (m_connection_status.isSet()) {
        obj.insert(QString("connectionStatus"), ::OpenAPI::toJsonValue(m_connection_status));
    }
    if (m_egress_bytes_transferred_isSet) {
        obj.insert(QString("egressBytesTransferred"), ::OpenAPI::toJsonValue(m_egress_bytes_transferred));
    }
    if (m_ingress_bytes_transferred_isSet) {
        obj.insert(QString("ingressBytesTransferred"), ::OpenAPI::toJsonValue(m_ingress_bytes_transferred));
    }
    if (m_last_connection_established_utc_time_isSet) {
        obj.insert(QString("lastConnectionEstablishedUtcTime"), ::OpenAPI::toJsonValue(m_last_connection_established_utc_time));
    }
    if (m_tunnel_isSet) {
        obj.insert(QString("tunnel"), ::OpenAPI::toJsonValue(m_tunnel));
    }
    return obj;
}

OAIVirtualNetworkGatewayConnectionStatus OAITunnelConnectionHealth::getConnectionStatus() const {
    return m_connection_status;
}
void OAITunnelConnectionHealth::setConnectionStatus(const OAIVirtualNetworkGatewayConnectionStatus &connection_status) {
    m_connection_status = connection_status;
    m_connection_status_isSet = true;
}

bool OAITunnelConnectionHealth::is_connection_status_Set() const{
    return m_connection_status_isSet;
}

bool OAITunnelConnectionHealth::is_connection_status_Valid() const{
    return m_connection_status_isValid;
}

qint64 OAITunnelConnectionHealth::getEgressBytesTransferred() const {
    return m_egress_bytes_transferred;
}
void OAITunnelConnectionHealth::setEgressBytesTransferred(const qint64 &egress_bytes_transferred) {
    m_egress_bytes_transferred = egress_bytes_transferred;
    m_egress_bytes_transferred_isSet = true;
}

bool OAITunnelConnectionHealth::is_egress_bytes_transferred_Set() const{
    return m_egress_bytes_transferred_isSet;
}

bool OAITunnelConnectionHealth::is_egress_bytes_transferred_Valid() const{
    return m_egress_bytes_transferred_isValid;
}

qint64 OAITunnelConnectionHealth::getIngressBytesTransferred() const {
    return m_ingress_bytes_transferred;
}
void OAITunnelConnectionHealth::setIngressBytesTransferred(const qint64 &ingress_bytes_transferred) {
    m_ingress_bytes_transferred = ingress_bytes_transferred;
    m_ingress_bytes_transferred_isSet = true;
}

bool OAITunnelConnectionHealth::is_ingress_bytes_transferred_Set() const{
    return m_ingress_bytes_transferred_isSet;
}

bool OAITunnelConnectionHealth::is_ingress_bytes_transferred_Valid() const{
    return m_ingress_bytes_transferred_isValid;
}

QString OAITunnelConnectionHealth::getLastConnectionEstablishedUtcTime() const {
    return m_last_connection_established_utc_time;
}
void OAITunnelConnectionHealth::setLastConnectionEstablishedUtcTime(const QString &last_connection_established_utc_time) {
    m_last_connection_established_utc_time = last_connection_established_utc_time;
    m_last_connection_established_utc_time_isSet = true;
}

bool OAITunnelConnectionHealth::is_last_connection_established_utc_time_Set() const{
    return m_last_connection_established_utc_time_isSet;
}

bool OAITunnelConnectionHealth::is_last_connection_established_utc_time_Valid() const{
    return m_last_connection_established_utc_time_isValid;
}

QString OAITunnelConnectionHealth::getTunnel() const {
    return m_tunnel;
}
void OAITunnelConnectionHealth::setTunnel(const QString &tunnel) {
    m_tunnel = tunnel;
    m_tunnel_isSet = true;
}

bool OAITunnelConnectionHealth::is_tunnel_Set() const{
    return m_tunnel_isSet;
}

bool OAITunnelConnectionHealth::is_tunnel_Valid() const{
    return m_tunnel_isValid;
}

bool OAITunnelConnectionHealth::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_connection_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_egress_bytes_transferred_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ingress_bytes_transferred_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_connection_established_utc_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tunnel_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITunnelConnectionHealth::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
