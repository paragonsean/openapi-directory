/**
 * NetworkManagementClient
 * The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.
 *
 * The version of the OpenAPI document: 2019-04-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVpnClientIPsecParameters.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVpnClientIPsecParameters::OAIVpnClientIPsecParameters(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVpnClientIPsecParameters::OAIVpnClientIPsecParameters() {
    this->initializeModel();
}

OAIVpnClientIPsecParameters::~OAIVpnClientIPsecParameters() {}

void OAIVpnClientIPsecParameters::initializeModel() {

    m_dh_group_isSet = false;
    m_dh_group_isValid = false;

    m_ike_encryption_isSet = false;
    m_ike_encryption_isValid = false;

    m_ike_integrity_isSet = false;
    m_ike_integrity_isValid = false;

    m_ipsec_encryption_isSet = false;
    m_ipsec_encryption_isValid = false;

    m_ipsec_integrity_isSet = false;
    m_ipsec_integrity_isValid = false;

    m_pfs_group_isSet = false;
    m_pfs_group_isValid = false;

    m_sa_data_size_kilobytes_isSet = false;
    m_sa_data_size_kilobytes_isValid = false;

    m_sa_life_time_seconds_isSet = false;
    m_sa_life_time_seconds_isValid = false;
}

void OAIVpnClientIPsecParameters::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVpnClientIPsecParameters::fromJsonObject(QJsonObject json) {

    m_dh_group_isValid = ::OpenAPI::fromJsonValue(m_dh_group, json[QString("dhGroup")]);
    m_dh_group_isSet = !json[QString("dhGroup")].isNull() && m_dh_group_isValid;

    m_ike_encryption_isValid = ::OpenAPI::fromJsonValue(m_ike_encryption, json[QString("ikeEncryption")]);
    m_ike_encryption_isSet = !json[QString("ikeEncryption")].isNull() && m_ike_encryption_isValid;

    m_ike_integrity_isValid = ::OpenAPI::fromJsonValue(m_ike_integrity, json[QString("ikeIntegrity")]);
    m_ike_integrity_isSet = !json[QString("ikeIntegrity")].isNull() && m_ike_integrity_isValid;

    m_ipsec_encryption_isValid = ::OpenAPI::fromJsonValue(m_ipsec_encryption, json[QString("ipsecEncryption")]);
    m_ipsec_encryption_isSet = !json[QString("ipsecEncryption")].isNull() && m_ipsec_encryption_isValid;

    m_ipsec_integrity_isValid = ::OpenAPI::fromJsonValue(m_ipsec_integrity, json[QString("ipsecIntegrity")]);
    m_ipsec_integrity_isSet = !json[QString("ipsecIntegrity")].isNull() && m_ipsec_integrity_isValid;

    m_pfs_group_isValid = ::OpenAPI::fromJsonValue(m_pfs_group, json[QString("pfsGroup")]);
    m_pfs_group_isSet = !json[QString("pfsGroup")].isNull() && m_pfs_group_isValid;

    m_sa_data_size_kilobytes_isValid = ::OpenAPI::fromJsonValue(m_sa_data_size_kilobytes, json[QString("saDataSizeKilobytes")]);
    m_sa_data_size_kilobytes_isSet = !json[QString("saDataSizeKilobytes")].isNull() && m_sa_data_size_kilobytes_isValid;

    m_sa_life_time_seconds_isValid = ::OpenAPI::fromJsonValue(m_sa_life_time_seconds, json[QString("saLifeTimeSeconds")]);
    m_sa_life_time_seconds_isSet = !json[QString("saLifeTimeSeconds")].isNull() && m_sa_life_time_seconds_isValid;
}

QString OAIVpnClientIPsecParameters::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVpnClientIPsecParameters::asJsonObject() const {
    QJsonObject obj;
    if (m_dh_group.isSet()) {
        obj.insert(QString("dhGroup"), ::OpenAPI::toJsonValue(m_dh_group));
    }
    if (m_ike_encryption.isSet()) {
        obj.insert(QString("ikeEncryption"), ::OpenAPI::toJsonValue(m_ike_encryption));
    }
    if (m_ike_integrity.isSet()) {
        obj.insert(QString("ikeIntegrity"), ::OpenAPI::toJsonValue(m_ike_integrity));
    }
    if (m_ipsec_encryption.isSet()) {
        obj.insert(QString("ipsecEncryption"), ::OpenAPI::toJsonValue(m_ipsec_encryption));
    }
    if (m_ipsec_integrity.isSet()) {
        obj.insert(QString("ipsecIntegrity"), ::OpenAPI::toJsonValue(m_ipsec_integrity));
    }
    if (m_pfs_group.isSet()) {
        obj.insert(QString("pfsGroup"), ::OpenAPI::toJsonValue(m_pfs_group));
    }
    if (m_sa_data_size_kilobytes_isSet) {
        obj.insert(QString("saDataSizeKilobytes"), ::OpenAPI::toJsonValue(m_sa_data_size_kilobytes));
    }
    if (m_sa_life_time_seconds_isSet) {
        obj.insert(QString("saLifeTimeSeconds"), ::OpenAPI::toJsonValue(m_sa_life_time_seconds));
    }
    return obj;
}

OAIDhGroup OAIVpnClientIPsecParameters::getDhGroup() const {
    return m_dh_group;
}
void OAIVpnClientIPsecParameters::setDhGroup(const OAIDhGroup &dh_group) {
    m_dh_group = dh_group;
    m_dh_group_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_dh_group_Set() const{
    return m_dh_group_isSet;
}

bool OAIVpnClientIPsecParameters::is_dh_group_Valid() const{
    return m_dh_group_isValid;
}

OAIIkeEncryption OAIVpnClientIPsecParameters::getIkeEncryption() const {
    return m_ike_encryption;
}
void OAIVpnClientIPsecParameters::setIkeEncryption(const OAIIkeEncryption &ike_encryption) {
    m_ike_encryption = ike_encryption;
    m_ike_encryption_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_ike_encryption_Set() const{
    return m_ike_encryption_isSet;
}

bool OAIVpnClientIPsecParameters::is_ike_encryption_Valid() const{
    return m_ike_encryption_isValid;
}

OAIIkeIntegrity OAIVpnClientIPsecParameters::getIkeIntegrity() const {
    return m_ike_integrity;
}
void OAIVpnClientIPsecParameters::setIkeIntegrity(const OAIIkeIntegrity &ike_integrity) {
    m_ike_integrity = ike_integrity;
    m_ike_integrity_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_ike_integrity_Set() const{
    return m_ike_integrity_isSet;
}

bool OAIVpnClientIPsecParameters::is_ike_integrity_Valid() const{
    return m_ike_integrity_isValid;
}

OAIIpsecEncryption OAIVpnClientIPsecParameters::getIpsecEncryption() const {
    return m_ipsec_encryption;
}
void OAIVpnClientIPsecParameters::setIpsecEncryption(const OAIIpsecEncryption &ipsec_encryption) {
    m_ipsec_encryption = ipsec_encryption;
    m_ipsec_encryption_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_ipsec_encryption_Set() const{
    return m_ipsec_encryption_isSet;
}

bool OAIVpnClientIPsecParameters::is_ipsec_encryption_Valid() const{
    return m_ipsec_encryption_isValid;
}

OAIIpsecIntegrity OAIVpnClientIPsecParameters::getIpsecIntegrity() const {
    return m_ipsec_integrity;
}
void OAIVpnClientIPsecParameters::setIpsecIntegrity(const OAIIpsecIntegrity &ipsec_integrity) {
    m_ipsec_integrity = ipsec_integrity;
    m_ipsec_integrity_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_ipsec_integrity_Set() const{
    return m_ipsec_integrity_isSet;
}

bool OAIVpnClientIPsecParameters::is_ipsec_integrity_Valid() const{
    return m_ipsec_integrity_isValid;
}

OAIPfsGroup OAIVpnClientIPsecParameters::getPfsGroup() const {
    return m_pfs_group;
}
void OAIVpnClientIPsecParameters::setPfsGroup(const OAIPfsGroup &pfs_group) {
    m_pfs_group = pfs_group;
    m_pfs_group_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_pfs_group_Set() const{
    return m_pfs_group_isSet;
}

bool OAIVpnClientIPsecParameters::is_pfs_group_Valid() const{
    return m_pfs_group_isValid;
}

qint32 OAIVpnClientIPsecParameters::getSaDataSizeKilobytes() const {
    return m_sa_data_size_kilobytes;
}
void OAIVpnClientIPsecParameters::setSaDataSizeKilobytes(const qint32 &sa_data_size_kilobytes) {
    m_sa_data_size_kilobytes = sa_data_size_kilobytes;
    m_sa_data_size_kilobytes_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_sa_data_size_kilobytes_Set() const{
    return m_sa_data_size_kilobytes_isSet;
}

bool OAIVpnClientIPsecParameters::is_sa_data_size_kilobytes_Valid() const{
    return m_sa_data_size_kilobytes_isValid;
}

qint32 OAIVpnClientIPsecParameters::getSaLifeTimeSeconds() const {
    return m_sa_life_time_seconds;
}
void OAIVpnClientIPsecParameters::setSaLifeTimeSeconds(const qint32 &sa_life_time_seconds) {
    m_sa_life_time_seconds = sa_life_time_seconds;
    m_sa_life_time_seconds_isSet = true;
}

bool OAIVpnClientIPsecParameters::is_sa_life_time_seconds_Set() const{
    return m_sa_life_time_seconds_isSet;
}

bool OAIVpnClientIPsecParameters::is_sa_life_time_seconds_Valid() const{
    return m_sa_life_time_seconds_isValid;
}

bool OAIVpnClientIPsecParameters::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_dh_group.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ike_encryption.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ike_integrity.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ipsec_encryption.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ipsec_integrity.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_pfs_group.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_sa_data_size_kilobytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sa_life_time_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVpnClientIPsecParameters::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_dh_group_isValid && m_ike_encryption_isValid && m_ike_integrity_isValid && m_ipsec_encryption_isValid && m_ipsec_integrity_isValid && m_pfs_group_isValid && m_sa_data_size_kilobytes_isValid && m_sa_life_time_seconds_isValid && true;
}

} // namespace OpenAPI
