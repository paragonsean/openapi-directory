/**
 * NetworkManagementClient
 * The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.
 *
 * The version of the OpenAPI document: 2018-10-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIIpsecPolicy.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIIpsecPolicy::OAIIpsecPolicy(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIIpsecPolicy::OAIIpsecPolicy() {
    this->initializeModel();
}

OAIIpsecPolicy::~OAIIpsecPolicy() {}

void OAIIpsecPolicy::initializeModel() {

    m_dh_group_isSet = false;
    m_dh_group_isValid = false;

    m_ike_encryption_isSet = false;
    m_ike_encryption_isValid = false;

    m_ike_integrity_isSet = false;
    m_ike_integrity_isValid = false;

    m_ipsec_encryption_isSet = false;
    m_ipsec_encryption_isValid = false;

    m_ipsec_integrity_isSet = false;
    m_ipsec_integrity_isValid = false;

    m_pfs_group_isSet = false;
    m_pfs_group_isValid = false;

    m_sa_data_size_kilobytes_isSet = false;
    m_sa_data_size_kilobytes_isValid = false;

    m_sa_life_time_seconds_isSet = false;
    m_sa_life_time_seconds_isValid = false;
}

void OAIIpsecPolicy::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIIpsecPolicy::fromJsonObject(QJsonObject json) {

    m_dh_group_isValid = ::OpenAPI::fromJsonValue(m_dh_group, json[QString("dhGroup")]);
    m_dh_group_isSet = !json[QString("dhGroup")].isNull() && m_dh_group_isValid;

    m_ike_encryption_isValid = ::OpenAPI::fromJsonValue(m_ike_encryption, json[QString("ikeEncryption")]);
    m_ike_encryption_isSet = !json[QString("ikeEncryption")].isNull() && m_ike_encryption_isValid;

    m_ike_integrity_isValid = ::OpenAPI::fromJsonValue(m_ike_integrity, json[QString("ikeIntegrity")]);
    m_ike_integrity_isSet = !json[QString("ikeIntegrity")].isNull() && m_ike_integrity_isValid;

    m_ipsec_encryption_isValid = ::OpenAPI::fromJsonValue(m_ipsec_encryption, json[QString("ipsecEncryption")]);
    m_ipsec_encryption_isSet = !json[QString("ipsecEncryption")].isNull() && m_ipsec_encryption_isValid;

    m_ipsec_integrity_isValid = ::OpenAPI::fromJsonValue(m_ipsec_integrity, json[QString("ipsecIntegrity")]);
    m_ipsec_integrity_isSet = !json[QString("ipsecIntegrity")].isNull() && m_ipsec_integrity_isValid;

    m_pfs_group_isValid = ::OpenAPI::fromJsonValue(m_pfs_group, json[QString("pfsGroup")]);
    m_pfs_group_isSet = !json[QString("pfsGroup")].isNull() && m_pfs_group_isValid;

    m_sa_data_size_kilobytes_isValid = ::OpenAPI::fromJsonValue(m_sa_data_size_kilobytes, json[QString("saDataSizeKilobytes")]);
    m_sa_data_size_kilobytes_isSet = !json[QString("saDataSizeKilobytes")].isNull() && m_sa_data_size_kilobytes_isValid;

    m_sa_life_time_seconds_isValid = ::OpenAPI::fromJsonValue(m_sa_life_time_seconds, json[QString("saLifeTimeSeconds")]);
    m_sa_life_time_seconds_isSet = !json[QString("saLifeTimeSeconds")].isNull() && m_sa_life_time_seconds_isValid;
}

QString OAIIpsecPolicy::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIIpsecPolicy::asJsonObject() const {
    QJsonObject obj;
    if (m_dh_group_isSet) {
        obj.insert(QString("dhGroup"), ::OpenAPI::toJsonValue(m_dh_group));
    }
    if (m_ike_encryption_isSet) {
        obj.insert(QString("ikeEncryption"), ::OpenAPI::toJsonValue(m_ike_encryption));
    }
    if (m_ike_integrity_isSet) {
        obj.insert(QString("ikeIntegrity"), ::OpenAPI::toJsonValue(m_ike_integrity));
    }
    if (m_ipsec_encryption_isSet) {
        obj.insert(QString("ipsecEncryption"), ::OpenAPI::toJsonValue(m_ipsec_encryption));
    }
    if (m_ipsec_integrity_isSet) {
        obj.insert(QString("ipsecIntegrity"), ::OpenAPI::toJsonValue(m_ipsec_integrity));
    }
    if (m_pfs_group_isSet) {
        obj.insert(QString("pfsGroup"), ::OpenAPI::toJsonValue(m_pfs_group));
    }
    if (m_sa_data_size_kilobytes_isSet) {
        obj.insert(QString("saDataSizeKilobytes"), ::OpenAPI::toJsonValue(m_sa_data_size_kilobytes));
    }
    if (m_sa_life_time_seconds_isSet) {
        obj.insert(QString("saLifeTimeSeconds"), ::OpenAPI::toJsonValue(m_sa_life_time_seconds));
    }
    return obj;
}

QString OAIIpsecPolicy::getDhGroup() const {
    return m_dh_group;
}
void OAIIpsecPolicy::setDhGroup(const QString &dh_group) {
    m_dh_group = dh_group;
    m_dh_group_isSet = true;
}

bool OAIIpsecPolicy::is_dh_group_Set() const{
    return m_dh_group_isSet;
}

bool OAIIpsecPolicy::is_dh_group_Valid() const{
    return m_dh_group_isValid;
}

QString OAIIpsecPolicy::getIkeEncryption() const {
    return m_ike_encryption;
}
void OAIIpsecPolicy::setIkeEncryption(const QString &ike_encryption) {
    m_ike_encryption = ike_encryption;
    m_ike_encryption_isSet = true;
}

bool OAIIpsecPolicy::is_ike_encryption_Set() const{
    return m_ike_encryption_isSet;
}

bool OAIIpsecPolicy::is_ike_encryption_Valid() const{
    return m_ike_encryption_isValid;
}

QString OAIIpsecPolicy::getIkeIntegrity() const {
    return m_ike_integrity;
}
void OAIIpsecPolicy::setIkeIntegrity(const QString &ike_integrity) {
    m_ike_integrity = ike_integrity;
    m_ike_integrity_isSet = true;
}

bool OAIIpsecPolicy::is_ike_integrity_Set() const{
    return m_ike_integrity_isSet;
}

bool OAIIpsecPolicy::is_ike_integrity_Valid() const{
    return m_ike_integrity_isValid;
}

QString OAIIpsecPolicy::getIpsecEncryption() const {
    return m_ipsec_encryption;
}
void OAIIpsecPolicy::setIpsecEncryption(const QString &ipsec_encryption) {
    m_ipsec_encryption = ipsec_encryption;
    m_ipsec_encryption_isSet = true;
}

bool OAIIpsecPolicy::is_ipsec_encryption_Set() const{
    return m_ipsec_encryption_isSet;
}

bool OAIIpsecPolicy::is_ipsec_encryption_Valid() const{
    return m_ipsec_encryption_isValid;
}

QString OAIIpsecPolicy::getIpsecIntegrity() const {
    return m_ipsec_integrity;
}
void OAIIpsecPolicy::setIpsecIntegrity(const QString &ipsec_integrity) {
    m_ipsec_integrity = ipsec_integrity;
    m_ipsec_integrity_isSet = true;
}

bool OAIIpsecPolicy::is_ipsec_integrity_Set() const{
    return m_ipsec_integrity_isSet;
}

bool OAIIpsecPolicy::is_ipsec_integrity_Valid() const{
    return m_ipsec_integrity_isValid;
}

QString OAIIpsecPolicy::getPfsGroup() const {
    return m_pfs_group;
}
void OAIIpsecPolicy::setPfsGroup(const QString &pfs_group) {
    m_pfs_group = pfs_group;
    m_pfs_group_isSet = true;
}

bool OAIIpsecPolicy::is_pfs_group_Set() const{
    return m_pfs_group_isSet;
}

bool OAIIpsecPolicy::is_pfs_group_Valid() const{
    return m_pfs_group_isValid;
}

qint32 OAIIpsecPolicy::getSaDataSizeKilobytes() const {
    return m_sa_data_size_kilobytes;
}
void OAIIpsecPolicy::setSaDataSizeKilobytes(const qint32 &sa_data_size_kilobytes) {
    m_sa_data_size_kilobytes = sa_data_size_kilobytes;
    m_sa_data_size_kilobytes_isSet = true;
}

bool OAIIpsecPolicy::is_sa_data_size_kilobytes_Set() const{
    return m_sa_data_size_kilobytes_isSet;
}

bool OAIIpsecPolicy::is_sa_data_size_kilobytes_Valid() const{
    return m_sa_data_size_kilobytes_isValid;
}

qint32 OAIIpsecPolicy::getSaLifeTimeSeconds() const {
    return m_sa_life_time_seconds;
}
void OAIIpsecPolicy::setSaLifeTimeSeconds(const qint32 &sa_life_time_seconds) {
    m_sa_life_time_seconds = sa_life_time_seconds;
    m_sa_life_time_seconds_isSet = true;
}

bool OAIIpsecPolicy::is_sa_life_time_seconds_Set() const{
    return m_sa_life_time_seconds_isSet;
}

bool OAIIpsecPolicy::is_sa_life_time_seconds_Valid() const{
    return m_sa_life_time_seconds_isValid;
}

bool OAIIpsecPolicy::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_dh_group_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ike_encryption_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ike_integrity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ipsec_encryption_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ipsec_integrity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pfs_group_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sa_data_size_kilobytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sa_life_time_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIIpsecPolicy::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_dh_group_isValid && m_ike_encryption_isValid && m_ike_integrity_isValid && m_ipsec_encryption_isValid && m_ipsec_integrity_isValid && m_pfs_group_isValid && m_sa_data_size_kilobytes_isValid && m_sa_life_time_seconds_isValid && true;
}

} // namespace OpenAPI
