/*
 * Azure Media Services
 * Streaming resource management client for Azure Media Services
 *
 * The version of the OpenAPI document: 2018-07-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.LiveEventEndpoint;
import org.openapitools.client.model.LiveEventPreviewAccessControl;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The Live Event preview.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:59:07.239488-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LiveEventPreview {
  public static final String SERIALIZED_NAME_ACCESS_CONTROL = "accessControl";
  @SerializedName(SERIALIZED_NAME_ACCESS_CONTROL)
  private LiveEventPreviewAccessControl accessControl;

  public static final String SERIALIZED_NAME_ALTERNATIVE_MEDIA_ID = "alternativeMediaId";
  @SerializedName(SERIALIZED_NAME_ALTERNATIVE_MEDIA_ID)
  private String alternativeMediaId;

  public static final String SERIALIZED_NAME_ENDPOINTS = "endpoints";
  @SerializedName(SERIALIZED_NAME_ENDPOINTS)
  private List<LiveEventEndpoint> endpoints = new ArrayList<>();

  public static final String SERIALIZED_NAME_PREVIEW_LOCATOR = "previewLocator";
  @SerializedName(SERIALIZED_NAME_PREVIEW_LOCATOR)
  private String previewLocator;

  public static final String SERIALIZED_NAME_STREAMING_POLICY_NAME = "streamingPolicyName";
  @SerializedName(SERIALIZED_NAME_STREAMING_POLICY_NAME)
  private String streamingPolicyName;

  public LiveEventPreview() {
  }

  public LiveEventPreview accessControl(LiveEventPreviewAccessControl accessControl) {
    this.accessControl = accessControl;
    return this;
  }

  /**
   * Get accessControl
   * @return accessControl
   */
  @javax.annotation.Nullable
  public LiveEventPreviewAccessControl getAccessControl() {
    return accessControl;
  }

  public void setAccessControl(LiveEventPreviewAccessControl accessControl) {
    this.accessControl = accessControl;
  }


  public LiveEventPreview alternativeMediaId(String alternativeMediaId) {
    this.alternativeMediaId = alternativeMediaId;
    return this;
  }

  /**
   * An Alternative Media Identifier associated with the StreamingLocator created for the preview.  This value is specified at creation time and cannot be updated.  The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
   * @return alternativeMediaId
   */
  @javax.annotation.Nullable
  public String getAlternativeMediaId() {
    return alternativeMediaId;
  }

  public void setAlternativeMediaId(String alternativeMediaId) {
    this.alternativeMediaId = alternativeMediaId;
  }


  public LiveEventPreview endpoints(List<LiveEventEndpoint> endpoints) {
    this.endpoints = endpoints;
    return this;
  }

  public LiveEventPreview addEndpointsItem(LiveEventEndpoint endpointsItem) {
    if (this.endpoints == null) {
      this.endpoints = new ArrayList<>();
    }
    this.endpoints.add(endpointsItem);
    return this;
  }

  /**
   * The endpoints for preview.
   * @return endpoints
   */
  @javax.annotation.Nullable
  public List<LiveEventEndpoint> getEndpoints() {
    return endpoints;
  }

  public void setEndpoints(List<LiveEventEndpoint> endpoints) {
    this.endpoints = endpoints;
  }


  public LiveEventPreview previewLocator(String previewLocator) {
    this.previewLocator = previewLocator;
    return this;
  }

  /**
   * The identifier of the preview locator in Guid format.  Specifying this at creation time allows the caller to know the preview locator url before the event is created.  If omitted, the service will generate a random identifier.  This value cannot be updated once the live event is created.
   * @return previewLocator
   */
  @javax.annotation.Nullable
  public String getPreviewLocator() {
    return previewLocator;
  }

  public void setPreviewLocator(String previewLocator) {
    this.previewLocator = previewLocator;
  }


  public LiveEventPreview streamingPolicyName(String streamingPolicyName) {
    this.streamingPolicyName = streamingPolicyName;
    return this;
  }

  /**
   * The name of streaming policy used for the LiveEvent preview.  This value is specified at creation time and cannot be updated.
   * @return streamingPolicyName
   */
  @javax.annotation.Nullable
  public String getStreamingPolicyName() {
    return streamingPolicyName;
  }

  public void setStreamingPolicyName(String streamingPolicyName) {
    this.streamingPolicyName = streamingPolicyName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LiveEventPreview liveEventPreview = (LiveEventPreview) o;
    return Objects.equals(this.accessControl, liveEventPreview.accessControl) &&
        Objects.equals(this.alternativeMediaId, liveEventPreview.alternativeMediaId) &&
        Objects.equals(this.endpoints, liveEventPreview.endpoints) &&
        Objects.equals(this.previewLocator, liveEventPreview.previewLocator) &&
        Objects.equals(this.streamingPolicyName, liveEventPreview.streamingPolicyName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessControl, alternativeMediaId, endpoints, previewLocator, streamingPolicyName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LiveEventPreview {\n");
    sb.append("    accessControl: ").append(toIndentedString(accessControl)).append("\n");
    sb.append("    alternativeMediaId: ").append(toIndentedString(alternativeMediaId)).append("\n");
    sb.append("    endpoints: ").append(toIndentedString(endpoints)).append("\n");
    sb.append("    previewLocator: ").append(toIndentedString(previewLocator)).append("\n");
    sb.append("    streamingPolicyName: ").append(toIndentedString(streamingPolicyName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessControl");
    openapiFields.add("alternativeMediaId");
    openapiFields.add("endpoints");
    openapiFields.add("previewLocator");
    openapiFields.add("streamingPolicyName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LiveEventPreview
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LiveEventPreview.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LiveEventPreview is not found in the empty JSON string", LiveEventPreview.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LiveEventPreview.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LiveEventPreview` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `accessControl`
      if (jsonObj.get("accessControl") != null && !jsonObj.get("accessControl").isJsonNull()) {
        LiveEventPreviewAccessControl.validateJsonElement(jsonObj.get("accessControl"));
      }
      if ((jsonObj.get("alternativeMediaId") != null && !jsonObj.get("alternativeMediaId").isJsonNull()) && !jsonObj.get("alternativeMediaId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alternativeMediaId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alternativeMediaId").toString()));
      }
      if (jsonObj.get("endpoints") != null && !jsonObj.get("endpoints").isJsonNull()) {
        JsonArray jsonArrayendpoints = jsonObj.getAsJsonArray("endpoints");
        if (jsonArrayendpoints != null) {
          // ensure the json data is an array
          if (!jsonObj.get("endpoints").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `endpoints` to be an array in the JSON string but got `%s`", jsonObj.get("endpoints").toString()));
          }

          // validate the optional field `endpoints` (array)
          for (int i = 0; i < jsonArrayendpoints.size(); i++) {
            LiveEventEndpoint.validateJsonElement(jsonArrayendpoints.get(i));
          };
        }
      }
      if ((jsonObj.get("previewLocator") != null && !jsonObj.get("previewLocator").isJsonNull()) && !jsonObj.get("previewLocator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `previewLocator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("previewLocator").toString()));
      }
      if ((jsonObj.get("streamingPolicyName") != null && !jsonObj.get("streamingPolicyName").isJsonNull()) && !jsonObj.get("streamingPolicyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streamingPolicyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streamingPolicyName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LiveEventPreview.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LiveEventPreview' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LiveEventPreview> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LiveEventPreview.class));

       return (TypeAdapter<T>) new TypeAdapter<LiveEventPreview>() {
           @Override
           public void write(JsonWriter out, LiveEventPreview value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LiveEventPreview read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LiveEventPreview given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LiveEventPreview
   * @throws IOException if the JSON string is invalid with respect to LiveEventPreview
   */
  public static LiveEventPreview fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LiveEventPreview.class);
  }

  /**
   * Convert an instance of LiveEventPreview to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

