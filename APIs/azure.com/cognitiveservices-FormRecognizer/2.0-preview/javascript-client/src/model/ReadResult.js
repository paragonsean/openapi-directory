/**
 * Form Recognizer Client
 * Extracts information from forms and images into structured data.
 *
 * The version of the OpenAPI document: 2.0-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Language from './Language';
import TextLine from './TextLine';

/**
 * The ReadResult model module.
 * @module model/ReadResult
 * @version 2.0-preview
 */
class ReadResult {
    /**
     * Constructs a new <code>ReadResult</code>.
     * Text extracted from a page in the input document.
     * @alias module:model/ReadResult
     * @param angle {Number} The general orientation of the text in clockwise direction, measured in degrees between (-180, 180].
     * @param height {Number} The height of the image/PDF in pixels/inches, respectively.
     * @param page {Number} The 1-based page number in the input document.
     * @param unit {module:model/ReadResult.UnitEnum} The unit used by the width, height and boundingBox properties. For images, the unit is \"pixel\". For PDF, the unit is \"inch\".
     * @param width {Number} The width of the image/PDF in pixels/inches, respectively.
     */
    constructor(angle, height, page, unit, width) { 
        
        ReadResult.initialize(this, angle, height, page, unit, width);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, angle, height, page, unit, width) { 
        obj['angle'] = angle;
        obj['height'] = height;
        obj['page'] = page;
        obj['unit'] = unit;
        obj['width'] = width;
    }

    /**
     * Constructs a <code>ReadResult</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ReadResult} obj Optional instance to populate.
     * @return {module:model/ReadResult} The populated <code>ReadResult</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ReadResult();

            if (data.hasOwnProperty('angle')) {
                obj['angle'] = ApiClient.convertToType(data['angle'], 'Number');
            }
            if (data.hasOwnProperty('height')) {
                obj['height'] = ApiClient.convertToType(data['height'], 'Number');
            }
            if (data.hasOwnProperty('language')) {
                obj['language'] = Language.constructFromObject(data['language']);
            }
            if (data.hasOwnProperty('lines')) {
                obj['lines'] = ApiClient.convertToType(data['lines'], [TextLine]);
            }
            if (data.hasOwnProperty('page')) {
                obj['page'] = ApiClient.convertToType(data['page'], 'Number');
            }
            if (data.hasOwnProperty('unit')) {
                obj['unit'] = ApiClient.convertToType(data['unit'], 'String');
            }
            if (data.hasOwnProperty('width')) {
                obj['width'] = ApiClient.convertToType(data['width'], 'Number');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ReadResult</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ReadResult</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of ReadResult.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        if (data['lines']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['lines'])) {
                throw new Error("Expected the field `lines` to be an array in the JSON data but got " + data['lines']);
            }
            // validate the optional field `lines` (array)
            for (const item of data['lines']) {
                TextLine.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['unit'] && !(typeof data['unit'] === 'string' || data['unit'] instanceof String)) {
            throw new Error("Expected the field `unit` to be a primitive type in the JSON string but got " + data['unit']);
        }

        return true;
    }


}

ReadResult.RequiredProperties = ["angle", "height", "page", "unit", "width"];

/**
 * The general orientation of the text in clockwise direction, measured in degrees between (-180, 180].
 * @member {Number} angle
 */
ReadResult.prototype['angle'] = undefined;

/**
 * The height of the image/PDF in pixels/inches, respectively.
 * @member {Number} height
 */
ReadResult.prototype['height'] = undefined;

/**
 * @member {module:model/Language} language
 */
ReadResult.prototype['language'] = undefined;

/**
 * When includeTextDetails is set to true, a list of recognized text lines. The maximum number of lines returned is 300 per page. The lines are sorted top to bottom, left to right, although in certain cases proximity is treated with higher priority. As the sorting order depends on the detected text, it may change across images and OCR version updates. Thus, business logic should be built upon the actual line location instead of order.
 * @member {Array.<module:model/TextLine>} lines
 */
ReadResult.prototype['lines'] = undefined;

/**
 * The 1-based page number in the input document.
 * @member {Number} page
 */
ReadResult.prototype['page'] = undefined;

/**
 * The unit used by the width, height and boundingBox properties. For images, the unit is \"pixel\". For PDF, the unit is \"inch\".
 * @member {module:model/ReadResult.UnitEnum} unit
 */
ReadResult.prototype['unit'] = undefined;

/**
 * The width of the image/PDF in pixels/inches, respectively.
 * @member {Number} width
 */
ReadResult.prototype['width'] = undefined;





/**
 * Allowed values for the <code>unit</code> property.
 * @enum {String}
 * @readonly
 */
ReadResult['UnitEnum'] = {

    /**
     * value: "pixel"
     * @const
     */
    "pixel": "pixel",

    /**
     * value: "inch"
     * @const
     */
    "inch": "inch"
};



export default ReadResult;

