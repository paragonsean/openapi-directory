/*
 * Face Client
 * An API for face detection, verification, and identification.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.APIError;
import org.openapitools.client.model.ApplySnapshotRequest;
import org.openapitools.client.model.DetectedFace;
import org.openapitools.client.model.FaceDetectWithUrlRequest;
import org.openapitools.client.model.FaceList;
import org.openapitools.client.model.FindSimilarRequest;
import org.openapitools.client.model.GroupRequest;
import org.openapitools.client.model.GroupResult;
import org.openapitools.client.model.IdentifyRequest;
import org.openapitools.client.model.IdentifyResult;
import org.openapitools.client.model.LargeFaceList;
import org.openapitools.client.model.LargePersonGroup;
import org.openapitools.client.model.MetaDataContract;
import org.openapitools.client.model.NameAndUserDataContract;
import org.openapitools.client.model.OperationStatus;
import org.openapitools.client.model.PersistedFace;
import org.openapitools.client.model.Person;
import org.openapitools.client.model.PersonGroup;
import org.openapitools.client.model.SimilarFace;
import org.openapitools.client.model.Snapshot;
import org.openapitools.client.model.TakeSnapshotRequest;
import org.openapitools.client.model.TrainingStatus;
import java.util.UUID;
import org.openapitools.client.model.UpdateFaceRequest;
import org.openapitools.client.model.UpdateSnapshotRequest;
import org.openapitools.client.model.VerifyFaceToFaceRequest;
import org.openapitools.client.model.VerifyResult;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for faceDetectWithUrl
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param returnFaceId A value indicating whether the operation should return faceIds of detected faces. (optional, default to true)
     * @param returnFaceLandmarks A value indicating whether the operation should return landmarks of the detected faces. (optional, default to false)
     * @param returnFaceAttributes Analyze and return the one or more specified face attributes in the comma-separated string like \&quot;returnFaceAttributes&#x3D;age,gender\&quot;. Supported face attributes include age, gender, headPose, smile, facialHair, glasses and emotion. Note that each face attribute analysis has additional computational and time cost. (optional)
     * @param recognitionModel Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is &#39;recognition_01&#39;, if latest model needed, please explicitly specify the model you need. (optional, default to recognition_01)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face entries ranked by face rectangle size in descending order. An empty response indicates no faces detected. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceDetectWithUrlCall(FaceDetectWithUrlRequest imageUrl, Boolean returnFaceId, Boolean returnFaceLandmarks, List<String> returnFaceAttributes, String recognitionModel, Boolean returnRecognitionModel, String detectionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = imageUrl;

        // create path and map variables
        String localVarPath = "/detect";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (returnFaceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnFaceId", returnFaceId));
        }

        if (returnFaceLandmarks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnFaceLandmarks", returnFaceLandmarks));
        }

        if (returnFaceAttributes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "returnFaceAttributes", returnFaceAttributes));
        }

        if (recognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recognitionModel", recognitionModel));
        }

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        if (detectionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("detectionModel", detectionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceDetectWithUrlValidateBeforeCall(FaceDetectWithUrlRequest imageUrl, Boolean returnFaceId, Boolean returnFaceLandmarks, List<String> returnFaceAttributes, String recognitionModel, Boolean returnRecognitionModel, String detectionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'imageUrl' is set
        if (imageUrl == null) {
            throw new ApiException("Missing the required parameter 'imageUrl' when calling faceDetectWithUrl(Async)");
        }

        return faceDetectWithUrlCall(imageUrl, returnFaceId, returnFaceLandmarks, returnFaceAttributes, recognitionModel, returnRecognitionModel, detectionModel, _callback);

    }

    /**
     * 
     * Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks, and attributes.&lt;br /&gt; * No image will be stored. Only the extracted face feature will be stored on server. The faceId is an identifier of the face feature and will be used in [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). The stored face feature(s) will expire and be deleted 24 hours after the original detection call. * Optional parameters include faceId, landmarks, and attributes. Attributes include age, gender, headPose, smile, facialHair, glasses, emotion, hair, makeup, occlusion, accessories, blur, exposure and noise. Some of the results returned for specific attributes may not be highly accurate. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * Up to 100 faces can be returned for an image. Faces are ranked by face rectangle size from large to small. * For optimal results when querying [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) (&#39;returnFaceId&#39; is true), please use faces that are: frontal, clear, and with a minimum size of 200x200 pixels (100 pixels between eyes). * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |  * Different &#39;recognitionModel&#39; values are provided. If follow-up operations like Verify, Identify, Find Similar are needed, please specify the recognition model with &#39;recognitionModel&#39; parameter. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if latest model needed, please explicitly specify the model you need in this parameter. Once specified, the detected faceIds will be associated with the specified recognition model. More details, please refer to [How to specify a recognition model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-recognition-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;recognition_01&#39;: | The default recognition model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). All those faceIds created before 2019 March are bonded with this recognition model. |   | &#39;recognition_02&#39;: | Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;. |
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param returnFaceId A value indicating whether the operation should return faceIds of detected faces. (optional, default to true)
     * @param returnFaceLandmarks A value indicating whether the operation should return landmarks of the detected faces. (optional, default to false)
     * @param returnFaceAttributes Analyze and return the one or more specified face attributes in the comma-separated string like \&quot;returnFaceAttributes&#x3D;age,gender\&quot;. Supported face attributes include age, gender, headPose, smile, facialHair, glasses and emotion. Note that each face attribute analysis has additional computational and time cost. (optional)
     * @param recognitionModel Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is &#39;recognition_01&#39;, if latest model needed, please explicitly specify the model you need. (optional, default to recognition_01)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return List&lt;DetectedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face entries ranked by face rectangle size in descending order. An empty response indicates no faces detected. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<DetectedFace> faceDetectWithUrl(FaceDetectWithUrlRequest imageUrl, Boolean returnFaceId, Boolean returnFaceLandmarks, List<String> returnFaceAttributes, String recognitionModel, Boolean returnRecognitionModel, String detectionModel) throws ApiException {
        ApiResponse<List<DetectedFace>> localVarResp = faceDetectWithUrlWithHttpInfo(imageUrl, returnFaceId, returnFaceLandmarks, returnFaceAttributes, recognitionModel, returnRecognitionModel, detectionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks, and attributes.&lt;br /&gt; * No image will be stored. Only the extracted face feature will be stored on server. The faceId is an identifier of the face feature and will be used in [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). The stored face feature(s) will expire and be deleted 24 hours after the original detection call. * Optional parameters include faceId, landmarks, and attributes. Attributes include age, gender, headPose, smile, facialHair, glasses, emotion, hair, makeup, occlusion, accessories, blur, exposure and noise. Some of the results returned for specific attributes may not be highly accurate. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * Up to 100 faces can be returned for an image. Faces are ranked by face rectangle size from large to small. * For optimal results when querying [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) (&#39;returnFaceId&#39; is true), please use faces that are: frontal, clear, and with a minimum size of 200x200 pixels (100 pixels between eyes). * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |  * Different &#39;recognitionModel&#39; values are provided. If follow-up operations like Verify, Identify, Find Similar are needed, please specify the recognition model with &#39;recognitionModel&#39; parameter. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if latest model needed, please explicitly specify the model you need in this parameter. Once specified, the detected faceIds will be associated with the specified recognition model. More details, please refer to [How to specify a recognition model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-recognition-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;recognition_01&#39;: | The default recognition model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). All those faceIds created before 2019 March are bonded with this recognition model. |   | &#39;recognition_02&#39;: | Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;. |
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param returnFaceId A value indicating whether the operation should return faceIds of detected faces. (optional, default to true)
     * @param returnFaceLandmarks A value indicating whether the operation should return landmarks of the detected faces. (optional, default to false)
     * @param returnFaceAttributes Analyze and return the one or more specified face attributes in the comma-separated string like \&quot;returnFaceAttributes&#x3D;age,gender\&quot;. Supported face attributes include age, gender, headPose, smile, facialHair, glasses and emotion. Note that each face attribute analysis has additional computational and time cost. (optional)
     * @param recognitionModel Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is &#39;recognition_01&#39;, if latest model needed, please explicitly specify the model you need. (optional, default to recognition_01)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return ApiResponse&lt;List&lt;DetectedFace&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face entries ranked by face rectangle size in descending order. An empty response indicates no faces detected. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DetectedFace>> faceDetectWithUrlWithHttpInfo(FaceDetectWithUrlRequest imageUrl, Boolean returnFaceId, Boolean returnFaceLandmarks, List<String> returnFaceAttributes, String recognitionModel, Boolean returnRecognitionModel, String detectionModel) throws ApiException {
        okhttp3.Call localVarCall = faceDetectWithUrlValidateBeforeCall(imageUrl, returnFaceId, returnFaceLandmarks, returnFaceAttributes, recognitionModel, returnRecognitionModel, detectionModel, null);
        Type localVarReturnType = new TypeToken<List<DetectedFace>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks, and attributes.&lt;br /&gt; * No image will be stored. Only the extracted face feature will be stored on server. The faceId is an identifier of the face feature and will be used in [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). The stored face feature(s) will expire and be deleted 24 hours after the original detection call. * Optional parameters include faceId, landmarks, and attributes. Attributes include age, gender, headPose, smile, facialHair, glasses, emotion, hair, makeup, occlusion, accessories, blur, exposure and noise. Some of the results returned for specific attributes may not be highly accurate. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * Up to 100 faces can be returned for an image. Faces are ranked by face rectangle size from large to small. * For optimal results when querying [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) (&#39;returnFaceId&#39; is true), please use faces that are: frontal, clear, and with a minimum size of 200x200 pixels (100 pixels between eyes). * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |  * Different &#39;recognitionModel&#39; values are provided. If follow-up operations like Verify, Identify, Find Similar are needed, please specify the recognition model with &#39;recognitionModel&#39; parameter. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if latest model needed, please explicitly specify the model you need in this parameter. Once specified, the detected faceIds will be associated with the specified recognition model. More details, please refer to [How to specify a recognition model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-recognition-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;recognition_01&#39;: | The default recognition model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). All those faceIds created before 2019 March are bonded with this recognition model. |   | &#39;recognition_02&#39;: | Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;. |
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param returnFaceId A value indicating whether the operation should return faceIds of detected faces. (optional, default to true)
     * @param returnFaceLandmarks A value indicating whether the operation should return landmarks of the detected faces. (optional, default to false)
     * @param returnFaceAttributes Analyze and return the one or more specified face attributes in the comma-separated string like \&quot;returnFaceAttributes&#x3D;age,gender\&quot;. Supported face attributes include age, gender, headPose, smile, facialHair, glasses and emotion. Note that each face attribute analysis has additional computational and time cost. (optional)
     * @param recognitionModel Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is &#39;recognition_01&#39;, if latest model needed, please explicitly specify the model you need. (optional, default to recognition_01)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face entries ranked by face rectangle size in descending order. An empty response indicates no faces detected. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceDetectWithUrlAsync(FaceDetectWithUrlRequest imageUrl, Boolean returnFaceId, Boolean returnFaceLandmarks, List<String> returnFaceAttributes, String recognitionModel, Boolean returnRecognitionModel, String detectionModel, final ApiCallback<List<DetectedFace>> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceDetectWithUrlValidateBeforeCall(imageUrl, returnFaceId, returnFaceLandmarks, returnFaceAttributes, recognitionModel, returnRecognitionModel, detectionModel, _callback);
        Type localVarReturnType = new TypeToken<List<DetectedFace>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceFindSimilar
     * @param body Request body for Find Similar. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of the most similar faces represented in faceId if the input parameter is faceIds or persistedFaceId if the input parameter is faceListId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceFindSimilarCall(FindSimilarRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/findsimilars";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceFindSimilarValidateBeforeCall(FindSimilarRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling faceFindSimilar(Async)");
        }

        return faceFindSimilarCall(body, _callback);

    }

    /**
     * 
     * Given query face&#39;s faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. faceId array contains the faces created by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), which will expire 24 hours after creation. A \&quot;faceListId\&quot; is created by [FaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b) containing persistedFaceIds that will not expire. And a \&quot;largeFaceListId\&quot; is created by [LargeFaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) containing persistedFaceIds that will also not expire. Depending on the input the returned similar faces list contains faceIds or persistedFaceIds ranked by similarity. &lt;br/&gt;Find similar has two working modes, \&quot;matchPerson\&quot; and \&quot;matchFace\&quot;. \&quot;matchPerson\&quot; is the default mode that it tries to find faces of the same person as possible by using internal same-person thresholds. It is useful to find a known person&#39;s other photos. Note that an empty list will be returned if no faces pass the internal thresholds. \&quot;matchFace\&quot; mode ignores same-person thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used in the cases like searching celebrity-looking faces. &lt;br/&gt;The &#39;recognitionModel&#39; associated with the query face&#39;s faceId should be the same as the &#39;recognitionModel&#39; used by the target faceId array, face list or large face list. 
     * @param body Request body for Find Similar. (required)
     * @return List&lt;SimilarFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of the most similar faces represented in faceId if the input parameter is faceIds or persistedFaceId if the input parameter is faceListId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<SimilarFace> faceFindSimilar(FindSimilarRequest body) throws ApiException {
        ApiResponse<List<SimilarFace>> localVarResp = faceFindSimilarWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * 
     * Given query face&#39;s faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. faceId array contains the faces created by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), which will expire 24 hours after creation. A \&quot;faceListId\&quot; is created by [FaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b) containing persistedFaceIds that will not expire. And a \&quot;largeFaceListId\&quot; is created by [LargeFaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) containing persistedFaceIds that will also not expire. Depending on the input the returned similar faces list contains faceIds or persistedFaceIds ranked by similarity. &lt;br/&gt;Find similar has two working modes, \&quot;matchPerson\&quot; and \&quot;matchFace\&quot;. \&quot;matchPerson\&quot; is the default mode that it tries to find faces of the same person as possible by using internal same-person thresholds. It is useful to find a known person&#39;s other photos. Note that an empty list will be returned if no faces pass the internal thresholds. \&quot;matchFace\&quot; mode ignores same-person thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used in the cases like searching celebrity-looking faces. &lt;br/&gt;The &#39;recognitionModel&#39; associated with the query face&#39;s faceId should be the same as the &#39;recognitionModel&#39; used by the target faceId array, face list or large face list. 
     * @param body Request body for Find Similar. (required)
     * @return ApiResponse&lt;List&lt;SimilarFace&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of the most similar faces represented in faceId if the input parameter is faceIds or persistedFaceId if the input parameter is faceListId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<SimilarFace>> faceFindSimilarWithHttpInfo(FindSimilarRequest body) throws ApiException {
        okhttp3.Call localVarCall = faceFindSimilarValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<List<SimilarFace>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Given query face&#39;s faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. faceId array contains the faces created by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), which will expire 24 hours after creation. A \&quot;faceListId\&quot; is created by [FaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b) containing persistedFaceIds that will not expire. And a \&quot;largeFaceListId\&quot; is created by [LargeFaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) containing persistedFaceIds that will also not expire. Depending on the input the returned similar faces list contains faceIds or persistedFaceIds ranked by similarity. &lt;br/&gt;Find similar has two working modes, \&quot;matchPerson\&quot; and \&quot;matchFace\&quot;. \&quot;matchPerson\&quot; is the default mode that it tries to find faces of the same person as possible by using internal same-person thresholds. It is useful to find a known person&#39;s other photos. Note that an empty list will be returned if no faces pass the internal thresholds. \&quot;matchFace\&quot; mode ignores same-person thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used in the cases like searching celebrity-looking faces. &lt;br/&gt;The &#39;recognitionModel&#39; associated with the query face&#39;s faceId should be the same as the &#39;recognitionModel&#39; used by the target faceId array, face list or large face list. 
     * @param body Request body for Find Similar. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of the most similar faces represented in faceId if the input parameter is faceIds or persistedFaceId if the input parameter is faceListId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceFindSimilarAsync(FindSimilarRequest body, final ApiCallback<List<SimilarFace>> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceFindSimilarValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<List<SimilarFace>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceGroup
     * @param body Request body for grouping. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns one or more groups of similar faces (rank by group size) and a messyGroup. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceGroupCall(GroupRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/group";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceGroupValidateBeforeCall(GroupRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling faceGroup(Async)");
        }

        return faceGroupCall(body, _callback);

    }

    /**
     * 
     * Divide candidate faces into groups based on face similarity.&lt;br /&gt; * The output is one or more disjointed face groups and a messyGroup. A face group contains faces that have similar looking, often of the same person. Face groups are ranked by group size, i.e. number of faces. Notice that faces belonging to a same person might be split into several groups in the result. * MessyGroup is a special face group containing faces that cannot find any similar counterpart face from original faces. The messyGroup will not appear in the result if all faces found their counterparts. * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a) when you only have 2 candidate faces. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same. 
     * @param body Request body for grouping. (required)
     * @return GroupResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns one or more groups of similar faces (rank by group size) and a messyGroup. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public GroupResult faceGroup(GroupRequest body) throws ApiException {
        ApiResponse<GroupResult> localVarResp = faceGroupWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * 
     * Divide candidate faces into groups based on face similarity.&lt;br /&gt; * The output is one or more disjointed face groups and a messyGroup. A face group contains faces that have similar looking, often of the same person. Face groups are ranked by group size, i.e. number of faces. Notice that faces belonging to a same person might be split into several groups in the result. * MessyGroup is a special face group containing faces that cannot find any similar counterpart face from original faces. The messyGroup will not appear in the result if all faces found their counterparts. * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a) when you only have 2 candidate faces. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same. 
     * @param body Request body for grouping. (required)
     * @return ApiResponse&lt;GroupResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns one or more groups of similar faces (rank by group size) and a messyGroup. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GroupResult> faceGroupWithHttpInfo(GroupRequest body) throws ApiException {
        okhttp3.Call localVarCall = faceGroupValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<GroupResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Divide candidate faces into groups based on face similarity.&lt;br /&gt; * The output is one or more disjointed face groups and a messyGroup. A face group contains faces that have similar looking, often of the same person. Face groups are ranked by group size, i.e. number of faces. Notice that faces belonging to a same person might be split into several groups in the result. * MessyGroup is a special face group containing faces that cannot find any similar counterpart face from original faces. The messyGroup will not appear in the result if all faces found their counterparts. * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a) when you only have 2 candidate faces. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same. 
     * @param body Request body for grouping. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns one or more groups of similar faces (rank by group size) and a messyGroup. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceGroupAsync(GroupRequest body, final ApiCallback<GroupResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceGroupValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<GroupResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceIdentify
     * @param body Request body for identify operation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the identified candidate person(s) for each query face. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceIdentifyCall(IdentifyRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/identify";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceIdentifyValidateBeforeCall(IdentifyRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling faceIdentify(Async)");
        }

        return faceIdentifyCall(body, _callback);

    }

    /**
     * 
     * 1-to-many identification to find the closest matches of the specific query person face from a person group or large person group. &lt;br/&gt; For each face in the faceIds array, Face Identify will compute similarities between the query face and all the faces in the person group (given by personGroupId) or large person group (given by largePersonGroupId), and return candidate person(s) for that face ranked by similarity confidence. The person group/large person group should be trained to make it ready for identification. See more in [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) and [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4). &lt;br/&gt;   Remarks:&lt;br /&gt; * The algorithm allows more than one face to be identified independently at the same request, but no more than 10 faces. * Each person in the person group/large person group could have more than one face, but no more than 248 faces. * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Number of candidates returned is restricted by maxNumOfCandidatesReturned and confidenceThreshold. If no person is identified, the returned candidates will be an empty array. * Try [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) when you need to find similar faces from a face list/large face list instead of a person group/large person group. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same as the &#39;recognitionModel&#39; used by the target person group or large person group. 
     * @param body Request body for identify operation. (required)
     * @return List&lt;IdentifyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the identified candidate person(s) for each query face. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<IdentifyResult> faceIdentify(IdentifyRequest body) throws ApiException {
        ApiResponse<List<IdentifyResult>> localVarResp = faceIdentifyWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * 
     * 1-to-many identification to find the closest matches of the specific query person face from a person group or large person group. &lt;br/&gt; For each face in the faceIds array, Face Identify will compute similarities between the query face and all the faces in the person group (given by personGroupId) or large person group (given by largePersonGroupId), and return candidate person(s) for that face ranked by similarity confidence. The person group/large person group should be trained to make it ready for identification. See more in [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) and [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4). &lt;br/&gt;   Remarks:&lt;br /&gt; * The algorithm allows more than one face to be identified independently at the same request, but no more than 10 faces. * Each person in the person group/large person group could have more than one face, but no more than 248 faces. * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Number of candidates returned is restricted by maxNumOfCandidatesReturned and confidenceThreshold. If no person is identified, the returned candidates will be an empty array. * Try [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) when you need to find similar faces from a face list/large face list instead of a person group/large person group. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same as the &#39;recognitionModel&#39; used by the target person group or large person group. 
     * @param body Request body for identify operation. (required)
     * @return ApiResponse&lt;List&lt;IdentifyResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the identified candidate person(s) for each query face. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<IdentifyResult>> faceIdentifyWithHttpInfo(IdentifyRequest body) throws ApiException {
        okhttp3.Call localVarCall = faceIdentifyValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<List<IdentifyResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 1-to-many identification to find the closest matches of the specific query person face from a person group or large person group. &lt;br/&gt; For each face in the faceIds array, Face Identify will compute similarities between the query face and all the faces in the person group (given by personGroupId) or large person group (given by largePersonGroupId), and return candidate person(s) for that face ranked by similarity confidence. The person group/large person group should be trained to make it ready for identification. See more in [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) and [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4). &lt;br/&gt;   Remarks:&lt;br /&gt; * The algorithm allows more than one face to be identified independently at the same request, but no more than 10 faces. * Each person in the person group/large person group could have more than one face, but no more than 248 faces. * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Number of candidates returned is restricted by maxNumOfCandidatesReturned and confidenceThreshold. If no person is identified, the returned candidates will be an empty array. * Try [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) when you need to find similar faces from a face list/large face list instead of a person group/large person group. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same as the &#39;recognitionModel&#39; used by the target person group or large person group. 
     * @param body Request body for identify operation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the identified candidate person(s) for each query face. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceIdentifyAsync(IdentifyRequest body, final ApiCallback<List<IdentifyResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceIdentifyValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<List<IdentifyResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceListAddFaceFromUrl
     * @param faceListId Id referencing a particular face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListAddFaceFromUrlCall(String faceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = imageUrl;

        // create path and map variables
        String localVarPath = "/facelists/{faceListId}/persistedfaces"
            .replace("{" + "faceListId" + "}", localVarApiClient.escapeString(faceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userData", userData));
        }

        if (targetFace != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "targetFace", targetFace));
        }

        if (detectionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("detectionModel", detectionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceListAddFaceFromUrlValidateBeforeCall(String faceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'faceListId' is set
        if (faceListId == null) {
            throw new ApiException("Missing the required parameter 'faceListId' when calling faceListAddFaceFromUrl(Async)");
        }

        // verify the required parameter 'imageUrl' is set
        if (imageUrl == null) {
            throw new ApiException("Missing the required parameter 'imageUrl' when calling faceListAddFaceFromUrl(Async)");
        }

        return faceListAddFaceFromUrlCall(faceListId, imageUrl, userData, targetFace, detectionModel, _callback);

    }

    /**
     * 
     * Add a face to a specified face list, up to 1,000 faces. &lt;br /&gt; To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [FaceList - Delete Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395251) or [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better detection and recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param faceListId Id referencing a particular face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return PersistedFace
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersistedFace faceListAddFaceFromUrl(String faceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        ApiResponse<PersistedFace> localVarResp = faceListAddFaceFromUrlWithHttpInfo(faceListId, imageUrl, userData, targetFace, detectionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Add a face to a specified face list, up to 1,000 faces. &lt;br /&gt; To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [FaceList - Delete Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395251) or [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better detection and recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param faceListId Id referencing a particular face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return ApiResponse&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersistedFace> faceListAddFaceFromUrlWithHttpInfo(String faceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        okhttp3.Call localVarCall = faceListAddFaceFromUrlValidateBeforeCall(faceListId, imageUrl, userData, targetFace, detectionModel, null);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Add a face to a specified face list, up to 1,000 faces. &lt;br /&gt; To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [FaceList - Delete Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395251) or [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better detection and recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param faceListId Id referencing a particular face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListAddFaceFromUrlAsync(String faceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback<PersistedFace> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceListAddFaceFromUrlValidateBeforeCall(faceListId, imageUrl, userData, targetFace, detectionModel, _callback);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceListCreate
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for creating a face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListCreateCall(String faceListId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/facelists/{faceListId}"
            .replace("{" + "faceListId" + "}", localVarApiClient.escapeString(faceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceListCreateValidateBeforeCall(String faceListId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'faceListId' is set
        if (faceListId == null) {
            throw new ApiException("Missing the required parameter 'faceListId' when calling faceListCreate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling faceListCreate(Async)");
        }

        return faceListCreateCall(faceListId, body, _callback);

    }

    /**
     * 
     * Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel. Up to 64 face lists are allowed in one subscription. &lt;br /&gt; Face list is a list of faces, up to 1,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). &lt;br /&gt; After creation, user should use [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250) to import the faces. No image will be stored. Only the extracted face features are stored on server until [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called. &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; Please consider [LargeFaceList](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) when the face number is large. It can support up to 1,000,000 faces. &lt;br /&gt;&#39;recognitionModel&#39; should be specified to associate with this face list. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing face list will use the recognition model that&#39;s already associated with the collection. Existing face features in a face list can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [FaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b). All those face lists created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for creating a face list. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void faceListCreate(String faceListId, MetaDataContract body) throws ApiException {
        faceListCreateWithHttpInfo(faceListId, body);
    }

    /**
     * 
     * Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel. Up to 64 face lists are allowed in one subscription. &lt;br /&gt; Face list is a list of faces, up to 1,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). &lt;br /&gt; After creation, user should use [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250) to import the faces. No image will be stored. Only the extracted face features are stored on server until [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called. &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; Please consider [LargeFaceList](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) when the face number is large. It can support up to 1,000,000 faces. &lt;br /&gt;&#39;recognitionModel&#39; should be specified to associate with this face list. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing face list will use the recognition model that&#39;s already associated with the collection. Existing face features in a face list can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [FaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b). All those face lists created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for creating a face list. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> faceListCreateWithHttpInfo(String faceListId, MetaDataContract body) throws ApiException {
        okhttp3.Call localVarCall = faceListCreateValidateBeforeCall(faceListId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel. Up to 64 face lists are allowed in one subscription. &lt;br /&gt; Face list is a list of faces, up to 1,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). &lt;br /&gt; After creation, user should use [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250) to import the faces. No image will be stored. Only the extracted face features are stored on server until [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called. &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; Please consider [LargeFaceList](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) when the face number is large. It can support up to 1,000,000 faces. &lt;br /&gt;&#39;recognitionModel&#39; should be specified to associate with this face list. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing face list will use the recognition model that&#39;s already associated with the collection. Existing face features in a face list can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [FaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b). All those face lists created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for creating a face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListCreateAsync(String faceListId, MetaDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceListCreateValidateBeforeCall(faceListId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceListDelete
     * @param faceListId Id referencing a particular face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListDeleteCall(String faceListId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/facelists/{faceListId}"
            .replace("{" + "faceListId" + "}", localVarApiClient.escapeString(faceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceListDeleteValidateBeforeCall(String faceListId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'faceListId' is set
        if (faceListId == null) {
            throw new ApiException("Missing the required parameter 'faceListId' when calling faceListDelete(Async)");
        }

        return faceListDeleteCall(faceListId, _callback);

    }

    /**
     * 
     * Delete a specified face list.
     * @param faceListId Id referencing a particular face list. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void faceListDelete(String faceListId) throws ApiException {
        faceListDeleteWithHttpInfo(faceListId);
    }

    /**
     * 
     * Delete a specified face list.
     * @param faceListId Id referencing a particular face list. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> faceListDeleteWithHttpInfo(String faceListId) throws ApiException {
        okhttp3.Call localVarCall = faceListDeleteValidateBeforeCall(faceListId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete a specified face list.
     * @param faceListId Id referencing a particular face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListDeleteAsync(String faceListId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceListDeleteValidateBeforeCall(faceListId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceListDeleteFace
     * @param faceListId Id referencing a particular face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListDeleteFaceCall(String faceListId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/facelists/{faceListId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "faceListId" + "}", localVarApiClient.escapeString(faceListId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceListDeleteFaceValidateBeforeCall(String faceListId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'faceListId' is set
        if (faceListId == null) {
            throw new ApiException("Missing the required parameter 'faceListId' when calling faceListDeleteFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling faceListDeleteFace(Async)");
        }

        return faceListDeleteFaceCall(faceListId, persistedFaceId, _callback);

    }

    /**
     * 
     * Delete a face from a face list by specified faceListId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel.
     * @param faceListId Id referencing a particular face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void faceListDeleteFace(String faceListId, UUID persistedFaceId) throws ApiException {
        faceListDeleteFaceWithHttpInfo(faceListId, persistedFaceId);
    }

    /**
     * 
     * Delete a face from a face list by specified faceListId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel.
     * @param faceListId Id referencing a particular face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> faceListDeleteFaceWithHttpInfo(String faceListId, UUID persistedFaceId) throws ApiException {
        okhttp3.Call localVarCall = faceListDeleteFaceValidateBeforeCall(faceListId, persistedFaceId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete a face from a face list by specified faceListId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel.
     * @param faceListId Id referencing a particular face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListDeleteFaceAsync(String faceListId, UUID persistedFaceId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceListDeleteFaceValidateBeforeCall(faceListId, persistedFaceId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceListGet
     * @param faceListId Id referencing a particular face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListGetCall(String faceListId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/facelists/{faceListId}"
            .replace("{" + "faceListId" + "}", localVarApiClient.escapeString(faceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceListGetValidateBeforeCall(String faceListId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'faceListId' is set
        if (faceListId == null) {
            throw new ApiException("Missing the required parameter 'faceListId' when calling faceListGet(Async)");
        }

        return faceListGetCall(faceListId, returnRecognitionModel, _callback);

    }

    /**
     * 
     * Retrieve a face list’s faceListId, name, userData, recognitionModel and faces in the face list. 
     * @param faceListId Id referencing a particular face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return FaceList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public FaceList faceListGet(String faceListId, Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<FaceList> localVarResp = faceListGetWithHttpInfo(faceListId, returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve a face list’s faceListId, name, userData, recognitionModel and faces in the face list. 
     * @param faceListId Id referencing a particular face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;FaceList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FaceList> faceListGetWithHttpInfo(String faceListId, Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = faceListGetValidateBeforeCall(faceListId, returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<FaceList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve a face list’s faceListId, name, userData, recognitionModel and faces in the face list. 
     * @param faceListId Id referencing a particular face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListGetAsync(String faceListId, Boolean returnRecognitionModel, final ApiCallback<FaceList> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceListGetValidateBeforeCall(faceListId, returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<FaceList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceListList
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of faceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListListCall(Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/facelists";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceListListValidateBeforeCall(Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        return faceListListCall(returnRecognitionModel, _callback);

    }

    /**
     * 
     * List face lists’ faceListId, name, userData and recognitionModel. &lt;br /&gt;  To get face information inside faceList use [FaceList - Get](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c) 
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return List&lt;FaceList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of faceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<FaceList> faceListList(Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<List<FaceList>> localVarResp = faceListListWithHttpInfo(returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * List face lists’ faceListId, name, userData and recognitionModel. &lt;br /&gt;  To get face information inside faceList use [FaceList - Get](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c) 
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;List&lt;FaceList&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of faceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<FaceList>> faceListListWithHttpInfo(Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = faceListListValidateBeforeCall(returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<List<FaceList>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List face lists’ faceListId, name, userData and recognitionModel. &lt;br /&gt;  To get face information inside faceList use [FaceList - Get](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c) 
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of faceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListListAsync(Boolean returnRecognitionModel, final ApiCallback<List<FaceList>> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceListListValidateBeforeCall(returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<List<FaceList>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceListUpdate
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for updating a face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListUpdateCall(String faceListId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/facelists/{faceListId}"
            .replace("{" + "faceListId" + "}", localVarApiClient.escapeString(faceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceListUpdateValidateBeforeCall(String faceListId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'faceListId' is set
        if (faceListId == null) {
            throw new ApiException("Missing the required parameter 'faceListId' when calling faceListUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling faceListUpdate(Async)");
        }

        return faceListUpdateCall(faceListId, body, _callback);

    }

    /**
     * 
     * Update information of a face list.
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for updating a face list. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void faceListUpdate(String faceListId, NameAndUserDataContract body) throws ApiException {
        faceListUpdateWithHttpInfo(faceListId, body);
    }

    /**
     * 
     * Update information of a face list.
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for updating a face list. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> faceListUpdateWithHttpInfo(String faceListId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = faceListUpdateValidateBeforeCall(faceListId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update information of a face list.
     * @param faceListId Id referencing a particular face list. (required)
     * @param body Request body for updating a face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceListUpdateAsync(String faceListId, NameAndUserDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceListUpdateValidateBeforeCall(faceListId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for faceVerifyFaceToFace
     * @param body Request body for face to face verification. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the verification result. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceVerifyFaceToFaceCall(VerifyFaceToFaceRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/verify";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call faceVerifyFaceToFaceValidateBeforeCall(VerifyFaceToFaceRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling faceVerifyFaceToFace(Async)");
        }

        return faceVerifyFaceToFaceCall(body, _callback);

    }

    /**
     * 
     * Verify whether two faces belong to a same person or whether one face belongs to a person. &lt;br/&gt; Remarks:&lt;br /&gt; * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * For the scenarios that are sensitive to accuracy please make your own judgment. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same as the &#39;recognitionModel&#39; used by the target face, person group or large person group. 
     * @param body Request body for face to face verification. (required)
     * @return VerifyResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the verification result. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public VerifyResult faceVerifyFaceToFace(VerifyFaceToFaceRequest body) throws ApiException {
        ApiResponse<VerifyResult> localVarResp = faceVerifyFaceToFaceWithHttpInfo(body);
        return localVarResp.getData();
    }

    /**
     * 
     * Verify whether two faces belong to a same person or whether one face belongs to a person. &lt;br/&gt; Remarks:&lt;br /&gt; * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * For the scenarios that are sensitive to accuracy please make your own judgment. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same as the &#39;recognitionModel&#39; used by the target face, person group or large person group. 
     * @param body Request body for face to face verification. (required)
     * @return ApiResponse&lt;VerifyResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the verification result. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VerifyResult> faceVerifyFaceToFaceWithHttpInfo(VerifyFaceToFaceRequest body) throws ApiException {
        okhttp3.Call localVarCall = faceVerifyFaceToFaceValidateBeforeCall(body, null);
        Type localVarReturnType = new TypeToken<VerifyResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Verify whether two faces belong to a same person or whether one face belongs to a person. &lt;br/&gt; Remarks:&lt;br /&gt; * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * For the scenarios that are sensitive to accuracy please make your own judgment. * The &#39;recognitionModel&#39; associated with the query faces&#39; faceIds should be the same as the &#39;recognitionModel&#39; used by the target face, person group or large person group. 
     * @param body Request body for face to face verification. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the verification result. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call faceVerifyFaceToFaceAsync(VerifyFaceToFaceRequest body, final ApiCallback<VerifyResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = faceVerifyFaceToFaceValidateBeforeCall(body, _callback);
        Type localVarReturnType = new TypeToken<VerifyResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListAddFaceFromUrl
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListAddFaceFromUrlCall(String largeFaceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = imageUrl;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}/persistedfaces"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userData", userData));
        }

        if (targetFace != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "targetFace", targetFace));
        }

        if (detectionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("detectionModel", detectionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListAddFaceFromUrlValidateBeforeCall(String largeFaceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListAddFaceFromUrl(Async)");
        }

        // verify the required parameter 'imageUrl' is set
        if (imageUrl == null) {
            throw new ApiException("Missing the required parameter 'imageUrl' when calling largeFaceListAddFaceFromUrl(Async)");
        }

        return largeFaceListAddFaceFromUrlCall(largeFaceListId, imageUrl, userData, targetFace, detectionModel, _callback);

    }

    /**
     * 
     * Add a face to a specified large face list, up to 1,000,000 faces. &lt;br /&gt; To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargeFaceList Face - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a158c8ad2de3616c086f2d4) or [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [LargeFaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |  Quota: * Free-tier subscription quota: 1,000 faces per large face list. * S0-tier subscription quota: 1,000,000 faces per large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return PersistedFace
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersistedFace largeFaceListAddFaceFromUrl(String largeFaceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        ApiResponse<PersistedFace> localVarResp = largeFaceListAddFaceFromUrlWithHttpInfo(largeFaceListId, imageUrl, userData, targetFace, detectionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Add a face to a specified large face list, up to 1,000,000 faces. &lt;br /&gt; To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargeFaceList Face - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a158c8ad2de3616c086f2d4) or [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [LargeFaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |  Quota: * Free-tier subscription quota: 1,000 faces per large face list. * S0-tier subscription quota: 1,000,000 faces per large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return ApiResponse&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersistedFace> largeFaceListAddFaceFromUrlWithHttpInfo(String largeFaceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListAddFaceFromUrlValidateBeforeCall(largeFaceListId, imageUrl, userData, targetFace, detectionModel, null);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Add a face to a specified large face list, up to 1,000,000 faces. &lt;br /&gt; To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargeFaceList Face - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a158c8ad2de3616c086f2d4) or [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [LargeFaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |  Quota: * Free-tier subscription quota: 1,000 faces per large face list. * S0-tier subscription quota: 1,000,000 faces per large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListAddFaceFromUrlAsync(String largeFaceListId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback<PersistedFace> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListAddFaceFromUrlValidateBeforeCall(largeFaceListId, imageUrl, userData, targetFace, detectionModel, _callback);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListCreate
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for creating a large face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListCreateCall(String largeFaceListId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListCreateValidateBeforeCall(String largeFaceListId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListCreate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largeFaceListCreate(Async)");
        }

        return largeFaceListCreateCall(largeFaceListId, body, _callback);

    }

    /**
     * 
     * Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel. &lt;br /&gt; Large face list is a list of faces, up to 1,000,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). &lt;br /&gt; After creation, user should use [LargeFaceList Face - Add](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3) to import the faces and [LargeFaceList - Train](/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1) to make it ready for [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). No image will be stored. Only the extracted face features are stored on server until [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called. &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this large face list. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large face list will use the recognition model that&#39;s already associated with the collection. Existing face features in a large face list can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [LargeFaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc). All those large face lists created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Large face list quota: * Free-tier subscription quota: 64 large face lists. * S0-tier subscription quota: 1,000,000 large face lists.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for creating a large face list. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largeFaceListCreate(String largeFaceListId, MetaDataContract body) throws ApiException {
        largeFaceListCreateWithHttpInfo(largeFaceListId, body);
    }

    /**
     * 
     * Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel. &lt;br /&gt; Large face list is a list of faces, up to 1,000,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). &lt;br /&gt; After creation, user should use [LargeFaceList Face - Add](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3) to import the faces and [LargeFaceList - Train](/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1) to make it ready for [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). No image will be stored. Only the extracted face features are stored on server until [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called. &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this large face list. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large face list will use the recognition model that&#39;s already associated with the collection. Existing face features in a large face list can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [LargeFaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc). All those large face lists created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Large face list quota: * Free-tier subscription quota: 64 large face lists. * S0-tier subscription quota: 1,000,000 large face lists.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for creating a large face list. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largeFaceListCreateWithHttpInfo(String largeFaceListId, MetaDataContract body) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListCreateValidateBeforeCall(largeFaceListId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel. &lt;br /&gt; Large face list is a list of faces, up to 1,000,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). &lt;br /&gt; After creation, user should use [LargeFaceList Face - Add](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3) to import the faces and [LargeFaceList - Train](/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1) to make it ready for [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). No image will be stored. Only the extracted face features are stored on server until [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called. &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this large face list. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large face list will use the recognition model that&#39;s already associated with the collection. Existing face features in a large face list can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [LargeFaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc). All those large face lists created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Large face list quota: * Free-tier subscription quota: 64 large face lists. * S0-tier subscription quota: 1,000,000 large face lists.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for creating a large face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListCreateAsync(String largeFaceListId, MetaDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListCreateValidateBeforeCall(largeFaceListId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListDelete
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListDeleteCall(String largeFaceListId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListDeleteValidateBeforeCall(String largeFaceListId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListDelete(Async)");
        }

        return largeFaceListDeleteCall(largeFaceListId, _callback);

    }

    /**
     * 
     * Delete a specified large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largeFaceListDelete(String largeFaceListId) throws ApiException {
        largeFaceListDeleteWithHttpInfo(largeFaceListId);
    }

    /**
     * 
     * Delete a specified large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largeFaceListDeleteWithHttpInfo(String largeFaceListId) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListDeleteValidateBeforeCall(largeFaceListId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete a specified large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListDeleteAsync(String largeFaceListId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListDeleteValidateBeforeCall(largeFaceListId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListDeleteFace
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListDeleteFaceCall(String largeFaceListId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListDeleteFaceValidateBeforeCall(String largeFaceListId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListDeleteFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling largeFaceListDeleteFace(Async)");
        }

        return largeFaceListDeleteFaceCall(largeFaceListId, persistedFaceId, _callback);

    }

    /**
     * 
     * Delete a face from a large face list by specified largeFaceListId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same large face list are processed sequentially and to/from different large face lists are in parallel.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largeFaceListDeleteFace(String largeFaceListId, UUID persistedFaceId) throws ApiException {
        largeFaceListDeleteFaceWithHttpInfo(largeFaceListId, persistedFaceId);
    }

    /**
     * 
     * Delete a face from a large face list by specified largeFaceListId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same large face list are processed sequentially and to/from different large face lists are in parallel.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largeFaceListDeleteFaceWithHttpInfo(String largeFaceListId, UUID persistedFaceId) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListDeleteFaceValidateBeforeCall(largeFaceListId, persistedFaceId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete a face from a large face list by specified largeFaceListId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same large face list are processed sequentially and to/from different large face lists are in parallel.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListDeleteFaceAsync(String largeFaceListId, UUID persistedFaceId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListDeleteFaceValidateBeforeCall(largeFaceListId, persistedFaceId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListGet
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListGetCall(String largeFaceListId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListGetValidateBeforeCall(String largeFaceListId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListGet(Async)");
        }

        return largeFaceListGetCall(largeFaceListId, returnRecognitionModel, _callback);

    }

    /**
     * 
     * Retrieve a large face list’s largeFaceListId, name, userData and recognitionModel.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return LargeFaceList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public LargeFaceList largeFaceListGet(String largeFaceListId, Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<LargeFaceList> localVarResp = largeFaceListGetWithHttpInfo(largeFaceListId, returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve a large face list’s largeFaceListId, name, userData and recognitionModel.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;LargeFaceList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LargeFaceList> largeFaceListGetWithHttpInfo(String largeFaceListId, Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListGetValidateBeforeCall(largeFaceListId, returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<LargeFaceList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve a large face list’s largeFaceListId, name, userData and recognitionModel.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListGetAsync(String largeFaceListId, Boolean returnRecognitionModel, final ApiCallback<LargeFaceList> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListGetValidateBeforeCall(largeFaceListId, returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<LargeFaceList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListGetFace
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListGetFaceCall(String largeFaceListId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListGetFaceValidateBeforeCall(String largeFaceListId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListGetFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling largeFaceListGetFace(Async)");
        }

        return largeFaceListGetFaceCall(largeFaceListId, persistedFaceId, _callback);

    }

    /**
     * 
     * Retrieve information about a persisted face (specified by persistedFaceId and its belonging largeFaceListId).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return PersistedFace
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersistedFace largeFaceListGetFace(String largeFaceListId, UUID persistedFaceId) throws ApiException {
        ApiResponse<PersistedFace> localVarResp = largeFaceListGetFaceWithHttpInfo(largeFaceListId, persistedFaceId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve information about a persisted face (specified by persistedFaceId and its belonging largeFaceListId).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return ApiResponse&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersistedFace> largeFaceListGetFaceWithHttpInfo(String largeFaceListId, UUID persistedFaceId) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListGetFaceValidateBeforeCall(largeFaceListId, persistedFaceId, null);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve information about a persisted face (specified by persistedFaceId and its belonging largeFaceListId).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListGetFaceAsync(String largeFaceListId, UUID persistedFaceId, final ApiCallback<PersistedFace> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListGetFaceValidateBeforeCall(largeFaceListId, persistedFaceId, _callback);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListGetTrainingStatus
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListGetTrainingStatusCall(String largeFaceListId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}/training"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListGetTrainingStatusValidateBeforeCall(String largeFaceListId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListGetTrainingStatus(Async)");
        }

        return largeFaceListGetTrainingStatusCall(largeFaceListId, _callback);

    }

    /**
     * 
     * Retrieve the training status of a large face list (completed or ongoing).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @return TrainingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public TrainingStatus largeFaceListGetTrainingStatus(String largeFaceListId) throws ApiException {
        ApiResponse<TrainingStatus> localVarResp = largeFaceListGetTrainingStatusWithHttpInfo(largeFaceListId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the training status of a large face list (completed or ongoing).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @return ApiResponse&lt;TrainingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TrainingStatus> largeFaceListGetTrainingStatusWithHttpInfo(String largeFaceListId) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListGetTrainingStatusValidateBeforeCall(largeFaceListId, null);
        Type localVarReturnType = new TypeToken<TrainingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the training status of a large face list (completed or ongoing).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large face list&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListGetTrainingStatusAsync(String largeFaceListId, final ApiCallback<TrainingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListGetTrainingStatusValidateBeforeCall(largeFaceListId, _callback);
        Type localVarReturnType = new TypeToken<TrainingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListList
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of largeFaceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListListCall(Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListListValidateBeforeCall(Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        return largeFaceListListCall(returnRecognitionModel, _callback);

    }

    /**
     * 
     * List large face lists’ information of largeFaceListId, name, userData and recognitionModel. &lt;br /&gt;  To get face information inside largeFaceList use [LargeFaceList Face - Get](/docs/services/563879b61984550e40cbbe8d/operations/5a158cf2d2de3616c086f2d5)&lt;br /&gt; * Large face lists are stored in alphabetical order of largeFaceListId. * \&quot;start\&quot; parameter (string, optional) is a user-provided largeFaceListId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 large person lists: \&quot;list1\&quot;, ..., \&quot;list5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 lists. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;list1\&quot;, \&quot;list2\&quot;. &lt;br /&gt; \&quot;start&#x3D;list2&amp;top&#x3D;3\&quot; will return \&quot;list3\&quot;, \&quot;list4\&quot;, \&quot;list5\&quot;. 
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return List&lt;LargeFaceList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of largeFaceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<LargeFaceList> largeFaceListList(Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<List<LargeFaceList>> localVarResp = largeFaceListListWithHttpInfo(returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * List large face lists’ information of largeFaceListId, name, userData and recognitionModel. &lt;br /&gt;  To get face information inside largeFaceList use [LargeFaceList Face - Get](/docs/services/563879b61984550e40cbbe8d/operations/5a158cf2d2de3616c086f2d5)&lt;br /&gt; * Large face lists are stored in alphabetical order of largeFaceListId. * \&quot;start\&quot; parameter (string, optional) is a user-provided largeFaceListId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 large person lists: \&quot;list1\&quot;, ..., \&quot;list5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 lists. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;list1\&quot;, \&quot;list2\&quot;. &lt;br /&gt; \&quot;start&#x3D;list2&amp;top&#x3D;3\&quot; will return \&quot;list3\&quot;, \&quot;list4\&quot;, \&quot;list5\&quot;. 
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;List&lt;LargeFaceList&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of largeFaceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<LargeFaceList>> largeFaceListListWithHttpInfo(Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListListValidateBeforeCall(returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<List<LargeFaceList>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List large face lists’ information of largeFaceListId, name, userData and recognitionModel. &lt;br /&gt;  To get face information inside largeFaceList use [LargeFaceList Face - Get](/docs/services/563879b61984550e40cbbe8d/operations/5a158cf2d2de3616c086f2d5)&lt;br /&gt; * Large face lists are stored in alphabetical order of largeFaceListId. * \&quot;start\&quot; parameter (string, optional) is a user-provided largeFaceListId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 large person lists: \&quot;list1\&quot;, ..., \&quot;list5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 lists. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;list1\&quot;, \&quot;list2\&quot;. &lt;br /&gt; \&quot;start&#x3D;list2&amp;top&#x3D;3\&quot; will return \&quot;list3\&quot;, \&quot;list4\&quot;, \&quot;list5\&quot;. 
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of largeFaceList. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListListAsync(Boolean returnRecognitionModel, final ApiCallback<List<LargeFaceList>> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListListValidateBeforeCall(returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<List<LargeFaceList>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListListFaces
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param start Starting face id to return (used to list a range of faces). (optional)
     * @param top Number of faces to return starting with the face id indicated by the &#39;start&#39; parameter. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face information that belong to the large face list. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListListFacesCall(String largeFaceListId, String start, Integer top, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}/persistedfaces"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (top != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("top", top));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListListFacesValidateBeforeCall(String largeFaceListId, String start, Integer top, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListListFaces(Async)");
        }

        return largeFaceListListFacesCall(largeFaceListId, start, top, _callback);

    }

    /**
     * 
     * List all faces in a large face list, and retrieve face information (including userData and persistedFaceIds of registered faces of the face).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param start Starting face id to return (used to list a range of faces). (optional)
     * @param top Number of faces to return starting with the face id indicated by the &#39;start&#39; parameter. (optional)
     * @return List&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face information that belong to the large face list. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<PersistedFace> largeFaceListListFaces(String largeFaceListId, String start, Integer top) throws ApiException {
        ApiResponse<List<PersistedFace>> localVarResp = largeFaceListListFacesWithHttpInfo(largeFaceListId, start, top);
        return localVarResp.getData();
    }

    /**
     * 
     * List all faces in a large face list, and retrieve face information (including userData and persistedFaceIds of registered faces of the face).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param start Starting face id to return (used to list a range of faces). (optional)
     * @param top Number of faces to return starting with the face id indicated by the &#39;start&#39; parameter. (optional)
     * @return ApiResponse&lt;List&lt;PersistedFace&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face information that belong to the large face list. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<PersistedFace>> largeFaceListListFacesWithHttpInfo(String largeFaceListId, String start, Integer top) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListListFacesValidateBeforeCall(largeFaceListId, start, top, null);
        Type localVarReturnType = new TypeToken<List<PersistedFace>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List all faces in a large face list, and retrieve face information (including userData and persistedFaceIds of registered faces of the face).
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param start Starting face id to return (used to list a range of faces). (optional)
     * @param top Number of faces to return starting with the face id indicated by the &#39;start&#39; parameter. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of face information that belong to the large face list. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListListFacesAsync(String largeFaceListId, String start, Integer top, final ApiCallback<List<PersistedFace>> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListListFacesValidateBeforeCall(largeFaceListId, start, top, _callback);
        Type localVarReturnType = new TypeToken<List<PersistedFace>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListTrain
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListTrainCall(String largeFaceListId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}/train"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListTrainValidateBeforeCall(String largeFaceListId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListTrain(Async)");
        }

        return largeFaceListTrainCall(largeFaceListId, _callback);

    }

    /**
     * 
     * Queue a large face list training task, the training task may not be started immediately.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largeFaceListTrain(String largeFaceListId) throws ApiException {
        largeFaceListTrainWithHttpInfo(largeFaceListId);
    }

    /**
     * 
     * Queue a large face list training task, the training task may not be started immediately.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largeFaceListTrainWithHttpInfo(String largeFaceListId) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListTrainValidateBeforeCall(largeFaceListId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Queue a large face list training task, the training task may not be started immediately.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListTrainAsync(String largeFaceListId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListTrainValidateBeforeCall(largeFaceListId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListUpdate
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for updating a large face list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListUpdateCall(String largeFaceListId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListUpdateValidateBeforeCall(String largeFaceListId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largeFaceListUpdate(Async)");
        }

        return largeFaceListUpdateCall(largeFaceListId, body, _callback);

    }

    /**
     * 
     * Update information of a large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for updating a large face list. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largeFaceListUpdate(String largeFaceListId, NameAndUserDataContract body) throws ApiException {
        largeFaceListUpdateWithHttpInfo(largeFaceListId, body);
    }

    /**
     * 
     * Update information of a large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for updating a large face list. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largeFaceListUpdateWithHttpInfo(String largeFaceListId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListUpdateValidateBeforeCall(largeFaceListId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update information of a large face list.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param body Request body for updating a large face list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListUpdateAsync(String largeFaceListId, NameAndUserDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListUpdateValidateBeforeCall(largeFaceListId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largeFaceListUpdateFace
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListUpdateFaceCall(String largeFaceListId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "largeFaceListId" + "}", localVarApiClient.escapeString(largeFaceListId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largeFaceListUpdateFaceValidateBeforeCall(String largeFaceListId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largeFaceListId' is set
        if (largeFaceListId == null) {
            throw new ApiException("Missing the required parameter 'largeFaceListId' when calling largeFaceListUpdateFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling largeFaceListUpdateFace(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largeFaceListUpdateFace(Async)");
        }

        return largeFaceListUpdateFaceCall(largeFaceListId, persistedFaceId, body, _callback);

    }

    /**
     * 
     * Update a persisted face&#39;s userData field.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largeFaceListUpdateFace(String largeFaceListId, UUID persistedFaceId, UpdateFaceRequest body) throws ApiException {
        largeFaceListUpdateFaceWithHttpInfo(largeFaceListId, persistedFaceId, body);
    }

    /**
     * 
     * Update a persisted face&#39;s userData field.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largeFaceListUpdateFaceWithHttpInfo(String largeFaceListId, UUID persistedFaceId, UpdateFaceRequest body) throws ApiException {
        okhttp3.Call localVarCall = largeFaceListUpdateFaceValidateBeforeCall(largeFaceListId, persistedFaceId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update a persisted face&#39;s userData field.
     * @param largeFaceListId Id referencing a particular large face list. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largeFaceListUpdateFaceAsync(String largeFaceListId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largeFaceListUpdateFaceValidateBeforeCall(largeFaceListId, persistedFaceId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupCreate
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new large person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupCreateCall(String largePersonGroupId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupCreateValidateBeforeCall(String largePersonGroupId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupCreate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largePersonGroupCreate(Async)");
        }

        return largePersonGroupCreateCall(largePersonGroupId, body, _callback);

    }

    /**
     * 
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel. &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people. &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40) to add person into the group, and call [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; No image will be stored. Only the person&#39;s extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called. &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this large person group. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that&#39;s already associated with the collection. Existing face features in a large person group can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [LargePersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d). All those large person groups created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Large person group quota: * Free-tier subscription quota: 1,000 large person groups. * S0-tier subscription quota: 1,000,000 large person groups.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new large person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupCreate(String largePersonGroupId, MetaDataContract body) throws ApiException {
        largePersonGroupCreateWithHttpInfo(largePersonGroupId, body);
    }

    /**
     * 
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel. &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people. &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40) to add person into the group, and call [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; No image will be stored. Only the person&#39;s extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called. &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this large person group. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that&#39;s already associated with the collection. Existing face features in a large person group can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [LargePersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d). All those large person groups created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Large person group quota: * Free-tier subscription quota: 1,000 large person groups. * S0-tier subscription quota: 1,000,000 large person groups.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new large person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupCreateWithHttpInfo(String largePersonGroupId, MetaDataContract body) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupCreateValidateBeforeCall(largePersonGroupId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel. &lt;br /&gt; A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000 people. &lt;br /&gt; After creation, use [LargePersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40) to add person into the group, and call [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; No image will be stored. Only the person&#39;s extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called. &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this large person group. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that&#39;s already associated with the collection. Existing face features in a large person group can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [LargePersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d). All those large person groups created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Large person group quota: * Free-tier subscription quota: 1,000 large person groups. * S0-tier subscription quota: 1,000,000 large person groups.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new large person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupCreateAsync(String largePersonGroupId, MetaDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupCreateValidateBeforeCall(largePersonGroupId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupDelete
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupDeleteCall(String largePersonGroupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupDeleteValidateBeforeCall(String largePersonGroupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupDelete(Async)");
        }

        return largePersonGroupDeleteCall(largePersonGroupId, _callback);

    }

    /**
     * 
     * Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupDelete(String largePersonGroupId) throws ApiException {
        largePersonGroupDeleteWithHttpInfo(largePersonGroupId);
    }

    /**
     * 
     * Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupDeleteWithHttpInfo(String largePersonGroupId) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupDeleteValidateBeforeCall(largePersonGroupId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupDeleteAsync(String largePersonGroupId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupDeleteValidateBeforeCall(largePersonGroupId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupGet
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupGetCall(String largePersonGroupId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupGetValidateBeforeCall(String largePersonGroupId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupGet(Async)");
        }

        return largePersonGroupGetCall(largePersonGroupId, returnRecognitionModel, _callback);

    }

    /**
     * 
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/599adda06ac60f11b48b5aa1) instead to retrieve person information under the large person group. 
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return LargePersonGroup
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public LargePersonGroup largePersonGroupGet(String largePersonGroupId, Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<LargePersonGroup> localVarResp = largePersonGroupGetWithHttpInfo(largePersonGroupId, returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/599adda06ac60f11b48b5aa1) instead to retrieve person information under the large person group. 
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;LargePersonGroup&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<LargePersonGroup> largePersonGroupGetWithHttpInfo(String largePersonGroupId, Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupGetValidateBeforeCall(largePersonGroupId, returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<LargePersonGroup>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/599adda06ac60f11b48b5aa1) instead to retrieve person information under the large person group. 
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupGetAsync(String largePersonGroupId, Boolean returnRecognitionModel, final ApiCallback<LargePersonGroup> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupGetValidateBeforeCall(largePersonGroupId, returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<LargePersonGroup>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupGetTrainingStatus
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupGetTrainingStatusCall(String largePersonGroupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/training"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupGetTrainingStatusValidateBeforeCall(String largePersonGroupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupGetTrainingStatus(Async)");
        }

        return largePersonGroupGetTrainingStatusCall(largePersonGroupId, _callback);

    }

    /**
     * 
     * Retrieve the training status of a large person group (completed or ongoing).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @return TrainingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public TrainingStatus largePersonGroupGetTrainingStatus(String largePersonGroupId) throws ApiException {
        ApiResponse<TrainingStatus> localVarResp = largePersonGroupGetTrainingStatusWithHttpInfo(largePersonGroupId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the training status of a large person group (completed or ongoing).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @return ApiResponse&lt;TrainingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TrainingStatus> largePersonGroupGetTrainingStatusWithHttpInfo(String largePersonGroupId) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupGetTrainingStatusValidateBeforeCall(largePersonGroupId, null);
        Type localVarReturnType = new TypeToken<TrainingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the training status of a large person group (completed or ongoing).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the large person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupGetTrainingStatusAsync(String largePersonGroupId, final ApiCallback<TrainingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupGetTrainingStatusValidateBeforeCall(largePersonGroupId, _callback);
        Type localVarReturnType = new TypeToken<TrainingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupList
     * @param start List large person groups from the least largePersonGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of large person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of large person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupListCall(String start, Integer top, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (top != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("top", top));
        }

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupListValidateBeforeCall(String start, Integer top, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        return largePersonGroupListCall(start, top, returnRecognitionModel, _callback);

    }

    /**
     * 
     * List all existing large person groups’ largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt; * Large person groups are stored in alphabetical order of largePersonGroupId. * \&quot;start\&quot; parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 large person groups: \&quot;group1\&quot;, ..., \&quot;group5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 groups. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;group1\&quot;, \&quot;group2\&quot;. &lt;br /&gt; \&quot;start&#x3D;group2&amp;top&#x3D;3\&quot; will return \&quot;group3\&quot;, \&quot;group4\&quot;, \&quot;group5\&quot;. 
     * @param start List large person groups from the least largePersonGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of large person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return List&lt;LargePersonGroup&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of large person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<LargePersonGroup> largePersonGroupList(String start, Integer top, Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<List<LargePersonGroup>> localVarResp = largePersonGroupListWithHttpInfo(start, top, returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * List all existing large person groups’ largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt; * Large person groups are stored in alphabetical order of largePersonGroupId. * \&quot;start\&quot; parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 large person groups: \&quot;group1\&quot;, ..., \&quot;group5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 groups. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;group1\&quot;, \&quot;group2\&quot;. &lt;br /&gt; \&quot;start&#x3D;group2&amp;top&#x3D;3\&quot; will return \&quot;group3\&quot;, \&quot;group4\&quot;, \&quot;group5\&quot;. 
     * @param start List large person groups from the least largePersonGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of large person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;List&lt;LargePersonGroup&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of large person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<LargePersonGroup>> largePersonGroupListWithHttpInfo(String start, Integer top, Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupListValidateBeforeCall(start, top, returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<List<LargePersonGroup>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List all existing large person groups’ largePersonGroupId, name, userData and recognitionModel.&lt;br /&gt; * Large person groups are stored in alphabetical order of largePersonGroupId. * \&quot;start\&quot; parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 large person groups: \&quot;group1\&quot;, ..., \&quot;group5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 groups. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;group1\&quot;, \&quot;group2\&quot;. &lt;br /&gt; \&quot;start&#x3D;group2&amp;top&#x3D;3\&quot; will return \&quot;group3\&quot;, \&quot;group4\&quot;, \&quot;group5\&quot;. 
     * @param start List large person groups from the least largePersonGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of large person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of large person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupListAsync(String start, Integer top, Boolean returnRecognitionModel, final ApiCallback<List<LargePersonGroup>> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupListValidateBeforeCall(start, top, returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<List<LargePersonGroup>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonAddFaceFromUrl
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonAddFaceFromUrlCall(String largePersonGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = imageUrl;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userData", userData));
        }

        if (targetFace != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "targetFace", targetFace));
        }

        if (detectionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("detectionModel", detectionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonAddFaceFromUrlValidateBeforeCall(String largePersonGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonAddFaceFromUrl(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling largePersonGroupPersonAddFaceFromUrl(Async)");
        }

        // verify the required parameter 'imageUrl' is set
        if (imageUrl == null) {
            throw new ApiException("Missing the required parameter 'imageUrl' when calling largePersonGroupPersonAddFaceFromUrl(Async)");
        }

        return largePersonGroupPersonAddFaceFromUrlCall(largePersonGroupId, personId, imageUrl, userData, targetFace, detectionModel, _callback);

    }

    /**
     * 
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Each person entry can hold up to 248 faces. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return PersistedFace
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersistedFace largePersonGroupPersonAddFaceFromUrl(String largePersonGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        ApiResponse<PersistedFace> localVarResp = largePersonGroupPersonAddFaceFromUrlWithHttpInfo(largePersonGroupId, personId, imageUrl, userData, targetFace, detectionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Each person entry can hold up to 248 faces. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return ApiResponse&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersistedFace> largePersonGroupPersonAddFaceFromUrlWithHttpInfo(String largePersonGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonAddFaceFromUrlValidateBeforeCall(largePersonGroupId, personId, imageUrl, userData, targetFace, detectionModel, null);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Each person entry can hold up to 248 faces. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonAddFaceFromUrlAsync(String largePersonGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback<PersistedFace> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonAddFaceFromUrlValidateBeforeCall(largePersonGroupId, personId, imageUrl, userData, targetFace, detectionModel, _callback);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonCreate
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new person. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonCreateCall(String largePersonGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonCreateValidateBeforeCall(String largePersonGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonCreate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largePersonGroupPersonCreate(Async)");
        }

        return largePersonGroupPersonCreateCall(largePersonGroupId, body, _callback);

    }

    /**
     * 
     * Create a new person in a specified large person group.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new person. (required)
     * @return Person
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public Person largePersonGroupPersonCreate(String largePersonGroupId, NameAndUserDataContract body) throws ApiException {
        ApiResponse<Person> localVarResp = largePersonGroupPersonCreateWithHttpInfo(largePersonGroupId, body);
        return localVarResp.getData();
    }

    /**
     * 
     * Create a new person in a specified large person group.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new person. (required)
     * @return ApiResponse&lt;Person&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Person> largePersonGroupPersonCreateWithHttpInfo(String largePersonGroupId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonCreateValidateBeforeCall(largePersonGroupId, body, null);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Create a new person in a specified large person group.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for creating new person. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonCreateAsync(String largePersonGroupId, NameAndUserDataContract body, final ApiCallback<Person> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonCreateValidateBeforeCall(largePersonGroupId, body, _callback);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonDelete
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonDeleteCall(String largePersonGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons/{personId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonDeleteValidateBeforeCall(String largePersonGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonDelete(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling largePersonGroupPersonDelete(Async)");
        }

        return largePersonGroupPersonDeleteCall(largePersonGroupId, personId, _callback);

    }

    /**
     * 
     * Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupPersonDelete(String largePersonGroupId, UUID personId) throws ApiException {
        largePersonGroupPersonDeleteWithHttpInfo(largePersonGroupId, personId);
    }

    /**
     * 
     * Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupPersonDeleteWithHttpInfo(String largePersonGroupId, UUID personId) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonDeleteValidateBeforeCall(largePersonGroupId, personId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonDeleteAsync(String largePersonGroupId, UUID personId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonDeleteValidateBeforeCall(largePersonGroupId, personId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonDeleteFace
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonDeleteFaceCall(String largePersonGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonDeleteFaceValidateBeforeCall(String largePersonGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonDeleteFace(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling largePersonGroupPersonDeleteFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling largePersonGroupPersonDeleteFace(Async)");
        }

        return largePersonGroupPersonDeleteFaceCall(largePersonGroupId, personId, persistedFaceId, _callback);

    }

    /**
     * 
     * Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupPersonDeleteFace(String largePersonGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        largePersonGroupPersonDeleteFaceWithHttpInfo(largePersonGroupId, personId, persistedFaceId);
    }

    /**
     * 
     * Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupPersonDeleteFaceWithHttpInfo(String largePersonGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonDeleteFaceValidateBeforeCall(largePersonGroupId, personId, persistedFaceId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonDeleteFaceAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonDeleteFaceValidateBeforeCall(largePersonGroupId, personId, persistedFaceId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonGet
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonGetCall(String largePersonGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons/{personId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonGetValidateBeforeCall(String largePersonGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonGet(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling largePersonGroupPersonGet(Async)");
        }

        return largePersonGroupPersonGetCall(largePersonGroupId, personId, _callback);

    }

    /**
     * 
     * Retrieve a person&#39;s name and userData, and the persisted faceIds representing the registered person face feature.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @return Person
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public Person largePersonGroupPersonGet(String largePersonGroupId, UUID personId) throws ApiException {
        ApiResponse<Person> localVarResp = largePersonGroupPersonGetWithHttpInfo(largePersonGroupId, personId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve a person&#39;s name and userData, and the persisted faceIds representing the registered person face feature.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @return ApiResponse&lt;Person&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Person> largePersonGroupPersonGetWithHttpInfo(String largePersonGroupId, UUID personId) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonGetValidateBeforeCall(largePersonGroupId, personId, null);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve a person&#39;s name and userData, and the persisted faceIds representing the registered person face feature.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonGetAsync(String largePersonGroupId, UUID personId, final ApiCallback<Person> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonGetValidateBeforeCall(largePersonGroupId, personId, _callback);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonGetFace
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonGetFaceCall(String largePersonGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonGetFaceValidateBeforeCall(String largePersonGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonGetFace(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling largePersonGroupPersonGetFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling largePersonGroupPersonGetFace(Async)");
        }

        return largePersonGroupPersonGetFaceCall(largePersonGroupId, personId, persistedFaceId, _callback);

    }

    /**
     * 
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging largePersonGroupId).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return PersistedFace
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersistedFace largePersonGroupPersonGetFace(String largePersonGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        ApiResponse<PersistedFace> localVarResp = largePersonGroupPersonGetFaceWithHttpInfo(largePersonGroupId, personId, persistedFaceId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging largePersonGroupId).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return ApiResponse&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersistedFace> largePersonGroupPersonGetFaceWithHttpInfo(String largePersonGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonGetFaceValidateBeforeCall(largePersonGroupId, personId, persistedFaceId, null);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging largePersonGroupId).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonGetFaceAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId, final ApiCallback<PersistedFace> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonGetFaceValidateBeforeCall(largePersonGroupId, personId, persistedFaceId, _callback);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonList
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the large person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonListCall(String largePersonGroupId, String start, Integer top, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (top != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("top", top));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonListValidateBeforeCall(String largePersonGroupId, String start, Integer top, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonList(Async)");
        }

        return largePersonGroupPersonListCall(largePersonGroupId, start, top, _callback);

    }

    /**
     * 
     * List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @return List&lt;Person&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the large person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<Person> largePersonGroupPersonList(String largePersonGroupId, String start, Integer top) throws ApiException {
        ApiResponse<List<Person>> localVarResp = largePersonGroupPersonListWithHttpInfo(largePersonGroupId, start, top);
        return localVarResp.getData();
    }

    /**
     * 
     * List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @return ApiResponse&lt;List&lt;Person&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the large person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Person>> largePersonGroupPersonListWithHttpInfo(String largePersonGroupId, String start, Integer top) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonListValidateBeforeCall(largePersonGroupId, start, top, null);
        Type localVarReturnType = new TypeToken<List<Person>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the large person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonListAsync(String largePersonGroupId, String start, Integer top, final ApiCallback<List<Person>> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonListValidateBeforeCall(largePersonGroupId, start, top, _callback);
        Type localVarReturnType = new TypeToken<List<Person>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonUpdate
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonUpdateCall(String largePersonGroupId, UUID personId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons/{personId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonUpdateValidateBeforeCall(String largePersonGroupId, UUID personId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonUpdate(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling largePersonGroupPersonUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largePersonGroupPersonUpdate(Async)");
        }

        return largePersonGroupPersonUpdateCall(largePersonGroupId, personId, body, _callback);

    }

    /**
     * 
     * Update name or userData of a person.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupPersonUpdate(String largePersonGroupId, UUID personId, NameAndUserDataContract body) throws ApiException {
        largePersonGroupPersonUpdateWithHttpInfo(largePersonGroupId, personId, body);
    }

    /**
     * 
     * Update name or userData of a person.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupPersonUpdateWithHttpInfo(String largePersonGroupId, UUID personId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonUpdateValidateBeforeCall(largePersonGroupId, personId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update name or userData of a person.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonUpdateAsync(String largePersonGroupId, UUID personId, NameAndUserDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonUpdateValidateBeforeCall(largePersonGroupId, personId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupPersonUpdateFace
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonUpdateFaceCall(String largePersonGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupPersonUpdateFaceValidateBeforeCall(String largePersonGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupPersonUpdateFace(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling largePersonGroupPersonUpdateFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling largePersonGroupPersonUpdateFace(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largePersonGroupPersonUpdateFace(Async)");
        }

        return largePersonGroupPersonUpdateFaceCall(largePersonGroupId, personId, persistedFaceId, body, _callback);

    }

    /**
     * 
     * Update a person persisted face&#39;s userData field.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupPersonUpdateFace(String largePersonGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body) throws ApiException {
        largePersonGroupPersonUpdateFaceWithHttpInfo(largePersonGroupId, personId, persistedFaceId, body);
    }

    /**
     * 
     * Update a person persisted face&#39;s userData field.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupPersonUpdateFaceWithHttpInfo(String largePersonGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupPersonUpdateFaceValidateBeforeCall(largePersonGroupId, personId, persistedFaceId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update a person persisted face&#39;s userData field.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupPersonUpdateFaceAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupPersonUpdateFaceValidateBeforeCall(largePersonGroupId, personId, persistedFaceId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupTrain
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupTrainCall(String largePersonGroupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}/train"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupTrainValidateBeforeCall(String largePersonGroupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupTrain(Async)");
        }

        return largePersonGroupTrainCall(largePersonGroupId, _callback);

    }

    /**
     * 
     * Queue a large person group training task, the training task may not be started immediately.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupTrain(String largePersonGroupId) throws ApiException {
        largePersonGroupTrainWithHttpInfo(largePersonGroupId);
    }

    /**
     * 
     * Queue a large person group training task, the training task may not be started immediately.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupTrainWithHttpInfo(String largePersonGroupId) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupTrainValidateBeforeCall(largePersonGroupId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Queue a large person group training task, the training task may not be started immediately.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupTrainAsync(String largePersonGroupId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupTrainValidateBeforeCall(largePersonGroupId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for largePersonGroupUpdate
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for updating large person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupUpdateCall(String largePersonGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/largepersongroups/{largePersonGroupId}"
            .replace("{" + "largePersonGroupId" + "}", localVarApiClient.escapeString(largePersonGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call largePersonGroupUpdateValidateBeforeCall(String largePersonGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'largePersonGroupId' is set
        if (largePersonGroupId == null) {
            throw new ApiException("Missing the required parameter 'largePersonGroupId' when calling largePersonGroupUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling largePersonGroupUpdate(Async)");
        }

        return largePersonGroupUpdateCall(largePersonGroupId, body, _callback);

    }

    /**
     * 
     * Update an existing large person group&#39;s display name and userData. The properties which does not appear in request body will not be updated.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for updating large person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void largePersonGroupUpdate(String largePersonGroupId, NameAndUserDataContract body) throws ApiException {
        largePersonGroupUpdateWithHttpInfo(largePersonGroupId, body);
    }

    /**
     * 
     * Update an existing large person group&#39;s display name and userData. The properties which does not appear in request body will not be updated.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for updating large person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> largePersonGroupUpdateWithHttpInfo(String largePersonGroupId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = largePersonGroupUpdateValidateBeforeCall(largePersonGroupId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update an existing large person group&#39;s display name and userData. The properties which does not appear in request body will not be updated.
     * @param largePersonGroupId Id referencing a particular large person group. (required)
     * @param body Request body for updating large person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call largePersonGroupUpdateAsync(String largePersonGroupId, NameAndUserDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = largePersonGroupUpdateValidateBeforeCall(largePersonGroupId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupCreate
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupCreateCall(String personGroupId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupCreateValidateBeforeCall(String personGroupId, MetaDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupCreate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling personGroupCreate(Async)");
        }

        return personGroupCreateCall(personGroupId, body, _callback);

    }

    /**
     * 
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel. &lt;br /&gt; A person group is the container of the uploaded person data, including face recognition features. &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; No image will be stored. Only the person&#39;s extracted face features and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this person group. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that&#39;s already associated with the collection. Existing face features in a person group can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [PersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244). All those person groups created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Person group quota: * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons. * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons. * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupCreate(String personGroupId, MetaDataContract body) throws ApiException {
        personGroupCreateWithHttpInfo(personGroupId, body);
    }

    /**
     * 
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel. &lt;br /&gt; A person group is the container of the uploaded person data, including face recognition features. &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; No image will be stored. Only the person&#39;s extracted face features and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this person group. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that&#39;s already associated with the collection. Existing face features in a person group can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [PersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244). All those person groups created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Person group quota: * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons. * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons. * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupCreateWithHttpInfo(String personGroupId, MetaDataContract body) throws ApiException {
        okhttp3.Call localVarCall = personGroupCreateValidateBeforeCall(personGroupId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel. &lt;br /&gt; A person group is the container of the uploaded person data, including face recognition features. &lt;br /&gt; After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239). &lt;br /&gt; No image will be stored. Only the person&#39;s extracted face features and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br/&gt;&#39;recognitionModel&#39; should be specified to associate with this person group. The default value for &#39;recognitionModel&#39; is &#39;recognition_01&#39;, if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that&#39;s already associated with the collection. Existing face features in a person group can&#39;t be updated to features extracted by another version of recognition model. * &#39;recognition_01&#39;: The default recognition model for [PersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244). All those person groups created before 2019 March are bonded with this recognition model. * &#39;recognition_02&#39;: Recognition model released in 2019 March. &#39;recognition_02&#39; is recommended since its overall accuracy is improved compared with &#39;recognition_01&#39;.  Person group quota: * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons. * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons. * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupCreateAsync(String personGroupId, MetaDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupCreateValidateBeforeCall(personGroupId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupDelete
     * @param personGroupId Id referencing a particular person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupDeleteCall(String personGroupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupDeleteValidateBeforeCall(String personGroupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupDelete(Async)");
        }

        return personGroupDeleteCall(personGroupId, _callback);

    }

    /**
     * 
     * Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
     * @param personGroupId Id referencing a particular person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupDelete(String personGroupId) throws ApiException {
        personGroupDeleteWithHttpInfo(personGroupId);
    }

    /**
     * 
     * Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
     * @param personGroupId Id referencing a particular person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupDeleteWithHttpInfo(String personGroupId) throws ApiException {
        okhttp3.Call localVarCall = personGroupDeleteValidateBeforeCall(personGroupId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupDeleteAsync(String personGroupId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupDeleteValidateBeforeCall(personGroupId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupGet
     * @param personGroupId Id referencing a particular person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupGetCall(String personGroupId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupGetValidateBeforeCall(String personGroupId, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupGet(Async)");
        }

        return personGroupGetCall(personGroupId, returnRecognitionModel, _callback);

    }

    /**
     * 
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return PersonGroup
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersonGroup personGroupGet(String personGroupId, Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<PersonGroup> localVarResp = personGroupGetWithHttpInfo(personGroupId, returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;PersonGroup&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersonGroup> personGroupGetWithHttpInfo(String personGroupId, Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = personGroupGetValidateBeforeCall(personGroupId, returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<PersonGroup>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupGetAsync(String personGroupId, Boolean returnRecognitionModel, final ApiCallback<PersonGroup> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupGetValidateBeforeCall(personGroupId, returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<PersonGroup>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupGetTrainingStatus
     * @param personGroupId Id referencing a particular person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupGetTrainingStatusCall(String personGroupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/training"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupGetTrainingStatusValidateBeforeCall(String personGroupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupGetTrainingStatus(Async)");
        }

        return personGroupGetTrainingStatusCall(personGroupId, _callback);

    }

    /**
     * 
     * Retrieve the training status of a person group (completed or ongoing).
     * @param personGroupId Id referencing a particular person group. (required)
     * @return TrainingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public TrainingStatus personGroupGetTrainingStatus(String personGroupId) throws ApiException {
        ApiResponse<TrainingStatus> localVarResp = personGroupGetTrainingStatusWithHttpInfo(personGroupId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the training status of a person group (completed or ongoing).
     * @param personGroupId Id referencing a particular person group. (required)
     * @return ApiResponse&lt;TrainingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TrainingStatus> personGroupGetTrainingStatusWithHttpInfo(String personGroupId) throws ApiException {
        okhttp3.Call localVarCall = personGroupGetTrainingStatusValidateBeforeCall(personGroupId, null);
        Type localVarReturnType = new TypeToken<TrainingStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the training status of a person group (completed or ongoing).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person group&#39;s training status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupGetTrainingStatusAsync(String personGroupId, final ApiCallback<TrainingStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupGetTrainingStatusValidateBeforeCall(personGroupId, _callback);
        Type localVarReturnType = new TypeToken<TrainingStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupList
     * @param start List person groups from the least personGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupListCall(String start, Integer top, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (top != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("top", top));
        }

        if (returnRecognitionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnRecognitionModel", returnRecognitionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupListValidateBeforeCall(String start, Integer top, Boolean returnRecognitionModel, final ApiCallback _callback) throws ApiException {
        return personGroupListCall(start, top, returnRecognitionModel, _callback);

    }

    /**
     * 
     * List person groups’ personGroupId, name, userData and recognitionModel.&lt;br /&gt; * Person groups are stored in alphabetical order of personGroupId. * \&quot;start\&quot; parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 person groups: \&quot;group1\&quot;, ..., \&quot;group5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 groups. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;group1\&quot;, \&quot;group2\&quot;. &lt;br /&gt; \&quot;start&#x3D;group2&amp;top&#x3D;3\&quot; will return \&quot;group3\&quot;, \&quot;group4\&quot;, \&quot;group5\&quot;. 
     * @param start List person groups from the least personGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return List&lt;PersonGroup&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<PersonGroup> personGroupList(String start, Integer top, Boolean returnRecognitionModel) throws ApiException {
        ApiResponse<List<PersonGroup>> localVarResp = personGroupListWithHttpInfo(start, top, returnRecognitionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * List person groups’ personGroupId, name, userData and recognitionModel.&lt;br /&gt; * Person groups are stored in alphabetical order of personGroupId. * \&quot;start\&quot; parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 person groups: \&quot;group1\&quot;, ..., \&quot;group5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 groups. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;group1\&quot;, \&quot;group2\&quot;. &lt;br /&gt; \&quot;start&#x3D;group2&amp;top&#x3D;3\&quot; will return \&quot;group3\&quot;, \&quot;group4\&quot;, \&quot;group5\&quot;. 
     * @param start List person groups from the least personGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @return ApiResponse&lt;List&lt;PersonGroup&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<PersonGroup>> personGroupListWithHttpInfo(String start, Integer top, Boolean returnRecognitionModel) throws ApiException {
        okhttp3.Call localVarCall = personGroupListValidateBeforeCall(start, top, returnRecognitionModel, null);
        Type localVarReturnType = new TypeToken<List<PersonGroup>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List person groups’ personGroupId, name, userData and recognitionModel.&lt;br /&gt; * Person groups are stored in alphabetical order of personGroupId. * \&quot;start\&quot; parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. \&quot;start\&quot; set to empty to indicate return from the first item. * \&quot;top\&quot; parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify \&quot;start\&quot; with the last returned entry’s Id of the current call. &lt;br /&gt; For example, total 5 person groups: \&quot;group1\&quot;, ..., \&quot;group5\&quot;. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;\&quot; will return all 5 groups. &lt;br /&gt; \&quot;start&#x3D;&amp;top&#x3D;2\&quot; will return \&quot;group1\&quot;, \&quot;group2\&quot;. &lt;br /&gt; \&quot;start&#x3D;group2&amp;top&#x3D;3\&quot; will return \&quot;group3\&quot;, \&quot;group4\&quot;, \&quot;group5\&quot;. 
     * @param start List person groups from the least personGroupId greater than the \&quot;start\&quot;. (optional)
     * @param top The number of person groups to list. (optional, default to 1000)
     * @param returnRecognitionModel A value indicating whether the operation should return &#39;recognitionModel&#39; in response. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person groups and their information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupListAsync(String start, Integer top, Boolean returnRecognitionModel, final ApiCallback<List<PersonGroup>> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupListValidateBeforeCall(start, top, returnRecognitionModel, _callback);
        Type localVarReturnType = new TypeToken<List<PersonGroup>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonAddFaceFromUrl
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonAddFaceFromUrlCall(String personGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = imageUrl;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userData", userData));
        }

        if (targetFace != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "targetFace", targetFace));
        }

        if (detectionModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("detectionModel", detectionModel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonAddFaceFromUrlValidateBeforeCall(String personGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonAddFaceFromUrl(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling personGroupPersonAddFaceFromUrl(Async)");
        }

        // verify the required parameter 'imageUrl' is set
        if (imageUrl == null) {
            throw new ApiException("Missing the required parameter 'imageUrl' when calling personGroupPersonAddFaceFromUrl(Async)");
        }

        return personGroupPersonAddFaceFromUrlCall(personGroupId, personId, imageUrl, userData, targetFace, detectionModel, _callback);

    }

    /**
     * 
     * Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). *   Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. *   Each person entry can hold up to 248 faces. *   JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. *   \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. *   Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. *   Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [PersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return PersistedFace
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersistedFace personGroupPersonAddFaceFromUrl(String personGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        ApiResponse<PersistedFace> localVarResp = personGroupPersonAddFaceFromUrlWithHttpInfo(personGroupId, personId, imageUrl, userData, targetFace, detectionModel);
        return localVarResp.getData();
    }

    /**
     * 
     * Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). *   Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. *   Each person entry can hold up to 248 faces. *   JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. *   \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. *   Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. *   Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [PersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @return ApiResponse&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersistedFace> personGroupPersonAddFaceFromUrlWithHttpInfo(String personGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonAddFaceFromUrlValidateBeforeCall(personGroupId, personId, imageUrl, userData, targetFace, detectionModel, null);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). *   Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. *   Each person entry can hold up to 248 faces. *   JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. *   \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. *   Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. *   Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size. * Different &#39;detectionModel&#39; values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)   | Model | Recommended use-case(s) |   | ---------- | -------- |   | &#39;detection_01&#39;: | The default detection model for [PersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |   | &#39;detection_02&#39;: | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param imageUrl A JSON document with a URL pointing to the image that is to be analyzed. (required)
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB. (optional)
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of \&quot;targetFace&#x3D;left,top,width,height\&quot;. E.g. \&quot;targetFace&#x3D;10,10,100,100\&quot;. If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image. (optional)
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is &#39;detection_01&#39;, if another model is needed, please explicitly specify it. (optional, default to detection_01)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the new persistedFaceId. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonAddFaceFromUrlAsync(String personGroupId, UUID personId, FaceDetectWithUrlRequest imageUrl, String userData, List<Integer> targetFace, String detectionModel, final ApiCallback<PersistedFace> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonAddFaceFromUrlValidateBeforeCall(personGroupId, personId, imageUrl, userData, targetFace, detectionModel, _callback);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonCreate
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonCreateCall(String personGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonCreateValidateBeforeCall(String personGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonCreate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling personGroupPersonCreate(Async)");
        }

        return personGroupPersonCreateCall(personGroupId, body, _callback);

    }

    /**
     * 
     * Create a new person in a specified person group.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person. (required)
     * @return Person
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public Person personGroupPersonCreate(String personGroupId, NameAndUserDataContract body) throws ApiException {
        ApiResponse<Person> localVarResp = personGroupPersonCreateWithHttpInfo(personGroupId, body);
        return localVarResp.getData();
    }

    /**
     * 
     * Create a new person in a specified person group.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person. (required)
     * @return ApiResponse&lt;Person&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Person> personGroupPersonCreateWithHttpInfo(String personGroupId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonCreateValidateBeforeCall(personGroupId, body, null);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Create a new person in a specified person group.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for creating new person. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns a new personId created. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonCreateAsync(String personGroupId, NameAndUserDataContract body, final ApiCallback<Person> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonCreateValidateBeforeCall(personGroupId, body, _callback);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonDelete
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonDeleteCall(String personGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons/{personId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonDeleteValidateBeforeCall(String personGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonDelete(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling personGroupPersonDelete(Async)");
        }

        return personGroupPersonDeleteCall(personGroupId, personId, _callback);

    }

    /**
     * 
     * Delete an existing person from a person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupPersonDelete(String personGroupId, UUID personId) throws ApiException {
        personGroupPersonDeleteWithHttpInfo(personGroupId, personId);
    }

    /**
     * 
     * Delete an existing person from a person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupPersonDeleteWithHttpInfo(String personGroupId, UUID personId) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonDeleteValidateBeforeCall(personGroupId, personId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete an existing person from a person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonDeleteAsync(String personGroupId, UUID personId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonDeleteValidateBeforeCall(personGroupId, personId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonDeleteFace
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonDeleteFaceCall(String personGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonDeleteFaceValidateBeforeCall(String personGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonDeleteFace(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling personGroupPersonDeleteFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling personGroupPersonDeleteFace(Async)");
        }

        return personGroupPersonDeleteFaceCall(personGroupId, personId, persistedFaceId, _callback);

    }

    /**
     * 
     * Delete a face from a person in a person group by specified personGroupId, personId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupPersonDeleteFace(String personGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        personGroupPersonDeleteFaceWithHttpInfo(personGroupId, personId, persistedFaceId);
    }

    /**
     * 
     * Delete a face from a person in a person group by specified personGroupId, personId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupPersonDeleteFaceWithHttpInfo(String personGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonDeleteFaceValidateBeforeCall(personGroupId, personId, persistedFaceId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete a face from a person in a person group by specified personGroupId, personId and persistedFaceId. &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonDeleteFaceAsync(String personGroupId, UUID personId, UUID persistedFaceId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonDeleteFaceValidateBeforeCall(personGroupId, personId, persistedFaceId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonGet
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonGetCall(String personGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons/{personId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonGetValidateBeforeCall(String personGroupId, UUID personId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonGet(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling personGroupPersonGet(Async)");
        }

        return personGroupPersonGetCall(personGroupId, personId, _callback);

    }

    /**
     * 
     * Retrieve a person&#39;s information, including registered persisted faces, name and userData.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @return Person
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public Person personGroupPersonGet(String personGroupId, UUID personId) throws ApiException {
        ApiResponse<Person> localVarResp = personGroupPersonGetWithHttpInfo(personGroupId, personId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve a person&#39;s information, including registered persisted faces, name and userData.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @return ApiResponse&lt;Person&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Person> personGroupPersonGetWithHttpInfo(String personGroupId, UUID personId) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonGetValidateBeforeCall(personGroupId, personId, null);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve a person&#39;s information, including registered persisted faces, name and userData.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the person&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonGetAsync(String personGroupId, UUID personId, final ApiCallback<Person> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonGetValidateBeforeCall(personGroupId, personId, _callback);
        Type localVarReturnType = new TypeToken<Person>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonGetFace
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonGetFaceCall(String personGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonGetFaceValidateBeforeCall(String personGroupId, UUID personId, UUID persistedFaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonGetFace(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling personGroupPersonGetFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling personGroupPersonGetFace(Async)");
        }

        return personGroupPersonGetFaceCall(personGroupId, personId, persistedFaceId, _callback);

    }

    /**
     * 
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging personGroupId).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return PersistedFace
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public PersistedFace personGroupPersonGetFace(String personGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        ApiResponse<PersistedFace> localVarResp = personGroupPersonGetFaceWithHttpInfo(personGroupId, personId, persistedFaceId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging personGroupId).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @return ApiResponse&lt;PersistedFace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PersistedFace> personGroupPersonGetFaceWithHttpInfo(String personGroupId, UUID personId, UUID persistedFaceId) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonGetFaceValidateBeforeCall(personGroupId, personId, persistedFaceId, null);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging personGroupId).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns target persisted face&#39;s information (persistedFaceId and userData). </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonGetFaceAsync(String personGroupId, UUID personId, UUID persistedFaceId, final ApiCallback<PersistedFace> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonGetFaceValidateBeforeCall(personGroupId, personId, persistedFaceId, _callback);
        Type localVarReturnType = new TypeToken<PersistedFace>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonList
     * @param personGroupId Id referencing a particular person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonListCall(String personGroupId, String start, Integer top, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (start != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start", start));
        }

        if (top != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("top", top));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonListValidateBeforeCall(String personGroupId, String start, Integer top, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonList(Async)");
        }

        return personGroupPersonListCall(personGroupId, start, top, _callback);

    }

    /**
     * 
     * List all persons in a person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @return List&lt;Person&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<Person> personGroupPersonList(String personGroupId, String start, Integer top) throws ApiException {
        ApiResponse<List<Person>> localVarResp = personGroupPersonListWithHttpInfo(personGroupId, start, top);
        return localVarResp.getData();
    }

    /**
     * 
     * List all persons in a person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @return ApiResponse&lt;List&lt;Person&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Person>> personGroupPersonListWithHttpInfo(String personGroupId, String start, Integer top) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonListValidateBeforeCall(personGroupId, start, top, null);
        Type localVarReturnType = new TypeToken<List<Person>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List all persons in a person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     * @param personGroupId Id referencing a particular person group. (required)
     * @param start Starting person id to return (used to list a range of persons). (optional)
     * @param top Number of persons to return starting with the person id indicated by the &#39;start&#39; parameter. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of person information that belong to the person group. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonListAsync(String personGroupId, String start, Integer top, final ApiCallback<List<Person>> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonListValidateBeforeCall(personGroupId, start, top, _callback);
        Type localVarReturnType = new TypeToken<List<Person>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonUpdate
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonUpdateCall(String personGroupId, UUID personId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons/{personId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonUpdateValidateBeforeCall(String personGroupId, UUID personId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonUpdate(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling personGroupPersonUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling personGroupPersonUpdate(Async)");
        }

        return personGroupPersonUpdateCall(personGroupId, personId, body, _callback);

    }

    /**
     * 
     * Update name or userData of a person.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupPersonUpdate(String personGroupId, UUID personId, NameAndUserDataContract body) throws ApiException {
        personGroupPersonUpdateWithHttpInfo(personGroupId, personId, body);
    }

    /**
     * 
     * Update name or userData of a person.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupPersonUpdateWithHttpInfo(String personGroupId, UUID personId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonUpdateValidateBeforeCall(personGroupId, personId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update name or userData of a person.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param body Request body for person update operation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonUpdateAsync(String personGroupId, UUID personId, NameAndUserDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonUpdateValidateBeforeCall(personGroupId, personId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupPersonUpdateFace
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonUpdateFaceCall(String personGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()))
            .replace("{" + "personId" + "}", localVarApiClient.escapeString(personId.toString()))
            .replace("{" + "persistedFaceId" + "}", localVarApiClient.escapeString(persistedFaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupPersonUpdateFaceValidateBeforeCall(String personGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupPersonUpdateFace(Async)");
        }

        // verify the required parameter 'personId' is set
        if (personId == null) {
            throw new ApiException("Missing the required parameter 'personId' when calling personGroupPersonUpdateFace(Async)");
        }

        // verify the required parameter 'persistedFaceId' is set
        if (persistedFaceId == null) {
            throw new ApiException("Missing the required parameter 'persistedFaceId' when calling personGroupPersonUpdateFace(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling personGroupPersonUpdateFace(Async)");
        }

        return personGroupPersonUpdateFaceCall(personGroupId, personId, persistedFaceId, body, _callback);

    }

    /**
     * 
     * Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Each person entry can hold up to 248 faces. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupPersonUpdateFace(String personGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body) throws ApiException {
        personGroupPersonUpdateFaceWithHttpInfo(personGroupId, personId, persistedFaceId, body);
    }

    /**
     * 
     * Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Each person entry can hold up to 248 faces. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupPersonUpdateFaceWithHttpInfo(String personGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body) throws ApiException {
        okhttp3.Call localVarCall = personGroupPersonUpdateFaceValidateBeforeCall(personGroupId, personId, persistedFaceId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called. &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger. * Each person entry can hold up to 248 faces. * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB. * \&quot;targetFace\&quot; rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided \&quot;targetFace\&quot; rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully. * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures. * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param personId Id referencing a particular person. (required)
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face. (required)
     * @param body Request body for updating persisted face. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupPersonUpdateFaceAsync(String personGroupId, UUID personId, UUID persistedFaceId, UpdateFaceRequest body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupPersonUpdateFaceValidateBeforeCall(personGroupId, personId, persistedFaceId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupTrain
     * @param personGroupId Id referencing a particular person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupTrainCall(String personGroupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}/train"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupTrainValidateBeforeCall(String personGroupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupTrain(Async)");
        }

        return personGroupTrainCall(personGroupId, _callback);

    }

    /**
     * 
     * Queue a person group training task, the training task may not be started immediately.
     * @param personGroupId Id referencing a particular person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupTrain(String personGroupId) throws ApiException {
        personGroupTrainWithHttpInfo(personGroupId);
    }

    /**
     * 
     * Queue a person group training task, the training task may not be started immediately.
     * @param personGroupId Id referencing a particular person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupTrainWithHttpInfo(String personGroupId) throws ApiException {
        okhttp3.Call localVarCall = personGroupTrainValidateBeforeCall(personGroupId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Queue a person group training task, the training task may not be started immediately.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The training task was queued successfully. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupTrainAsync(String personGroupId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupTrainValidateBeforeCall(personGroupId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for personGroupUpdate
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for updating person group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupUpdateCall(String personGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/persongroups/{personGroupId}"
            .replace("{" + "personGroupId" + "}", localVarApiClient.escapeString(personGroupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call personGroupUpdateValidateBeforeCall(String personGroupId, NameAndUserDataContract body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'personGroupId' is set
        if (personGroupId == null) {
            throw new ApiException("Missing the required parameter 'personGroupId' when calling personGroupUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling personGroupUpdate(Async)");
        }

        return personGroupUpdateCall(personGroupId, body, _callback);

    }

    /**
     * 
     * Update an existing person group&#39;s display name and userData. The properties which does not appear in request body will not be updated.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for updating person group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void personGroupUpdate(String personGroupId, NameAndUserDataContract body) throws ApiException {
        personGroupUpdateWithHttpInfo(personGroupId, body);
    }

    /**
     * 
     * Update an existing person group&#39;s display name and userData. The properties which does not appear in request body will not be updated.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for updating person group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> personGroupUpdateWithHttpInfo(String personGroupId, NameAndUserDataContract body) throws ApiException {
        okhttp3.Call localVarCall = personGroupUpdateValidateBeforeCall(personGroupId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update an existing person group&#39;s display name and userData. The properties which does not appear in request body will not be updated.
     * @param personGroupId Id referencing a particular person group. (required)
     * @param body Request body for updating person group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call personGroupUpdateAsync(String personGroupId, NameAndUserDataContract body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = personGroupUpdateValidateBeforeCall(personGroupId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snapshotApply
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for applying a snapshot. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot applying task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotApplyCall(UUID snapshotId, ApplySnapshotRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/snapshots/{snapshotId}/apply"
            .replace("{" + "snapshotId" + "}", localVarApiClient.escapeString(snapshotId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snapshotApplyValidateBeforeCall(UUID snapshotId, ApplySnapshotRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotId' is set
        if (snapshotId == null) {
            throw new ApiException("Missing the required parameter 'snapshotId' when calling snapshotApply(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling snapshotApply(Async)");
        }

        return snapshotApplyCall(snapshotId, body, _callback);

    }

    /**
     * 
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt; The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt; Applying snapshot is an asynchronous operation. An operation id can be obtained from the \&quot;Operation-Location\&quot; field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the \&quot;resourceLocation\&quot; field in OperationStatus - Get response when the operation status is \&quot;succeeded\&quot;.&lt;br /&gt; Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt; Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the \&quot;objectId\&quot; in request body to avoid such conflicts.&lt;br /&gt; * Free-tier subscription quota: 100 apply operations per month. * S0-tier subscription quota: 100 apply operations per day.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for applying a snapshot. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot applying task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void snapshotApply(UUID snapshotId, ApplySnapshotRequest body) throws ApiException {
        snapshotApplyWithHttpInfo(snapshotId, body);
    }

    /**
     * 
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt; The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt; Applying snapshot is an asynchronous operation. An operation id can be obtained from the \&quot;Operation-Location\&quot; field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the \&quot;resourceLocation\&quot; field in OperationStatus - Get response when the operation status is \&quot;succeeded\&quot;.&lt;br /&gt; Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt; Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the \&quot;objectId\&quot; in request body to avoid such conflicts.&lt;br /&gt; * Free-tier subscription quota: 100 apply operations per month. * S0-tier subscription quota: 100 apply operations per day.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for applying a snapshot. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot applying task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snapshotApplyWithHttpInfo(UUID snapshotId, ApplySnapshotRequest body) throws ApiException {
        okhttp3.Call localVarCall = snapshotApplyValidateBeforeCall(snapshotId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.&lt;br /&gt; The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt; Applying snapshot is an asynchronous operation. An operation id can be obtained from the \&quot;Operation-Location\&quot; field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the \&quot;resourceLocation\&quot; field in OperationStatus - Get response when the operation status is \&quot;succeeded\&quot;.&lt;br /&gt; Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.&lt;br /&gt; Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the \&quot;objectId\&quot; in request body to avoid such conflicts.&lt;br /&gt; * Free-tier subscription quota: 100 apply operations per month. * S0-tier subscription quota: 100 apply operations per day.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for applying a snapshot. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot applying task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotApplyAsync(UUID snapshotId, ApplySnapshotRequest body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snapshotApplyValidateBeforeCall(snapshotId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snapshotDelete
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotDeleteCall(UUID snapshotId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snapshots/{snapshotId}"
            .replace("{" + "snapshotId" + "}", localVarApiClient.escapeString(snapshotId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snapshotDeleteValidateBeforeCall(UUID snapshotId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotId' is set
        if (snapshotId == null) {
            throw new ApiException("Missing the required parameter 'snapshotId' when calling snapshotDelete(Async)");
        }

        return snapshotDeleteCall(snapshotId, _callback);

    }

    /**
     * 
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void snapshotDelete(UUID snapshotId) throws ApiException {
        snapshotDeleteWithHttpInfo(snapshotId);
    }

    /**
     * 
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snapshotDeleteWithHttpInfo(UUID snapshotId) throws ApiException {
        okhttp3.Call localVarCall = snapshotDeleteValidateBeforeCall(snapshotId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotDeleteAsync(UUID snapshotId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snapshotDeleteValidateBeforeCall(snapshotId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snapshotGet
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotGetCall(UUID snapshotId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snapshots/{snapshotId}"
            .replace("{" + "snapshotId" + "}", localVarApiClient.escapeString(snapshotId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snapshotGetValidateBeforeCall(UUID snapshotId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotId' is set
        if (snapshotId == null) {
            throw new ApiException("Missing the required parameter 'snapshotId' when calling snapshotGet(Async)");
        }

        return snapshotGetCall(snapshotId, _callback);

    }

    /**
     * 
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @return Snapshot
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public Snapshot snapshotGet(UUID snapshotId) throws ApiException {
        ApiResponse<Snapshot> localVarResp = snapshotGetWithHttpInfo(snapshotId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @return ApiResponse&lt;Snapshot&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Snapshot> snapshotGetWithHttpInfo(UUID snapshotId) throws ApiException {
        okhttp3.Call localVarCall = snapshotGetValidateBeforeCall(snapshotId, null);
        Type localVarReturnType = new TypeToken<Snapshot>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot&#39;s information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotGetAsync(UUID snapshotId, final ApiCallback<Snapshot> _callback) throws ApiException {

        okhttp3.Call localVarCall = snapshotGetValidateBeforeCall(snapshotId, _callback);
        Type localVarReturnType = new TypeToken<Snapshot>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snapshotGetOperationStatus
     * @param operationId Id referencing a particular take/apply snapshot operation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot operation&#39;s status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotGetOperationStatusCall(UUID operationId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/operations/{operationId}"
            .replace("{" + "operationId" + "}", localVarApiClient.escapeString(operationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snapshotGetOperationStatusValidateBeforeCall(UUID operationId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'operationId' is set
        if (operationId == null) {
            throw new ApiException("Missing the required parameter 'operationId' when calling snapshotGetOperationStatus(Async)");
        }

        return snapshotGetOperationStatusCall(operationId, _callback);

    }

    /**
     * 
     * Retrieve the status of a take/apply snapshot operation.
     * @param operationId Id referencing a particular take/apply snapshot operation. (required)
     * @return OperationStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot operation&#39;s status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public OperationStatus snapshotGetOperationStatus(UUID operationId) throws ApiException {
        ApiResponse<OperationStatus> localVarResp = snapshotGetOperationStatusWithHttpInfo(operationId);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the status of a take/apply snapshot operation.
     * @param operationId Id referencing a particular take/apply snapshot operation. (required)
     * @return ApiResponse&lt;OperationStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot operation&#39;s status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<OperationStatus> snapshotGetOperationStatusWithHttpInfo(UUID operationId) throws ApiException {
        okhttp3.Call localVarCall = snapshotGetOperationStatusValidateBeforeCall(operationId, null);
        Type localVarReturnType = new TypeToken<OperationStatus>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the status of a take/apply snapshot operation.
     * @param operationId Id referencing a particular take/apply snapshot operation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns the snapshot operation&#39;s status. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotGetOperationStatusAsync(UUID operationId, final ApiCallback<OperationStatus> _callback) throws ApiException {

        okhttp3.Call localVarCall = snapshotGetOperationStatusValidateBeforeCall(operationId, _callback);
        Type localVarReturnType = new TypeToken<OperationStatus>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snapshotList
     * @param type User specified object type as a search filter. (optional)
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of snapshots with snapshot information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotListCall(String type, List<UUID> applyScope, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (applyScope != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "applyScope", applyScope));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snapshotListValidateBeforeCall(String type, List<UUID> applyScope, final ApiCallback _callback) throws ApiException {
        return snapshotListCall(type, applyScope, _callback);

    }

    /**
     * 
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     * @param type User specified object type as a search filter. (optional)
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take. (optional)
     * @return List&lt;Snapshot&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of snapshots with snapshot information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public List<Snapshot> snapshotList(String type, List<UUID> applyScope) throws ApiException {
        ApiResponse<List<Snapshot>> localVarResp = snapshotListWithHttpInfo(type, applyScope);
        return localVarResp.getData();
    }

    /**
     * 
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     * @param type User specified object type as a search filter. (optional)
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take. (optional)
     * @return ApiResponse&lt;List&lt;Snapshot&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of snapshots with snapshot information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Snapshot>> snapshotListWithHttpInfo(String type, List<UUID> applyScope) throws ApiException {
        okhttp3.Call localVarCall = snapshotListValidateBeforeCall(type, applyScope, null);
        Type localVarReturnType = new TypeToken<List<Snapshot>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     * @param type User specified object type as a search filter. (optional)
     * @param applyScope User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an array of snapshots with snapshot information. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotListAsync(String type, List<UUID> applyScope, final ApiCallback<List<Snapshot>> _callback) throws ApiException {

        okhttp3.Call localVarCall = snapshotListValidateBeforeCall(type, applyScope, _callback);
        Type localVarReturnType = new TypeToken<List<Snapshot>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snapshotTake
     * @param body Request body for taking a snapshot. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot taking task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotTakeCall(TakeSnapshotRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/snapshots";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snapshotTakeValidateBeforeCall(TakeSnapshotRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling snapshotTake(Async)");
        }

        return snapshotTakeCall(body, _callback);

    }

    /**
     * 
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt; The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt; Taking snapshot is an asynchronous operation. An operation id can be obtained from the \&quot;Operation-Location\&quot; field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the \&quot;resourceLocation\&quot; field in OperationStatus - Get response when the operation status is \&quot;succeeded\&quot;.&lt;br /&gt; Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt; Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; * Free-tier subscription quota: 100 take operations per month. * S0-tier subscription quota: 100 take operations per day.
     * @param body Request body for taking a snapshot. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot taking task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void snapshotTake(TakeSnapshotRequest body) throws ApiException {
        snapshotTakeWithHttpInfo(body);
    }

    /**
     * 
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt; The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt; Taking snapshot is an asynchronous operation. An operation id can be obtained from the \&quot;Operation-Location\&quot; field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the \&quot;resourceLocation\&quot; field in OperationStatus - Get response when the operation status is \&quot;succeeded\&quot;.&lt;br /&gt; Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt; Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; * Free-tier subscription quota: 100 take operations per month. * S0-tier subscription quota: 100 take operations per day.
     * @param body Request body for taking a snapshot. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot taking task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snapshotTakeWithHttpInfo(TakeSnapshotRequest body) throws ApiException {
        okhttp3.Call localVarCall = snapshotTakeValidateBeforeCall(body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt; The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br /&gt; Taking snapshot is an asynchronous operation. An operation id can be obtained from the \&quot;Operation-Location\&quot; field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the \&quot;resourceLocation\&quot; field in OperationStatus - Get response when the operation status is \&quot;succeeded\&quot;.&lt;br /&gt; Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.&lt;br /&gt; Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; * Free-tier subscription quota: 100 take operations per month. * S0-tier subscription quota: 100 take operations per day.
     * @param body Request body for taking a snapshot. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The snapshot taking task was queued successfully. </td><td>  * Operation-Location - Operation location with an operation id used to track the progress of applying the snapshot by OperationStatus - Get. <br>  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotTakeAsync(TakeSnapshotRequest body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snapshotTakeValidateBeforeCall(body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snapshotUpdate
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for updating a snapshot. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotUpdateCall(UUID snapshotId, UpdateSnapshotRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/snapshots/{snapshotId}"
            .replace("{" + "snapshotId" + "}", localVarApiClient.escapeString(snapshotId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "apim_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snapshotUpdateValidateBeforeCall(UUID snapshotId, UpdateSnapshotRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snapshotId' is set
        if (snapshotId == null) {
            throw new ApiException("Missing the required parameter 'snapshotId' when calling snapshotUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling snapshotUpdate(Async)");
        }

        return snapshotUpdateCall(snapshotId, body, _callback);

    }

    /**
     * 
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for updating a snapshot. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public void snapshotUpdate(UUID snapshotId, UpdateSnapshotRequest body) throws ApiException {
        snapshotUpdateWithHttpInfo(snapshotId, body);
    }

    /**
     * 
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for updating a snapshot. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snapshotUpdateWithHttpInfo(UUID snapshotId, UpdateSnapshotRequest body) throws ApiException {
        okhttp3.Call localVarCall = snapshotUpdateValidateBeforeCall(snapshotId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     *  (asynchronously)
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     * @param snapshotId Id referencing a particular snapshot. (required)
     * @param body Request body for updating a snapshot. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful call returns an empty response body. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snapshotUpdateAsync(UUID snapshotId, UpdateSnapshotRequest body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snapshotUpdateValidateBeforeCall(snapshotId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
