/*
 * Face Client
 * An API for face detection, verification, and identification.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Request body for find similar operation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:41:23.692507-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FindSimilarRequest {
  public static final String SERIALIZED_NAME_FACE_ID = "faceId";
  @SerializedName(SERIALIZED_NAME_FACE_ID)
  private UUID faceId;

  public static final String SERIALIZED_NAME_FACE_IDS = "faceIds";
  @SerializedName(SERIALIZED_NAME_FACE_IDS)
  private List<UUID> faceIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_FACE_LIST_ID = "faceListId";
  @SerializedName(SERIALIZED_NAME_FACE_LIST_ID)
  private String faceListId;

  public static final String SERIALIZED_NAME_LARGE_FACE_LIST_ID = "largeFaceListId";
  @SerializedName(SERIALIZED_NAME_LARGE_FACE_LIST_ID)
  private String largeFaceListId;

  public static final String SERIALIZED_NAME_MAX_NUM_OF_CANDIDATES_RETURNED = "maxNumOfCandidatesReturned";
  @SerializedName(SERIALIZED_NAME_MAX_NUM_OF_CANDIDATES_RETURNED)
  private Integer maxNumOfCandidatesReturned;

  /**
   * Similar face searching mode. It can be \&quot;matchPerson\&quot; or \&quot;matchFace\&quot;.
   */
  @JsonAdapter(ModeEnum.Adapter.class)
  public enum ModeEnum {
    MATCH_PERSON("matchPerson"),
    
    MATCH_FACE("matchFace");

    private String value;

    ModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ModeEnum fromValue(String value) {
      for (ModeEnum b : ModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private ModeEnum mode = ModeEnum.MATCH_PERSON;

  public FindSimilarRequest() {
  }

  public FindSimilarRequest faceId(UUID faceId) {
    this.faceId = faceId;
    return this;
  }

  /**
   * FaceId of the query face. User needs to call Face - Detect first to get a valid faceId. Note that this faceId is not persisted and will expire 24 hours after the detection call
   * @return faceId
   */
  @javax.annotation.Nonnull
  public UUID getFaceId() {
    return faceId;
  }

  public void setFaceId(UUID faceId) {
    this.faceId = faceId;
  }


  public FindSimilarRequest faceIds(List<UUID> faceIds) {
    this.faceIds = faceIds;
    return this;
  }

  public FindSimilarRequest addFaceIdsItem(UUID faceIdsItem) {
    if (this.faceIds == null) {
      this.faceIds = new ArrayList<>();
    }
    this.faceIds.add(faceIdsItem);
    return this;
  }

  /**
   * An array of candidate faceIds. All of them are created by Face - Detect and the faceIds will expire 24 hours after the detection call. The number of faceIds is limited to 1000. Parameter faceListId, largeFaceListId and faceIds should not be provided at the same time.
   * @return faceIds
   */
  @javax.annotation.Nullable
  public List<UUID> getFaceIds() {
    return faceIds;
  }

  public void setFaceIds(List<UUID> faceIds) {
    this.faceIds = faceIds;
  }


  public FindSimilarRequest faceListId(String faceListId) {
    this.faceListId = faceListId;
    return this;
  }

  /**
   * An existing user-specified unique candidate face list, created in Face List - Create a Face List. Face list contains a set of persistedFaceIds which are persisted and will never expire. Parameter faceListId, largeFaceListId and faceIds should not be provided at the same time.
   * @return faceListId
   */
  @javax.annotation.Nullable
  public String getFaceListId() {
    return faceListId;
  }

  public void setFaceListId(String faceListId) {
    this.faceListId = faceListId;
  }


  public FindSimilarRequest largeFaceListId(String largeFaceListId) {
    this.largeFaceListId = largeFaceListId;
    return this;
  }

  /**
   * An existing user-specified unique candidate large face list, created in LargeFaceList - Create. Large face list contains a set of persistedFaceIds which are persisted and will never expire. Parameter faceListId, largeFaceListId and faceIds should not be provided at the same time.
   * @return largeFaceListId
   */
  @javax.annotation.Nullable
  public String getLargeFaceListId() {
    return largeFaceListId;
  }

  public void setLargeFaceListId(String largeFaceListId) {
    this.largeFaceListId = largeFaceListId;
  }


  public FindSimilarRequest maxNumOfCandidatesReturned(Integer maxNumOfCandidatesReturned) {
    this.maxNumOfCandidatesReturned = maxNumOfCandidatesReturned;
    return this;
  }

  /**
   * The number of top similar faces returned. The valid range is [1, 1000].
   * minimum: 1
   * maximum: 1000
   * @return maxNumOfCandidatesReturned
   */
  @javax.annotation.Nullable
  public Integer getMaxNumOfCandidatesReturned() {
    return maxNumOfCandidatesReturned;
  }

  public void setMaxNumOfCandidatesReturned(Integer maxNumOfCandidatesReturned) {
    this.maxNumOfCandidatesReturned = maxNumOfCandidatesReturned;
  }


  public FindSimilarRequest mode(ModeEnum mode) {
    this.mode = mode;
    return this;
  }

  /**
   * Similar face searching mode. It can be \&quot;matchPerson\&quot; or \&quot;matchFace\&quot;.
   * @return mode
   */
  @javax.annotation.Nullable
  public ModeEnum getMode() {
    return mode;
  }

  public void setMode(ModeEnum mode) {
    this.mode = mode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FindSimilarRequest findSimilarRequest = (FindSimilarRequest) o;
    return Objects.equals(this.faceId, findSimilarRequest.faceId) &&
        Objects.equals(this.faceIds, findSimilarRequest.faceIds) &&
        Objects.equals(this.faceListId, findSimilarRequest.faceListId) &&
        Objects.equals(this.largeFaceListId, findSimilarRequest.largeFaceListId) &&
        Objects.equals(this.maxNumOfCandidatesReturned, findSimilarRequest.maxNumOfCandidatesReturned) &&
        Objects.equals(this.mode, findSimilarRequest.mode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(faceId, faceIds, faceListId, largeFaceListId, maxNumOfCandidatesReturned, mode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FindSimilarRequest {\n");
    sb.append("    faceId: ").append(toIndentedString(faceId)).append("\n");
    sb.append("    faceIds: ").append(toIndentedString(faceIds)).append("\n");
    sb.append("    faceListId: ").append(toIndentedString(faceListId)).append("\n");
    sb.append("    largeFaceListId: ").append(toIndentedString(largeFaceListId)).append("\n");
    sb.append("    maxNumOfCandidatesReturned: ").append(toIndentedString(maxNumOfCandidatesReturned)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("faceId");
    openapiFields.add("faceIds");
    openapiFields.add("faceListId");
    openapiFields.add("largeFaceListId");
    openapiFields.add("maxNumOfCandidatesReturned");
    openapiFields.add("mode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("faceId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FindSimilarRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FindSimilarRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FindSimilarRequest is not found in the empty JSON string", FindSimilarRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FindSimilarRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FindSimilarRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FindSimilarRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("faceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `faceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("faceId").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("faceIds") != null && !jsonObj.get("faceIds").isJsonNull() && !jsonObj.get("faceIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `faceIds` to be an array in the JSON string but got `%s`", jsonObj.get("faceIds").toString()));
      }
      if ((jsonObj.get("faceListId") != null && !jsonObj.get("faceListId").isJsonNull()) && !jsonObj.get("faceListId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `faceListId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("faceListId").toString()));
      }
      if ((jsonObj.get("largeFaceListId") != null && !jsonObj.get("largeFaceListId").isJsonNull()) && !jsonObj.get("largeFaceListId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `largeFaceListId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("largeFaceListId").toString()));
      }
      if ((jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) && !jsonObj.get("mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mode").toString()));
      }
      // validate the optional field `mode`
      if (jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) {
        ModeEnum.validateJsonElement(jsonObj.get("mode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FindSimilarRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FindSimilarRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FindSimilarRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FindSimilarRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<FindSimilarRequest>() {
           @Override
           public void write(JsonWriter out, FindSimilarRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FindSimilarRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FindSimilarRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FindSimilarRequest
   * @throws IOException if the JSON string is invalid with respect to FindSimilarRequest
   */
  public static FindSimilarRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FindSimilarRequest.class);
  }

  /**
   * Convert an instance of FindSimilarRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

