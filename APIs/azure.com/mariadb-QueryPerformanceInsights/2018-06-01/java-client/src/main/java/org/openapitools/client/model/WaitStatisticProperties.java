/*
 * MariaDBManagementClient
 * The Microsoft Azure management API provides create, read, update, and delete functionality for Azure MariaDB resources including servers, databases, firewall rules, VNET rules, log files and configurations with new business model.
 *
 * The version of the OpenAPI document: 2018-06-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The properties of a wait statistic.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:08:28.274226-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class WaitStatisticProperties {
  public static final String SERIALIZED_NAME_COUNT = "count";
  @SerializedName(SERIALIZED_NAME_COUNT)
  private Long count;

  public static final String SERIALIZED_NAME_DATABASE_NAME = "databaseName";
  @SerializedName(SERIALIZED_NAME_DATABASE_NAME)
  private String databaseName;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private OffsetDateTime endTime;

  public static final String SERIALIZED_NAME_EVENT_NAME = "eventName";
  @SerializedName(SERIALIZED_NAME_EVENT_NAME)
  private String eventName;

  public static final String SERIALIZED_NAME_EVENT_TYPE_NAME = "eventTypeName";
  @SerializedName(SERIALIZED_NAME_EVENT_TYPE_NAME)
  private String eventTypeName;

  public static final String SERIALIZED_NAME_QUERY_ID = "queryId";
  @SerializedName(SERIALIZED_NAME_QUERY_ID)
  private Long queryId;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private OffsetDateTime startTime;

  public static final String SERIALIZED_NAME_TOTAL_TIME_IN_MS = "totalTimeInMs";
  @SerializedName(SERIALIZED_NAME_TOTAL_TIME_IN_MS)
  private Double totalTimeInMs;

  public static final String SERIALIZED_NAME_USER_ID = "userId";
  @SerializedName(SERIALIZED_NAME_USER_ID)
  private Long userId;

  public WaitStatisticProperties() {
  }

  public WaitStatisticProperties count(Long count) {
    this.count = count;
    return this;
  }

  /**
   * Wait event count observed in this time interval.
   * @return count
   */
  @javax.annotation.Nullable
  public Long getCount() {
    return count;
  }

  public void setCount(Long count) {
    this.count = count;
  }


  public WaitStatisticProperties databaseName(String databaseName) {
    this.databaseName = databaseName;
    return this;
  }

  /**
   * Database Name.
   * @return databaseName
   */
  @javax.annotation.Nullable
  public String getDatabaseName() {
    return databaseName;
  }

  public void setDatabaseName(String databaseName) {
    this.databaseName = databaseName;
  }


  public WaitStatisticProperties endTime(OffsetDateTime endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * Observation end time.
   * @return endTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEndTime() {
    return endTime;
  }

  public void setEndTime(OffsetDateTime endTime) {
    this.endTime = endTime;
  }


  public WaitStatisticProperties eventName(String eventName) {
    this.eventName = eventName;
    return this;
  }

  /**
   * Wait event name.
   * @return eventName
   */
  @javax.annotation.Nullable
  public String getEventName() {
    return eventName;
  }

  public void setEventName(String eventName) {
    this.eventName = eventName;
  }


  public WaitStatisticProperties eventTypeName(String eventTypeName) {
    this.eventTypeName = eventTypeName;
    return this;
  }

  /**
   * Wait event type name.
   * @return eventTypeName
   */
  @javax.annotation.Nullable
  public String getEventTypeName() {
    return eventTypeName;
  }

  public void setEventTypeName(String eventTypeName) {
    this.eventTypeName = eventTypeName;
  }


  public WaitStatisticProperties queryId(Long queryId) {
    this.queryId = queryId;
    return this;
  }

  /**
   * Database query identifier.
   * @return queryId
   */
  @javax.annotation.Nullable
  public Long getQueryId() {
    return queryId;
  }

  public void setQueryId(Long queryId) {
    this.queryId = queryId;
  }


  public WaitStatisticProperties startTime(OffsetDateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Observation start time.
   * @return startTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartTime() {
    return startTime;
  }

  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = startTime;
  }


  public WaitStatisticProperties totalTimeInMs(Double totalTimeInMs) {
    this.totalTimeInMs = totalTimeInMs;
    return this;
  }

  /**
   * Total time of wait in milliseconds in this time interval.
   * @return totalTimeInMs
   */
  @javax.annotation.Nullable
  public Double getTotalTimeInMs() {
    return totalTimeInMs;
  }

  public void setTotalTimeInMs(Double totalTimeInMs) {
    this.totalTimeInMs = totalTimeInMs;
  }


  public WaitStatisticProperties userId(Long userId) {
    this.userId = userId;
    return this;
  }

  /**
   * Database user identifier.
   * @return userId
   */
  @javax.annotation.Nullable
  public Long getUserId() {
    return userId;
  }

  public void setUserId(Long userId) {
    this.userId = userId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WaitStatisticProperties waitStatisticProperties = (WaitStatisticProperties) o;
    return Objects.equals(this.count, waitStatisticProperties.count) &&
        Objects.equals(this.databaseName, waitStatisticProperties.databaseName) &&
        Objects.equals(this.endTime, waitStatisticProperties.endTime) &&
        Objects.equals(this.eventName, waitStatisticProperties.eventName) &&
        Objects.equals(this.eventTypeName, waitStatisticProperties.eventTypeName) &&
        Objects.equals(this.queryId, waitStatisticProperties.queryId) &&
        Objects.equals(this.startTime, waitStatisticProperties.startTime) &&
        Objects.equals(this.totalTimeInMs, waitStatisticProperties.totalTimeInMs) &&
        Objects.equals(this.userId, waitStatisticProperties.userId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(count, databaseName, endTime, eventName, eventTypeName, queryId, startTime, totalTimeInMs, userId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WaitStatisticProperties {\n");
    sb.append("    count: ").append(toIndentedString(count)).append("\n");
    sb.append("    databaseName: ").append(toIndentedString(databaseName)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    eventName: ").append(toIndentedString(eventName)).append("\n");
    sb.append("    eventTypeName: ").append(toIndentedString(eventTypeName)).append("\n");
    sb.append("    queryId: ").append(toIndentedString(queryId)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    totalTimeInMs: ").append(toIndentedString(totalTimeInMs)).append("\n");
    sb.append("    userId: ").append(toIndentedString(userId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("count");
    openapiFields.add("databaseName");
    openapiFields.add("endTime");
    openapiFields.add("eventName");
    openapiFields.add("eventTypeName");
    openapiFields.add("queryId");
    openapiFields.add("startTime");
    openapiFields.add("totalTimeInMs");
    openapiFields.add("userId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to WaitStatisticProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WaitStatisticProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WaitStatisticProperties is not found in the empty JSON string", WaitStatisticProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WaitStatisticProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WaitStatisticProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("databaseName") != null && !jsonObj.get("databaseName").isJsonNull()) && !jsonObj.get("databaseName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseName").toString()));
      }
      if ((jsonObj.get("eventName") != null && !jsonObj.get("eventName").isJsonNull()) && !jsonObj.get("eventName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `eventName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("eventName").toString()));
      }
      if ((jsonObj.get("eventTypeName") != null && !jsonObj.get("eventTypeName").isJsonNull()) && !jsonObj.get("eventTypeName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `eventTypeName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("eventTypeName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WaitStatisticProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WaitStatisticProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WaitStatisticProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WaitStatisticProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<WaitStatisticProperties>() {
           @Override
           public void write(JsonWriter out, WaitStatisticProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WaitStatisticProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of WaitStatisticProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of WaitStatisticProperties
   * @throws IOException if the JSON string is invalid with respect to WaitStatisticProperties
   */
  public static WaitStatisticProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WaitStatisticProperties.class);
  }

  /**
   * Convert an instance of WaitStatisticProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

