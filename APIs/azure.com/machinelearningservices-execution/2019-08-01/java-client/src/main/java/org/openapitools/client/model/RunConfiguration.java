/*
 * Execution Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2019-08-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DataReferenceConfiguration;
import org.openapitools.client.model.EnvironmentDefinition;
import org.openapitools.client.model.HdiConfiguration;
import org.openapitools.client.model.HistoryConfiguration;
import org.openapitools.client.model.MpiConfiguration;
import org.openapitools.client.model.SparkConfiguration;
import org.openapitools.client.model.TensorflowConfiguration;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * RunConfiguration
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:55:51.767311-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RunConfiguration {
  public static final String SERIALIZED_NAME_ARGUMENTS = "arguments";
  @SerializedName(SERIALIZED_NAME_ARGUMENTS)
  private List<String> arguments = new ArrayList<>();

  /**
   * The supported communicators are None, ParameterServer, OpenMpi, and IntelMpi Keep in mind that OpenMpi requires a custom image with OpenMpi installed.  Use ParameterServer or OpenMpi for AmlCompute clusters. Use IntelMpi for distributed training jobs.
   */
  @JsonAdapter(CommunicatorEnum.Adapter.class)
  public enum CommunicatorEnum {
    NONE("None"),
    
    PARAMETER_SERVER("ParameterServer"),
    
    GLOO("Gloo"),
    
    MPI("Mpi"),
    
    NCCL("Nccl");

    private String value;

    CommunicatorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CommunicatorEnum fromValue(String value) {
      for (CommunicatorEnum b : CommunicatorEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CommunicatorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CommunicatorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CommunicatorEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CommunicatorEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CommunicatorEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COMMUNICATOR = "communicator";
  @SerializedName(SERIALIZED_NAME_COMMUNICATOR)
  private CommunicatorEnum communicator;

  public static final String SERIALIZED_NAME_DATA_REFERENCES = "dataReferences";
  @SerializedName(SERIALIZED_NAME_DATA_REFERENCES)
  private Map<String, DataReferenceConfiguration> dataReferences = new HashMap<>();

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private EnvironmentDefinition environment;

  /**
   * The supported frameworks are Python, PySpark, CNTK, TensorFlow, and PyTorch. Use Tensorflow for AmlCompute clusters, and Python for distributed training jobs.
   */
  @JsonAdapter(FrameworkEnum.Adapter.class)
  public enum FrameworkEnum {
    PYTHON("Python"),
    
    PY_SPARK("PySpark"),
    
    CNTK("Cntk"),
    
    TENSOR_FLOW("TensorFlow"),
    
    PY_TORCH("PyTorch");

    private String value;

    FrameworkEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FrameworkEnum fromValue(String value) {
      for (FrameworkEnum b : FrameworkEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FrameworkEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FrameworkEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FrameworkEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FrameworkEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FrameworkEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FRAMEWORK = "framework";
  @SerializedName(SERIALIZED_NAME_FRAMEWORK)
  private FrameworkEnum framework;

  public static final String SERIALIZED_NAME_HDI = "hdi";
  @SerializedName(SERIALIZED_NAME_HDI)
  private HdiConfiguration hdi;

  public static final String SERIALIZED_NAME_HISTORY = "history";
  @SerializedName(SERIALIZED_NAME_HISTORY)
  private HistoryConfiguration history;

  public static final String SERIALIZED_NAME_JOB_NAME = "jobName";
  @SerializedName(SERIALIZED_NAME_JOB_NAME)
  private String jobName;

  public static final String SERIALIZED_NAME_MAX_RUN_DURATION_SECONDS = "maxRunDurationSeconds";
  @SerializedName(SERIALIZED_NAME_MAX_RUN_DURATION_SECONDS)
  private Long maxRunDurationSeconds;

  public static final String SERIALIZED_NAME_MPI = "mpi";
  @SerializedName(SERIALIZED_NAME_MPI)
  private MpiConfiguration mpi;

  public static final String SERIALIZED_NAME_NODE_COUNT = "nodeCount";
  @SerializedName(SERIALIZED_NAME_NODE_COUNT)
  private Integer nodeCount;

  public static final String SERIALIZED_NAME_SCRIPT = "script";
  @SerializedName(SERIALIZED_NAME_SCRIPT)
  private String script;

  public static final String SERIALIZED_NAME_SPARK = "spark";
  @SerializedName(SERIALIZED_NAME_SPARK)
  private SparkConfiguration spark;

  public static final String SERIALIZED_NAME_TARGET = "target";
  @SerializedName(SERIALIZED_NAME_TARGET)
  private String target;

  public static final String SERIALIZED_NAME_TENSORFLOW = "tensorflow";
  @SerializedName(SERIALIZED_NAME_TENSORFLOW)
  private TensorflowConfiguration tensorflow;

  public RunConfiguration() {
  }

  public RunConfiguration arguments(List<String> arguments) {
    this.arguments = arguments;
    return this;
  }

  public RunConfiguration addArgumentsItem(String argumentsItem) {
    if (this.arguments == null) {
      this.arguments = new ArrayList<>();
    }
    this.arguments.add(argumentsItem);
    return this;
  }

  /**
   * Command line arguments for the python script file.
   * @return arguments
   */
  @javax.annotation.Nullable
  public List<String> getArguments() {
    return arguments;
  }

  public void setArguments(List<String> arguments) {
    this.arguments = arguments;
  }


  public RunConfiguration communicator(CommunicatorEnum communicator) {
    this.communicator = communicator;
    return this;
  }

  /**
   * The supported communicators are None, ParameterServer, OpenMpi, and IntelMpi Keep in mind that OpenMpi requires a custom image with OpenMpi installed.  Use ParameterServer or OpenMpi for AmlCompute clusters. Use IntelMpi for distributed training jobs.
   * @return communicator
   */
  @javax.annotation.Nullable
  public CommunicatorEnum getCommunicator() {
    return communicator;
  }

  public void setCommunicator(CommunicatorEnum communicator) {
    this.communicator = communicator;
  }


  public RunConfiguration dataReferences(Map<String, DataReferenceConfiguration> dataReferences) {
    this.dataReferences = dataReferences;
    return this;
  }

  public RunConfiguration putDataReferencesItem(String key, DataReferenceConfiguration dataReferencesItem) {
    if (this.dataReferences == null) {
      this.dataReferences = new HashMap<>();
    }
    this.dataReferences.put(key, dataReferencesItem);
    return this;
  }

  /**
   * All the data sources are made available to the run during execution based on each configuration.
   * @return dataReferences
   */
  @javax.annotation.Nullable
  public Map<String, DataReferenceConfiguration> getDataReferences() {
    return dataReferences;
  }

  public void setDataReferences(Map<String, DataReferenceConfiguration> dataReferences) {
    this.dataReferences = dataReferences;
  }


  public RunConfiguration environment(EnvironmentDefinition environment) {
    this.environment = environment;
    return this;
  }

  /**
   * Get environment
   * @return environment
   */
  @javax.annotation.Nullable
  public EnvironmentDefinition getEnvironment() {
    return environment;
  }

  public void setEnvironment(EnvironmentDefinition environment) {
    this.environment = environment;
  }


  public RunConfiguration framework(FrameworkEnum framework) {
    this.framework = framework;
    return this;
  }

  /**
   * The supported frameworks are Python, PySpark, CNTK, TensorFlow, and PyTorch. Use Tensorflow for AmlCompute clusters, and Python for distributed training jobs.
   * @return framework
   */
  @javax.annotation.Nullable
  public FrameworkEnum getFramework() {
    return framework;
  }

  public void setFramework(FrameworkEnum framework) {
    this.framework = framework;
  }


  public RunConfiguration hdi(HdiConfiguration hdi) {
    this.hdi = hdi;
    return this;
  }

  /**
   * Get hdi
   * @return hdi
   */
  @javax.annotation.Nullable
  public HdiConfiguration getHdi() {
    return hdi;
  }

  public void setHdi(HdiConfiguration hdi) {
    this.hdi = hdi;
  }


  public RunConfiguration history(HistoryConfiguration history) {
    this.history = history;
    return this;
  }

  /**
   * Get history
   * @return history
   */
  @javax.annotation.Nullable
  public HistoryConfiguration getHistory() {
    return history;
  }

  public void setHistory(HistoryConfiguration history) {
    this.history = history;
  }


  public RunConfiguration jobName(String jobName) {
    this.jobName = jobName;
    return this;
  }

  /**
   * This is primarily intended for notebooks to override the default job name.  Defaults to ArgumentVector[0] if not specified.
   * @return jobName
   */
  @javax.annotation.Nullable
  public String getJobName() {
    return jobName;
  }

  public void setJobName(String jobName) {
    this.jobName = jobName;
  }


  public RunConfiguration maxRunDurationSeconds(Long maxRunDurationSeconds) {
    this.maxRunDurationSeconds = maxRunDurationSeconds;
    return this;
  }

  /**
   * Maximum allowed time for the run. The system will attempt to automatically cancel the run if it took longer than this value.  MaxRunDurationSeconds&#x3D;null means infinite duration.
   * @return maxRunDurationSeconds
   */
  @javax.annotation.Nullable
  public Long getMaxRunDurationSeconds() {
    return maxRunDurationSeconds;
  }

  public void setMaxRunDurationSeconds(Long maxRunDurationSeconds) {
    this.maxRunDurationSeconds = maxRunDurationSeconds;
  }


  public RunConfiguration mpi(MpiConfiguration mpi) {
    this.mpi = mpi;
    return this;
  }

  /**
   * Get mpi
   * @return mpi
   */
  @javax.annotation.Nullable
  public MpiConfiguration getMpi() {
    return mpi;
  }

  public void setMpi(MpiConfiguration mpi) {
    this.mpi = mpi;
  }


  public RunConfiguration nodeCount(Integer nodeCount) {
    this.nodeCount = nodeCount;
    return this;
  }

  /**
   * Number of compute nodes to run the job on. Only applies to AMLCompute.
   * @return nodeCount
   */
  @javax.annotation.Nullable
  public Integer getNodeCount() {
    return nodeCount;
  }

  public void setNodeCount(Integer nodeCount) {
    this.nodeCount = nodeCount;
  }


  public RunConfiguration script(String script) {
    this.script = script;
    return this;
  }

  /**
   * The relative path to the python script file. The file path is relative to the source_directory passed to submit run.
   * @return script
   */
  @javax.annotation.Nullable
  public String getScript() {
    return script;
  }

  public void setScript(String script) {
    this.script = script;
  }


  public RunConfiguration spark(SparkConfiguration spark) {
    this.spark = spark;
    return this;
  }

  /**
   * Get spark
   * @return spark
   */
  @javax.annotation.Nullable
  public SparkConfiguration getSpark() {
    return spark;
  }

  public void setSpark(SparkConfiguration spark) {
    this.spark = spark;
  }


  public RunConfiguration target(String target) {
    this.target = target;
    return this;
  }

  /**
   * Target refers to compute where the job is scheduled for execution. The default target is \&quot;local\&quot; referring to the local machine.
   * @return target
   */
  @javax.annotation.Nullable
  public String getTarget() {
    return target;
  }

  public void setTarget(String target) {
    this.target = target;
  }


  public RunConfiguration tensorflow(TensorflowConfiguration tensorflow) {
    this.tensorflow = tensorflow;
    return this;
  }

  /**
   * Get tensorflow
   * @return tensorflow
   */
  @javax.annotation.Nullable
  public TensorflowConfiguration getTensorflow() {
    return tensorflow;
  }

  public void setTensorflow(TensorflowConfiguration tensorflow) {
    this.tensorflow = tensorflow;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RunConfiguration runConfiguration = (RunConfiguration) o;
    return Objects.equals(this.arguments, runConfiguration.arguments) &&
        Objects.equals(this.communicator, runConfiguration.communicator) &&
        Objects.equals(this.dataReferences, runConfiguration.dataReferences) &&
        Objects.equals(this.environment, runConfiguration.environment) &&
        Objects.equals(this.framework, runConfiguration.framework) &&
        Objects.equals(this.hdi, runConfiguration.hdi) &&
        Objects.equals(this.history, runConfiguration.history) &&
        Objects.equals(this.jobName, runConfiguration.jobName) &&
        Objects.equals(this.maxRunDurationSeconds, runConfiguration.maxRunDurationSeconds) &&
        Objects.equals(this.mpi, runConfiguration.mpi) &&
        Objects.equals(this.nodeCount, runConfiguration.nodeCount) &&
        Objects.equals(this.script, runConfiguration.script) &&
        Objects.equals(this.spark, runConfiguration.spark) &&
        Objects.equals(this.target, runConfiguration.target) &&
        Objects.equals(this.tensorflow, runConfiguration.tensorflow);
  }

  @Override
  public int hashCode() {
    return Objects.hash(arguments, communicator, dataReferences, environment, framework, hdi, history, jobName, maxRunDurationSeconds, mpi, nodeCount, script, spark, target, tensorflow);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RunConfiguration {\n");
    sb.append("    arguments: ").append(toIndentedString(arguments)).append("\n");
    sb.append("    communicator: ").append(toIndentedString(communicator)).append("\n");
    sb.append("    dataReferences: ").append(toIndentedString(dataReferences)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    framework: ").append(toIndentedString(framework)).append("\n");
    sb.append("    hdi: ").append(toIndentedString(hdi)).append("\n");
    sb.append("    history: ").append(toIndentedString(history)).append("\n");
    sb.append("    jobName: ").append(toIndentedString(jobName)).append("\n");
    sb.append("    maxRunDurationSeconds: ").append(toIndentedString(maxRunDurationSeconds)).append("\n");
    sb.append("    mpi: ").append(toIndentedString(mpi)).append("\n");
    sb.append("    nodeCount: ").append(toIndentedString(nodeCount)).append("\n");
    sb.append("    script: ").append(toIndentedString(script)).append("\n");
    sb.append("    spark: ").append(toIndentedString(spark)).append("\n");
    sb.append("    target: ").append(toIndentedString(target)).append("\n");
    sb.append("    tensorflow: ").append(toIndentedString(tensorflow)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("arguments");
    openapiFields.add("communicator");
    openapiFields.add("dataReferences");
    openapiFields.add("environment");
    openapiFields.add("framework");
    openapiFields.add("hdi");
    openapiFields.add("history");
    openapiFields.add("jobName");
    openapiFields.add("maxRunDurationSeconds");
    openapiFields.add("mpi");
    openapiFields.add("nodeCount");
    openapiFields.add("script");
    openapiFields.add("spark");
    openapiFields.add("target");
    openapiFields.add("tensorflow");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RunConfiguration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RunConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RunConfiguration is not found in the empty JSON string", RunConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RunConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RunConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("arguments") != null && !jsonObj.get("arguments").isJsonNull() && !jsonObj.get("arguments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `arguments` to be an array in the JSON string but got `%s`", jsonObj.get("arguments").toString()));
      }
      if ((jsonObj.get("communicator") != null && !jsonObj.get("communicator").isJsonNull()) && !jsonObj.get("communicator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `communicator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("communicator").toString()));
      }
      // validate the optional field `communicator`
      if (jsonObj.get("communicator") != null && !jsonObj.get("communicator").isJsonNull()) {
        CommunicatorEnum.validateJsonElement(jsonObj.get("communicator"));
      }
      // validate the optional field `environment`
      if (jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull()) {
        EnvironmentDefinition.validateJsonElement(jsonObj.get("environment"));
      }
      if ((jsonObj.get("framework") != null && !jsonObj.get("framework").isJsonNull()) && !jsonObj.get("framework").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `framework` to be a primitive type in the JSON string but got `%s`", jsonObj.get("framework").toString()));
      }
      // validate the optional field `framework`
      if (jsonObj.get("framework") != null && !jsonObj.get("framework").isJsonNull()) {
        FrameworkEnum.validateJsonElement(jsonObj.get("framework"));
      }
      // validate the optional field `hdi`
      if (jsonObj.get("hdi") != null && !jsonObj.get("hdi").isJsonNull()) {
        HdiConfiguration.validateJsonElement(jsonObj.get("hdi"));
      }
      // validate the optional field `history`
      if (jsonObj.get("history") != null && !jsonObj.get("history").isJsonNull()) {
        HistoryConfiguration.validateJsonElement(jsonObj.get("history"));
      }
      if ((jsonObj.get("jobName") != null && !jsonObj.get("jobName").isJsonNull()) && !jsonObj.get("jobName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `jobName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("jobName").toString()));
      }
      // validate the optional field `mpi`
      if (jsonObj.get("mpi") != null && !jsonObj.get("mpi").isJsonNull()) {
        MpiConfiguration.validateJsonElement(jsonObj.get("mpi"));
      }
      if ((jsonObj.get("script") != null && !jsonObj.get("script").isJsonNull()) && !jsonObj.get("script").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `script` to be a primitive type in the JSON string but got `%s`", jsonObj.get("script").toString()));
      }
      // validate the optional field `spark`
      if (jsonObj.get("spark") != null && !jsonObj.get("spark").isJsonNull()) {
        SparkConfiguration.validateJsonElement(jsonObj.get("spark"));
      }
      if ((jsonObj.get("target") != null && !jsonObj.get("target").isJsonNull()) && !jsonObj.get("target").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `target` to be a primitive type in the JSON string but got `%s`", jsonObj.get("target").toString()));
      }
      // validate the optional field `tensorflow`
      if (jsonObj.get("tensorflow") != null && !jsonObj.get("tensorflow").isJsonNull()) {
        TensorflowConfiguration.validateJsonElement(jsonObj.get("tensorflow"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RunConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RunConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RunConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RunConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<RunConfiguration>() {
           @Override
           public void write(JsonWriter out, RunConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RunConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RunConfiguration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RunConfiguration
   * @throws IOException if the JSON string is invalid with respect to RunConfiguration
   */
  public static RunConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RunConfiguration.class);
  }

  /**
   * Convert an instance of RunConfiguration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

