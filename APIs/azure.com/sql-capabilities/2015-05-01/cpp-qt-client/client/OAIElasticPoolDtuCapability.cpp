/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2015-05-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIElasticPoolDtuCapability.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIElasticPoolDtuCapability::OAIElasticPoolDtuCapability(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIElasticPoolDtuCapability::OAIElasticPoolDtuCapability() {
    this->initializeModel();
}

OAIElasticPoolDtuCapability::~OAIElasticPoolDtuCapability() {}

void OAIElasticPoolDtuCapability::initializeModel() {

    m_included_max_size_isSet = false;
    m_included_max_size_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_max_database_count_isSet = false;
    m_max_database_count_isValid = false;

    m_reason_isSet = false;
    m_reason_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_supported_max_sizes_isSet = false;
    m_supported_max_sizes_isValid = false;

    m_supported_per_database_max_dtus_isSet = false;
    m_supported_per_database_max_dtus_isValid = false;

    m_supported_per_database_max_sizes_isSet = false;
    m_supported_per_database_max_sizes_isValid = false;
}

void OAIElasticPoolDtuCapability::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIElasticPoolDtuCapability::fromJsonObject(QJsonObject json) {

    m_included_max_size_isValid = ::OpenAPI::fromJsonValue(m_included_max_size, json[QString("includedMaxSize")]);
    m_included_max_size_isSet = !json[QString("includedMaxSize")].isNull() && m_included_max_size_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_max_database_count_isValid = ::OpenAPI::fromJsonValue(m_max_database_count, json[QString("maxDatabaseCount")]);
    m_max_database_count_isSet = !json[QString("maxDatabaseCount")].isNull() && m_max_database_count_isValid;

    m_reason_isValid = ::OpenAPI::fromJsonValue(m_reason, json[QString("reason")]);
    m_reason_isSet = !json[QString("reason")].isNull() && m_reason_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_supported_max_sizes_isValid = ::OpenAPI::fromJsonValue(m_supported_max_sizes, json[QString("supportedMaxSizes")]);
    m_supported_max_sizes_isSet = !json[QString("supportedMaxSizes")].isNull() && m_supported_max_sizes_isValid;

    m_supported_per_database_max_dtus_isValid = ::OpenAPI::fromJsonValue(m_supported_per_database_max_dtus, json[QString("supportedPerDatabaseMaxDtus")]);
    m_supported_per_database_max_dtus_isSet = !json[QString("supportedPerDatabaseMaxDtus")].isNull() && m_supported_per_database_max_dtus_isValid;

    m_supported_per_database_max_sizes_isValid = ::OpenAPI::fromJsonValue(m_supported_per_database_max_sizes, json[QString("supportedPerDatabaseMaxSizes")]);
    m_supported_per_database_max_sizes_isSet = !json[QString("supportedPerDatabaseMaxSizes")].isNull() && m_supported_per_database_max_sizes_isValid;
}

QString OAIElasticPoolDtuCapability::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIElasticPoolDtuCapability::asJsonObject() const {
    QJsonObject obj;
    if (m_included_max_size.isSet()) {
        obj.insert(QString("includedMaxSize"), ::OpenAPI::toJsonValue(m_included_max_size));
    }
    if (m_limit_isSet) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_max_database_count_isSet) {
        obj.insert(QString("maxDatabaseCount"), ::OpenAPI::toJsonValue(m_max_database_count));
    }
    if (m_reason_isSet) {
        obj.insert(QString("reason"), ::OpenAPI::toJsonValue(m_reason));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_supported_max_sizes.size() > 0) {
        obj.insert(QString("supportedMaxSizes"), ::OpenAPI::toJsonValue(m_supported_max_sizes));
    }
    if (m_supported_per_database_max_dtus.size() > 0) {
        obj.insert(QString("supportedPerDatabaseMaxDtus"), ::OpenAPI::toJsonValue(m_supported_per_database_max_dtus));
    }
    if (m_supported_per_database_max_sizes.size() > 0) {
        obj.insert(QString("supportedPerDatabaseMaxSizes"), ::OpenAPI::toJsonValue(m_supported_per_database_max_sizes));
    }
    return obj;
}

OAIMaxSizeCapability OAIElasticPoolDtuCapability::getIncludedMaxSize() const {
    return m_included_max_size;
}
void OAIElasticPoolDtuCapability::setIncludedMaxSize(const OAIMaxSizeCapability &included_max_size) {
    m_included_max_size = included_max_size;
    m_included_max_size_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_included_max_size_Set() const{
    return m_included_max_size_isSet;
}

bool OAIElasticPoolDtuCapability::is_included_max_size_Valid() const{
    return m_included_max_size_isValid;
}

qint32 OAIElasticPoolDtuCapability::getLimit() const {
    return m_limit;
}
void OAIElasticPoolDtuCapability::setLimit(const qint32 &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIElasticPoolDtuCapability::is_limit_Valid() const{
    return m_limit_isValid;
}

qint32 OAIElasticPoolDtuCapability::getMaxDatabaseCount() const {
    return m_max_database_count;
}
void OAIElasticPoolDtuCapability::setMaxDatabaseCount(const qint32 &max_database_count) {
    m_max_database_count = max_database_count;
    m_max_database_count_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_max_database_count_Set() const{
    return m_max_database_count_isSet;
}

bool OAIElasticPoolDtuCapability::is_max_database_count_Valid() const{
    return m_max_database_count_isValid;
}

QString OAIElasticPoolDtuCapability::getReason() const {
    return m_reason;
}
void OAIElasticPoolDtuCapability::setReason(const QString &reason) {
    m_reason = reason;
    m_reason_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_reason_Set() const{
    return m_reason_isSet;
}

bool OAIElasticPoolDtuCapability::is_reason_Valid() const{
    return m_reason_isValid;
}

QString OAIElasticPoolDtuCapability::getStatus() const {
    return m_status;
}
void OAIElasticPoolDtuCapability::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_status_Set() const{
    return m_status_isSet;
}

bool OAIElasticPoolDtuCapability::is_status_Valid() const{
    return m_status_isValid;
}

QList<OAIMaxSizeCapability> OAIElasticPoolDtuCapability::getSupportedMaxSizes() const {
    return m_supported_max_sizes;
}
void OAIElasticPoolDtuCapability::setSupportedMaxSizes(const QList<OAIMaxSizeCapability> &supported_max_sizes) {
    m_supported_max_sizes = supported_max_sizes;
    m_supported_max_sizes_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_supported_max_sizes_Set() const{
    return m_supported_max_sizes_isSet;
}

bool OAIElasticPoolDtuCapability::is_supported_max_sizes_Valid() const{
    return m_supported_max_sizes_isValid;
}

QList<OAIElasticPoolPerDatabaseMaxDtuCapability> OAIElasticPoolDtuCapability::getSupportedPerDatabaseMaxDtus() const {
    return m_supported_per_database_max_dtus;
}
void OAIElasticPoolDtuCapability::setSupportedPerDatabaseMaxDtus(const QList<OAIElasticPoolPerDatabaseMaxDtuCapability> &supported_per_database_max_dtus) {
    m_supported_per_database_max_dtus = supported_per_database_max_dtus;
    m_supported_per_database_max_dtus_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_supported_per_database_max_dtus_Set() const{
    return m_supported_per_database_max_dtus_isSet;
}

bool OAIElasticPoolDtuCapability::is_supported_per_database_max_dtus_Valid() const{
    return m_supported_per_database_max_dtus_isValid;
}

QList<OAIMaxSizeCapability> OAIElasticPoolDtuCapability::getSupportedPerDatabaseMaxSizes() const {
    return m_supported_per_database_max_sizes;
}
void OAIElasticPoolDtuCapability::setSupportedPerDatabaseMaxSizes(const QList<OAIMaxSizeCapability> &supported_per_database_max_sizes) {
    m_supported_per_database_max_sizes = supported_per_database_max_sizes;
    m_supported_per_database_max_sizes_isSet = true;
}

bool OAIElasticPoolDtuCapability::is_supported_per_database_max_sizes_Set() const{
    return m_supported_per_database_max_sizes_isSet;
}

bool OAIElasticPoolDtuCapability::is_supported_per_database_max_sizes_Valid() const{
    return m_supported_per_database_max_sizes_isValid;
}

bool OAIElasticPoolDtuCapability::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_included_max_size.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_database_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_max_sizes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_per_database_max_dtus.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_per_database_max_sizes.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIElasticPoolDtuCapability::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
