/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2015-05-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIElasticPoolPerDatabaseMaxDtuCapability.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIElasticPoolPerDatabaseMaxDtuCapability::OAIElasticPoolPerDatabaseMaxDtuCapability(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIElasticPoolPerDatabaseMaxDtuCapability::OAIElasticPoolPerDatabaseMaxDtuCapability() {
    this->initializeModel();
}

OAIElasticPoolPerDatabaseMaxDtuCapability::~OAIElasticPoolPerDatabaseMaxDtuCapability() {}

void OAIElasticPoolPerDatabaseMaxDtuCapability::initializeModel() {

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_reason_isSet = false;
    m_reason_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_supported_per_database_min_dtus_isSet = false;
    m_supported_per_database_min_dtus_isValid = false;
}

void OAIElasticPoolPerDatabaseMaxDtuCapability::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIElasticPoolPerDatabaseMaxDtuCapability::fromJsonObject(QJsonObject json) {

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_reason_isValid = ::OpenAPI::fromJsonValue(m_reason, json[QString("reason")]);
    m_reason_isSet = !json[QString("reason")].isNull() && m_reason_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_supported_per_database_min_dtus_isValid = ::OpenAPI::fromJsonValue(m_supported_per_database_min_dtus, json[QString("supportedPerDatabaseMinDtus")]);
    m_supported_per_database_min_dtus_isSet = !json[QString("supportedPerDatabaseMinDtus")].isNull() && m_supported_per_database_min_dtus_isValid;
}

QString OAIElasticPoolPerDatabaseMaxDtuCapability::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIElasticPoolPerDatabaseMaxDtuCapability::asJsonObject() const {
    QJsonObject obj;
    if (m_limit_isSet) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_reason_isSet) {
        obj.insert(QString("reason"), ::OpenAPI::toJsonValue(m_reason));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_supported_per_database_min_dtus.size() > 0) {
        obj.insert(QString("supportedPerDatabaseMinDtus"), ::OpenAPI::toJsonValue(m_supported_per_database_min_dtus));
    }
    return obj;
}

qint32 OAIElasticPoolPerDatabaseMaxDtuCapability::getLimit() const {
    return m_limit;
}
void OAIElasticPoolPerDatabaseMaxDtuCapability::setLimit(const qint32 &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_limit_Valid() const{
    return m_limit_isValid;
}

QString OAIElasticPoolPerDatabaseMaxDtuCapability::getReason() const {
    return m_reason;
}
void OAIElasticPoolPerDatabaseMaxDtuCapability::setReason(const QString &reason) {
    m_reason = reason;
    m_reason_isSet = true;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_reason_Set() const{
    return m_reason_isSet;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_reason_Valid() const{
    return m_reason_isValid;
}

QString OAIElasticPoolPerDatabaseMaxDtuCapability::getStatus() const {
    return m_status;
}
void OAIElasticPoolPerDatabaseMaxDtuCapability::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_status_Set() const{
    return m_status_isSet;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_status_Valid() const{
    return m_status_isValid;
}

QList<OAIElasticPoolPerDatabaseMinDtuCapability> OAIElasticPoolPerDatabaseMaxDtuCapability::getSupportedPerDatabaseMinDtus() const {
    return m_supported_per_database_min_dtus;
}
void OAIElasticPoolPerDatabaseMaxDtuCapability::setSupportedPerDatabaseMinDtus(const QList<OAIElasticPoolPerDatabaseMinDtuCapability> &supported_per_database_min_dtus) {
    m_supported_per_database_min_dtus = supported_per_database_min_dtus;
    m_supported_per_database_min_dtus_isSet = true;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_supported_per_database_min_dtus_Set() const{
    return m_supported_per_database_min_dtus_isSet;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::is_supported_per_database_min_dtus_Valid() const{
    return m_supported_per_database_min_dtus_isValid;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_per_database_min_dtus.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIElasticPoolPerDatabaseMaxDtuCapability::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
