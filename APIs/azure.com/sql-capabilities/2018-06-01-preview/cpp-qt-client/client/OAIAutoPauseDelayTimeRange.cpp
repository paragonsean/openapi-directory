/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2018-06-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAutoPauseDelayTimeRange.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAutoPauseDelayTimeRange::OAIAutoPauseDelayTimeRange(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAutoPauseDelayTimeRange::OAIAutoPauseDelayTimeRange() {
    this->initializeModel();
}

OAIAutoPauseDelayTimeRange::~OAIAutoPauseDelayTimeRange() {}

void OAIAutoPauseDelayTimeRange::initializeModel() {

    m_r_default_isSet = false;
    m_r_default_isValid = false;

    m_do_not_pause_value_isSet = false;
    m_do_not_pause_value_isValid = false;

    m_max_value_isSet = false;
    m_max_value_isValid = false;

    m_min_value_isSet = false;
    m_min_value_isValid = false;

    m_step_size_isSet = false;
    m_step_size_isValid = false;

    m_unit_isSet = false;
    m_unit_isValid = false;
}

void OAIAutoPauseDelayTimeRange::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAutoPauseDelayTimeRange::fromJsonObject(QJsonObject json) {

    m_r_default_isValid = ::OpenAPI::fromJsonValue(m_r_default, json[QString("default")]);
    m_r_default_isSet = !json[QString("default")].isNull() && m_r_default_isValid;

    m_do_not_pause_value_isValid = ::OpenAPI::fromJsonValue(m_do_not_pause_value, json[QString("doNotPauseValue")]);
    m_do_not_pause_value_isSet = !json[QString("doNotPauseValue")].isNull() && m_do_not_pause_value_isValid;

    m_max_value_isValid = ::OpenAPI::fromJsonValue(m_max_value, json[QString("maxValue")]);
    m_max_value_isSet = !json[QString("maxValue")].isNull() && m_max_value_isValid;

    m_min_value_isValid = ::OpenAPI::fromJsonValue(m_min_value, json[QString("minValue")]);
    m_min_value_isSet = !json[QString("minValue")].isNull() && m_min_value_isValid;

    m_step_size_isValid = ::OpenAPI::fromJsonValue(m_step_size, json[QString("stepSize")]);
    m_step_size_isSet = !json[QString("stepSize")].isNull() && m_step_size_isValid;

    m_unit_isValid = ::OpenAPI::fromJsonValue(m_unit, json[QString("unit")]);
    m_unit_isSet = !json[QString("unit")].isNull() && m_unit_isValid;
}

QString OAIAutoPauseDelayTimeRange::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAutoPauseDelayTimeRange::asJsonObject() const {
    QJsonObject obj;
    if (m_r_default_isSet) {
        obj.insert(QString("default"), ::OpenAPI::toJsonValue(m_r_default));
    }
    if (m_do_not_pause_value_isSet) {
        obj.insert(QString("doNotPauseValue"), ::OpenAPI::toJsonValue(m_do_not_pause_value));
    }
    if (m_max_value_isSet) {
        obj.insert(QString("maxValue"), ::OpenAPI::toJsonValue(m_max_value));
    }
    if (m_min_value_isSet) {
        obj.insert(QString("minValue"), ::OpenAPI::toJsonValue(m_min_value));
    }
    if (m_step_size_isSet) {
        obj.insert(QString("stepSize"), ::OpenAPI::toJsonValue(m_step_size));
    }
    if (m_unit_isSet) {
        obj.insert(QString("unit"), ::OpenAPI::toJsonValue(m_unit));
    }
    return obj;
}

qint32 OAIAutoPauseDelayTimeRange::getRDefault() const {
    return m_r_default;
}
void OAIAutoPauseDelayTimeRange::setRDefault(const qint32 &r_default) {
    m_r_default = r_default;
    m_r_default_isSet = true;
}

bool OAIAutoPauseDelayTimeRange::is_r_default_Set() const{
    return m_r_default_isSet;
}

bool OAIAutoPauseDelayTimeRange::is_r_default_Valid() const{
    return m_r_default_isValid;
}

qint32 OAIAutoPauseDelayTimeRange::getDoNotPauseValue() const {
    return m_do_not_pause_value;
}
void OAIAutoPauseDelayTimeRange::setDoNotPauseValue(const qint32 &do_not_pause_value) {
    m_do_not_pause_value = do_not_pause_value;
    m_do_not_pause_value_isSet = true;
}

bool OAIAutoPauseDelayTimeRange::is_do_not_pause_value_Set() const{
    return m_do_not_pause_value_isSet;
}

bool OAIAutoPauseDelayTimeRange::is_do_not_pause_value_Valid() const{
    return m_do_not_pause_value_isValid;
}

qint32 OAIAutoPauseDelayTimeRange::getMaxValue() const {
    return m_max_value;
}
void OAIAutoPauseDelayTimeRange::setMaxValue(const qint32 &max_value) {
    m_max_value = max_value;
    m_max_value_isSet = true;
}

bool OAIAutoPauseDelayTimeRange::is_max_value_Set() const{
    return m_max_value_isSet;
}

bool OAIAutoPauseDelayTimeRange::is_max_value_Valid() const{
    return m_max_value_isValid;
}

qint32 OAIAutoPauseDelayTimeRange::getMinValue() const {
    return m_min_value;
}
void OAIAutoPauseDelayTimeRange::setMinValue(const qint32 &min_value) {
    m_min_value = min_value;
    m_min_value_isSet = true;
}

bool OAIAutoPauseDelayTimeRange::is_min_value_Set() const{
    return m_min_value_isSet;
}

bool OAIAutoPauseDelayTimeRange::is_min_value_Valid() const{
    return m_min_value_isValid;
}

qint32 OAIAutoPauseDelayTimeRange::getStepSize() const {
    return m_step_size;
}
void OAIAutoPauseDelayTimeRange::setStepSize(const qint32 &step_size) {
    m_step_size = step_size;
    m_step_size_isSet = true;
}

bool OAIAutoPauseDelayTimeRange::is_step_size_Set() const{
    return m_step_size_isSet;
}

bool OAIAutoPauseDelayTimeRange::is_step_size_Valid() const{
    return m_step_size_isValid;
}

QString OAIAutoPauseDelayTimeRange::getUnit() const {
    return m_unit;
}
void OAIAutoPauseDelayTimeRange::setUnit(const QString &unit) {
    m_unit = unit;
    m_unit_isSet = true;
}

bool OAIAutoPauseDelayTimeRange::is_unit_Set() const{
    return m_unit_isSet;
}

bool OAIAutoPauseDelayTimeRange::is_unit_Valid() const{
    return m_unit_isValid;
}

bool OAIAutoPauseDelayTimeRange::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_r_default_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_do_not_pause_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_step_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unit_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAutoPauseDelayTimeRange::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
