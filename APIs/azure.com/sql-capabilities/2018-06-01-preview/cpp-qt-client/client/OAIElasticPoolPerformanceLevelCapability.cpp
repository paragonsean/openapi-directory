/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2018-06-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIElasticPoolPerformanceLevelCapability.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIElasticPoolPerformanceLevelCapability::OAIElasticPoolPerformanceLevelCapability(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIElasticPoolPerformanceLevelCapability::OAIElasticPoolPerformanceLevelCapability() {
    this->initializeModel();
}

OAIElasticPoolPerformanceLevelCapability::~OAIElasticPoolPerformanceLevelCapability() {}

void OAIElasticPoolPerformanceLevelCapability::initializeModel() {

    m_included_max_size_isSet = false;
    m_included_max_size_isValid = false;

    m_max_database_count_isSet = false;
    m_max_database_count_isValid = false;

    m_performance_level_isSet = false;
    m_performance_level_isValid = false;

    m_reason_isSet = false;
    m_reason_isValid = false;

    m_sku_isSet = false;
    m_sku_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_supported_license_types_isSet = false;
    m_supported_license_types_isValid = false;

    m_supported_max_sizes_isSet = false;
    m_supported_max_sizes_isValid = false;

    m_supported_per_database_max_performance_levels_isSet = false;
    m_supported_per_database_max_performance_levels_isValid = false;

    m_supported_per_database_max_sizes_isSet = false;
    m_supported_per_database_max_sizes_isValid = false;

    m_zone_redundant_isSet = false;
    m_zone_redundant_isValid = false;
}

void OAIElasticPoolPerformanceLevelCapability::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIElasticPoolPerformanceLevelCapability::fromJsonObject(QJsonObject json) {

    m_included_max_size_isValid = ::OpenAPI::fromJsonValue(m_included_max_size, json[QString("includedMaxSize")]);
    m_included_max_size_isSet = !json[QString("includedMaxSize")].isNull() && m_included_max_size_isValid;

    m_max_database_count_isValid = ::OpenAPI::fromJsonValue(m_max_database_count, json[QString("maxDatabaseCount")]);
    m_max_database_count_isSet = !json[QString("maxDatabaseCount")].isNull() && m_max_database_count_isValid;

    m_performance_level_isValid = ::OpenAPI::fromJsonValue(m_performance_level, json[QString("performanceLevel")]);
    m_performance_level_isSet = !json[QString("performanceLevel")].isNull() && m_performance_level_isValid;

    m_reason_isValid = ::OpenAPI::fromJsonValue(m_reason, json[QString("reason")]);
    m_reason_isSet = !json[QString("reason")].isNull() && m_reason_isValid;

    m_sku_isValid = ::OpenAPI::fromJsonValue(m_sku, json[QString("sku")]);
    m_sku_isSet = !json[QString("sku")].isNull() && m_sku_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_supported_license_types_isValid = ::OpenAPI::fromJsonValue(m_supported_license_types, json[QString("supportedLicenseTypes")]);
    m_supported_license_types_isSet = !json[QString("supportedLicenseTypes")].isNull() && m_supported_license_types_isValid;

    m_supported_max_sizes_isValid = ::OpenAPI::fromJsonValue(m_supported_max_sizes, json[QString("supportedMaxSizes")]);
    m_supported_max_sizes_isSet = !json[QString("supportedMaxSizes")].isNull() && m_supported_max_sizes_isValid;

    m_supported_per_database_max_performance_levels_isValid = ::OpenAPI::fromJsonValue(m_supported_per_database_max_performance_levels, json[QString("supportedPerDatabaseMaxPerformanceLevels")]);
    m_supported_per_database_max_performance_levels_isSet = !json[QString("supportedPerDatabaseMaxPerformanceLevels")].isNull() && m_supported_per_database_max_performance_levels_isValid;

    m_supported_per_database_max_sizes_isValid = ::OpenAPI::fromJsonValue(m_supported_per_database_max_sizes, json[QString("supportedPerDatabaseMaxSizes")]);
    m_supported_per_database_max_sizes_isSet = !json[QString("supportedPerDatabaseMaxSizes")].isNull() && m_supported_per_database_max_sizes_isValid;

    m_zone_redundant_isValid = ::OpenAPI::fromJsonValue(m_zone_redundant, json[QString("zoneRedundant")]);
    m_zone_redundant_isSet = !json[QString("zoneRedundant")].isNull() && m_zone_redundant_isValid;
}

QString OAIElasticPoolPerformanceLevelCapability::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIElasticPoolPerformanceLevelCapability::asJsonObject() const {
    QJsonObject obj;
    if (m_included_max_size.isSet()) {
        obj.insert(QString("includedMaxSize"), ::OpenAPI::toJsonValue(m_included_max_size));
    }
    if (m_max_database_count_isSet) {
        obj.insert(QString("maxDatabaseCount"), ::OpenAPI::toJsonValue(m_max_database_count));
    }
    if (m_performance_level.isSet()) {
        obj.insert(QString("performanceLevel"), ::OpenAPI::toJsonValue(m_performance_level));
    }
    if (m_reason_isSet) {
        obj.insert(QString("reason"), ::OpenAPI::toJsonValue(m_reason));
    }
    if (m_sku.isSet()) {
        obj.insert(QString("sku"), ::OpenAPI::toJsonValue(m_sku));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_supported_license_types.size() > 0) {
        obj.insert(QString("supportedLicenseTypes"), ::OpenAPI::toJsonValue(m_supported_license_types));
    }
    if (m_supported_max_sizes.size() > 0) {
        obj.insert(QString("supportedMaxSizes"), ::OpenAPI::toJsonValue(m_supported_max_sizes));
    }
    if (m_supported_per_database_max_performance_levels.size() > 0) {
        obj.insert(QString("supportedPerDatabaseMaxPerformanceLevels"), ::OpenAPI::toJsonValue(m_supported_per_database_max_performance_levels));
    }
    if (m_supported_per_database_max_sizes.size() > 0) {
        obj.insert(QString("supportedPerDatabaseMaxSizes"), ::OpenAPI::toJsonValue(m_supported_per_database_max_sizes));
    }
    if (m_zone_redundant_isSet) {
        obj.insert(QString("zoneRedundant"), ::OpenAPI::toJsonValue(m_zone_redundant));
    }
    return obj;
}

OAIMaxSizeCapability OAIElasticPoolPerformanceLevelCapability::getIncludedMaxSize() const {
    return m_included_max_size;
}
void OAIElasticPoolPerformanceLevelCapability::setIncludedMaxSize(const OAIMaxSizeCapability &included_max_size) {
    m_included_max_size = included_max_size;
    m_included_max_size_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_included_max_size_Set() const{
    return m_included_max_size_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_included_max_size_Valid() const{
    return m_included_max_size_isValid;
}

qint32 OAIElasticPoolPerformanceLevelCapability::getMaxDatabaseCount() const {
    return m_max_database_count;
}
void OAIElasticPoolPerformanceLevelCapability::setMaxDatabaseCount(const qint32 &max_database_count) {
    m_max_database_count = max_database_count;
    m_max_database_count_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_max_database_count_Set() const{
    return m_max_database_count_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_max_database_count_Valid() const{
    return m_max_database_count_isValid;
}

OAIPerformanceLevelCapability OAIElasticPoolPerformanceLevelCapability::getPerformanceLevel() const {
    return m_performance_level;
}
void OAIElasticPoolPerformanceLevelCapability::setPerformanceLevel(const OAIPerformanceLevelCapability &performance_level) {
    m_performance_level = performance_level;
    m_performance_level_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_performance_level_Set() const{
    return m_performance_level_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_performance_level_Valid() const{
    return m_performance_level_isValid;
}

QString OAIElasticPoolPerformanceLevelCapability::getReason() const {
    return m_reason;
}
void OAIElasticPoolPerformanceLevelCapability::setReason(const QString &reason) {
    m_reason = reason;
    m_reason_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_reason_Set() const{
    return m_reason_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_reason_Valid() const{
    return m_reason_isValid;
}

OAIElasticPoolPerformanceLevelCapability_sku OAIElasticPoolPerformanceLevelCapability::getSku() const {
    return m_sku;
}
void OAIElasticPoolPerformanceLevelCapability::setSku(const OAIElasticPoolPerformanceLevelCapability_sku &sku) {
    m_sku = sku;
    m_sku_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_sku_Set() const{
    return m_sku_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_sku_Valid() const{
    return m_sku_isValid;
}

QString OAIElasticPoolPerformanceLevelCapability::getStatus() const {
    return m_status;
}
void OAIElasticPoolPerformanceLevelCapability::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_status_Set() const{
    return m_status_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_status_Valid() const{
    return m_status_isValid;
}

QList<OAILicenseTypeCapability> OAIElasticPoolPerformanceLevelCapability::getSupportedLicenseTypes() const {
    return m_supported_license_types;
}
void OAIElasticPoolPerformanceLevelCapability::setSupportedLicenseTypes(const QList<OAILicenseTypeCapability> &supported_license_types) {
    m_supported_license_types = supported_license_types;
    m_supported_license_types_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_license_types_Set() const{
    return m_supported_license_types_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_license_types_Valid() const{
    return m_supported_license_types_isValid;
}

QList<OAIMaxSizeRangeCapability> OAIElasticPoolPerformanceLevelCapability::getSupportedMaxSizes() const {
    return m_supported_max_sizes;
}
void OAIElasticPoolPerformanceLevelCapability::setSupportedMaxSizes(const QList<OAIMaxSizeRangeCapability> &supported_max_sizes) {
    m_supported_max_sizes = supported_max_sizes;
    m_supported_max_sizes_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_max_sizes_Set() const{
    return m_supported_max_sizes_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_max_sizes_Valid() const{
    return m_supported_max_sizes_isValid;
}

QList<OAIElasticPoolPerDatabaseMaxPerformanceLevelCapability> OAIElasticPoolPerformanceLevelCapability::getSupportedPerDatabaseMaxPerformanceLevels() const {
    return m_supported_per_database_max_performance_levels;
}
void OAIElasticPoolPerformanceLevelCapability::setSupportedPerDatabaseMaxPerformanceLevels(const QList<OAIElasticPoolPerDatabaseMaxPerformanceLevelCapability> &supported_per_database_max_performance_levels) {
    m_supported_per_database_max_performance_levels = supported_per_database_max_performance_levels;
    m_supported_per_database_max_performance_levels_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_per_database_max_performance_levels_Set() const{
    return m_supported_per_database_max_performance_levels_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_per_database_max_performance_levels_Valid() const{
    return m_supported_per_database_max_performance_levels_isValid;
}

QList<OAIMaxSizeRangeCapability> OAIElasticPoolPerformanceLevelCapability::getSupportedPerDatabaseMaxSizes() const {
    return m_supported_per_database_max_sizes;
}
void OAIElasticPoolPerformanceLevelCapability::setSupportedPerDatabaseMaxSizes(const QList<OAIMaxSizeRangeCapability> &supported_per_database_max_sizes) {
    m_supported_per_database_max_sizes = supported_per_database_max_sizes;
    m_supported_per_database_max_sizes_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_per_database_max_sizes_Set() const{
    return m_supported_per_database_max_sizes_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_supported_per_database_max_sizes_Valid() const{
    return m_supported_per_database_max_sizes_isValid;
}

bool OAIElasticPoolPerformanceLevelCapability::isZoneRedundant() const {
    return m_zone_redundant;
}
void OAIElasticPoolPerformanceLevelCapability::setZoneRedundant(const bool &zone_redundant) {
    m_zone_redundant = zone_redundant;
    m_zone_redundant_isSet = true;
}

bool OAIElasticPoolPerformanceLevelCapability::is_zone_redundant_Set() const{
    return m_zone_redundant_isSet;
}

bool OAIElasticPoolPerformanceLevelCapability::is_zone_redundant_Valid() const{
    return m_zone_redundant_isValid;
}

bool OAIElasticPoolPerformanceLevelCapability::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_included_max_size.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_database_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_performance_level.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sku.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_license_types.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_max_sizes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_per_database_max_performance_levels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_per_database_max_sizes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_zone_redundant_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIElasticPoolPerformanceLevelCapability::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
