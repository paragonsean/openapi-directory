/**
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2015-05-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIEncryptionProtectorProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIEncryptionProtectorProperties::OAIEncryptionProtectorProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIEncryptionProtectorProperties::OAIEncryptionProtectorProperties() {
    this->initializeModel();
}

OAIEncryptionProtectorProperties::~OAIEncryptionProtectorProperties() {}

void OAIEncryptionProtectorProperties::initializeModel() {

    m_server_key_name_isSet = false;
    m_server_key_name_isValid = false;

    m_server_key_type_isSet = false;
    m_server_key_type_isValid = false;

    m_subregion_isSet = false;
    m_subregion_isValid = false;

    m_thumbprint_isSet = false;
    m_thumbprint_isValid = false;

    m_uri_isSet = false;
    m_uri_isValid = false;
}

void OAIEncryptionProtectorProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIEncryptionProtectorProperties::fromJsonObject(QJsonObject json) {

    m_server_key_name_isValid = ::OpenAPI::fromJsonValue(m_server_key_name, json[QString("serverKeyName")]);
    m_server_key_name_isSet = !json[QString("serverKeyName")].isNull() && m_server_key_name_isValid;

    m_server_key_type_isValid = ::OpenAPI::fromJsonValue(m_server_key_type, json[QString("serverKeyType")]);
    m_server_key_type_isSet = !json[QString("serverKeyType")].isNull() && m_server_key_type_isValid;

    m_subregion_isValid = ::OpenAPI::fromJsonValue(m_subregion, json[QString("subregion")]);
    m_subregion_isSet = !json[QString("subregion")].isNull() && m_subregion_isValid;

    m_thumbprint_isValid = ::OpenAPI::fromJsonValue(m_thumbprint, json[QString("thumbprint")]);
    m_thumbprint_isSet = !json[QString("thumbprint")].isNull() && m_thumbprint_isValid;

    m_uri_isValid = ::OpenAPI::fromJsonValue(m_uri, json[QString("uri")]);
    m_uri_isSet = !json[QString("uri")].isNull() && m_uri_isValid;
}

QString OAIEncryptionProtectorProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIEncryptionProtectorProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_server_key_name_isSet) {
        obj.insert(QString("serverKeyName"), ::OpenAPI::toJsonValue(m_server_key_name));
    }
    if (m_server_key_type_isSet) {
        obj.insert(QString("serverKeyType"), ::OpenAPI::toJsonValue(m_server_key_type));
    }
    if (m_subregion_isSet) {
        obj.insert(QString("subregion"), ::OpenAPI::toJsonValue(m_subregion));
    }
    if (m_thumbprint_isSet) {
        obj.insert(QString("thumbprint"), ::OpenAPI::toJsonValue(m_thumbprint));
    }
    if (m_uri_isSet) {
        obj.insert(QString("uri"), ::OpenAPI::toJsonValue(m_uri));
    }
    return obj;
}

QString OAIEncryptionProtectorProperties::getServerKeyName() const {
    return m_server_key_name;
}
void OAIEncryptionProtectorProperties::setServerKeyName(const QString &server_key_name) {
    m_server_key_name = server_key_name;
    m_server_key_name_isSet = true;
}

bool OAIEncryptionProtectorProperties::is_server_key_name_Set() const{
    return m_server_key_name_isSet;
}

bool OAIEncryptionProtectorProperties::is_server_key_name_Valid() const{
    return m_server_key_name_isValid;
}

QString OAIEncryptionProtectorProperties::getServerKeyType() const {
    return m_server_key_type;
}
void OAIEncryptionProtectorProperties::setServerKeyType(const QString &server_key_type) {
    m_server_key_type = server_key_type;
    m_server_key_type_isSet = true;
}

bool OAIEncryptionProtectorProperties::is_server_key_type_Set() const{
    return m_server_key_type_isSet;
}

bool OAIEncryptionProtectorProperties::is_server_key_type_Valid() const{
    return m_server_key_type_isValid;
}

QString OAIEncryptionProtectorProperties::getSubregion() const {
    return m_subregion;
}
void OAIEncryptionProtectorProperties::setSubregion(const QString &subregion) {
    m_subregion = subregion;
    m_subregion_isSet = true;
}

bool OAIEncryptionProtectorProperties::is_subregion_Set() const{
    return m_subregion_isSet;
}

bool OAIEncryptionProtectorProperties::is_subregion_Valid() const{
    return m_subregion_isValid;
}

QString OAIEncryptionProtectorProperties::getThumbprint() const {
    return m_thumbprint;
}
void OAIEncryptionProtectorProperties::setThumbprint(const QString &thumbprint) {
    m_thumbprint = thumbprint;
    m_thumbprint_isSet = true;
}

bool OAIEncryptionProtectorProperties::is_thumbprint_Set() const{
    return m_thumbprint_isSet;
}

bool OAIEncryptionProtectorProperties::is_thumbprint_Valid() const{
    return m_thumbprint_isValid;
}

QString OAIEncryptionProtectorProperties::getUri() const {
    return m_uri;
}
void OAIEncryptionProtectorProperties::setUri(const QString &uri) {
    m_uri = uri;
    m_uri_isSet = true;
}

bool OAIEncryptionProtectorProperties::is_uri_Set() const{
    return m_uri_isSet;
}

bool OAIEncryptionProtectorProperties::is_uri_Valid() const{
    return m_uri_isValid;
}

bool OAIEncryptionProtectorProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_server_key_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_server_key_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_subregion_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_thumbprint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uri_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIEncryptionProtectorProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_server_key_type_isValid && true;
}

} // namespace OpenAPI
