/*
 * Azure Log Analytics Query Packs
 * Azure Log Analytics API reference for Query Packs management.
 *
 * The version of the OpenAPI document: 2019-09-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Properties that define a Log Analytics QueryPack resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:12:11.994636-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LogAnalyticsQueryPackProperties {
  public static final String SERIALIZED_NAME_PROVISIONING_STATE = "provisioningState";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE)
  private String provisioningState;

  public static final String SERIALIZED_NAME_QUERY_PACK_ID = "queryPackId";
  @SerializedName(SERIALIZED_NAME_QUERY_PACK_ID)
  private String queryPackId;

  public static final String SERIALIZED_NAME_TIME_CREATED = "timeCreated";
  @SerializedName(SERIALIZED_NAME_TIME_CREATED)
  private OffsetDateTime timeCreated;

  public static final String SERIALIZED_NAME_TIME_MODIFIED = "timeModified";
  @SerializedName(SERIALIZED_NAME_TIME_MODIFIED)
  private OffsetDateTime timeModified;

  public LogAnalyticsQueryPackProperties() {
  }

  public LogAnalyticsQueryPackProperties(
     String provisioningState, 
     String queryPackId, 
     OffsetDateTime timeCreated, 
     OffsetDateTime timeModified
  ) {
    this();
    this.provisioningState = provisioningState;
    this.queryPackId = queryPackId;
    this.timeCreated = timeCreated;
    this.timeModified = timeModified;
  }

  /**
   * Current state of this QueryPack: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Succeeded, Deploying, Canceled, and Failed.
   * @return provisioningState
   */
  @javax.annotation.Nullable
  public String getProvisioningState() {
    return provisioningState;
  }



  /**
   * The unique ID of your application. This field cannot be changed.
   * @return queryPackId
   */
  @javax.annotation.Nullable
  public String getQueryPackId() {
    return queryPackId;
  }



  /**
   * Creation Date for the Log Analytics QueryPack, in ISO 8601 format.
   * @return timeCreated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTimeCreated() {
    return timeCreated;
  }



  /**
   * Last modified date of the Log Analytics QueryPack, in ISO 8601 format.
   * @return timeModified
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTimeModified() {
    return timeModified;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LogAnalyticsQueryPackProperties logAnalyticsQueryPackProperties = (LogAnalyticsQueryPackProperties) o;
    return Objects.equals(this.provisioningState, logAnalyticsQueryPackProperties.provisioningState) &&
        Objects.equals(this.queryPackId, logAnalyticsQueryPackProperties.queryPackId) &&
        Objects.equals(this.timeCreated, logAnalyticsQueryPackProperties.timeCreated) &&
        Objects.equals(this.timeModified, logAnalyticsQueryPackProperties.timeModified);
  }

  @Override
  public int hashCode() {
    return Objects.hash(provisioningState, queryPackId, timeCreated, timeModified);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LogAnalyticsQueryPackProperties {\n");
    sb.append("    provisioningState: ").append(toIndentedString(provisioningState)).append("\n");
    sb.append("    queryPackId: ").append(toIndentedString(queryPackId)).append("\n");
    sb.append("    timeCreated: ").append(toIndentedString(timeCreated)).append("\n");
    sb.append("    timeModified: ").append(toIndentedString(timeModified)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("provisioningState");
    openapiFields.add("queryPackId");
    openapiFields.add("timeCreated");
    openapiFields.add("timeModified");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LogAnalyticsQueryPackProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LogAnalyticsQueryPackProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LogAnalyticsQueryPackProperties is not found in the empty JSON string", LogAnalyticsQueryPackProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LogAnalyticsQueryPackProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LogAnalyticsQueryPackProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) && !jsonObj.get("provisioningState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioningState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioningState").toString()));
      }
      if ((jsonObj.get("queryPackId") != null && !jsonObj.get("queryPackId").isJsonNull()) && !jsonObj.get("queryPackId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `queryPackId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("queryPackId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LogAnalyticsQueryPackProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LogAnalyticsQueryPackProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LogAnalyticsQueryPackProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LogAnalyticsQueryPackProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<LogAnalyticsQueryPackProperties>() {
           @Override
           public void write(JsonWriter out, LogAnalyticsQueryPackProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LogAnalyticsQueryPackProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LogAnalyticsQueryPackProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LogAnalyticsQueryPackProperties
   * @throws IOException if the JSON string is invalid with respect to LogAnalyticsQueryPackProperties
   */
  public static LogAnalyticsQueryPackProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LogAnalyticsQueryPackProperties.class);
  }

  /**
   * Convert an instance of LogAnalyticsQueryPackProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

