/*
 * ExpressRouteCrossConnection REST APIs
 * The Microsoft Azure ExpressRouteCrossConnection Resource Provider REST APIs describes the operations for the connectivity provider to provision ExpressRoute circuit, create and modify BGP peering entities and troubleshoot connectivity on customer's ExpressRoute circuit.
 *
 * The version of the OpenAPI document: 2019-07-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The routes table associated with the ExpressRouteCircuit.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:23:34.769281-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExpressRouteCrossConnectionRoutesTableSummary {
  public static final String SERIALIZED_NAME_ASN = "asn";
  @SerializedName(SERIALIZED_NAME_ASN)
  private Integer asn;

  public static final String SERIALIZED_NAME_NEIGHBOR = "neighbor";
  @SerializedName(SERIALIZED_NAME_NEIGHBOR)
  private String neighbor;

  public static final String SERIALIZED_NAME_STATE_OR_PREFIXES_RECEIVED = "stateOrPrefixesReceived";
  @SerializedName(SERIALIZED_NAME_STATE_OR_PREFIXES_RECEIVED)
  private String stateOrPrefixesReceived;

  public static final String SERIALIZED_NAME_UP_DOWN = "upDown";
  @SerializedName(SERIALIZED_NAME_UP_DOWN)
  private String upDown;

  public ExpressRouteCrossConnectionRoutesTableSummary() {
  }

  public ExpressRouteCrossConnectionRoutesTableSummary asn(Integer asn) {
    this.asn = asn;
    return this;
  }

  /**
   * Autonomous system number.
   * @return asn
   */
  @javax.annotation.Nullable
  public Integer getAsn() {
    return asn;
  }

  public void setAsn(Integer asn) {
    this.asn = asn;
  }


  public ExpressRouteCrossConnectionRoutesTableSummary neighbor(String neighbor) {
    this.neighbor = neighbor;
    return this;
  }

  /**
   * IP address of Neighbor router.
   * @return neighbor
   */
  @javax.annotation.Nullable
  public String getNeighbor() {
    return neighbor;
  }

  public void setNeighbor(String neighbor) {
    this.neighbor = neighbor;
  }


  public ExpressRouteCrossConnectionRoutesTableSummary stateOrPrefixesReceived(String stateOrPrefixesReceived) {
    this.stateOrPrefixesReceived = stateOrPrefixesReceived;
    return this;
  }

  /**
   * Current state of the BGP session, and the number of prefixes that have been received from a neighbor or peer group.
   * @return stateOrPrefixesReceived
   */
  @javax.annotation.Nullable
  public String getStateOrPrefixesReceived() {
    return stateOrPrefixesReceived;
  }

  public void setStateOrPrefixesReceived(String stateOrPrefixesReceived) {
    this.stateOrPrefixesReceived = stateOrPrefixesReceived;
  }


  public ExpressRouteCrossConnectionRoutesTableSummary upDown(String upDown) {
    this.upDown = upDown;
    return this;
  }

  /**
   * The length of time that the BGP session has been in the Established state, or the current status if not in the Established state.
   * @return upDown
   */
  @javax.annotation.Nullable
  public String getUpDown() {
    return upDown;
  }

  public void setUpDown(String upDown) {
    this.upDown = upDown;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExpressRouteCrossConnectionRoutesTableSummary expressRouteCrossConnectionRoutesTableSummary = (ExpressRouteCrossConnectionRoutesTableSummary) o;
    return Objects.equals(this.asn, expressRouteCrossConnectionRoutesTableSummary.asn) &&
        Objects.equals(this.neighbor, expressRouteCrossConnectionRoutesTableSummary.neighbor) &&
        Objects.equals(this.stateOrPrefixesReceived, expressRouteCrossConnectionRoutesTableSummary.stateOrPrefixesReceived) &&
        Objects.equals(this.upDown, expressRouteCrossConnectionRoutesTableSummary.upDown);
  }

  @Override
  public int hashCode() {
    return Objects.hash(asn, neighbor, stateOrPrefixesReceived, upDown);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExpressRouteCrossConnectionRoutesTableSummary {\n");
    sb.append("    asn: ").append(toIndentedString(asn)).append("\n");
    sb.append("    neighbor: ").append(toIndentedString(neighbor)).append("\n");
    sb.append("    stateOrPrefixesReceived: ").append(toIndentedString(stateOrPrefixesReceived)).append("\n");
    sb.append("    upDown: ").append(toIndentedString(upDown)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("asn");
    openapiFields.add("neighbor");
    openapiFields.add("stateOrPrefixesReceived");
    openapiFields.add("upDown");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExpressRouteCrossConnectionRoutesTableSummary
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExpressRouteCrossConnectionRoutesTableSummary.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExpressRouteCrossConnectionRoutesTableSummary is not found in the empty JSON string", ExpressRouteCrossConnectionRoutesTableSummary.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExpressRouteCrossConnectionRoutesTableSummary.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExpressRouteCrossConnectionRoutesTableSummary` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("neighbor") != null && !jsonObj.get("neighbor").isJsonNull()) && !jsonObj.get("neighbor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `neighbor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("neighbor").toString()));
      }
      if ((jsonObj.get("stateOrPrefixesReceived") != null && !jsonObj.get("stateOrPrefixesReceived").isJsonNull()) && !jsonObj.get("stateOrPrefixesReceived").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stateOrPrefixesReceived` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stateOrPrefixesReceived").toString()));
      }
      if ((jsonObj.get("upDown") != null && !jsonObj.get("upDown").isJsonNull()) && !jsonObj.get("upDown").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `upDown` to be a primitive type in the JSON string but got `%s`", jsonObj.get("upDown").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExpressRouteCrossConnectionRoutesTableSummary.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExpressRouteCrossConnectionRoutesTableSummary' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExpressRouteCrossConnectionRoutesTableSummary> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExpressRouteCrossConnectionRoutesTableSummary.class));

       return (TypeAdapter<T>) new TypeAdapter<ExpressRouteCrossConnectionRoutesTableSummary>() {
           @Override
           public void write(JsonWriter out, ExpressRouteCrossConnectionRoutesTableSummary value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExpressRouteCrossConnectionRoutesTableSummary read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExpressRouteCrossConnectionRoutesTableSummary given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExpressRouteCrossConnectionRoutesTableSummary
   * @throws IOException if the JSON string is invalid with respect to ExpressRouteCrossConnectionRoutesTableSummary
   */
  public static ExpressRouteCrossConnectionRoutesTableSummary fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExpressRouteCrossConnectionRoutesTableSummary.class);
  }

  /**
   * Convert an instance of ExpressRouteCrossConnectionRoutesTableSummary to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

