/**
 * ExpressRouteCrossConnection REST APIs
 * The Microsoft Azure ExpressRouteCrossConnection Resource Provider REST APIs describes the operations for the connectivity provider to provision ExpressRoute circuit, create and modify BGP peering entities and troubleshoot connectivity on customer's ExpressRoute circuit.
 *
 * The version of the OpenAPI document: 2019-04-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIExpressRouteCrossConnectionProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIExpressRouteCrossConnectionProperties::OAIExpressRouteCrossConnectionProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIExpressRouteCrossConnectionProperties::OAIExpressRouteCrossConnectionProperties() {
    this->initializeModel();
}

OAIExpressRouteCrossConnectionProperties::~OAIExpressRouteCrossConnectionProperties() {}

void OAIExpressRouteCrossConnectionProperties::initializeModel() {

    m_bandwidth_in_mbps_isSet = false;
    m_bandwidth_in_mbps_isValid = false;

    m_express_route_circuit_isSet = false;
    m_express_route_circuit_isValid = false;

    m_peering_location_isSet = false;
    m_peering_location_isValid = false;

    m_peerings_isSet = false;
    m_peerings_isValid = false;

    m_primary_azure_port_isSet = false;
    m_primary_azure_port_isValid = false;

    m_provisioning_state_isSet = false;
    m_provisioning_state_isValid = false;

    m_s_tag_isSet = false;
    m_s_tag_isValid = false;

    m_secondary_azure_port_isSet = false;
    m_secondary_azure_port_isValid = false;

    m_service_provider_notes_isSet = false;
    m_service_provider_notes_isValid = false;

    m_service_provider_provisioning_state_isSet = false;
    m_service_provider_provisioning_state_isValid = false;
}

void OAIExpressRouteCrossConnectionProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIExpressRouteCrossConnectionProperties::fromJsonObject(QJsonObject json) {

    m_bandwidth_in_mbps_isValid = ::OpenAPI::fromJsonValue(m_bandwidth_in_mbps, json[QString("bandwidthInMbps")]);
    m_bandwidth_in_mbps_isSet = !json[QString("bandwidthInMbps")].isNull() && m_bandwidth_in_mbps_isValid;

    m_express_route_circuit_isValid = ::OpenAPI::fromJsonValue(m_express_route_circuit, json[QString("expressRouteCircuit")]);
    m_express_route_circuit_isSet = !json[QString("expressRouteCircuit")].isNull() && m_express_route_circuit_isValid;

    m_peering_location_isValid = ::OpenAPI::fromJsonValue(m_peering_location, json[QString("peeringLocation")]);
    m_peering_location_isSet = !json[QString("peeringLocation")].isNull() && m_peering_location_isValid;

    m_peerings_isValid = ::OpenAPI::fromJsonValue(m_peerings, json[QString("peerings")]);
    m_peerings_isSet = !json[QString("peerings")].isNull() && m_peerings_isValid;

    m_primary_azure_port_isValid = ::OpenAPI::fromJsonValue(m_primary_azure_port, json[QString("primaryAzurePort")]);
    m_primary_azure_port_isSet = !json[QString("primaryAzurePort")].isNull() && m_primary_azure_port_isValid;

    m_provisioning_state_isValid = ::OpenAPI::fromJsonValue(m_provisioning_state, json[QString("provisioningState")]);
    m_provisioning_state_isSet = !json[QString("provisioningState")].isNull() && m_provisioning_state_isValid;

    m_s_tag_isValid = ::OpenAPI::fromJsonValue(m_s_tag, json[QString("sTag")]);
    m_s_tag_isSet = !json[QString("sTag")].isNull() && m_s_tag_isValid;

    m_secondary_azure_port_isValid = ::OpenAPI::fromJsonValue(m_secondary_azure_port, json[QString("secondaryAzurePort")]);
    m_secondary_azure_port_isSet = !json[QString("secondaryAzurePort")].isNull() && m_secondary_azure_port_isValid;

    m_service_provider_notes_isValid = ::OpenAPI::fromJsonValue(m_service_provider_notes, json[QString("serviceProviderNotes")]);
    m_service_provider_notes_isSet = !json[QString("serviceProviderNotes")].isNull() && m_service_provider_notes_isValid;

    m_service_provider_provisioning_state_isValid = ::OpenAPI::fromJsonValue(m_service_provider_provisioning_state, json[QString("serviceProviderProvisioningState")]);
    m_service_provider_provisioning_state_isSet = !json[QString("serviceProviderProvisioningState")].isNull() && m_service_provider_provisioning_state_isValid;
}

QString OAIExpressRouteCrossConnectionProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIExpressRouteCrossConnectionProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_bandwidth_in_mbps_isSet) {
        obj.insert(QString("bandwidthInMbps"), ::OpenAPI::toJsonValue(m_bandwidth_in_mbps));
    }
    if (m_express_route_circuit.isSet()) {
        obj.insert(QString("expressRouteCircuit"), ::OpenAPI::toJsonValue(m_express_route_circuit));
    }
    if (m_peering_location_isSet) {
        obj.insert(QString("peeringLocation"), ::OpenAPI::toJsonValue(m_peering_location));
    }
    if (m_peerings.size() > 0) {
        obj.insert(QString("peerings"), ::OpenAPI::toJsonValue(m_peerings));
    }
    if (m_primary_azure_port_isSet) {
        obj.insert(QString("primaryAzurePort"), ::OpenAPI::toJsonValue(m_primary_azure_port));
    }
    if (m_provisioning_state_isSet) {
        obj.insert(QString("provisioningState"), ::OpenAPI::toJsonValue(m_provisioning_state));
    }
    if (m_s_tag_isSet) {
        obj.insert(QString("sTag"), ::OpenAPI::toJsonValue(m_s_tag));
    }
    if (m_secondary_azure_port_isSet) {
        obj.insert(QString("secondaryAzurePort"), ::OpenAPI::toJsonValue(m_secondary_azure_port));
    }
    if (m_service_provider_notes_isSet) {
        obj.insert(QString("serviceProviderNotes"), ::OpenAPI::toJsonValue(m_service_provider_notes));
    }
    if (m_service_provider_provisioning_state_isSet) {
        obj.insert(QString("serviceProviderProvisioningState"), ::OpenAPI::toJsonValue(m_service_provider_provisioning_state));
    }
    return obj;
}

qint32 OAIExpressRouteCrossConnectionProperties::getBandwidthInMbps() const {
    return m_bandwidth_in_mbps;
}
void OAIExpressRouteCrossConnectionProperties::setBandwidthInMbps(const qint32 &bandwidth_in_mbps) {
    m_bandwidth_in_mbps = bandwidth_in_mbps;
    m_bandwidth_in_mbps_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_bandwidth_in_mbps_Set() const{
    return m_bandwidth_in_mbps_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_bandwidth_in_mbps_Valid() const{
    return m_bandwidth_in_mbps_isValid;
}

OAIExpressRouteCircuitReference OAIExpressRouteCrossConnectionProperties::getExpressRouteCircuit() const {
    return m_express_route_circuit;
}
void OAIExpressRouteCrossConnectionProperties::setExpressRouteCircuit(const OAIExpressRouteCircuitReference &express_route_circuit) {
    m_express_route_circuit = express_route_circuit;
    m_express_route_circuit_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_express_route_circuit_Set() const{
    return m_express_route_circuit_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_express_route_circuit_Valid() const{
    return m_express_route_circuit_isValid;
}

QString OAIExpressRouteCrossConnectionProperties::getPeeringLocation() const {
    return m_peering_location;
}
void OAIExpressRouteCrossConnectionProperties::setPeeringLocation(const QString &peering_location) {
    m_peering_location = peering_location;
    m_peering_location_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_peering_location_Set() const{
    return m_peering_location_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_peering_location_Valid() const{
    return m_peering_location_isValid;
}

QList<OAIExpressRouteCrossConnectionPeering> OAIExpressRouteCrossConnectionProperties::getPeerings() const {
    return m_peerings;
}
void OAIExpressRouteCrossConnectionProperties::setPeerings(const QList<OAIExpressRouteCrossConnectionPeering> &peerings) {
    m_peerings = peerings;
    m_peerings_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_peerings_Set() const{
    return m_peerings_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_peerings_Valid() const{
    return m_peerings_isValid;
}

QString OAIExpressRouteCrossConnectionProperties::getPrimaryAzurePort() const {
    return m_primary_azure_port;
}
void OAIExpressRouteCrossConnectionProperties::setPrimaryAzurePort(const QString &primary_azure_port) {
    m_primary_azure_port = primary_azure_port;
    m_primary_azure_port_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_primary_azure_port_Set() const{
    return m_primary_azure_port_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_primary_azure_port_Valid() const{
    return m_primary_azure_port_isValid;
}

QString OAIExpressRouteCrossConnectionProperties::getProvisioningState() const {
    return m_provisioning_state;
}
void OAIExpressRouteCrossConnectionProperties::setProvisioningState(const QString &provisioning_state) {
    m_provisioning_state = provisioning_state;
    m_provisioning_state_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_provisioning_state_Set() const{
    return m_provisioning_state_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_provisioning_state_Valid() const{
    return m_provisioning_state_isValid;
}

qint32 OAIExpressRouteCrossConnectionProperties::getSTag() const {
    return m_s_tag;
}
void OAIExpressRouteCrossConnectionProperties::setSTag(const qint32 &s_tag) {
    m_s_tag = s_tag;
    m_s_tag_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_s_tag_Set() const{
    return m_s_tag_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_s_tag_Valid() const{
    return m_s_tag_isValid;
}

QString OAIExpressRouteCrossConnectionProperties::getSecondaryAzurePort() const {
    return m_secondary_azure_port;
}
void OAIExpressRouteCrossConnectionProperties::setSecondaryAzurePort(const QString &secondary_azure_port) {
    m_secondary_azure_port = secondary_azure_port;
    m_secondary_azure_port_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_secondary_azure_port_Set() const{
    return m_secondary_azure_port_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_secondary_azure_port_Valid() const{
    return m_secondary_azure_port_isValid;
}

QString OAIExpressRouteCrossConnectionProperties::getServiceProviderNotes() const {
    return m_service_provider_notes;
}
void OAIExpressRouteCrossConnectionProperties::setServiceProviderNotes(const QString &service_provider_notes) {
    m_service_provider_notes = service_provider_notes;
    m_service_provider_notes_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_service_provider_notes_Set() const{
    return m_service_provider_notes_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_service_provider_notes_Valid() const{
    return m_service_provider_notes_isValid;
}

QString OAIExpressRouteCrossConnectionProperties::getServiceProviderProvisioningState() const {
    return m_service_provider_provisioning_state;
}
void OAIExpressRouteCrossConnectionProperties::setServiceProviderProvisioningState(const QString &service_provider_provisioning_state) {
    m_service_provider_provisioning_state = service_provider_provisioning_state;
    m_service_provider_provisioning_state_isSet = true;
}

bool OAIExpressRouteCrossConnectionProperties::is_service_provider_provisioning_state_Set() const{
    return m_service_provider_provisioning_state_isSet;
}

bool OAIExpressRouteCrossConnectionProperties::is_service_provider_provisioning_state_Valid() const{
    return m_service_provider_provisioning_state_isValid;
}

bool OAIExpressRouteCrossConnectionProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_bandwidth_in_mbps_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_express_route_circuit.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_peering_location_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_peerings.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_primary_azure_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_provisioning_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_s_tag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_secondary_azure_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_provider_notes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_provider_provisioning_state_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIExpressRouteCrossConnectionProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
