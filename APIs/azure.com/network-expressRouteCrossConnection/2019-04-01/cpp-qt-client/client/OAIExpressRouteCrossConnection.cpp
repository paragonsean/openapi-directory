/**
 * ExpressRouteCrossConnection REST APIs
 * The Microsoft Azure ExpressRouteCrossConnection Resource Provider REST APIs describes the operations for the connectivity provider to provision ExpressRoute circuit, create and modify BGP peering entities and troubleshoot connectivity on customer's ExpressRoute circuit.
 *
 * The version of the OpenAPI document: 2019-04-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIExpressRouteCrossConnection.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIExpressRouteCrossConnection::OAIExpressRouteCrossConnection(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIExpressRouteCrossConnection::OAIExpressRouteCrossConnection() {
    this->initializeModel();
}

OAIExpressRouteCrossConnection::~OAIExpressRouteCrossConnection() {}

void OAIExpressRouteCrossConnection::initializeModel() {

    m_etag_isSet = false;
    m_etag_isValid = false;

    m_properties_isSet = false;
    m_properties_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_location_isSet = false;
    m_location_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIExpressRouteCrossConnection::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIExpressRouteCrossConnection::fromJsonObject(QJsonObject json) {

    m_etag_isValid = ::OpenAPI::fromJsonValue(m_etag, json[QString("etag")]);
    m_etag_isSet = !json[QString("etag")].isNull() && m_etag_isValid;

    m_properties_isValid = ::OpenAPI::fromJsonValue(m_properties, json[QString("properties")]);
    m_properties_isSet = !json[QString("properties")].isNull() && m_properties_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_location_isValid = ::OpenAPI::fromJsonValue(m_location, json[QString("location")]);
    m_location_isSet = !json[QString("location")].isNull() && m_location_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIExpressRouteCrossConnection::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIExpressRouteCrossConnection::asJsonObject() const {
    QJsonObject obj;
    if (m_etag_isSet) {
        obj.insert(QString("etag"), ::OpenAPI::toJsonValue(m_etag));
    }
    if (m_properties.isSet()) {
        obj.insert(QString("properties"), ::OpenAPI::toJsonValue(m_properties));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_location_isSet) {
        obj.insert(QString("location"), ::OpenAPI::toJsonValue(m_location));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_tags.size() > 0) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QString OAIExpressRouteCrossConnection::getEtag() const {
    return m_etag;
}
void OAIExpressRouteCrossConnection::setEtag(const QString &etag) {
    m_etag = etag;
    m_etag_isSet = true;
}

bool OAIExpressRouteCrossConnection::is_etag_Set() const{
    return m_etag_isSet;
}

bool OAIExpressRouteCrossConnection::is_etag_Valid() const{
    return m_etag_isValid;
}

OAIExpressRouteCrossConnectionProperties OAIExpressRouteCrossConnection::getProperties() const {
    return m_properties;
}
void OAIExpressRouteCrossConnection::setProperties(const OAIExpressRouteCrossConnectionProperties &properties) {
    m_properties = properties;
    m_properties_isSet = true;
}

bool OAIExpressRouteCrossConnection::is_properties_Set() const{
    return m_properties_isSet;
}

bool OAIExpressRouteCrossConnection::is_properties_Valid() const{
    return m_properties_isValid;
}

QString OAIExpressRouteCrossConnection::getId() const {
    return m_id;
}
void OAIExpressRouteCrossConnection::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIExpressRouteCrossConnection::is_id_Set() const{
    return m_id_isSet;
}

bool OAIExpressRouteCrossConnection::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIExpressRouteCrossConnection::getLocation() const {
    return m_location;
}
void OAIExpressRouteCrossConnection::setLocation(const QString &location) {
    m_location = location;
    m_location_isSet = true;
}

bool OAIExpressRouteCrossConnection::is_location_Set() const{
    return m_location_isSet;
}

bool OAIExpressRouteCrossConnection::is_location_Valid() const{
    return m_location_isValid;
}

QString OAIExpressRouteCrossConnection::getName() const {
    return m_name;
}
void OAIExpressRouteCrossConnection::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIExpressRouteCrossConnection::is_name_Set() const{
    return m_name_isSet;
}

bool OAIExpressRouteCrossConnection::is_name_Valid() const{
    return m_name_isValid;
}

QMap<QString, QString> OAIExpressRouteCrossConnection::getTags() const {
    return m_tags;
}
void OAIExpressRouteCrossConnection::setTags(const QMap<QString, QString> &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAIExpressRouteCrossConnection::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAIExpressRouteCrossConnection::is_tags_Valid() const{
    return m_tags_isValid;
}

QString OAIExpressRouteCrossConnection::getType() const {
    return m_type;
}
void OAIExpressRouteCrossConnection::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIExpressRouteCrossConnection::is_type_Set() const{
    return m_type_isSet;
}

bool OAIExpressRouteCrossConnection::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIExpressRouteCrossConnection::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_etag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_properties.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_location_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIExpressRouteCrossConnection::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
