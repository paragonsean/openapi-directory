/**
 * PostgreSQLManagementClient
 * The Microsoft Azure management API provides create, read, update, and delete functionality for Azure PostgreSQL resources including servers, databases, firewall rules, VNET rules, security alert policies, log files and configurations with new business model.
 *
 * The version of the OpenAPI document: 2017-12-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIServerPropertiesForRestore.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIServerPropertiesForRestore::OAIServerPropertiesForRestore(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIServerPropertiesForRestore::OAIServerPropertiesForRestore() {
    this->initializeModel();
}

OAIServerPropertiesForRestore::~OAIServerPropertiesForRestore() {}

void OAIServerPropertiesForRestore::initializeModel() {

    m_restore_point_in_time_isSet = false;
    m_restore_point_in_time_isValid = false;

    m_source_server_id_isSet = false;
    m_source_server_id_isValid = false;

    m_create_mode_isSet = false;
    m_create_mode_isValid = false;

    m_ssl_enforcement_isSet = false;
    m_ssl_enforcement_isValid = false;

    m_storage_profile_isSet = false;
    m_storage_profile_isValid = false;

    m_version_isSet = false;
    m_version_isValid = false;
}

void OAIServerPropertiesForRestore::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIServerPropertiesForRestore::fromJsonObject(QJsonObject json) {

    m_restore_point_in_time_isValid = ::OpenAPI::fromJsonValue(m_restore_point_in_time, json[QString("restorePointInTime")]);
    m_restore_point_in_time_isSet = !json[QString("restorePointInTime")].isNull() && m_restore_point_in_time_isValid;

    m_source_server_id_isValid = ::OpenAPI::fromJsonValue(m_source_server_id, json[QString("sourceServerId")]);
    m_source_server_id_isSet = !json[QString("sourceServerId")].isNull() && m_source_server_id_isValid;

    m_create_mode_isValid = ::OpenAPI::fromJsonValue(m_create_mode, json[QString("createMode")]);
    m_create_mode_isSet = !json[QString("createMode")].isNull() && m_create_mode_isValid;

    m_ssl_enforcement_isValid = ::OpenAPI::fromJsonValue(m_ssl_enforcement, json[QString("sslEnforcement")]);
    m_ssl_enforcement_isSet = !json[QString("sslEnforcement")].isNull() && m_ssl_enforcement_isValid;

    m_storage_profile_isValid = ::OpenAPI::fromJsonValue(m_storage_profile, json[QString("storageProfile")]);
    m_storage_profile_isSet = !json[QString("storageProfile")].isNull() && m_storage_profile_isValid;

    m_version_isValid = ::OpenAPI::fromJsonValue(m_version, json[QString("version")]);
    m_version_isSet = !json[QString("version")].isNull() && m_version_isValid;
}

QString OAIServerPropertiesForRestore::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIServerPropertiesForRestore::asJsonObject() const {
    QJsonObject obj;
    if (m_restore_point_in_time_isSet) {
        obj.insert(QString("restorePointInTime"), ::OpenAPI::toJsonValue(m_restore_point_in_time));
    }
    if (m_source_server_id_isSet) {
        obj.insert(QString("sourceServerId"), ::OpenAPI::toJsonValue(m_source_server_id));
    }
    if (m_create_mode_isSet) {
        obj.insert(QString("createMode"), ::OpenAPI::toJsonValue(m_create_mode));
    }
    if (m_ssl_enforcement.isSet()) {
        obj.insert(QString("sslEnforcement"), ::OpenAPI::toJsonValue(m_ssl_enforcement));
    }
    if (m_storage_profile.isSet()) {
        obj.insert(QString("storageProfile"), ::OpenAPI::toJsonValue(m_storage_profile));
    }
    if (m_version.isSet()) {
        obj.insert(QString("version"), ::OpenAPI::toJsonValue(m_version));
    }
    return obj;
}

QDateTime OAIServerPropertiesForRestore::getRestorePointInTime() const {
    return m_restore_point_in_time;
}
void OAIServerPropertiesForRestore::setRestorePointInTime(const QDateTime &restore_point_in_time) {
    m_restore_point_in_time = restore_point_in_time;
    m_restore_point_in_time_isSet = true;
}

bool OAIServerPropertiesForRestore::is_restore_point_in_time_Set() const{
    return m_restore_point_in_time_isSet;
}

bool OAIServerPropertiesForRestore::is_restore_point_in_time_Valid() const{
    return m_restore_point_in_time_isValid;
}

QString OAIServerPropertiesForRestore::getSourceServerId() const {
    return m_source_server_id;
}
void OAIServerPropertiesForRestore::setSourceServerId(const QString &source_server_id) {
    m_source_server_id = source_server_id;
    m_source_server_id_isSet = true;
}

bool OAIServerPropertiesForRestore::is_source_server_id_Set() const{
    return m_source_server_id_isSet;
}

bool OAIServerPropertiesForRestore::is_source_server_id_Valid() const{
    return m_source_server_id_isValid;
}

QString OAIServerPropertiesForRestore::getCreateMode() const {
    return m_create_mode;
}
void OAIServerPropertiesForRestore::setCreateMode(const QString &create_mode) {
    m_create_mode = create_mode;
    m_create_mode_isSet = true;
}

bool OAIServerPropertiesForRestore::is_create_mode_Set() const{
    return m_create_mode_isSet;
}

bool OAIServerPropertiesForRestore::is_create_mode_Valid() const{
    return m_create_mode_isValid;
}

OAISslEnforcement OAIServerPropertiesForRestore::getSslEnforcement() const {
    return m_ssl_enforcement;
}
void OAIServerPropertiesForRestore::setSslEnforcement(const OAISslEnforcement &ssl_enforcement) {
    m_ssl_enforcement = ssl_enforcement;
    m_ssl_enforcement_isSet = true;
}

bool OAIServerPropertiesForRestore::is_ssl_enforcement_Set() const{
    return m_ssl_enforcement_isSet;
}

bool OAIServerPropertiesForRestore::is_ssl_enforcement_Valid() const{
    return m_ssl_enforcement_isValid;
}

OAIStorageProfile OAIServerPropertiesForRestore::getStorageProfile() const {
    return m_storage_profile;
}
void OAIServerPropertiesForRestore::setStorageProfile(const OAIStorageProfile &storage_profile) {
    m_storage_profile = storage_profile;
    m_storage_profile_isSet = true;
}

bool OAIServerPropertiesForRestore::is_storage_profile_Set() const{
    return m_storage_profile_isSet;
}

bool OAIServerPropertiesForRestore::is_storage_profile_Valid() const{
    return m_storage_profile_isValid;
}

OAIServerVersion OAIServerPropertiesForRestore::getVersion() const {
    return m_version;
}
void OAIServerPropertiesForRestore::setVersion(const OAIServerVersion &version) {
    m_version = version;
    m_version_isSet = true;
}

bool OAIServerPropertiesForRestore::is_version_Set() const{
    return m_version_isSet;
}

bool OAIServerPropertiesForRestore::is_version_Valid() const{
    return m_version_isValid;
}

bool OAIServerPropertiesForRestore::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_restore_point_in_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_source_server_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_create_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ssl_enforcement.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_storage_profile.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_version.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIServerPropertiesForRestore::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_restore_point_in_time_isValid && m_source_server_id_isValid && m_create_mode_isValid && true;
}

} // namespace OpenAPI
