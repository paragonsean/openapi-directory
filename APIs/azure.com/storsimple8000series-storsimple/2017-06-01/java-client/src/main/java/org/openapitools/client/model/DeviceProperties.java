/*
 * StorSimple8000SeriesManagementClient
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2017-06-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.DeviceDetails;
import org.openapitools.client.model.DeviceRolloverDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The properties of the StorSimple device.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:41:41.316643-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DeviceProperties {
  public static final String SERIALIZED_NAME_ACTIVATION_TIME = "activationTime";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_TIME)
  private OffsetDateTime activationTime;

  /**
   * The identifier of the active controller of the device.
   */
  @JsonAdapter(ActiveControllerEnum.Adapter.class)
  public enum ActiveControllerEnum {
    UNKNOWN("Unknown"),
    
    NONE("None"),
    
    CONTROLLER0("Controller0"),
    
    CONTROLLER1("Controller1");

    private String value;

    ActiveControllerEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ActiveControllerEnum fromValue(String value) {
      for (ActiveControllerEnum b : ActiveControllerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ActiveControllerEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ActiveControllerEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ActiveControllerEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ActiveControllerEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ActiveControllerEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACTIVE_CONTROLLER = "activeController";
  @SerializedName(SERIALIZED_NAME_ACTIVE_CONTROLLER)
  private ActiveControllerEnum activeController;

  public static final String SERIALIZED_NAME_AGENT_GROUP_VERSION = "agentGroupVersion";
  @SerializedName(SERIALIZED_NAME_AGENT_GROUP_VERSION)
  private Integer agentGroupVersion;

  public static final String SERIALIZED_NAME_AVAILABLE_LOCAL_STORAGE_IN_BYTES = "availableLocalStorageInBytes";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_LOCAL_STORAGE_IN_BYTES)
  private Long availableLocalStorageInBytes;

  public static final String SERIALIZED_NAME_AVAILABLE_TIERED_STORAGE_IN_BYTES = "availableTieredStorageInBytes";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_TIERED_STORAGE_IN_BYTES)
  private Long availableTieredStorageInBytes;

  public static final String SERIALIZED_NAME_CULTURE = "culture";
  @SerializedName(SERIALIZED_NAME_CULTURE)
  private String culture;

  public static final String SERIALIZED_NAME_DETAILS = "details";
  @SerializedName(SERIALIZED_NAME_DETAILS)
  private DeviceDetails details;

  /**
   * The current configuration status of the device.
   */
  @JsonAdapter(DeviceConfigurationStatusEnum.Adapter.class)
  public enum DeviceConfigurationStatusEnum {
    COMPLETE("Complete"),
    
    PENDING("Pending");

    private String value;

    DeviceConfigurationStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeviceConfigurationStatusEnum fromValue(String value) {
      for (DeviceConfigurationStatusEnum b : DeviceConfigurationStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DeviceConfigurationStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeviceConfigurationStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeviceConfigurationStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DeviceConfigurationStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DeviceConfigurationStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEVICE_CONFIGURATION_STATUS = "deviceConfigurationStatus";
  @SerializedName(SERIALIZED_NAME_DEVICE_CONFIGURATION_STATUS)
  private DeviceConfigurationStatusEnum deviceConfigurationStatus;

  public static final String SERIALIZED_NAME_DEVICE_DESCRIPTION = "deviceDescription";
  @SerializedName(SERIALIZED_NAME_DEVICE_DESCRIPTION)
  private String deviceDescription;

  public static final String SERIALIZED_NAME_DEVICE_LOCATION = "deviceLocation";
  @SerializedName(SERIALIZED_NAME_DEVICE_LOCATION)
  private String deviceLocation;

  public static final String SERIALIZED_NAME_DEVICE_SOFTWARE_VERSION = "deviceSoftwareVersion";
  @SerializedName(SERIALIZED_NAME_DEVICE_SOFTWARE_VERSION)
  private String deviceSoftwareVersion;

  /**
   * The type of the device.
   */
  @JsonAdapter(DeviceTypeEnum.Adapter.class)
  public enum DeviceTypeEnum {
    INVALID("Invalid"),
    
    SERIES8000_VIRTUAL_APPLIANCE("Series8000VirtualAppliance"),
    
    SERIES8000_PHYSICAL_APPLIANCE("Series8000PhysicalAppliance");

    private String value;

    DeviceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeviceTypeEnum fromValue(String value) {
      for (DeviceTypeEnum b : DeviceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DeviceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeviceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeviceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DeviceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DeviceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEVICE_TYPE = "deviceType";
  @SerializedName(SERIALIZED_NAME_DEVICE_TYPE)
  private DeviceTypeEnum deviceType;

  public static final String SERIALIZED_NAME_FRIENDLY_NAME = "friendlyName";
  @SerializedName(SERIALIZED_NAME_FRIENDLY_NAME)
  private String friendlyName;

  public static final String SERIALIZED_NAME_FRIENDLY_SOFTWARE_NAME = "friendlySoftwareName";
  @SerializedName(SERIALIZED_NAME_FRIENDLY_SOFTWARE_NAME)
  private String friendlySoftwareName;

  public static final String SERIALIZED_NAME_FRIENDLY_SOFTWARE_VERSION = "friendlySoftwareVersion";
  @SerializedName(SERIALIZED_NAME_FRIENDLY_SOFTWARE_VERSION)
  private String friendlySoftwareVersion;

  public static final String SERIALIZED_NAME_MODEL_DESCRIPTION = "modelDescription";
  @SerializedName(SERIALIZED_NAME_MODEL_DESCRIPTION)
  private String modelDescription;

  public static final String SERIALIZED_NAME_NETWORK_INTERFACE_CARD_COUNT = "networkInterfaceCardCount";
  @SerializedName(SERIALIZED_NAME_NETWORK_INTERFACE_CARD_COUNT)
  private Integer networkInterfaceCardCount;

  public static final String SERIALIZED_NAME_PROVISIONED_LOCAL_STORAGE_IN_BYTES = "provisionedLocalStorageInBytes";
  @SerializedName(SERIALIZED_NAME_PROVISIONED_LOCAL_STORAGE_IN_BYTES)
  private Long provisionedLocalStorageInBytes;

  public static final String SERIALIZED_NAME_PROVISIONED_TIERED_STORAGE_IN_BYTES = "provisionedTieredStorageInBytes";
  @SerializedName(SERIALIZED_NAME_PROVISIONED_TIERED_STORAGE_IN_BYTES)
  private Long provisionedTieredStorageInBytes;

  public static final String SERIALIZED_NAME_PROVISIONED_VOLUME_SIZE_IN_BYTES = "provisionedVolumeSizeInBytes";
  @SerializedName(SERIALIZED_NAME_PROVISIONED_VOLUME_SIZE_IN_BYTES)
  private Long provisionedVolumeSizeInBytes;

  public static final String SERIALIZED_NAME_ROLLOVER_DETAILS = "rolloverDetails";
  @SerializedName(SERIALIZED_NAME_ROLLOVER_DETAILS)
  private DeviceRolloverDetails rolloverDetails;

  public static final String SERIALIZED_NAME_SERIAL_NUMBER = "serialNumber";
  @SerializedName(SERIALIZED_NAME_SERIAL_NUMBER)
  private String serialNumber;

  /**
   * The current status of the device.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    UNKNOWN("Unknown"),
    
    ONLINE("Online"),
    
    OFFLINE("Offline"),
    
    DEACTIVATED("Deactivated"),
    
    REQUIRES_ATTENTION("RequiresAttention"),
    
    MAINTENANCE_MODE("MaintenanceMode"),
    
    CREATING("Creating"),
    
    PROVISIONING("Provisioning"),
    
    DEACTIVATING("Deactivating"),
    
    DELETED("Deleted"),
    
    READY_TO_SETUP("ReadyToSetup");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_TARGET_IQN = "targetIqn";
  @SerializedName(SERIALIZED_NAME_TARGET_IQN)
  private String targetIqn;

  public static final String SERIALIZED_NAME_TOTAL_TIERED_STORAGE_IN_BYTES = "totalTieredStorageInBytes";
  @SerializedName(SERIALIZED_NAME_TOTAL_TIERED_STORAGE_IN_BYTES)
  private Long totalTieredStorageInBytes;

  public static final String SERIALIZED_NAME_USING_STORAGE_IN_BYTES = "usingStorageInBytes";
  @SerializedName(SERIALIZED_NAME_USING_STORAGE_IN_BYTES)
  private Long usingStorageInBytes;

  /**
   * The virtual machine API type.
   */
  @JsonAdapter(VirtualMachineApiTypeEnum.Adapter.class)
  public enum VirtualMachineApiTypeEnum {
    CLASSIC("Classic"),
    
    ARM("Arm");

    private String value;

    VirtualMachineApiTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VirtualMachineApiTypeEnum fromValue(String value) {
      for (VirtualMachineApiTypeEnum b : VirtualMachineApiTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<VirtualMachineApiTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VirtualMachineApiTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VirtualMachineApiTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return VirtualMachineApiTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      VirtualMachineApiTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VIRTUAL_MACHINE_API_TYPE = "virtualMachineApiType";
  @SerializedName(SERIALIZED_NAME_VIRTUAL_MACHINE_API_TYPE)
  private VirtualMachineApiTypeEnum virtualMachineApiType;

  public DeviceProperties() {
  }

  public DeviceProperties(
     VirtualMachineApiTypeEnum virtualMachineApiType
  ) {
    this();
    this.virtualMachineApiType = virtualMachineApiType;
  }

  public DeviceProperties activationTime(OffsetDateTime activationTime) {
    this.activationTime = activationTime;
    return this;
  }

  /**
   * The UTC time at which the device was activated
   * @return activationTime
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getActivationTime() {
    return activationTime;
  }

  public void setActivationTime(OffsetDateTime activationTime) {
    this.activationTime = activationTime;
  }


  public DeviceProperties activeController(ActiveControllerEnum activeController) {
    this.activeController = activeController;
    return this;
  }

  /**
   * The identifier of the active controller of the device.
   * @return activeController
   */
  @javax.annotation.Nonnull
  public ActiveControllerEnum getActiveController() {
    return activeController;
  }

  public void setActiveController(ActiveControllerEnum activeController) {
    this.activeController = activeController;
  }


  public DeviceProperties agentGroupVersion(Integer agentGroupVersion) {
    this.agentGroupVersion = agentGroupVersion;
    return this;
  }

  /**
   * The device agent group version.
   * @return agentGroupVersion
   */
  @javax.annotation.Nullable
  public Integer getAgentGroupVersion() {
    return agentGroupVersion;
  }

  public void setAgentGroupVersion(Integer agentGroupVersion) {
    this.agentGroupVersion = agentGroupVersion;
  }


  public DeviceProperties availableLocalStorageInBytes(Long availableLocalStorageInBytes) {
    this.availableLocalStorageInBytes = availableLocalStorageInBytes;
    return this;
  }

  /**
   * The storage in bytes that is available locally on the device.
   * @return availableLocalStorageInBytes
   */
  @javax.annotation.Nullable
  public Long getAvailableLocalStorageInBytes() {
    return availableLocalStorageInBytes;
  }

  public void setAvailableLocalStorageInBytes(Long availableLocalStorageInBytes) {
    this.availableLocalStorageInBytes = availableLocalStorageInBytes;
  }


  public DeviceProperties availableTieredStorageInBytes(Long availableTieredStorageInBytes) {
    this.availableTieredStorageInBytes = availableTieredStorageInBytes;
    return this;
  }

  /**
   * The storage in bytes that is available on the device for tiered volumes.
   * @return availableTieredStorageInBytes
   */
  @javax.annotation.Nullable
  public Long getAvailableTieredStorageInBytes() {
    return availableTieredStorageInBytes;
  }

  public void setAvailableTieredStorageInBytes(Long availableTieredStorageInBytes) {
    this.availableTieredStorageInBytes = availableTieredStorageInBytes;
  }


  public DeviceProperties culture(String culture) {
    this.culture = culture;
    return this;
  }

  /**
   * The language culture setting on the device. For eg: \&quot;en-US\&quot;
   * @return culture
   */
  @javax.annotation.Nonnull
  public String getCulture() {
    return culture;
  }

  public void setCulture(String culture) {
    this.culture = culture;
  }


  public DeviceProperties details(DeviceDetails details) {
    this.details = details;
    return this;
  }

  /**
   * Get details
   * @return details
   */
  @javax.annotation.Nullable
  public DeviceDetails getDetails() {
    return details;
  }

  public void setDetails(DeviceDetails details) {
    this.details = details;
  }


  public DeviceProperties deviceConfigurationStatus(DeviceConfigurationStatusEnum deviceConfigurationStatus) {
    this.deviceConfigurationStatus = deviceConfigurationStatus;
    return this;
  }

  /**
   * The current configuration status of the device.
   * @return deviceConfigurationStatus
   */
  @javax.annotation.Nonnull
  public DeviceConfigurationStatusEnum getDeviceConfigurationStatus() {
    return deviceConfigurationStatus;
  }

  public void setDeviceConfigurationStatus(DeviceConfigurationStatusEnum deviceConfigurationStatus) {
    this.deviceConfigurationStatus = deviceConfigurationStatus;
  }


  public DeviceProperties deviceDescription(String deviceDescription) {
    this.deviceDescription = deviceDescription;
    return this;
  }

  /**
   * The device description.
   * @return deviceDescription
   */
  @javax.annotation.Nonnull
  public String getDeviceDescription() {
    return deviceDescription;
  }

  public void setDeviceDescription(String deviceDescription) {
    this.deviceDescription = deviceDescription;
  }


  public DeviceProperties deviceLocation(String deviceLocation) {
    this.deviceLocation = deviceLocation;
    return this;
  }

  /**
   * The location of the virtual appliance.
   * @return deviceLocation
   */
  @javax.annotation.Nullable
  public String getDeviceLocation() {
    return deviceLocation;
  }

  public void setDeviceLocation(String deviceLocation) {
    this.deviceLocation = deviceLocation;
  }


  public DeviceProperties deviceSoftwareVersion(String deviceSoftwareVersion) {
    this.deviceSoftwareVersion = deviceSoftwareVersion;
    return this;
  }

  /**
   * The version number of the software running on the device.
   * @return deviceSoftwareVersion
   */
  @javax.annotation.Nonnull
  public String getDeviceSoftwareVersion() {
    return deviceSoftwareVersion;
  }

  public void setDeviceSoftwareVersion(String deviceSoftwareVersion) {
    this.deviceSoftwareVersion = deviceSoftwareVersion;
  }


  public DeviceProperties deviceType(DeviceTypeEnum deviceType) {
    this.deviceType = deviceType;
    return this;
  }

  /**
   * The type of the device.
   * @return deviceType
   */
  @javax.annotation.Nonnull
  public DeviceTypeEnum getDeviceType() {
    return deviceType;
  }

  public void setDeviceType(DeviceTypeEnum deviceType) {
    this.deviceType = deviceType;
  }


  public DeviceProperties friendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
    return this;
  }

  /**
   * The friendly name of the device.
   * @return friendlyName
   */
  @javax.annotation.Nonnull
  public String getFriendlyName() {
    return friendlyName;
  }

  public void setFriendlyName(String friendlyName) {
    this.friendlyName = friendlyName;
  }


  public DeviceProperties friendlySoftwareName(String friendlySoftwareName) {
    this.friendlySoftwareName = friendlySoftwareName;
    return this;
  }

  /**
   * The friendly name of the software running on the device.
   * @return friendlySoftwareName
   */
  @javax.annotation.Nullable
  public String getFriendlySoftwareName() {
    return friendlySoftwareName;
  }

  public void setFriendlySoftwareName(String friendlySoftwareName) {
    this.friendlySoftwareName = friendlySoftwareName;
  }


  public DeviceProperties friendlySoftwareVersion(String friendlySoftwareVersion) {
    this.friendlySoftwareVersion = friendlySoftwareVersion;
    return this;
  }

  /**
   * The device friendly software version.
   * @return friendlySoftwareVersion
   */
  @javax.annotation.Nonnull
  public String getFriendlySoftwareVersion() {
    return friendlySoftwareVersion;
  }

  public void setFriendlySoftwareVersion(String friendlySoftwareVersion) {
    this.friendlySoftwareVersion = friendlySoftwareVersion;
  }


  public DeviceProperties modelDescription(String modelDescription) {
    this.modelDescription = modelDescription;
    return this;
  }

  /**
   * The device model.
   * @return modelDescription
   */
  @javax.annotation.Nonnull
  public String getModelDescription() {
    return modelDescription;
  }

  public void setModelDescription(String modelDescription) {
    this.modelDescription = modelDescription;
  }


  public DeviceProperties networkInterfaceCardCount(Integer networkInterfaceCardCount) {
    this.networkInterfaceCardCount = networkInterfaceCardCount;
    return this;
  }

  /**
   * The number of network interface cards
   * @return networkInterfaceCardCount
   */
  @javax.annotation.Nullable
  public Integer getNetworkInterfaceCardCount() {
    return networkInterfaceCardCount;
  }

  public void setNetworkInterfaceCardCount(Integer networkInterfaceCardCount) {
    this.networkInterfaceCardCount = networkInterfaceCardCount;
  }


  public DeviceProperties provisionedLocalStorageInBytes(Long provisionedLocalStorageInBytes) {
    this.provisionedLocalStorageInBytes = provisionedLocalStorageInBytes;
    return this;
  }

  /**
   * The storage in bytes used for locally pinned volumes on the device (including additional local reservation).
   * @return provisionedLocalStorageInBytes
   */
  @javax.annotation.Nullable
  public Long getProvisionedLocalStorageInBytes() {
    return provisionedLocalStorageInBytes;
  }

  public void setProvisionedLocalStorageInBytes(Long provisionedLocalStorageInBytes) {
    this.provisionedLocalStorageInBytes = provisionedLocalStorageInBytes;
  }


  public DeviceProperties provisionedTieredStorageInBytes(Long provisionedTieredStorageInBytes) {
    this.provisionedTieredStorageInBytes = provisionedTieredStorageInBytes;
    return this;
  }

  /**
   * The storage in bytes that has been provisioned on the device for tiered volumes.
   * @return provisionedTieredStorageInBytes
   */
  @javax.annotation.Nullable
  public Long getProvisionedTieredStorageInBytes() {
    return provisionedTieredStorageInBytes;
  }

  public void setProvisionedTieredStorageInBytes(Long provisionedTieredStorageInBytes) {
    this.provisionedTieredStorageInBytes = provisionedTieredStorageInBytes;
  }


  public DeviceProperties provisionedVolumeSizeInBytes(Long provisionedVolumeSizeInBytes) {
    this.provisionedVolumeSizeInBytes = provisionedVolumeSizeInBytes;
    return this;
  }

  /**
   * Total capacity in bytes of tiered and locally pinned volumes on the device
   * @return provisionedVolumeSizeInBytes
   */
  @javax.annotation.Nullable
  public Long getProvisionedVolumeSizeInBytes() {
    return provisionedVolumeSizeInBytes;
  }

  public void setProvisionedVolumeSizeInBytes(Long provisionedVolumeSizeInBytes) {
    this.provisionedVolumeSizeInBytes = provisionedVolumeSizeInBytes;
  }


  public DeviceProperties rolloverDetails(DeviceRolloverDetails rolloverDetails) {
    this.rolloverDetails = rolloverDetails;
    return this;
  }

  /**
   * Get rolloverDetails
   * @return rolloverDetails
   */
  @javax.annotation.Nullable
  public DeviceRolloverDetails getRolloverDetails() {
    return rolloverDetails;
  }

  public void setRolloverDetails(DeviceRolloverDetails rolloverDetails) {
    this.rolloverDetails = rolloverDetails;
  }


  public DeviceProperties serialNumber(String serialNumber) {
    this.serialNumber = serialNumber;
    return this;
  }

  /**
   * The serial number.
   * @return serialNumber
   */
  @javax.annotation.Nonnull
  public String getSerialNumber() {
    return serialNumber;
  }

  public void setSerialNumber(String serialNumber) {
    this.serialNumber = serialNumber;
  }


  public DeviceProperties status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * The current status of the device.
   * @return status
   */
  @javax.annotation.Nonnull
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }


  public DeviceProperties targetIqn(String targetIqn) {
    this.targetIqn = targetIqn;
    return this;
  }

  /**
   * The target IQN.
   * @return targetIqn
   */
  @javax.annotation.Nonnull
  public String getTargetIqn() {
    return targetIqn;
  }

  public void setTargetIqn(String targetIqn) {
    this.targetIqn = targetIqn;
  }


  public DeviceProperties totalTieredStorageInBytes(Long totalTieredStorageInBytes) {
    this.totalTieredStorageInBytes = totalTieredStorageInBytes;
    return this;
  }

  /**
   * The total tiered storage available on the device in bytes.
   * @return totalTieredStorageInBytes
   */
  @javax.annotation.Nullable
  public Long getTotalTieredStorageInBytes() {
    return totalTieredStorageInBytes;
  }

  public void setTotalTieredStorageInBytes(Long totalTieredStorageInBytes) {
    this.totalTieredStorageInBytes = totalTieredStorageInBytes;
  }


  public DeviceProperties usingStorageInBytes(Long usingStorageInBytes) {
    this.usingStorageInBytes = usingStorageInBytes;
    return this;
  }

  /**
   * The storage in bytes that is currently being used on the device, including both local and cloud.
   * @return usingStorageInBytes
   */
  @javax.annotation.Nullable
  public Long getUsingStorageInBytes() {
    return usingStorageInBytes;
  }

  public void setUsingStorageInBytes(Long usingStorageInBytes) {
    this.usingStorageInBytes = usingStorageInBytes;
  }


  /**
   * The virtual machine API type.
   * @return virtualMachineApiType
   */
  @javax.annotation.Nullable
  public VirtualMachineApiTypeEnum getVirtualMachineApiType() {
    return virtualMachineApiType;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DeviceProperties deviceProperties = (DeviceProperties) o;
    return Objects.equals(this.activationTime, deviceProperties.activationTime) &&
        Objects.equals(this.activeController, deviceProperties.activeController) &&
        Objects.equals(this.agentGroupVersion, deviceProperties.agentGroupVersion) &&
        Objects.equals(this.availableLocalStorageInBytes, deviceProperties.availableLocalStorageInBytes) &&
        Objects.equals(this.availableTieredStorageInBytes, deviceProperties.availableTieredStorageInBytes) &&
        Objects.equals(this.culture, deviceProperties.culture) &&
        Objects.equals(this.details, deviceProperties.details) &&
        Objects.equals(this.deviceConfigurationStatus, deviceProperties.deviceConfigurationStatus) &&
        Objects.equals(this.deviceDescription, deviceProperties.deviceDescription) &&
        Objects.equals(this.deviceLocation, deviceProperties.deviceLocation) &&
        Objects.equals(this.deviceSoftwareVersion, deviceProperties.deviceSoftwareVersion) &&
        Objects.equals(this.deviceType, deviceProperties.deviceType) &&
        Objects.equals(this.friendlyName, deviceProperties.friendlyName) &&
        Objects.equals(this.friendlySoftwareName, deviceProperties.friendlySoftwareName) &&
        Objects.equals(this.friendlySoftwareVersion, deviceProperties.friendlySoftwareVersion) &&
        Objects.equals(this.modelDescription, deviceProperties.modelDescription) &&
        Objects.equals(this.networkInterfaceCardCount, deviceProperties.networkInterfaceCardCount) &&
        Objects.equals(this.provisionedLocalStorageInBytes, deviceProperties.provisionedLocalStorageInBytes) &&
        Objects.equals(this.provisionedTieredStorageInBytes, deviceProperties.provisionedTieredStorageInBytes) &&
        Objects.equals(this.provisionedVolumeSizeInBytes, deviceProperties.provisionedVolumeSizeInBytes) &&
        Objects.equals(this.rolloverDetails, deviceProperties.rolloverDetails) &&
        Objects.equals(this.serialNumber, deviceProperties.serialNumber) &&
        Objects.equals(this.status, deviceProperties.status) &&
        Objects.equals(this.targetIqn, deviceProperties.targetIqn) &&
        Objects.equals(this.totalTieredStorageInBytes, deviceProperties.totalTieredStorageInBytes) &&
        Objects.equals(this.usingStorageInBytes, deviceProperties.usingStorageInBytes) &&
        Objects.equals(this.virtualMachineApiType, deviceProperties.virtualMachineApiType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activationTime, activeController, agentGroupVersion, availableLocalStorageInBytes, availableTieredStorageInBytes, culture, details, deviceConfigurationStatus, deviceDescription, deviceLocation, deviceSoftwareVersion, deviceType, friendlyName, friendlySoftwareName, friendlySoftwareVersion, modelDescription, networkInterfaceCardCount, provisionedLocalStorageInBytes, provisionedTieredStorageInBytes, provisionedVolumeSizeInBytes, rolloverDetails, serialNumber, status, targetIqn, totalTieredStorageInBytes, usingStorageInBytes, virtualMachineApiType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DeviceProperties {\n");
    sb.append("    activationTime: ").append(toIndentedString(activationTime)).append("\n");
    sb.append("    activeController: ").append(toIndentedString(activeController)).append("\n");
    sb.append("    agentGroupVersion: ").append(toIndentedString(agentGroupVersion)).append("\n");
    sb.append("    availableLocalStorageInBytes: ").append(toIndentedString(availableLocalStorageInBytes)).append("\n");
    sb.append("    availableTieredStorageInBytes: ").append(toIndentedString(availableTieredStorageInBytes)).append("\n");
    sb.append("    culture: ").append(toIndentedString(culture)).append("\n");
    sb.append("    details: ").append(toIndentedString(details)).append("\n");
    sb.append("    deviceConfigurationStatus: ").append(toIndentedString(deviceConfigurationStatus)).append("\n");
    sb.append("    deviceDescription: ").append(toIndentedString(deviceDescription)).append("\n");
    sb.append("    deviceLocation: ").append(toIndentedString(deviceLocation)).append("\n");
    sb.append("    deviceSoftwareVersion: ").append(toIndentedString(deviceSoftwareVersion)).append("\n");
    sb.append("    deviceType: ").append(toIndentedString(deviceType)).append("\n");
    sb.append("    friendlyName: ").append(toIndentedString(friendlyName)).append("\n");
    sb.append("    friendlySoftwareName: ").append(toIndentedString(friendlySoftwareName)).append("\n");
    sb.append("    friendlySoftwareVersion: ").append(toIndentedString(friendlySoftwareVersion)).append("\n");
    sb.append("    modelDescription: ").append(toIndentedString(modelDescription)).append("\n");
    sb.append("    networkInterfaceCardCount: ").append(toIndentedString(networkInterfaceCardCount)).append("\n");
    sb.append("    provisionedLocalStorageInBytes: ").append(toIndentedString(provisionedLocalStorageInBytes)).append("\n");
    sb.append("    provisionedTieredStorageInBytes: ").append(toIndentedString(provisionedTieredStorageInBytes)).append("\n");
    sb.append("    provisionedVolumeSizeInBytes: ").append(toIndentedString(provisionedVolumeSizeInBytes)).append("\n");
    sb.append("    rolloverDetails: ").append(toIndentedString(rolloverDetails)).append("\n");
    sb.append("    serialNumber: ").append(toIndentedString(serialNumber)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    targetIqn: ").append(toIndentedString(targetIqn)).append("\n");
    sb.append("    totalTieredStorageInBytes: ").append(toIndentedString(totalTieredStorageInBytes)).append("\n");
    sb.append("    usingStorageInBytes: ").append(toIndentedString(usingStorageInBytes)).append("\n");
    sb.append("    virtualMachineApiType: ").append(toIndentedString(virtualMachineApiType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activationTime");
    openapiFields.add("activeController");
    openapiFields.add("agentGroupVersion");
    openapiFields.add("availableLocalStorageInBytes");
    openapiFields.add("availableTieredStorageInBytes");
    openapiFields.add("culture");
    openapiFields.add("details");
    openapiFields.add("deviceConfigurationStatus");
    openapiFields.add("deviceDescription");
    openapiFields.add("deviceLocation");
    openapiFields.add("deviceSoftwareVersion");
    openapiFields.add("deviceType");
    openapiFields.add("friendlyName");
    openapiFields.add("friendlySoftwareName");
    openapiFields.add("friendlySoftwareVersion");
    openapiFields.add("modelDescription");
    openapiFields.add("networkInterfaceCardCount");
    openapiFields.add("provisionedLocalStorageInBytes");
    openapiFields.add("provisionedTieredStorageInBytes");
    openapiFields.add("provisionedVolumeSizeInBytes");
    openapiFields.add("rolloverDetails");
    openapiFields.add("serialNumber");
    openapiFields.add("status");
    openapiFields.add("targetIqn");
    openapiFields.add("totalTieredStorageInBytes");
    openapiFields.add("usingStorageInBytes");
    openapiFields.add("virtualMachineApiType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("activationTime");
    openapiRequiredFields.add("activeController");
    openapiRequiredFields.add("culture");
    openapiRequiredFields.add("deviceConfigurationStatus");
    openapiRequiredFields.add("deviceDescription");
    openapiRequiredFields.add("deviceSoftwareVersion");
    openapiRequiredFields.add("deviceType");
    openapiRequiredFields.add("friendlyName");
    openapiRequiredFields.add("friendlySoftwareVersion");
    openapiRequiredFields.add("modelDescription");
    openapiRequiredFields.add("serialNumber");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("targetIqn");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DeviceProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DeviceProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DeviceProperties is not found in the empty JSON string", DeviceProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DeviceProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DeviceProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DeviceProperties.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("activeController").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `activeController` to be a primitive type in the JSON string but got `%s`", jsonObj.get("activeController").toString()));
      }
      // validate the required field `activeController`
      ActiveControllerEnum.validateJsonElement(jsonObj.get("activeController"));
      if (!jsonObj.get("culture").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `culture` to be a primitive type in the JSON string but got `%s`", jsonObj.get("culture").toString()));
      }
      // validate the optional field `details`
      if (jsonObj.get("details") != null && !jsonObj.get("details").isJsonNull()) {
        DeviceDetails.validateJsonElement(jsonObj.get("details"));
      }
      if (!jsonObj.get("deviceConfigurationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceConfigurationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceConfigurationStatus").toString()));
      }
      // validate the required field `deviceConfigurationStatus`
      DeviceConfigurationStatusEnum.validateJsonElement(jsonObj.get("deviceConfigurationStatus"));
      if (!jsonObj.get("deviceDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceDescription").toString()));
      }
      if ((jsonObj.get("deviceLocation") != null && !jsonObj.get("deviceLocation").isJsonNull()) && !jsonObj.get("deviceLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceLocation").toString()));
      }
      if (!jsonObj.get("deviceSoftwareVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceSoftwareVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceSoftwareVersion").toString()));
      }
      if (!jsonObj.get("deviceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceType").toString()));
      }
      // validate the required field `deviceType`
      DeviceTypeEnum.validateJsonElement(jsonObj.get("deviceType"));
      if (!jsonObj.get("friendlyName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `friendlyName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("friendlyName").toString()));
      }
      if ((jsonObj.get("friendlySoftwareName") != null && !jsonObj.get("friendlySoftwareName").isJsonNull()) && !jsonObj.get("friendlySoftwareName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `friendlySoftwareName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("friendlySoftwareName").toString()));
      }
      if (!jsonObj.get("friendlySoftwareVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `friendlySoftwareVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("friendlySoftwareVersion").toString()));
      }
      if (!jsonObj.get("modelDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `modelDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("modelDescription").toString()));
      }
      // validate the optional field `rolloverDetails`
      if (jsonObj.get("rolloverDetails") != null && !jsonObj.get("rolloverDetails").isJsonNull()) {
        DeviceRolloverDetails.validateJsonElement(jsonObj.get("rolloverDetails"));
      }
      if (!jsonObj.get("serialNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serialNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serialNumber").toString()));
      }
      if (!jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the required field `status`
      StatusEnum.validateJsonElement(jsonObj.get("status"));
      if (!jsonObj.get("targetIqn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `targetIqn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("targetIqn").toString()));
      }
      if ((jsonObj.get("virtualMachineApiType") != null && !jsonObj.get("virtualMachineApiType").isJsonNull()) && !jsonObj.get("virtualMachineApiType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `virtualMachineApiType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("virtualMachineApiType").toString()));
      }
      // validate the optional field `virtualMachineApiType`
      if (jsonObj.get("virtualMachineApiType") != null && !jsonObj.get("virtualMachineApiType").isJsonNull()) {
        VirtualMachineApiTypeEnum.validateJsonElement(jsonObj.get("virtualMachineApiType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DeviceProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DeviceProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DeviceProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DeviceProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<DeviceProperties>() {
           @Override
           public void write(JsonWriter out, DeviceProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DeviceProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DeviceProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DeviceProperties
   * @throws IOException if the JSON string is invalid with respect to DeviceProperties
   */
  public static DeviceProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DeviceProperties.class);
  }

  /**
   * Convert an instance of DeviceProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

