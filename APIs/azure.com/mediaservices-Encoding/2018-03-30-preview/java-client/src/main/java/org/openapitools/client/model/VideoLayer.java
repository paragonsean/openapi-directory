/*
 * Azure Media Services
 * This Swagger was generated by the API Framework.
 *
 * The version of the OpenAPI document: 2018-03-30-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Layer;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the settings to be used when encoding the input video into a desired output bitrate layer.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:53:54.202035-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoLayer extends Layer {
  public static final String SERIALIZED_NAME_ADAPTIVE_B_FRAME = "adaptiveBFrame";
  @SerializedName(SERIALIZED_NAME_ADAPTIVE_B_FRAME)
  private Boolean adaptiveBFrame;

  public static final String SERIALIZED_NAME_B_FRAMES = "bFrames";
  @SerializedName(SERIALIZED_NAME_B_FRAMES)
  private Integer bFrames;

  public static final String SERIALIZED_NAME_BITRATE = "bitrate";
  @SerializedName(SERIALIZED_NAME_BITRATE)
  private Integer bitrate;

  public static final String SERIALIZED_NAME_FRAME_RATE = "frameRate";
  @SerializedName(SERIALIZED_NAME_FRAME_RATE)
  private String frameRate;

  public static final String SERIALIZED_NAME_MAX_BITRATE = "maxBitrate";
  @SerializedName(SERIALIZED_NAME_MAX_BITRATE)
  private Integer maxBitrate;

  public static final String SERIALIZED_NAME_SLICES = "slices";
  @SerializedName(SERIALIZED_NAME_SLICES)
  private Integer slices;

  public VideoLayer() {
    this.atOdataType = this.getClass().getSimpleName();
  }

  public VideoLayer adaptiveBFrame(Boolean adaptiveBFrame) {
    this.adaptiveBFrame = adaptiveBFrame;
    return this;
  }

  /**
   * Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
   * @return adaptiveBFrame
   */
  @javax.annotation.Nullable
  public Boolean getAdaptiveBFrame() {
    return adaptiveBFrame;
  }

  public void setAdaptiveBFrame(Boolean adaptiveBFrame) {
    this.adaptiveBFrame = adaptiveBFrame;
  }


  public VideoLayer bFrames(Integer bFrames) {
    this.bFrames = bFrames;
    return this;
  }

  /**
   * The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
   * @return bFrames
   */
  @javax.annotation.Nullable
  public Integer getbFrames() {
    return bFrames;
  }

  public void setbFrames(Integer bFrames) {
    this.bFrames = bFrames;
  }


  public VideoLayer bitrate(Integer bitrate) {
    this.bitrate = bitrate;
    return this;
  }

  /**
   * The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
   * @return bitrate
   */
  @javax.annotation.Nullable
  public Integer getBitrate() {
    return bitrate;
  }

  public void setBitrate(Integer bitrate) {
    this.bitrate = bitrate;
  }


  public VideoLayer frameRate(String frameRate) {
    this.frameRate = frameRate;
    return this;
  }

  /**
   * The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
   * @return frameRate
   */
  @javax.annotation.Nullable
  public String getFrameRate() {
    return frameRate;
  }

  public void setFrameRate(String frameRate) {
    this.frameRate = frameRate;
  }


  public VideoLayer maxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
    return this;
  }

  /**
   * The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
   * @return maxBitrate
   */
  @javax.annotation.Nullable
  public Integer getMaxBitrate() {
    return maxBitrate;
  }

  public void setMaxBitrate(Integer maxBitrate) {
    this.maxBitrate = maxBitrate;
  }


  public VideoLayer slices(Integer slices) {
    this.slices = slices;
    return this;
  }

  /**
   * The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
   * @return slices
   */
  @javax.annotation.Nullable
  public Integer getSlices() {
    return slices;
  }

  public void setSlices(Integer slices) {
    this.slices = slices;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoLayer videoLayer = (VideoLayer) o;
    return Objects.equals(this.adaptiveBFrame, videoLayer.adaptiveBFrame) &&
        Objects.equals(this.bFrames, videoLayer.bFrames) &&
        Objects.equals(this.bitrate, videoLayer.bitrate) &&
        Objects.equals(this.frameRate, videoLayer.frameRate) &&
        Objects.equals(this.maxBitrate, videoLayer.maxBitrate) &&
        Objects.equals(this.slices, videoLayer.slices) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(adaptiveBFrame, bFrames, bitrate, frameRate, maxBitrate, slices, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoLayer {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    adaptiveBFrame: ").append(toIndentedString(adaptiveBFrame)).append("\n");
    sb.append("    bFrames: ").append(toIndentedString(bFrames)).append("\n");
    sb.append("    bitrate: ").append(toIndentedString(bitrate)).append("\n");
    sb.append("    frameRate: ").append(toIndentedString(frameRate)).append("\n");
    sb.append("    maxBitrate: ").append(toIndentedString(maxBitrate)).append("\n");
    sb.append("    slices: ").append(toIndentedString(slices)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("@odata.type");
    openapiFields.add("height");
    openapiFields.add("label");
    openapiFields.add("width");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("@odata.type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoLayer
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoLayer.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoLayer is not found in the empty JSON string", VideoLayer.openapiRequiredFields.toString()));
        }
      }

      String discriminatorValue = jsonElement.getAsJsonObject().get("@odata.type").getAsString();
      switch (discriminatorValue) {
        case "H264Layer":
          H264Layer.validateJsonElement(jsonElement);
          break;
        default:
          throw new IllegalArgumentException(String.format("The value of the `@odata.type` field `%s` does not match any key defined in the discriminator's mapping.", discriminatorValue));
      }
  }


  /**
   * Create an instance of VideoLayer given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoLayer
   * @throws IOException if the JSON string is invalid with respect to VideoLayer
   */
  public static VideoLayer fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoLayer.class);
  }

  /**
   * Convert an instance of VideoLayer to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

