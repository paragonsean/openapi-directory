/**
 * SiteRecoveryManagementClient
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2016-08-10
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVMwareDetails.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVMwareDetails::OAIVMwareDetails(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVMwareDetails::OAIVMwareDetails() {
    this->initializeModel();
}

OAIVMwareDetails::~OAIVMwareDetails() {}

void OAIVMwareDetails::initializeModel() {

    m_agent_count_isSet = false;
    m_agent_count_isValid = false;

    m_agent_version_isSet = false;
    m_agent_version_isValid = false;

    m_available_memory_in_bytes_isSet = false;
    m_available_memory_in_bytes_isValid = false;

    m_available_space_in_bytes_isSet = false;
    m_available_space_in_bytes_isValid = false;

    m_cpu_load_isSet = false;
    m_cpu_load_isValid = false;

    m_cpu_load_status_isSet = false;
    m_cpu_load_status_isValid = false;

    m_cs_service_status_isSet = false;
    m_cs_service_status_isValid = false;

    m_database_server_load_isSet = false;
    m_database_server_load_isValid = false;

    m_database_server_load_status_isSet = false;
    m_database_server_load_status_isValid = false;

    m_host_name_isSet = false;
    m_host_name_isValid = false;

    m_ip_address_isSet = false;
    m_ip_address_isValid = false;

    m_last_heartbeat_isSet = false;
    m_last_heartbeat_isValid = false;

    m_master_target_servers_isSet = false;
    m_master_target_servers_isValid = false;

    m_memory_usage_status_isSet = false;
    m_memory_usage_status_isValid = false;

    m_process_server_count_isSet = false;
    m_process_server_count_isValid = false;

    m_process_servers_isSet = false;
    m_process_servers_isValid = false;

    m_protected_servers_isSet = false;
    m_protected_servers_isValid = false;

    m_ps_template_version_isSet = false;
    m_ps_template_version_isValid = false;

    m_replication_pair_count_isSet = false;
    m_replication_pair_count_isValid = false;

    m_run_as_accounts_isSet = false;
    m_run_as_accounts_isValid = false;

    m_space_usage_status_isSet = false;
    m_space_usage_status_isValid = false;

    m_ssl_cert_expiry_date_isSet = false;
    m_ssl_cert_expiry_date_isValid = false;

    m_ssl_cert_expiry_remaining_days_isSet = false;
    m_ssl_cert_expiry_remaining_days_isValid = false;

    m_system_load_isSet = false;
    m_system_load_isValid = false;

    m_system_load_status_isSet = false;
    m_system_load_status_isValid = false;

    m_total_memory_in_bytes_isSet = false;
    m_total_memory_in_bytes_isValid = false;

    m_total_space_in_bytes_isSet = false;
    m_total_space_in_bytes_isValid = false;

    m_version_status_isSet = false;
    m_version_status_isValid = false;

    m_web_load_isSet = false;
    m_web_load_isValid = false;

    m_web_load_status_isSet = false;
    m_web_load_status_isValid = false;

    m_instance_type_isSet = false;
    m_instance_type_isValid = false;
}

void OAIVMwareDetails::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVMwareDetails::fromJsonObject(QJsonObject json) {

    m_agent_count_isValid = ::OpenAPI::fromJsonValue(m_agent_count, json[QString("agentCount")]);
    m_agent_count_isSet = !json[QString("agentCount")].isNull() && m_agent_count_isValid;

    m_agent_version_isValid = ::OpenAPI::fromJsonValue(m_agent_version, json[QString("agentVersion")]);
    m_agent_version_isSet = !json[QString("agentVersion")].isNull() && m_agent_version_isValid;

    m_available_memory_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_available_memory_in_bytes, json[QString("availableMemoryInBytes")]);
    m_available_memory_in_bytes_isSet = !json[QString("availableMemoryInBytes")].isNull() && m_available_memory_in_bytes_isValid;

    m_available_space_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_available_space_in_bytes, json[QString("availableSpaceInBytes")]);
    m_available_space_in_bytes_isSet = !json[QString("availableSpaceInBytes")].isNull() && m_available_space_in_bytes_isValid;

    m_cpu_load_isValid = ::OpenAPI::fromJsonValue(m_cpu_load, json[QString("cpuLoad")]);
    m_cpu_load_isSet = !json[QString("cpuLoad")].isNull() && m_cpu_load_isValid;

    m_cpu_load_status_isValid = ::OpenAPI::fromJsonValue(m_cpu_load_status, json[QString("cpuLoadStatus")]);
    m_cpu_load_status_isSet = !json[QString("cpuLoadStatus")].isNull() && m_cpu_load_status_isValid;

    m_cs_service_status_isValid = ::OpenAPI::fromJsonValue(m_cs_service_status, json[QString("csServiceStatus")]);
    m_cs_service_status_isSet = !json[QString("csServiceStatus")].isNull() && m_cs_service_status_isValid;

    m_database_server_load_isValid = ::OpenAPI::fromJsonValue(m_database_server_load, json[QString("databaseServerLoad")]);
    m_database_server_load_isSet = !json[QString("databaseServerLoad")].isNull() && m_database_server_load_isValid;

    m_database_server_load_status_isValid = ::OpenAPI::fromJsonValue(m_database_server_load_status, json[QString("databaseServerLoadStatus")]);
    m_database_server_load_status_isSet = !json[QString("databaseServerLoadStatus")].isNull() && m_database_server_load_status_isValid;

    m_host_name_isValid = ::OpenAPI::fromJsonValue(m_host_name, json[QString("hostName")]);
    m_host_name_isSet = !json[QString("hostName")].isNull() && m_host_name_isValid;

    m_ip_address_isValid = ::OpenAPI::fromJsonValue(m_ip_address, json[QString("ipAddress")]);
    m_ip_address_isSet = !json[QString("ipAddress")].isNull() && m_ip_address_isValid;

    m_last_heartbeat_isValid = ::OpenAPI::fromJsonValue(m_last_heartbeat, json[QString("lastHeartbeat")]);
    m_last_heartbeat_isSet = !json[QString("lastHeartbeat")].isNull() && m_last_heartbeat_isValid;

    m_master_target_servers_isValid = ::OpenAPI::fromJsonValue(m_master_target_servers, json[QString("masterTargetServers")]);
    m_master_target_servers_isSet = !json[QString("masterTargetServers")].isNull() && m_master_target_servers_isValid;

    m_memory_usage_status_isValid = ::OpenAPI::fromJsonValue(m_memory_usage_status, json[QString("memoryUsageStatus")]);
    m_memory_usage_status_isSet = !json[QString("memoryUsageStatus")].isNull() && m_memory_usage_status_isValid;

    m_process_server_count_isValid = ::OpenAPI::fromJsonValue(m_process_server_count, json[QString("processServerCount")]);
    m_process_server_count_isSet = !json[QString("processServerCount")].isNull() && m_process_server_count_isValid;

    m_process_servers_isValid = ::OpenAPI::fromJsonValue(m_process_servers, json[QString("processServers")]);
    m_process_servers_isSet = !json[QString("processServers")].isNull() && m_process_servers_isValid;

    m_protected_servers_isValid = ::OpenAPI::fromJsonValue(m_protected_servers, json[QString("protectedServers")]);
    m_protected_servers_isSet = !json[QString("protectedServers")].isNull() && m_protected_servers_isValid;

    m_ps_template_version_isValid = ::OpenAPI::fromJsonValue(m_ps_template_version, json[QString("psTemplateVersion")]);
    m_ps_template_version_isSet = !json[QString("psTemplateVersion")].isNull() && m_ps_template_version_isValid;

    m_replication_pair_count_isValid = ::OpenAPI::fromJsonValue(m_replication_pair_count, json[QString("replicationPairCount")]);
    m_replication_pair_count_isSet = !json[QString("replicationPairCount")].isNull() && m_replication_pair_count_isValid;

    m_run_as_accounts_isValid = ::OpenAPI::fromJsonValue(m_run_as_accounts, json[QString("runAsAccounts")]);
    m_run_as_accounts_isSet = !json[QString("runAsAccounts")].isNull() && m_run_as_accounts_isValid;

    m_space_usage_status_isValid = ::OpenAPI::fromJsonValue(m_space_usage_status, json[QString("spaceUsageStatus")]);
    m_space_usage_status_isSet = !json[QString("spaceUsageStatus")].isNull() && m_space_usage_status_isValid;

    m_ssl_cert_expiry_date_isValid = ::OpenAPI::fromJsonValue(m_ssl_cert_expiry_date, json[QString("sslCertExpiryDate")]);
    m_ssl_cert_expiry_date_isSet = !json[QString("sslCertExpiryDate")].isNull() && m_ssl_cert_expiry_date_isValid;

    m_ssl_cert_expiry_remaining_days_isValid = ::OpenAPI::fromJsonValue(m_ssl_cert_expiry_remaining_days, json[QString("sslCertExpiryRemainingDays")]);
    m_ssl_cert_expiry_remaining_days_isSet = !json[QString("sslCertExpiryRemainingDays")].isNull() && m_ssl_cert_expiry_remaining_days_isValid;

    m_system_load_isValid = ::OpenAPI::fromJsonValue(m_system_load, json[QString("systemLoad")]);
    m_system_load_isSet = !json[QString("systemLoad")].isNull() && m_system_load_isValid;

    m_system_load_status_isValid = ::OpenAPI::fromJsonValue(m_system_load_status, json[QString("systemLoadStatus")]);
    m_system_load_status_isSet = !json[QString("systemLoadStatus")].isNull() && m_system_load_status_isValid;

    m_total_memory_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_total_memory_in_bytes, json[QString("totalMemoryInBytes")]);
    m_total_memory_in_bytes_isSet = !json[QString("totalMemoryInBytes")].isNull() && m_total_memory_in_bytes_isValid;

    m_total_space_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_total_space_in_bytes, json[QString("totalSpaceInBytes")]);
    m_total_space_in_bytes_isSet = !json[QString("totalSpaceInBytes")].isNull() && m_total_space_in_bytes_isValid;

    m_version_status_isValid = ::OpenAPI::fromJsonValue(m_version_status, json[QString("versionStatus")]);
    m_version_status_isSet = !json[QString("versionStatus")].isNull() && m_version_status_isValid;

    m_web_load_isValid = ::OpenAPI::fromJsonValue(m_web_load, json[QString("webLoad")]);
    m_web_load_isSet = !json[QString("webLoad")].isNull() && m_web_load_isValid;

    m_web_load_status_isValid = ::OpenAPI::fromJsonValue(m_web_load_status, json[QString("webLoadStatus")]);
    m_web_load_status_isSet = !json[QString("webLoadStatus")].isNull() && m_web_load_status_isValid;

    m_instance_type_isValid = ::OpenAPI::fromJsonValue(m_instance_type, json[QString("instanceType")]);
    m_instance_type_isSet = !json[QString("instanceType")].isNull() && m_instance_type_isValid;
}

QString OAIVMwareDetails::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVMwareDetails::asJsonObject() const {
    QJsonObject obj;
    if (m_agent_count_isSet) {
        obj.insert(QString("agentCount"), ::OpenAPI::toJsonValue(m_agent_count));
    }
    if (m_agent_version_isSet) {
        obj.insert(QString("agentVersion"), ::OpenAPI::toJsonValue(m_agent_version));
    }
    if (m_available_memory_in_bytes_isSet) {
        obj.insert(QString("availableMemoryInBytes"), ::OpenAPI::toJsonValue(m_available_memory_in_bytes));
    }
    if (m_available_space_in_bytes_isSet) {
        obj.insert(QString("availableSpaceInBytes"), ::OpenAPI::toJsonValue(m_available_space_in_bytes));
    }
    if (m_cpu_load_isSet) {
        obj.insert(QString("cpuLoad"), ::OpenAPI::toJsonValue(m_cpu_load));
    }
    if (m_cpu_load_status_isSet) {
        obj.insert(QString("cpuLoadStatus"), ::OpenAPI::toJsonValue(m_cpu_load_status));
    }
    if (m_cs_service_status_isSet) {
        obj.insert(QString("csServiceStatus"), ::OpenAPI::toJsonValue(m_cs_service_status));
    }
    if (m_database_server_load_isSet) {
        obj.insert(QString("databaseServerLoad"), ::OpenAPI::toJsonValue(m_database_server_load));
    }
    if (m_database_server_load_status_isSet) {
        obj.insert(QString("databaseServerLoadStatus"), ::OpenAPI::toJsonValue(m_database_server_load_status));
    }
    if (m_host_name_isSet) {
        obj.insert(QString("hostName"), ::OpenAPI::toJsonValue(m_host_name));
    }
    if (m_ip_address_isSet) {
        obj.insert(QString("ipAddress"), ::OpenAPI::toJsonValue(m_ip_address));
    }
    if (m_last_heartbeat_isSet) {
        obj.insert(QString("lastHeartbeat"), ::OpenAPI::toJsonValue(m_last_heartbeat));
    }
    if (m_master_target_servers.size() > 0) {
        obj.insert(QString("masterTargetServers"), ::OpenAPI::toJsonValue(m_master_target_servers));
    }
    if (m_memory_usage_status_isSet) {
        obj.insert(QString("memoryUsageStatus"), ::OpenAPI::toJsonValue(m_memory_usage_status));
    }
    if (m_process_server_count_isSet) {
        obj.insert(QString("processServerCount"), ::OpenAPI::toJsonValue(m_process_server_count));
    }
    if (m_process_servers.size() > 0) {
        obj.insert(QString("processServers"), ::OpenAPI::toJsonValue(m_process_servers));
    }
    if (m_protected_servers_isSet) {
        obj.insert(QString("protectedServers"), ::OpenAPI::toJsonValue(m_protected_servers));
    }
    if (m_ps_template_version_isSet) {
        obj.insert(QString("psTemplateVersion"), ::OpenAPI::toJsonValue(m_ps_template_version));
    }
    if (m_replication_pair_count_isSet) {
        obj.insert(QString("replicationPairCount"), ::OpenAPI::toJsonValue(m_replication_pair_count));
    }
    if (m_run_as_accounts.size() > 0) {
        obj.insert(QString("runAsAccounts"), ::OpenAPI::toJsonValue(m_run_as_accounts));
    }
    if (m_space_usage_status_isSet) {
        obj.insert(QString("spaceUsageStatus"), ::OpenAPI::toJsonValue(m_space_usage_status));
    }
    if (m_ssl_cert_expiry_date_isSet) {
        obj.insert(QString("sslCertExpiryDate"), ::OpenAPI::toJsonValue(m_ssl_cert_expiry_date));
    }
    if (m_ssl_cert_expiry_remaining_days_isSet) {
        obj.insert(QString("sslCertExpiryRemainingDays"), ::OpenAPI::toJsonValue(m_ssl_cert_expiry_remaining_days));
    }
    if (m_system_load_isSet) {
        obj.insert(QString("systemLoad"), ::OpenAPI::toJsonValue(m_system_load));
    }
    if (m_system_load_status_isSet) {
        obj.insert(QString("systemLoadStatus"), ::OpenAPI::toJsonValue(m_system_load_status));
    }
    if (m_total_memory_in_bytes_isSet) {
        obj.insert(QString("totalMemoryInBytes"), ::OpenAPI::toJsonValue(m_total_memory_in_bytes));
    }
    if (m_total_space_in_bytes_isSet) {
        obj.insert(QString("totalSpaceInBytes"), ::OpenAPI::toJsonValue(m_total_space_in_bytes));
    }
    if (m_version_status_isSet) {
        obj.insert(QString("versionStatus"), ::OpenAPI::toJsonValue(m_version_status));
    }
    if (m_web_load_isSet) {
        obj.insert(QString("webLoad"), ::OpenAPI::toJsonValue(m_web_load));
    }
    if (m_web_load_status_isSet) {
        obj.insert(QString("webLoadStatus"), ::OpenAPI::toJsonValue(m_web_load_status));
    }
    if (m_instance_type_isSet) {
        obj.insert(QString("instanceType"), ::OpenAPI::toJsonValue(m_instance_type));
    }
    return obj;
}

QString OAIVMwareDetails::getAgentCount() const {
    return m_agent_count;
}
void OAIVMwareDetails::setAgentCount(const QString &agent_count) {
    m_agent_count = agent_count;
    m_agent_count_isSet = true;
}

bool OAIVMwareDetails::is_agent_count_Set() const{
    return m_agent_count_isSet;
}

bool OAIVMwareDetails::is_agent_count_Valid() const{
    return m_agent_count_isValid;
}

QString OAIVMwareDetails::getAgentVersion() const {
    return m_agent_version;
}
void OAIVMwareDetails::setAgentVersion(const QString &agent_version) {
    m_agent_version = agent_version;
    m_agent_version_isSet = true;
}

bool OAIVMwareDetails::is_agent_version_Set() const{
    return m_agent_version_isSet;
}

bool OAIVMwareDetails::is_agent_version_Valid() const{
    return m_agent_version_isValid;
}

qint64 OAIVMwareDetails::getAvailableMemoryInBytes() const {
    return m_available_memory_in_bytes;
}
void OAIVMwareDetails::setAvailableMemoryInBytes(const qint64 &available_memory_in_bytes) {
    m_available_memory_in_bytes = available_memory_in_bytes;
    m_available_memory_in_bytes_isSet = true;
}

bool OAIVMwareDetails::is_available_memory_in_bytes_Set() const{
    return m_available_memory_in_bytes_isSet;
}

bool OAIVMwareDetails::is_available_memory_in_bytes_Valid() const{
    return m_available_memory_in_bytes_isValid;
}

qint64 OAIVMwareDetails::getAvailableSpaceInBytes() const {
    return m_available_space_in_bytes;
}
void OAIVMwareDetails::setAvailableSpaceInBytes(const qint64 &available_space_in_bytes) {
    m_available_space_in_bytes = available_space_in_bytes;
    m_available_space_in_bytes_isSet = true;
}

bool OAIVMwareDetails::is_available_space_in_bytes_Set() const{
    return m_available_space_in_bytes_isSet;
}

bool OAIVMwareDetails::is_available_space_in_bytes_Valid() const{
    return m_available_space_in_bytes_isValid;
}

QString OAIVMwareDetails::getCpuLoad() const {
    return m_cpu_load;
}
void OAIVMwareDetails::setCpuLoad(const QString &cpu_load) {
    m_cpu_load = cpu_load;
    m_cpu_load_isSet = true;
}

bool OAIVMwareDetails::is_cpu_load_Set() const{
    return m_cpu_load_isSet;
}

bool OAIVMwareDetails::is_cpu_load_Valid() const{
    return m_cpu_load_isValid;
}

QString OAIVMwareDetails::getCpuLoadStatus() const {
    return m_cpu_load_status;
}
void OAIVMwareDetails::setCpuLoadStatus(const QString &cpu_load_status) {
    m_cpu_load_status = cpu_load_status;
    m_cpu_load_status_isSet = true;
}

bool OAIVMwareDetails::is_cpu_load_status_Set() const{
    return m_cpu_load_status_isSet;
}

bool OAIVMwareDetails::is_cpu_load_status_Valid() const{
    return m_cpu_load_status_isValid;
}

QString OAIVMwareDetails::getCsServiceStatus() const {
    return m_cs_service_status;
}
void OAIVMwareDetails::setCsServiceStatus(const QString &cs_service_status) {
    m_cs_service_status = cs_service_status;
    m_cs_service_status_isSet = true;
}

bool OAIVMwareDetails::is_cs_service_status_Set() const{
    return m_cs_service_status_isSet;
}

bool OAIVMwareDetails::is_cs_service_status_Valid() const{
    return m_cs_service_status_isValid;
}

QString OAIVMwareDetails::getDatabaseServerLoad() const {
    return m_database_server_load;
}
void OAIVMwareDetails::setDatabaseServerLoad(const QString &database_server_load) {
    m_database_server_load = database_server_load;
    m_database_server_load_isSet = true;
}

bool OAIVMwareDetails::is_database_server_load_Set() const{
    return m_database_server_load_isSet;
}

bool OAIVMwareDetails::is_database_server_load_Valid() const{
    return m_database_server_load_isValid;
}

QString OAIVMwareDetails::getDatabaseServerLoadStatus() const {
    return m_database_server_load_status;
}
void OAIVMwareDetails::setDatabaseServerLoadStatus(const QString &database_server_load_status) {
    m_database_server_load_status = database_server_load_status;
    m_database_server_load_status_isSet = true;
}

bool OAIVMwareDetails::is_database_server_load_status_Set() const{
    return m_database_server_load_status_isSet;
}

bool OAIVMwareDetails::is_database_server_load_status_Valid() const{
    return m_database_server_load_status_isValid;
}

QString OAIVMwareDetails::getHostName() const {
    return m_host_name;
}
void OAIVMwareDetails::setHostName(const QString &host_name) {
    m_host_name = host_name;
    m_host_name_isSet = true;
}

bool OAIVMwareDetails::is_host_name_Set() const{
    return m_host_name_isSet;
}

bool OAIVMwareDetails::is_host_name_Valid() const{
    return m_host_name_isValid;
}

QString OAIVMwareDetails::getIpAddress() const {
    return m_ip_address;
}
void OAIVMwareDetails::setIpAddress(const QString &ip_address) {
    m_ip_address = ip_address;
    m_ip_address_isSet = true;
}

bool OAIVMwareDetails::is_ip_address_Set() const{
    return m_ip_address_isSet;
}

bool OAIVMwareDetails::is_ip_address_Valid() const{
    return m_ip_address_isValid;
}

QDateTime OAIVMwareDetails::getLastHeartbeat() const {
    return m_last_heartbeat;
}
void OAIVMwareDetails::setLastHeartbeat(const QDateTime &last_heartbeat) {
    m_last_heartbeat = last_heartbeat;
    m_last_heartbeat_isSet = true;
}

bool OAIVMwareDetails::is_last_heartbeat_Set() const{
    return m_last_heartbeat_isSet;
}

bool OAIVMwareDetails::is_last_heartbeat_Valid() const{
    return m_last_heartbeat_isValid;
}

QList<OAIMasterTargetServer> OAIVMwareDetails::getMasterTargetServers() const {
    return m_master_target_servers;
}
void OAIVMwareDetails::setMasterTargetServers(const QList<OAIMasterTargetServer> &master_target_servers) {
    m_master_target_servers = master_target_servers;
    m_master_target_servers_isSet = true;
}

bool OAIVMwareDetails::is_master_target_servers_Set() const{
    return m_master_target_servers_isSet;
}

bool OAIVMwareDetails::is_master_target_servers_Valid() const{
    return m_master_target_servers_isValid;
}

QString OAIVMwareDetails::getMemoryUsageStatus() const {
    return m_memory_usage_status;
}
void OAIVMwareDetails::setMemoryUsageStatus(const QString &memory_usage_status) {
    m_memory_usage_status = memory_usage_status;
    m_memory_usage_status_isSet = true;
}

bool OAIVMwareDetails::is_memory_usage_status_Set() const{
    return m_memory_usage_status_isSet;
}

bool OAIVMwareDetails::is_memory_usage_status_Valid() const{
    return m_memory_usage_status_isValid;
}

QString OAIVMwareDetails::getProcessServerCount() const {
    return m_process_server_count;
}
void OAIVMwareDetails::setProcessServerCount(const QString &process_server_count) {
    m_process_server_count = process_server_count;
    m_process_server_count_isSet = true;
}

bool OAIVMwareDetails::is_process_server_count_Set() const{
    return m_process_server_count_isSet;
}

bool OAIVMwareDetails::is_process_server_count_Valid() const{
    return m_process_server_count_isValid;
}

QList<OAIProcessServer> OAIVMwareDetails::getProcessServers() const {
    return m_process_servers;
}
void OAIVMwareDetails::setProcessServers(const QList<OAIProcessServer> &process_servers) {
    m_process_servers = process_servers;
    m_process_servers_isSet = true;
}

bool OAIVMwareDetails::is_process_servers_Set() const{
    return m_process_servers_isSet;
}

bool OAIVMwareDetails::is_process_servers_Valid() const{
    return m_process_servers_isValid;
}

QString OAIVMwareDetails::getProtectedServers() const {
    return m_protected_servers;
}
void OAIVMwareDetails::setProtectedServers(const QString &protected_servers) {
    m_protected_servers = protected_servers;
    m_protected_servers_isSet = true;
}

bool OAIVMwareDetails::is_protected_servers_Set() const{
    return m_protected_servers_isSet;
}

bool OAIVMwareDetails::is_protected_servers_Valid() const{
    return m_protected_servers_isValid;
}

QString OAIVMwareDetails::getPsTemplateVersion() const {
    return m_ps_template_version;
}
void OAIVMwareDetails::setPsTemplateVersion(const QString &ps_template_version) {
    m_ps_template_version = ps_template_version;
    m_ps_template_version_isSet = true;
}

bool OAIVMwareDetails::is_ps_template_version_Set() const{
    return m_ps_template_version_isSet;
}

bool OAIVMwareDetails::is_ps_template_version_Valid() const{
    return m_ps_template_version_isValid;
}

QString OAIVMwareDetails::getReplicationPairCount() const {
    return m_replication_pair_count;
}
void OAIVMwareDetails::setReplicationPairCount(const QString &replication_pair_count) {
    m_replication_pair_count = replication_pair_count;
    m_replication_pair_count_isSet = true;
}

bool OAIVMwareDetails::is_replication_pair_count_Set() const{
    return m_replication_pair_count_isSet;
}

bool OAIVMwareDetails::is_replication_pair_count_Valid() const{
    return m_replication_pair_count_isValid;
}

QList<OAIRunAsAccount> OAIVMwareDetails::getRunAsAccounts() const {
    return m_run_as_accounts;
}
void OAIVMwareDetails::setRunAsAccounts(const QList<OAIRunAsAccount> &run_as_accounts) {
    m_run_as_accounts = run_as_accounts;
    m_run_as_accounts_isSet = true;
}

bool OAIVMwareDetails::is_run_as_accounts_Set() const{
    return m_run_as_accounts_isSet;
}

bool OAIVMwareDetails::is_run_as_accounts_Valid() const{
    return m_run_as_accounts_isValid;
}

QString OAIVMwareDetails::getSpaceUsageStatus() const {
    return m_space_usage_status;
}
void OAIVMwareDetails::setSpaceUsageStatus(const QString &space_usage_status) {
    m_space_usage_status = space_usage_status;
    m_space_usage_status_isSet = true;
}

bool OAIVMwareDetails::is_space_usage_status_Set() const{
    return m_space_usage_status_isSet;
}

bool OAIVMwareDetails::is_space_usage_status_Valid() const{
    return m_space_usage_status_isValid;
}

QDateTime OAIVMwareDetails::getSslCertExpiryDate() const {
    return m_ssl_cert_expiry_date;
}
void OAIVMwareDetails::setSslCertExpiryDate(const QDateTime &ssl_cert_expiry_date) {
    m_ssl_cert_expiry_date = ssl_cert_expiry_date;
    m_ssl_cert_expiry_date_isSet = true;
}

bool OAIVMwareDetails::is_ssl_cert_expiry_date_Set() const{
    return m_ssl_cert_expiry_date_isSet;
}

bool OAIVMwareDetails::is_ssl_cert_expiry_date_Valid() const{
    return m_ssl_cert_expiry_date_isValid;
}

qint32 OAIVMwareDetails::getSslCertExpiryRemainingDays() const {
    return m_ssl_cert_expiry_remaining_days;
}
void OAIVMwareDetails::setSslCertExpiryRemainingDays(const qint32 &ssl_cert_expiry_remaining_days) {
    m_ssl_cert_expiry_remaining_days = ssl_cert_expiry_remaining_days;
    m_ssl_cert_expiry_remaining_days_isSet = true;
}

bool OAIVMwareDetails::is_ssl_cert_expiry_remaining_days_Set() const{
    return m_ssl_cert_expiry_remaining_days_isSet;
}

bool OAIVMwareDetails::is_ssl_cert_expiry_remaining_days_Valid() const{
    return m_ssl_cert_expiry_remaining_days_isValid;
}

QString OAIVMwareDetails::getSystemLoad() const {
    return m_system_load;
}
void OAIVMwareDetails::setSystemLoad(const QString &system_load) {
    m_system_load = system_load;
    m_system_load_isSet = true;
}

bool OAIVMwareDetails::is_system_load_Set() const{
    return m_system_load_isSet;
}

bool OAIVMwareDetails::is_system_load_Valid() const{
    return m_system_load_isValid;
}

QString OAIVMwareDetails::getSystemLoadStatus() const {
    return m_system_load_status;
}
void OAIVMwareDetails::setSystemLoadStatus(const QString &system_load_status) {
    m_system_load_status = system_load_status;
    m_system_load_status_isSet = true;
}

bool OAIVMwareDetails::is_system_load_status_Set() const{
    return m_system_load_status_isSet;
}

bool OAIVMwareDetails::is_system_load_status_Valid() const{
    return m_system_load_status_isValid;
}

qint64 OAIVMwareDetails::getTotalMemoryInBytes() const {
    return m_total_memory_in_bytes;
}
void OAIVMwareDetails::setTotalMemoryInBytes(const qint64 &total_memory_in_bytes) {
    m_total_memory_in_bytes = total_memory_in_bytes;
    m_total_memory_in_bytes_isSet = true;
}

bool OAIVMwareDetails::is_total_memory_in_bytes_Set() const{
    return m_total_memory_in_bytes_isSet;
}

bool OAIVMwareDetails::is_total_memory_in_bytes_Valid() const{
    return m_total_memory_in_bytes_isValid;
}

qint64 OAIVMwareDetails::getTotalSpaceInBytes() const {
    return m_total_space_in_bytes;
}
void OAIVMwareDetails::setTotalSpaceInBytes(const qint64 &total_space_in_bytes) {
    m_total_space_in_bytes = total_space_in_bytes;
    m_total_space_in_bytes_isSet = true;
}

bool OAIVMwareDetails::is_total_space_in_bytes_Set() const{
    return m_total_space_in_bytes_isSet;
}

bool OAIVMwareDetails::is_total_space_in_bytes_Valid() const{
    return m_total_space_in_bytes_isValid;
}

QString OAIVMwareDetails::getVersionStatus() const {
    return m_version_status;
}
void OAIVMwareDetails::setVersionStatus(const QString &version_status) {
    m_version_status = version_status;
    m_version_status_isSet = true;
}

bool OAIVMwareDetails::is_version_status_Set() const{
    return m_version_status_isSet;
}

bool OAIVMwareDetails::is_version_status_Valid() const{
    return m_version_status_isValid;
}

QString OAIVMwareDetails::getWebLoad() const {
    return m_web_load;
}
void OAIVMwareDetails::setWebLoad(const QString &web_load) {
    m_web_load = web_load;
    m_web_load_isSet = true;
}

bool OAIVMwareDetails::is_web_load_Set() const{
    return m_web_load_isSet;
}

bool OAIVMwareDetails::is_web_load_Valid() const{
    return m_web_load_isValid;
}

QString OAIVMwareDetails::getWebLoadStatus() const {
    return m_web_load_status;
}
void OAIVMwareDetails::setWebLoadStatus(const QString &web_load_status) {
    m_web_load_status = web_load_status;
    m_web_load_status_isSet = true;
}

bool OAIVMwareDetails::is_web_load_status_Set() const{
    return m_web_load_status_isSet;
}

bool OAIVMwareDetails::is_web_load_status_Valid() const{
    return m_web_load_status_isValid;
}

QString OAIVMwareDetails::getInstanceType() const {
    return m_instance_type;
}
void OAIVMwareDetails::setInstanceType(const QString &instance_type) {
    m_instance_type = instance_type;
    m_instance_type_isSet = true;
}

bool OAIVMwareDetails::is_instance_type_Set() const{
    return m_instance_type_isSet;
}

bool OAIVMwareDetails::is_instance_type_Valid() const{
    return m_instance_type_isValid;
}

bool OAIVMwareDetails::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_agent_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_agent_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_available_memory_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_available_space_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpu_load_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cpu_load_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cs_service_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_database_server_load_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_database_server_load_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_host_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_address_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_heartbeat_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_master_target_servers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_memory_usage_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_process_server_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_process_servers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_protected_servers_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ps_template_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_replication_pair_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_run_as_accounts.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_space_usage_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ssl_cert_expiry_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ssl_cert_expiry_remaining_days_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_system_load_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_system_load_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_memory_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_space_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_version_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_web_load_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_web_load_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instance_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVMwareDetails::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
