/**
 * Content Moderator Client
 * You use the API to scan your content as it is generated. Content Moderator then processes your content and sends the results along with relevant information either back to your systems or to the built-in review tool. You can use this information to take decisions e.g. take it down, send to human judge, etc.    When using the API, images need to have a minimum of 128 pixels and a maximum file size of 4MB.   Text can be at most 1024 characters long.   If the content passed to the text API or the image API exceeds the size limits, the API will return an error code that informs about the issue.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIListManagementTermListsApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIListManagementTermListsApi::OAIListManagementTermListsApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIListManagementTermListsApi::~OAIListManagementTermListsApi() {
}

void OAIListManagementTermListsApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://azure.local/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("listManagementTermListsCreate", defaultConf);
    _serverIndices.insert("listManagementTermListsCreate", 0);
    _serverConfigs.insert("listManagementTermListsDelete", defaultConf);
    _serverIndices.insert("listManagementTermListsDelete", 0);
    _serverConfigs.insert("listManagementTermListsGetAllTermLists", defaultConf);
    _serverIndices.insert("listManagementTermListsGetAllTermLists", 0);
    _serverConfigs.insert("listManagementTermListsGetDetails", defaultConf);
    _serverIndices.insert("listManagementTermListsGetDetails", 0);
    _serverConfigs.insert("listManagementTermListsRefreshIndex", defaultConf);
    _serverIndices.insert("listManagementTermListsRefreshIndex", 0);
    _serverConfigs.insert("listManagementTermListsUpdate", defaultConf);
    _serverIndices.insert("listManagementTermListsUpdate", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIListManagementTermListsApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIListManagementTermListsApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIListManagementTermListsApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIListManagementTermListsApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIListManagementTermListsApi::setUsername(const QString &username) {
    _username = username;
}

void OAIListManagementTermListsApi::setPassword(const QString &password) {
    _password = password;
}


void OAIListManagementTermListsApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIListManagementTermListsApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIListManagementTermListsApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIListManagementTermListsApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIListManagementTermListsApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIListManagementTermListsApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIListManagementTermListsApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIListManagementTermListsApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIListManagementTermListsApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIListManagementTermListsApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIListManagementTermListsApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIListManagementTermListsApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIListManagementTermListsApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIListManagementTermListsApi::listManagementTermListsCreate(const QString &content_type, const OAIListManagementImageLists_Create_request &body) {
    QString fullPath = QString(_serverConfigs["listManagementTermListsCreate"][_serverIndices.value("listManagementTermListsCreate")].URL()+"/contentmoderator/lists/v1.0/termlists");
    
    if (_apiKeys.contains("apim_key")) {
        addHeaders("apim_key",_apiKeys.find("apim_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIListManagementTermListsApi::listManagementTermListsCreateCallback);
    connect(this, &OAIListManagementTermListsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIListManagementTermListsApi::listManagementTermListsCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITermList output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listManagementTermListsCreateSignal(output);
        Q_EMIT listManagementTermListsCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listManagementTermListsCreateSignalE(output, error_type, error_str);
        Q_EMIT listManagementTermListsCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listManagementTermListsCreateSignalError(output, error_type, error_str);
        Q_EMIT listManagementTermListsCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIListManagementTermListsApi::listManagementTermListsDelete(const QString &list_id) {
    QString fullPath = QString(_serverConfigs["listManagementTermListsDelete"][_serverIndices.value("listManagementTermListsDelete")].URL()+"/contentmoderator/lists/v1.0/termlists/{listId}");
    
    if (_apiKeys.contains("apim_key")) {
        addHeaders("apim_key",_apiKeys.find("apim_key").value());
    }
    
    
    {
        QString list_idPathParam("{");
        list_idPathParam.append("listId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "listId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"listId"+pathSuffix : pathPrefix;
        fullPath.replace(list_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(list_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIListManagementTermListsApi::listManagementTermListsDeleteCallback);
    connect(this, &OAIListManagementTermListsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIListManagementTermListsApi::listManagementTermListsDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listManagementTermListsDeleteSignal(output);
        Q_EMIT listManagementTermListsDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listManagementTermListsDeleteSignalE(output, error_type, error_str);
        Q_EMIT listManagementTermListsDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listManagementTermListsDeleteSignalError(output, error_type, error_str);
        Q_EMIT listManagementTermListsDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIListManagementTermListsApi::listManagementTermListsGetAllTermLists() {
    QString fullPath = QString(_serverConfigs["listManagementTermListsGetAllTermLists"][_serverIndices.value("listManagementTermListsGetAllTermLists")].URL()+"/contentmoderator/lists/v1.0/termlists");
    
    if (_apiKeys.contains("apim_key")) {
        addHeaders("apim_key",_apiKeys.find("apim_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIListManagementTermListsApi::listManagementTermListsGetAllTermListsCallback);
    connect(this, &OAIListManagementTermListsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIListManagementTermListsApi::listManagementTermListsGetAllTermListsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAITermList> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAITermList val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listManagementTermListsGetAllTermListsSignal(output);
        Q_EMIT listManagementTermListsGetAllTermListsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listManagementTermListsGetAllTermListsSignalE(output, error_type, error_str);
        Q_EMIT listManagementTermListsGetAllTermListsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listManagementTermListsGetAllTermListsSignalError(output, error_type, error_str);
        Q_EMIT listManagementTermListsGetAllTermListsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIListManagementTermListsApi::listManagementTermListsGetDetails(const QString &list_id) {
    QString fullPath = QString(_serverConfigs["listManagementTermListsGetDetails"][_serverIndices.value("listManagementTermListsGetDetails")].URL()+"/contentmoderator/lists/v1.0/termlists/{listId}");
    
    if (_apiKeys.contains("apim_key")) {
        addHeaders("apim_key",_apiKeys.find("apim_key").value());
    }
    
    
    {
        QString list_idPathParam("{");
        list_idPathParam.append("listId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "listId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"listId"+pathSuffix : pathPrefix;
        fullPath.replace(list_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(list_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIListManagementTermListsApi::listManagementTermListsGetDetailsCallback);
    connect(this, &OAIListManagementTermListsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIListManagementTermListsApi::listManagementTermListsGetDetailsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITermList output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listManagementTermListsGetDetailsSignal(output);
        Q_EMIT listManagementTermListsGetDetailsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listManagementTermListsGetDetailsSignalE(output, error_type, error_str);
        Q_EMIT listManagementTermListsGetDetailsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listManagementTermListsGetDetailsSignalError(output, error_type, error_str);
        Q_EMIT listManagementTermListsGetDetailsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIListManagementTermListsApi::listManagementTermListsRefreshIndex(const QString &list_id, const QString &language) {
    QString fullPath = QString(_serverConfigs["listManagementTermListsRefreshIndex"][_serverIndices.value("listManagementTermListsRefreshIndex")].URL()+"/contentmoderator/lists/v1.0/termlists/{listId}/RefreshIndex");
    
    if (_apiKeys.contains("apim_key")) {
        addHeaders("apim_key",_apiKeys.find("apim_key").value());
    }
    
    
    {
        QString list_idPathParam("{");
        list_idPathParam.append("listId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "listId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"listId"+pathSuffix : pathPrefix;
        fullPath.replace(list_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(list_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "language", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("language")).append(querySuffix).append(QUrl::toPercentEncoding(language));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIListManagementTermListsApi::listManagementTermListsRefreshIndexCallback);
    connect(this, &OAIListManagementTermListsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIListManagementTermListsApi::listManagementTermListsRefreshIndexCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRefreshIndex output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listManagementTermListsRefreshIndexSignal(output);
        Q_EMIT listManagementTermListsRefreshIndexSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listManagementTermListsRefreshIndexSignalE(output, error_type, error_str);
        Q_EMIT listManagementTermListsRefreshIndexSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listManagementTermListsRefreshIndexSignalError(output, error_type, error_str);
        Q_EMIT listManagementTermListsRefreshIndexSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIListManagementTermListsApi::listManagementTermListsUpdate(const QString &list_id, const QString &content_type, const OAIListManagementImageLists_Create_request &body) {
    QString fullPath = QString(_serverConfigs["listManagementTermListsUpdate"][_serverIndices.value("listManagementTermListsUpdate")].URL()+"/contentmoderator/lists/v1.0/termlists/{listId}");
    
    if (_apiKeys.contains("apim_key")) {
        addHeaders("apim_key",_apiKeys.find("apim_key").value());
    }
    
    
    {
        QString list_idPathParam("{");
        list_idPathParam.append("listId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "listId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"listId"+pathSuffix : pathPrefix;
        fullPath.replace(list_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(list_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIListManagementTermListsApi::listManagementTermListsUpdateCallback);
    connect(this, &OAIListManagementTermListsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIListManagementTermListsApi::listManagementTermListsUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITermList output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listManagementTermListsUpdateSignal(output);
        Q_EMIT listManagementTermListsUpdateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listManagementTermListsUpdateSignalE(output, error_type, error_str);
        Q_EMIT listManagementTermListsUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listManagementTermListsUpdateSignalError(output, error_type, error_str);
        Q_EMIT listManagementTermListsUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIListManagementTermListsApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
