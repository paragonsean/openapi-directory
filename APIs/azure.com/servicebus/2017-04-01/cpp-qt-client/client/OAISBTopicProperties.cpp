/**
 * ServiceBusManagementClient
 * Azure Service Bus client
 *
 * The version of the OpenAPI document: 2017-04-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAISBTopicProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAISBTopicProperties::OAISBTopicProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAISBTopicProperties::OAISBTopicProperties() {
    this->initializeModel();
}

OAISBTopicProperties::~OAISBTopicProperties() {}

void OAISBTopicProperties::initializeModel() {

    m_accessed_at_isSet = false;
    m_accessed_at_isValid = false;

    m_auto_delete_on_idle_isSet = false;
    m_auto_delete_on_idle_isValid = false;

    m_count_details_isSet = false;
    m_count_details_isValid = false;

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_default_message_time_to_live_isSet = false;
    m_default_message_time_to_live_isValid = false;

    m_duplicate_detection_history_time_window_isSet = false;
    m_duplicate_detection_history_time_window_isValid = false;

    m_enable_batched_operations_isSet = false;
    m_enable_batched_operations_isValid = false;

    m_enable_express_isSet = false;
    m_enable_express_isValid = false;

    m_enable_partitioning_isSet = false;
    m_enable_partitioning_isValid = false;

    m_max_size_in_megabytes_isSet = false;
    m_max_size_in_megabytes_isValid = false;

    m_requires_duplicate_detection_isSet = false;
    m_requires_duplicate_detection_isValid = false;

    m_size_in_bytes_isSet = false;
    m_size_in_bytes_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_subscription_count_isSet = false;
    m_subscription_count_isValid = false;

    m_support_ordering_isSet = false;
    m_support_ordering_isValid = false;

    m_updated_at_isSet = false;
    m_updated_at_isValid = false;
}

void OAISBTopicProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAISBTopicProperties::fromJsonObject(QJsonObject json) {

    m_accessed_at_isValid = ::OpenAPI::fromJsonValue(m_accessed_at, json[QString("accessedAt")]);
    m_accessed_at_isSet = !json[QString("accessedAt")].isNull() && m_accessed_at_isValid;

    m_auto_delete_on_idle_isValid = ::OpenAPI::fromJsonValue(m_auto_delete_on_idle, json[QString("autoDeleteOnIdle")]);
    m_auto_delete_on_idle_isSet = !json[QString("autoDeleteOnIdle")].isNull() && m_auto_delete_on_idle_isValid;

    m_count_details_isValid = ::OpenAPI::fromJsonValue(m_count_details, json[QString("countDetails")]);
    m_count_details_isSet = !json[QString("countDetails")].isNull() && m_count_details_isValid;

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("createdAt")]);
    m_created_at_isSet = !json[QString("createdAt")].isNull() && m_created_at_isValid;

    m_default_message_time_to_live_isValid = ::OpenAPI::fromJsonValue(m_default_message_time_to_live, json[QString("defaultMessageTimeToLive")]);
    m_default_message_time_to_live_isSet = !json[QString("defaultMessageTimeToLive")].isNull() && m_default_message_time_to_live_isValid;

    m_duplicate_detection_history_time_window_isValid = ::OpenAPI::fromJsonValue(m_duplicate_detection_history_time_window, json[QString("duplicateDetectionHistoryTimeWindow")]);
    m_duplicate_detection_history_time_window_isSet = !json[QString("duplicateDetectionHistoryTimeWindow")].isNull() && m_duplicate_detection_history_time_window_isValid;

    m_enable_batched_operations_isValid = ::OpenAPI::fromJsonValue(m_enable_batched_operations, json[QString("enableBatchedOperations")]);
    m_enable_batched_operations_isSet = !json[QString("enableBatchedOperations")].isNull() && m_enable_batched_operations_isValid;

    m_enable_express_isValid = ::OpenAPI::fromJsonValue(m_enable_express, json[QString("enableExpress")]);
    m_enable_express_isSet = !json[QString("enableExpress")].isNull() && m_enable_express_isValid;

    m_enable_partitioning_isValid = ::OpenAPI::fromJsonValue(m_enable_partitioning, json[QString("enablePartitioning")]);
    m_enable_partitioning_isSet = !json[QString("enablePartitioning")].isNull() && m_enable_partitioning_isValid;

    m_max_size_in_megabytes_isValid = ::OpenAPI::fromJsonValue(m_max_size_in_megabytes, json[QString("maxSizeInMegabytes")]);
    m_max_size_in_megabytes_isSet = !json[QString("maxSizeInMegabytes")].isNull() && m_max_size_in_megabytes_isValid;

    m_requires_duplicate_detection_isValid = ::OpenAPI::fromJsonValue(m_requires_duplicate_detection, json[QString("requiresDuplicateDetection")]);
    m_requires_duplicate_detection_isSet = !json[QString("requiresDuplicateDetection")].isNull() && m_requires_duplicate_detection_isValid;

    m_size_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_size_in_bytes, json[QString("sizeInBytes")]);
    m_size_in_bytes_isSet = !json[QString("sizeInBytes")].isNull() && m_size_in_bytes_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_subscription_count_isValid = ::OpenAPI::fromJsonValue(m_subscription_count, json[QString("subscriptionCount")]);
    m_subscription_count_isSet = !json[QString("subscriptionCount")].isNull() && m_subscription_count_isValid;

    m_support_ordering_isValid = ::OpenAPI::fromJsonValue(m_support_ordering, json[QString("supportOrdering")]);
    m_support_ordering_isSet = !json[QString("supportOrdering")].isNull() && m_support_ordering_isValid;

    m_updated_at_isValid = ::OpenAPI::fromJsonValue(m_updated_at, json[QString("updatedAt")]);
    m_updated_at_isSet = !json[QString("updatedAt")].isNull() && m_updated_at_isValid;
}

QString OAISBTopicProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAISBTopicProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_accessed_at_isSet) {
        obj.insert(QString("accessedAt"), ::OpenAPI::toJsonValue(m_accessed_at));
    }
    if (m_auto_delete_on_idle_isSet) {
        obj.insert(QString("autoDeleteOnIdle"), ::OpenAPI::toJsonValue(m_auto_delete_on_idle));
    }
    if (m_count_details.isSet()) {
        obj.insert(QString("countDetails"), ::OpenAPI::toJsonValue(m_count_details));
    }
    if (m_created_at_isSet) {
        obj.insert(QString("createdAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_default_message_time_to_live_isSet) {
        obj.insert(QString("defaultMessageTimeToLive"), ::OpenAPI::toJsonValue(m_default_message_time_to_live));
    }
    if (m_duplicate_detection_history_time_window_isSet) {
        obj.insert(QString("duplicateDetectionHistoryTimeWindow"), ::OpenAPI::toJsonValue(m_duplicate_detection_history_time_window));
    }
    if (m_enable_batched_operations_isSet) {
        obj.insert(QString("enableBatchedOperations"), ::OpenAPI::toJsonValue(m_enable_batched_operations));
    }
    if (m_enable_express_isSet) {
        obj.insert(QString("enableExpress"), ::OpenAPI::toJsonValue(m_enable_express));
    }
    if (m_enable_partitioning_isSet) {
        obj.insert(QString("enablePartitioning"), ::OpenAPI::toJsonValue(m_enable_partitioning));
    }
    if (m_max_size_in_megabytes_isSet) {
        obj.insert(QString("maxSizeInMegabytes"), ::OpenAPI::toJsonValue(m_max_size_in_megabytes));
    }
    if (m_requires_duplicate_detection_isSet) {
        obj.insert(QString("requiresDuplicateDetection"), ::OpenAPI::toJsonValue(m_requires_duplicate_detection));
    }
    if (m_size_in_bytes_isSet) {
        obj.insert(QString("sizeInBytes"), ::OpenAPI::toJsonValue(m_size_in_bytes));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_subscription_count_isSet) {
        obj.insert(QString("subscriptionCount"), ::OpenAPI::toJsonValue(m_subscription_count));
    }
    if (m_support_ordering_isSet) {
        obj.insert(QString("supportOrdering"), ::OpenAPI::toJsonValue(m_support_ordering));
    }
    if (m_updated_at_isSet) {
        obj.insert(QString("updatedAt"), ::OpenAPI::toJsonValue(m_updated_at));
    }
    return obj;
}

QDateTime OAISBTopicProperties::getAccessedAt() const {
    return m_accessed_at;
}
void OAISBTopicProperties::setAccessedAt(const QDateTime &accessed_at) {
    m_accessed_at = accessed_at;
    m_accessed_at_isSet = true;
}

bool OAISBTopicProperties::is_accessed_at_Set() const{
    return m_accessed_at_isSet;
}

bool OAISBTopicProperties::is_accessed_at_Valid() const{
    return m_accessed_at_isValid;
}

QString OAISBTopicProperties::getAutoDeleteOnIdle() const {
    return m_auto_delete_on_idle;
}
void OAISBTopicProperties::setAutoDeleteOnIdle(const QString &auto_delete_on_idle) {
    m_auto_delete_on_idle = auto_delete_on_idle;
    m_auto_delete_on_idle_isSet = true;
}

bool OAISBTopicProperties::is_auto_delete_on_idle_Set() const{
    return m_auto_delete_on_idle_isSet;
}

bool OAISBTopicProperties::is_auto_delete_on_idle_Valid() const{
    return m_auto_delete_on_idle_isValid;
}

OAIMessageCountDetails OAISBTopicProperties::getCountDetails() const {
    return m_count_details;
}
void OAISBTopicProperties::setCountDetails(const OAIMessageCountDetails &count_details) {
    m_count_details = count_details;
    m_count_details_isSet = true;
}

bool OAISBTopicProperties::is_count_details_Set() const{
    return m_count_details_isSet;
}

bool OAISBTopicProperties::is_count_details_Valid() const{
    return m_count_details_isValid;
}

QDateTime OAISBTopicProperties::getCreatedAt() const {
    return m_created_at;
}
void OAISBTopicProperties::setCreatedAt(const QDateTime &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAISBTopicProperties::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAISBTopicProperties::is_created_at_Valid() const{
    return m_created_at_isValid;
}

QString OAISBTopicProperties::getDefaultMessageTimeToLive() const {
    return m_default_message_time_to_live;
}
void OAISBTopicProperties::setDefaultMessageTimeToLive(const QString &default_message_time_to_live) {
    m_default_message_time_to_live = default_message_time_to_live;
    m_default_message_time_to_live_isSet = true;
}

bool OAISBTopicProperties::is_default_message_time_to_live_Set() const{
    return m_default_message_time_to_live_isSet;
}

bool OAISBTopicProperties::is_default_message_time_to_live_Valid() const{
    return m_default_message_time_to_live_isValid;
}

QString OAISBTopicProperties::getDuplicateDetectionHistoryTimeWindow() const {
    return m_duplicate_detection_history_time_window;
}
void OAISBTopicProperties::setDuplicateDetectionHistoryTimeWindow(const QString &duplicate_detection_history_time_window) {
    m_duplicate_detection_history_time_window = duplicate_detection_history_time_window;
    m_duplicate_detection_history_time_window_isSet = true;
}

bool OAISBTopicProperties::is_duplicate_detection_history_time_window_Set() const{
    return m_duplicate_detection_history_time_window_isSet;
}

bool OAISBTopicProperties::is_duplicate_detection_history_time_window_Valid() const{
    return m_duplicate_detection_history_time_window_isValid;
}

bool OAISBTopicProperties::isEnableBatchedOperations() const {
    return m_enable_batched_operations;
}
void OAISBTopicProperties::setEnableBatchedOperations(const bool &enable_batched_operations) {
    m_enable_batched_operations = enable_batched_operations;
    m_enable_batched_operations_isSet = true;
}

bool OAISBTopicProperties::is_enable_batched_operations_Set() const{
    return m_enable_batched_operations_isSet;
}

bool OAISBTopicProperties::is_enable_batched_operations_Valid() const{
    return m_enable_batched_operations_isValid;
}

bool OAISBTopicProperties::isEnableExpress() const {
    return m_enable_express;
}
void OAISBTopicProperties::setEnableExpress(const bool &enable_express) {
    m_enable_express = enable_express;
    m_enable_express_isSet = true;
}

bool OAISBTopicProperties::is_enable_express_Set() const{
    return m_enable_express_isSet;
}

bool OAISBTopicProperties::is_enable_express_Valid() const{
    return m_enable_express_isValid;
}

bool OAISBTopicProperties::isEnablePartitioning() const {
    return m_enable_partitioning;
}
void OAISBTopicProperties::setEnablePartitioning(const bool &enable_partitioning) {
    m_enable_partitioning = enable_partitioning;
    m_enable_partitioning_isSet = true;
}

bool OAISBTopicProperties::is_enable_partitioning_Set() const{
    return m_enable_partitioning_isSet;
}

bool OAISBTopicProperties::is_enable_partitioning_Valid() const{
    return m_enable_partitioning_isValid;
}

qint32 OAISBTopicProperties::getMaxSizeInMegabytes() const {
    return m_max_size_in_megabytes;
}
void OAISBTopicProperties::setMaxSizeInMegabytes(const qint32 &max_size_in_megabytes) {
    m_max_size_in_megabytes = max_size_in_megabytes;
    m_max_size_in_megabytes_isSet = true;
}

bool OAISBTopicProperties::is_max_size_in_megabytes_Set() const{
    return m_max_size_in_megabytes_isSet;
}

bool OAISBTopicProperties::is_max_size_in_megabytes_Valid() const{
    return m_max_size_in_megabytes_isValid;
}

bool OAISBTopicProperties::isRequiresDuplicateDetection() const {
    return m_requires_duplicate_detection;
}
void OAISBTopicProperties::setRequiresDuplicateDetection(const bool &requires_duplicate_detection) {
    m_requires_duplicate_detection = requires_duplicate_detection;
    m_requires_duplicate_detection_isSet = true;
}

bool OAISBTopicProperties::is_requires_duplicate_detection_Set() const{
    return m_requires_duplicate_detection_isSet;
}

bool OAISBTopicProperties::is_requires_duplicate_detection_Valid() const{
    return m_requires_duplicate_detection_isValid;
}

qint64 OAISBTopicProperties::getSizeInBytes() const {
    return m_size_in_bytes;
}
void OAISBTopicProperties::setSizeInBytes(const qint64 &size_in_bytes) {
    m_size_in_bytes = size_in_bytes;
    m_size_in_bytes_isSet = true;
}

bool OAISBTopicProperties::is_size_in_bytes_Set() const{
    return m_size_in_bytes_isSet;
}

bool OAISBTopicProperties::is_size_in_bytes_Valid() const{
    return m_size_in_bytes_isValid;
}

OAIEntityStatus OAISBTopicProperties::getStatus() const {
    return m_status;
}
void OAISBTopicProperties::setStatus(const OAIEntityStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAISBTopicProperties::is_status_Set() const{
    return m_status_isSet;
}

bool OAISBTopicProperties::is_status_Valid() const{
    return m_status_isValid;
}

qint32 OAISBTopicProperties::getSubscriptionCount() const {
    return m_subscription_count;
}
void OAISBTopicProperties::setSubscriptionCount(const qint32 &subscription_count) {
    m_subscription_count = subscription_count;
    m_subscription_count_isSet = true;
}

bool OAISBTopicProperties::is_subscription_count_Set() const{
    return m_subscription_count_isSet;
}

bool OAISBTopicProperties::is_subscription_count_Valid() const{
    return m_subscription_count_isValid;
}

bool OAISBTopicProperties::isSupportOrdering() const {
    return m_support_ordering;
}
void OAISBTopicProperties::setSupportOrdering(const bool &support_ordering) {
    m_support_ordering = support_ordering;
    m_support_ordering_isSet = true;
}

bool OAISBTopicProperties::is_support_ordering_Set() const{
    return m_support_ordering_isSet;
}

bool OAISBTopicProperties::is_support_ordering_Valid() const{
    return m_support_ordering_isValid;
}

QDateTime OAISBTopicProperties::getUpdatedAt() const {
    return m_updated_at;
}
void OAISBTopicProperties::setUpdatedAt(const QDateTime &updated_at) {
    m_updated_at = updated_at;
    m_updated_at_isSet = true;
}

bool OAISBTopicProperties::is_updated_at_Set() const{
    return m_updated_at_isSet;
}

bool OAISBTopicProperties::is_updated_at_Valid() const{
    return m_updated_at_isValid;
}

bool OAISBTopicProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accessed_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_delete_on_idle_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_details.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_message_time_to_live_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_duplicate_detection_history_time_window_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_batched_operations_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_express_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_partitioning_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_size_in_megabytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_duplicate_detection_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subscription_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_support_ordering_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_updated_at_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAISBTopicProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
