/**
 * ServiceBusManagementClient
 * Azure Service Bus client
 *
 * The version of the OpenAPI document: 2015-08-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITopicProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITopicProperties::OAITopicProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITopicProperties::OAITopicProperties() {
    this->initializeModel();
}

OAITopicProperties::~OAITopicProperties() {}

void OAITopicProperties::initializeModel() {

    m_accessed_at_isSet = false;
    m_accessed_at_isValid = false;

    m_auto_delete_on_idle_isSet = false;
    m_auto_delete_on_idle_isValid = false;

    m_count_details_isSet = false;
    m_count_details_isValid = false;

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_default_message_time_to_live_isSet = false;
    m_default_message_time_to_live_isValid = false;

    m_duplicate_detection_history_time_window_isSet = false;
    m_duplicate_detection_history_time_window_isValid = false;

    m_enable_batched_operations_isSet = false;
    m_enable_batched_operations_isValid = false;

    m_enable_express_isSet = false;
    m_enable_express_isValid = false;

    m_enable_partitioning_isSet = false;
    m_enable_partitioning_isValid = false;

    m_entity_availability_status_isSet = false;
    m_entity_availability_status_isValid = false;

    m_filtering_messages_before_publishing_isSet = false;
    m_filtering_messages_before_publishing_isValid = false;

    m_is_anonymous_accessible_isSet = false;
    m_is_anonymous_accessible_isValid = false;

    m_is_express_isSet = false;
    m_is_express_isValid = false;

    m_max_size_in_megabytes_isSet = false;
    m_max_size_in_megabytes_isValid = false;

    m_requires_duplicate_detection_isSet = false;
    m_requires_duplicate_detection_isValid = false;

    m_size_in_bytes_isSet = false;
    m_size_in_bytes_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_subscription_count_isSet = false;
    m_subscription_count_isValid = false;

    m_support_ordering_isSet = false;
    m_support_ordering_isValid = false;

    m_updated_at_isSet = false;
    m_updated_at_isValid = false;
}

void OAITopicProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITopicProperties::fromJsonObject(QJsonObject json) {

    m_accessed_at_isValid = ::OpenAPI::fromJsonValue(m_accessed_at, json[QString("accessedAt")]);
    m_accessed_at_isSet = !json[QString("accessedAt")].isNull() && m_accessed_at_isValid;

    m_auto_delete_on_idle_isValid = ::OpenAPI::fromJsonValue(m_auto_delete_on_idle, json[QString("autoDeleteOnIdle")]);
    m_auto_delete_on_idle_isSet = !json[QString("autoDeleteOnIdle")].isNull() && m_auto_delete_on_idle_isValid;

    m_count_details_isValid = ::OpenAPI::fromJsonValue(m_count_details, json[QString("countDetails")]);
    m_count_details_isSet = !json[QString("countDetails")].isNull() && m_count_details_isValid;

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("createdAt")]);
    m_created_at_isSet = !json[QString("createdAt")].isNull() && m_created_at_isValid;

    m_default_message_time_to_live_isValid = ::OpenAPI::fromJsonValue(m_default_message_time_to_live, json[QString("defaultMessageTimeToLive")]);
    m_default_message_time_to_live_isSet = !json[QString("defaultMessageTimeToLive")].isNull() && m_default_message_time_to_live_isValid;

    m_duplicate_detection_history_time_window_isValid = ::OpenAPI::fromJsonValue(m_duplicate_detection_history_time_window, json[QString("duplicateDetectionHistoryTimeWindow")]);
    m_duplicate_detection_history_time_window_isSet = !json[QString("duplicateDetectionHistoryTimeWindow")].isNull() && m_duplicate_detection_history_time_window_isValid;

    m_enable_batched_operations_isValid = ::OpenAPI::fromJsonValue(m_enable_batched_operations, json[QString("enableBatchedOperations")]);
    m_enable_batched_operations_isSet = !json[QString("enableBatchedOperations")].isNull() && m_enable_batched_operations_isValid;

    m_enable_express_isValid = ::OpenAPI::fromJsonValue(m_enable_express, json[QString("enableExpress")]);
    m_enable_express_isSet = !json[QString("enableExpress")].isNull() && m_enable_express_isValid;

    m_enable_partitioning_isValid = ::OpenAPI::fromJsonValue(m_enable_partitioning, json[QString("enablePartitioning")]);
    m_enable_partitioning_isSet = !json[QString("enablePartitioning")].isNull() && m_enable_partitioning_isValid;

    m_entity_availability_status_isValid = ::OpenAPI::fromJsonValue(m_entity_availability_status, json[QString("entityAvailabilityStatus")]);
    m_entity_availability_status_isSet = !json[QString("entityAvailabilityStatus")].isNull() && m_entity_availability_status_isValid;

    m_filtering_messages_before_publishing_isValid = ::OpenAPI::fromJsonValue(m_filtering_messages_before_publishing, json[QString("filteringMessagesBeforePublishing")]);
    m_filtering_messages_before_publishing_isSet = !json[QString("filteringMessagesBeforePublishing")].isNull() && m_filtering_messages_before_publishing_isValid;

    m_is_anonymous_accessible_isValid = ::OpenAPI::fromJsonValue(m_is_anonymous_accessible, json[QString("isAnonymousAccessible")]);
    m_is_anonymous_accessible_isSet = !json[QString("isAnonymousAccessible")].isNull() && m_is_anonymous_accessible_isValid;

    m_is_express_isValid = ::OpenAPI::fromJsonValue(m_is_express, json[QString("isExpress")]);
    m_is_express_isSet = !json[QString("isExpress")].isNull() && m_is_express_isValid;

    m_max_size_in_megabytes_isValid = ::OpenAPI::fromJsonValue(m_max_size_in_megabytes, json[QString("maxSizeInMegabytes")]);
    m_max_size_in_megabytes_isSet = !json[QString("maxSizeInMegabytes")].isNull() && m_max_size_in_megabytes_isValid;

    m_requires_duplicate_detection_isValid = ::OpenAPI::fromJsonValue(m_requires_duplicate_detection, json[QString("requiresDuplicateDetection")]);
    m_requires_duplicate_detection_isSet = !json[QString("requiresDuplicateDetection")].isNull() && m_requires_duplicate_detection_isValid;

    m_size_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_size_in_bytes, json[QString("sizeInBytes")]);
    m_size_in_bytes_isSet = !json[QString("sizeInBytes")].isNull() && m_size_in_bytes_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_subscription_count_isValid = ::OpenAPI::fromJsonValue(m_subscription_count, json[QString("subscriptionCount")]);
    m_subscription_count_isSet = !json[QString("subscriptionCount")].isNull() && m_subscription_count_isValid;

    m_support_ordering_isValid = ::OpenAPI::fromJsonValue(m_support_ordering, json[QString("supportOrdering")]);
    m_support_ordering_isSet = !json[QString("supportOrdering")].isNull() && m_support_ordering_isValid;

    m_updated_at_isValid = ::OpenAPI::fromJsonValue(m_updated_at, json[QString("updatedAt")]);
    m_updated_at_isSet = !json[QString("updatedAt")].isNull() && m_updated_at_isValid;
}

QString OAITopicProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITopicProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_accessed_at_isSet) {
        obj.insert(QString("accessedAt"), ::OpenAPI::toJsonValue(m_accessed_at));
    }
    if (m_auto_delete_on_idle_isSet) {
        obj.insert(QString("autoDeleteOnIdle"), ::OpenAPI::toJsonValue(m_auto_delete_on_idle));
    }
    if (m_count_details.isSet()) {
        obj.insert(QString("countDetails"), ::OpenAPI::toJsonValue(m_count_details));
    }
    if (m_created_at_isSet) {
        obj.insert(QString("createdAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_default_message_time_to_live_isSet) {
        obj.insert(QString("defaultMessageTimeToLive"), ::OpenAPI::toJsonValue(m_default_message_time_to_live));
    }
    if (m_duplicate_detection_history_time_window_isSet) {
        obj.insert(QString("duplicateDetectionHistoryTimeWindow"), ::OpenAPI::toJsonValue(m_duplicate_detection_history_time_window));
    }
    if (m_enable_batched_operations_isSet) {
        obj.insert(QString("enableBatchedOperations"), ::OpenAPI::toJsonValue(m_enable_batched_operations));
    }
    if (m_enable_express_isSet) {
        obj.insert(QString("enableExpress"), ::OpenAPI::toJsonValue(m_enable_express));
    }
    if (m_enable_partitioning_isSet) {
        obj.insert(QString("enablePartitioning"), ::OpenAPI::toJsonValue(m_enable_partitioning));
    }
    if (m_entity_availability_status.isSet()) {
        obj.insert(QString("entityAvailabilityStatus"), ::OpenAPI::toJsonValue(m_entity_availability_status));
    }
    if (m_filtering_messages_before_publishing_isSet) {
        obj.insert(QString("filteringMessagesBeforePublishing"), ::OpenAPI::toJsonValue(m_filtering_messages_before_publishing));
    }
    if (m_is_anonymous_accessible_isSet) {
        obj.insert(QString("isAnonymousAccessible"), ::OpenAPI::toJsonValue(m_is_anonymous_accessible));
    }
    if (m_is_express_isSet) {
        obj.insert(QString("isExpress"), ::OpenAPI::toJsonValue(m_is_express));
    }
    if (m_max_size_in_megabytes_isSet) {
        obj.insert(QString("maxSizeInMegabytes"), ::OpenAPI::toJsonValue(m_max_size_in_megabytes));
    }
    if (m_requires_duplicate_detection_isSet) {
        obj.insert(QString("requiresDuplicateDetection"), ::OpenAPI::toJsonValue(m_requires_duplicate_detection));
    }
    if (m_size_in_bytes_isSet) {
        obj.insert(QString("sizeInBytes"), ::OpenAPI::toJsonValue(m_size_in_bytes));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_subscription_count_isSet) {
        obj.insert(QString("subscriptionCount"), ::OpenAPI::toJsonValue(m_subscription_count));
    }
    if (m_support_ordering_isSet) {
        obj.insert(QString("supportOrdering"), ::OpenAPI::toJsonValue(m_support_ordering));
    }
    if (m_updated_at_isSet) {
        obj.insert(QString("updatedAt"), ::OpenAPI::toJsonValue(m_updated_at));
    }
    return obj;
}

QDateTime OAITopicProperties::getAccessedAt() const {
    return m_accessed_at;
}
void OAITopicProperties::setAccessedAt(const QDateTime &accessed_at) {
    m_accessed_at = accessed_at;
    m_accessed_at_isSet = true;
}

bool OAITopicProperties::is_accessed_at_Set() const{
    return m_accessed_at_isSet;
}

bool OAITopicProperties::is_accessed_at_Valid() const{
    return m_accessed_at_isValid;
}

QString OAITopicProperties::getAutoDeleteOnIdle() const {
    return m_auto_delete_on_idle;
}
void OAITopicProperties::setAutoDeleteOnIdle(const QString &auto_delete_on_idle) {
    m_auto_delete_on_idle = auto_delete_on_idle;
    m_auto_delete_on_idle_isSet = true;
}

bool OAITopicProperties::is_auto_delete_on_idle_Set() const{
    return m_auto_delete_on_idle_isSet;
}

bool OAITopicProperties::is_auto_delete_on_idle_Valid() const{
    return m_auto_delete_on_idle_isValid;
}

OAIMessageCountDetails OAITopicProperties::getCountDetails() const {
    return m_count_details;
}
void OAITopicProperties::setCountDetails(const OAIMessageCountDetails &count_details) {
    m_count_details = count_details;
    m_count_details_isSet = true;
}

bool OAITopicProperties::is_count_details_Set() const{
    return m_count_details_isSet;
}

bool OAITopicProperties::is_count_details_Valid() const{
    return m_count_details_isValid;
}

QDateTime OAITopicProperties::getCreatedAt() const {
    return m_created_at;
}
void OAITopicProperties::setCreatedAt(const QDateTime &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAITopicProperties::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAITopicProperties::is_created_at_Valid() const{
    return m_created_at_isValid;
}

QString OAITopicProperties::getDefaultMessageTimeToLive() const {
    return m_default_message_time_to_live;
}
void OAITopicProperties::setDefaultMessageTimeToLive(const QString &default_message_time_to_live) {
    m_default_message_time_to_live = default_message_time_to_live;
    m_default_message_time_to_live_isSet = true;
}

bool OAITopicProperties::is_default_message_time_to_live_Set() const{
    return m_default_message_time_to_live_isSet;
}

bool OAITopicProperties::is_default_message_time_to_live_Valid() const{
    return m_default_message_time_to_live_isValid;
}

QString OAITopicProperties::getDuplicateDetectionHistoryTimeWindow() const {
    return m_duplicate_detection_history_time_window;
}
void OAITopicProperties::setDuplicateDetectionHistoryTimeWindow(const QString &duplicate_detection_history_time_window) {
    m_duplicate_detection_history_time_window = duplicate_detection_history_time_window;
    m_duplicate_detection_history_time_window_isSet = true;
}

bool OAITopicProperties::is_duplicate_detection_history_time_window_Set() const{
    return m_duplicate_detection_history_time_window_isSet;
}

bool OAITopicProperties::is_duplicate_detection_history_time_window_Valid() const{
    return m_duplicate_detection_history_time_window_isValid;
}

bool OAITopicProperties::isEnableBatchedOperations() const {
    return m_enable_batched_operations;
}
void OAITopicProperties::setEnableBatchedOperations(const bool &enable_batched_operations) {
    m_enable_batched_operations = enable_batched_operations;
    m_enable_batched_operations_isSet = true;
}

bool OAITopicProperties::is_enable_batched_operations_Set() const{
    return m_enable_batched_operations_isSet;
}

bool OAITopicProperties::is_enable_batched_operations_Valid() const{
    return m_enable_batched_operations_isValid;
}

bool OAITopicProperties::isEnableExpress() const {
    return m_enable_express;
}
void OAITopicProperties::setEnableExpress(const bool &enable_express) {
    m_enable_express = enable_express;
    m_enable_express_isSet = true;
}

bool OAITopicProperties::is_enable_express_Set() const{
    return m_enable_express_isSet;
}

bool OAITopicProperties::is_enable_express_Valid() const{
    return m_enable_express_isValid;
}

bool OAITopicProperties::isEnablePartitioning() const {
    return m_enable_partitioning;
}
void OAITopicProperties::setEnablePartitioning(const bool &enable_partitioning) {
    m_enable_partitioning = enable_partitioning;
    m_enable_partitioning_isSet = true;
}

bool OAITopicProperties::is_enable_partitioning_Set() const{
    return m_enable_partitioning_isSet;
}

bool OAITopicProperties::is_enable_partitioning_Valid() const{
    return m_enable_partitioning_isValid;
}

OAIEntityAvailabilityStatus OAITopicProperties::getEntityAvailabilityStatus() const {
    return m_entity_availability_status;
}
void OAITopicProperties::setEntityAvailabilityStatus(const OAIEntityAvailabilityStatus &entity_availability_status) {
    m_entity_availability_status = entity_availability_status;
    m_entity_availability_status_isSet = true;
}

bool OAITopicProperties::is_entity_availability_status_Set() const{
    return m_entity_availability_status_isSet;
}

bool OAITopicProperties::is_entity_availability_status_Valid() const{
    return m_entity_availability_status_isValid;
}

bool OAITopicProperties::isFilteringMessagesBeforePublishing() const {
    return m_filtering_messages_before_publishing;
}
void OAITopicProperties::setFilteringMessagesBeforePublishing(const bool &filtering_messages_before_publishing) {
    m_filtering_messages_before_publishing = filtering_messages_before_publishing;
    m_filtering_messages_before_publishing_isSet = true;
}

bool OAITopicProperties::is_filtering_messages_before_publishing_Set() const{
    return m_filtering_messages_before_publishing_isSet;
}

bool OAITopicProperties::is_filtering_messages_before_publishing_Valid() const{
    return m_filtering_messages_before_publishing_isValid;
}

bool OAITopicProperties::isIsAnonymousAccessible() const {
    return m_is_anonymous_accessible;
}
void OAITopicProperties::setIsAnonymousAccessible(const bool &is_anonymous_accessible) {
    m_is_anonymous_accessible = is_anonymous_accessible;
    m_is_anonymous_accessible_isSet = true;
}

bool OAITopicProperties::is_is_anonymous_accessible_Set() const{
    return m_is_anonymous_accessible_isSet;
}

bool OAITopicProperties::is_is_anonymous_accessible_Valid() const{
    return m_is_anonymous_accessible_isValid;
}

bool OAITopicProperties::isIsExpress() const {
    return m_is_express;
}
void OAITopicProperties::setIsExpress(const bool &is_express) {
    m_is_express = is_express;
    m_is_express_isSet = true;
}

bool OAITopicProperties::is_is_express_Set() const{
    return m_is_express_isSet;
}

bool OAITopicProperties::is_is_express_Valid() const{
    return m_is_express_isValid;
}

qint64 OAITopicProperties::getMaxSizeInMegabytes() const {
    return m_max_size_in_megabytes;
}
void OAITopicProperties::setMaxSizeInMegabytes(const qint64 &max_size_in_megabytes) {
    m_max_size_in_megabytes = max_size_in_megabytes;
    m_max_size_in_megabytes_isSet = true;
}

bool OAITopicProperties::is_max_size_in_megabytes_Set() const{
    return m_max_size_in_megabytes_isSet;
}

bool OAITopicProperties::is_max_size_in_megabytes_Valid() const{
    return m_max_size_in_megabytes_isValid;
}

bool OAITopicProperties::isRequiresDuplicateDetection() const {
    return m_requires_duplicate_detection;
}
void OAITopicProperties::setRequiresDuplicateDetection(const bool &requires_duplicate_detection) {
    m_requires_duplicate_detection = requires_duplicate_detection;
    m_requires_duplicate_detection_isSet = true;
}

bool OAITopicProperties::is_requires_duplicate_detection_Set() const{
    return m_requires_duplicate_detection_isSet;
}

bool OAITopicProperties::is_requires_duplicate_detection_Valid() const{
    return m_requires_duplicate_detection_isValid;
}

qint64 OAITopicProperties::getSizeInBytes() const {
    return m_size_in_bytes;
}
void OAITopicProperties::setSizeInBytes(const qint64 &size_in_bytes) {
    m_size_in_bytes = size_in_bytes;
    m_size_in_bytes_isSet = true;
}

bool OAITopicProperties::is_size_in_bytes_Set() const{
    return m_size_in_bytes_isSet;
}

bool OAITopicProperties::is_size_in_bytes_Valid() const{
    return m_size_in_bytes_isValid;
}

OAIEntityStatus OAITopicProperties::getStatus() const {
    return m_status;
}
void OAITopicProperties::setStatus(const OAIEntityStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAITopicProperties::is_status_Set() const{
    return m_status_isSet;
}

bool OAITopicProperties::is_status_Valid() const{
    return m_status_isValid;
}

qint32 OAITopicProperties::getSubscriptionCount() const {
    return m_subscription_count;
}
void OAITopicProperties::setSubscriptionCount(const qint32 &subscription_count) {
    m_subscription_count = subscription_count;
    m_subscription_count_isSet = true;
}

bool OAITopicProperties::is_subscription_count_Set() const{
    return m_subscription_count_isSet;
}

bool OAITopicProperties::is_subscription_count_Valid() const{
    return m_subscription_count_isValid;
}

bool OAITopicProperties::isSupportOrdering() const {
    return m_support_ordering;
}
void OAITopicProperties::setSupportOrdering(const bool &support_ordering) {
    m_support_ordering = support_ordering;
    m_support_ordering_isSet = true;
}

bool OAITopicProperties::is_support_ordering_Set() const{
    return m_support_ordering_isSet;
}

bool OAITopicProperties::is_support_ordering_Valid() const{
    return m_support_ordering_isValid;
}

QDateTime OAITopicProperties::getUpdatedAt() const {
    return m_updated_at;
}
void OAITopicProperties::setUpdatedAt(const QDateTime &updated_at) {
    m_updated_at = updated_at;
    m_updated_at_isSet = true;
}

bool OAITopicProperties::is_updated_at_Set() const{
    return m_updated_at_isSet;
}

bool OAITopicProperties::is_updated_at_Valid() const{
    return m_updated_at_isValid;
}

bool OAITopicProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accessed_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_delete_on_idle_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_details.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_message_time_to_live_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_duplicate_detection_history_time_window_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_batched_operations_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_express_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_partitioning_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entity_availability_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_filtering_messages_before_publishing_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_anonymous_accessible_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_express_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_size_in_megabytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_duplicate_detection_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_subscription_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_support_ordering_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_updated_at_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITopicProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
