/*
 * ServiceBusManagementClient
 * Azure Service Bus client
 *
 * The version of the OpenAPI document: 2015-08-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.EntityAvailabilityStatus;
import org.openapitools.client.model.EntityStatus;
import org.openapitools.client.model.MessageCountDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The Topic Properties definition.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:12:59.525861-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TopicProperties {
  public static final String SERIALIZED_NAME_ACCESSED_AT = "accessedAt";
  @SerializedName(SERIALIZED_NAME_ACCESSED_AT)
  private OffsetDateTime accessedAt;

  public static final String SERIALIZED_NAME_AUTO_DELETE_ON_IDLE = "autoDeleteOnIdle";
  @SerializedName(SERIALIZED_NAME_AUTO_DELETE_ON_IDLE)
  private String autoDeleteOnIdle;

  public static final String SERIALIZED_NAME_COUNT_DETAILS = "countDetails";
  @SerializedName(SERIALIZED_NAME_COUNT_DETAILS)
  private MessageCountDetails countDetails;

  public static final String SERIALIZED_NAME_CREATED_AT = "createdAt";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DEFAULT_MESSAGE_TIME_TO_LIVE = "defaultMessageTimeToLive";
  @SerializedName(SERIALIZED_NAME_DEFAULT_MESSAGE_TIME_TO_LIVE)
  private String defaultMessageTimeToLive;

  public static final String SERIALIZED_NAME_DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = "duplicateDetectionHistoryTimeWindow";
  @SerializedName(SERIALIZED_NAME_DUPLICATE_DETECTION_HISTORY_TIME_WINDOW)
  private String duplicateDetectionHistoryTimeWindow;

  public static final String SERIALIZED_NAME_ENABLE_BATCHED_OPERATIONS = "enableBatchedOperations";
  @SerializedName(SERIALIZED_NAME_ENABLE_BATCHED_OPERATIONS)
  private Boolean enableBatchedOperations;

  public static final String SERIALIZED_NAME_ENABLE_EXPRESS = "enableExpress";
  @SerializedName(SERIALIZED_NAME_ENABLE_EXPRESS)
  private Boolean enableExpress;

  public static final String SERIALIZED_NAME_ENABLE_PARTITIONING = "enablePartitioning";
  @SerializedName(SERIALIZED_NAME_ENABLE_PARTITIONING)
  private Boolean enablePartitioning;

  public static final String SERIALIZED_NAME_ENTITY_AVAILABILITY_STATUS = "entityAvailabilityStatus";
  @SerializedName(SERIALIZED_NAME_ENTITY_AVAILABILITY_STATUS)
  private EntityAvailabilityStatus entityAvailabilityStatus;

  public static final String SERIALIZED_NAME_FILTERING_MESSAGES_BEFORE_PUBLISHING = "filteringMessagesBeforePublishing";
  @SerializedName(SERIALIZED_NAME_FILTERING_MESSAGES_BEFORE_PUBLISHING)
  private Boolean filteringMessagesBeforePublishing;

  public static final String SERIALIZED_NAME_IS_ANONYMOUS_ACCESSIBLE = "isAnonymousAccessible";
  @SerializedName(SERIALIZED_NAME_IS_ANONYMOUS_ACCESSIBLE)
  private Boolean isAnonymousAccessible;

  public static final String SERIALIZED_NAME_IS_EXPRESS = "isExpress";
  @SerializedName(SERIALIZED_NAME_IS_EXPRESS)
  private Boolean isExpress;

  public static final String SERIALIZED_NAME_MAX_SIZE_IN_MEGABYTES = "maxSizeInMegabytes";
  @SerializedName(SERIALIZED_NAME_MAX_SIZE_IN_MEGABYTES)
  private Long maxSizeInMegabytes;

  public static final String SERIALIZED_NAME_REQUIRES_DUPLICATE_DETECTION = "requiresDuplicateDetection";
  @SerializedName(SERIALIZED_NAME_REQUIRES_DUPLICATE_DETECTION)
  private Boolean requiresDuplicateDetection;

  public static final String SERIALIZED_NAME_SIZE_IN_BYTES = "sizeInBytes";
  @SerializedName(SERIALIZED_NAME_SIZE_IN_BYTES)
  private Long sizeInBytes;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private EntityStatus status;

  public static final String SERIALIZED_NAME_SUBSCRIPTION_COUNT = "subscriptionCount";
  @SerializedName(SERIALIZED_NAME_SUBSCRIPTION_COUNT)
  private Integer subscriptionCount;

  public static final String SERIALIZED_NAME_SUPPORT_ORDERING = "supportOrdering";
  @SerializedName(SERIALIZED_NAME_SUPPORT_ORDERING)
  private Boolean supportOrdering;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updatedAt";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public TopicProperties() {
  }

  public TopicProperties(
     OffsetDateTime accessedAt, 
     OffsetDateTime createdAt, 
     Long sizeInBytes, 
     Integer subscriptionCount, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.accessedAt = accessedAt;
    this.createdAt = createdAt;
    this.sizeInBytes = sizeInBytes;
    this.subscriptionCount = subscriptionCount;
    this.updatedAt = updatedAt;
  }

  /**
   * Last time the message was sent, or a request was received, for this topic.
   * @return accessedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAccessedAt() {
    return accessedAt;
  }



  public TopicProperties autoDeleteOnIdle(String autoDeleteOnIdle) {
    this.autoDeleteOnIdle = autoDeleteOnIdle;
    return this;
  }

  /**
   * TimeSpan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
   * @return autoDeleteOnIdle
   */
  @javax.annotation.Nullable
  public String getAutoDeleteOnIdle() {
    return autoDeleteOnIdle;
  }

  public void setAutoDeleteOnIdle(String autoDeleteOnIdle) {
    this.autoDeleteOnIdle = autoDeleteOnIdle;
  }


  public TopicProperties countDetails(MessageCountDetails countDetails) {
    this.countDetails = countDetails;
    return this;
  }

  /**
   * Get countDetails
   * @return countDetails
   */
  @javax.annotation.Nullable
  public MessageCountDetails getCountDetails() {
    return countDetails;
  }

  public void setCountDetails(MessageCountDetails countDetails) {
    this.countDetails = countDetails;
  }


  /**
   * Exact time the message was created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public TopicProperties defaultMessageTimeToLive(String defaultMessageTimeToLive) {
    this.defaultMessageTimeToLive = defaultMessageTimeToLive;
    return this;
  }

  /**
   * Default message time to live value. This is the duration after which the message expires, starting from when the message is sent to Service Bus. This is the default value used when TimeToLive is not set on a message itself.
   * @return defaultMessageTimeToLive
   */
  @javax.annotation.Nullable
  public String getDefaultMessageTimeToLive() {
    return defaultMessageTimeToLive;
  }

  public void setDefaultMessageTimeToLive(String defaultMessageTimeToLive) {
    this.defaultMessageTimeToLive = defaultMessageTimeToLive;
  }


  public TopicProperties duplicateDetectionHistoryTimeWindow(String duplicateDetectionHistoryTimeWindow) {
    this.duplicateDetectionHistoryTimeWindow = duplicateDetectionHistoryTimeWindow;
    return this;
  }

  /**
   * TimeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
   * @return duplicateDetectionHistoryTimeWindow
   */
  @javax.annotation.Nullable
  public String getDuplicateDetectionHistoryTimeWindow() {
    return duplicateDetectionHistoryTimeWindow;
  }

  public void setDuplicateDetectionHistoryTimeWindow(String duplicateDetectionHistoryTimeWindow) {
    this.duplicateDetectionHistoryTimeWindow = duplicateDetectionHistoryTimeWindow;
  }


  public TopicProperties enableBatchedOperations(Boolean enableBatchedOperations) {
    this.enableBatchedOperations = enableBatchedOperations;
    return this;
  }

  /**
   * Value that indicates whether server-side batched operations are enabled.
   * @return enableBatchedOperations
   */
  @javax.annotation.Nullable
  public Boolean getEnableBatchedOperations() {
    return enableBatchedOperations;
  }

  public void setEnableBatchedOperations(Boolean enableBatchedOperations) {
    this.enableBatchedOperations = enableBatchedOperations;
  }


  public TopicProperties enableExpress(Boolean enableExpress) {
    this.enableExpress = enableExpress;
    return this;
  }

  /**
   * Value that indicates whether Express Entities are enabled. An express topic holds a message in memory temporarily before writing it to persistent storage.
   * @return enableExpress
   */
  @javax.annotation.Nullable
  public Boolean getEnableExpress() {
    return enableExpress;
  }

  public void setEnableExpress(Boolean enableExpress) {
    this.enableExpress = enableExpress;
  }


  public TopicProperties enablePartitioning(Boolean enablePartitioning) {
    this.enablePartitioning = enablePartitioning;
    return this;
  }

  /**
   * Value that indicates whether the topic to be partitioned across multiple message brokers is enabled.
   * @return enablePartitioning
   */
  @javax.annotation.Nullable
  public Boolean getEnablePartitioning() {
    return enablePartitioning;
  }

  public void setEnablePartitioning(Boolean enablePartitioning) {
    this.enablePartitioning = enablePartitioning;
  }


  public TopicProperties entityAvailabilityStatus(EntityAvailabilityStatus entityAvailabilityStatus) {
    this.entityAvailabilityStatus = entityAvailabilityStatus;
    return this;
  }

  /**
   * Get entityAvailabilityStatus
   * @return entityAvailabilityStatus
   */
  @javax.annotation.Nullable
  public EntityAvailabilityStatus getEntityAvailabilityStatus() {
    return entityAvailabilityStatus;
  }

  public void setEntityAvailabilityStatus(EntityAvailabilityStatus entityAvailabilityStatus) {
    this.entityAvailabilityStatus = entityAvailabilityStatus;
  }


  public TopicProperties filteringMessagesBeforePublishing(Boolean filteringMessagesBeforePublishing) {
    this.filteringMessagesBeforePublishing = filteringMessagesBeforePublishing;
    return this;
  }

  /**
   * Whether messages should be filtered before publishing.
   * @return filteringMessagesBeforePublishing
   */
  @javax.annotation.Nullable
  public Boolean getFilteringMessagesBeforePublishing() {
    return filteringMessagesBeforePublishing;
  }

  public void setFilteringMessagesBeforePublishing(Boolean filteringMessagesBeforePublishing) {
    this.filteringMessagesBeforePublishing = filteringMessagesBeforePublishing;
  }


  public TopicProperties isAnonymousAccessible(Boolean isAnonymousAccessible) {
    this.isAnonymousAccessible = isAnonymousAccessible;
    return this;
  }

  /**
   * Value that indicates whether the message is accessible anonymously.
   * @return isAnonymousAccessible
   */
  @javax.annotation.Nullable
  public Boolean getIsAnonymousAccessible() {
    return isAnonymousAccessible;
  }

  public void setIsAnonymousAccessible(Boolean isAnonymousAccessible) {
    this.isAnonymousAccessible = isAnonymousAccessible;
  }


  public TopicProperties isExpress(Boolean isExpress) {
    this.isExpress = isExpress;
    return this;
  }

  /**
   * 
   * @return isExpress
   */
  @javax.annotation.Nullable
  public Boolean getIsExpress() {
    return isExpress;
  }

  public void setIsExpress(Boolean isExpress) {
    this.isExpress = isExpress;
  }


  public TopicProperties maxSizeInMegabytes(Long maxSizeInMegabytes) {
    this.maxSizeInMegabytes = maxSizeInMegabytes;
    return this;
  }

  /**
   * Maximum size of the topic in megabytes, which is the size of the memory allocated for the topic.
   * @return maxSizeInMegabytes
   */
  @javax.annotation.Nullable
  public Long getMaxSizeInMegabytes() {
    return maxSizeInMegabytes;
  }

  public void setMaxSizeInMegabytes(Long maxSizeInMegabytes) {
    this.maxSizeInMegabytes = maxSizeInMegabytes;
  }


  public TopicProperties requiresDuplicateDetection(Boolean requiresDuplicateDetection) {
    this.requiresDuplicateDetection = requiresDuplicateDetection;
    return this;
  }

  /**
   * Value indicating if this topic requires duplicate detection.
   * @return requiresDuplicateDetection
   */
  @javax.annotation.Nullable
  public Boolean getRequiresDuplicateDetection() {
    return requiresDuplicateDetection;
  }

  public void setRequiresDuplicateDetection(Boolean requiresDuplicateDetection) {
    this.requiresDuplicateDetection = requiresDuplicateDetection;
  }


  /**
   * Size of the topic, in bytes.
   * @return sizeInBytes
   */
  @javax.annotation.Nullable
  public Long getSizeInBytes() {
    return sizeInBytes;
  }



  public TopicProperties status(EntityStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public EntityStatus getStatus() {
    return status;
  }

  public void setStatus(EntityStatus status) {
    this.status = status;
  }


  /**
   * Number of subscriptions.
   * @return subscriptionCount
   */
  @javax.annotation.Nullable
  public Integer getSubscriptionCount() {
    return subscriptionCount;
  }



  public TopicProperties supportOrdering(Boolean supportOrdering) {
    this.supportOrdering = supportOrdering;
    return this;
  }

  /**
   * Value that indicates whether the topic supports ordering.
   * @return supportOrdering
   */
  @javax.annotation.Nullable
  public Boolean getSupportOrdering() {
    return supportOrdering;
  }

  public void setSupportOrdering(Boolean supportOrdering) {
    this.supportOrdering = supportOrdering;
  }


  /**
   * The exact time the message was updated.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TopicProperties topicProperties = (TopicProperties) o;
    return Objects.equals(this.accessedAt, topicProperties.accessedAt) &&
        Objects.equals(this.autoDeleteOnIdle, topicProperties.autoDeleteOnIdle) &&
        Objects.equals(this.countDetails, topicProperties.countDetails) &&
        Objects.equals(this.createdAt, topicProperties.createdAt) &&
        Objects.equals(this.defaultMessageTimeToLive, topicProperties.defaultMessageTimeToLive) &&
        Objects.equals(this.duplicateDetectionHistoryTimeWindow, topicProperties.duplicateDetectionHistoryTimeWindow) &&
        Objects.equals(this.enableBatchedOperations, topicProperties.enableBatchedOperations) &&
        Objects.equals(this.enableExpress, topicProperties.enableExpress) &&
        Objects.equals(this.enablePartitioning, topicProperties.enablePartitioning) &&
        Objects.equals(this.entityAvailabilityStatus, topicProperties.entityAvailabilityStatus) &&
        Objects.equals(this.filteringMessagesBeforePublishing, topicProperties.filteringMessagesBeforePublishing) &&
        Objects.equals(this.isAnonymousAccessible, topicProperties.isAnonymousAccessible) &&
        Objects.equals(this.isExpress, topicProperties.isExpress) &&
        Objects.equals(this.maxSizeInMegabytes, topicProperties.maxSizeInMegabytes) &&
        Objects.equals(this.requiresDuplicateDetection, topicProperties.requiresDuplicateDetection) &&
        Objects.equals(this.sizeInBytes, topicProperties.sizeInBytes) &&
        Objects.equals(this.status, topicProperties.status) &&
        Objects.equals(this.subscriptionCount, topicProperties.subscriptionCount) &&
        Objects.equals(this.supportOrdering, topicProperties.supportOrdering) &&
        Objects.equals(this.updatedAt, topicProperties.updatedAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessedAt, autoDeleteOnIdle, countDetails, createdAt, defaultMessageTimeToLive, duplicateDetectionHistoryTimeWindow, enableBatchedOperations, enableExpress, enablePartitioning, entityAvailabilityStatus, filteringMessagesBeforePublishing, isAnonymousAccessible, isExpress, maxSizeInMegabytes, requiresDuplicateDetection, sizeInBytes, status, subscriptionCount, supportOrdering, updatedAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TopicProperties {\n");
    sb.append("    accessedAt: ").append(toIndentedString(accessedAt)).append("\n");
    sb.append("    autoDeleteOnIdle: ").append(toIndentedString(autoDeleteOnIdle)).append("\n");
    sb.append("    countDetails: ").append(toIndentedString(countDetails)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    defaultMessageTimeToLive: ").append(toIndentedString(defaultMessageTimeToLive)).append("\n");
    sb.append("    duplicateDetectionHistoryTimeWindow: ").append(toIndentedString(duplicateDetectionHistoryTimeWindow)).append("\n");
    sb.append("    enableBatchedOperations: ").append(toIndentedString(enableBatchedOperations)).append("\n");
    sb.append("    enableExpress: ").append(toIndentedString(enableExpress)).append("\n");
    sb.append("    enablePartitioning: ").append(toIndentedString(enablePartitioning)).append("\n");
    sb.append("    entityAvailabilityStatus: ").append(toIndentedString(entityAvailabilityStatus)).append("\n");
    sb.append("    filteringMessagesBeforePublishing: ").append(toIndentedString(filteringMessagesBeforePublishing)).append("\n");
    sb.append("    isAnonymousAccessible: ").append(toIndentedString(isAnonymousAccessible)).append("\n");
    sb.append("    isExpress: ").append(toIndentedString(isExpress)).append("\n");
    sb.append("    maxSizeInMegabytes: ").append(toIndentedString(maxSizeInMegabytes)).append("\n");
    sb.append("    requiresDuplicateDetection: ").append(toIndentedString(requiresDuplicateDetection)).append("\n");
    sb.append("    sizeInBytes: ").append(toIndentedString(sizeInBytes)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    subscriptionCount: ").append(toIndentedString(subscriptionCount)).append("\n");
    sb.append("    supportOrdering: ").append(toIndentedString(supportOrdering)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessedAt");
    openapiFields.add("autoDeleteOnIdle");
    openapiFields.add("countDetails");
    openapiFields.add("createdAt");
    openapiFields.add("defaultMessageTimeToLive");
    openapiFields.add("duplicateDetectionHistoryTimeWindow");
    openapiFields.add("enableBatchedOperations");
    openapiFields.add("enableExpress");
    openapiFields.add("enablePartitioning");
    openapiFields.add("entityAvailabilityStatus");
    openapiFields.add("filteringMessagesBeforePublishing");
    openapiFields.add("isAnonymousAccessible");
    openapiFields.add("isExpress");
    openapiFields.add("maxSizeInMegabytes");
    openapiFields.add("requiresDuplicateDetection");
    openapiFields.add("sizeInBytes");
    openapiFields.add("status");
    openapiFields.add("subscriptionCount");
    openapiFields.add("supportOrdering");
    openapiFields.add("updatedAt");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TopicProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TopicProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TopicProperties is not found in the empty JSON string", TopicProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TopicProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TopicProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("autoDeleteOnIdle") != null && !jsonObj.get("autoDeleteOnIdle").isJsonNull()) && !jsonObj.get("autoDeleteOnIdle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoDeleteOnIdle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoDeleteOnIdle").toString()));
      }
      // validate the optional field `countDetails`
      if (jsonObj.get("countDetails") != null && !jsonObj.get("countDetails").isJsonNull()) {
        MessageCountDetails.validateJsonElement(jsonObj.get("countDetails"));
      }
      if ((jsonObj.get("defaultMessageTimeToLive") != null && !jsonObj.get("defaultMessageTimeToLive").isJsonNull()) && !jsonObj.get("defaultMessageTimeToLive").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultMessageTimeToLive` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultMessageTimeToLive").toString()));
      }
      if ((jsonObj.get("duplicateDetectionHistoryTimeWindow") != null && !jsonObj.get("duplicateDetectionHistoryTimeWindow").isJsonNull()) && !jsonObj.get("duplicateDetectionHistoryTimeWindow").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `duplicateDetectionHistoryTimeWindow` to be a primitive type in the JSON string but got `%s`", jsonObj.get("duplicateDetectionHistoryTimeWindow").toString()));
      }
      // validate the optional field `entityAvailabilityStatus`
      if (jsonObj.get("entityAvailabilityStatus") != null && !jsonObj.get("entityAvailabilityStatus").isJsonNull()) {
        EntityAvailabilityStatus.validateJsonElement(jsonObj.get("entityAvailabilityStatus"));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        EntityStatus.validateJsonElement(jsonObj.get("status"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TopicProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TopicProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TopicProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TopicProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<TopicProperties>() {
           @Override
           public void write(JsonWriter out, TopicProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TopicProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TopicProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TopicProperties
   * @throws IOException if the JSON string is invalid with respect to TopicProperties
   */
  public static TopicProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TopicProperties.class);
  }

  /**
   * Convert an instance of TopicProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

