/*
 * ServiceBusManagementClient
 * Azure Service Bus client
 *
 * The version of the OpenAPI document: 2014-09-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.EntityAvailabilityStatus;
import org.openapitools.client.model.EntityStatus;
import org.openapitools.client.model.MessageCountDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Description of Subscription Resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:12:56.106573-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SubscriptionProperties {
  public static final String SERIALIZED_NAME_ACCESSED_AT = "accessedAt";
  @SerializedName(SERIALIZED_NAME_ACCESSED_AT)
  private OffsetDateTime accessedAt;

  public static final String SERIALIZED_NAME_AUTO_DELETE_ON_IDLE = "autoDeleteOnIdle";
  @SerializedName(SERIALIZED_NAME_AUTO_DELETE_ON_IDLE)
  private String autoDeleteOnIdle;

  public static final String SERIALIZED_NAME_COUNT_DETAILS = "countDetails";
  @SerializedName(SERIALIZED_NAME_COUNT_DETAILS)
  private MessageCountDetails countDetails;

  public static final String SERIALIZED_NAME_CREATED_AT = "createdAt";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS = "deadLetteringOnFilterEvaluationExceptions";
  @SerializedName(SERIALIZED_NAME_DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS)
  private Boolean deadLetteringOnFilterEvaluationExceptions;

  public static final String SERIALIZED_NAME_DEAD_LETTERING_ON_MESSAGE_EXPIRATION = "deadLetteringOnMessageExpiration";
  @SerializedName(SERIALIZED_NAME_DEAD_LETTERING_ON_MESSAGE_EXPIRATION)
  private Boolean deadLetteringOnMessageExpiration;

  public static final String SERIALIZED_NAME_DEFAULT_MESSAGE_TIME_TO_LIVE = "defaultMessageTimeToLive";
  @SerializedName(SERIALIZED_NAME_DEFAULT_MESSAGE_TIME_TO_LIVE)
  private String defaultMessageTimeToLive;

  public static final String SERIALIZED_NAME_ENABLE_BATCHED_OPERATIONS = "enableBatchedOperations";
  @SerializedName(SERIALIZED_NAME_ENABLE_BATCHED_OPERATIONS)
  private Boolean enableBatchedOperations;

  public static final String SERIALIZED_NAME_ENTITY_AVAILABILITY_STATUS = "entityAvailabilityStatus";
  @SerializedName(SERIALIZED_NAME_ENTITY_AVAILABILITY_STATUS)
  private EntityAvailabilityStatus entityAvailabilityStatus;

  public static final String SERIALIZED_NAME_IS_READ_ONLY = "isReadOnly";
  @SerializedName(SERIALIZED_NAME_IS_READ_ONLY)
  private Boolean isReadOnly;

  public static final String SERIALIZED_NAME_LOCK_DURATION = "lockDuration";
  @SerializedName(SERIALIZED_NAME_LOCK_DURATION)
  private String lockDuration;

  public static final String SERIALIZED_NAME_MAX_DELIVERY_COUNT = "maxDeliveryCount";
  @SerializedName(SERIALIZED_NAME_MAX_DELIVERY_COUNT)
  private Integer maxDeliveryCount;

  public static final String SERIALIZED_NAME_MESSAGE_COUNT = "messageCount";
  @SerializedName(SERIALIZED_NAME_MESSAGE_COUNT)
  private Long messageCount;

  public static final String SERIALIZED_NAME_REQUIRES_SESSION = "requiresSession";
  @SerializedName(SERIALIZED_NAME_REQUIRES_SESSION)
  private Boolean requiresSession;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private EntityStatus status;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updatedAt";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public SubscriptionProperties() {
  }

  public SubscriptionProperties(
     OffsetDateTime accessedAt, 
     OffsetDateTime createdAt, 
     Long messageCount, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.accessedAt = accessedAt;
    this.createdAt = createdAt;
    this.messageCount = messageCount;
    this.updatedAt = updatedAt;
  }

  /**
   * Last time there was a receive request to this subscription.
   * @return accessedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAccessedAt() {
    return accessedAt;
  }



  public SubscriptionProperties autoDeleteOnIdle(String autoDeleteOnIdle) {
    this.autoDeleteOnIdle = autoDeleteOnIdle;
    return this;
  }

  /**
   * TimeSpan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
   * @return autoDeleteOnIdle
   */
  @javax.annotation.Nullable
  public String getAutoDeleteOnIdle() {
    return autoDeleteOnIdle;
  }

  public void setAutoDeleteOnIdle(String autoDeleteOnIdle) {
    this.autoDeleteOnIdle = autoDeleteOnIdle;
  }


  public SubscriptionProperties countDetails(MessageCountDetails countDetails) {
    this.countDetails = countDetails;
    return this;
  }

  /**
   * Get countDetails
   * @return countDetails
   */
  @javax.annotation.Nullable
  public MessageCountDetails getCountDetails() {
    return countDetails;
  }

  public void setCountDetails(MessageCountDetails countDetails) {
    this.countDetails = countDetails;
  }


  /**
   * Exact time the message was created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public SubscriptionProperties deadLetteringOnFilterEvaluationExceptions(Boolean deadLetteringOnFilterEvaluationExceptions) {
    this.deadLetteringOnFilterEvaluationExceptions = deadLetteringOnFilterEvaluationExceptions;
    return this;
  }

  /**
   * Value that indicates whether a subscription has dead letter support on filter evaluation exceptions.
   * @return deadLetteringOnFilterEvaluationExceptions
   */
  @javax.annotation.Nullable
  public Boolean getDeadLetteringOnFilterEvaluationExceptions() {
    return deadLetteringOnFilterEvaluationExceptions;
  }

  public void setDeadLetteringOnFilterEvaluationExceptions(Boolean deadLetteringOnFilterEvaluationExceptions) {
    this.deadLetteringOnFilterEvaluationExceptions = deadLetteringOnFilterEvaluationExceptions;
  }


  public SubscriptionProperties deadLetteringOnMessageExpiration(Boolean deadLetteringOnMessageExpiration) {
    this.deadLetteringOnMessageExpiration = deadLetteringOnMessageExpiration;
    return this;
  }

  /**
   * Value that indicates whether a subscription has dead letter support when a message expires.
   * @return deadLetteringOnMessageExpiration
   */
  @javax.annotation.Nullable
  public Boolean getDeadLetteringOnMessageExpiration() {
    return deadLetteringOnMessageExpiration;
  }

  public void setDeadLetteringOnMessageExpiration(Boolean deadLetteringOnMessageExpiration) {
    this.deadLetteringOnMessageExpiration = deadLetteringOnMessageExpiration;
  }


  public SubscriptionProperties defaultMessageTimeToLive(String defaultMessageTimeToLive) {
    this.defaultMessageTimeToLive = defaultMessageTimeToLive;
    return this;
  }

  /**
   * Default message time to live value. This is the duration after which the message expires, starting from when the message is sent to Service Bus. This is the default value used when TimeToLive is not set on a message itself.
   * @return defaultMessageTimeToLive
   */
  @javax.annotation.Nullable
  public String getDefaultMessageTimeToLive() {
    return defaultMessageTimeToLive;
  }

  public void setDefaultMessageTimeToLive(String defaultMessageTimeToLive) {
    this.defaultMessageTimeToLive = defaultMessageTimeToLive;
  }


  public SubscriptionProperties enableBatchedOperations(Boolean enableBatchedOperations) {
    this.enableBatchedOperations = enableBatchedOperations;
    return this;
  }

  /**
   * Value that indicates whether server-side batched operations are enabled.
   * @return enableBatchedOperations
   */
  @javax.annotation.Nullable
  public Boolean getEnableBatchedOperations() {
    return enableBatchedOperations;
  }

  public void setEnableBatchedOperations(Boolean enableBatchedOperations) {
    this.enableBatchedOperations = enableBatchedOperations;
  }


  public SubscriptionProperties entityAvailabilityStatus(EntityAvailabilityStatus entityAvailabilityStatus) {
    this.entityAvailabilityStatus = entityAvailabilityStatus;
    return this;
  }

  /**
   * Get entityAvailabilityStatus
   * @return entityAvailabilityStatus
   */
  @javax.annotation.Nullable
  public EntityAvailabilityStatus getEntityAvailabilityStatus() {
    return entityAvailabilityStatus;
  }

  public void setEntityAvailabilityStatus(EntityAvailabilityStatus entityAvailabilityStatus) {
    this.entityAvailabilityStatus = entityAvailabilityStatus;
  }


  public SubscriptionProperties isReadOnly(Boolean isReadOnly) {
    this.isReadOnly = isReadOnly;
    return this;
  }

  /**
   * Value that indicates whether the entity description is read-only.
   * @return isReadOnly
   */
  @javax.annotation.Nullable
  public Boolean getIsReadOnly() {
    return isReadOnly;
  }

  public void setIsReadOnly(Boolean isReadOnly) {
    this.isReadOnly = isReadOnly;
  }


  public SubscriptionProperties lockDuration(String lockDuration) {
    this.lockDuration = lockDuration;
    return this;
  }

  /**
   * The lock duration time span for the subscription.
   * @return lockDuration
   */
  @javax.annotation.Nullable
  public String getLockDuration() {
    return lockDuration;
  }

  public void setLockDuration(String lockDuration) {
    this.lockDuration = lockDuration;
  }


  public SubscriptionProperties maxDeliveryCount(Integer maxDeliveryCount) {
    this.maxDeliveryCount = maxDeliveryCount;
    return this;
  }

  /**
   * Number of maximum deliveries.
   * @return maxDeliveryCount
   */
  @javax.annotation.Nullable
  public Integer getMaxDeliveryCount() {
    return maxDeliveryCount;
  }

  public void setMaxDeliveryCount(Integer maxDeliveryCount) {
    this.maxDeliveryCount = maxDeliveryCount;
  }


  /**
   * Number of messages.
   * @return messageCount
   */
  @javax.annotation.Nullable
  public Long getMessageCount() {
    return messageCount;
  }



  public SubscriptionProperties requiresSession(Boolean requiresSession) {
    this.requiresSession = requiresSession;
    return this;
  }

  /**
   * Value indicating if a subscription supports the concept of sessions.
   * @return requiresSession
   */
  @javax.annotation.Nullable
  public Boolean getRequiresSession() {
    return requiresSession;
  }

  public void setRequiresSession(Boolean requiresSession) {
    this.requiresSession = requiresSession;
  }


  public SubscriptionProperties status(EntityStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public EntityStatus getStatus() {
    return status;
  }

  public void setStatus(EntityStatus status) {
    this.status = status;
  }


  /**
   * The exact time the message was updated.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SubscriptionProperties subscriptionProperties = (SubscriptionProperties) o;
    return Objects.equals(this.accessedAt, subscriptionProperties.accessedAt) &&
        Objects.equals(this.autoDeleteOnIdle, subscriptionProperties.autoDeleteOnIdle) &&
        Objects.equals(this.countDetails, subscriptionProperties.countDetails) &&
        Objects.equals(this.createdAt, subscriptionProperties.createdAt) &&
        Objects.equals(this.deadLetteringOnFilterEvaluationExceptions, subscriptionProperties.deadLetteringOnFilterEvaluationExceptions) &&
        Objects.equals(this.deadLetteringOnMessageExpiration, subscriptionProperties.deadLetteringOnMessageExpiration) &&
        Objects.equals(this.defaultMessageTimeToLive, subscriptionProperties.defaultMessageTimeToLive) &&
        Objects.equals(this.enableBatchedOperations, subscriptionProperties.enableBatchedOperations) &&
        Objects.equals(this.entityAvailabilityStatus, subscriptionProperties.entityAvailabilityStatus) &&
        Objects.equals(this.isReadOnly, subscriptionProperties.isReadOnly) &&
        Objects.equals(this.lockDuration, subscriptionProperties.lockDuration) &&
        Objects.equals(this.maxDeliveryCount, subscriptionProperties.maxDeliveryCount) &&
        Objects.equals(this.messageCount, subscriptionProperties.messageCount) &&
        Objects.equals(this.requiresSession, subscriptionProperties.requiresSession) &&
        Objects.equals(this.status, subscriptionProperties.status) &&
        Objects.equals(this.updatedAt, subscriptionProperties.updatedAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessedAt, autoDeleteOnIdle, countDetails, createdAt, deadLetteringOnFilterEvaluationExceptions, deadLetteringOnMessageExpiration, defaultMessageTimeToLive, enableBatchedOperations, entityAvailabilityStatus, isReadOnly, lockDuration, maxDeliveryCount, messageCount, requiresSession, status, updatedAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SubscriptionProperties {\n");
    sb.append("    accessedAt: ").append(toIndentedString(accessedAt)).append("\n");
    sb.append("    autoDeleteOnIdle: ").append(toIndentedString(autoDeleteOnIdle)).append("\n");
    sb.append("    countDetails: ").append(toIndentedString(countDetails)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    deadLetteringOnFilterEvaluationExceptions: ").append(toIndentedString(deadLetteringOnFilterEvaluationExceptions)).append("\n");
    sb.append("    deadLetteringOnMessageExpiration: ").append(toIndentedString(deadLetteringOnMessageExpiration)).append("\n");
    sb.append("    defaultMessageTimeToLive: ").append(toIndentedString(defaultMessageTimeToLive)).append("\n");
    sb.append("    enableBatchedOperations: ").append(toIndentedString(enableBatchedOperations)).append("\n");
    sb.append("    entityAvailabilityStatus: ").append(toIndentedString(entityAvailabilityStatus)).append("\n");
    sb.append("    isReadOnly: ").append(toIndentedString(isReadOnly)).append("\n");
    sb.append("    lockDuration: ").append(toIndentedString(lockDuration)).append("\n");
    sb.append("    maxDeliveryCount: ").append(toIndentedString(maxDeliveryCount)).append("\n");
    sb.append("    messageCount: ").append(toIndentedString(messageCount)).append("\n");
    sb.append("    requiresSession: ").append(toIndentedString(requiresSession)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessedAt");
    openapiFields.add("autoDeleteOnIdle");
    openapiFields.add("countDetails");
    openapiFields.add("createdAt");
    openapiFields.add("deadLetteringOnFilterEvaluationExceptions");
    openapiFields.add("deadLetteringOnMessageExpiration");
    openapiFields.add("defaultMessageTimeToLive");
    openapiFields.add("enableBatchedOperations");
    openapiFields.add("entityAvailabilityStatus");
    openapiFields.add("isReadOnly");
    openapiFields.add("lockDuration");
    openapiFields.add("maxDeliveryCount");
    openapiFields.add("messageCount");
    openapiFields.add("requiresSession");
    openapiFields.add("status");
    openapiFields.add("updatedAt");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SubscriptionProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SubscriptionProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SubscriptionProperties is not found in the empty JSON string", SubscriptionProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SubscriptionProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SubscriptionProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("autoDeleteOnIdle") != null && !jsonObj.get("autoDeleteOnIdle").isJsonNull()) && !jsonObj.get("autoDeleteOnIdle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoDeleteOnIdle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoDeleteOnIdle").toString()));
      }
      // validate the optional field `countDetails`
      if (jsonObj.get("countDetails") != null && !jsonObj.get("countDetails").isJsonNull()) {
        MessageCountDetails.validateJsonElement(jsonObj.get("countDetails"));
      }
      if ((jsonObj.get("defaultMessageTimeToLive") != null && !jsonObj.get("defaultMessageTimeToLive").isJsonNull()) && !jsonObj.get("defaultMessageTimeToLive").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultMessageTimeToLive` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultMessageTimeToLive").toString()));
      }
      // validate the optional field `entityAvailabilityStatus`
      if (jsonObj.get("entityAvailabilityStatus") != null && !jsonObj.get("entityAvailabilityStatus").isJsonNull()) {
        EntityAvailabilityStatus.validateJsonElement(jsonObj.get("entityAvailabilityStatus"));
      }
      if ((jsonObj.get("lockDuration") != null && !jsonObj.get("lockDuration").isJsonNull()) && !jsonObj.get("lockDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lockDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lockDuration").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        EntityStatus.validateJsonElement(jsonObj.get("status"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SubscriptionProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SubscriptionProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SubscriptionProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SubscriptionProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<SubscriptionProperties>() {
           @Override
           public void write(JsonWriter out, SubscriptionProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SubscriptionProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SubscriptionProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SubscriptionProperties
   * @throws IOException if the JSON string is invalid with respect to SubscriptionProperties
   */
  public static SubscriptionProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SubscriptionProperties.class);
  }

  /**
   * Convert an instance of SubscriptionProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

