/**
 * ServiceBusManagementClient
 * Azure Service Bus client
 *
 * The version of the OpenAPI document: 2014-09-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIQueueProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIQueueProperties::OAIQueueProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIQueueProperties::OAIQueueProperties() {
    this->initializeModel();
}

OAIQueueProperties::~OAIQueueProperties() {}

void OAIQueueProperties::initializeModel() {

    m_accessed_at_isSet = false;
    m_accessed_at_isValid = false;

    m_auto_delete_on_idle_isSet = false;
    m_auto_delete_on_idle_isValid = false;

    m_count_details_isSet = false;
    m_count_details_isValid = false;

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_dead_lettering_on_message_expiration_isSet = false;
    m_dead_lettering_on_message_expiration_isValid = false;

    m_default_message_time_to_live_isSet = false;
    m_default_message_time_to_live_isValid = false;

    m_duplicate_detection_history_time_window_isSet = false;
    m_duplicate_detection_history_time_window_isValid = false;

    m_enable_batched_operations_isSet = false;
    m_enable_batched_operations_isValid = false;

    m_enable_express_isSet = false;
    m_enable_express_isValid = false;

    m_enable_partitioning_isSet = false;
    m_enable_partitioning_isValid = false;

    m_entity_availability_status_isSet = false;
    m_entity_availability_status_isValid = false;

    m_is_anonymous_accessible_isSet = false;
    m_is_anonymous_accessible_isValid = false;

    m_lock_duration_isSet = false;
    m_lock_duration_isValid = false;

    m_max_delivery_count_isSet = false;
    m_max_delivery_count_isValid = false;

    m_max_size_in_megabytes_isSet = false;
    m_max_size_in_megabytes_isValid = false;

    m_message_count_isSet = false;
    m_message_count_isValid = false;

    m_requires_duplicate_detection_isSet = false;
    m_requires_duplicate_detection_isValid = false;

    m_requires_session_isSet = false;
    m_requires_session_isValid = false;

    m_size_in_bytes_isSet = false;
    m_size_in_bytes_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_support_ordering_isSet = false;
    m_support_ordering_isValid = false;

    m_updated_at_isSet = false;
    m_updated_at_isValid = false;
}

void OAIQueueProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIQueueProperties::fromJsonObject(QJsonObject json) {

    m_accessed_at_isValid = ::OpenAPI::fromJsonValue(m_accessed_at, json[QString("accessedAt")]);
    m_accessed_at_isSet = !json[QString("accessedAt")].isNull() && m_accessed_at_isValid;

    m_auto_delete_on_idle_isValid = ::OpenAPI::fromJsonValue(m_auto_delete_on_idle, json[QString("autoDeleteOnIdle")]);
    m_auto_delete_on_idle_isSet = !json[QString("autoDeleteOnIdle")].isNull() && m_auto_delete_on_idle_isValid;

    m_count_details_isValid = ::OpenAPI::fromJsonValue(m_count_details, json[QString("countDetails")]);
    m_count_details_isSet = !json[QString("countDetails")].isNull() && m_count_details_isValid;

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("createdAt")]);
    m_created_at_isSet = !json[QString("createdAt")].isNull() && m_created_at_isValid;

    m_dead_lettering_on_message_expiration_isValid = ::OpenAPI::fromJsonValue(m_dead_lettering_on_message_expiration, json[QString("deadLetteringOnMessageExpiration")]);
    m_dead_lettering_on_message_expiration_isSet = !json[QString("deadLetteringOnMessageExpiration")].isNull() && m_dead_lettering_on_message_expiration_isValid;

    m_default_message_time_to_live_isValid = ::OpenAPI::fromJsonValue(m_default_message_time_to_live, json[QString("defaultMessageTimeToLive")]);
    m_default_message_time_to_live_isSet = !json[QString("defaultMessageTimeToLive")].isNull() && m_default_message_time_to_live_isValid;

    m_duplicate_detection_history_time_window_isValid = ::OpenAPI::fromJsonValue(m_duplicate_detection_history_time_window, json[QString("duplicateDetectionHistoryTimeWindow")]);
    m_duplicate_detection_history_time_window_isSet = !json[QString("duplicateDetectionHistoryTimeWindow")].isNull() && m_duplicate_detection_history_time_window_isValid;

    m_enable_batched_operations_isValid = ::OpenAPI::fromJsonValue(m_enable_batched_operations, json[QString("enableBatchedOperations")]);
    m_enable_batched_operations_isSet = !json[QString("enableBatchedOperations")].isNull() && m_enable_batched_operations_isValid;

    m_enable_express_isValid = ::OpenAPI::fromJsonValue(m_enable_express, json[QString("enableExpress")]);
    m_enable_express_isSet = !json[QString("enableExpress")].isNull() && m_enable_express_isValid;

    m_enable_partitioning_isValid = ::OpenAPI::fromJsonValue(m_enable_partitioning, json[QString("enablePartitioning")]);
    m_enable_partitioning_isSet = !json[QString("enablePartitioning")].isNull() && m_enable_partitioning_isValid;

    m_entity_availability_status_isValid = ::OpenAPI::fromJsonValue(m_entity_availability_status, json[QString("entityAvailabilityStatus")]);
    m_entity_availability_status_isSet = !json[QString("entityAvailabilityStatus")].isNull() && m_entity_availability_status_isValid;

    m_is_anonymous_accessible_isValid = ::OpenAPI::fromJsonValue(m_is_anonymous_accessible, json[QString("isAnonymousAccessible")]);
    m_is_anonymous_accessible_isSet = !json[QString("isAnonymousAccessible")].isNull() && m_is_anonymous_accessible_isValid;

    m_lock_duration_isValid = ::OpenAPI::fromJsonValue(m_lock_duration, json[QString("lockDuration")]);
    m_lock_duration_isSet = !json[QString("lockDuration")].isNull() && m_lock_duration_isValid;

    m_max_delivery_count_isValid = ::OpenAPI::fromJsonValue(m_max_delivery_count, json[QString("maxDeliveryCount")]);
    m_max_delivery_count_isSet = !json[QString("maxDeliveryCount")].isNull() && m_max_delivery_count_isValid;

    m_max_size_in_megabytes_isValid = ::OpenAPI::fromJsonValue(m_max_size_in_megabytes, json[QString("maxSizeInMegabytes")]);
    m_max_size_in_megabytes_isSet = !json[QString("maxSizeInMegabytes")].isNull() && m_max_size_in_megabytes_isValid;

    m_message_count_isValid = ::OpenAPI::fromJsonValue(m_message_count, json[QString("messageCount")]);
    m_message_count_isSet = !json[QString("messageCount")].isNull() && m_message_count_isValid;

    m_requires_duplicate_detection_isValid = ::OpenAPI::fromJsonValue(m_requires_duplicate_detection, json[QString("requiresDuplicateDetection")]);
    m_requires_duplicate_detection_isSet = !json[QString("requiresDuplicateDetection")].isNull() && m_requires_duplicate_detection_isValid;

    m_requires_session_isValid = ::OpenAPI::fromJsonValue(m_requires_session, json[QString("requiresSession")]);
    m_requires_session_isSet = !json[QString("requiresSession")].isNull() && m_requires_session_isValid;

    m_size_in_bytes_isValid = ::OpenAPI::fromJsonValue(m_size_in_bytes, json[QString("sizeInBytes")]);
    m_size_in_bytes_isSet = !json[QString("sizeInBytes")].isNull() && m_size_in_bytes_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_support_ordering_isValid = ::OpenAPI::fromJsonValue(m_support_ordering, json[QString("supportOrdering")]);
    m_support_ordering_isSet = !json[QString("supportOrdering")].isNull() && m_support_ordering_isValid;

    m_updated_at_isValid = ::OpenAPI::fromJsonValue(m_updated_at, json[QString("updatedAt")]);
    m_updated_at_isSet = !json[QString("updatedAt")].isNull() && m_updated_at_isValid;
}

QString OAIQueueProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIQueueProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_accessed_at_isSet) {
        obj.insert(QString("accessedAt"), ::OpenAPI::toJsonValue(m_accessed_at));
    }
    if (m_auto_delete_on_idle_isSet) {
        obj.insert(QString("autoDeleteOnIdle"), ::OpenAPI::toJsonValue(m_auto_delete_on_idle));
    }
    if (m_count_details.isSet()) {
        obj.insert(QString("countDetails"), ::OpenAPI::toJsonValue(m_count_details));
    }
    if (m_created_at_isSet) {
        obj.insert(QString("createdAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_dead_lettering_on_message_expiration_isSet) {
        obj.insert(QString("deadLetteringOnMessageExpiration"), ::OpenAPI::toJsonValue(m_dead_lettering_on_message_expiration));
    }
    if (m_default_message_time_to_live_isSet) {
        obj.insert(QString("defaultMessageTimeToLive"), ::OpenAPI::toJsonValue(m_default_message_time_to_live));
    }
    if (m_duplicate_detection_history_time_window_isSet) {
        obj.insert(QString("duplicateDetectionHistoryTimeWindow"), ::OpenAPI::toJsonValue(m_duplicate_detection_history_time_window));
    }
    if (m_enable_batched_operations_isSet) {
        obj.insert(QString("enableBatchedOperations"), ::OpenAPI::toJsonValue(m_enable_batched_operations));
    }
    if (m_enable_express_isSet) {
        obj.insert(QString("enableExpress"), ::OpenAPI::toJsonValue(m_enable_express));
    }
    if (m_enable_partitioning_isSet) {
        obj.insert(QString("enablePartitioning"), ::OpenAPI::toJsonValue(m_enable_partitioning));
    }
    if (m_entity_availability_status.isSet()) {
        obj.insert(QString("entityAvailabilityStatus"), ::OpenAPI::toJsonValue(m_entity_availability_status));
    }
    if (m_is_anonymous_accessible_isSet) {
        obj.insert(QString("isAnonymousAccessible"), ::OpenAPI::toJsonValue(m_is_anonymous_accessible));
    }
    if (m_lock_duration_isSet) {
        obj.insert(QString("lockDuration"), ::OpenAPI::toJsonValue(m_lock_duration));
    }
    if (m_max_delivery_count_isSet) {
        obj.insert(QString("maxDeliveryCount"), ::OpenAPI::toJsonValue(m_max_delivery_count));
    }
    if (m_max_size_in_megabytes_isSet) {
        obj.insert(QString("maxSizeInMegabytes"), ::OpenAPI::toJsonValue(m_max_size_in_megabytes));
    }
    if (m_message_count_isSet) {
        obj.insert(QString("messageCount"), ::OpenAPI::toJsonValue(m_message_count));
    }
    if (m_requires_duplicate_detection_isSet) {
        obj.insert(QString("requiresDuplicateDetection"), ::OpenAPI::toJsonValue(m_requires_duplicate_detection));
    }
    if (m_requires_session_isSet) {
        obj.insert(QString("requiresSession"), ::OpenAPI::toJsonValue(m_requires_session));
    }
    if (m_size_in_bytes_isSet) {
        obj.insert(QString("sizeInBytes"), ::OpenAPI::toJsonValue(m_size_in_bytes));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_support_ordering_isSet) {
        obj.insert(QString("supportOrdering"), ::OpenAPI::toJsonValue(m_support_ordering));
    }
    if (m_updated_at_isSet) {
        obj.insert(QString("updatedAt"), ::OpenAPI::toJsonValue(m_updated_at));
    }
    return obj;
}

QDateTime OAIQueueProperties::getAccessedAt() const {
    return m_accessed_at;
}
void OAIQueueProperties::setAccessedAt(const QDateTime &accessed_at) {
    m_accessed_at = accessed_at;
    m_accessed_at_isSet = true;
}

bool OAIQueueProperties::is_accessed_at_Set() const{
    return m_accessed_at_isSet;
}

bool OAIQueueProperties::is_accessed_at_Valid() const{
    return m_accessed_at_isValid;
}

QString OAIQueueProperties::getAutoDeleteOnIdle() const {
    return m_auto_delete_on_idle;
}
void OAIQueueProperties::setAutoDeleteOnIdle(const QString &auto_delete_on_idle) {
    m_auto_delete_on_idle = auto_delete_on_idle;
    m_auto_delete_on_idle_isSet = true;
}

bool OAIQueueProperties::is_auto_delete_on_idle_Set() const{
    return m_auto_delete_on_idle_isSet;
}

bool OAIQueueProperties::is_auto_delete_on_idle_Valid() const{
    return m_auto_delete_on_idle_isValid;
}

OAIMessageCountDetails OAIQueueProperties::getCountDetails() const {
    return m_count_details;
}
void OAIQueueProperties::setCountDetails(const OAIMessageCountDetails &count_details) {
    m_count_details = count_details;
    m_count_details_isSet = true;
}

bool OAIQueueProperties::is_count_details_Set() const{
    return m_count_details_isSet;
}

bool OAIQueueProperties::is_count_details_Valid() const{
    return m_count_details_isValid;
}

QDateTime OAIQueueProperties::getCreatedAt() const {
    return m_created_at;
}
void OAIQueueProperties::setCreatedAt(const QDateTime &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAIQueueProperties::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAIQueueProperties::is_created_at_Valid() const{
    return m_created_at_isValid;
}

bool OAIQueueProperties::isDeadLetteringOnMessageExpiration() const {
    return m_dead_lettering_on_message_expiration;
}
void OAIQueueProperties::setDeadLetteringOnMessageExpiration(const bool &dead_lettering_on_message_expiration) {
    m_dead_lettering_on_message_expiration = dead_lettering_on_message_expiration;
    m_dead_lettering_on_message_expiration_isSet = true;
}

bool OAIQueueProperties::is_dead_lettering_on_message_expiration_Set() const{
    return m_dead_lettering_on_message_expiration_isSet;
}

bool OAIQueueProperties::is_dead_lettering_on_message_expiration_Valid() const{
    return m_dead_lettering_on_message_expiration_isValid;
}

QString OAIQueueProperties::getDefaultMessageTimeToLive() const {
    return m_default_message_time_to_live;
}
void OAIQueueProperties::setDefaultMessageTimeToLive(const QString &default_message_time_to_live) {
    m_default_message_time_to_live = default_message_time_to_live;
    m_default_message_time_to_live_isSet = true;
}

bool OAIQueueProperties::is_default_message_time_to_live_Set() const{
    return m_default_message_time_to_live_isSet;
}

bool OAIQueueProperties::is_default_message_time_to_live_Valid() const{
    return m_default_message_time_to_live_isValid;
}

QString OAIQueueProperties::getDuplicateDetectionHistoryTimeWindow() const {
    return m_duplicate_detection_history_time_window;
}
void OAIQueueProperties::setDuplicateDetectionHistoryTimeWindow(const QString &duplicate_detection_history_time_window) {
    m_duplicate_detection_history_time_window = duplicate_detection_history_time_window;
    m_duplicate_detection_history_time_window_isSet = true;
}

bool OAIQueueProperties::is_duplicate_detection_history_time_window_Set() const{
    return m_duplicate_detection_history_time_window_isSet;
}

bool OAIQueueProperties::is_duplicate_detection_history_time_window_Valid() const{
    return m_duplicate_detection_history_time_window_isValid;
}

bool OAIQueueProperties::isEnableBatchedOperations() const {
    return m_enable_batched_operations;
}
void OAIQueueProperties::setEnableBatchedOperations(const bool &enable_batched_operations) {
    m_enable_batched_operations = enable_batched_operations;
    m_enable_batched_operations_isSet = true;
}

bool OAIQueueProperties::is_enable_batched_operations_Set() const{
    return m_enable_batched_operations_isSet;
}

bool OAIQueueProperties::is_enable_batched_operations_Valid() const{
    return m_enable_batched_operations_isValid;
}

bool OAIQueueProperties::isEnableExpress() const {
    return m_enable_express;
}
void OAIQueueProperties::setEnableExpress(const bool &enable_express) {
    m_enable_express = enable_express;
    m_enable_express_isSet = true;
}

bool OAIQueueProperties::is_enable_express_Set() const{
    return m_enable_express_isSet;
}

bool OAIQueueProperties::is_enable_express_Valid() const{
    return m_enable_express_isValid;
}

bool OAIQueueProperties::isEnablePartitioning() const {
    return m_enable_partitioning;
}
void OAIQueueProperties::setEnablePartitioning(const bool &enable_partitioning) {
    m_enable_partitioning = enable_partitioning;
    m_enable_partitioning_isSet = true;
}

bool OAIQueueProperties::is_enable_partitioning_Set() const{
    return m_enable_partitioning_isSet;
}

bool OAIQueueProperties::is_enable_partitioning_Valid() const{
    return m_enable_partitioning_isValid;
}

OAIEntityAvailabilityStatus OAIQueueProperties::getEntityAvailabilityStatus() const {
    return m_entity_availability_status;
}
void OAIQueueProperties::setEntityAvailabilityStatus(const OAIEntityAvailabilityStatus &entity_availability_status) {
    m_entity_availability_status = entity_availability_status;
    m_entity_availability_status_isSet = true;
}

bool OAIQueueProperties::is_entity_availability_status_Set() const{
    return m_entity_availability_status_isSet;
}

bool OAIQueueProperties::is_entity_availability_status_Valid() const{
    return m_entity_availability_status_isValid;
}

bool OAIQueueProperties::isIsAnonymousAccessible() const {
    return m_is_anonymous_accessible;
}
void OAIQueueProperties::setIsAnonymousAccessible(const bool &is_anonymous_accessible) {
    m_is_anonymous_accessible = is_anonymous_accessible;
    m_is_anonymous_accessible_isSet = true;
}

bool OAIQueueProperties::is_is_anonymous_accessible_Set() const{
    return m_is_anonymous_accessible_isSet;
}

bool OAIQueueProperties::is_is_anonymous_accessible_Valid() const{
    return m_is_anonymous_accessible_isValid;
}

QString OAIQueueProperties::getLockDuration() const {
    return m_lock_duration;
}
void OAIQueueProperties::setLockDuration(const QString &lock_duration) {
    m_lock_duration = lock_duration;
    m_lock_duration_isSet = true;
}

bool OAIQueueProperties::is_lock_duration_Set() const{
    return m_lock_duration_isSet;
}

bool OAIQueueProperties::is_lock_duration_Valid() const{
    return m_lock_duration_isValid;
}

qint32 OAIQueueProperties::getMaxDeliveryCount() const {
    return m_max_delivery_count;
}
void OAIQueueProperties::setMaxDeliveryCount(const qint32 &max_delivery_count) {
    m_max_delivery_count = max_delivery_count;
    m_max_delivery_count_isSet = true;
}

bool OAIQueueProperties::is_max_delivery_count_Set() const{
    return m_max_delivery_count_isSet;
}

bool OAIQueueProperties::is_max_delivery_count_Valid() const{
    return m_max_delivery_count_isValid;
}

qint64 OAIQueueProperties::getMaxSizeInMegabytes() const {
    return m_max_size_in_megabytes;
}
void OAIQueueProperties::setMaxSizeInMegabytes(const qint64 &max_size_in_megabytes) {
    m_max_size_in_megabytes = max_size_in_megabytes;
    m_max_size_in_megabytes_isSet = true;
}

bool OAIQueueProperties::is_max_size_in_megabytes_Set() const{
    return m_max_size_in_megabytes_isSet;
}

bool OAIQueueProperties::is_max_size_in_megabytes_Valid() const{
    return m_max_size_in_megabytes_isValid;
}

qint64 OAIQueueProperties::getMessageCount() const {
    return m_message_count;
}
void OAIQueueProperties::setMessageCount(const qint64 &message_count) {
    m_message_count = message_count;
    m_message_count_isSet = true;
}

bool OAIQueueProperties::is_message_count_Set() const{
    return m_message_count_isSet;
}

bool OAIQueueProperties::is_message_count_Valid() const{
    return m_message_count_isValid;
}

bool OAIQueueProperties::isRequiresDuplicateDetection() const {
    return m_requires_duplicate_detection;
}
void OAIQueueProperties::setRequiresDuplicateDetection(const bool &requires_duplicate_detection) {
    m_requires_duplicate_detection = requires_duplicate_detection;
    m_requires_duplicate_detection_isSet = true;
}

bool OAIQueueProperties::is_requires_duplicate_detection_Set() const{
    return m_requires_duplicate_detection_isSet;
}

bool OAIQueueProperties::is_requires_duplicate_detection_Valid() const{
    return m_requires_duplicate_detection_isValid;
}

bool OAIQueueProperties::isRequiresSession() const {
    return m_requires_session;
}
void OAIQueueProperties::setRequiresSession(const bool &requires_session) {
    m_requires_session = requires_session;
    m_requires_session_isSet = true;
}

bool OAIQueueProperties::is_requires_session_Set() const{
    return m_requires_session_isSet;
}

bool OAIQueueProperties::is_requires_session_Valid() const{
    return m_requires_session_isValid;
}

qint64 OAIQueueProperties::getSizeInBytes() const {
    return m_size_in_bytes;
}
void OAIQueueProperties::setSizeInBytes(const qint64 &size_in_bytes) {
    m_size_in_bytes = size_in_bytes;
    m_size_in_bytes_isSet = true;
}

bool OAIQueueProperties::is_size_in_bytes_Set() const{
    return m_size_in_bytes_isSet;
}

bool OAIQueueProperties::is_size_in_bytes_Valid() const{
    return m_size_in_bytes_isValid;
}

OAIEntityStatus OAIQueueProperties::getStatus() const {
    return m_status;
}
void OAIQueueProperties::setStatus(const OAIEntityStatus &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIQueueProperties::is_status_Set() const{
    return m_status_isSet;
}

bool OAIQueueProperties::is_status_Valid() const{
    return m_status_isValid;
}

bool OAIQueueProperties::isSupportOrdering() const {
    return m_support_ordering;
}
void OAIQueueProperties::setSupportOrdering(const bool &support_ordering) {
    m_support_ordering = support_ordering;
    m_support_ordering_isSet = true;
}

bool OAIQueueProperties::is_support_ordering_Set() const{
    return m_support_ordering_isSet;
}

bool OAIQueueProperties::is_support_ordering_Valid() const{
    return m_support_ordering_isValid;
}

QDateTime OAIQueueProperties::getUpdatedAt() const {
    return m_updated_at;
}
void OAIQueueProperties::setUpdatedAt(const QDateTime &updated_at) {
    m_updated_at = updated_at;
    m_updated_at_isSet = true;
}

bool OAIQueueProperties::is_updated_at_Set() const{
    return m_updated_at_isSet;
}

bool OAIQueueProperties::is_updated_at_Valid() const{
    return m_updated_at_isValid;
}

bool OAIQueueProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accessed_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_auto_delete_on_idle_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_count_details.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dead_lettering_on_message_expiration_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_message_time_to_live_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_duplicate_detection_history_time_window_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_batched_operations_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_express_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_partitioning_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entity_availability_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_anonymous_accessible_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lock_duration_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_delivery_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_size_in_megabytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_message_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_duplicate_detection_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_requires_session_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_in_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_support_ordering_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_updated_at_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIQueueProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
