/**
 * Security Center
 * API spec for Microsoft.Security (Azure Security Center) resource provider
 *
 * The version of the OpenAPI document: 2015-06-01-preview
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPathRecommendation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPathRecommendation::OAIPathRecommendation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPathRecommendation::OAIPathRecommendation() {
    this->initializeModel();
}

OAIPathRecommendation::~OAIPathRecommendation() {}

void OAIPathRecommendation::initializeModel() {

    m_action_isSet = false;
    m_action_isValid = false;

    m_common_isSet = false;
    m_common_isValid = false;

    m_configuration_status_isSet = false;
    m_configuration_status_isValid = false;

    m_file_type_isSet = false;
    m_file_type_isValid = false;

    m_path_isSet = false;
    m_path_isValid = false;

    m_publisher_info_isSet = false;
    m_publisher_info_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_user_sids_isSet = false;
    m_user_sids_isValid = false;

    m_usernames_isSet = false;
    m_usernames_isValid = false;
}

void OAIPathRecommendation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPathRecommendation::fromJsonObject(QJsonObject json) {

    m_action_isValid = ::OpenAPI::fromJsonValue(m_action, json[QString("action")]);
    m_action_isSet = !json[QString("action")].isNull() && m_action_isValid;

    m_common_isValid = ::OpenAPI::fromJsonValue(m_common, json[QString("common")]);
    m_common_isSet = !json[QString("common")].isNull() && m_common_isValid;

    m_configuration_status_isValid = ::OpenAPI::fromJsonValue(m_configuration_status, json[QString("configurationStatus")]);
    m_configuration_status_isSet = !json[QString("configurationStatus")].isNull() && m_configuration_status_isValid;

    m_file_type_isValid = ::OpenAPI::fromJsonValue(m_file_type, json[QString("fileType")]);
    m_file_type_isSet = !json[QString("fileType")].isNull() && m_file_type_isValid;

    m_path_isValid = ::OpenAPI::fromJsonValue(m_path, json[QString("path")]);
    m_path_isSet = !json[QString("path")].isNull() && m_path_isValid;

    m_publisher_info_isValid = ::OpenAPI::fromJsonValue(m_publisher_info, json[QString("publisherInfo")]);
    m_publisher_info_isSet = !json[QString("publisherInfo")].isNull() && m_publisher_info_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_user_sids_isValid = ::OpenAPI::fromJsonValue(m_user_sids, json[QString("userSids")]);
    m_user_sids_isSet = !json[QString("userSids")].isNull() && m_user_sids_isValid;

    m_usernames_isValid = ::OpenAPI::fromJsonValue(m_usernames, json[QString("usernames")]);
    m_usernames_isSet = !json[QString("usernames")].isNull() && m_usernames_isValid;
}

QString OAIPathRecommendation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPathRecommendation::asJsonObject() const {
    QJsonObject obj;
    if (m_action.isSet()) {
        obj.insert(QString("action"), ::OpenAPI::toJsonValue(m_action));
    }
    if (m_common_isSet) {
        obj.insert(QString("common"), ::OpenAPI::toJsonValue(m_common));
    }
    if (m_configuration_status.isSet()) {
        obj.insert(QString("configurationStatus"), ::OpenAPI::toJsonValue(m_configuration_status));
    }
    if (m_file_type.isSet()) {
        obj.insert(QString("fileType"), ::OpenAPI::toJsonValue(m_file_type));
    }
    if (m_path_isSet) {
        obj.insert(QString("path"), ::OpenAPI::toJsonValue(m_path));
    }
    if (m_publisher_info.isSet()) {
        obj.insert(QString("publisherInfo"), ::OpenAPI::toJsonValue(m_publisher_info));
    }
    if (m_type.isSet()) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_user_sids.size() > 0) {
        obj.insert(QString("userSids"), ::OpenAPI::toJsonValue(m_user_sids));
    }
    if (m_usernames.size() > 0) {
        obj.insert(QString("usernames"), ::OpenAPI::toJsonValue(m_usernames));
    }
    return obj;
}

OAIRecommendationAction OAIPathRecommendation::getAction() const {
    return m_action;
}
void OAIPathRecommendation::setAction(const OAIRecommendationAction &action) {
    m_action = action;
    m_action_isSet = true;
}

bool OAIPathRecommendation::is_action_Set() const{
    return m_action_isSet;
}

bool OAIPathRecommendation::is_action_Valid() const{
    return m_action_isValid;
}

bool OAIPathRecommendation::isCommon() const {
    return m_common;
}
void OAIPathRecommendation::setCommon(const bool &common) {
    m_common = common;
    m_common_isSet = true;
}

bool OAIPathRecommendation::is_common_Set() const{
    return m_common_isSet;
}

bool OAIPathRecommendation::is_common_Valid() const{
    return m_common_isValid;
}

OAIConfigurationStatus OAIPathRecommendation::getConfigurationStatus() const {
    return m_configuration_status;
}
void OAIPathRecommendation::setConfigurationStatus(const OAIConfigurationStatus &configuration_status) {
    m_configuration_status = configuration_status;
    m_configuration_status_isSet = true;
}

bool OAIPathRecommendation::is_configuration_status_Set() const{
    return m_configuration_status_isSet;
}

bool OAIPathRecommendation::is_configuration_status_Valid() const{
    return m_configuration_status_isValid;
}

OAIFileType OAIPathRecommendation::getFileType() const {
    return m_file_type;
}
void OAIPathRecommendation::setFileType(const OAIFileType &file_type) {
    m_file_type = file_type;
    m_file_type_isSet = true;
}

bool OAIPathRecommendation::is_file_type_Set() const{
    return m_file_type_isSet;
}

bool OAIPathRecommendation::is_file_type_Valid() const{
    return m_file_type_isValid;
}

QString OAIPathRecommendation::getPath() const {
    return m_path;
}
void OAIPathRecommendation::setPath(const QString &path) {
    m_path = path;
    m_path_isSet = true;
}

bool OAIPathRecommendation::is_path_Set() const{
    return m_path_isSet;
}

bool OAIPathRecommendation::is_path_Valid() const{
    return m_path_isValid;
}

OAIPublisherInfo OAIPathRecommendation::getPublisherInfo() const {
    return m_publisher_info;
}
void OAIPathRecommendation::setPublisherInfo(const OAIPublisherInfo &publisher_info) {
    m_publisher_info = publisher_info;
    m_publisher_info_isSet = true;
}

bool OAIPathRecommendation::is_publisher_info_Set() const{
    return m_publisher_info_isSet;
}

bool OAIPathRecommendation::is_publisher_info_Valid() const{
    return m_publisher_info_isValid;
}

OAIRecommendationType OAIPathRecommendation::getType() const {
    return m_type;
}
void OAIPathRecommendation::setType(const OAIRecommendationType &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIPathRecommendation::is_type_Set() const{
    return m_type_isSet;
}

bool OAIPathRecommendation::is_type_Valid() const{
    return m_type_isValid;
}

QList<QString> OAIPathRecommendation::getUserSids() const {
    return m_user_sids;
}
void OAIPathRecommendation::setUserSids(const QList<QString> &user_sids) {
    m_user_sids = user_sids;
    m_user_sids_isSet = true;
}

bool OAIPathRecommendation::is_user_sids_Set() const{
    return m_user_sids_isSet;
}

bool OAIPathRecommendation::is_user_sids_Valid() const{
    return m_user_sids_isValid;
}

QList<OAIUserRecommendation> OAIPathRecommendation::getUsernames() const {
    return m_usernames;
}
void OAIPathRecommendation::setUsernames(const QList<OAIUserRecommendation> &usernames) {
    m_usernames = usernames;
    m_usernames_isSet = true;
}

bool OAIPathRecommendation::is_usernames_Set() const{
    return m_usernames_isSet;
}

bool OAIPathRecommendation::is_usernames_Valid() const{
    return m_usernames_isValid;
}

bool OAIPathRecommendation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_action.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_common_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_configuration_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_file_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_publisher_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_sids.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_usernames.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPathRecommendation::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
