/*
 * Anomaly Finder Client
 * The Anomaly Finder API detects anomalies automatically in time series data. It supports two functionalities, one is for detecting the whole series with model trained by the timeseries, another is detecting last point with model trained by points before. By using this service, business customers can discover incidents and establish a logic flow for root cause analysis.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * LastDetectResponse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:50:31.711271-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LastDetectResponse {
  public static final String SERIALIZED_NAME_EXPECTED_VALUE = "expectedValue";
  @SerializedName(SERIALIZED_NAME_EXPECTED_VALUE)
  private Float expectedValue;

  public static final String SERIALIZED_NAME_IS_ANOMALY = "isAnomaly";
  @SerializedName(SERIALIZED_NAME_IS_ANOMALY)
  private Boolean isAnomaly;

  public static final String SERIALIZED_NAME_IS_NEGATIVE_ANOMALY = "isNegativeAnomaly";
  @SerializedName(SERIALIZED_NAME_IS_NEGATIVE_ANOMALY)
  private Boolean isNegativeAnomaly;

  public static final String SERIALIZED_NAME_IS_POSITIVE_ANOMALY = "isPositiveAnomaly";
  @SerializedName(SERIALIZED_NAME_IS_POSITIVE_ANOMALY)
  private Boolean isPositiveAnomaly;

  public static final String SERIALIZED_NAME_LOWER_MARGIN = "lowerMargin";
  @SerializedName(SERIALIZED_NAME_LOWER_MARGIN)
  private Float lowerMargin;

  public static final String SERIALIZED_NAME_PERIOD = "period";
  @SerializedName(SERIALIZED_NAME_PERIOD)
  private Integer period;

  public static final String SERIALIZED_NAME_SUGGESTED_WINDOW = "suggestedWindow";
  @SerializedName(SERIALIZED_NAME_SUGGESTED_WINDOW)
  private Integer suggestedWindow;

  public static final String SERIALIZED_NAME_UPPER_MARGIN = "upperMargin";
  @SerializedName(SERIALIZED_NAME_UPPER_MARGIN)
  private Float upperMargin;

  public LastDetectResponse() {
  }

  public LastDetectResponse expectedValue(Float expectedValue) {
    this.expectedValue = expectedValue;
    return this;
  }

  /**
   * Expected value of the latest point.
   * @return expectedValue
   */
  @javax.annotation.Nullable
  public Float getExpectedValue() {
    return expectedValue;
  }

  public void setExpectedValue(Float expectedValue) {
    this.expectedValue = expectedValue;
  }


  public LastDetectResponse isAnomaly(Boolean isAnomaly) {
    this.isAnomaly = isAnomaly;
    return this;
  }

  /**
   * Anomaly status of the latest point, true means the latest point is an anomaly either in negative direction or positive direction.
   * @return isAnomaly
   */
  @javax.annotation.Nullable
  public Boolean getIsAnomaly() {
    return isAnomaly;
  }

  public void setIsAnomaly(Boolean isAnomaly) {
    this.isAnomaly = isAnomaly;
  }


  public LastDetectResponse isNegativeAnomaly(Boolean isNegativeAnomaly) {
    this.isNegativeAnomaly = isNegativeAnomaly;
    return this;
  }

  /**
   * Anomaly status in negative direction of the latest point. True means the latest point is an anomaly and its real value is smaller than the expected one.
   * @return isNegativeAnomaly
   */
  @javax.annotation.Nullable
  public Boolean getIsNegativeAnomaly() {
    return isNegativeAnomaly;
  }

  public void setIsNegativeAnomaly(Boolean isNegativeAnomaly) {
    this.isNegativeAnomaly = isNegativeAnomaly;
  }


  public LastDetectResponse isPositiveAnomaly(Boolean isPositiveAnomaly) {
    this.isPositiveAnomaly = isPositiveAnomaly;
    return this;
  }

  /**
   * Anomaly status in positive direction of the latest point. True means the latest point is an anomaly and its real value is larger than the expected one.
   * @return isPositiveAnomaly
   */
  @javax.annotation.Nullable
  public Boolean getIsPositiveAnomaly() {
    return isPositiveAnomaly;
  }

  public void setIsPositiveAnomaly(Boolean isPositiveAnomaly) {
    this.isPositiveAnomaly = isPositiveAnomaly;
  }


  public LastDetectResponse lowerMargin(Float lowerMargin) {
    this.lowerMargin = lowerMargin;
    return this;
  }

  /**
   * Lower margin of the latest point. LowerMargin is used to calculate lowerBoundary, which equals to expectedValue - (100 - sensitivity)*lowerMargin. 
   * @return lowerMargin
   */
  @javax.annotation.Nullable
  public Float getLowerMargin() {
    return lowerMargin;
  }

  public void setLowerMargin(Float lowerMargin) {
    this.lowerMargin = lowerMargin;
  }


  public LastDetectResponse period(Integer period) {
    this.period = period;
    return this;
  }

  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   * @return period
   */
  @javax.annotation.Nullable
  public Integer getPeriod() {
    return period;
  }

  public void setPeriod(Integer period) {
    this.period = period;
  }


  public LastDetectResponse suggestedWindow(Integer suggestedWindow) {
    this.suggestedWindow = suggestedWindow;
    return this;
  }

  /**
   * Suggested input series points needed for detecting the latest point.
   * @return suggestedWindow
   */
  @javax.annotation.Nullable
  public Integer getSuggestedWindow() {
    return suggestedWindow;
  }

  public void setSuggestedWindow(Integer suggestedWindow) {
    this.suggestedWindow = suggestedWindow;
  }


  public LastDetectResponse upperMargin(Float upperMargin) {
    this.upperMargin = upperMargin;
    return this;
  }

  /**
   * Upper margin of the latest point. UpperMargin is used to calculate upperBoundary, which equals to expectedValue + (100 - sensitivity)*upperMargin. If the value of latest point is between upperBoundary and lowerBoundary, it should be treated as normal value. By adjusting sensitivity value, anomaly status of latest point can be changed.
   * @return upperMargin
   */
  @javax.annotation.Nullable
  public Float getUpperMargin() {
    return upperMargin;
  }

  public void setUpperMargin(Float upperMargin) {
    this.upperMargin = upperMargin;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LastDetectResponse lastDetectResponse = (LastDetectResponse) o;
    return Objects.equals(this.expectedValue, lastDetectResponse.expectedValue) &&
        Objects.equals(this.isAnomaly, lastDetectResponse.isAnomaly) &&
        Objects.equals(this.isNegativeAnomaly, lastDetectResponse.isNegativeAnomaly) &&
        Objects.equals(this.isPositiveAnomaly, lastDetectResponse.isPositiveAnomaly) &&
        Objects.equals(this.lowerMargin, lastDetectResponse.lowerMargin) &&
        Objects.equals(this.period, lastDetectResponse.period) &&
        Objects.equals(this.suggestedWindow, lastDetectResponse.suggestedWindow) &&
        Objects.equals(this.upperMargin, lastDetectResponse.upperMargin);
  }

  @Override
  public int hashCode() {
    return Objects.hash(expectedValue, isAnomaly, isNegativeAnomaly, isPositiveAnomaly, lowerMargin, period, suggestedWindow, upperMargin);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LastDetectResponse {\n");
    sb.append("    expectedValue: ").append(toIndentedString(expectedValue)).append("\n");
    sb.append("    isAnomaly: ").append(toIndentedString(isAnomaly)).append("\n");
    sb.append("    isNegativeAnomaly: ").append(toIndentedString(isNegativeAnomaly)).append("\n");
    sb.append("    isPositiveAnomaly: ").append(toIndentedString(isPositiveAnomaly)).append("\n");
    sb.append("    lowerMargin: ").append(toIndentedString(lowerMargin)).append("\n");
    sb.append("    period: ").append(toIndentedString(period)).append("\n");
    sb.append("    suggestedWindow: ").append(toIndentedString(suggestedWindow)).append("\n");
    sb.append("    upperMargin: ").append(toIndentedString(upperMargin)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("expectedValue");
    openapiFields.add("isAnomaly");
    openapiFields.add("isNegativeAnomaly");
    openapiFields.add("isPositiveAnomaly");
    openapiFields.add("lowerMargin");
    openapiFields.add("period");
    openapiFields.add("suggestedWindow");
    openapiFields.add("upperMargin");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LastDetectResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LastDetectResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LastDetectResponse is not found in the empty JSON string", LastDetectResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LastDetectResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LastDetectResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LastDetectResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LastDetectResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LastDetectResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LastDetectResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<LastDetectResponse>() {
           @Override
           public void write(JsonWriter out, LastDetectResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LastDetectResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LastDetectResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LastDetectResponse
   * @throws IOException if the JSON string is invalid with respect to LastDetectResponse
   */
  public static LastDetectResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LastDetectResponse.class);
  }

  /**
   * Convert an instance of LastDetectResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

