/*
 * Anomaly Finder Client
 * The Anomaly Finder API detects anomalies automatically in time series data. It supports two functionalities, one is for detecting the whole series with model trained by the timeseries, another is detecting last point with model trained by points before. By using this service, business customers can discover incidents and establish a logic flow for root cause analysis.
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * EntireDetectResponse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:50:31.711271-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class EntireDetectResponse {
  public static final String SERIALIZED_NAME_EXPECTED_VALUES = "expectedValues";
  @SerializedName(SERIALIZED_NAME_EXPECTED_VALUES)
  private List<Float> expectedValues = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_ANOMALY = "isAnomaly";
  @SerializedName(SERIALIZED_NAME_IS_ANOMALY)
  private List<Boolean> isAnomaly = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_NEGATIVE_ANOMALY = "isNegativeAnomaly";
  @SerializedName(SERIALIZED_NAME_IS_NEGATIVE_ANOMALY)
  private List<Boolean> isNegativeAnomaly = new ArrayList<>();

  public static final String SERIALIZED_NAME_IS_POSITIVE_ANOMALY = "isPositiveAnomaly";
  @SerializedName(SERIALIZED_NAME_IS_POSITIVE_ANOMALY)
  private List<Boolean> isPositiveAnomaly = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOWER_MARGINS = "lowerMargins";
  @SerializedName(SERIALIZED_NAME_LOWER_MARGINS)
  private List<Float> lowerMargins = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERIOD = "period";
  @SerializedName(SERIALIZED_NAME_PERIOD)
  private Integer period;

  public static final String SERIALIZED_NAME_UPPER_MARGINS = "upperMargins";
  @SerializedName(SERIALIZED_NAME_UPPER_MARGINS)
  private List<Float> upperMargins = new ArrayList<>();

  public EntireDetectResponse() {
  }

  public EntireDetectResponse expectedValues(List<Float> expectedValues) {
    this.expectedValues = expectedValues;
    return this;
  }

  public EntireDetectResponse addExpectedValuesItem(Float expectedValuesItem) {
    if (this.expectedValues == null) {
      this.expectedValues = new ArrayList<>();
    }
    this.expectedValues.add(expectedValuesItem);
    return this;
  }

  /**
   * ExpectedValues contain expected value for each input point. The index of the array is consistent with the input series.
   * @return expectedValues
   */
  @javax.annotation.Nonnull
  public List<Float> getExpectedValues() {
    return expectedValues;
  }

  public void setExpectedValues(List<Float> expectedValues) {
    this.expectedValues = expectedValues;
  }


  public EntireDetectResponse isAnomaly(List<Boolean> isAnomaly) {
    this.isAnomaly = isAnomaly;
    return this;
  }

  public EntireDetectResponse addIsAnomalyItem(Boolean isAnomalyItem) {
    if (this.isAnomaly == null) {
      this.isAnomaly = new ArrayList<>();
    }
    this.isAnomaly.add(isAnomalyItem);
    return this;
  }

  /**
   * IsAnomaly contains anomaly properties for each input point. True means an anomaly either negative or positive has been detected. The index of the array is consistent with the input series.
   * @return isAnomaly
   */
  @javax.annotation.Nonnull
  public List<Boolean> getIsAnomaly() {
    return isAnomaly;
  }

  public void setIsAnomaly(List<Boolean> isAnomaly) {
    this.isAnomaly = isAnomaly;
  }


  public EntireDetectResponse isNegativeAnomaly(List<Boolean> isNegativeAnomaly) {
    this.isNegativeAnomaly = isNegativeAnomaly;
    return this;
  }

  public EntireDetectResponse addIsNegativeAnomalyItem(Boolean isNegativeAnomalyItem) {
    if (this.isNegativeAnomaly == null) {
      this.isNegativeAnomaly = new ArrayList<>();
    }
    this.isNegativeAnomaly.add(isNegativeAnomalyItem);
    return this;
  }

  /**
   * IsNegativeAnomaly contains anomaly status in negative direction for each input point. True means a negative anomaly has been detected. A negative anomaly means the point is detected as an anomaly and its real value is smaller than the expected one. The index of the array is consistent with the input series.
   * @return isNegativeAnomaly
   */
  @javax.annotation.Nonnull
  public List<Boolean> getIsNegativeAnomaly() {
    return isNegativeAnomaly;
  }

  public void setIsNegativeAnomaly(List<Boolean> isNegativeAnomaly) {
    this.isNegativeAnomaly = isNegativeAnomaly;
  }


  public EntireDetectResponse isPositiveAnomaly(List<Boolean> isPositiveAnomaly) {
    this.isPositiveAnomaly = isPositiveAnomaly;
    return this;
  }

  public EntireDetectResponse addIsPositiveAnomalyItem(Boolean isPositiveAnomalyItem) {
    if (this.isPositiveAnomaly == null) {
      this.isPositiveAnomaly = new ArrayList<>();
    }
    this.isPositiveAnomaly.add(isPositiveAnomalyItem);
    return this;
  }

  /**
   * IsPositiveAnomaly contain anomaly status in positive direction for each input point. True means a positive anomaly has been detected. A positive anomaly means the point is detected as an anomaly and its real value is larger than the expected one. The index of the array is consistent with the input series.
   * @return isPositiveAnomaly
   */
  @javax.annotation.Nonnull
  public List<Boolean> getIsPositiveAnomaly() {
    return isPositiveAnomaly;
  }

  public void setIsPositiveAnomaly(List<Boolean> isPositiveAnomaly) {
    this.isPositiveAnomaly = isPositiveAnomaly;
  }


  public EntireDetectResponse lowerMargins(List<Float> lowerMargins) {
    this.lowerMargins = lowerMargins;
    return this;
  }

  public EntireDetectResponse addLowerMarginsItem(Float lowerMarginsItem) {
    if (this.lowerMargins == null) {
      this.lowerMargins = new ArrayList<>();
    }
    this.lowerMargins.add(lowerMarginsItem);
    return this;
  }

  /**
   * LowerMargins contain lower margin of each input point. LowerMargin is used to calculate lowerBoundary, which equals to expectedValue - (100 - sensitivity)*lowerMargin. Points between the boundary can be marked as normal ones in client side. The index of the array is consistent with the input series.
   * @return lowerMargins
   */
  @javax.annotation.Nonnull
  public List<Float> getLowerMargins() {
    return lowerMargins;
  }

  public void setLowerMargins(List<Float> lowerMargins) {
    this.lowerMargins = lowerMargins;
  }


  public EntireDetectResponse period(Integer period) {
    this.period = period;
    return this;
  }

  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   * @return period
   */
  @javax.annotation.Nonnull
  public Integer getPeriod() {
    return period;
  }

  public void setPeriod(Integer period) {
    this.period = period;
  }


  public EntireDetectResponse upperMargins(List<Float> upperMargins) {
    this.upperMargins = upperMargins;
    return this;
  }

  public EntireDetectResponse addUpperMarginsItem(Float upperMarginsItem) {
    if (this.upperMargins == null) {
      this.upperMargins = new ArrayList<>();
    }
    this.upperMargins.add(upperMarginsItem);
    return this;
  }

  /**
   * UpperMargins contain upper margin of each input point. UpperMargin is used to calculate upperBoundary, which equals to expectedValue + (100 - sensitivity)*upperMargin. Anomalies in response can be filtered by upperBoundary and lowerBoundary. By adjusting sensitivity value, less significant anomalies can be filtered in client side. The index of the array is consistent with the input series.
   * @return upperMargins
   */
  @javax.annotation.Nonnull
  public List<Float> getUpperMargins() {
    return upperMargins;
  }

  public void setUpperMargins(List<Float> upperMargins) {
    this.upperMargins = upperMargins;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EntireDetectResponse entireDetectResponse = (EntireDetectResponse) o;
    return Objects.equals(this.expectedValues, entireDetectResponse.expectedValues) &&
        Objects.equals(this.isAnomaly, entireDetectResponse.isAnomaly) &&
        Objects.equals(this.isNegativeAnomaly, entireDetectResponse.isNegativeAnomaly) &&
        Objects.equals(this.isPositiveAnomaly, entireDetectResponse.isPositiveAnomaly) &&
        Objects.equals(this.lowerMargins, entireDetectResponse.lowerMargins) &&
        Objects.equals(this.period, entireDetectResponse.period) &&
        Objects.equals(this.upperMargins, entireDetectResponse.upperMargins);
  }

  @Override
  public int hashCode() {
    return Objects.hash(expectedValues, isAnomaly, isNegativeAnomaly, isPositiveAnomaly, lowerMargins, period, upperMargins);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EntireDetectResponse {\n");
    sb.append("    expectedValues: ").append(toIndentedString(expectedValues)).append("\n");
    sb.append("    isAnomaly: ").append(toIndentedString(isAnomaly)).append("\n");
    sb.append("    isNegativeAnomaly: ").append(toIndentedString(isNegativeAnomaly)).append("\n");
    sb.append("    isPositiveAnomaly: ").append(toIndentedString(isPositiveAnomaly)).append("\n");
    sb.append("    lowerMargins: ").append(toIndentedString(lowerMargins)).append("\n");
    sb.append("    period: ").append(toIndentedString(period)).append("\n");
    sb.append("    upperMargins: ").append(toIndentedString(upperMargins)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("expectedValues");
    openapiFields.add("isAnomaly");
    openapiFields.add("isNegativeAnomaly");
    openapiFields.add("isPositiveAnomaly");
    openapiFields.add("lowerMargins");
    openapiFields.add("period");
    openapiFields.add("upperMargins");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("expectedValues");
    openapiRequiredFields.add("isAnomaly");
    openapiRequiredFields.add("isNegativeAnomaly");
    openapiRequiredFields.add("isPositiveAnomaly");
    openapiRequiredFields.add("lowerMargins");
    openapiRequiredFields.add("period");
    openapiRequiredFields.add("upperMargins");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to EntireDetectResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EntireDetectResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EntireDetectResponse is not found in the empty JSON string", EntireDetectResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!EntireDetectResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EntireDetectResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : EntireDetectResponse.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the required json array is present
      if (jsonObj.get("expectedValues") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("expectedValues").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `expectedValues` to be an array in the JSON string but got `%s`", jsonObj.get("expectedValues").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("isAnomaly") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("isAnomaly").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `isAnomaly` to be an array in the JSON string but got `%s`", jsonObj.get("isAnomaly").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("isNegativeAnomaly") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("isNegativeAnomaly").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `isNegativeAnomaly` to be an array in the JSON string but got `%s`", jsonObj.get("isNegativeAnomaly").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("isPositiveAnomaly") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("isPositiveAnomaly").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `isPositiveAnomaly` to be an array in the JSON string but got `%s`", jsonObj.get("isPositiveAnomaly").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("lowerMargins") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("lowerMargins").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `lowerMargins` to be an array in the JSON string but got `%s`", jsonObj.get("lowerMargins").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("upperMargins") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("upperMargins").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `upperMargins` to be an array in the JSON string but got `%s`", jsonObj.get("upperMargins").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EntireDetectResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EntireDetectResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EntireDetectResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EntireDetectResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<EntireDetectResponse>() {
           @Override
           public void write(JsonWriter out, EntireDetectResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EntireDetectResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of EntireDetectResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of EntireDetectResponse
   * @throws IOException if the JSON string is invalid with respect to EntireDetectResponse
   */
  public static EntireDetectResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EntireDetectResponse.class);
  }

  /**
   * Convert an instance of EntireDetectResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

