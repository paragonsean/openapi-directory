/**
 * Anomaly Finder Client
 * The Anomaly Finder API detects anomalies automatically in time series data. It supports two functionalities, one is for detecting the whole series with model trained by the timeseries, another is detecting last point with model trained by points before. By using this service, business customers can discover incidents and establish a logic flow for root cause analysis.
 *
 * The version of the OpenAPI document: 2.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAILastDetectResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAILastDetectResponse::OAILastDetectResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAILastDetectResponse::OAILastDetectResponse() {
    this->initializeModel();
}

OAILastDetectResponse::~OAILastDetectResponse() {}

void OAILastDetectResponse::initializeModel() {

    m_expected_value_isSet = false;
    m_expected_value_isValid = false;

    m_is_anomaly_isSet = false;
    m_is_anomaly_isValid = false;

    m_is_negative_anomaly_isSet = false;
    m_is_negative_anomaly_isValid = false;

    m_is_positive_anomaly_isSet = false;
    m_is_positive_anomaly_isValid = false;

    m_lower_margin_isSet = false;
    m_lower_margin_isValid = false;

    m_period_isSet = false;
    m_period_isValid = false;

    m_suggested_window_isSet = false;
    m_suggested_window_isValid = false;

    m_upper_margin_isSet = false;
    m_upper_margin_isValid = false;
}

void OAILastDetectResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAILastDetectResponse::fromJsonObject(QJsonObject json) {

    m_expected_value_isValid = ::OpenAPI::fromJsonValue(m_expected_value, json[QString("expectedValue")]);
    m_expected_value_isSet = !json[QString("expectedValue")].isNull() && m_expected_value_isValid;

    m_is_anomaly_isValid = ::OpenAPI::fromJsonValue(m_is_anomaly, json[QString("isAnomaly")]);
    m_is_anomaly_isSet = !json[QString("isAnomaly")].isNull() && m_is_anomaly_isValid;

    m_is_negative_anomaly_isValid = ::OpenAPI::fromJsonValue(m_is_negative_anomaly, json[QString("isNegativeAnomaly")]);
    m_is_negative_anomaly_isSet = !json[QString("isNegativeAnomaly")].isNull() && m_is_negative_anomaly_isValid;

    m_is_positive_anomaly_isValid = ::OpenAPI::fromJsonValue(m_is_positive_anomaly, json[QString("isPositiveAnomaly")]);
    m_is_positive_anomaly_isSet = !json[QString("isPositiveAnomaly")].isNull() && m_is_positive_anomaly_isValid;

    m_lower_margin_isValid = ::OpenAPI::fromJsonValue(m_lower_margin, json[QString("lowerMargin")]);
    m_lower_margin_isSet = !json[QString("lowerMargin")].isNull() && m_lower_margin_isValid;

    m_period_isValid = ::OpenAPI::fromJsonValue(m_period, json[QString("period")]);
    m_period_isSet = !json[QString("period")].isNull() && m_period_isValid;

    m_suggested_window_isValid = ::OpenAPI::fromJsonValue(m_suggested_window, json[QString("suggestedWindow")]);
    m_suggested_window_isSet = !json[QString("suggestedWindow")].isNull() && m_suggested_window_isValid;

    m_upper_margin_isValid = ::OpenAPI::fromJsonValue(m_upper_margin, json[QString("upperMargin")]);
    m_upper_margin_isSet = !json[QString("upperMargin")].isNull() && m_upper_margin_isValid;
}

QString OAILastDetectResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAILastDetectResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_expected_value_isSet) {
        obj.insert(QString("expectedValue"), ::OpenAPI::toJsonValue(m_expected_value));
    }
    if (m_is_anomaly_isSet) {
        obj.insert(QString("isAnomaly"), ::OpenAPI::toJsonValue(m_is_anomaly));
    }
    if (m_is_negative_anomaly_isSet) {
        obj.insert(QString("isNegativeAnomaly"), ::OpenAPI::toJsonValue(m_is_negative_anomaly));
    }
    if (m_is_positive_anomaly_isSet) {
        obj.insert(QString("isPositiveAnomaly"), ::OpenAPI::toJsonValue(m_is_positive_anomaly));
    }
    if (m_lower_margin_isSet) {
        obj.insert(QString("lowerMargin"), ::OpenAPI::toJsonValue(m_lower_margin));
    }
    if (m_period_isSet) {
        obj.insert(QString("period"), ::OpenAPI::toJsonValue(m_period));
    }
    if (m_suggested_window_isSet) {
        obj.insert(QString("suggestedWindow"), ::OpenAPI::toJsonValue(m_suggested_window));
    }
    if (m_upper_margin_isSet) {
        obj.insert(QString("upperMargin"), ::OpenAPI::toJsonValue(m_upper_margin));
    }
    return obj;
}

float OAILastDetectResponse::getExpectedValue() const {
    return m_expected_value;
}
void OAILastDetectResponse::setExpectedValue(const float &expected_value) {
    m_expected_value = expected_value;
    m_expected_value_isSet = true;
}

bool OAILastDetectResponse::is_expected_value_Set() const{
    return m_expected_value_isSet;
}

bool OAILastDetectResponse::is_expected_value_Valid() const{
    return m_expected_value_isValid;
}

bool OAILastDetectResponse::isIsAnomaly() const {
    return m_is_anomaly;
}
void OAILastDetectResponse::setIsAnomaly(const bool &is_anomaly) {
    m_is_anomaly = is_anomaly;
    m_is_anomaly_isSet = true;
}

bool OAILastDetectResponse::is_is_anomaly_Set() const{
    return m_is_anomaly_isSet;
}

bool OAILastDetectResponse::is_is_anomaly_Valid() const{
    return m_is_anomaly_isValid;
}

bool OAILastDetectResponse::isIsNegativeAnomaly() const {
    return m_is_negative_anomaly;
}
void OAILastDetectResponse::setIsNegativeAnomaly(const bool &is_negative_anomaly) {
    m_is_negative_anomaly = is_negative_anomaly;
    m_is_negative_anomaly_isSet = true;
}

bool OAILastDetectResponse::is_is_negative_anomaly_Set() const{
    return m_is_negative_anomaly_isSet;
}

bool OAILastDetectResponse::is_is_negative_anomaly_Valid() const{
    return m_is_negative_anomaly_isValid;
}

bool OAILastDetectResponse::isIsPositiveAnomaly() const {
    return m_is_positive_anomaly;
}
void OAILastDetectResponse::setIsPositiveAnomaly(const bool &is_positive_anomaly) {
    m_is_positive_anomaly = is_positive_anomaly;
    m_is_positive_anomaly_isSet = true;
}

bool OAILastDetectResponse::is_is_positive_anomaly_Set() const{
    return m_is_positive_anomaly_isSet;
}

bool OAILastDetectResponse::is_is_positive_anomaly_Valid() const{
    return m_is_positive_anomaly_isValid;
}

float OAILastDetectResponse::getLowerMargin() const {
    return m_lower_margin;
}
void OAILastDetectResponse::setLowerMargin(const float &lower_margin) {
    m_lower_margin = lower_margin;
    m_lower_margin_isSet = true;
}

bool OAILastDetectResponse::is_lower_margin_Set() const{
    return m_lower_margin_isSet;
}

bool OAILastDetectResponse::is_lower_margin_Valid() const{
    return m_lower_margin_isValid;
}

qint32 OAILastDetectResponse::getPeriod() const {
    return m_period;
}
void OAILastDetectResponse::setPeriod(const qint32 &period) {
    m_period = period;
    m_period_isSet = true;
}

bool OAILastDetectResponse::is_period_Set() const{
    return m_period_isSet;
}

bool OAILastDetectResponse::is_period_Valid() const{
    return m_period_isValid;
}

qint32 OAILastDetectResponse::getSuggestedWindow() const {
    return m_suggested_window;
}
void OAILastDetectResponse::setSuggestedWindow(const qint32 &suggested_window) {
    m_suggested_window = suggested_window;
    m_suggested_window_isSet = true;
}

bool OAILastDetectResponse::is_suggested_window_Set() const{
    return m_suggested_window_isSet;
}

bool OAILastDetectResponse::is_suggested_window_Valid() const{
    return m_suggested_window_isValid;
}

float OAILastDetectResponse::getUpperMargin() const {
    return m_upper_margin;
}
void OAILastDetectResponse::setUpperMargin(const float &upper_margin) {
    m_upper_margin = upper_margin;
    m_upper_margin_isSet = true;
}

bool OAILastDetectResponse::is_upper_margin_Set() const{
    return m_upper_margin_isSet;
}

bool OAILastDetectResponse::is_upper_margin_Valid() const{
    return m_upper_margin_isValid;
}

bool OAILastDetectResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_expected_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_anomaly_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_negative_anomaly_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_positive_anomaly_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lower_margin_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_suggested_window_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_upper_margin_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAILastDetectResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
