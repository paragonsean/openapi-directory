/**
 * Anomaly Finder Client
 * The Anomaly Finder API detects anomalies automatically in time series data. It supports two functionalities, one is for detecting the whole series with model trained by the timeseries, another is detecting last point with model trained by points before. By using this service, business customers can discover incidents and establish a logic flow for root cause analysis.
 *
 * The version of the OpenAPI document: 2.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIEntireDetectResponse.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIEntireDetectResponse::OAIEntireDetectResponse(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIEntireDetectResponse::OAIEntireDetectResponse() {
    this->initializeModel();
}

OAIEntireDetectResponse::~OAIEntireDetectResponse() {}

void OAIEntireDetectResponse::initializeModel() {

    m_expected_values_isSet = false;
    m_expected_values_isValid = false;

    m_is_anomaly_isSet = false;
    m_is_anomaly_isValid = false;

    m_is_negative_anomaly_isSet = false;
    m_is_negative_anomaly_isValid = false;

    m_is_positive_anomaly_isSet = false;
    m_is_positive_anomaly_isValid = false;

    m_lower_margins_isSet = false;
    m_lower_margins_isValid = false;

    m_period_isSet = false;
    m_period_isValid = false;

    m_upper_margins_isSet = false;
    m_upper_margins_isValid = false;
}

void OAIEntireDetectResponse::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIEntireDetectResponse::fromJsonObject(QJsonObject json) {

    m_expected_values_isValid = ::OpenAPI::fromJsonValue(m_expected_values, json[QString("expectedValues")]);
    m_expected_values_isSet = !json[QString("expectedValues")].isNull() && m_expected_values_isValid;

    m_is_anomaly_isValid = ::OpenAPI::fromJsonValue(m_is_anomaly, json[QString("isAnomaly")]);
    m_is_anomaly_isSet = !json[QString("isAnomaly")].isNull() && m_is_anomaly_isValid;

    m_is_negative_anomaly_isValid = ::OpenAPI::fromJsonValue(m_is_negative_anomaly, json[QString("isNegativeAnomaly")]);
    m_is_negative_anomaly_isSet = !json[QString("isNegativeAnomaly")].isNull() && m_is_negative_anomaly_isValid;

    m_is_positive_anomaly_isValid = ::OpenAPI::fromJsonValue(m_is_positive_anomaly, json[QString("isPositiveAnomaly")]);
    m_is_positive_anomaly_isSet = !json[QString("isPositiveAnomaly")].isNull() && m_is_positive_anomaly_isValid;

    m_lower_margins_isValid = ::OpenAPI::fromJsonValue(m_lower_margins, json[QString("lowerMargins")]);
    m_lower_margins_isSet = !json[QString("lowerMargins")].isNull() && m_lower_margins_isValid;

    m_period_isValid = ::OpenAPI::fromJsonValue(m_period, json[QString("period")]);
    m_period_isSet = !json[QString("period")].isNull() && m_period_isValid;

    m_upper_margins_isValid = ::OpenAPI::fromJsonValue(m_upper_margins, json[QString("upperMargins")]);
    m_upper_margins_isSet = !json[QString("upperMargins")].isNull() && m_upper_margins_isValid;
}

QString OAIEntireDetectResponse::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIEntireDetectResponse::asJsonObject() const {
    QJsonObject obj;
    if (m_expected_values.size() > 0) {
        obj.insert(QString("expectedValues"), ::OpenAPI::toJsonValue(m_expected_values));
    }
    if (m_is_anomaly.size() > 0) {
        obj.insert(QString("isAnomaly"), ::OpenAPI::toJsonValue(m_is_anomaly));
    }
    if (m_is_negative_anomaly.size() > 0) {
        obj.insert(QString("isNegativeAnomaly"), ::OpenAPI::toJsonValue(m_is_negative_anomaly));
    }
    if (m_is_positive_anomaly.size() > 0) {
        obj.insert(QString("isPositiveAnomaly"), ::OpenAPI::toJsonValue(m_is_positive_anomaly));
    }
    if (m_lower_margins.size() > 0) {
        obj.insert(QString("lowerMargins"), ::OpenAPI::toJsonValue(m_lower_margins));
    }
    if (m_period_isSet) {
        obj.insert(QString("period"), ::OpenAPI::toJsonValue(m_period));
    }
    if (m_upper_margins.size() > 0) {
        obj.insert(QString("upperMargins"), ::OpenAPI::toJsonValue(m_upper_margins));
    }
    return obj;
}

QList<float> OAIEntireDetectResponse::getExpectedValues() const {
    return m_expected_values;
}
void OAIEntireDetectResponse::setExpectedValues(const QList<float> &expected_values) {
    m_expected_values = expected_values;
    m_expected_values_isSet = true;
}

bool OAIEntireDetectResponse::is_expected_values_Set() const{
    return m_expected_values_isSet;
}

bool OAIEntireDetectResponse::is_expected_values_Valid() const{
    return m_expected_values_isValid;
}

QList<bool> OAIEntireDetectResponse::getIsAnomaly() const {
    return m_is_anomaly;
}
void OAIEntireDetectResponse::setIsAnomaly(const QList<bool> &is_anomaly) {
    m_is_anomaly = is_anomaly;
    m_is_anomaly_isSet = true;
}

bool OAIEntireDetectResponse::is_is_anomaly_Set() const{
    return m_is_anomaly_isSet;
}

bool OAIEntireDetectResponse::is_is_anomaly_Valid() const{
    return m_is_anomaly_isValid;
}

QList<bool> OAIEntireDetectResponse::getIsNegativeAnomaly() const {
    return m_is_negative_anomaly;
}
void OAIEntireDetectResponse::setIsNegativeAnomaly(const QList<bool> &is_negative_anomaly) {
    m_is_negative_anomaly = is_negative_anomaly;
    m_is_negative_anomaly_isSet = true;
}

bool OAIEntireDetectResponse::is_is_negative_anomaly_Set() const{
    return m_is_negative_anomaly_isSet;
}

bool OAIEntireDetectResponse::is_is_negative_anomaly_Valid() const{
    return m_is_negative_anomaly_isValid;
}

QList<bool> OAIEntireDetectResponse::getIsPositiveAnomaly() const {
    return m_is_positive_anomaly;
}
void OAIEntireDetectResponse::setIsPositiveAnomaly(const QList<bool> &is_positive_anomaly) {
    m_is_positive_anomaly = is_positive_anomaly;
    m_is_positive_anomaly_isSet = true;
}

bool OAIEntireDetectResponse::is_is_positive_anomaly_Set() const{
    return m_is_positive_anomaly_isSet;
}

bool OAIEntireDetectResponse::is_is_positive_anomaly_Valid() const{
    return m_is_positive_anomaly_isValid;
}

QList<float> OAIEntireDetectResponse::getLowerMargins() const {
    return m_lower_margins;
}
void OAIEntireDetectResponse::setLowerMargins(const QList<float> &lower_margins) {
    m_lower_margins = lower_margins;
    m_lower_margins_isSet = true;
}

bool OAIEntireDetectResponse::is_lower_margins_Set() const{
    return m_lower_margins_isSet;
}

bool OAIEntireDetectResponse::is_lower_margins_Valid() const{
    return m_lower_margins_isValid;
}

qint32 OAIEntireDetectResponse::getPeriod() const {
    return m_period;
}
void OAIEntireDetectResponse::setPeriod(const qint32 &period) {
    m_period = period;
    m_period_isSet = true;
}

bool OAIEntireDetectResponse::is_period_Set() const{
    return m_period_isSet;
}

bool OAIEntireDetectResponse::is_period_Valid() const{
    return m_period_isValid;
}

QList<float> OAIEntireDetectResponse::getUpperMargins() const {
    return m_upper_margins;
}
void OAIEntireDetectResponse::setUpperMargins(const QList<float> &upper_margins) {
    m_upper_margins = upper_margins;
    m_upper_margins_isSet = true;
}

bool OAIEntireDetectResponse::is_upper_margins_Set() const{
    return m_upper_margins_isSet;
}

bool OAIEntireDetectResponse::is_upper_margins_Valid() const{
    return m_upper_margins_isValid;
}

bool OAIEntireDetectResponse::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_expected_values.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_anomaly.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_negative_anomaly.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_positive_anomaly.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_lower_margins.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_upper_margins.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIEntireDetectResponse::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_expected_values_isValid && m_is_anomaly_isValid && m_is_negative_anomaly_isValid && m_is_positive_anomaly_isValid && m_lower_margins_isValid && m_period_isValid && m_upper_margins_isValid && true;
}

} // namespace OpenAPI
