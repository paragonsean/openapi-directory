/**
 * DeploymentAdminClient
 * Deployment Admin Client.
 *
 * The version of the OpenAPI document: 2019-01-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The SecretDescriptor model module.
 * @module model/SecretDescriptor
 * @version 2019-01-01
 */
class SecretDescriptor {
    /**
     * Constructs a new <code>SecretDescriptor</code>.
     * The secret type-specific descriptor.
     * @alias module:model/SecretDescriptor
     */
    constructor() { 
        
        SecretDescriptor.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>SecretDescriptor</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/SecretDescriptor} obj Optional instance to populate.
     * @return {module:model/SecretDescriptor} The populated <code>SecretDescriptor</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new SecretDescriptor();

            if (data.hasOwnProperty('allowedCharacters')) {
                obj['allowedCharacters'] = ApiClient.convertToType(data['allowedCharacters'], 'String');
            }
            if (data.hasOwnProperty('alternativeDnsNames')) {
                obj['alternativeDnsNames'] = ApiClient.convertToType(data['alternativeDnsNames'], ['String']);
            }
            if (data.hasOwnProperty('alternativeIpAddresses')) {
                obj['alternativeIpAddresses'] = ApiClient.convertToType(data['alternativeIpAddresses'], ['String']);
            }
            if (data.hasOwnProperty('keyLength')) {
                obj['keyLength'] = ApiClient.convertToType(data['keyLength'], 'Number');
            }
            if (data.hasOwnProperty('passwordLength')) {
                obj['passwordLength'] = ApiClient.convertToType(data['passwordLength'], 'Number');
            }
            if (data.hasOwnProperty('passwordValidationRegex')) {
                obj['passwordValidationRegex'] = ApiClient.convertToType(data['passwordValidationRegex'], 'String');
            }
            if (data.hasOwnProperty('rotationStatus')) {
                obj['rotationStatus'] = ApiClient.convertToType(data['rotationStatus'], 'String');
            }
            if (data.hasOwnProperty('secondaryKeyIsActive')) {
                obj['secondaryKeyIsActive'] = ApiClient.convertToType(data['secondaryKeyIsActive'], 'Boolean');
            }
            if (data.hasOwnProperty('subject')) {
                obj['subject'] = ApiClient.convertToType(data['subject'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>SecretDescriptor</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>SecretDescriptor</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['allowedCharacters'] && !(typeof data['allowedCharacters'] === 'string' || data['allowedCharacters'] instanceof String)) {
            throw new Error("Expected the field `allowedCharacters` to be a primitive type in the JSON string but got " + data['allowedCharacters']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['alternativeDnsNames'])) {
            throw new Error("Expected the field `alternativeDnsNames` to be an array in the JSON data but got " + data['alternativeDnsNames']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['alternativeIpAddresses'])) {
            throw new Error("Expected the field `alternativeIpAddresses` to be an array in the JSON data but got " + data['alternativeIpAddresses']);
        }
        // ensure the json data is a string
        if (data['passwordValidationRegex'] && !(typeof data['passwordValidationRegex'] === 'string' || data['passwordValidationRegex'] instanceof String)) {
            throw new Error("Expected the field `passwordValidationRegex` to be a primitive type in the JSON string but got " + data['passwordValidationRegex']);
        }
        // ensure the json data is a string
        if (data['rotationStatus'] && !(typeof data['rotationStatus'] === 'string' || data['rotationStatus'] instanceof String)) {
            throw new Error("Expected the field `rotationStatus` to be a primitive type in the JSON string but got " + data['rotationStatus']);
        }
        // ensure the json data is a string
        if (data['subject'] && !(typeof data['subject'] === 'string' || data['subject'] instanceof String)) {
            throw new Error("Expected the field `subject` to be a primitive type in the JSON string but got " + data['subject']);
        }

        return true;
    }


}



/**
 * The allowed characters in the password
 * @member {String} allowedCharacters
 */
SecretDescriptor.prototype['allowedCharacters'] = undefined;

/**
 * Alternative DNS Names.
 * @member {Array.<String>} alternativeDnsNames
 */
SecretDescriptor.prototype['alternativeDnsNames'] = undefined;

/**
 * The list of alternative IP addresses.
 * @member {Array.<String>} alternativeIpAddresses
 */
SecretDescriptor.prototype['alternativeIpAddresses'] = undefined;

/**
 * The key length.
 * @member {Number} keyLength
 */
SecretDescriptor.prototype['keyLength'] = undefined;

/**
 * The minimum password length is 8 characters, and the maximum password length is 128 characters.
 * @member {Number} passwordLength
 */
SecretDescriptor.prototype['passwordLength'] = undefined;

/**
 * Password validation regular expression.
 * @member {String} passwordValidationRegex
 */
SecretDescriptor.prototype['passwordValidationRegex'] = undefined;

/**
 * The storage account key secret rotation status.
 * @member {module:model/SecretDescriptor.RotationStatusEnum} rotationStatus
 */
SecretDescriptor.prototype['rotationStatus'] = undefined;

/**
 * A value indicating whether the secondary or primary storage account key is active as a secret.
 * @member {Boolean} secondaryKeyIsActive
 */
SecretDescriptor.prototype['secondaryKeyIsActive'] = undefined;

/**
 * Certificate's subject
 * @member {String} subject
 */
SecretDescriptor.prototype['subject'] = undefined;





/**
 * Allowed values for the <code>rotationStatus</code> property.
 * @enum {String}
 * @readonly
 */
SecretDescriptor['RotationStatusEnum'] = {

    /**
     * value: "None"
     * @const
     */
    "None": "None",

    /**
     * value: "PlantNewSak"
     * @const
     */
    "PlantNewSak": "PlantNewSak",

    /**
     * value: "RotateInactiveSak"
     * @const
     */
    "RotateInactiveSak": "RotateInactiveSak",

    /**
     * value: "Complete"
     * @const
     */
    "Complete": "Complete"
};



export default SecretDescriptor;

