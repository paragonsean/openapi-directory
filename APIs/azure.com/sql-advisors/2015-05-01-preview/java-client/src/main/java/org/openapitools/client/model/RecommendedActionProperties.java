/*
 * SqlManagementClient
 * The Azure SQL Database management API provides a RESTful set of web APIs that interact with Azure SQL Database services to manage your databases. The API enables users to create, retrieve, update, and delete databases, servers, and other entities.
 *
 * The version of the OpenAPI document: 2015-05-01-preview
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.RecommendedActionErrorInfo;
import org.openapitools.client.model.RecommendedActionImpactRecord;
import org.openapitools.client.model.RecommendedActionImplementationInfo;
import org.openapitools.client.model.RecommendedActionMetricInfo;
import org.openapitools.client.model.RecommendedActionStateInfo;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Properties for a Database, Server or Elastic Pool Recommended Action.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:23:02.976731-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RecommendedActionProperties {
  public static final String SERIALIZED_NAME_DETAILS = "details";
  @SerializedName(SERIALIZED_NAME_DETAILS)
  private Map<String, Object> details = new HashMap<>();

  public static final String SERIALIZED_NAME_ERROR_DETAILS = "errorDetails";
  @SerializedName(SERIALIZED_NAME_ERROR_DETAILS)
  private RecommendedActionErrorInfo errorDetails;

  public static final String SERIALIZED_NAME_ESTIMATED_IMPACT = "estimatedImpact";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_IMPACT)
  private List<RecommendedActionImpactRecord> estimatedImpact = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXECUTE_ACTION_DURATION = "executeActionDuration";
  @SerializedName(SERIALIZED_NAME_EXECUTE_ACTION_DURATION)
  private String executeActionDuration;

  /**
   * Gets if approval for applying this recommended action was given by user/system.
   */
  @JsonAdapter(ExecuteActionInitiatedByEnum.Adapter.class)
  public enum ExecuteActionInitiatedByEnum {
    USER("User"),
    
    SYSTEM("System");

    private String value;

    ExecuteActionInitiatedByEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ExecuteActionInitiatedByEnum fromValue(String value) {
      for (ExecuteActionInitiatedByEnum b : ExecuteActionInitiatedByEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ExecuteActionInitiatedByEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ExecuteActionInitiatedByEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ExecuteActionInitiatedByEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ExecuteActionInitiatedByEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ExecuteActionInitiatedByEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EXECUTE_ACTION_INITIATED_BY = "executeActionInitiatedBy";
  @SerializedName(SERIALIZED_NAME_EXECUTE_ACTION_INITIATED_BY)
  private ExecuteActionInitiatedByEnum executeActionInitiatedBy;

  public static final String SERIALIZED_NAME_EXECUTE_ACTION_INITIATED_TIME = "executeActionInitiatedTime";
  @SerializedName(SERIALIZED_NAME_EXECUTE_ACTION_INITIATED_TIME)
  private OffsetDateTime executeActionInitiatedTime;

  public static final String SERIALIZED_NAME_EXECUTE_ACTION_START_TIME = "executeActionStartTime";
  @SerializedName(SERIALIZED_NAME_EXECUTE_ACTION_START_TIME)
  private OffsetDateTime executeActionStartTime;

  public static final String SERIALIZED_NAME_IMPLEMENTATION_DETAILS = "implementationDetails";
  @SerializedName(SERIALIZED_NAME_IMPLEMENTATION_DETAILS)
  private RecommendedActionImplementationInfo implementationDetails;

  public static final String SERIALIZED_NAME_IS_ARCHIVED_ACTION = "isArchivedAction";
  @SerializedName(SERIALIZED_NAME_IS_ARCHIVED_ACTION)
  private Boolean isArchivedAction;

  public static final String SERIALIZED_NAME_IS_EXECUTABLE_ACTION = "isExecutableAction";
  @SerializedName(SERIALIZED_NAME_IS_EXECUTABLE_ACTION)
  private Boolean isExecutableAction;

  public static final String SERIALIZED_NAME_IS_REVERTABLE_ACTION = "isRevertableAction";
  @SerializedName(SERIALIZED_NAME_IS_REVERTABLE_ACTION)
  private Boolean isRevertableAction;

  public static final String SERIALIZED_NAME_LAST_REFRESH = "lastRefresh";
  @SerializedName(SERIALIZED_NAME_LAST_REFRESH)
  private OffsetDateTime lastRefresh;

  public static final String SERIALIZED_NAME_LINKED_OBJECTS = "linkedObjects";
  @SerializedName(SERIALIZED_NAME_LINKED_OBJECTS)
  private List<String> linkedObjects = new ArrayList<>();

  public static final String SERIALIZED_NAME_OBSERVED_IMPACT = "observedImpact";
  @SerializedName(SERIALIZED_NAME_OBSERVED_IMPACT)
  private List<RecommendedActionImpactRecord> observedImpact = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECOMMENDATION_REASON = "recommendationReason";
  @SerializedName(SERIALIZED_NAME_RECOMMENDATION_REASON)
  private String recommendationReason;

  public static final String SERIALIZED_NAME_REVERT_ACTION_DURATION = "revertActionDuration";
  @SerializedName(SERIALIZED_NAME_REVERT_ACTION_DURATION)
  private String revertActionDuration;

  /**
   * Gets if approval for reverting this recommended action was given by user/system.
   */
  @JsonAdapter(RevertActionInitiatedByEnum.Adapter.class)
  public enum RevertActionInitiatedByEnum {
    USER("User"),
    
    SYSTEM("System");

    private String value;

    RevertActionInitiatedByEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RevertActionInitiatedByEnum fromValue(String value) {
      for (RevertActionInitiatedByEnum b : RevertActionInitiatedByEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RevertActionInitiatedByEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RevertActionInitiatedByEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RevertActionInitiatedByEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RevertActionInitiatedByEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RevertActionInitiatedByEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REVERT_ACTION_INITIATED_BY = "revertActionInitiatedBy";
  @SerializedName(SERIALIZED_NAME_REVERT_ACTION_INITIATED_BY)
  private RevertActionInitiatedByEnum revertActionInitiatedBy;

  public static final String SERIALIZED_NAME_REVERT_ACTION_INITIATED_TIME = "revertActionInitiatedTime";
  @SerializedName(SERIALIZED_NAME_REVERT_ACTION_INITIATED_TIME)
  private OffsetDateTime revertActionInitiatedTime;

  public static final String SERIALIZED_NAME_REVERT_ACTION_START_TIME = "revertActionStartTime";
  @SerializedName(SERIALIZED_NAME_REVERT_ACTION_START_TIME)
  private OffsetDateTime revertActionStartTime;

  public static final String SERIALIZED_NAME_SCORE = "score";
  @SerializedName(SERIALIZED_NAME_SCORE)
  private Integer score;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private RecommendedActionStateInfo state;

  public static final String SERIALIZED_NAME_TIME_SERIES = "timeSeries";
  @SerializedName(SERIALIZED_NAME_TIME_SERIES)
  private List<RecommendedActionMetricInfo> timeSeries = new ArrayList<>();

  public static final String SERIALIZED_NAME_VALID_SINCE = "validSince";
  @SerializedName(SERIALIZED_NAME_VALID_SINCE)
  private OffsetDateTime validSince;

  public RecommendedActionProperties() {
  }

  public RecommendedActionProperties(
     Map<String, Object> details, 
     List<RecommendedActionImpactRecord> estimatedImpact, 
     String executeActionDuration, 
     ExecuteActionInitiatedByEnum executeActionInitiatedBy, 
     OffsetDateTime executeActionInitiatedTime, 
     OffsetDateTime executeActionStartTime, 
     Boolean isArchivedAction, 
     Boolean isExecutableAction, 
     Boolean isRevertableAction, 
     OffsetDateTime lastRefresh, 
     List<String> linkedObjects, 
     List<RecommendedActionImpactRecord> observedImpact, 
     String recommendationReason, 
     String revertActionDuration, 
     RevertActionInitiatedByEnum revertActionInitiatedBy, 
     OffsetDateTime revertActionInitiatedTime, 
     OffsetDateTime revertActionStartTime, 
     Integer score, 
     List<RecommendedActionMetricInfo> timeSeries, 
     OffsetDateTime validSince
  ) {
    this();
    this.details = details;
    this.estimatedImpact = estimatedImpact;
    this.executeActionDuration = executeActionDuration;
    this.executeActionInitiatedBy = executeActionInitiatedBy;
    this.executeActionInitiatedTime = executeActionInitiatedTime;
    this.executeActionStartTime = executeActionStartTime;
    this.isArchivedAction = isArchivedAction;
    this.isExecutableAction = isExecutableAction;
    this.isRevertableAction = isRevertableAction;
    this.lastRefresh = lastRefresh;
    this.linkedObjects = linkedObjects;
    this.observedImpact = observedImpact;
    this.recommendationReason = recommendationReason;
    this.revertActionDuration = revertActionDuration;
    this.revertActionInitiatedBy = revertActionInitiatedBy;
    this.revertActionInitiatedTime = revertActionInitiatedTime;
    this.revertActionStartTime = revertActionStartTime;
    this.score = score;
    this.timeSeries = timeSeries;
    this.validSince = validSince;
  }

  /**
   * Gets additional details specific to this recommended action.
   * @return details
   */
  @javax.annotation.Nullable
  public Map<String, Object> getDetails() {
    return details;
  }



  public RecommendedActionProperties errorDetails(RecommendedActionErrorInfo errorDetails) {
    this.errorDetails = errorDetails;
    return this;
  }

  /**
   * Get errorDetails
   * @return errorDetails
   */
  @javax.annotation.Nullable
  public RecommendedActionErrorInfo getErrorDetails() {
    return errorDetails;
  }

  public void setErrorDetails(RecommendedActionErrorInfo errorDetails) {
    this.errorDetails = errorDetails;
  }


  /**
   * Gets the estimated impact info for this recommended action e.g., Estimated CPU gain, Estimated Disk Space change
   * @return estimatedImpact
   */
  @javax.annotation.Nullable
  public List<RecommendedActionImpactRecord> getEstimatedImpact() {
    return estimatedImpact;
  }



  /**
   * Gets the time taken for applying this recommended action on user resource. e.g., time taken for index creation
   * @return executeActionDuration
   */
  @javax.annotation.Nullable
  public String getExecuteActionDuration() {
    return executeActionDuration;
  }



  /**
   * Gets if approval for applying this recommended action was given by user/system.
   * @return executeActionInitiatedBy
   */
  @javax.annotation.Nullable
  public ExecuteActionInitiatedByEnum getExecuteActionInitiatedBy() {
    return executeActionInitiatedBy;
  }



  /**
   * Gets the time when this recommended action was approved for execution.
   * @return executeActionInitiatedTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExecuteActionInitiatedTime() {
    return executeActionInitiatedTime;
  }



  /**
   * Gets the time when system started applying this recommended action on the user resource. e.g., index creation start time
   * @return executeActionStartTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExecuteActionStartTime() {
    return executeActionStartTime;
  }



  public RecommendedActionProperties implementationDetails(RecommendedActionImplementationInfo implementationDetails) {
    this.implementationDetails = implementationDetails;
    return this;
  }

  /**
   * Get implementationDetails
   * @return implementationDetails
   */
  @javax.annotation.Nullable
  public RecommendedActionImplementationInfo getImplementationDetails() {
    return implementationDetails;
  }

  public void setImplementationDetails(RecommendedActionImplementationInfo implementationDetails) {
    this.implementationDetails = implementationDetails;
  }


  /**
   * Gets if this recommended action was suggested some time ago but user chose to ignore this and system added a new recommended action again.
   * @return isArchivedAction
   */
  @javax.annotation.Nullable
  public Boolean getIsArchivedAction() {
    return isArchivedAction;
  }



  /**
   * Gets if this recommended action is actionable by user
   * @return isExecutableAction
   */
  @javax.annotation.Nullable
  public Boolean getIsExecutableAction() {
    return isExecutableAction;
  }



  /**
   * Gets if changes applied by this recommended action can be reverted by user
   * @return isRevertableAction
   */
  @javax.annotation.Nullable
  public Boolean getIsRevertableAction() {
    return isRevertableAction;
  }



  /**
   * Gets time when this recommended action was last refreshed.
   * @return lastRefresh
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastRefresh() {
    return lastRefresh;
  }



  /**
   * Gets the linked objects, if any.
   * @return linkedObjects
   */
  @javax.annotation.Nullable
  public List<String> getLinkedObjects() {
    return linkedObjects;
  }



  /**
   * Gets the observed/actual impact info for this recommended action e.g., Actual CPU gain, Actual Disk Space change
   * @return observedImpact
   */
  @javax.annotation.Nullable
  public List<RecommendedActionImpactRecord> getObservedImpact() {
    return observedImpact;
  }



  /**
   * Gets the reason for recommending this action. e.g., DuplicateIndex
   * @return recommendationReason
   */
  @javax.annotation.Nullable
  public String getRecommendationReason() {
    return recommendationReason;
  }



  /**
   * Gets the time taken for reverting changes of this recommended action on user resource. e.g., time taken for dropping the created index.
   * @return revertActionDuration
   */
  @javax.annotation.Nullable
  public String getRevertActionDuration() {
    return revertActionDuration;
  }



  /**
   * Gets if approval for reverting this recommended action was given by user/system.
   * @return revertActionInitiatedBy
   */
  @javax.annotation.Nullable
  public RevertActionInitiatedByEnum getRevertActionInitiatedBy() {
    return revertActionInitiatedBy;
  }



  /**
   * Gets the time when this recommended action was approved for revert.
   * @return revertActionInitiatedTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRevertActionInitiatedTime() {
    return revertActionInitiatedTime;
  }



  /**
   * Gets the time when system started reverting changes of this recommended action on user resource. e.g., time when index drop is executed.
   * @return revertActionStartTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRevertActionStartTime() {
    return revertActionStartTime;
  }



  /**
   * Gets the impact of this recommended action. Possible values are 1 - Low impact, 2 - Medium Impact and 3 - High Impact
   * @return score
   */
  @javax.annotation.Nullable
  public Integer getScore() {
    return score;
  }



  public RecommendedActionProperties state(RecommendedActionStateInfo state) {
    this.state = state;
    return this;
  }

  /**
   * Get state
   * @return state
   */
  @javax.annotation.Nonnull
  public RecommendedActionStateInfo getState() {
    return state;
  }

  public void setState(RecommendedActionStateInfo state) {
    this.state = state;
  }


  /**
   * Gets the time series info of metrics for this recommended action e.g., CPU consumption time series
   * @return timeSeries
   */
  @javax.annotation.Nullable
  public List<RecommendedActionMetricInfo> getTimeSeries() {
    return timeSeries;
  }



  /**
   * Gets the time since when this recommended action is valid.
   * @return validSince
   */
  @javax.annotation.Nullable
  public OffsetDateTime getValidSince() {
    return validSince;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RecommendedActionProperties recommendedActionProperties = (RecommendedActionProperties) o;
    return Objects.equals(this.details, recommendedActionProperties.details) &&
        Objects.equals(this.errorDetails, recommendedActionProperties.errorDetails) &&
        Objects.equals(this.estimatedImpact, recommendedActionProperties.estimatedImpact) &&
        Objects.equals(this.executeActionDuration, recommendedActionProperties.executeActionDuration) &&
        Objects.equals(this.executeActionInitiatedBy, recommendedActionProperties.executeActionInitiatedBy) &&
        Objects.equals(this.executeActionInitiatedTime, recommendedActionProperties.executeActionInitiatedTime) &&
        Objects.equals(this.executeActionStartTime, recommendedActionProperties.executeActionStartTime) &&
        Objects.equals(this.implementationDetails, recommendedActionProperties.implementationDetails) &&
        Objects.equals(this.isArchivedAction, recommendedActionProperties.isArchivedAction) &&
        Objects.equals(this.isExecutableAction, recommendedActionProperties.isExecutableAction) &&
        Objects.equals(this.isRevertableAction, recommendedActionProperties.isRevertableAction) &&
        Objects.equals(this.lastRefresh, recommendedActionProperties.lastRefresh) &&
        Objects.equals(this.linkedObjects, recommendedActionProperties.linkedObjects) &&
        Objects.equals(this.observedImpact, recommendedActionProperties.observedImpact) &&
        Objects.equals(this.recommendationReason, recommendedActionProperties.recommendationReason) &&
        Objects.equals(this.revertActionDuration, recommendedActionProperties.revertActionDuration) &&
        Objects.equals(this.revertActionInitiatedBy, recommendedActionProperties.revertActionInitiatedBy) &&
        Objects.equals(this.revertActionInitiatedTime, recommendedActionProperties.revertActionInitiatedTime) &&
        Objects.equals(this.revertActionStartTime, recommendedActionProperties.revertActionStartTime) &&
        Objects.equals(this.score, recommendedActionProperties.score) &&
        Objects.equals(this.state, recommendedActionProperties.state) &&
        Objects.equals(this.timeSeries, recommendedActionProperties.timeSeries) &&
        Objects.equals(this.validSince, recommendedActionProperties.validSince);
  }

  @Override
  public int hashCode() {
    return Objects.hash(details, errorDetails, estimatedImpact, executeActionDuration, executeActionInitiatedBy, executeActionInitiatedTime, executeActionStartTime, implementationDetails, isArchivedAction, isExecutableAction, isRevertableAction, lastRefresh, linkedObjects, observedImpact, recommendationReason, revertActionDuration, revertActionInitiatedBy, revertActionInitiatedTime, revertActionStartTime, score, state, timeSeries, validSince);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RecommendedActionProperties {\n");
    sb.append("    details: ").append(toIndentedString(details)).append("\n");
    sb.append("    errorDetails: ").append(toIndentedString(errorDetails)).append("\n");
    sb.append("    estimatedImpact: ").append(toIndentedString(estimatedImpact)).append("\n");
    sb.append("    executeActionDuration: ").append(toIndentedString(executeActionDuration)).append("\n");
    sb.append("    executeActionInitiatedBy: ").append(toIndentedString(executeActionInitiatedBy)).append("\n");
    sb.append("    executeActionInitiatedTime: ").append(toIndentedString(executeActionInitiatedTime)).append("\n");
    sb.append("    executeActionStartTime: ").append(toIndentedString(executeActionStartTime)).append("\n");
    sb.append("    implementationDetails: ").append(toIndentedString(implementationDetails)).append("\n");
    sb.append("    isArchivedAction: ").append(toIndentedString(isArchivedAction)).append("\n");
    sb.append("    isExecutableAction: ").append(toIndentedString(isExecutableAction)).append("\n");
    sb.append("    isRevertableAction: ").append(toIndentedString(isRevertableAction)).append("\n");
    sb.append("    lastRefresh: ").append(toIndentedString(lastRefresh)).append("\n");
    sb.append("    linkedObjects: ").append(toIndentedString(linkedObjects)).append("\n");
    sb.append("    observedImpact: ").append(toIndentedString(observedImpact)).append("\n");
    sb.append("    recommendationReason: ").append(toIndentedString(recommendationReason)).append("\n");
    sb.append("    revertActionDuration: ").append(toIndentedString(revertActionDuration)).append("\n");
    sb.append("    revertActionInitiatedBy: ").append(toIndentedString(revertActionInitiatedBy)).append("\n");
    sb.append("    revertActionInitiatedTime: ").append(toIndentedString(revertActionInitiatedTime)).append("\n");
    sb.append("    revertActionStartTime: ").append(toIndentedString(revertActionStartTime)).append("\n");
    sb.append("    score: ").append(toIndentedString(score)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    timeSeries: ").append(toIndentedString(timeSeries)).append("\n");
    sb.append("    validSince: ").append(toIndentedString(validSince)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("details");
    openapiFields.add("errorDetails");
    openapiFields.add("estimatedImpact");
    openapiFields.add("executeActionDuration");
    openapiFields.add("executeActionInitiatedBy");
    openapiFields.add("executeActionInitiatedTime");
    openapiFields.add("executeActionStartTime");
    openapiFields.add("implementationDetails");
    openapiFields.add("isArchivedAction");
    openapiFields.add("isExecutableAction");
    openapiFields.add("isRevertableAction");
    openapiFields.add("lastRefresh");
    openapiFields.add("linkedObjects");
    openapiFields.add("observedImpact");
    openapiFields.add("recommendationReason");
    openapiFields.add("revertActionDuration");
    openapiFields.add("revertActionInitiatedBy");
    openapiFields.add("revertActionInitiatedTime");
    openapiFields.add("revertActionStartTime");
    openapiFields.add("score");
    openapiFields.add("state");
    openapiFields.add("timeSeries");
    openapiFields.add("validSince");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("state");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RecommendedActionProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RecommendedActionProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RecommendedActionProperties is not found in the empty JSON string", RecommendedActionProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RecommendedActionProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RecommendedActionProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : RecommendedActionProperties.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `errorDetails`
      if (jsonObj.get("errorDetails") != null && !jsonObj.get("errorDetails").isJsonNull()) {
        RecommendedActionErrorInfo.validateJsonElement(jsonObj.get("errorDetails"));
      }
      if (jsonObj.get("estimatedImpact") != null && !jsonObj.get("estimatedImpact").isJsonNull()) {
        JsonArray jsonArrayestimatedImpact = jsonObj.getAsJsonArray("estimatedImpact");
        if (jsonArrayestimatedImpact != null) {
          // ensure the json data is an array
          if (!jsonObj.get("estimatedImpact").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `estimatedImpact` to be an array in the JSON string but got `%s`", jsonObj.get("estimatedImpact").toString()));
          }

          // validate the optional field `estimatedImpact` (array)
          for (int i = 0; i < jsonArrayestimatedImpact.size(); i++) {
            RecommendedActionImpactRecord.validateJsonElement(jsonArrayestimatedImpact.get(i));
          };
        }
      }
      if ((jsonObj.get("executeActionDuration") != null && !jsonObj.get("executeActionDuration").isJsonNull()) && !jsonObj.get("executeActionDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `executeActionDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("executeActionDuration").toString()));
      }
      if ((jsonObj.get("executeActionInitiatedBy") != null && !jsonObj.get("executeActionInitiatedBy").isJsonNull()) && !jsonObj.get("executeActionInitiatedBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `executeActionInitiatedBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("executeActionInitiatedBy").toString()));
      }
      // validate the optional field `executeActionInitiatedBy`
      if (jsonObj.get("executeActionInitiatedBy") != null && !jsonObj.get("executeActionInitiatedBy").isJsonNull()) {
        ExecuteActionInitiatedByEnum.validateJsonElement(jsonObj.get("executeActionInitiatedBy"));
      }
      // validate the optional field `implementationDetails`
      if (jsonObj.get("implementationDetails") != null && !jsonObj.get("implementationDetails").isJsonNull()) {
        RecommendedActionImplementationInfo.validateJsonElement(jsonObj.get("implementationDetails"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("linkedObjects") != null && !jsonObj.get("linkedObjects").isJsonNull() && !jsonObj.get("linkedObjects").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `linkedObjects` to be an array in the JSON string but got `%s`", jsonObj.get("linkedObjects").toString()));
      }
      if (jsonObj.get("observedImpact") != null && !jsonObj.get("observedImpact").isJsonNull()) {
        JsonArray jsonArrayobservedImpact = jsonObj.getAsJsonArray("observedImpact");
        if (jsonArrayobservedImpact != null) {
          // ensure the json data is an array
          if (!jsonObj.get("observedImpact").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `observedImpact` to be an array in the JSON string but got `%s`", jsonObj.get("observedImpact").toString()));
          }

          // validate the optional field `observedImpact` (array)
          for (int i = 0; i < jsonArrayobservedImpact.size(); i++) {
            RecommendedActionImpactRecord.validateJsonElement(jsonArrayobservedImpact.get(i));
          };
        }
      }
      if ((jsonObj.get("recommendationReason") != null && !jsonObj.get("recommendationReason").isJsonNull()) && !jsonObj.get("recommendationReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recommendationReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recommendationReason").toString()));
      }
      if ((jsonObj.get("revertActionDuration") != null && !jsonObj.get("revertActionDuration").isJsonNull()) && !jsonObj.get("revertActionDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revertActionDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revertActionDuration").toString()));
      }
      if ((jsonObj.get("revertActionInitiatedBy") != null && !jsonObj.get("revertActionInitiatedBy").isJsonNull()) && !jsonObj.get("revertActionInitiatedBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revertActionInitiatedBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revertActionInitiatedBy").toString()));
      }
      // validate the optional field `revertActionInitiatedBy`
      if (jsonObj.get("revertActionInitiatedBy") != null && !jsonObj.get("revertActionInitiatedBy").isJsonNull()) {
        RevertActionInitiatedByEnum.validateJsonElement(jsonObj.get("revertActionInitiatedBy"));
      }
      // validate the required field `state`
      RecommendedActionStateInfo.validateJsonElement(jsonObj.get("state"));
      if (jsonObj.get("timeSeries") != null && !jsonObj.get("timeSeries").isJsonNull()) {
        JsonArray jsonArraytimeSeries = jsonObj.getAsJsonArray("timeSeries");
        if (jsonArraytimeSeries != null) {
          // ensure the json data is an array
          if (!jsonObj.get("timeSeries").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `timeSeries` to be an array in the JSON string but got `%s`", jsonObj.get("timeSeries").toString()));
          }

          // validate the optional field `timeSeries` (array)
          for (int i = 0; i < jsonArraytimeSeries.size(); i++) {
            RecommendedActionMetricInfo.validateJsonElement(jsonArraytimeSeries.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RecommendedActionProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RecommendedActionProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RecommendedActionProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RecommendedActionProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<RecommendedActionProperties>() {
           @Override
           public void write(JsonWriter out, RecommendedActionProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RecommendedActionProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RecommendedActionProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RecommendedActionProperties
   * @throws IOException if the JSON string is invalid with respect to RecommendedActionProperties
   */
  public static RecommendedActionProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RecommendedActionProperties.class);
  }

  /**
   * Convert an instance of RecommendedActionProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

