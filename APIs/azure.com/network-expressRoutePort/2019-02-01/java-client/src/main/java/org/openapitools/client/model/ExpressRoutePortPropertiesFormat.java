/*
 * NetworkManagementClient
 * The Microsoft Azure Network management API provides a RESTful set of web services that interact with Microsoft Azure Networks service to manage your network resources. The API has entities that capture the relationship between an end user and the Microsoft Azure Networks service.
 *
 * The version of the OpenAPI document: 2019-02-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ExpressRouteLink;
import org.openapitools.client.model.ExpressRoutePortPropertiesFormatCircuitsInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Properties specific to ExpressRoutePort resources.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:21:40.251775-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExpressRoutePortPropertiesFormat {
  public static final String SERIALIZED_NAME_ALLOCATION_DATE = "allocationDate";
  @SerializedName(SERIALIZED_NAME_ALLOCATION_DATE)
  private String allocationDate;

  public static final String SERIALIZED_NAME_BANDWIDTH_IN_GBPS = "bandwidthInGbps";
  @SerializedName(SERIALIZED_NAME_BANDWIDTH_IN_GBPS)
  private Integer bandwidthInGbps;

  public static final String SERIALIZED_NAME_CIRCUITS = "circuits";
  @SerializedName(SERIALIZED_NAME_CIRCUITS)
  private List<ExpressRoutePortPropertiesFormatCircuitsInner> circuits = new ArrayList<>();

  /**
   * Encapsulation method on physical ports.
   */
  @JsonAdapter(EncapsulationEnum.Adapter.class)
  public enum EncapsulationEnum {
    DOT1_Q("Dot1Q"),
    
    QIN_Q("QinQ");

    private String value;

    EncapsulationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EncapsulationEnum fromValue(String value) {
      for (EncapsulationEnum b : EncapsulationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EncapsulationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EncapsulationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EncapsulationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EncapsulationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EncapsulationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ENCAPSULATION = "encapsulation";
  @SerializedName(SERIALIZED_NAME_ENCAPSULATION)
  private EncapsulationEnum encapsulation;

  public static final String SERIALIZED_NAME_ETHER_TYPE = "etherType";
  @SerializedName(SERIALIZED_NAME_ETHER_TYPE)
  private String etherType;

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private List<ExpressRouteLink> links = new ArrayList<>();

  public static final String SERIALIZED_NAME_MTU = "mtu";
  @SerializedName(SERIALIZED_NAME_MTU)
  private String mtu;

  public static final String SERIALIZED_NAME_PEERING_LOCATION = "peeringLocation";
  @SerializedName(SERIALIZED_NAME_PEERING_LOCATION)
  private String peeringLocation;

  public static final String SERIALIZED_NAME_PROVISIONED_BANDWIDTH_IN_GBPS = "provisionedBandwidthInGbps";
  @SerializedName(SERIALIZED_NAME_PROVISIONED_BANDWIDTH_IN_GBPS)
  private BigDecimal provisionedBandwidthInGbps;

  public static final String SERIALIZED_NAME_PROVISIONING_STATE = "provisioningState";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE)
  private String provisioningState;

  public static final String SERIALIZED_NAME_RESOURCE_GUID = "resourceGuid";
  @SerializedName(SERIALIZED_NAME_RESOURCE_GUID)
  private String resourceGuid;

  public ExpressRoutePortPropertiesFormat() {
  }

  public ExpressRoutePortPropertiesFormat(
     String allocationDate, 
     List<ExpressRoutePortPropertiesFormatCircuitsInner> circuits, 
     String etherType, 
     String mtu, 
     BigDecimal provisionedBandwidthInGbps, 
     String provisioningState
  ) {
    this();
    this.allocationDate = allocationDate;
    this.circuits = circuits;
    this.etherType = etherType;
    this.mtu = mtu;
    this.provisionedBandwidthInGbps = provisionedBandwidthInGbps;
    this.provisioningState = provisioningState;
  }

  /**
   * Date of the physical port allocation to be used in Letter of Authorization.
   * @return allocationDate
   */
  @javax.annotation.Nullable
  public String getAllocationDate() {
    return allocationDate;
  }



  public ExpressRoutePortPropertiesFormat bandwidthInGbps(Integer bandwidthInGbps) {
    this.bandwidthInGbps = bandwidthInGbps;
    return this;
  }

  /**
   * Bandwidth of procured ports in Gbps
   * @return bandwidthInGbps
   */
  @javax.annotation.Nullable
  public Integer getBandwidthInGbps() {
    return bandwidthInGbps;
  }

  public void setBandwidthInGbps(Integer bandwidthInGbps) {
    this.bandwidthInGbps = bandwidthInGbps;
  }


  /**
   * Reference the ExpressRoute circuit(s) that are provisioned on this ExpressRoutePort resource.
   * @return circuits
   */
  @javax.annotation.Nullable
  public List<ExpressRoutePortPropertiesFormatCircuitsInner> getCircuits() {
    return circuits;
  }



  public ExpressRoutePortPropertiesFormat encapsulation(EncapsulationEnum encapsulation) {
    this.encapsulation = encapsulation;
    return this;
  }

  /**
   * Encapsulation method on physical ports.
   * @return encapsulation
   */
  @javax.annotation.Nullable
  public EncapsulationEnum getEncapsulation() {
    return encapsulation;
  }

  public void setEncapsulation(EncapsulationEnum encapsulation) {
    this.encapsulation = encapsulation;
  }


  /**
   * Ether type of the physical port.
   * @return etherType
   */
  @javax.annotation.Nullable
  public String getEtherType() {
    return etherType;
  }



  public ExpressRoutePortPropertiesFormat links(List<ExpressRouteLink> links) {
    this.links = links;
    return this;
  }

  public ExpressRoutePortPropertiesFormat addLinksItem(ExpressRouteLink linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

  /**
   * The set of physical links of the ExpressRoutePort resource
   * @return links
   */
  @javax.annotation.Nullable
  public List<ExpressRouteLink> getLinks() {
    return links;
  }

  public void setLinks(List<ExpressRouteLink> links) {
    this.links = links;
  }


  /**
   * Maximum transmission unit of the physical port pair(s)
   * @return mtu
   */
  @javax.annotation.Nullable
  public String getMtu() {
    return mtu;
  }



  public ExpressRoutePortPropertiesFormat peeringLocation(String peeringLocation) {
    this.peeringLocation = peeringLocation;
    return this;
  }

  /**
   * The name of the peering location that the ExpressRoutePort is mapped to physically.
   * @return peeringLocation
   */
  @javax.annotation.Nullable
  public String getPeeringLocation() {
    return peeringLocation;
  }

  public void setPeeringLocation(String peeringLocation) {
    this.peeringLocation = peeringLocation;
  }


  /**
   * Aggregate Gbps of associated circuit bandwidths.
   * @return provisionedBandwidthInGbps
   */
  @javax.annotation.Nullable
  public BigDecimal getProvisionedBandwidthInGbps() {
    return provisionedBandwidthInGbps;
  }



  /**
   * The provisioning state of the ExpressRoutePort resource. Possible values are: &#39;Succeeded&#39;, &#39;Updating&#39;, &#39;Deleting&#39;, and &#39;Failed&#39;.
   * @return provisioningState
   */
  @javax.annotation.Nullable
  public String getProvisioningState() {
    return provisioningState;
  }



  public ExpressRoutePortPropertiesFormat resourceGuid(String resourceGuid) {
    this.resourceGuid = resourceGuid;
    return this;
  }

  /**
   * The resource GUID property of the ExpressRoutePort resource.
   * @return resourceGuid
   */
  @javax.annotation.Nullable
  public String getResourceGuid() {
    return resourceGuid;
  }

  public void setResourceGuid(String resourceGuid) {
    this.resourceGuid = resourceGuid;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExpressRoutePortPropertiesFormat expressRoutePortPropertiesFormat = (ExpressRoutePortPropertiesFormat) o;
    return Objects.equals(this.allocationDate, expressRoutePortPropertiesFormat.allocationDate) &&
        Objects.equals(this.bandwidthInGbps, expressRoutePortPropertiesFormat.bandwidthInGbps) &&
        Objects.equals(this.circuits, expressRoutePortPropertiesFormat.circuits) &&
        Objects.equals(this.encapsulation, expressRoutePortPropertiesFormat.encapsulation) &&
        Objects.equals(this.etherType, expressRoutePortPropertiesFormat.etherType) &&
        Objects.equals(this.links, expressRoutePortPropertiesFormat.links) &&
        Objects.equals(this.mtu, expressRoutePortPropertiesFormat.mtu) &&
        Objects.equals(this.peeringLocation, expressRoutePortPropertiesFormat.peeringLocation) &&
        Objects.equals(this.provisionedBandwidthInGbps, expressRoutePortPropertiesFormat.provisionedBandwidthInGbps) &&
        Objects.equals(this.provisioningState, expressRoutePortPropertiesFormat.provisioningState) &&
        Objects.equals(this.resourceGuid, expressRoutePortPropertiesFormat.resourceGuid);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allocationDate, bandwidthInGbps, circuits, encapsulation, etherType, links, mtu, peeringLocation, provisionedBandwidthInGbps, provisioningState, resourceGuid);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExpressRoutePortPropertiesFormat {\n");
    sb.append("    allocationDate: ").append(toIndentedString(allocationDate)).append("\n");
    sb.append("    bandwidthInGbps: ").append(toIndentedString(bandwidthInGbps)).append("\n");
    sb.append("    circuits: ").append(toIndentedString(circuits)).append("\n");
    sb.append("    encapsulation: ").append(toIndentedString(encapsulation)).append("\n");
    sb.append("    etherType: ").append(toIndentedString(etherType)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    mtu: ").append(toIndentedString(mtu)).append("\n");
    sb.append("    peeringLocation: ").append(toIndentedString(peeringLocation)).append("\n");
    sb.append("    provisionedBandwidthInGbps: ").append(toIndentedString(provisionedBandwidthInGbps)).append("\n");
    sb.append("    provisioningState: ").append(toIndentedString(provisioningState)).append("\n");
    sb.append("    resourceGuid: ").append(toIndentedString(resourceGuid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allocationDate");
    openapiFields.add("bandwidthInGbps");
    openapiFields.add("circuits");
    openapiFields.add("encapsulation");
    openapiFields.add("etherType");
    openapiFields.add("links");
    openapiFields.add("mtu");
    openapiFields.add("peeringLocation");
    openapiFields.add("provisionedBandwidthInGbps");
    openapiFields.add("provisioningState");
    openapiFields.add("resourceGuid");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExpressRoutePortPropertiesFormat
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExpressRoutePortPropertiesFormat.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExpressRoutePortPropertiesFormat is not found in the empty JSON string", ExpressRoutePortPropertiesFormat.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExpressRoutePortPropertiesFormat.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExpressRoutePortPropertiesFormat` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("allocationDate") != null && !jsonObj.get("allocationDate").isJsonNull()) && !jsonObj.get("allocationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `allocationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("allocationDate").toString()));
      }
      if (jsonObj.get("circuits") != null && !jsonObj.get("circuits").isJsonNull()) {
        JsonArray jsonArraycircuits = jsonObj.getAsJsonArray("circuits");
        if (jsonArraycircuits != null) {
          // ensure the json data is an array
          if (!jsonObj.get("circuits").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `circuits` to be an array in the JSON string but got `%s`", jsonObj.get("circuits").toString()));
          }

          // validate the optional field `circuits` (array)
          for (int i = 0; i < jsonArraycircuits.size(); i++) {
            ExpressRoutePortPropertiesFormatCircuitsInner.validateJsonElement(jsonArraycircuits.get(i));
          };
        }
      }
      if ((jsonObj.get("encapsulation") != null && !jsonObj.get("encapsulation").isJsonNull()) && !jsonObj.get("encapsulation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `encapsulation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("encapsulation").toString()));
      }
      // validate the optional field `encapsulation`
      if (jsonObj.get("encapsulation") != null && !jsonObj.get("encapsulation").isJsonNull()) {
        EncapsulationEnum.validateJsonElement(jsonObj.get("encapsulation"));
      }
      if ((jsonObj.get("etherType") != null && !jsonObj.get("etherType").isJsonNull()) && !jsonObj.get("etherType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etherType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etherType").toString()));
      }
      if (jsonObj.get("links") != null && !jsonObj.get("links").isJsonNull()) {
        JsonArray jsonArraylinks = jsonObj.getAsJsonArray("links");
        if (jsonArraylinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("links").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `links` to be an array in the JSON string but got `%s`", jsonObj.get("links").toString()));
          }

          // validate the optional field `links` (array)
          for (int i = 0; i < jsonArraylinks.size(); i++) {
            ExpressRouteLink.validateJsonElement(jsonArraylinks.get(i));
          };
        }
      }
      if ((jsonObj.get("mtu") != null && !jsonObj.get("mtu").isJsonNull()) && !jsonObj.get("mtu").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mtu` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mtu").toString()));
      }
      if ((jsonObj.get("peeringLocation") != null && !jsonObj.get("peeringLocation").isJsonNull()) && !jsonObj.get("peeringLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `peeringLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("peeringLocation").toString()));
      }
      if ((jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) && !jsonObj.get("provisioningState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioningState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioningState").toString()));
      }
      if ((jsonObj.get("resourceGuid") != null && !jsonObj.get("resourceGuid").isJsonNull()) && !jsonObj.get("resourceGuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resourceGuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resourceGuid").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExpressRoutePortPropertiesFormat.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExpressRoutePortPropertiesFormat' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExpressRoutePortPropertiesFormat> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExpressRoutePortPropertiesFormat.class));

       return (TypeAdapter<T>) new TypeAdapter<ExpressRoutePortPropertiesFormat>() {
           @Override
           public void write(JsonWriter out, ExpressRoutePortPropertiesFormat value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExpressRoutePortPropertiesFormat read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExpressRoutePortPropertiesFormat given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExpressRoutePortPropertiesFormat
   * @throws IOException if the JSON string is invalid with respect to ExpressRoutePortPropertiesFormat
   */
  public static ExpressRoutePortPropertiesFormat fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExpressRoutePortPropertiesFormat.class);
  }

  /**
   * Convert an instance of ExpressRoutePortPropertiesFormat to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

