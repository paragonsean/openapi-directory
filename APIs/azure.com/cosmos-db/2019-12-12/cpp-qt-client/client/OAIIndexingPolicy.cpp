/**
 * Cosmos DB
 * Azure Cosmos DB Database Service Resource Provider REST API
 *
 * The version of the OpenAPI document: 2019-12-12
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIIndexingPolicy.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIIndexingPolicy::OAIIndexingPolicy(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIIndexingPolicy::OAIIndexingPolicy() {
    this->initializeModel();
}

OAIIndexingPolicy::~OAIIndexingPolicy() {}

void OAIIndexingPolicy::initializeModel() {

    m_automatic_isSet = false;
    m_automatic_isValid = false;

    m_composite_indexes_isSet = false;
    m_composite_indexes_isValid = false;

    m_excluded_paths_isSet = false;
    m_excluded_paths_isValid = false;

    m_included_paths_isSet = false;
    m_included_paths_isValid = false;

    m_indexing_mode_isSet = false;
    m_indexing_mode_isValid = false;

    m_spatial_indexes_isSet = false;
    m_spatial_indexes_isValid = false;
}

void OAIIndexingPolicy::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIIndexingPolicy::fromJsonObject(QJsonObject json) {

    m_automatic_isValid = ::OpenAPI::fromJsonValue(m_automatic, json[QString("automatic")]);
    m_automatic_isSet = !json[QString("automatic")].isNull() && m_automatic_isValid;

    if(json["compositeIndexes"].isArray()){
        auto arr = json["compositeIndexes"].toArray();
        m_composite_indexes_isValid = true;
        if(arr.count() > 0) {
            for (const QJsonValue jval : arr) {
                QList<OAICompositePath> item;
                m_composite_indexes_isValid &= ::OpenAPI::fromJsonValue(item, jval);
                m_composite_indexes_isSet = !jval.isNull() && m_composite_indexes_isValid;
                m_composite_indexes.push_back(item);
            }
        }
    }

    m_excluded_paths_isValid = ::OpenAPI::fromJsonValue(m_excluded_paths, json[QString("excludedPaths")]);
    m_excluded_paths_isSet = !json[QString("excludedPaths")].isNull() && m_excluded_paths_isValid;

    m_included_paths_isValid = ::OpenAPI::fromJsonValue(m_included_paths, json[QString("includedPaths")]);
    m_included_paths_isSet = !json[QString("includedPaths")].isNull() && m_included_paths_isValid;

    m_indexing_mode_isValid = ::OpenAPI::fromJsonValue(m_indexing_mode, json[QString("indexingMode")]);
    m_indexing_mode_isSet = !json[QString("indexingMode")].isNull() && m_indexing_mode_isValid;

    m_spatial_indexes_isValid = ::OpenAPI::fromJsonValue(m_spatial_indexes, json[QString("spatialIndexes")]);
    m_spatial_indexes_isSet = !json[QString("spatialIndexes")].isNull() && m_spatial_indexes_isValid;
}

QString OAIIndexingPolicy::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIIndexingPolicy::asJsonObject() const {
    QJsonObject obj;
    if (m_automatic_isSet) {
        obj.insert(QString("automatic"), ::OpenAPI::toJsonValue(m_automatic));
    }
    if (m_composite_indexes.size() > 0) {
        
        obj.insert(QString("compositeIndexes"), toJsonValue(m_composite_indexes));
    }
    if (m_excluded_paths.size() > 0) {
        obj.insert(QString("excludedPaths"), ::OpenAPI::toJsonValue(m_excluded_paths));
    }
    if (m_included_paths.size() > 0) {
        obj.insert(QString("includedPaths"), ::OpenAPI::toJsonValue(m_included_paths));
    }
    if (m_indexing_mode_isSet) {
        obj.insert(QString("indexingMode"), ::OpenAPI::toJsonValue(m_indexing_mode));
    }
    if (m_spatial_indexes.size() > 0) {
        obj.insert(QString("spatialIndexes"), ::OpenAPI::toJsonValue(m_spatial_indexes));
    }
    return obj;
}

bool OAIIndexingPolicy::isAutomatic() const {
    return m_automatic;
}
void OAIIndexingPolicy::setAutomatic(const bool &automatic) {
    m_automatic = automatic;
    m_automatic_isSet = true;
}

bool OAIIndexingPolicy::is_automatic_Set() const{
    return m_automatic_isSet;
}

bool OAIIndexingPolicy::is_automatic_Valid() const{
    return m_automatic_isValid;
}

QList<QList> OAIIndexingPolicy::getCompositeIndexes() const {
    return m_composite_indexes;
}
void OAIIndexingPolicy::setCompositeIndexes(const QList<QList> &composite_indexes) {
    m_composite_indexes = composite_indexes;
    m_composite_indexes_isSet = true;
}

bool OAIIndexingPolicy::is_composite_indexes_Set() const{
    return m_composite_indexes_isSet;
}

bool OAIIndexingPolicy::is_composite_indexes_Valid() const{
    return m_composite_indexes_isValid;
}

QList<OAIExcludedPath> OAIIndexingPolicy::getExcludedPaths() const {
    return m_excluded_paths;
}
void OAIIndexingPolicy::setExcludedPaths(const QList<OAIExcludedPath> &excluded_paths) {
    m_excluded_paths = excluded_paths;
    m_excluded_paths_isSet = true;
}

bool OAIIndexingPolicy::is_excluded_paths_Set() const{
    return m_excluded_paths_isSet;
}

bool OAIIndexingPolicy::is_excluded_paths_Valid() const{
    return m_excluded_paths_isValid;
}

QList<OAIIncludedPath> OAIIndexingPolicy::getIncludedPaths() const {
    return m_included_paths;
}
void OAIIndexingPolicy::setIncludedPaths(const QList<OAIIncludedPath> &included_paths) {
    m_included_paths = included_paths;
    m_included_paths_isSet = true;
}

bool OAIIndexingPolicy::is_included_paths_Set() const{
    return m_included_paths_isSet;
}

bool OAIIndexingPolicy::is_included_paths_Valid() const{
    return m_included_paths_isValid;
}

QString OAIIndexingPolicy::getIndexingMode() const {
    return m_indexing_mode;
}
void OAIIndexingPolicy::setIndexingMode(const QString &indexing_mode) {
    m_indexing_mode = indexing_mode;
    m_indexing_mode_isSet = true;
}

bool OAIIndexingPolicy::is_indexing_mode_Set() const{
    return m_indexing_mode_isSet;
}

bool OAIIndexingPolicy::is_indexing_mode_Valid() const{
    return m_indexing_mode_isValid;
}

QList<OAISpatialSpec> OAIIndexingPolicy::getSpatialIndexes() const {
    return m_spatial_indexes;
}
void OAIIndexingPolicy::setSpatialIndexes(const QList<OAISpatialSpec> &spatial_indexes) {
    m_spatial_indexes = spatial_indexes;
    m_spatial_indexes_isSet = true;
}

bool OAIIndexingPolicy::is_spatial_indexes_Set() const{
    return m_spatial_indexes_isSet;
}

bool OAIIndexingPolicy::is_spatial_indexes_Valid() const{
    return m_spatial_indexes_isValid;
}

bool OAIIndexingPolicy::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_automatic_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_composite_indexes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_excluded_paths.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_included_paths.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_indexing_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_spatial_indexes.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIIndexingPolicy::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
