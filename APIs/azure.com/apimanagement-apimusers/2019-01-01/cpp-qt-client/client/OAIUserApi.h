/**
 * ApiManagementClient
 * Use these REST APIs for performing operations on User entity in Azure API Management deployment. The User entity in API Management represents the developers that call the APIs of the products to which they are subscribed.
 *
 * The version of the OpenAPI document: 2019-01-01
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIUserApi_H
#define OAI_OAIUserApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include "OAIUser_CreateOrUpdate_request.h"
#include "OAIUser_Get_200_response.h"
#include "OAIUser_ListByService_200_response.h"
#include "OAIUser_ListByService_default_response.h"
#include "OAIUser_Update_request.h"
#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIUserApi : public QObject {
    Q_OBJECT

public:
    OAIUserApi(const int timeOut = 0);
    ~OAIUserApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  resource_group_name QString [required]
    * @param[in]  service_name QString [required]
    * @param[in]  user_id QString [required]
    * @param[in]  api_version QString [required]
    * @param[in]  subscription_id QString [required]
    * @param[in]  parameters OAIUser_CreateOrUpdate_request [required]
    * @param[in]  notify bool [optional]
    * @param[in]  if_match QString [optional]
    */
    virtual void userCreateOrUpdate(const QString &resource_group_name, const QString &service_name, const QString &user_id, const QString &api_version, const QString &subscription_id, const OAIUser_CreateOrUpdate_request &parameters, const ::OpenAPI::OptionalParam<bool> &notify = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<QString> &if_match = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  resource_group_name QString [required]
    * @param[in]  service_name QString [required]
    * @param[in]  user_id QString [required]
    * @param[in]  if_match QString [required]
    * @param[in]  api_version QString [required]
    * @param[in]  subscription_id QString [required]
    * @param[in]  delete_subscriptions bool [optional]
    * @param[in]  notify bool [optional]
    * @param[in]  app_type QString [optional]
    */
    virtual void userDelete(const QString &resource_group_name, const QString &service_name, const QString &user_id, const QString &if_match, const QString &api_version, const QString &subscription_id, const ::OpenAPI::OptionalParam<bool> &delete_subscriptions = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<bool> &notify = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<QString> &app_type = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  resource_group_name QString [required]
    * @param[in]  service_name QString [required]
    * @param[in]  user_id QString [required]
    * @param[in]  api_version QString [required]
    * @param[in]  subscription_id QString [required]
    */
    virtual void userGet(const QString &resource_group_name, const QString &service_name, const QString &user_id, const QString &api_version, const QString &subscription_id);

    /**
    * @param[in]  resource_group_name QString [required]
    * @param[in]  service_name QString [required]
    * @param[in]  user_id QString [required]
    * @param[in]  api_version QString [required]
    * @param[in]  subscription_id QString [required]
    */
    virtual void userGetEntityTag(const QString &resource_group_name, const QString &service_name, const QString &user_id, const QString &api_version, const QString &subscription_id);

    /**
    * @param[in]  resource_group_name QString [required]
    * @param[in]  service_name QString [required]
    * @param[in]  api_version QString [required]
    * @param[in]  subscription_id QString [required]
    * @param[in]  filter QString [optional]
    * @param[in]  top qint32 [optional]
    * @param[in]  skip qint32 [optional]
    * @param[in]  expand_groups bool [optional]
    */
    virtual void userListByService(const QString &resource_group_name, const QString &service_name, const QString &api_version, const QString &subscription_id, const ::OpenAPI::OptionalParam<QString> &filter = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<qint32> &top = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &skip = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<bool> &expand_groups = ::OpenAPI::OptionalParam<bool>());

    /**
    * @param[in]  resource_group_name QString [required]
    * @param[in]  service_name QString [required]
    * @param[in]  user_id QString [required]
    * @param[in]  if_match QString [required]
    * @param[in]  api_version QString [required]
    * @param[in]  subscription_id QString [required]
    * @param[in]  parameters OAIUser_Update_request [required]
    */
    virtual void userUpdate(const QString &resource_group_name, const QString &service_name, const QString &user_id, const QString &if_match, const QString &api_version, const QString &subscription_id, const OAIUser_Update_request &parameters);


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void userCreateOrUpdateCallback(OAIHttpRequestWorker *worker);
    void userDeleteCallback(OAIHttpRequestWorker *worker);
    void userGetCallback(OAIHttpRequestWorker *worker);
    void userGetEntityTagCallback(OAIHttpRequestWorker *worker);
    void userListByServiceCallback(OAIHttpRequestWorker *worker);
    void userUpdateCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void userCreateOrUpdateSignal(OAIUser_Get_200_response summary);
    void userDeleteSignal();
    void userGetSignal(OAIUser_Get_200_response summary);
    void userGetEntityTagSignal();
    void userListByServiceSignal(OAIUser_ListByService_200_response summary);
    void userUpdateSignal();


    void userCreateOrUpdateSignalFull(OAIHttpRequestWorker *worker, OAIUser_Get_200_response summary);
    void userDeleteSignalFull(OAIHttpRequestWorker *worker);
    void userGetSignalFull(OAIHttpRequestWorker *worker, OAIUser_Get_200_response summary);
    void userGetEntityTagSignalFull(OAIHttpRequestWorker *worker);
    void userListByServiceSignalFull(OAIHttpRequestWorker *worker, OAIUser_ListByService_200_response summary);
    void userUpdateSignalFull(OAIHttpRequestWorker *worker);

    Q_DECL_DEPRECATED_X("Use userCreateOrUpdateSignalError() instead")
    void userCreateOrUpdateSignalE(OAIUser_Get_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void userCreateOrUpdateSignalError(OAIUser_Get_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userDeleteSignalError() instead")
    void userDeleteSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void userDeleteSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userGetSignalError() instead")
    void userGetSignalE(OAIUser_Get_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void userGetSignalError(OAIUser_Get_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userGetEntityTagSignalError() instead")
    void userGetEntityTagSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void userGetEntityTagSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userListByServiceSignalError() instead")
    void userListByServiceSignalE(OAIUser_ListByService_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void userListByServiceSignalError(OAIUser_ListByService_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userUpdateSignalError() instead")
    void userUpdateSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void userUpdateSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use userCreateOrUpdateSignalErrorFull() instead")
    void userCreateOrUpdateSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void userCreateOrUpdateSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userDeleteSignalErrorFull() instead")
    void userDeleteSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void userDeleteSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userGetSignalErrorFull() instead")
    void userGetSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void userGetSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userGetEntityTagSignalErrorFull() instead")
    void userGetEntityTagSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void userGetEntityTagSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userListByServiceSignalErrorFull() instead")
    void userListByServiceSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void userListByServiceSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use userUpdateSignalErrorFull() instead")
    void userUpdateSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void userUpdateSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
