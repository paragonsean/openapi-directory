/*
 * NotificationHubsManagementClient
 * Azure NotificationHub client
 *
 * The version of the OpenAPI document: 2014-09-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Namespace properties.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:21:59.836594-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NamespaceProperties {
  public static final String SERIALIZED_NAME_CREATED_AT = "createdAt";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_CRITICAL = "critical";
  @SerializedName(SERIALIZED_NAME_CRITICAL)
  private Boolean critical;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * Gets or sets the namespace type.
   */
  @JsonAdapter(NamespaceTypeEnum.Adapter.class)
  public enum NamespaceTypeEnum {
    MESSAGING("Messaging"),
    
    NOTIFICATION_HUB("NotificationHub");

    private String value;

    NamespaceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NamespaceTypeEnum fromValue(String value) {
      for (NamespaceTypeEnum b : NamespaceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<NamespaceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NamespaceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NamespaceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return NamespaceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      NamespaceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_NAMESPACE_TYPE = "namespaceType";
  @SerializedName(SERIALIZED_NAME_NAMESPACE_TYPE)
  private NamespaceTypeEnum namespaceType;

  public static final String SERIALIZED_NAME_PROVISIONING_STATE = "provisioningState";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATE)
  private String provisioningState;

  public static final String SERIALIZED_NAME_REGION = "region";
  @SerializedName(SERIALIZED_NAME_REGION)
  private String region;

  public static final String SERIALIZED_NAME_SCALE_UNIT = "scaleUnit";
  @SerializedName(SERIALIZED_NAME_SCALE_UNIT)
  private String scaleUnit;

  public static final String SERIALIZED_NAME_SERVICE_BUS_ENDPOINT = "serviceBusEndpoint";
  @SerializedName(SERIALIZED_NAME_SERVICE_BUS_ENDPOINT)
  private String serviceBusEndpoint;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_SUBSCRIPTION_ID = "subscriptionId";
  @SerializedName(SERIALIZED_NAME_SUBSCRIPTION_ID)
  private String subscriptionId;

  public NamespaceProperties() {
  }

  public NamespaceProperties createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

  /**
   * The time the namespace was created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public NamespaceProperties critical(Boolean critical) {
    this.critical = critical;
    return this;
  }

  /**
   * Whether or not the namespace is set as Critical.
   * @return critical
   */
  @javax.annotation.Nullable
  public Boolean getCritical() {
    return critical;
  }

  public void setCritical(Boolean critical) {
    this.critical = critical;
  }


  public NamespaceProperties enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Whether or not the namespace is currently enabled.
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public NamespaceProperties name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the namespace.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public NamespaceProperties namespaceType(NamespaceTypeEnum namespaceType) {
    this.namespaceType = namespaceType;
    return this;
  }

  /**
   * Gets or sets the namespace type.
   * @return namespaceType
   */
  @javax.annotation.Nullable
  public NamespaceTypeEnum getNamespaceType() {
    return namespaceType;
  }

  public void setNamespaceType(NamespaceTypeEnum namespaceType) {
    this.namespaceType = namespaceType;
  }


  public NamespaceProperties provisioningState(String provisioningState) {
    this.provisioningState = provisioningState;
    return this;
  }

  /**
   * Gets or sets provisioning state of the Namespace.
   * @return provisioningState
   */
  @javax.annotation.Nullable
  public String getProvisioningState() {
    return provisioningState;
  }

  public void setProvisioningState(String provisioningState) {
    this.provisioningState = provisioningState;
  }


  public NamespaceProperties region(String region) {
    this.region = region;
    return this;
  }

  /**
   * Specifies the targeted region in which the namespace should be created. It can be any of the following values: Australia East, Australia Southeast, Central US, East US, East US 2, West US, North Central US, South Central US, East Asia, Southeast Asia, Brazil South, Japan East, Japan West, North Europe, West Europe
   * @return region
   */
  @javax.annotation.Nullable
  public String getRegion() {
    return region;
  }

  public void setRegion(String region) {
    this.region = region;
  }


  public NamespaceProperties scaleUnit(String scaleUnit) {
    this.scaleUnit = scaleUnit;
    return this;
  }

  /**
   * ScaleUnit where the namespace gets created
   * @return scaleUnit
   */
  @javax.annotation.Nullable
  public String getScaleUnit() {
    return scaleUnit;
  }

  public void setScaleUnit(String scaleUnit) {
    this.scaleUnit = scaleUnit;
  }


  public NamespaceProperties serviceBusEndpoint(String serviceBusEndpoint) {
    this.serviceBusEndpoint = serviceBusEndpoint;
    return this;
  }

  /**
   * Endpoint you can use to perform NotificationHub operations.
   * @return serviceBusEndpoint
   */
  @javax.annotation.Nullable
  public String getServiceBusEndpoint() {
    return serviceBusEndpoint;
  }

  public void setServiceBusEndpoint(String serviceBusEndpoint) {
    this.serviceBusEndpoint = serviceBusEndpoint;
  }


  public NamespaceProperties status(String status) {
    this.status = status;
    return this;
  }

  /**
   * Status of the namespace. It can be any of these values:1 &#x3D; Created/Active2 &#x3D; Creating3 &#x3D; Suspended4 &#x3D; Deleting
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public NamespaceProperties subscriptionId(String subscriptionId) {
    this.subscriptionId = subscriptionId;
    return this;
  }

  /**
   * The Id of the Azure subscription associated with the namespace.
   * @return subscriptionId
   */
  @javax.annotation.Nullable
  public String getSubscriptionId() {
    return subscriptionId;
  }

  public void setSubscriptionId(String subscriptionId) {
    this.subscriptionId = subscriptionId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NamespaceProperties namespaceProperties = (NamespaceProperties) o;
    return Objects.equals(this.createdAt, namespaceProperties.createdAt) &&
        Objects.equals(this.critical, namespaceProperties.critical) &&
        Objects.equals(this.enabled, namespaceProperties.enabled) &&
        Objects.equals(this.name, namespaceProperties.name) &&
        Objects.equals(this.namespaceType, namespaceProperties.namespaceType) &&
        Objects.equals(this.provisioningState, namespaceProperties.provisioningState) &&
        Objects.equals(this.region, namespaceProperties.region) &&
        Objects.equals(this.scaleUnit, namespaceProperties.scaleUnit) &&
        Objects.equals(this.serviceBusEndpoint, namespaceProperties.serviceBusEndpoint) &&
        Objects.equals(this.status, namespaceProperties.status) &&
        Objects.equals(this.subscriptionId, namespaceProperties.subscriptionId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createdAt, critical, enabled, name, namespaceType, provisioningState, region, scaleUnit, serviceBusEndpoint, status, subscriptionId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NamespaceProperties {\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    critical: ").append(toIndentedString(critical)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespaceType: ").append(toIndentedString(namespaceType)).append("\n");
    sb.append("    provisioningState: ").append(toIndentedString(provisioningState)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    scaleUnit: ").append(toIndentedString(scaleUnit)).append("\n");
    sb.append("    serviceBusEndpoint: ").append(toIndentedString(serviceBusEndpoint)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    subscriptionId: ").append(toIndentedString(subscriptionId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("createdAt");
    openapiFields.add("critical");
    openapiFields.add("enabled");
    openapiFields.add("name");
    openapiFields.add("namespaceType");
    openapiFields.add("provisioningState");
    openapiFields.add("region");
    openapiFields.add("scaleUnit");
    openapiFields.add("serviceBusEndpoint");
    openapiFields.add("status");
    openapiFields.add("subscriptionId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NamespaceProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NamespaceProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NamespaceProperties is not found in the empty JSON string", NamespaceProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NamespaceProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NamespaceProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("namespaceType") != null && !jsonObj.get("namespaceType").isJsonNull()) && !jsonObj.get("namespaceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespaceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("namespaceType").toString()));
      }
      // validate the optional field `namespaceType`
      if (jsonObj.get("namespaceType") != null && !jsonObj.get("namespaceType").isJsonNull()) {
        NamespaceTypeEnum.validateJsonElement(jsonObj.get("namespaceType"));
      }
      if ((jsonObj.get("provisioningState") != null && !jsonObj.get("provisioningState").isJsonNull()) && !jsonObj.get("provisioningState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioningState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioningState").toString()));
      }
      if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull()) && !jsonObj.get("region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("region").toString()));
      }
      if ((jsonObj.get("scaleUnit") != null && !jsonObj.get("scaleUnit").isJsonNull()) && !jsonObj.get("scaleUnit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scaleUnit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scaleUnit").toString()));
      }
      if ((jsonObj.get("serviceBusEndpoint") != null && !jsonObj.get("serviceBusEndpoint").isJsonNull()) && !jsonObj.get("serviceBusEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceBusEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceBusEndpoint").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if ((jsonObj.get("subscriptionId") != null && !jsonObj.get("subscriptionId").isJsonNull()) && !jsonObj.get("subscriptionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subscriptionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subscriptionId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NamespaceProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NamespaceProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NamespaceProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NamespaceProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<NamespaceProperties>() {
           @Override
           public void write(JsonWriter out, NamespaceProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NamespaceProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NamespaceProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NamespaceProperties
   * @throws IOException if the JSON string is invalid with respect to NamespaceProperties
   */
  public static NamespaceProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NamespaceProperties.class);
  }

  /**
   * Convert an instance of NamespaceProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

