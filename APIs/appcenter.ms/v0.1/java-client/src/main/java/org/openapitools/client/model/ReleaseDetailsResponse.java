/*
 * App Center Client
 * Microsoft Visual Studio App Center API
 *
 * The version of the OpenAPI document: v0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ReleasesGetLatestByDistributionGroup200ResponseBuild;
import org.openapitools.client.model.ReleasesGetLatestByDistributionGroup200ResponseDestinationsInner;
import org.openapitools.client.model.ReleasesGetLatestByDistributionGroup200ResponseDistributionGroupsInner;
import org.openapitools.client.model.ReleasesGetLatestByDistributionGroup200ResponseDistributionStoresInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Details of an uploaded release
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:56:40.008147-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReleaseDetailsResponse {
  public static final String SERIALIZED_NAME_ANDROID_MIN_API_LEVEL = "android_min_api_level";
  @SerializedName(SERIALIZED_NAME_ANDROID_MIN_API_LEVEL)
  private String androidMinApiLevel;

  public static final String SERIALIZED_NAME_APP_DISPLAY_NAME = "app_display_name";
  @SerializedName(SERIALIZED_NAME_APP_DISPLAY_NAME)
  private String appDisplayName;

  public static final String SERIALIZED_NAME_APP_ICON_URL = "app_icon_url";
  @SerializedName(SERIALIZED_NAME_APP_ICON_URL)
  private String appIconUrl;

  public static final String SERIALIZED_NAME_APP_NAME = "app_name";
  @SerializedName(SERIALIZED_NAME_APP_NAME)
  private String appName;

  public static final String SERIALIZED_NAME_APP_OS = "app_os";
  @SerializedName(SERIALIZED_NAME_APP_OS)
  private String appOs;

  public static final String SERIALIZED_NAME_BUILD = "build";
  @SerializedName(SERIALIZED_NAME_BUILD)
  private ReleasesGetLatestByDistributionGroup200ResponseBuild build;

  public static final String SERIALIZED_NAME_BUNDLE_IDENTIFIER = "bundle_identifier";
  @SerializedName(SERIALIZED_NAME_BUNDLE_IDENTIFIER)
  private String bundleIdentifier;

  public static final String SERIALIZED_NAME_CAN_RESIGN = "can_resign";
  @SerializedName(SERIALIZED_NAME_CAN_RESIGN)
  private Boolean canResign;

  /**
   * OBSOLETE. Will be removed in next version. The destination type.&lt;br&gt; &lt;b&gt;group&lt;/b&gt;: The release distributed to internal groups and distribution_groups details will be returned.&lt;br&gt; &lt;b&gt;store&lt;/b&gt;: The release distributed to external stores and distribution_stores details will be returned.&lt;br&gt; &lt;b&gt;tester&lt;/b&gt;: The release distributed testers details will be returned.&lt;br&gt; 
   */
  @JsonAdapter(DestinationTypeEnum.Adapter.class)
  public enum DestinationTypeEnum {
    GROUP("group"),
    
    STORE("store"),
    
    TESTER("tester");

    private String value;

    DestinationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DestinationTypeEnum fromValue(String value) {
      for (DestinationTypeEnum b : DestinationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DestinationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DestinationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DestinationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DestinationTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DestinationTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DESTINATION_TYPE = "destination_type";
  @SerializedName(SERIALIZED_NAME_DESTINATION_TYPE)
  private DestinationTypeEnum destinationType;

  public static final String SERIALIZED_NAME_DESTINATIONS = "destinations";
  @SerializedName(SERIALIZED_NAME_DESTINATIONS)
  private List<ReleasesGetLatestByDistributionGroup200ResponseDestinationsInner> destinations = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEVICE_FAMILY = "device_family";
  @SerializedName(SERIALIZED_NAME_DEVICE_FAMILY)
  private String deviceFamily;

  public static final String SERIALIZED_NAME_DISTRIBUTION_GROUPS = "distribution_groups";
  @SerializedName(SERIALIZED_NAME_DISTRIBUTION_GROUPS)
  private List<ReleasesGetLatestByDistributionGroup200ResponseDistributionGroupsInner> distributionGroups = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISTRIBUTION_STORES = "distribution_stores";
  @SerializedName(SERIALIZED_NAME_DISTRIBUTION_STORES)
  private List<ReleasesGetLatestByDistributionGroup200ResponseDistributionStoresInner> distributionStores = new ArrayList<>();

  public static final String SERIALIZED_NAME_DOWNLOAD_URL = "download_url";
  @SerializedName(SERIALIZED_NAME_DOWNLOAD_URL)
  private String downloadUrl;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_FINGERPRINT = "fingerprint";
  @SerializedName(SERIALIZED_NAME_FINGERPRINT)
  private String fingerprint;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public static final String SERIALIZED_NAME_INSTALL_URL = "install_url";
  @SerializedName(SERIALIZED_NAME_INSTALL_URL)
  private String installUrl;

  public static final String SERIALIZED_NAME_IS_EXTERNAL_BUILD = "is_external_build";
  @SerializedName(SERIALIZED_NAME_IS_EXTERNAL_BUILD)
  private Boolean isExternalBuild;

  public static final String SERIALIZED_NAME_IS_PROVISIONING_PROFILE_SYNCING = "is_provisioning_profile_syncing";
  @SerializedName(SERIALIZED_NAME_IS_PROVISIONING_PROFILE_SYNCING)
  private Boolean isProvisioningProfileSyncing;

  public static final String SERIALIZED_NAME_IS_UDID_PROVISIONED = "is_udid_provisioned";
  @SerializedName(SERIALIZED_NAME_IS_UDID_PROVISIONED)
  private Boolean isUdidProvisioned;

  public static final String SERIALIZED_NAME_MIN_OS = "min_os";
  @SerializedName(SERIALIZED_NAME_MIN_OS)
  private String minOs;

  /**
   * The release&#39;s origin
   */
  @JsonAdapter(OriginEnum.Adapter.class)
  public enum OriginEnum {
    HOCKEYAPP("hockeyapp"),
    
    APPCENTER("appcenter");

    private String value;

    OriginEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OriginEnum fromValue(String value) {
      for (OriginEnum b : OriginEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OriginEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OriginEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OriginEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OriginEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OriginEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ORIGIN = "origin";
  @SerializedName(SERIALIZED_NAME_ORIGIN)
  private OriginEnum origin;

  public static final String SERIALIZED_NAME_PACKAGE_HASHES = "package_hashes";
  @SerializedName(SERIALIZED_NAME_PACKAGE_HASHES)
  private List<String> packageHashes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROVISIONING_PROFILE_EXPIRY_DATE = "provisioning_profile_expiry_date";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_PROFILE_EXPIRY_DATE)
  private String provisioningProfileExpiryDate;

  public static final String SERIALIZED_NAME_PROVISIONING_PROFILE_NAME = "provisioning_profile_name";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_PROFILE_NAME)
  private String provisioningProfileName;

  /**
   * The type of the provisioning profile for the requested app version.
   */
  @JsonAdapter(ProvisioningProfileTypeEnum.Adapter.class)
  public enum ProvisioningProfileTypeEnum {
    ADHOC("adhoc"),
    
    ENTERPRISE("enterprise"),
    
    OTHER("other");

    private String value;

    ProvisioningProfileTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProvisioningProfileTypeEnum fromValue(String value) {
      for (ProvisioningProfileTypeEnum b : ProvisioningProfileTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProvisioningProfileTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProvisioningProfileTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProvisioningProfileTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProvisioningProfileTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProvisioningProfileTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROVISIONING_PROFILE_TYPE = "provisioning_profile_type";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_PROFILE_TYPE)
  private ProvisioningProfileTypeEnum provisioningProfileType;

  public static final String SERIALIZED_NAME_RELEASE_NOTES = "release_notes";
  @SerializedName(SERIALIZED_NAME_RELEASE_NOTES)
  private String releaseNotes;

  public static final String SERIALIZED_NAME_SECONDARY_DOWNLOAD_URL = "secondary_download_url";
  @SerializedName(SERIALIZED_NAME_SECONDARY_DOWNLOAD_URL)
  private String secondaryDownloadUrl;

  public static final String SERIALIZED_NAME_SHORT_VERSION = "short_version";
  @SerializedName(SERIALIZED_NAME_SHORT_VERSION)
  private String shortVersion;

  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private Integer size;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_UPLOADED_AT = "uploaded_at";
  @SerializedName(SERIALIZED_NAME_UPLOADED_AT)
  private String uploadedAt;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public ReleaseDetailsResponse() {
  }

  public ReleaseDetailsResponse androidMinApiLevel(String androidMinApiLevel) {
    this.androidMinApiLevel = androidMinApiLevel;
    return this;
  }

  /**
   * The release&#39;s minimum required Android API level.
   * @return androidMinApiLevel
   */
  @javax.annotation.Nullable
  public String getAndroidMinApiLevel() {
    return androidMinApiLevel;
  }

  public void setAndroidMinApiLevel(String androidMinApiLevel) {
    this.androidMinApiLevel = androidMinApiLevel;
  }


  public ReleaseDetailsResponse appDisplayName(String appDisplayName) {
    this.appDisplayName = appDisplayName;
    return this;
  }

  /**
   * The app&#39;s display name.
   * @return appDisplayName
   */
  @javax.annotation.Nonnull
  public String getAppDisplayName() {
    return appDisplayName;
  }

  public void setAppDisplayName(String appDisplayName) {
    this.appDisplayName = appDisplayName;
  }


  public ReleaseDetailsResponse appIconUrl(String appIconUrl) {
    this.appIconUrl = appIconUrl;
    return this;
  }

  /**
   * A URL to the app&#39;s icon.
   * @return appIconUrl
   */
  @javax.annotation.Nonnull
  public String getAppIconUrl() {
    return appIconUrl;
  }

  public void setAppIconUrl(String appIconUrl) {
    this.appIconUrl = appIconUrl;
  }


  public ReleaseDetailsResponse appName(String appName) {
    this.appName = appName;
    return this;
  }

  /**
   * The app&#39;s name (extracted from the uploaded release).
   * @return appName
   */
  @javax.annotation.Nonnull
  public String getAppName() {
    return appName;
  }

  public void setAppName(String appName) {
    this.appName = appName;
  }


  public ReleaseDetailsResponse appOs(String appOs) {
    this.appOs = appOs;
    return this;
  }

  /**
   * The app&#39;s OS.
   * @return appOs
   */
  @javax.annotation.Nullable
  public String getAppOs() {
    return appOs;
  }

  public void setAppOs(String appOs) {
    this.appOs = appOs;
  }


  public ReleaseDetailsResponse build(ReleasesGetLatestByDistributionGroup200ResponseBuild build) {
    this.build = build;
    return this;
  }

  /**
   * Get build
   * @return build
   */
  @javax.annotation.Nullable
  public ReleasesGetLatestByDistributionGroup200ResponseBuild getBuild() {
    return build;
  }

  public void setBuild(ReleasesGetLatestByDistributionGroup200ResponseBuild build) {
    this.build = build;
  }


  public ReleaseDetailsResponse bundleIdentifier(String bundleIdentifier) {
    this.bundleIdentifier = bundleIdentifier;
    return this;
  }

  /**
   * The identifier of the apps bundle.
   * @return bundleIdentifier
   */
  @javax.annotation.Nullable
  public String getBundleIdentifier() {
    return bundleIdentifier;
  }

  public void setBundleIdentifier(String bundleIdentifier) {
    this.bundleIdentifier = bundleIdentifier;
  }


  public ReleaseDetailsResponse canResign(Boolean canResign) {
    this.canResign = canResign;
    return this;
  }

  /**
   * In calls that allow passing &#x60;udid&#x60; in the query string, this value determines if a release can be re-signed. When true, after a re-sign, the tester will be able to install the release from his registered devices. Will not be returned for non-iOS platforms.
   * @return canResign
   */
  @javax.annotation.Nullable
  public Boolean getCanResign() {
    return canResign;
  }

  public void setCanResign(Boolean canResign) {
    this.canResign = canResign;
  }


  public ReleaseDetailsResponse destinationType(DestinationTypeEnum destinationType) {
    this.destinationType = destinationType;
    return this;
  }

  /**
   * OBSOLETE. Will be removed in next version. The destination type.&lt;br&gt; &lt;b&gt;group&lt;/b&gt;: The release distributed to internal groups and distribution_groups details will be returned.&lt;br&gt; &lt;b&gt;store&lt;/b&gt;: The release distributed to external stores and distribution_stores details will be returned.&lt;br&gt; &lt;b&gt;tester&lt;/b&gt;: The release distributed testers details will be returned.&lt;br&gt; 
   * @return destinationType
   */
  @javax.annotation.Nullable
  public DestinationTypeEnum getDestinationType() {
    return destinationType;
  }

  public void setDestinationType(DestinationTypeEnum destinationType) {
    this.destinationType = destinationType;
  }


  public ReleaseDetailsResponse destinations(List<ReleasesGetLatestByDistributionGroup200ResponseDestinationsInner> destinations) {
    this.destinations = destinations;
    return this;
  }

  public ReleaseDetailsResponse addDestinationsItem(ReleasesGetLatestByDistributionGroup200ResponseDestinationsInner destinationsItem) {
    if (this.destinations == null) {
      this.destinations = new ArrayList<>();
    }
    this.destinations.add(destinationsItem);
    return this;
  }

  /**
   * A list of distribution groups or stores.
   * @return destinations
   */
  @javax.annotation.Nullable
  public List<ReleasesGetLatestByDistributionGroup200ResponseDestinationsInner> getDestinations() {
    return destinations;
  }

  public void setDestinations(List<ReleasesGetLatestByDistributionGroup200ResponseDestinationsInner> destinations) {
    this.destinations = destinations;
  }


  public ReleaseDetailsResponse deviceFamily(String deviceFamily) {
    this.deviceFamily = deviceFamily;
    return this;
  }

  /**
   * The release&#39;s device family.
   * @return deviceFamily
   */
  @javax.annotation.Nullable
  public String getDeviceFamily() {
    return deviceFamily;
  }

  public void setDeviceFamily(String deviceFamily) {
    this.deviceFamily = deviceFamily;
  }


  public ReleaseDetailsResponse distributionGroups(List<ReleasesGetLatestByDistributionGroup200ResponseDistributionGroupsInner> distributionGroups) {
    this.distributionGroups = distributionGroups;
    return this;
  }

  public ReleaseDetailsResponse addDistributionGroupsItem(ReleasesGetLatestByDistributionGroup200ResponseDistributionGroupsInner distributionGroupsItem) {
    if (this.distributionGroups == null) {
      this.distributionGroups = new ArrayList<>();
    }
    this.distributionGroups.add(distributionGroupsItem);
    return this;
  }

  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated with this release.
   * @return distributionGroups
   */
  @javax.annotation.Nullable
  public List<ReleasesGetLatestByDistributionGroup200ResponseDistributionGroupsInner> getDistributionGroups() {
    return distributionGroups;
  }

  public void setDistributionGroups(List<ReleasesGetLatestByDistributionGroup200ResponseDistributionGroupsInner> distributionGroups) {
    this.distributionGroups = distributionGroups;
  }


  public ReleaseDetailsResponse distributionStores(List<ReleasesGetLatestByDistributionGroup200ResponseDistributionStoresInner> distributionStores) {
    this.distributionStores = distributionStores;
    return this;
  }

  public ReleaseDetailsResponse addDistributionStoresItem(ReleasesGetLatestByDistributionGroup200ResponseDistributionStoresInner distributionStoresItem) {
    if (this.distributionStores == null) {
      this.distributionStores = new ArrayList<>();
    }
    this.distributionStores.add(distributionStoresItem);
    return this;
  }

  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated with this release.
   * @return distributionStores
   */
  @javax.annotation.Nullable
  public List<ReleasesGetLatestByDistributionGroup200ResponseDistributionStoresInner> getDistributionStores() {
    return distributionStores;
  }

  public void setDistributionStores(List<ReleasesGetLatestByDistributionGroup200ResponseDistributionStoresInner> distributionStores) {
    this.distributionStores = distributionStores;
  }


  public ReleaseDetailsResponse downloadUrl(String downloadUrl) {
    this.downloadUrl = downloadUrl;
    return this;
  }

  /**
   * The URL that hosts the binary for this release.
   * @return downloadUrl
   */
  @javax.annotation.Nullable
  public String getDownloadUrl() {
    return downloadUrl;
  }

  public void setDownloadUrl(String downloadUrl) {
    this.downloadUrl = downloadUrl;
  }


  public ReleaseDetailsResponse enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * This value determines the whether a release currently is enabled or disabled.
   * @return enabled
   */
  @javax.annotation.Nonnull
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public ReleaseDetailsResponse fingerprint(String fingerprint) {
    this.fingerprint = fingerprint;
    return this;
  }

  /**
   * MD5 checksum of the release binary.
   * @return fingerprint
   */
  @javax.annotation.Nullable
  public String getFingerprint() {
    return fingerprint;
  }

  public void setFingerprint(String fingerprint) {
    this.fingerprint = fingerprint;
  }


  public ReleaseDetailsResponse id(Integer id) {
    this.id = id;
    return this;
  }

  /**
   * ID identifying this unique release.
   * @return id
   */
  @javax.annotation.Nonnull
  public Integer getId() {
    return id;
  }

  public void setId(Integer id) {
    this.id = id;
  }


  public ReleaseDetailsResponse installUrl(String installUrl) {
    this.installUrl = installUrl;
    return this;
  }

  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed with &#x60;itms-services://?action&#x3D;download-manifest&amp;url&#x3D;&#x60;
   * @return installUrl
   */
  @javax.annotation.Nullable
  public String getInstallUrl() {
    return installUrl;
  }

  public void setInstallUrl(String installUrl) {
    this.installUrl = installUrl;
  }


  public ReleaseDetailsResponse isExternalBuild(Boolean isExternalBuild) {
    this.isExternalBuild = isExternalBuild;
    return this;
  }

  /**
   * This value determines if a release is external or not.
   * @return isExternalBuild
   */
  @javax.annotation.Nullable
  public Boolean getIsExternalBuild() {
    return isExternalBuild;
  }

  public void setIsExternalBuild(Boolean isExternalBuild) {
    this.isExternalBuild = isExternalBuild;
  }


  public ReleaseDetailsResponse isProvisioningProfileSyncing(Boolean isProvisioningProfileSyncing) {
    this.isProvisioningProfileSyncing = isProvisioningProfileSyncing;
    return this;
  }

  /**
   * A flag that determines whether the release&#39;s provisioning profile is still extracted or not.
   * @return isProvisioningProfileSyncing
   */
  @javax.annotation.Nullable
  public Boolean getIsProvisioningProfileSyncing() {
    return isProvisioningProfileSyncing;
  }

  public void setIsProvisioningProfileSyncing(Boolean isProvisioningProfileSyncing) {
    this.isProvisioningProfileSyncing = isProvisioningProfileSyncing;
  }


  public ReleaseDetailsResponse isUdidProvisioned(Boolean isUdidProvisioned) {
    this.isUdidProvisioned = isUdidProvisioned;
    return this;
  }

  /**
   * In calls that allow passing &#x60;udid&#x60; in the query string, this value will hold the provisioning status of that UDID in this release. Will be ignored for non-iOS platforms.
   * @return isUdidProvisioned
   */
  @javax.annotation.Nullable
  public Boolean getIsUdidProvisioned() {
    return isUdidProvisioned;
  }

  public void setIsUdidProvisioned(Boolean isUdidProvisioned) {
    this.isUdidProvisioned = isUdidProvisioned;
  }


  public ReleaseDetailsResponse minOs(String minOs) {
    this.minOs = minOs;
    return this;
  }

  /**
   * The release&#39;s minimum required operating system.
   * @return minOs
   */
  @javax.annotation.Nullable
  public String getMinOs() {
    return minOs;
  }

  public void setMinOs(String minOs) {
    this.minOs = minOs;
  }


  public ReleaseDetailsResponse origin(OriginEnum origin) {
    this.origin = origin;
    return this;
  }

  /**
   * The release&#39;s origin
   * @return origin
   */
  @javax.annotation.Nullable
  public OriginEnum getOrigin() {
    return origin;
  }

  public void setOrigin(OriginEnum origin) {
    this.origin = origin;
  }


  public ReleaseDetailsResponse packageHashes(List<String> packageHashes) {
    this.packageHashes = packageHashes;
    return this;
  }

  public ReleaseDetailsResponse addPackageHashesItem(String packageHashesItem) {
    if (this.packageHashes == null) {
      this.packageHashes = new ArrayList<>();
    }
    this.packageHashes.add(packageHashesItem);
    return this;
  }

  /**
   * Hashes for the packages.
   * @return packageHashes
   */
  @javax.annotation.Nullable
  public List<String> getPackageHashes() {
    return packageHashes;
  }

  public void setPackageHashes(List<String> packageHashes) {
    this.packageHashes = packageHashes;
  }


  public ReleaseDetailsResponse provisioningProfileExpiryDate(String provisioningProfileExpiryDate) {
    this.provisioningProfileExpiryDate = provisioningProfileExpiryDate;
    return this;
  }

  /**
   * expiration date of provisioning profile in UTC format.
   * @return provisioningProfileExpiryDate
   */
  @javax.annotation.Nullable
  public String getProvisioningProfileExpiryDate() {
    return provisioningProfileExpiryDate;
  }

  public void setProvisioningProfileExpiryDate(String provisioningProfileExpiryDate) {
    this.provisioningProfileExpiryDate = provisioningProfileExpiryDate;
  }


  public ReleaseDetailsResponse provisioningProfileName(String provisioningProfileName) {
    this.provisioningProfileName = provisioningProfileName;
    return this;
  }

  /**
   * The release&#39;s provisioning profile name.
   * @return provisioningProfileName
   */
  @javax.annotation.Nullable
  public String getProvisioningProfileName() {
    return provisioningProfileName;
  }

  public void setProvisioningProfileName(String provisioningProfileName) {
    this.provisioningProfileName = provisioningProfileName;
  }


  public ReleaseDetailsResponse provisioningProfileType(ProvisioningProfileTypeEnum provisioningProfileType) {
    this.provisioningProfileType = provisioningProfileType;
    return this;
  }

  /**
   * The type of the provisioning profile for the requested app version.
   * @return provisioningProfileType
   */
  @javax.annotation.Nullable
  public ProvisioningProfileTypeEnum getProvisioningProfileType() {
    return provisioningProfileType;
  }

  public void setProvisioningProfileType(ProvisioningProfileTypeEnum provisioningProfileType) {
    this.provisioningProfileType = provisioningProfileType;
  }


  public ReleaseDetailsResponse releaseNotes(String releaseNotes) {
    this.releaseNotes = releaseNotes;
    return this;
  }

  /**
   * The release&#39;s release notes.
   * @return releaseNotes
   */
  @javax.annotation.Nullable
  public String getReleaseNotes() {
    return releaseNotes;
  }

  public void setReleaseNotes(String releaseNotes) {
    this.releaseNotes = releaseNotes;
  }


  public ReleaseDetailsResponse secondaryDownloadUrl(String secondaryDownloadUrl) {
    this.secondaryDownloadUrl = secondaryDownloadUrl;
    return this;
  }

  /**
   * The URL that hosts the secondary binary for this release, such as the apk file for aab releases.
   * @return secondaryDownloadUrl
   */
  @javax.annotation.Nullable
  public String getSecondaryDownloadUrl() {
    return secondaryDownloadUrl;
  }

  public void setSecondaryDownloadUrl(String secondaryDownloadUrl) {
    this.secondaryDownloadUrl = secondaryDownloadUrl;
  }


  public ReleaseDetailsResponse shortVersion(String shortVersion) {
    this.shortVersion = shortVersion;
    return this;
  }

  /**
   * The release&#39;s short version.&lt;br&gt; For iOS: CFBundleShortVersionString from info.plist. For Android: android:versionName from AppManifest.xml. 
   * @return shortVersion
   */
  @javax.annotation.Nonnull
  public String getShortVersion() {
    return shortVersion;
  }

  public void setShortVersion(String shortVersion) {
    this.shortVersion = shortVersion;
  }


  public ReleaseDetailsResponse size(Integer size) {
    this.size = size;
    return this;
  }

  /**
   * The release&#39;s size in bytes.
   * @return size
   */
  @javax.annotation.Nullable
  public Integer getSize() {
    return size;
  }

  public void setSize(Integer size) {
    this.size = size;
  }


  public ReleaseDetailsResponse status(String status) {
    this.status = status;
    return this;
  }

  /**
   * Status of the release.
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public ReleaseDetailsResponse uploadedAt(String uploadedAt) {
    this.uploadedAt = uploadedAt;
    return this;
  }

  /**
   * UTC time in ISO 8601 format of the uploaded time.
   * @return uploadedAt
   */
  @javax.annotation.Nonnull
  public String getUploadedAt() {
    return uploadedAt;
  }

  public void setUploadedAt(String uploadedAt) {
    this.uploadedAt = uploadedAt;
  }


  public ReleaseDetailsResponse version(String version) {
    this.version = version;
    return this;
  }

  /**
   * The release&#39;s version.&lt;br&gt; For iOS: CFBundleVersion from info.plist. For Android: android:versionCode from AppManifest.xml. 
   * @return version
   */
  @javax.annotation.Nonnull
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReleaseDetailsResponse releaseDetailsResponse = (ReleaseDetailsResponse) o;
    return Objects.equals(this.androidMinApiLevel, releaseDetailsResponse.androidMinApiLevel) &&
        Objects.equals(this.appDisplayName, releaseDetailsResponse.appDisplayName) &&
        Objects.equals(this.appIconUrl, releaseDetailsResponse.appIconUrl) &&
        Objects.equals(this.appName, releaseDetailsResponse.appName) &&
        Objects.equals(this.appOs, releaseDetailsResponse.appOs) &&
        Objects.equals(this.build, releaseDetailsResponse.build) &&
        Objects.equals(this.bundleIdentifier, releaseDetailsResponse.bundleIdentifier) &&
        Objects.equals(this.canResign, releaseDetailsResponse.canResign) &&
        Objects.equals(this.destinationType, releaseDetailsResponse.destinationType) &&
        Objects.equals(this.destinations, releaseDetailsResponse.destinations) &&
        Objects.equals(this.deviceFamily, releaseDetailsResponse.deviceFamily) &&
        Objects.equals(this.distributionGroups, releaseDetailsResponse.distributionGroups) &&
        Objects.equals(this.distributionStores, releaseDetailsResponse.distributionStores) &&
        Objects.equals(this.downloadUrl, releaseDetailsResponse.downloadUrl) &&
        Objects.equals(this.enabled, releaseDetailsResponse.enabled) &&
        Objects.equals(this.fingerprint, releaseDetailsResponse.fingerprint) &&
        Objects.equals(this.id, releaseDetailsResponse.id) &&
        Objects.equals(this.installUrl, releaseDetailsResponse.installUrl) &&
        Objects.equals(this.isExternalBuild, releaseDetailsResponse.isExternalBuild) &&
        Objects.equals(this.isProvisioningProfileSyncing, releaseDetailsResponse.isProvisioningProfileSyncing) &&
        Objects.equals(this.isUdidProvisioned, releaseDetailsResponse.isUdidProvisioned) &&
        Objects.equals(this.minOs, releaseDetailsResponse.minOs) &&
        Objects.equals(this.origin, releaseDetailsResponse.origin) &&
        Objects.equals(this.packageHashes, releaseDetailsResponse.packageHashes) &&
        Objects.equals(this.provisioningProfileExpiryDate, releaseDetailsResponse.provisioningProfileExpiryDate) &&
        Objects.equals(this.provisioningProfileName, releaseDetailsResponse.provisioningProfileName) &&
        Objects.equals(this.provisioningProfileType, releaseDetailsResponse.provisioningProfileType) &&
        Objects.equals(this.releaseNotes, releaseDetailsResponse.releaseNotes) &&
        Objects.equals(this.secondaryDownloadUrl, releaseDetailsResponse.secondaryDownloadUrl) &&
        Objects.equals(this.shortVersion, releaseDetailsResponse.shortVersion) &&
        Objects.equals(this.size, releaseDetailsResponse.size) &&
        Objects.equals(this.status, releaseDetailsResponse.status) &&
        Objects.equals(this.uploadedAt, releaseDetailsResponse.uploadedAt) &&
        Objects.equals(this.version, releaseDetailsResponse.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(androidMinApiLevel, appDisplayName, appIconUrl, appName, appOs, build, bundleIdentifier, canResign, destinationType, destinations, deviceFamily, distributionGroups, distributionStores, downloadUrl, enabled, fingerprint, id, installUrl, isExternalBuild, isProvisioningProfileSyncing, isUdidProvisioned, minOs, origin, packageHashes, provisioningProfileExpiryDate, provisioningProfileName, provisioningProfileType, releaseNotes, secondaryDownloadUrl, shortVersion, size, status, uploadedAt, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReleaseDetailsResponse {\n");
    sb.append("    androidMinApiLevel: ").append(toIndentedString(androidMinApiLevel)).append("\n");
    sb.append("    appDisplayName: ").append(toIndentedString(appDisplayName)).append("\n");
    sb.append("    appIconUrl: ").append(toIndentedString(appIconUrl)).append("\n");
    sb.append("    appName: ").append(toIndentedString(appName)).append("\n");
    sb.append("    appOs: ").append(toIndentedString(appOs)).append("\n");
    sb.append("    build: ").append(toIndentedString(build)).append("\n");
    sb.append("    bundleIdentifier: ").append(toIndentedString(bundleIdentifier)).append("\n");
    sb.append("    canResign: ").append(toIndentedString(canResign)).append("\n");
    sb.append("    destinationType: ").append(toIndentedString(destinationType)).append("\n");
    sb.append("    destinations: ").append(toIndentedString(destinations)).append("\n");
    sb.append("    deviceFamily: ").append(toIndentedString(deviceFamily)).append("\n");
    sb.append("    distributionGroups: ").append(toIndentedString(distributionGroups)).append("\n");
    sb.append("    distributionStores: ").append(toIndentedString(distributionStores)).append("\n");
    sb.append("    downloadUrl: ").append(toIndentedString(downloadUrl)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    fingerprint: ").append(toIndentedString(fingerprint)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    installUrl: ").append(toIndentedString(installUrl)).append("\n");
    sb.append("    isExternalBuild: ").append(toIndentedString(isExternalBuild)).append("\n");
    sb.append("    isProvisioningProfileSyncing: ").append(toIndentedString(isProvisioningProfileSyncing)).append("\n");
    sb.append("    isUdidProvisioned: ").append(toIndentedString(isUdidProvisioned)).append("\n");
    sb.append("    minOs: ").append(toIndentedString(minOs)).append("\n");
    sb.append("    origin: ").append(toIndentedString(origin)).append("\n");
    sb.append("    packageHashes: ").append(toIndentedString(packageHashes)).append("\n");
    sb.append("    provisioningProfileExpiryDate: ").append(toIndentedString(provisioningProfileExpiryDate)).append("\n");
    sb.append("    provisioningProfileName: ").append(toIndentedString(provisioningProfileName)).append("\n");
    sb.append("    provisioningProfileType: ").append(toIndentedString(provisioningProfileType)).append("\n");
    sb.append("    releaseNotes: ").append(toIndentedString(releaseNotes)).append("\n");
    sb.append("    secondaryDownloadUrl: ").append(toIndentedString(secondaryDownloadUrl)).append("\n");
    sb.append("    shortVersion: ").append(toIndentedString(shortVersion)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    uploadedAt: ").append(toIndentedString(uploadedAt)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("android_min_api_level");
    openapiFields.add("app_display_name");
    openapiFields.add("app_icon_url");
    openapiFields.add("app_name");
    openapiFields.add("app_os");
    openapiFields.add("build");
    openapiFields.add("bundle_identifier");
    openapiFields.add("can_resign");
    openapiFields.add("destination_type");
    openapiFields.add("destinations");
    openapiFields.add("device_family");
    openapiFields.add("distribution_groups");
    openapiFields.add("distribution_stores");
    openapiFields.add("download_url");
    openapiFields.add("enabled");
    openapiFields.add("fingerprint");
    openapiFields.add("id");
    openapiFields.add("install_url");
    openapiFields.add("is_external_build");
    openapiFields.add("is_provisioning_profile_syncing");
    openapiFields.add("is_udid_provisioned");
    openapiFields.add("min_os");
    openapiFields.add("origin");
    openapiFields.add("package_hashes");
    openapiFields.add("provisioning_profile_expiry_date");
    openapiFields.add("provisioning_profile_name");
    openapiFields.add("provisioning_profile_type");
    openapiFields.add("release_notes");
    openapiFields.add("secondary_download_url");
    openapiFields.add("short_version");
    openapiFields.add("size");
    openapiFields.add("status");
    openapiFields.add("uploaded_at");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("app_display_name");
    openapiRequiredFields.add("app_icon_url");
    openapiRequiredFields.add("app_name");
    openapiRequiredFields.add("enabled");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("short_version");
    openapiRequiredFields.add("uploaded_at");
    openapiRequiredFields.add("version");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReleaseDetailsResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReleaseDetailsResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReleaseDetailsResponse is not found in the empty JSON string", ReleaseDetailsResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReleaseDetailsResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReleaseDetailsResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ReleaseDetailsResponse.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("android_min_api_level") != null && !jsonObj.get("android_min_api_level").isJsonNull()) && !jsonObj.get("android_min_api_level").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `android_min_api_level` to be a primitive type in the JSON string but got `%s`", jsonObj.get("android_min_api_level").toString()));
      }
      if (!jsonObj.get("app_display_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `app_display_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("app_display_name").toString()));
      }
      if (!jsonObj.get("app_icon_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `app_icon_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("app_icon_url").toString()));
      }
      if (!jsonObj.get("app_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `app_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("app_name").toString()));
      }
      if ((jsonObj.get("app_os") != null && !jsonObj.get("app_os").isJsonNull()) && !jsonObj.get("app_os").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `app_os` to be a primitive type in the JSON string but got `%s`", jsonObj.get("app_os").toString()));
      }
      // validate the optional field `build`
      if (jsonObj.get("build") != null && !jsonObj.get("build").isJsonNull()) {
        ReleasesGetLatestByDistributionGroup200ResponseBuild.validateJsonElement(jsonObj.get("build"));
      }
      if ((jsonObj.get("bundle_identifier") != null && !jsonObj.get("bundle_identifier").isJsonNull()) && !jsonObj.get("bundle_identifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bundle_identifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bundle_identifier").toString()));
      }
      if ((jsonObj.get("destination_type") != null && !jsonObj.get("destination_type").isJsonNull()) && !jsonObj.get("destination_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destination_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destination_type").toString()));
      }
      // validate the optional field `destination_type`
      if (jsonObj.get("destination_type") != null && !jsonObj.get("destination_type").isJsonNull()) {
        DestinationTypeEnum.validateJsonElement(jsonObj.get("destination_type"));
      }
      if (jsonObj.get("destinations") != null && !jsonObj.get("destinations").isJsonNull()) {
        JsonArray jsonArraydestinations = jsonObj.getAsJsonArray("destinations");
        if (jsonArraydestinations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("destinations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `destinations` to be an array in the JSON string but got `%s`", jsonObj.get("destinations").toString()));
          }

          // validate the optional field `destinations` (array)
          for (int i = 0; i < jsonArraydestinations.size(); i++) {
            ReleasesGetLatestByDistributionGroup200ResponseDestinationsInner.validateJsonElement(jsonArraydestinations.get(i));
          };
        }
      }
      if ((jsonObj.get("device_family") != null && !jsonObj.get("device_family").isJsonNull()) && !jsonObj.get("device_family").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `device_family` to be a primitive type in the JSON string but got `%s`", jsonObj.get("device_family").toString()));
      }
      if (jsonObj.get("distribution_groups") != null && !jsonObj.get("distribution_groups").isJsonNull()) {
        JsonArray jsonArraydistributionGroups = jsonObj.getAsJsonArray("distribution_groups");
        if (jsonArraydistributionGroups != null) {
          // ensure the json data is an array
          if (!jsonObj.get("distribution_groups").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `distribution_groups` to be an array in the JSON string but got `%s`", jsonObj.get("distribution_groups").toString()));
          }

          // validate the optional field `distribution_groups` (array)
          for (int i = 0; i < jsonArraydistributionGroups.size(); i++) {
            ReleasesGetLatestByDistributionGroup200ResponseDistributionGroupsInner.validateJsonElement(jsonArraydistributionGroups.get(i));
          };
        }
      }
      if (jsonObj.get("distribution_stores") != null && !jsonObj.get("distribution_stores").isJsonNull()) {
        JsonArray jsonArraydistributionStores = jsonObj.getAsJsonArray("distribution_stores");
        if (jsonArraydistributionStores != null) {
          // ensure the json data is an array
          if (!jsonObj.get("distribution_stores").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `distribution_stores` to be an array in the JSON string but got `%s`", jsonObj.get("distribution_stores").toString()));
          }

          // validate the optional field `distribution_stores` (array)
          for (int i = 0; i < jsonArraydistributionStores.size(); i++) {
            ReleasesGetLatestByDistributionGroup200ResponseDistributionStoresInner.validateJsonElement(jsonArraydistributionStores.get(i));
          };
        }
      }
      if ((jsonObj.get("download_url") != null && !jsonObj.get("download_url").isJsonNull()) && !jsonObj.get("download_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `download_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("download_url").toString()));
      }
      if ((jsonObj.get("fingerprint") != null && !jsonObj.get("fingerprint").isJsonNull()) && !jsonObj.get("fingerprint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fingerprint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fingerprint").toString()));
      }
      if ((jsonObj.get("install_url") != null && !jsonObj.get("install_url").isJsonNull()) && !jsonObj.get("install_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `install_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("install_url").toString()));
      }
      if ((jsonObj.get("min_os") != null && !jsonObj.get("min_os").isJsonNull()) && !jsonObj.get("min_os").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `min_os` to be a primitive type in the JSON string but got `%s`", jsonObj.get("min_os").toString()));
      }
      if ((jsonObj.get("origin") != null && !jsonObj.get("origin").isJsonNull()) && !jsonObj.get("origin").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `origin` to be a primitive type in the JSON string but got `%s`", jsonObj.get("origin").toString()));
      }
      // validate the optional field `origin`
      if (jsonObj.get("origin") != null && !jsonObj.get("origin").isJsonNull()) {
        OriginEnum.validateJsonElement(jsonObj.get("origin"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("package_hashes") != null && !jsonObj.get("package_hashes").isJsonNull() && !jsonObj.get("package_hashes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `package_hashes` to be an array in the JSON string but got `%s`", jsonObj.get("package_hashes").toString()));
      }
      if ((jsonObj.get("provisioning_profile_expiry_date") != null && !jsonObj.get("provisioning_profile_expiry_date").isJsonNull()) && !jsonObj.get("provisioning_profile_expiry_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioning_profile_expiry_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioning_profile_expiry_date").toString()));
      }
      if ((jsonObj.get("provisioning_profile_name") != null && !jsonObj.get("provisioning_profile_name").isJsonNull()) && !jsonObj.get("provisioning_profile_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioning_profile_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioning_profile_name").toString()));
      }
      if ((jsonObj.get("provisioning_profile_type") != null && !jsonObj.get("provisioning_profile_type").isJsonNull()) && !jsonObj.get("provisioning_profile_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provisioning_profile_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provisioning_profile_type").toString()));
      }
      // validate the optional field `provisioning_profile_type`
      if (jsonObj.get("provisioning_profile_type") != null && !jsonObj.get("provisioning_profile_type").isJsonNull()) {
        ProvisioningProfileTypeEnum.validateJsonElement(jsonObj.get("provisioning_profile_type"));
      }
      if ((jsonObj.get("release_notes") != null && !jsonObj.get("release_notes").isJsonNull()) && !jsonObj.get("release_notes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `release_notes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("release_notes").toString()));
      }
      if ((jsonObj.get("secondary_download_url") != null && !jsonObj.get("secondary_download_url").isJsonNull()) && !jsonObj.get("secondary_download_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secondary_download_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secondary_download_url").toString()));
      }
      if (!jsonObj.get("short_version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `short_version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("short_version").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if (!jsonObj.get("uploaded_at").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uploaded_at` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uploaded_at").toString()));
      }
      if (!jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReleaseDetailsResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReleaseDetailsResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReleaseDetailsResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReleaseDetailsResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<ReleaseDetailsResponse>() {
           @Override
           public void write(JsonWriter out, ReleaseDetailsResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReleaseDetailsResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReleaseDetailsResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReleaseDetailsResponse
   * @throws IOException if the JSON string is invalid with respect to ReleaseDetailsResponse
   */
  public static ReleaseDetailsResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReleaseDetailsResponse.class);
  }

  /**
   * Convert an instance of ReleaseDetailsResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

