/*
 * WhatsApp Business API
 * See https://developers.facebook.com/docs/whatsapp
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Media;
import org.openapitools.client.model.Webhooks;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ApplicationSettings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:33.067920-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ApplicationSettings {
  public static final String SERIALIZED_NAME_CALLBACK_BACKOFF_DELAY_MS = "callback_backoff_delay_ms";
  @SerializedName(SERIALIZED_NAME_CALLBACK_BACKOFF_DELAY_MS)
  private String callbackBackoffDelayMs = "3000";

  public static final String SERIALIZED_NAME_CALLBACK_PERSIST = "callback_persist";
  @SerializedName(SERIALIZED_NAME_CALLBACK_PERSIST)
  private Boolean callbackPersist = true;

  public static final String SERIALIZED_NAME_HEARTBEAT_INTERVAL = "heartbeat_interval";
  @SerializedName(SERIALIZED_NAME_HEARTBEAT_INTERVAL)
  private Integer heartbeatInterval = 5;

  public static final String SERIALIZED_NAME_MAX_CALLBACK_BACKOFF_DELAY_MS = "max_callback_backoff_delay_ms";
  @SerializedName(SERIALIZED_NAME_MAX_CALLBACK_BACKOFF_DELAY_MS)
  private String maxCallbackBackoffDelayMs = "900000";

  public static final String SERIALIZED_NAME_MEDIA = "media";
  @SerializedName(SERIALIZED_NAME_MEDIA)
  private Media media;

  public static final String SERIALIZED_NAME_ON_CALL_PAGER = "on_call_pager";
  @SerializedName(SERIALIZED_NAME_ON_CALL_PAGER)
  private String onCallPager;

  public static final String SERIALIZED_NAME_PASS_THROUGH = "pass_through";
  @SerializedName(SERIALIZED_NAME_PASS_THROUGH)
  private Boolean passThrough = true;

  public static final String SERIALIZED_NAME_SENT_STATUS = "sent_status";
  @SerializedName(SERIALIZED_NAME_SENT_STATUS)
  private Boolean sentStatus = false;

  public static final String SERIALIZED_NAME_UNHEALTHY_INTERVAL = "unhealthy_interval";
  @SerializedName(SERIALIZED_NAME_UNHEALTHY_INTERVAL)
  private Integer unhealthyInterval = 30;

  public static final String SERIALIZED_NAME_WEBHOOKS = "webhooks";
  @SerializedName(SERIALIZED_NAME_WEBHOOKS)
  private Webhooks webhooks;

  public ApplicationSettings() {
  }

  public ApplicationSettings callbackBackoffDelayMs(String callbackBackoffDelayMs) {
    this.callbackBackoffDelayMs = callbackBackoffDelayMs;
    return this;
  }

  /**
   * Backoff delay for a failed callback in milliseconds This setting is used to configure the amount of time the backoff delays before retrying a failed callback. The backoff delay increases linearly by this value each time a callback fails to get a HTTPS 200 OK response. The backoff delay is capped by the max_callback_backoff_delay_ms setting.
   * @return callbackBackoffDelayMs
   */
  @javax.annotation.Nullable
  public String getCallbackBackoffDelayMs() {
    return callbackBackoffDelayMs;
  }

  public void setCallbackBackoffDelayMs(String callbackBackoffDelayMs) {
    this.callbackBackoffDelayMs = callbackBackoffDelayMs;
  }


  public ApplicationSettings callbackPersist(Boolean callbackPersist) {
    this.callbackPersist = callbackPersist;
    return this;
  }

  /**
   * Stores callbacks on disk until they are successfully acknowledged by the Webhook or not. Restart required.
   * @return callbackPersist
   */
  @javax.annotation.Nullable
  public Boolean getCallbackPersist() {
    return callbackPersist;
  }

  public void setCallbackPersist(Boolean callbackPersist) {
    this.callbackPersist = callbackPersist;
  }


  public ApplicationSettings heartbeatInterval(Integer heartbeatInterval) {
    this.heartbeatInterval = heartbeatInterval;
    return this;
  }

  /**
   * Multiconnect: Interval of the Master node monitoring of Coreapp nodes in seconds
   * @return heartbeatInterval
   */
  @javax.annotation.Nullable
  public Integer getHeartbeatInterval() {
    return heartbeatInterval;
  }

  public void setHeartbeatInterval(Integer heartbeatInterval) {
    this.heartbeatInterval = heartbeatInterval;
  }


  public ApplicationSettings maxCallbackBackoffDelayMs(String maxCallbackBackoffDelayMs) {
    this.maxCallbackBackoffDelayMs = maxCallbackBackoffDelayMs;
    return this;
  }

  /**
   * Maximum delay for a failed callback in milliseconds
   * @return maxCallbackBackoffDelayMs
   */
  @javax.annotation.Nullable
  public String getMaxCallbackBackoffDelayMs() {
    return maxCallbackBackoffDelayMs;
  }

  public void setMaxCallbackBackoffDelayMs(String maxCallbackBackoffDelayMs) {
    this.maxCallbackBackoffDelayMs = maxCallbackBackoffDelayMs;
  }


  public ApplicationSettings media(Media media) {
    this.media = media;
    return this;
  }

  /**
   * Get media
   * @return media
   */
  @javax.annotation.Nullable
  public Media getMedia() {
    return media;
  }

  public void setMedia(Media media) {
    this.media = media;
  }


  public ApplicationSettings onCallPager(String onCallPager) {
    this.onCallPager = onCallPager;
    return this;
  }

  /**
   * Set to valid WhatsApp Group with users who wish to see alerts for critical errors and messages.
   * @return onCallPager
   */
  @javax.annotation.Nullable
  public String getOnCallPager() {
    return onCallPager;
  }

  public void setOnCallPager(String onCallPager) {
    this.onCallPager = onCallPager;
  }


  public ApplicationSettings passThrough(Boolean passThrough) {
    this.passThrough = passThrough;
    return this;
  }

  /**
   * When true, removes messages from the local database after they are delivered to or read by the recipient. When false, saves all messages on local storage until they are explicitly deleted. When messages are sent, they are stored in a local database. This database is used as the application&#39;s history. Since the business keeps its own history, you can specify whether you want message pass_through or not. Restart required.
   * @return passThrough
   */
  @javax.annotation.Nullable
  public Boolean getPassThrough() {
    return passThrough;
  }

  public void setPassThrough(Boolean passThrough) {
    this.passThrough = passThrough;
  }


  public ApplicationSettings sentStatus(Boolean sentStatus) {
    this.sentStatus = sentStatus;
    return this;
  }

  /**
   * Receive a notification that a message is sent to server. When true, you will receive a message indicating that a message has been sent. If false (default), you will not receive notification.
   * @return sentStatus
   */
  @javax.annotation.Nullable
  public Boolean getSentStatus() {
    return sentStatus;
  }

  public void setSentStatus(Boolean sentStatus) {
    this.sentStatus = sentStatus;
  }


  public ApplicationSettings unhealthyInterval(Integer unhealthyInterval) {
    this.unhealthyInterval = unhealthyInterval;
    return this;
  }

  /**
   * Multiconnect: Maximum amount of seconds a Master node waits for a Coreapp node to respond to a heartbeat before considering it unhealthy and starting the failover process.
   * @return unhealthyInterval
   */
  @javax.annotation.Nullable
  public Integer getUnhealthyInterval() {
    return unhealthyInterval;
  }

  public void setUnhealthyInterval(Integer unhealthyInterval) {
    this.unhealthyInterval = unhealthyInterval;
  }


  public ApplicationSettings webhooks(Webhooks webhooks) {
    this.webhooks = webhooks;
    return this;
  }

  /**
   * Get webhooks
   * @return webhooks
   */
  @javax.annotation.Nullable
  public Webhooks getWebhooks() {
    return webhooks;
  }

  public void setWebhooks(Webhooks webhooks) {
    this.webhooks = webhooks;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApplicationSettings applicationSettings = (ApplicationSettings) o;
    return Objects.equals(this.callbackBackoffDelayMs, applicationSettings.callbackBackoffDelayMs) &&
        Objects.equals(this.callbackPersist, applicationSettings.callbackPersist) &&
        Objects.equals(this.heartbeatInterval, applicationSettings.heartbeatInterval) &&
        Objects.equals(this.maxCallbackBackoffDelayMs, applicationSettings.maxCallbackBackoffDelayMs) &&
        Objects.equals(this.media, applicationSettings.media) &&
        Objects.equals(this.onCallPager, applicationSettings.onCallPager) &&
        Objects.equals(this.passThrough, applicationSettings.passThrough) &&
        Objects.equals(this.sentStatus, applicationSettings.sentStatus) &&
        Objects.equals(this.unhealthyInterval, applicationSettings.unhealthyInterval) &&
        Objects.equals(this.webhooks, applicationSettings.webhooks);
  }

  @Override
  public int hashCode() {
    return Objects.hash(callbackBackoffDelayMs, callbackPersist, heartbeatInterval, maxCallbackBackoffDelayMs, media, onCallPager, passThrough, sentStatus, unhealthyInterval, webhooks);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApplicationSettings {\n");
    sb.append("    callbackBackoffDelayMs: ").append(toIndentedString(callbackBackoffDelayMs)).append("\n");
    sb.append("    callbackPersist: ").append(toIndentedString(callbackPersist)).append("\n");
    sb.append("    heartbeatInterval: ").append(toIndentedString(heartbeatInterval)).append("\n");
    sb.append("    maxCallbackBackoffDelayMs: ").append(toIndentedString(maxCallbackBackoffDelayMs)).append("\n");
    sb.append("    media: ").append(toIndentedString(media)).append("\n");
    sb.append("    onCallPager: ").append(toIndentedString(onCallPager)).append("\n");
    sb.append("    passThrough: ").append(toIndentedString(passThrough)).append("\n");
    sb.append("    sentStatus: ").append(toIndentedString(sentStatus)).append("\n");
    sb.append("    unhealthyInterval: ").append(toIndentedString(unhealthyInterval)).append("\n");
    sb.append("    webhooks: ").append(toIndentedString(webhooks)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("callback_backoff_delay_ms");
    openapiFields.add("callback_persist");
    openapiFields.add("heartbeat_interval");
    openapiFields.add("max_callback_backoff_delay_ms");
    openapiFields.add("media");
    openapiFields.add("on_call_pager");
    openapiFields.add("pass_through");
    openapiFields.add("sent_status");
    openapiFields.add("unhealthy_interval");
    openapiFields.add("webhooks");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ApplicationSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ApplicationSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApplicationSettings is not found in the empty JSON string", ApplicationSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ApplicationSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ApplicationSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("callback_backoff_delay_ms") != null && !jsonObj.get("callback_backoff_delay_ms").isJsonNull()) && !jsonObj.get("callback_backoff_delay_ms").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `callback_backoff_delay_ms` to be a primitive type in the JSON string but got `%s`", jsonObj.get("callback_backoff_delay_ms").toString()));
      }
      if ((jsonObj.get("max_callback_backoff_delay_ms") != null && !jsonObj.get("max_callback_backoff_delay_ms").isJsonNull()) && !jsonObj.get("max_callback_backoff_delay_ms").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `max_callback_backoff_delay_ms` to be a primitive type in the JSON string but got `%s`", jsonObj.get("max_callback_backoff_delay_ms").toString()));
      }
      // validate the optional field `media`
      if (jsonObj.get("media") != null && !jsonObj.get("media").isJsonNull()) {
        Media.validateJsonElement(jsonObj.get("media"));
      }
      if ((jsonObj.get("on_call_pager") != null && !jsonObj.get("on_call_pager").isJsonNull()) && !jsonObj.get("on_call_pager").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `on_call_pager` to be a primitive type in the JSON string but got `%s`", jsonObj.get("on_call_pager").toString()));
      }
      // validate the optional field `webhooks`
      if (jsonObj.get("webhooks") != null && !jsonObj.get("webhooks").isJsonNull()) {
        Webhooks.validateJsonElement(jsonObj.get("webhooks"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApplicationSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApplicationSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApplicationSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApplicationSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<ApplicationSettings>() {
           @Override
           public void write(JsonWriter out, ApplicationSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApplicationSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ApplicationSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ApplicationSettings
   * @throws IOException if the JSON string is invalid with respect to ApplicationSettings
   */
  public static ApplicationSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApplicationSettings.class);
  }

  /**
   * Convert an instance of ApplicationSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

