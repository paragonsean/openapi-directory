/**
 * Rubrik REST API
 *  Copyright © 2017-2021 Rubrik Inc. [Legal](#section/Legal)  # Introduction  Welcome to the Rubrik™ REST API documentation.  The Rubrik REST API provides a RESTful interface for working with Rubrik clusters and Rubrik Edge virtual appliances. The Rubrik REST API can be used to query, configure, and control nearly all of the operations of the Rubrik software.  Through authenticated and encrypted interaction with the Rubrik REST API server, perform any of the operations that are available through the Rubrik web UI and many bulk-type operations that might otherwise be difficult or impossible to perform.  This documentation provides reference information and examples of typical workflows for the Rubrik REST API. For more detailed information about working with Rubrik clusters and Rubrik Edge virtual appliances refer to the *Rubrik User Guide*.  A quick way to become familiar with the Rubrik REST API, is to use the Rubrik REST API Explorer. [OpenAPI](#section/OpenAPI) describes this tool.  Refer to the [changelog](#section/Changelog) to see information about changes within this version of the Rubrik REST API.  # Changelog   Revisions are listed with the most recent revision first.   ### Changes to V1 API in Rubrik Version 6.0.0  ## Feature additions/improvements:  * Added optional fields: id(type: string) and networkType(type:    VmwareNetworkType Enum) to VmwareNetworkInfo, which is used by:    `Get /vmware/vm/{id}/snapshot`    `Get /vmware/config/recovery/networks`  * Added new optional field `maxLocalRetentionLimit` to    `CloudOutForecastSlaParameters`.  * Added following new endpoints for health monitor:    `POST /health_monitor/run_policy`    `GET /health_monitor/policies`    `GET /health_monitor/policy_status`  * Added new endpoints `POST /sap_hana/db/{id}/configure_restore` and    `/sap_hana/db/{id}/unconfigure_restore` to configure and unconfigure    system copy restore on the target SAP HANA database.  * Added new endpoint `POST /sla_domain/assign_to_downloaded_snapshots` to    assign retention SLA only to snapshots at downloaded locations.  * Copied the following endpoints from the internal Rubrik REST API listing    to the v1 listing:    `GET /oracle/db`    `GET /oracle/db/{id}`    `PATCH /oracle/db/{id}`    Added a new optional parameter `is_data_guard_group` to `GET /oracle/db`.  * Added new optional fields `advancedRecoveryConfigMap`, `preScriptPath`,    `postScriptPath`, and `shouldStopRecoveryOnPreScriptFailure` to    `ExportOracleDbConfig` and `MountOracleDbConfig` which specify the    Advanced Cloning Options (ACO) map, pre script path, post script path,    and whether to stop the recovery on pre-script failure, respectively.  * Added new endpoint `POST /oracle/validate_aco_file` to validate the given    Advanced Cloning Options (ACO) file and retrieve the validation results.  * Added new endpoint `GET /oracle/aco_parameter_list` to fetch the list of    supported Advanced Cloning Options (ACO) parameter names.  * Added new endpoint `PATCH /oracle/data_guard_group/{id}` to update the SLA    and user settings for a Data Guard group.  * Added new endpoints to get and change hostnames of nodes in a Rubrik cluster.    'GET /cluster/{id}/node_hostname',    'POST /cluster/{id}/node_hostname'.  * Added a new object `NodeHostnameInfo` used by    `GET /cluster/{id}/node_hostname` and `POST /cluster/{id}/node_hostname`.  * Added new endpoint to get Rubrik Backup Service details for a host.    `GET /host/rbs`  * Added new endpoint to install Rubrik Backup Service on a host.    `POST /host/rbs/install`  * Added new endpoint to uninstall Rubrik Backup Service from a host.    `POST /host/rbs/uninstall`  * Added new endpoint to upgrade Rubrik Backup Service on a host.    `POST /host/rbs/upgrade`  * Added new endpoints for user-defined tags management    `GET /user_defined_tag`    `POST /user_defined_tag`    `DELETE /user_defined_tag`    `GET /user_defined_tag/{id}`    `PATCH /user_defined_tag/{id}`    `DELETE /user_defined_tag/{id}`  * Added new optional field 'numChannels' to 'OracleValidateConfig' object.    This field specifies the number of channels used when validating Oracle    backups.  * Added new endpoint for batch VM snpshots query.    `POST /vmware/vm/snapshots`  * Added new endpoints for SQL Server host configuration.    `GET /mssql/host/configuration`,    `POST /mssql/host/configuration`,    `GET /mssql/host/configuration/{host_id}`,    `PATCH /mssql/host/configuration/{host_id}`,    `DELETE /mssql/host/configuration/{host_id}`  * Added new optional field `dataRetrievalCostInUSD` to    `CloudOutStorageForecastSummary`.  * Added `POST /cloud_utilization/cloud_out_forecast` endpoint to forecast cloud    utilization for archival use case.  * Changed `lastUpdatedTime` to be required in  * Changed `retryStatus` to be required in    `JobMonitoringInfo` which is used in endpoints `GET /job_monitoring`    and `GET /polaris/job_monitoring`.  * Changed `lastUpdatedTime` to be required in    `JobMonitoringInfo` which is used in endpoints `GET /job_monitoring`    and `GET /polaris/job_monitoring`.  * Added a new endpoint to bulk tier existing snapshots    `POST /unmanaged_object/snapshot/bulk_archive_tier`  * Added new field `snapshotVerificationInfo` to    `VerificationResponse` to include event information    about snapshots.  * Added new optional fields `errorInfo` and    `retryStatus` to `JobMonitoringInfo` to include backup    failure remediation status.  * Added new optional fields `snapMirrorLabelForFullBackup` and    `snapMirrorLabelForIncrementalBackup` to `FilesetSummary`, `FilesetUpdate`    and `FilesetCreate` to support SnapMirror destination volume    backup.    `FilesetSummary` is used by endpoints:     `GET /v1/fileset`,     `GET /v1/fileset/{id}`.    `FilesetUpdate` is used by endpoints:     `PATCH /v1/fileset/{id}`.    `FilesetCreate` is used by endpoints:     `POST /internal/fileset/bulk`,     `POST /v1/fileset`.  * Added new values of `IoFilterStatus` and `HostUiFilterStatus`    to help distinguish cluster and ESXi host states when there is    a mismatch between the installed IO filter and ESXi host versions,    instead of defaulting to Unsupported.  * Added new endpoints `GET /cluster/{id}/security/totp/setting` and    `PUT /cluster/{id}/security/totp/setting` for retreiving and    updating the 2-Step Verification global setting, respectively.  * Added new optional field `computeVisibilityFilter` to    `GET /vmware/vcenter/{id}`, `POST /vmware/vcenter` and `PUT /vmware/vcenter`     to specify compute resource visibility.  ## New features:  * Added new endpoint for querying LDAP domain names.    `GET /ldap_service/domain_name`  * Added new endpoints for supporting truststores    `GET /v1/cluster/{id}/security/truststore`    `DELETE /v1/cluster/{id}/security/truststore`    `PATCH /v1/cluster/{id}/security/truststore`  * Added new field `isOnSnapMirrorDestVolume` to HostHierarchyObjectSummary    returned by `GET /host/hierarchy/{id}/children`.  * Added new endpoint, `GET /volume_group/{id}/request/force_full_snapshot`.    This endpoint retrieves the configuration used to force a full snapshot    of a Volume Group.  * Added new endpoint, `POST /volume_group/{id}/request/force_full_snapshot`.    This endpoint requests to force a full snapshot of a Volume Group.  * Added new endpoint, `POST /archive/location/{id}/owner/disable` to disable    archival location.  * Added new endpoint, `POST /archive/location/{id}/owner/enable` to enable    archival location.  * Added new optional field `dataPathSpec` to `SapHanaSystemConfig` include    details of SAP HANA system data path  * Copied the following endpoints from the internal Rubrik REST API listing   to the v1 listings:      * `GET /vcd/hierarchy/{id}` to get summary of a vCD hierarchy object.      * `GET /vcd/hierarchy/{id}/children` to get immediate descendant objects.      * `GET /vcd/hierarchy/{id}/descendants` to get list of descendant objects.      * `GET /vcd/cluster` to get summary for all vCD Clusters.      * `POST /vcd/cluster` to add a vCD Cluster.      * `GET /vcd/cluster/{id}/vimserver` to get VimServers of a vCD Cluster.      * `POST /vcd/cluster/{id}/refresh` to refresh a vCD Cluster.      * `GET /vcd/cluster/{id}` to get vCD Cluster details.      * `PATCH /vcd/cluster/{id}` to modify the hostname and credentials of a       specified vCD Cluster object.      * `DELETE /vcd/cluster/{id}` to remove vCD Cluster.      * `GET /vcd/cluster/request/{id}` to get vCD Cluster job status.      * `GET /vcd/vapp` to get summary for vApps.      * `GET /vcd/vapp/{id}` to get vApp details.      * `PATCH /vcd/vapp/{id}` to make changes to the parameters of a       specified vApp object.      * `GET /vcd/vapp/{id}/snapshot` to retrieve summary information for each       of the snapshot objects of a specified vApp object.      * `POST /vcd/vapp/{id}/snapshot` to start an asynchronous job to create       an on-demand snapshot for a specified vApp object.      * `DELETE /vcd/vapp/{id}/snapshot` to delete all snapshots of vApp.      * `GET /vcd/vapp/snapshot/{id}` to get vApp snapshot details.      * `DELETE /vcd/vapp/snapshot/{id}` to delete vApp snapshot.      * `GET /vcd/vapp/{id}/missed_snapshot` to get details about missed       snapshots for a vApp.      * `GET /vcd/vapp/snapshot/{snapshot_id}/export/options` to get       exportable network configurations.      * `POST /vcd/vapp/snapshot/{snapshot_id}/export` to export vApp snapshot.      * `POST /vcd/vapp/snapshot/{snapshot_id}/instant_recover` to instant       Recovery of vApp virtual machines.      * `GET /vcd/vapp/snapshot/{snapshot_id}/instant_recover/options` to get       Instant Recovery information.      * `GET /vcd/vapp/request/{id}` to retrieve the details of a specified       asynchronous job for a vApp.      * `GET /vcd/vapp/{id}/search` to search for a file from a vApp.      * `POST /vcd/vapp/snapshot/{id}/download` to download snapshot from       archive.  * Added new endpoint, `GET /hyperv/vm/{id}/request/force_full_snapshot`.    This endpoint retrieves the configuration used to force a full snapshot    of a Hyper-V virtual machine.  * Added new endpoint, `POST /hyperv/vm/{id}/request/force_full_snapshot`.    This endpoint requests to force a full snapshot of a Hyper-V virtual machine.  * Added new endpoint, `GET /vmware/vm/{id}/request/force_full_snapshot`.   This endpoint retrieves the configuration used to force a full snapshot   of a VMware virtual machine.  * Added new endpoint `POST /vmware/vm/{id}/request/force_full_snapshot`.   This endpoint requests to force a full snapshot of a VMware virtual machine. ### Changes to V1 API in Rubrik Version 5.3.2  ## Feature additions/improvements:  * Modified instanceName field in the `GET /mssql/db` endpoint by adding    the network name for SQL Server databases belonging to a cluster    instance.   ### Changes to V1 API in Rubrik Version 5.3.1  ## Feature additions/improvements:  * Added `GET /exclusion_pattern`    endpoint to get all exclusion patterns.  * Added `GET /exclusion_pattern/{id}`    endpoint to get a exclusion pattern by id.  * Added `POST /exclusion_pattern`    endpoint to create a new exclusion pattern.  * Added `POST /exclusion_pattern/bulk`    endpoint to bulk create new exclusion patterns.  * Added `PATCH /exclusion_pattern/{id}`    endpoint to update a exclusion pattern.  * Added `DELETE /exclusion_pattern/{id}`    endpoint to delete a exclusion pattern.  * Added `DELETE /exclusion_pattern/bulk`    endpoint to bulk delete exclusion patterns.  * Added new optional field `keyProtection` to `EncryptionStatus`    to support returning key protection status via v1 API    `GET /cluster/{id}/security/encryption`.  * Added `Post /vmware/vm/snapshot/{id}/export_with_download` endpoint to export    a vm snapshot from an archival location.  * Added new field `index` to `JobMonitoringObjectsCountByType`, which contains    the total count of all Index jobs.  * Added `Index` to `JobMonitoringTaskType`.  * Added new optional field `isTotpEnforced` to `LdapServiceInfo`,    `LdapServiceSummary`, and `LdapServiceInfoUpdate` to support    TOTP enforcement for LDAP services in followin APIs.    `POST /v1/ldap_service`    `GET /v1/ldap_service`    `GET /v1/ldap_service/{id}`    `PATCH /v1/ldap_service/{id}`    `PUT /v1/ldap_service/{id}`  * Added new optional field `isTotpEnabled` as a query param in API    `GET /v1/principal` for fetch users with TOTP enabled.  * Added new optional fields `mfaServerName`, `isTotpEnabled`, and    `isTotpEnforced` to `PrincipalSummaryV1` as part of response from    API `GET /v1/principal` for rendering principals' MFA status.  * Modified `AgentConnectStatus` enum to add value SecondaryCluster for    multicluster Rubrik Backup Service support. This will be the status on a    cluster that is not the primary.  * Added new endpoint and optional fields for VMware network selection.     GET /vmware/config/recovery/networks for getting recovery networks.   ## New features:  * Added new endpoints for supporting TOTP configuration.    `GET /user/{id}/totp/status`    `PUT /user/{id}/totp/config`    `DELETE /user/{id}/totp/config`    `POST /user/{id}/totp/new_secret`  * Added new endpoints for supporting multicluster Rubrik Backup Service.    `POST /vmware/vm/make_primary`    `POST /host/make_primary`  * Added new endpoints for managing multicluster Rubrik Backup Service    certificates.    `GET /certificate/agent`    `POST /certificate/agent`    `DELETE /certificate/agent/{id}`   ### Changes to V1 API in Rubrik Version 5.3.0  ## Deprecation:  * Deprecated `SnapshotCloudStorageTier` enum value Cold. It will be left,    but will be mapped internally to the new value, AzureArchive,    which is recommended as a replacement.  * Removed signature and sigAlg return fields from `SamlSsoAuthnRequestDetail`,    which were wrongly introduced in 5.1.  * Removed `GET /vmware/resource_pool` endpoint, which doesn't have backend implementation.  * Removed `GET /vmware/resource_pool/{id}` endpoint, which doesn't have backend implementation.  ## New features:  * Added `Deleted` as new failover cluster node connection status in    FailoverClusterNodeConnectionStatus. The FailoverClusterNodeConnectionStatus    is in FailoverClusterNode object and is used by    `GET /failover_cluster`,    `GET /failover_cluster/{id}`,    `GET /failover_cluster/hierarchy/{id}`,    `GET /failover_cluster/hierarchy/{id}/children`,    `GET /failover_cluster/hierarchy/{id}/descendants` endpoints.  * Added `POST /cluster/{id}/manual_discover_ll_ipv4` endpoint to allow discovery of new    nodes over link local ipv4 network.  * Added new optional field `groupMaxLevel` to `AdvancedLdapConfiguration`    included in `LdapServiceSummary`, `LdapServiceInfo` and `LdapServiceInfoUpdate`    objects used by endpoints:    `GET /ldap_service`,    `POST /ldap_service`,    `GET /ldap_service/{id}`,    `PUT /ldap_service/{id}`,    `PATCH /ldap_service/{id}`.  * Added `is_on_demand` as an optional parameter to `GET /job_monitoring`  * Added `GET /cluster/{id}/syslog_msg_mib_link` and    `GET /cluster/{id}/syslog_tc_mib_link` endpoints to allow downloading syslog    SNMP MIB files.  * Added `POST /vmware/vm/missed_recoverable_range` endpoint to get missed recoverable    ranges for a list of virtual machines.  * Added `GET /backup/retry/{id}` endpoint to get status of reschedule    operation.  * Added `POST /backup/retry` endpoint to reschedule unsuccessful backup tasks.  * Added `POST /vmware/vm/recoverable_range` endpoint to get recoverable ranges    for a list of virtual machines.  * Added endpoint `POST /hierarchy/bulk_sla_conflicts`. Bulk get the list of    descendant objects with SLA conflicts.  * Added endpoint `GET /snapshot/{id}/storage/stats`. Returns storage stats    for a snapshot.  * Added optional query parameter `include_expired` to `GET /certificate`    endpoint, excluded expired certs by default after the change.  * Added endpoint    `GET /job_monitoring/subscription`. Gets all subscriptions to    monitoring page.  * Modified `SnapshotCloudStorageTier`, enum adding values AzureArchive, Glacier,    and GlacierDeepArchive.  * Added endpoint    `GET /backup/verify/{id}`. Get asynchronous request    details for a Backup Verification job.  * Added new optional field `privateKey` to `CertificateImportRequest`    object sent to `POST /certificate`. Using this field will fail the request    if the provided private key is not successfully parsed.  * Added endpoint    `DELETE /job_monitoring/subscription/{subscription_id}`. Delete a    monitoring page email subscription.  * Added endpoint    `PATCH /job_monitoring/subscription/{subscription_id}`. Update a    monitoring email subscription.  * Added endpoint    `GET /job_monitoring/subscription/{subscription_id}`. Get a    specific monitoring email subscription by id.  * Added endpoint    `POST /job_monitoring/subscription`. Create an email subscription    to the job monitoring page.  * Added new endpoint `POST /backup/verify`     Verifies the validity of a snapshot.  * Added endpoint `PATCH /organization/{id}/envoy/bulk`. Update a list of    Rubrik Envoy objects.  * Added new field `isGpsLoginEnabled` to `SamlSsoStatus` returned by    `GET /saml/sso_status`  * Added endpoint `GET /oracle/aco_example_download_link`. Get a download link    for an example Advanced Recovery Options file.  * Added endpoint `POST /organization/{id}/envoy/bulk`. Create a list of Rubrik    Envoy objects.  * Added endpoint `Delete /organization/{id}/envoy/bulk`. Remove a list of    Rubrik Envoy objects.  * Added organization ID parameter to the response object    IdProviderAuthDomainSummary.  * Added endpoint `GET /vmware/vcenter/hotadd/vm`. Gets details about     all HotAdd proxy virtual machines.  * Added endpoint `POST /sap_hana/system/{id}/refresh`. Initiates an     asynchronous job to refresh SAP HANA system metadata.  * Added new field `vcenterName` to `VritualMachineDetail` returned by    `GET /vmware/vm/{id}`.  * Added endpoint `DELETE /sap_hana/system/{id}`. Initiates an asynchronous     job to delete a SAP HANA system object.  * Added endpoint `GET /sap_hana/system/request/{id}`. Gets details about     a SAP HANA system related asynchronous request.  * Added endpoint `POST /sap_hana/db/{id}/snapshot`. Initiates a job to     take an on-demand full snapshot of a SAP HANA database.  * Added endpoint `GET /sap_hana/db/request/{id}`. Gets details about     a SAP HANA database related request.  * Added endpoint `GET /sap_hana/db/{id}/snapshot`. Returns a list of     summary of snapshots of a SAP HANA database.  * Added endpoint `GET /sap_hana/db/snapshot/{id}`. Gets details about     a SAP HANA database snapshot.  * Added the `POST /oracle/db/{id}/validate` to trigger an validation job on Oracle backups.  * Added new values `RetentionSlaDomainName` , `ObjectType`, `SnapshotCount`,    `AutoSnapshotCount` and  `ManualSnapshotCount` to    `UnmanagedObjectSortAttribute` field of the    `GET /unmanaged_object/reader_object` endpont.  * Added new values `RetentionSlaDomainName` , `ObjectType`, `SnapshotCount`,    `AutoSnapshotCount` and  `ManualSnapshotCount` to    `UnmanagedObjectSortAttribute` field of the `GET /unmanaged_object` endpont.  * Added the `POST /replication/location_pause/disable` to     resume replication from source cluster(s).  * Added the `POST /replication/location_pause/enable` to     pause replication from source cluster(s).  * Added endpoint `POST /sap_hana/system`. Adds new entry for SAP HANA system     and stores in database.  * Added endpoint `GET /sap_hana/db`. Returns summary of all discovered     SAP HANA databases.  * Added endpoint `GET /sap_hana/db/{id}` Returns summary of SAP HANA database     with given ID.  * Added `AggregateSapHanaDb`, `SapHanaDb` and `SapHanaSystem` to the     `object_type` filtering field of the `GET /event/latest` endpoint.  * Added the new optional field `failoverClusterAppName` to FilesetSummary     returned by `GET /fileset` and `GET /fileset/{id}`.  * Added the `GET /user/lockout` endpoint to     get the status of local user account lockout.  * Added the `PATCH /user/lockout` endpoint to     update the local user account lockout config.  * Added the `POST /user/{id}/unlock` endpoint to unlock local user.  * Added the `GET /cluster/{id}/upgrade/precheck_status` endpoint to     get the result of the latest run of periodic upgrade prechecks.  * Added the `POST /cluster/{id}/upgrade/precheck_status` endpoint to     start an on-demand run of the periodic upgrade prechecks.  * Added the `GET /cluster/{id}/rubrik_support_portal_credentials`     endpoint to check if the cluster already has credentials     for the Rubrik support portal.  * Added the `POST /cluster/{id}/rubrik_support_portal_credentials`     endpoint to update Rubrik support portal credentials for     the cluster.  * Added the `GET /vmware/vcenter/{id}/networks` endpoint to get the     networks in a vCenter.  * Added new field `isOracleHost` to HostDetail    returned by `GET /host/{id}`.  * Added the `POST /vmware/vcenter/{id}/hotadd/network` endpoint to set    the network for a HotAdd proxy virtual machine.  * Added new endpoint `GET /host/{id}/nas_share_discover`. Returns all    shares on the NAS host specified by 'id'.  * Added new endpoint `POST /host/share/bulk` to allow adding NAS    shares in bulk without validating their share credentials.  * Added `GET /volume_group` to retrieve a current list of Volume Groups.  * Added `GET /volume_group/{id}` to retrieve the details of a Volume Group.  * Added `PATCH /volume_group/{id}` to modify the details of a Volume Group.  * Added `GET /volume_group/{id}/snapshot` to retrieve the details of all    snapshots of a Volume Group.  * Added `POST /volume_group/{id}/snapshot` to create an on-demand snapshot    of a Volume Group.  * Added `GET /volume_group/snapshot/{id}` to get the details of a Volume    Group snapshot.  * Added `GET /volume_group/snapshot/mount` to retrieve summary information    of all Volume Group mounts.  * Added `GET /volume_group/snapshot/mount/{id}` to retrieve summary    information of one Volume Group mount.  * Added `GET /host/{id}/volume` to retrieve a list of all volumes on a    Volume Group host.  * Made field `restoreScriptSmbPath` optional in `VolumeGroupMountSummary`.    This change affects the endpoints `/volume_group/snapshot/mount` and    `/volume_group/snapshot/mount/{id}`.  * Added endpoint `GET /mfa/rsa/server` to get all MFA servers.  * Added endpoint `POST /mfa/rsa/server` to create a new MFA server.  * Added endpoint `GET /mfa/rsa/server/{id}` to get a specific MFA server.  * Added endpoint `PATCH /mfa/rsa/server/{id}` to update an MFA server.  * Added endpoint `DELETE /mfa/rsa/server/{id}` to delete an MFA server.  * Added endpoint `PUT /cluster/{id}/security/web_signed_cert`     to set the web server certificate.  * Added endpoint `DELETE /cluster/{id}/security/web_signed_cert`     to use the default, self-signed web server certificate.  * Added endpoint `PUT /cluster/{id}/security/kmip/client` to configure     the KMIP client on Rubrik.  * Added endpoint `GET /cluster/{id}/security/kmip/client` to get     the KMIP client configuration.  * Added endpoint `GET /cluster/{id}/security/kmip/server` to get the     KMIP server configurations.  * Added endpoint `PUT /cluster/{id}/security/kmip/server` to configure a     KMIP server.  * Added endpoint `DELETE /cluster/{id}/security/kmip/server` to delete a     configured KMIP server.  * Added endpoint `GET /database/log_report` to retrieve the database log     report summary.  * Added endpoint `POST /unmanaged_object/assign_retention_sla` to assign     a retention SLA to unmanaged objects asynchronously.  * Added endpoint `GET /sap_hana/db/{id}/recoverable_range`. Gets details     about recoverable ranges of a SAP HANA database.  * Added new  field `legalHoldDownloadConfig` to `MssqlBackupSelection` and    `DownloadMssqlBackupFilesByIdJobConfig`. An optional Boolean that specifies    whether the download is in response to a Legal Hold. This change affects    endpoints `/mssql/db/{id}/download_files_by_id`,    `/mssql/db/{id}/download_files` and `/mssql/db/{id}/browse`.  * Added new field `canUnmount` to `VolumeGroupMountSummary`, an optional    boolean value that indicates if the logged-in user has the authority    to remove the specified mount.  * Added `GET /vmware/vcenter/{id}/hotadd/needed` endpoint to get the     number of HotAdd proxies needed for a vCenter.  * Added endpoint `DELETE /sap_hana/db/snapshot/{id}`. Initiates a request    to delete a full snapshot of a SAP HANA database.  * Added new field `needsMigration` to `VolumeGroupSummary`. This change    affects the endpoints `GET /volume_group` and `GET /volume_group/{id}`.  * Added new fields `usedFastVhdx` and `fileSizeInBytes` to    `VolumeGroupSnapshotSummary`. This change affects the endpoints    `GET /volume_group/{id}/snapshot` and `GET /volume_group/snapshot/{id}`.  * Added endpoint `GET /cluster/me/upgrade/monitor_events` to get notifications    about events occurring at CDM.  * Added endpoint `GET /volume_group/{id}/latest_snapshot` to retrieve summary    information of the latest snapshot of a Volume Group.  * Added `GET /vmware/vcenter/{id}/hotadd/bandwidth` endpoint to get the    HotAdd bandwidth limits for a vCenter.  * Added `POST /vmware/vcenter/{id}/hotadd/bandwidth` endpoint to set the    HotAdd bandwidth limits for a vCenter.  * Added field `isVmc` returned by `GET /vmware/vcenter` to retrieve summary    information of a vCenter.  * Added new optional field `unreadable` to `BrowseResponse`, which is used by    `GET /browse`.  * Added new endpoint `GET /config/history/list_updates` Returns a list of    filtered configuration updates.  * Added new endpoint `GET /config/history/ondate` Returns a list of    configurations and their values on a given date.  * Added new field `dataToTransfer` to `EventSeriesSummaryV1`, an optional    integer value that represents the amount of data that needs to be    transferred by the job corresponding to the event.  * Added new field `estimatedTimeRemaining` to `EventSeriesSummaryV1`, an    optional string value that represents the estimated time remaining until    the job corresponding to the event has completed. The estimated time has    millisecond granularity.  * Added endpoint `GET /sap_hana/db/{id}/missed_snapshot` Returns a list of     summary information for the missed snapshots of a SAP HANA database.  * Added new field `forceFull` to `VolumeGroupSummary`. This change    affects the endpoints `GET /volume_group` and `GET /volume_group/{id}`.  * Modified afterId in response of `GET /event/latest` and `GET /event`    to point to each individual event in the list response instead of having    all afterId values in the list response point to the last event in the    list.  * Copied `GET /mssql/availability_group` endpoint from internal to v1 to get    all SQL Server availability groups.  * Copied `GET /mssql/availability_group/{id}` endpoint from internal to v1 to    get details of a SQL Server availability group.  * Copied `PATCH /mssql/availability_group/{id}` endpoint from internal to    v1 to update a SQL Server availability group.  * Copied `PATCH /mssql/db/bulk` endpoint from internal to v1 to update multiple    SQL Server databases.  * Copied `POST /mssql/db/bulk/snapshot` endpoint from internal to v1 to take on    demand snapshot of multiple SQL Server databases.  * Copied `GET /mssql/db/bulk/snapshot/{id}` endpoint from internal to v1 to get    details of on demand snapshot of multiple SQL Server databases.  * Copied `GET /mssql/db/count` endpoint from internal to v1 to get the count of    SQL Server databases.  * Copied `GET /mssql/instance/count` endpoint from internal to v1 to get the    count of SQL Server instances.  * Copied `DELETE /mssql/db/{id}/recoverable_range/download` endpoint from    internal to v1 to delete downloaded recoverable ranges of a SQL Server    database.  * Copied `GET /mssql/db/recoverable_range/download/{id}` endpoint from    internal to v1 to get the status of delete downloaded recoverable range job.  * Copied `GET /mssql/db/{id}/compatible_instance` endpoint from internal to v1    to get compatible instances for the recovery of a SQL Server database.  * Copied `GET /mssql/db/{id}/restore_estimate` endpoint from internal to v1 to    get size estimate for restore or export of a SQL Server database.  * Copied `GET /mssql/db/{id}/restore_files` endpoint from internal to v1 to get    all data files to be restored for an export or restore operation on a SQL    Server database.  * Copied `GET /mssql/db/{id}/snappable_id` endpoint from internal to v1 to get    the snappable id of a SQL Server database.  * Copied `GET /mssql/db/defaults` endpoint from internal to v1 to get the    default properties for SQL Server databases.  * Copied `PATCH /mssql/db/defaults` endpoint from internal to v1 to update the  * Added new field `instanceChildrenInfo` to the response from the v1 endpoint    `GET /mssql/hierarchy/root/children`. The new field is an array of type    `MssqlInstanceShortSummary` that contains the managed identifier, the name and    active node for a Windows Failover Cluster instance.  * Added enums for the `sort_by` parameter in `GET /mssql/db`.  * Added `POST /cluster/{id}/manual_discover_ipv4` endpoint to allow discovery of new    nodes over IPv4 network.  ## Breaking changes:  * Added new field `nodeName` in FailoverClusterNodeOrder object used by    `PATCH /failover_cluster/failover_cluster_app/{id}` and    `POST /failover_cluster/failover_cluster_app` endpoints.    The `nodeName` is the name of the failover cluster node.  * Renamed the field `vips` in FailoverClusterAppSource object to    `virtualIps`. The FailoverClusterAppSource is used by    `GET /failover_cluster/failover_cluster_app`,    `GET /failover_cluster/failover_cluster_app/{id}`,    `GET /failover_cluster/hierarchy/{id}`,    `GET /failover_cluster/hierarchy/{id}/children`,    `GET /failover_cluster/hierarchy/{id}/descendants`,    `PATCH /failover_cluster/failover_cluster_app/{id}` and    `POST /failover_cluster/failover_cluster_app` endpoints.  * Removed `POST /cluster/{id}/manual_discover_ll_ipv4`  ### Changes to V1 API in Rubrik Version 5.2.2  ## New features:  * Added optional field isOnDemand to `EventSeriesSummaryV1`.    The parameter indicates if the job associated with the event    series is a on demand job.   ### Changes to V1 API in Rubrik Version 5.2.1  ## New features:  * Added optional query parameters limit and offset to support pagination for    GET /role endpoint.   ### Changes to V1 API in Rubrik Version 5.2.0  ## Deprecation:  * Deprecating `slaId` field returned by `GET /mssql/db/{id}/snapshot`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /mssql/db/snapshot/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /vmware/vm/{id}/snapshot`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /vmware/vm/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /vmware/vm/snapshot/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /hdfs/snapshot/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /hdfs`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `POST /hdfs`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /hdfs/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `PATCH /hdfs/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /fileset/snapshot/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /fileset`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `POST /fileset`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /fileset/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `PATCH /fileset/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating `slaId` field returned by `GET /failover_cluster/     failover_cluster_app/{id}`.     See **snapshotRetentionInfo** to track retention for     snapshots.  ## New features:  * Added new endpoint   `GET /data_source/{id}/expired_custom_retention_snapshots`.    Get all expired snapshots which were explicitly assigned a SLA domain.  * Added new field `parentSnapshotId` to FilesetSnapshotDetail returned by    `GET /fileset/snapshot/{id}`.  * Added new field `parentSnapshotId` to HdfsSnapshotDetail returned by    `GET /hdfs/snapshot/{id}`.  * Added new field `parentSnapshotId` to MssqlDbSnapshotSummary returned by    `GET /mssql/db/{id}/snapshot`.  * Added new field `parentSnapshotId` to MssqlDbSnapshotDetail returned by    `GET /mssql/db/snapshot/{id}`.  * Added new field `parentSnapshotId` to VmSnapshotSummary returned by    `GET /vmware/vm/{id}/snapshot`.  * Added new field `parentSnapshotId` to VmSnapshotDetail returned by    `GET /vmware/vm/snapshot/{id}`.  * Added new field `retentionSlaDomanId` to MssqlHierarchyObjectSummary    returned by `GET /mssql/hierarchy/{id}`.  * Added new field `retentionSlaDomanId` to MssqlHierarchyObjectSummary    returned by `GET /mssql/hierarchy/{id}/descendants`.  * Added new field `retentionSlaDomanId` to MssqlHierarchyObjectSummary    returned by `GET /mssql/hierarchy/{id}/children`.  * Added new field `retentionSlaDomanId` to MssqlDbDetail    returned by `GET /mssql/db/{id}`.  * Added new field `retentionSlaDomanId` to MssqlDbDetail    returned by `PATCH /mssql/db/{id}`.  * Added new field `retentionSlaDomanId` to MssqlDbDetail    returned by `PATCH /mssql/db/bulk`.  * Added new field `retentionSlaDomanId` to MssqlDbSnapshotDetail    returned by `GET /mssql/db/snapshot/{id}`.  * Added new field `retentionSlaDomanId` to MssqlDbSummary    returned by `GET /mssql/db`.  * Added new field `retentionSlaDomainId` to ComputeClusterDetail    returned by `PATCH /vmware/compute_cluster/{id}`.  * Added new field `retentionSlaDomainId` to VmwareHostDetail    returned by `PATCH /vmware/host/{id}`.  * Added new field `retentionSlaDomainId` to VmwareVmMountDetailV1    returned by `PATCH /vmware/vm/snapshot/mount/{id}`.  * Added new field `retentionSlaDomainId` to VmwareVmMountSummary    returned by `GET /vmware/vm/snapshot/mount`.  * Added new field `retentionSlaDomainId` to BulkOracleDbDetails    returned by `PATCH /oracle/db/bulk`.  * Added new field `retentionSlaDomainId` to ComputeClusterDetail    returned by `GET /vmware/compute_cluster/{id}`.  * Added new field `retentionSlaDomainId` to UnmanagedObjectDetails    returned by `GET /unmanaged_object`.  * Added new field `retentionSlaDomainId` to UnmanagedObjectSummary    returned by `GET /unmanaged_object/reader_object`.  * Added new field `retentionSlaDomainId` to VirtualMachineDetail    returned by `GET /vmware/vm/{id}`.  * Added new field `retentionSlaDomainId` to VirtualMachineDetail    returned by `PATCH /vmware/vm/{id}`.  * Added new field `retentionSlaDomainId` to VirtualMachineSummary    returned by `GET /vmware/vm`.  * Added new field `retentionSlaDomainId` to VmSnapshotDetail    returned by `GET /vmware/vm/snapshot/{id}`.  * Added new field `retentionSlaDomainId` to VmwareHostDetail    returned by `GET /vmware/host/{id}`.  * Added new field `retentionSlaDomainId` to VmwareVmMountDetailV1    returned by `GET /vmware/vm/snapshot/mount/{id}`.  * Added new field `retentionSlaDomainId` to UnmanagedObjectSummary    returned by `GET /unmanaged_object`.  * Added new endpoint `GET /report/compliance_summary_sla`. Returns the    compliance summary information for all protected objects based on a    SLA Domain-based requirement of whether the last expected snapshot was taken.    Currently behind flag, will not return correct information    until flag is flipped.  * Added endpoint `GET /cluster/{id}/upgrade/available_version` which       retrieves a list of Rubrik CDM versions available to upgrade the Rubrik       cluster.  * Added endpoint `GET /cluster/{id}/upgrade/request/${request_id}` to    query the status of an asynchronous upgrade related request.  * Added endpoint `POST /cluster/{id}/upgrade/stage_cdm_software` which    allows staging CDM software for upgrades on the cluster.  * Added new field `hasSnapshotsWithPolicy` to UnmanagedObjectDetails returned    by GET `/unmanaged_object`.  * Added new field `hasSnapshotsWithPolicy` to UnmanagedObjectSummary returned    by GET `/unmanaged_object`.  * Added new field `hasSnapshotsWithPolicy` to UnmanagedObjectSummary returned    by GET `/unmanaged_object/reader_object`  * Added new field `slaLastUpdateTime` to BulkOracleDbDetails    returned by `PATCH /oracle/db/bulk`.  * Added new field `slaLastUpdateTime` to BulkOracleHostDetails    returned by `PATCH /oracle/host/bulk`.  * Added new field `slaLastUpdateTime` to BulkOracleRacDetails    returned by `PATCH /oracle/rac/bulk`.  * Added new field `slaLastUpdateTime` to ComputeClusterDetail    returned by `GET /vmware/compute_cluster/{id}`.  * Added new field `slaLastUpdateTime` to ComputeClusterDetail    returned by `PATCH /vmware/compute_cluster/{id}`.  * Added new field `slaLastUpdateTime` to ComputeClusterSummary    returned by `GET /vmware/compute_cluster`.  * Added new field `slaLastUpdateTime` to FailoverClusterAppDetail    returned by `GET /failover_cluster/failover_cluster_app/{id}`.  * Added new field `slaLastUpdateTime` to FailoverClusterAppSummary    returned by `GET /failover_cluster/failover_cluster_app`.  * Added new field `slaLastUpdateTime` to FailoverClusterAppSummary    returned by POST `/failover_cluster/failover_cluster_app`.  * Added new field `slaLastUpdateTime` to FailoverClusterAppSummary    returned by `PATCH /failover_cluster/failover_cluster_app/{id}`.  * Added new field `slaLastUpdateTime` to FailoverClusterDetail    returned by POST `/failover_cluster`.  * Added new field `slaLastUpdateTime` to FailoverClusterDetail    returned by `GET /failover_cluster/{id}`.  * Added new field `slaLastUpdateTime` to FailoverClusterDetail    returned by `PATCH /failover_cluster/{id}`.  * Added new field `slaLastUpdateTime` to FailoverClusterHierarchyObjectSummary    returned by `GET /failover_cluster/hierarchy/{id}`.  * Added new field `slaLastUpdateTime` to FailoverClusterHierarchyObjectSummary    returned by `GET /failover_cluster/hierarchy/{id}/children`.  * Added new field `slaLastUpdateTime` to FailoverClusterHierarchyObjectSummary    returned by `GET /failover_cluster/hierarchy/{id}/descendants`.  * Added new field `slaLastUpdateTime` to FailoverClusterSummary    returned by `GET /failover_cluster`.  * Added new field `slaLastUpdateTime` to FilesetDetail    returned by `POST /fileset`.  * Added new field `slaLastUpdateTime` to FilesetDetail    returned by `GET /fileset/{id}`.  * Added new field `slaLastUpdateTime` to FilesetDetail    returned by `PATCH /fileset/{id}`.  * Added new field `slaLastUpdateTime` to FilesetSummary    returned by `GET /fileset`.  * Added new field `slaLastUpdateTime` to HdfsDetail    returned by `POST /hdfs`.  * Added new field `slaLastUpdateTime` to HdfsDetail    returned by `GET /hdfs/{id}`.  * Added new field `slaLastUpdateTime` to HdfsDetail    returned by `PATCH /hdfs/{id}`.  * Added new field `slaLastUpdateTime` to HdfsSummary    returned by `GET /hdfs`.  * Added new field `slaLastUpdateTime` to HostHierarchyObjectSummary    returned by `GET /host/hierarchy/{id}`.  * Added new field `slaLastUpdateTime` to HostHierarchyObjectSummary    returned by `GET /host/hierarchy/{id}/children`.  * Added new field `slaLastUpdateTime` to VcenterDetail    returned by `GET /vmware/vcenter/{id}`.  * Added new field `slaLastUpdateTime` to VcenterSummary    returned by `GET /vmware/vcenter`.  * Added new field `slaLastUpdateTime` to VcenterSummary    returned by `PATCH /vmware/vcenter/{id}`.  * Added new field `slaLastUpdateTime` to VcenterSummary    returned by `PUT /vmware/vcenter/{id}`.  * Added new field `slaLastUpdateTime` to VirtualMachineDetail  * Added `PATCH /host/share/bulk` endpoint to update multiple network shares.  * Added new field `isCustomRetentionApplied` to SnapshotSummary returned by    `GET /unmanaged_object/{id}/snapshot`.  * Added new field `slaLastUpdateTime` to VirtualMachineDetail    returned by `GET /vmware/vm/{id}`.  * Added new field `slaLastUpdateTime` to VirtualMachineDetail    returned by `PATCH /vmware/vm/{id}`.  * Added new field `slaLastUpdateTime` to VirtualMachineSummary    returned by `GET /vmware/vm`.  * Added new field `slaLastUpdateTime` to VmSnapshotDetail    returned by `GET /vmware/vm/snapshot/{id}`.  * Added new field `slaLastUpdateTime` to VmwareHostDetail    returned by `GET /vmware/host/{id}`.  * Added new field `slaLastUpdateTime` to VmwareHostDetail    returned by `PATCH /vmware/host/{id}`.  * Added new field `slaLastUpdateTime` to VmwareHostSummary    returned by `GET /vmware/host`.  * Added new field `slaLastUpdateTime` to VmwareVmMountDetailV1    returned by `GET /vmware/vm/snapshot/mount/{id}`.  * Added new field `slaLastUpdateTime` to VmwareVmMountDetailV1    returned by `PATCH /vmware/vm/snapshot/mount/{id}`.  * Added new field `slaLastUpdateTime` to VmwareVmMountSummary    returned by `GET /vmware/vm/snapshot/mount`.  * Added new field `isCustomRetentionApplied` to SnapshotSummary returned by    `GET /unmanaged_object/{id}/snapshot`.  * Added new Field `configuredSlaDomainType` to BulkOracleDbDetails returned by   `PATCH /oracle/db/bulk`.  * Added new Field `configuredSlaDomainType` to BulkOracleHostDetails returned    by `PATCH /oracle/host/bulk`.  * Added new Field `configuredSlaDomainType` to BulkOracleRacDetails returned by   `PATCH /oracle/rac/bulk`.  * Added new Field `configuredSlaDomainType` to ComputeClusterDetail returned by   `GET /vmware/compute_cluster/{id}`.  * Added new Field `configuredSlaDomainType` to ComputeClusterDetail returned by   `PATCH /vmware/compute_cluster/{id}`.  * Added new Field `configuredSlaDomainType` to ComputeClusterSummary returned    by `GET /vmware/compute_cluster`.  * Added new Field `configuredSlaDomainType` to FailoverClusterAppDetail    returned by `GET /failover_cluster/failover_cluster_app/{id}`.  * Added new Field `configuredSlaDomainType` to FailoverClusterAppSummary    returned by `GET /failover_cluster/failover_cluster_app`.  * Added new Field `configuredSlaDomainType` to FailoverClusterAppSummary    returned by `POST /failover_cluster/failover_cluster_app`.  * Added new Field `configuredSlaDomainType` to FailoverClusterAppSummary    returned by `PATCH /failover_cluster/failover_cluster_app/{id}`.  * Added new Field `configuredSlaDomainType` to FailoverClusterDetail returned    by `POST /failover_cluster`.  * Added new Field `configuredSlaDomainType` to FailoverClusterDetail returned    by `GET /failover_cluster/{id}`.  * Added new Field `configuredSlaDomainType` to FailoverClusterDetail returned    by `PATCH /failover_cluster/{id}`.  * Added new Field `configuredSlaDomainType` to    FailoverClusterHierarchyObjectSummary returned by    `GET /failover_cluster/hierarchy/{id}`.  * Added new Field `configuredSlaDomainType` to    FailoverClusterHierarchyObjectSummary returned by    `GET /failover_cluster/hierarchy/{id}/children`.  * Added new Field `configuredSlaDomainType` to    FailoverClusterHierarchyObjectSummary returned by    `GET /failover_cluster/hierarchy/{id}/descendants`.  * Added new Field `configuredSlaDomainType` to  FailoverClusterSummary returned    by `GET /failover_cluster`.  * Added new Field `configuredSlaDomainType` to FilesetDetail returned by   `POST /fileset`.  * Added new Field `configuredSlaDomainType` to FilesetDetail returned by   `GET /fileset/{id}`.  * Added new Field `configuredSlaDomainType` to FilesetDetail returned by   `PATCH /fileset/{id}`.  * Added new Field `configuredSlaDomainType` to FilesetSummary returned by   `GET /fileset`.  * Added new Field `configuredSlaDomainType` to HdfsDetail returned by   `POST /hdfs`.  * Added new Field `configuredSlaDomainType` to HdfsDetail returned by   `GET /hdfs/{id}`.  * Added new Field `configuredSlaDomainType` to HdfsDetail returned by   `PATCH /hdfs/{id}`.  * Added new Field `configuredSlaDomainType` to HdfsSummary returned by   `GET /hdfs`.  * Added new Field `configuredSlaDomainType` to HostHierarchyObjectSummary    returned by `GET /host/hierarchy/{id}`.  * Added new Field `configuredSlaDomainType` to HostHierarchyObjectSummary    returned by `GET /host/hierarchy/{id}/children`.  * Added new Field `configuredSlaDomainType` to UnmanagedObjectDetails returned    by `GET /unmanaged_object`.  * Added new Field `configuredSlaDomainType` to UnmanagedObjectSummary returned    by `GET /unmanaged_object`.  * Added new Field `configuredSlaDomainType` to UnmanagedObjectSummary returned    by `GET /unmanaged_object/reader_object`.  * Added new Field `configuredSlaDomainType` to VcenterDetail returned by    `GET /vmware/vcenter/{id}`.  * Added new Field `configuredSlaDomainType` to VcenterSummary returned by    `GET /vmware/vcenter`.  * Added new Field `configuredSlaDomainType` to VcenterSummary returned by    `PATCH /vmware/vcenter/{id}`.  * Added new Field `configuredSlaDomainType` to VcenterSummary returned by    `PUT /vmware/vcenter/{id}`.  * Added new Field `configuredSlaDomainType` to VirtualMachineDetail returned by    `GET /vmware/vm/{id}`.  * Added new Field `configuredSlaDomainType` to VirtualMachineDetail returned by   `PATCH /vmware/vm/{id}`.  * Added new Field `configuredSlaDomainType` to VirtualMachineSummary returned    by `GET /vmware/vm`.  * Added new Field `configuredSlaDomainType` to VmSnapshotDetail returned by   `GET /vmware/vm/snapshot/{id}`.  * Added new Field `configuredSlaDomainType` to VmwareHostDetail returned by   `GET /vmware/host/{id}`.  * Added new Field `configuredSlaDomainType` to VmwareHostDetail returned by   `PATCH /vmware/host/{id}`.  * Added new Field `configuredSlaDomainType` to VmwareHostSummary returned by   `GET /vmware/host`.  * Added new Field `configuredSlaDomainType` to VmwareVmMountDetailV1 returned    by `GET /vmware/vm/snapshot/mount/{id}`.  * Added new Field `configuredSlaDomainType` to VmwareVmMountDetailV1 returned    by `PATCH /vmware/vm/snapshot/mount/{id}`.  * Added new Field `configuredSlaDomainType` to VmwareVmMountSummary returned by   `GET /vmware/vm/snapshot/mount`.  * Added new field `isCustomRetentionApplied` to FilesetSnapshotDetail returned    by `GET /fileset/snapshot/{id}`.  * Added new field `isCustomRetentionApplied` to HdfsSnapshotDetail returned by    `GET /hdfs/snapshot/{id}`.  * Added new field `isCustomRetentionApplied` to MssqlDbSnapshotSummary returned    by `GET /mssql/db/{id}/snapshot`.  * Added new field `isCustomRetentionApplied` to MssqlDbSnapshotDetail returned    by `GET /mssql/db/snapshot/{id}`.  * Added new field `isCustomRetentionApplied` to VmSnapshotSummary returned by    `GET /vmware/vm/{id}/snapshot`.  * Added new field `isCustomRetentionApplied` to VmSnapshotDetail returned by    `GET /vmware/vm/snapshot/{id}`.  * Added endpoint `POST /cluster/{id}/manual_discover`, which allows    the customer to manually input data that would be learned using    mDNS discovery. Returns same output as the `discover` endpoint.  * Added new endpoint `POST /data_source/{id}/snapshot/bulk_delete`.     Delete given snapshots for an object.  * Added new endpoint `POST /data_source/snapshot/bulk_delete`.     Delete all snapshots for given objects.  * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field    of `SnapshotRetentionInfo` field of FilesetSnapshotDetail returned by    `GET /fileset/snapshot/{id}`.  * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field    of `SnapshotRetentionInfo` field of HdfsSnapshotDetail returned by    `GET/hdfs/snapshot/{id}`.  * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field    of `SnapshotRetentionInfo` field of MssqlDbSnapshotSummary returned by    `GET /mssql/db/{id}/snapshot`.  * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field    of `SnapshotRetentionInfo` field of MssqlDbSnapshotDetail returned by    `GET /mssql/db/snapshot/{id}`.  * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field    of `SnapshotRetentionInfo` field of VmSnapshotSummary returned by    `GET /vmware/vm/{id}/snapshot`.  * Added new field `snapshotFrequency` to `snapshotLocationRetentionInfo` field    of `SnapshotRetentionInfo` field of VmSnapshotDetail returned by    `GET /vmware/vm/snapshot/{id}`.  * Added new field `SnapshotRetentionInfo` to FilesetSnapshotDetail returned by    `GET /fileset/snapshot/{id}`.  * Added new field `SnapshotRetentionInfo` to HdfsSnapshotDetail returned by    `GET /hdfs/snapshot/{id}`.  * Added new field `SnapshotRetentionInfo` to MssqlDbSnapshotSummary returned by    `GET /mssql/db/{id}/snapshot`.  * Added new field `SnapshotRetentionInfo` to MssqlDbSnapshotDetail returned by    `GET /mssql/db/snapshot/{id}`.  * Added new field `SnapshotRetentionInfo` to VmSnapshotSummary returned by    `GET /vmware/vm/{id}/snapshot`.  * Added new field `SnapshotRetentionInfo` to VmSnapshotDetail returned by    `GET /vmware/vm/snapshot/{id}`.  * Added new endpoint `GET /unmanaged_object/{id}/snapshot`. Returns summary    of all the snapshots for a given object.  * Added new endpoint `GET /unmanaged_object`. Returns the summary of all the    objects with unmanaged snapshots.  * Added new endpoint `GET /report/compliance_summary`. Returns the summary of    snapshot compliance based on a time-based requirement of at least one    snapshot in each 24 hour report period for each protected object.    This endpoint ignores the policies assigned to protected objects through SLA    Domains.  * Added new endpoint `GET /cluster/{id}/node_id`. Returns the IDs of the    nodes in the cluster.  * Added new endpoint `GET /role`. Returns role metadata for all roles in an    organization.  * Added new endpoint `POST /role`. Create a new role.  * Added new endpoint `GET /role/{id}`. Get role metadata and the list of    principals assigned to a specific role.  * Added new endpoint `PATCH /role/{id}`. Update metadata for a specific role.  * Added new endpoint `DELETE /role/{id}`. Delete a role.  * Added new endpoint `GET /principal`. Get principals.  * Added new endpoint `GET /principal/role`. Get list of roles assigned to    principals.  * Added new endpoint `POST /principal/role`. Assign roles to principals.  * Added new endpoint `POST /principal/role/bulk_revoke`. Revoke roles from    principals.  * Added `DELETE /certificate/{id}` endpoint to delete a certificate.  * Added `PATCH /cluster/{id}/security/cors` endpoint to update the current CORS    support configuration for a web server.  * Added `GET /cluster/{id}/security/cors` endpoint to get the current CORS    support configuration for a web server.  * Added new optional field `failoverClusterAppId` to FilesetSummary and    FilesetCreate in `POST /fileset`, `GET /fileset` and `PATCH /fileset/{id}`    endpoints to enable clustered fileset backup.  * Added `GET /unmanaged_object/reader_object` endpoint to get all    unmanaged objects that are recovered from reader archival locations.  * Added `GET /failover_cluster` endpoint to get all failover clusters.  * Added `POST /failover_cluster` endpoint to create a failover cluster.  * Added `GET /failover_cluster/{id}` endpoint to retrieve a failover    cluster by id.  * Added `PATCH /failover_cluster/{id}` endpoint to update a failover cluster.  * Added `DELETE /failover_cluster/{id}` endpoint to delete a failover cluster.  * Added `GET /failover_cluster/failover_cluster_app` endpoint to get all    failover cluster apps.  * Added `POST /failover_cluster/failover_cluster_app` endpoint to create a    failover cluster app.  * Added `GET /failover_cluster/failover_cluster_app/{id}` endpoint to retrieve    a failover cluster app by ID.  * Added `PATCH /failover_cluster/failover_cluster_app/{id}` endpoint to update    a failover cluster app.  * Added `DELETE /failover_cluster/failover_cluster_app/{id}` endpoint to delete    a failover cluster app.  * Added `GET /legal_hold/snapshot` endpoint to get snapshots under legal hold.  * Added `POST /legal_hold/snapshot` endpoint to apply legal hold on a snapshot.  * Added `GET /legal_hold/object` endpoint to get all objects with snasphot    under legal hold.  * Added `POST /legal_hold/snapshot/dissolve` to dissolve legal hold from    snapshots.  * Added optional field `shouldUseAgent` to `RestoreFileJobConfig`.    in `POST /vmware/vm/snapshot/{id}/restore_file` to specify    whether to use Rubrik Backup Service to restore file. Default value is true.  * Added `America/Costa_Rica`and `America/St_Johns` as supported cluster time    zones.  * Added `GET /failover_cluster/hierarchy/{id}` to get summary of a    failover cluster hierarchy object.  * Added `GET /failover_cluster/hierarchy/{id}/children` to get list of    immediate descendant objects.  * Added `GET /failover_cluster/hierarchy/{id}/descendants` to get list of    descendant objects.  * Added `GET /job_monitoring` to get job summary information, with options    to filter and sort the results for protection and recovery jobs that are    currently running, scheduled to run or completed in the past 24 hours.  * Added `GET /job_monitoring/summary_by_job_type` to get job summary    information separated by job type for all jobs that are currently running,    scheduled to run or completed in the past 24 hours.  * Added `GET /job_monitoring/summary_by_job_state` to get job summary    information separated by job state for all running jobs, jobs that have    been scheduled and jobs that are complete, for protection and recovery    jobs in the past 24 hours.  * Added `GET /job_monitoring/csv_download_link` which returns a link to    download job summary information with the same filters as the    `GET /job_monitoring` API.  * Added optional field 'legalHoldDownloadConfig' to    'FilesetDownloadFileJobConfig', 'DownloadFileJobConfig'.    This is an optional argument containing a Boolean parameter to depict if    the download is being triggered for Legal Hold use case.  * Added optional field isPlacedOnLegalHold to BaseSnapshotSummary.    The Boolean parameter specifies whether the snapshot is placed under a    Legal Hold.  * Added `POST /mssql/db/{id}/browse` endpoint to list backups, which includes    both snapshots and logs.  * Added `POST /mssql/db/{id}/download_files` endpoint to download a list of    backup files specified by time range or point in time.  * Added `POST /mssql/db/{id}/download_files_by_id` endpoint to download a list    of backup files specified by ID.  * Added `PATCH /report/config` to set the number of days for which the report    job instances for log jobs are retained.  * Added ISO8601 format date as a way of specifying time in MssqlRecoveryPoint.  * Added primaryDatabaseLogBackupFrequency parameter to the response objects    MssqlLogShippingSummary and MssqlLogShippingDetail.  * Added targetInstanceName parameter to MssqlMountSummary  * Added `POST /mssql/db/{id}/download` endpoint to download the logs/snapshots    required to restore a SQL database to a given recovery point.  * Added the optional fields uid, surname, and emailAddress to the    GenericCsrRequest (renamed from CsrRequest) and renamed WebCsrRequest    to CsrRequest.  * Added new endpoints `PATCH /oracle/db/bulk`,    `PATCH /oracle/host/bulk`, and `PATCH /oracle/rac/bulk` for bulk    updating an array of IDs with `OracleProperties`.  * Added an optional query parameter    `should_apply_to_existing_snapshots` to `PATCH /sla_domain/{id}` to    apply the new SLA configuration to existing snapshots of data sources    retained by the specified SLA Domain.  * Added an optional query parameter    `should_apply_to_existing_snapshots` to `PUT /sla_domain/{id}` to    apply the new SLA configuration to existing snapshots of data sources    retained by the specified SLA Domain.  * Added optional field 'shouldForce' to 'UpdateMountConfig' in PATCH    vmware/vm/snapshot/mount/{id} endpoint. Use this field to forcibly power    down a virtual machine mounted with Storage vMotion.  * Added a new optional field `isOracleHost` to `HostRegister` in `POST /host`.    and `HostUpdate` in `PATCH /host/{id}` to indicate if we should discover    Oracle information during registration and host refresh.  * Added a new model `EventCsvDownloadResponse` and REST API endpoints    `/event/csv_download_link` for downloading CSV file for event summary    information in the Activity log UI page.  * Added `GET /host/hierarchy/{id}` to get summary of a    host/share hierarchy object.  * Added `GET /host/hierarchy/{id}/children` to get list of    immediate descendant objects.  * Added `isInVmc` in `GET /vmware/vm/{id}` and `PATCH /vmware/vm/{id}`.    to return whether the virtual machine is in a VMC setup.  * Added `pendingSlaDomain` field to `GET /vmware/vm/{id}` and    `PATCH /vmware/vm/{id}` to indicate a pending SLA Domain assignment    on the Virtual Machine.  * Added `pendingSlaDomain` field to `GET /mssql/hierarchy/{id}`,    `GET /mssql/hierarchy/{id}/children`, and    `GET /mssql/hierarchy/{id}/descendants` to indicate a pending SLA    Domain assignment on the MSSQL object.  * Added `pendingSlaDomain` field to `GET /fileset`,    `POST /fileset`, `GET /fileset/{id}`, and `PATCH /fileset/{id}`    to indicate a pending SLA Domain assignment on the Fileset.  * Added `pendingSlaDomain` field to the objects referenced by the    `filesets` field in the response objects of    `GET /failover_cluster/hierarchy/{id}`,    `GET /failover_cluster/hierarchy/{id}/children`,    `GET /failover_cluster/hierarchy/{id}/descendants`,    `GET /host/hierarchy/{id}`, and `GET /host/hierarchy/{id}/children`    to indicate a pending SLA Domain assignment on the object.  * Added endpoint `POST /vmware/vcenter/{id}/refresh_vm` which     allows refreshing metadata for a single virtual machine in a vCenter.  * Added optional field `shouldForceFull` to the body parameter of    `PATCH /mssql/db/{id}` to enable requiring a full snapshot for a specified     SQL Server database.  * Added `LinuxHost`, `WindowsHost` and `NasHost` to the    `object_type` filtering field of the `GET /event/latest` endpoint.   ### Changes to V1 API in Rubrik Version 5.1.1  ## Breaking changes:   ## New features:  * Added `has_instances` parameter to GET `/mssql/hierarchy/{id}/descendants`.    and GET `/mssql/hierarchy/{id}/children`. Added `hasInstances` field in the    response object.   ### Changes to V1 API in Rubrik Version 5.1.0  ## Deprecation:   ## New features:  * Added `GET /archive/aws/s3/{id}/account_id` endpoint to get the    account ID of the AWS data location.  * Added `DELETE /authorization/cache` endpoint to clear cached authorization    information.  * Added the `GET /syslog/export` endpoint to get all syslog export rules.  * Added the `POST /syslog/export` endpoint to add a syslog export rule.  * Added the `GET /syslog/export/{id}` endpoint to get a syslog export rule.  * Added the `PATCH /syslog/export/{id}` endpoint to update a syslog export    rule.  * Added the `DELETE /syslog/export/{id}` endpoint to delete a syslog export    rule.  * Added the `POST /syslog/export/test` endpoint to test a syslog export rule.  * Added stubs for the `GET /event/latest` endpoint to V1 to    facilitate a future migration from internal to V1.  * Added stubs for the `GET /event_series/{id}` endpoint to V1    to facilitate a future migration from internal to V1.  * Added stubs for the `GET /event` endpoint to V1 to facilitate    a future migration from internal to V1.  * Added optional query parameter 'snappableStatus' to /vmware/vcenter,    /vmware/compute_cluster, /vmware/host,  /host, /mssql/instance, and    /windows_cluster. This parameter enables a user to fetch the set of    protectable objects from the list of objects visible to that user.  * Added optional field `alias` to HostSummary, HostRegister, and HostUpdate    schemas. This field will allow the user to specify an alias for each host    which can be used for search.  * Added `POST /archive/location/{location_id}/reader/refresh/data_sources`.    endpoint to refresh the metadata of a list of given data sources from    the given reader location.  * Added `POST /managed_volume/snapshot/export/{id}/script` endpoint to    generate a script to create a directory to view all files in all channels    of a managed volume snapshot export.  * Moved the `GET /blackout_window` endpoint from internal to V1.  * Moved the `PATCH /blackout_window` endpoint from internal to V1.  * Added `GET /certificate` endpoint to get all imported certificates.  * Added `POST /certificate` endpoint to import a certificate.  * Added `GET /certificate/{id}` endpoint to retrieve a certificate by id.  * Added `PATCH /certificate/{id}` endpoint to update a certificate.  * Added `GET /csr` endpoint to get all outstanding    Certificate-Signing-Requests.  * Added `POST /csr` endpoint to generate a Certificate-Signing-Request.  * Added 'DELETE /oracle/db/{id}/downloaded__snapshots' endpoint    to delete downloaded Oracle db snapshots and log snapshots.  * Added unauthenticated endpoint `GET /saml/sso_status` to check    SAML SSO status. For example, we can check whether SSO is enabled or not.  * Added optional field archivalTieringSpec to ArchivalSpecV2 to support    archival tiering. This enables the user to configure either Instant Tiering    or Smart Tiering (with a corresponding minimum accessible duration) on an    SLA domain with archival configured to an Azure archival location.  * Updated endpoint /mssql/db to have a new optional query paramter,    indicating if backup task information should be included.  * Added the `IoFilterSummary` object with `id`, `name`, `version`, `vendor`.    fields and `summary`, `releaseDate` optional fields.  * Added `GET /vmware/computer_cluster/request/{id}` endpoint to get the details    of an asynchronous request that involves a VMware compute cluster.  * Added `PATCH /vmware/computer_cluster/{id}` endpoint to update    the configuredSlaDomainId for a VMware compute cluster with a specific ID.  * Added `GET /vmware/compute_cluster/{id}/io_filter` to get the ioFilters on    the VMware compute cluster with a specific ID.  * Added `POST /vmware/compute_cluster/{id}/install_io_filter` endpoint to    install the Rubrik ioFilter to the VMware compute cluster with a specific    ID.  * Added `POST /vmware/compute_cluster/{id}/uninstall_io_filter` endpoint to    uninstall the Rubrik ioFilter from the VMware compute cluster with a    specific ID.  * Added `POST /vmware/compute_cluster/{id}/upgrade_io_filter` endpoint to    upgrade the Rubrik ioFilter to the latest version for the VMware compute    cluster with a specific ID.  * Moved the `GET /vmware/compute_cluster` endpoint from internal to V1.  * Moved the `GET /vmware/compute_cluster/{id}` endpoint from internal to V1.  * Added endpoint /saml/authn_request/{idp_name} for making SAML  * Added an optional field 'isRetentionLocked' to 'POST /sla_domain',    'PUT /sla_domain/{id}' and 'PATCH /sla_domain/{id}' to allow users to manage    the Retention Lock capabilities of an SLA Domain.  * Added endpoint 'POST /saml/authn_request/{idp_name}' for making SAML    authentication request for a given ID Provider.  * Added endpoint 'POST /saml/rubrik_metadata' for downloading Rubrik SAML    metadata file.  * Added a series of new endpoints /idp_auth_domain for managing SAML    Id Provider integration.  * Moved the 'connectionStatus' field from VcenterDetail to VcenterSummary.  * Added new optional query parameters 'data_sources' and 'snapshot_ids' to    'GET /sla_domain' endpoint. This allows users to filter SLA Domains based    on whether they can be assigned to specified data sources and snapshots.  * Changed the existing endpoints `GET /mssql/db/` `GET /mssql/instance`.    `GET /mssql/db/{id}` `PATCH /mssql/db/{id}` `GET /mssql/db/snapshot/{id}`.    `GET /mssql/instance/{id}` `GET /mssql/instance/{id}` to return an    unprotectable reason as a string in the 'unprotectableReason' field instead    of a JSON struct.  * Added a `PUT /host/certificate/{id}` endpoint to update the    certificate of the given host  * Added `GET /vcd/vapp/template/snapshot/{snapshot_id}/export` to get    available options for a vApp template snapshot export.  * Added `POST /vcd/vapp/template/snapshot/{snapshot_id}/export` to queue    export of a vApp template snapshot.  * Added continuous data protection state for each VMware virtual machine.  * Added optional field 'isIoFilterInstalled' to vCenter summary. Returns true    if any Rubrik IO filters are installed on any compute clusters that are    a part of the vCenter.  * Added optional field `cloudStorageTier` to `BaseSnapshotSummary`, to indicate    the current storage tier of the archived copy of a snapshot.  * Added `POST ` /vmware/vm/cdp endpoint to get live CDP info for a list of    virtual machines.  * Added `POST ` /vmware/vm/cdp_state endpoint to get CDP state info for a list    of virtual machines.  * Added the optional field isEffectiveSlaDomainRetentionLocked to    FilesetSummary. The field is a Boolean that specifies whether the effective    SLA Domain of a fileset is retention locked.  * Added optional field isEffectiveSlaDomainRetentionLocked to `Snappable`.    The parameter depicts if the effective SLA domain for the data source is    a Retention Lock SLA Domain.  * Added optional field isConfiguredSlaDomainRetentionLocked to SlaAssignable.    The parameter depicts if the configured SLA domain for the object is a    Retention Lock SLA Domain.  * Added optional parameter `ignore_connection_status` to `GET /vmware/vcenter`.    to skip calculating connection status.  * Added required fields: isCdpEnabled(type: boolean) and cdpState(type:    CdpState Enum) to VirtualMachineDetails.  * Moved the GET `/mssql/hierarchy/{id}/descendants` and    GET `/mssql/hierarchy/{id}/children` endpoints from internal to v1.    Added the `is_relic`, `is_live_mount` `is_clustered`, and    `is_log_shipping_secondary`.    parameters. Changed acceptable values of `object_type` and `sort_by`.    parameters. Added `hasPermissions`, `isInAvailabilityGroup`,    `descendantSlaDomains`, `instanceChildren`,    `unprotectableReasons`, `isLiveMount`, `isLogShippingSecondary`,    `hostStatus`, `cbtEnabled`, `cbtEffectiveStatus`, `isClustered` and    `clusterInstanceAddress` fields in the    response object. Removed `replicaCount` field in the response object.    Added support for returning non-availability databases.    Changed `object_type` query parameter to take a comma-separated list of    object types.    Added the GET `/mssql/hierarchy/{id}` endpoint to get a specific hierarchy    object.  * Added the POST `/mssql/sla_domain/assign` endpoint to assign SLA properties    to SQL Server objects.  * Added isRetentionLocked to MssqlInstanceSummary.   ### Changes to V1 API in Rubrik Version 5.0.3  ## Deprecation:   ## New features and improvements:  * Added a new optional field 'oracleQueryUser' to HostRegister, HostUpdate    and HostDetail objects, for setting the Oracle username for account with    query privileges on the host. This applies the following endpoints:    POST /host/bulk, PATCH /host/{id}, and GET /host/{id}.   ### Changes to V1 API in Rubrik Version 5.0.2  ## Deprecation:   ## New features and improvements:  * Added `GET /oracle/db/{id}/restore_estimate` endpoint to provide an    estimate of the amount of data that must be downloaded for a restore    operation.  * Introduced optional field `logicalSize` to `VirtualMachineDetail`. This    field gives the sum of logical sizes of all the disks in the virtual    machine.  * Added optional parameter `ignore_connection_status` to    `GET /vmware/vcenter/{id}`. Set this parameter to skip calculating    connection status.   ### Changes to V1 API in Rubrik Version 5.0.1  ## Deprecation:   ## New features and improvements:  * Added `GET /cluster/{id}/security/encryption` endpoint to provide encryption    at rest status of the cluster.  * Added `GET /vmware/host/{id}/datastore` endpoint to get the details    of datastores for an ESXi host.  * Added `POST /vmware/vm/mount/{id}/relocate` endpoint to migrate datastore    for a virtual machine from Live Mount or Instant Recovery.  * Added `America/Santiago`, `Australia/Adelaide` and `Australia/Brisbane` as    supported cluster time zones.   ### Changes to V1 API in Rubrik Version 5.0.0  ## Deprecation:  * Deprecating query paramter `hostname` of `GET /host` and response property    `hostname` of `GET /host`, `POST /host`, `PUT /host/certificate/{id}`,    `GET /host/{id}`, `PATCH /host/{id}`, and `POST /host/{id}/refresh`.    Use `name` instead. Support for `hostname` is present in v1 and removed in v2.  * Deprecating response property `isArchived` of `GET /mssql/db`,    `GET /mssql/db/{id}`, and `PATCH /mssql/db/{id}`. Use    `isDeleted` instead. Support for `isArchived` is present in v1 and removed in v2.  * Deprecating parameter `datastoreName` of `Post /vmware/vm/snapshot/{id}/mount`.   ## New features:  * Added a new PUT endpoint to /ldap_service/{id}.  * Added /cluster/{id}/snmp_mib_link endpoint.  * Added a new optional field 'oracleSysDbaUser' to /host/{id} POST endpoint    during register host for setting the Oracle username for account with sysdba    privileges on this host.  * Added a new optional field 'oracleSysDbaUser' to /host/{id} endpoint for    changing the Oracle username for account with sysdba privileges on this    host.  * Added a new optional field 'mfaServerId' to /ldap_service endpoint for    associating a configured MFA server.  * Added a new /sla_domain endpoint with the same functionality as /v1, but    added support for weekly and quarterly time units and modify the config of    monthly and yearly.  * Added a new optional field 'isArrayEnabled' to 'FilesetTemplateCreate'    for creation of storage array-enabled fileset templates. We also include    this new field in 'FilesetTemplateDetail'.  * Added a new optional field 'arraySpec' to 'FilesetCreate' for    creation of storage array-enabled filesets. We also include    this new field in the responses of the `GET /fileset/{id}` and    `GET /fileset` endpoints.  * Added ability to use the /host/{id} endpoint to specify a host level    setting for enabling or disabling CBT backups of SQL Server databases,    along with new optional fields 'mssqlCbtEnabled', 'mssqlCbtEffectiveStatus'    and 'mssqlCbtDriverInstalled'.  * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster    to remove the CBT driver from a Windows host that has CBT backups of SQL    Server databases disabled.  * Added new optional field 'isPassthrough' to 'POST /fileset' endpoint to    indicate if we want to take a direct archive backup.  * Added a new field unprotectable_reasons to GET /mssql/db/{id} and    GET /mssql/instance/{id}. This field keeps track of the reasons that a    SQL Server database or instance cannot be protected by Rubrik.  * Added ability to use the /host/{id} endpoint to specify a host level    setting for enabling or disabling VFD backups of volumes on Windows hosts.  * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster    to remove the VFD driver from a Windows host that has VFD backups of volumes    disabled.  * Added new optional field 'isOverwrite' to ExportMssqlDbJobConfig for    'POST /mssql/db/{id}/export' endpoint to enable overwriting an existing    database while using the export operation.  * Added a new optional field 'allowOverwrite' to the    'POST /mssql/db/{id}/export' endpoint to allow overwriting an existing    database during the export.  * Added a new field 'hasAttachingDisk' to 'GET /vmware/vm/snapshot/mount' and    'GET /vmware/vm/snapshot/mount/{id}' that indicates to the user whether    this is an attaching disk mount job.  * Added a new field 'attachingDiskCount' to 'GET /vmware/vm/snapshot/mount'    and 'GET /vmware/vm/snapshot/mount/{id}' that indicate to the user how many    disks are attached.  * Removed optional field 'clusterInstanceAddress' from    'PATCH /mssql/instance/{id}' endpoint since host-centric discovery for    cluster instances eliminates the need to edit the instance address.  * Added new field `missedSnapshotTimeUnits` in `MissedSnapshot`.  * Added new field 'vmxFileContent' in getSnapshotDetail  * Added new optional fields 'organizationId' and 'organizationName' to    `/host/{id}` and `/host` endpoints to get the organization a host is    assigned to due to Envoy.  * Added new field 'vmwareTagList' in getSnapshotDetail  * Added new endpoint GET /cluster/{id}/certificate to get the cluster cert.  * Added new optional field PATCH /vmware/vm/{id} to indicate whether or not    to refresh the in-memory cache after updates to a virtual machine record.  * Added new field 'shouldRecoverTags' in MountSnapshotJobConfigV1  * Added new field 'shouldRecoverTags' in InstantRecoveryJobConfig  * Added new field 'shouldRecoverTags' in ExportSnapshotJobConfig  * Added a new optional field 'operating_system' to 'GET /host'.  * Added a new optional field 'apiEndpoint' to 'NasBaseConfig'.  * Added new optional field 'enableSymlinkResolution' to FilesetSummary in    'POST /fileset', \"GET /fileset\" and \"PATCH /fileset/{id}\" endpoints to    indicate if we want to resolve symlinks during metadata scan.  * Added new optional field 'enableHardlinkSupport' to FilesetSummary and    FilesetCreate in 'POST /fileset', \"GET /fileset\" and \"PATCH /fileset/{id}\"    endpoints to enable recognition and deduplication of hardlinks in    fileset backup.   ## Improvements:  * Added optional 'apiToken' and 'apiEndpoint' fields to NasConfig to support    Pure FlashBlade devices.  * Added a new field 'guestOsName' to GET /vmware/vm. This allows users to    filter virtual machines based on the guest operating system name.  * Enhanced GET /vmware/vm/snapshot/{id} response by adding disk details    such as fileName and deviceKey.  * Added isMountAllowed field to the response of GET    /mssql/db/{id}/recoverable_range. This helps identify which recoverable    ranges support Live Mount, which is affected by whether a database snapshot    contains filestreams.  * Added optional query parameters limit and offset to support pagination for    GET /mssql/db endpoint.  * Added optional query parameters sortOrder and sortBy to enable users to    sort the results of GET /mssql/db endpoint by effectiveSlaDomainId and name.   ### Changes to V1 API in Rubrik Version 4.2  ## Breaking changes:  * The input field OperatingSystemType value `Linux` is replaced by `UnixLike`.    in FilesetTemplateCreateDefinition, used by POST /fileset-template, and    in FilesetTemplatePatchDefinition, used by PATCH /fileset_template/{id}.  * The input field operating_system_type value `Linux` is replaced by `UnixLike`.    in GET /fileset-template and GET /host.   ## New features:  * Added a new /ldap_service endpoint for managing Active Directory integration.  * Added a new optional field 'nasBaseConfig' to GET /api/v1/host. This field    allows NAS (Isilon/NetApp) api credential to be displayed and edited.  * GET /host/{id}/search now returns search results for filesets, Windows volume    groups, and storage array volume groups belonging to the host. Previously,    the endpoint would only return fileset search results.  * Added endpoints for actions related to log shipping configurations:    POST /mssql/db/{id}/log_shipping to create, GET /mssql/db/log_shipping to    query, GET /mssql/db/log_shipping/{id} to retrieve individual details,    DELETE /mssql/db/log_shipping/{id} to delete, and POST    /mssql/db/log_shipping/{id}/reseed to reseed an unhealthy secondary    database.  * Added `Africa/Johannesburg`, `Africa/Lagos` and `Africa/Nairobi` as    supported cluster time zones.  ## Improvements:  * Added 2 new optional fields `apiHostname` and `zoneName` to POST /host    and GET /host. These fields allow different zones to be configured for    Isilon NAS.  * Added a new field 'geolocation' to GET /cluster/{id} and PATCH /cluster/{id}.    These allow users to view and modify the geolocation of the cluster,    respectively.  * Added a new field `guestOsType` to the `VirtualMachineDetail`.    object used in response of `GET /vmware/vm/{id}`.  * Added an optional organizationId field to the HostRegister request in POST    /host to allow users with the global admin RBAC role to add a host to an    organization specified by the value of the organizationId field.  * Added canLiveMount field to the responses of `GET /mssql/db/snapshot/{id}`.    and `GET /mssql/db/{id}/snapshot`.  * Added an optional field `agentStatus` to `VirtualMachineSummary` object used    in response of `GET /vmware/vm` endpoint. This allows user to check the    Rubrik Backup Service connection status of the corresponding VMware VM.  * Added the `POST /vmware/vm/{id}/register_agent` endpoint.  * Added a new field 'createDatastoreOnly' to POST    /vmware/vm/snapshot/{id}/mount. This allows user to mount snapshot to vmware    datastore only, without create a virtual machine.  * Added a new field `numWindowsVolumeGroups` to the `SlaDomainDetail` and    `SlaDomainSummary` objects used in response to `GET /sla_domain` endpoints.  * Added new optional field 'shouldRefreshCacheAfterUpdate' for PATCH    /vmware/vm/{id} to indicate whether or not to refresh the in-memory cache    after updates to a virtual machine record.   ### Changes to V1 API in Rubrik Version 4.1   ## Breaking changes:  * The 'allowedBackupWindow' and 'firstFullBackupWindow' input field for    /sla_domain now take the cluster time zone instead of UTC.   ## New features:  * Added POST /host/{id}/refresh endpoint to refresh hosts without    registering them again  * Added GET /fileset/snapshot/{id} endpoint to retrieve details of a    fileset snapshot.  * Added POST /mssql/db/{id}/log_backup endpoint for taking on-demand    log backup of SQL Server databases.  * Added a new optional query parameter 'is_agentless' to    GET /windows_cluster. This allows users to filter all clusters that    do not have any hosts with Rubrik connectors installed. If this    parameter is omitted, all clusters are returned.  * Added a new field 'isAgentless' to GET /windows_cluster. This indicates    whether all the hosts on this windows cluster do not have Rubrik connector    installed. If even one host has Rubrik connector installed, this will    be set to false.  * Added a new optional 'organization_id' query parameter on POST /session.    This allows users to specify the organization to which they intend to    authenticate. If this parameter is omitted, an organization is chosen    automatically.  * Added a new 'organizationId' field to the response on POST /session. This    indicates the organization to which the user has authenticated.  * Added a new field 'moid' on GET /vmware/vm. This allows users to search    VMWare VMs by Managed Object ID. The list of results of the call can now    additionally be sorted in ascending/descending order by moid.  * Added new fields 'replicas' and 'availabilityGroupId' on GET /mssql/db    and GET /mssql/db/{id}. If a database is an availability database,    it will have some number of replicas, which are copies of the database    running on different instances. Otherwise, there will only be one    replica, which represents the single copy of the database. The field    'availabilityGroupId' will be set only for availability databases    and points to the availability group of the database. Also deprecated    several fields on these endpoints, as they should now be accessed via    the 'replicas' field.  * Added a field 'cloudInstantiationSpec' on GET /vmware/vm and PATCH    /vmware/vm/{id} to allow enabling/disabling/updating specs for automatic    conversion to cloud image on a per VM basis  * Added a new optional query parameter 'availabilityGroupId' to GET /mssql/db,    in order to filter databases by their availability group ID.  * Added a new field 'timezone' to GET /cluster/{id} and PATCH /cluster/{id}.    These calls show and change, the current time zone setting of the cluster.  * Add a new field 'ignoreErrors' to POST /vmware/vm/snapshot/{id}/restore_file    that will let job to ignore file errors during restore jobs.  * Added `Asia/Kolkata` and `Asia/Kathmandu` as supported cluster time zones.   ### Changes to V1 API in Rubrik version 4.0   New features:  * Added a new field 'name' on GET /sla_domain. This allows users to search    SLA Domains by name. Users can also sort the SLA Domain summary results    in ascending/descending order by name  * The Rubrik cluster generates a unique ID for each virtual machine when a    vCenter Server is added. When a virtual machine changes to another vCenter    Server or unregisters and registers with the same vCenter Server, a new    unique ID is generated for that virtual machine. When this happens, the    virtual machine object associated with the original ID becomes a relic.    In this release we have added the option conflictResolutionAuthz to    add/edit vCenter endpoints of the Rubrik REST APIs. This option can take    either 'AllowAutoConflictResolution' to authorize the linking of relic    virtual machine objects with the current virtual machine object of a    specific virtual machine, and makes the collective snapshot history    available through the current object. Or it can take 'NoConflictResolution'    to not allow linking. Default value is 'NoConflictResolution'.  * Introduced endpoints for SQL Server Live Mounts: POST /mssql/db/{id}/mount,    GET /mssql/db/mount, GET /mssql/db/mount/{id}, and    DELETE /mssql/db/mount/{id}. These allow users to create, query for, and    delete Live Mounts for SQL Server databases.  * Added the isLiveMount field to the response of GET /mssql/db. Added an    optional is_live_mount query parameter to filter by this field.  * Added links field to the paginated responses of    GET /vmware/vm, /vmware/vm/mount and /fileset endpoints. This allows users    to navigate between pages by following the href in links.prev and links.next.  * Introduced optional caCerts parameter for the vCenter post/put/patch    endpoints to specify trusted CA certs to use when connecting to a vCenter    server and associated ESX hosts.  * Modified PATCH /mssql/instance/{id} endpoint to support SQL db    auto-protection, added fields configuredSlaDomainId,    logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the PATCH    request, as well as configuredSlaDomainId, configuredSlaDomainName,    logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the GET and    PATCH responses.  * Added GET /vmware/vcenter/{id} endpoint to allow fetching details of a    single vCenter server, including its refresh and delete status.  * Introduced optional parameter keepMacAddresses to    POST /vmware/vm/snapshot/{id}/mount, /vmware/vm/snapshot/{id}/export, and    /vmware/vm/snapshot/{id}/instant_recovery endpints.    This allows new VMs to have the same MAC address as their source VMs.  * Introduced optional parameters offset and limit to support    pagination for Browse end-point.  * Added `nodeId` to `AsyncRequestStatus` to improve debugging job failures.    ### Changes to V1 API in Rubrik version 3.2   New features:  * Added an option to preserve the virtual machine moid during instant recovery.    Use this option cautiously. It will permanently overwrite the source    virtual machine. The source virtual machine cannot be recovered if the    operation fails. It will not create a new virtual machine and rename    the original one so we could fall back to the original in case of a failure    in the process. This is not exposed in the Web UI and the API user should    be careful to not destroy the original virtual machine by accident.  * Introduced shareId into /fileset endpoints to support    the creation of filesets based on network shares.  * Introduced optional config parameter for all on demand    snapshot endpoints. The config parameter includes an optional slaId field.    The policies of the specified SLA Domain determine the retention of backups    on the local Rubrik cluster, the retention target, and the archival location.  * Introduced optional parameters to endpoint /mssql/db/{id}/export,    so that physical filenames and logical filenames can be changed    for exported databases. These two parameters are newFilename and    newLogicalName.  * Introduced optional config parameter for the VM patch endpoint    (PATCH /vmware/vm/{id}) to specify a guest credential for a    specific VM.  * Introduced optional query parameters to endpoint /host, to    support infix searching by hostname and sort order of results.  * Introduced slaId and slaName field to all snapshot summary/details object.    These fields specify the SLA Domain object that is associated with the    snapshot.  Bug Fixes:  * Made path parameter required in GET /fileset/snapshot/{id}/browse    and GET /vmware/vm/snapshot/{id}/browse. Previously, an error was    thrown when path wasn't passed in. This solves that bug.   ### Changes to V1 API in Rubrik version 3.1  Initial GA release  # Overview # The Rubrik REST API provides a means to work with Rubrik clusters and Rubrik Edge virtual appliances using text-based representations of the resource objects that are managed by the Rubrik software.  In its simplest form, the RESTful architecture used by the Rubrik REST API has the following workflow: 1. Client authenticates with the Rubrik REST API server and starts a session. 2. Client sends an HTTP request to the URI for a resource object. 3. Server handles the request and sends an HTTP response with a JSON formatted response body.  This overview section provides a basic description of the HTTP requests and responses used with the Rubrik REST API. The [Authentication](#section/Authentication) section provides information about how a client authenticates with the Rubrik REST API server.  ## Documentation conventions  The descriptions in this documentation use 'Rubrik cluster' to refer to both Rubrik clusters and Rubrik Edge virtual appliances.  The documentation uses a dollar symbol to indicate a variable in body text and code samples. Some examples: * `$cluster_address` to represent a Rubrik cluster IP or resolvable host name * `$snapshot_id` to represent the ID of a specific snapshot * `$request_id` to represent the ID of a specific asynchronous request  To shorten the path shown in a code sample, the documentation sometimes replaces a longer variable form with the variable form `{id}`. This variable form represents the `id` value for an associated member string in a response body or request URL.  The documentation use the term 'snappable' to refer to all objects that have data that can be protected by a Rubrik cluster or a Rubrik Edge appliance. For example, all of the following are 'snappables': * Virtual machines * File systems * SQL Server databases  ## Versioning  The Rubrik REST API structures the request URL to include the version of the API. This ensures that backwards incompatible improvements in a new version are not unintentionally used with an earlier version of the API.  The URL of a request includes a segment that identifies the version of the API. In the URL, the version segment always follows immediately after the Rubrik REST API server name or IPv4 address.  For example, for a Rubrik cluster with the server address `$cluster_address` a request to the cluster endpoint for Rubrik REST API v1 would look like this: `https://$cluster_address/api/v1/cluster`  In this URL, the `v1` represents the version number for Rubrik REST API v1.  The Rubrik REST API increments the version number when the new version includes a change that is not backward compatible.  Examples of changes that are not backward compatible include: * Resource type removed * Required parameter added to an existing resource type * Required parameter removed from an existing resource type * Renamed resource or parameter * Authentication requirement added for a previously unauthenticated resource  When the Rubrik REST API has changes that are not backward compatible, those changes appear in a new version. For example, incompatible changes to v1 appear in v2. The Rubrik REST API server makes v2 endpoints available on the path: `https://$cluster_address/api/v2/`. The Rubrik REST API server continues to provide the v1 endpoints on the path: `https://$cluster_address/api/v1/`.  ### Changes within a version  Backward compatible changes can be added to the Rubrik REST API as part of an update of the Rubrik CDM software on a Rubrik cluster or Rubrik Edge appliance. When this occurs, the version number remains the same and the URL segment that identifies the API version does not change. The [Changelog](#section/Changelog) that is provided in the docs for each version of the Rubrik REST API describes the changes that are made within that version.  Examples of backward compatible changes include: * New API resource added * New optional request parameters added to existing resources * New properties added to existing responses  ## Architecture  The Rubrik REST API architecture centers around logical entities called *resource objects*. Resource objects can be discrete entities or can contain a hierarchy of other, dependent, resource objects. A dependent, or child, resource object is referenced through the parent object.  For example, a virtualization environment is a resource object that contains virtual machines as child resource objects. The virtual machines, in turn, contain snapshots as child resource objects. To address this hierarchy, the path to a snapshot must include the parent objects. As shown here those parent objects are the virtualization environment (`vmware`) and the virtual machine (`vm`): `/vmware/vm/snapshot`.  When a request addresses a specific resource object the path must include the  `id` of that specific object.  For example, to address a specific snapshot with the `id` value of `123-456` the path would be: `/vmware/vm/snapshot/123-456`.  The full URL for the request would be: `https://$cluster_address/api/v1/vmware/vm/snapshot/123-456`  The path in this example points to a specific snapshot with the `id` value of `123-456`.  The `id` is an opaque value which is generated by the Rubrik REST API. It does not follow any specific format.  ### API base path  Each endpoint in the Rubrik REST API exists on one of two possible base paths: * `https://$cluster_address/api/v1/` * `https://$cluster_address/api/internal/`  The `/api/v1` base path provides the most commonly used endpoints. Rubrik considers these endpoints to be stable. Rubrik designs new releases of the Rubrik REST API to provide as much backward compatibility for these endpoints as possible. After an upgrade to a new version of the Rubrik CDM software, or to a new version of the Rubrik REST API, existing calls to endpoints on the `/api/v1` base path will normally continue to work.  The primary purpose of the `/api/internal` base path is to provide endpoints that are used by the Rubrik cluster. These endpoints are *internal* in the sense that the Rubrik CDM software uses them to provide a wide variety of cloud data management features. The evolution and improvement of the Rubrik CDM software can cause changes to these endpoints, removal of these endpoints, or addition of new `/api/internal` endpoints. Rubrik does not attempt to make the `/api/internal` endpoints backward compatible.  ### Requests  To perform a task, the Rubrik REST API uses an HTTP request. Most requests perform one of these actions: * Get an instance of an object from a list * Add an instance of an object to a list * Perform an operation on an object using the `id` of the object.  The following table describes the HTTP method and endpoint excerpts for some typical HTTP requests.  **Note:** The endpoints shown here would be appended to the base URL: `https://$cluster_address/vmware`.  | Method | Endpoint | Description | | ------ | --- | ----------- | | GET | `/vm/snapshot` | Returns a list of snapshots. | | POST | `/vm/snapshot` | Creates a new snapshot resource object. | | GET | `/vm/snapshot/{id}` | Returns information about the snapshot that is identified by `id`. | | PATCH | `/vm/snapshot/mount/{id}` | Changes the power status of the mounted snapshot that is identified by `id`. | | PUT | `/vcenter/{id}` | Provides a request body with a complete update of the properties of the vCenter Server object that is identified by `id`. | | DELETE | `/vm/snapshot/{id}` | Deletes the snapshot that is identified by `id`. | | GET | `/vm/{id}/missed_snapshot` | Returns the value of `missed_snapshot` for a snapshot that is identified by `id`. | | POST | `/vm/snapshot/{id}/mount` | Performs a `mount` operation using the snapshot that is identified by `id`. |  #### Reserved ID alias  The alias `me` can be used with some endpoints as a shorthand replacement for the current, or local, value of that resource object type. For example, for the resource object type `/cluster` the alias `me` can be substituted for the `id` of the Rubrik cluster that is hosting the current session. For the resource object type `/session` the alias `me` can be substituted for the `id` of the current session.  In filters, use the alias `local` to refer to the Rubrik cluster that is hosting the current session.  #### Timestamp  The Rubrik REST API uses a timestamp to express all time values. The timestamp meets the standards of ISO 8601 and uses Coordinated Universal Time (UTC). Timestamps take the form: YYYY-MM-DDTHH:MM:SSZ, with YYYY for the four digit year value, MM for the two digit month value, DD for the two digit day of the month value, HH for the two digit hour value using a 24-hour clock, MM for the two digit minute value, and SS for the two digit second value. The T stands for time and the Z stands for Zulu time, another name for UTC.  **Example:** Timestamp in a JSON-formatted response body  ```bash {   \"createdTimestamp\": \"2016-02-11T18:02:24Z\" } ```  ### Responses  The Rubrik REST API server responds to all requests by sending an HTTP response message. The response contains a status code and, when appropriate, a JSON object in the response body.  #### Status codes  The Rubrik REST API server includes an HTTP status code with every response. The following table describes the status codes supported by the Rubrik REST API server.  | Status code | Description | | ----------- | ----------- | | 200&nbsp;OK | Request succeeded. Not used for a DELETE request, or for a POST request that creates a resource. | | 201&nbsp;Created | POST request to create a resource object succeeded. | | 202&nbsp;Accepted | Request was successfully accepted for further processing. | | 204&nbsp;No&nbsp;Content | Request succeeded and the response body is empty. Used for successful DELETE requests and for successful POST requests that do not return content. | | 400&nbsp;Bad&nbsp;Request | Request failed because it was malformed. The request may be garbled, or it may be missing required parameters. | | 401&nbsp;Unauthorized | The requestor has insufficient authorization to perform the requested action. | | 403&nbsp;Forbidden | The requested action is blocked in the current context. | | 404&nbsp;Not&nbsp;Found | The request references a resource object that is unknown to the Rubrik REST API server. | | 415&nbsp;Unsupported Media Type | The HTTP header of the request specifies a media type that is not supported by the Rubrik REST API server. | | 422&nbsp;Unprocessable Entity | The request specifies a correct media type and contains correct syntax but cannot be processed because of semantical errors. | | 500&nbsp;Internal Server Error | The Rubrik REST API server encountered an unhandled error. | | 503&nbsp;Service Unavailable Error | The Rubrik REST API server is temporarily unavailable. |  #### Response body  The JSON object included in a response body can contain members (`{string : value}`) and arrays (`[elements]`). Also, members and arrays can be nested within members and arrays.  When a response includes a resource object, the object always includes an `id` member in the form `id : $id`. The value of the `id` member is the unique ID of the resource.  When a response includes a large array (or list) of elements, the Rubrik REST API server encloses the array in a `ListResponse` structure. The `ListResponse` structure breaks a lengthy array into 'pages' of information to make the information easier to manage. Refer to 'Working with lists' for information about managing arrays with large numbers of values.  #### Status code 400 responses  The Rubrik REST API server sends a response containing the HTTP status code '400 Bad Request' when the server cannot process the request. This can be caused by malformed request syntax, invalid request message framing, or deceptive request routing.  The Rubrik REST API server returns a '400 Bad Request' when: * Request does not conform with the format specified in OpenAPI definition files. For example, the request is missing required fields. * Request is malformed. For example, the request has a malformed `id`. * Request contains unsupported `enum` values.  #### Status code 422 responses  The Rubrik REST API server sends a response containing the HTTP status code '422 Unproccessable entity' when the request is syntactically correct but has semantic errors.  For example, when a request refers to an archival location that is not available. Although the request is properly formed, the Rubrik REST API server cannot act on the request because of the missing archival location, and the server returns '422 Unproccessable entity'.  The Rubrik REST API server also returns '422 Unproccessable entity' when invalid credentials are submitted during login. In that situation, the request may be correctly formed but the action cannot be completed by using the supplied values.  The following table describes the members of a '422 Unproccessable entity' response object.  | Member | Optional | Description | | ------ | --- | ----------- | | `type` | No | Error category. Possible values include: vcenter_error, oracle_error, rubrik_error | | `message` | No | Plain text explanation of the cause of the error. | | `code` | Yes | A short text string representing the cause of the error. | | `param` | Yes | The request member that is the source of the error, such as `backup_window`. |  ## Working with lists  When a request returns a large list of elements, the response array can be encapsulated within a `ListResponse` object. The `ListResponse` object is a pagination structure for the elements in the response array. The `ListResponse` object allows the response array to be addressed through smaller subsets of the array, or 'pages'.  To work with a `ListResponse` object, form a request that calls for a specific page of the results by specifying an offset value and a limit. The response includes the elements from the list starting at the offset value and continuing to the limit. When the limit is very large, or unspecified, the Rubrik REST API server returns as many elements as can be handled by the available memory.  The `ListResponse` object consists of the members described in the following table.  | Member | Optional | Description | | ------ | --- | ----------- | | `hasMore` | No | Indicates whether the array contains elements that are not provided by the current response. `true` if more elements are available for the original request and `false` if the last element is in the current response. | | `data` | No | An array of the requested elements. Can be all or some of the elements requested. The elements can be members, arrays, or objects. | | `total` | Yes | Total number of elements. | | `links` | Yes | When `hasMore` is true, provides a request URL for the next page of results. When appropriate, also provides a request URL for the previous page of results. The request URLs provided by `links` retain the query parameters from the original request. For example, a request URL would retain a value specified by `limit` and a value specified by `search`. The exception to this is the value specified by `offset`, which the Rubrik REST API server uses to specify next and previous pages. |  Control the contents of a `ListResponse` object by including the following optional query parameters with the original request: * `limit` Defines the maximum number of a elements to include in the `data` array of the response. Available memory may prevent the return of all elements for very large `limit` values. When that occurs, the response includes `\"hasMore\": true`. * `offset` Index reference point to use when determining the elements to include in a response. Include the next element after the index number specified by `offset`. The default value is `0`, which means the list page that is provided in the response starts with first element in the list.  For example, if the total number of elements in response to a query are 100, and the request includes the following query parameters: `limit=10` and `offset=30`, then the response will include a list page with elements 31-40.  When the `ListResponse` object provides `next` and `prev`, use the URL specified by `next` to request the next page of elements or use the URL specified by `prev` to request the previous page of elements.  **Example:** Request for all snapshots from a Rubrik cluster  The initial request uses the query parameter `limit=1`.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1\" ```  The response returns the first element and `\"hasMore\": true` indicates that more than one snapshot meets the request.  ```bash {   \"hasMore\": true,   \"status\": \"RUNNING\",   \"data\": [     {       \"id\": \"1\",       \"name\": \"Windows2012\"     }   ],   \"links\": {     \"next\": {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=1\"     }   } }  ```  To obtain the next element, the request is reissued with the query parameters set to: `limit=1&offset=1`. This could also be achieved by using the URL specified by `next` to request the next page.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=1\" ```  The response returns the second element in the array. Since there are elements before and after the element in the response, the `links` member contains both a `next` request URL and a `prev` request URL.  ```bash {   \"hasMore\": false,   \"status\": \"RUNNING\",   \"data\": [     {       \"id\": \"2\",       \"name\": \"Windows2016\"     }   ],   \"links\": {     \"prev\": {        \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=0\",       \"rel\": \"prev\"     },     \"next\": {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&offset=2\",       \"rel\": \"next\"     }   } } ```  ## Asynchronous requests  The Rubrik REST API server uses asynchronous (async) API requests for tasks that take longer to run. By using async requests the Rubrik REST API server avoids blocking the requestor from performing other tasks while the async tasks run.  The response to an async request includes a task object in the response body. The following table describes the members of a task object.  | Member | Optional | Description | | ------ | --- | ----------- | | `id` | No |  ID assigned to the task.  | | `status` | No |  Status of the task: 'RUNNING', 'SUCCEEDED', 'CANCELED', or 'FAILED'.   | | `error` | No | Message describing reason for canceled or failed task, or 'None'. | | `startTime` | Yes | Timestamp when the Rubrik cluster schedules the task. | | `endTime` | Yes | Timestamp when the task ends. | | `progress` | Yes | Percentage of the task that is complete. | | `links` | No | Polling request array that provides information about how to poll the task. |  The following table describes the polling request array in the `links` member.  | Member | Optional | Description | | ------ | --- | ----------- | | `href` | No | URL to send requests to when polling the task. | | `rel` | No | Provides a value of 'self' to indicate that the array refers to the resource represented by the parent JSON object. |  When an async task is completed the Rubrik REST API server adds a second array to the `links` member in the response that is sent. The second array provides information about how to request the result of the async task.  The following table describes the results array in the `links` member.  | Member | Optional | Description | | ------ | --- | ----------- | | `href` | No | URL to send a request to for the result of the task. | | `rel` | No | Provides a value of 'result' to indicate that the array refers to the resource represented by the parent JSON object. |  **Example:** Starting a mount task and polling the task status  To initiate a mount operation, send a POST request to the mount endpoint. Include an object containing the details of the snapshot.  ```bash curl -X POST \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\" ```  The Rubrik REST API server returns a task object for the mount operation. The task object describes the task status as 'RUNNING' and provides the `links` member which contains the polling request array.  ```bash {   \"id\": \"$request_id\",   \"status\": \"RUNNING\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  Using the information provided in the task object, send a GET request to poll the task status.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\" ```  ```bash {   \"id\": \"$request_id\",   \"status\": \"RUNNING\",   \"error\": \"None\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  Continue to poll the task object until the status changes to 'SUCCEEDED'.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\" ```  When the task object status changes to 'SUCCEEDED', the `links` member of the request includes a results array that provides a URL for the task results.  ```bash {   \"id\": \"$request_id\",   \"status\": \"SUCCEEDED\",   \"error\": \"None\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       \"rel\": \"self\"     },     {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/$mounted_vm_id\",       \"rel\": \"result\"     }   ] } ```  # OpenAPI The Rubrik REST API specification conforms to the OpenAPI 2.0 Specification. Tools that work with the OpenAPI 2.0 Specification can be used with the Rubrik REST API specification.  Development releases (pre-1.0) of the Rubrik REST API specification made reference to 'swagger'. The previous release of the OpenAPI 2.0 Specification was named the Swagger 1.2 Specification.  Download the Rubrik REST API specification for your tools. [Download](./api-docs)  ## Rubrik REST API Explorer The Rubrik REST API Explorer is a browser-based API client hosted by the Rubrik cluster. The Explorer has the Rubrik REST API specification built in. You can use the Explorer to try out Rubrik REST API calls and view the responses.  **IMPORTANT:** The Explorer interacts with the Rubrik cluster through the API calls you make. Use care when making calls that modify or delete configurations and data.  To access the Rubrik REST API Explorer, click: [Rubrik REST API Explorer](./playground/)  # Authentication  The Rubrik REST API server requires that all API calls use the HTTPS protocol. To meet the security requirements of that protocol, the Rubrik REST API server uses a self-signed certificate. A Certificate Authority cannot validate a self-signed certificate. Configure client tools to ignore the certificate validation error.  The Rubrik REST API server requires authentication and authorization for each API call, except calls made to the following endpoints:  * [/cluster/me/version](#operation/getClusterVersion) * [/cluster/me/api_version](#operation/getClusterApiVersion)  ## Authentication session Rubrik REST API server authenticates a session using either of the following methods:  * BasicAuth * Token  The Rubrik REST API server requires that you use an authorized username and password for the Rubrik cluster. Usernames are managed by either the Rubrik cluster or by your LDAP service.  ### BasicAuth authentication  BasicAuth authentication uses the HTTP Basic Authentication method and requires you to include the user credentials with each API call. Since each API call made using the BasicAuth method is separately authenticated, you do not need to manage the session state. You also do not need to log out of a session, since this method does not create a session.  To use the BasicAuth method, provide the user credentials in the 'Authorization' header of an API call.  Use the string `Basic` followed by the Base64 encoding of `<username:password>` as the user credentials, where `<username:password>` is the username for an Admin account on the host Rubrik cluster, a colon, and the account password.  **Example:** Using curl to retrieve a session ID  This example uses the local Admin username 'admin' and the password 'pass' to retrieve: a session ID, the Rubrik server software version, and the API version.  The curl command shown here takes `<username:password>`, adds 'Basic ' to the string, and Base64 encodes the result.   The command includes the following arguments:  * `-k` to bypass an alert about the self-signed certificate  * `-u` to flag the `<username:password>` string  * `-X` to flag the HTTP method `GET`  ```bash curl -k -u admin:pass -X GET \"https://$cluster_address/api/v1/cluster/me\" ``` The Rubrik REST API server returns the following response body. ```bash {   \"id\": \"$cluster_id\",   \"version\": \"3.1.0\",   \"apiVersion\": \"1.0\" } ```  ### Token authentication  Token authentication creates a token at the beginning of a session and then uses that token to authenticate the API calls that are made during the session. The token remains valid for the session - normally 30 minutes after the last activity. You can close a session and invalidate the session token at any time by making a DELETE call to `/session/{id}` where `{id}` is the session ID or `me` for the current session ID.  **Example:** Token authentication in a session  This example uses the local Admin username 'admin' and the password 'pass'. To open a session, first use the [BasicAuth](#section/BasicAuth) method to authenticate a POST call to [/session](#operation/createSession).  ```bash curl -k -u admin:pass -X POST \"https://$cluster_address/api/v1/session\" ```  The response body includes an array with the session token.  ```bash {   \"id\": \"$session_id\",   \"token\": \"$token_id\",   \"userId\": \"$user_id\" } ``` For all subsequent calls during the session, include the token in the Authorization header using the form: `Authorization: Bearer $token_id` where `$token_id` is the value of the `token` member from the response array.  In this curl command, the GET request to [/cluster](#operation/getPublicClusterInfo) uses `-H` to provide the `Authorization: Bearer $token_id` value.  ```bash curl -k -H \"Authorization: Bearer $token_id\" -X GET   \"https://$cluster_address/api/v1/cluster/me\" ```  The response body contains an array with the session ID, the Rubrik cluster software version, and the API version.  ```bash {   \"id\": \"$cluster_id\",   \"version\": \"3.1.0\",   \"apiVersion\": \"1.0\" } ```  To close the session and invalidate the session token, make a DELETE call to [/session](#operation/deleteSession) using the value of the `id` key or use `me`. The alias `me` represents the session specified in the Authorization header.  ```bash curl -k -H \"Authorization: Bearer $token_id\" -X DELETE   \"https://$cluster_address/api/v1/session/me\" ```  ## LDAP Authentication  The Rubrik cluster can be integrated with an LDAP service for authentication. The API endpoints provide support for adding, updating and deleting a specific LDAP service as well as list all of the configured LDAP services.  ### Add a new LDAP service You can add a new LDAP service by making a POST call to [/ldap_service](#operation/createLdapService). Adding a new LDAP service requires information about the dynamic DNS name of the service, an administrative user who is authorized to create a computer user account as well as search for all the LDAP objects needed for use by the Rubrik cluster. The Rubrik cluster resolves the dynamic DNS name using DNS SRV records while honoring the advertised priority values.  **Example:** Adds a new LDAP service for use by the Rubrik cluster  This example adds an LDAP service that uses a dynamic DNS name of *example.com*, with a bind administrator user of *Administrator* with a password of *VerySafe*.  ```bash curl -k -u admin:pass -X POST -d '{\"dynamicDnsName\": \"example.com\",   \"bindUserName\": \"Administrator\", \"bindUserPassword\": \"VerySafe\"}'   'https://$cluster_address/api/v1/ldap_service' ```  The response body includes the ID associated with this LDAP service.  ```bash {   \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",   \"domainType\": \"AD\",   \"name\": \"example.com\",   \"serviceAccount\": \"cluster10-c8D7A54$\",   \"initialRefreshStatus\": \"ongoing\" } ```  The parameters associated with the LDAP service can be updated by making a PATCH request to [/ldap_service/{id}](#operation/patchLdapService) or a PUT request to [/ldap_service/{id}](#operation/putLdapService).  For example, you could add a prioritized list of authentication servers that supercede the LDAP servers advertised for the dynamic DNS name. These authentication servers can even be proxies that connect to the actual LDAP servers.  **Example:** Add two new LDAP services  This example adds two LDAP servers called ad-proxy1.example.com and ad-proxy2.cloud.example.com.  ```bash curl -k -u admin:pass -X PATCH -d '{ \"authServers\": [\"ldap://ad-proxy1.example.com:389\", \"ldap://ad-proxy2.example.com:389\"]}' https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd ```  The response body confirms a successful update.  ```bash {   \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",   \"domainType\": \"AD\",   \"name\": \"example.com\",   \"initialRefreshStatus\": \"success\" } ```  ### List configured LDAP services You can get a listing of all the configured authentication domains using a GET request to [/ldap_service](#operation/queryLdapService).  **Example:** Get the list of LDAP services.  ```bash curl -k -u admin:pass -X GET 'https://$cluster_address/api/v1/ldap_service' ```  The response body will contain the ID of all the authentication realms.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",       \"domainType\": \"AD\",       \"name\": \"example.com\",       \"serviceAccount\": \"cluster10-c8D7A54$\",       \"initialRefreshStatus\": \"success\"     },     {       \"id\": \"9fef084b-75f8-4c03-9efa-c73b55be5da8\",       \"domainType\": \"LOCAL\",       \"name\": \"local\",       \"initialRefreshStatus\": \"success\"     }   ],   \"total\": 2 }  ```  ### Get information about a specific LDAP service  You can also get information about a specific LDAP service using a GET request to [/ldap_service/{id}](#operation/getLdapService).  **Example:** Get information about a configured LDAP service.  ```bash curl -k -u admin:pass -X GET   'https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd' ```  The response body will contain information about the specified LDAP service.  ```bash {   \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",   \"domainType\": \"AD\",   \"name\": \"example.com\",   \"serviceAccount\": \"cluster10-c8D7A54$\",   \"initialRefreshStatus\": \"success\" } ```  ### Delete an LDAP service Any LDAP service that is configured to a Rubrik cluster can be removed by issuing a DELETE request to [/ldap_service/{id}](#operation/deleteLdapService).  **Example:** Remove an LDAP service  ```bash curl -k -u admin:pass -X DELETE https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd  ```  ## LDAP domain authentication Scripts that automate calls to the Rubrik REST API endpoints must include one of the available authentication methods: the HTTP Basic method, the session method, or the API token method.  When the HTTP Basic method is used, and authentication is through an LDAP domain, issues can arise when the Rubrik cluster is configured with multiple LDAP domains. With this method, the authentication server first attempts to authenticate through the Rubrik cluster local domain. If that authentication attempt does not succeed, the authentication server attempts authentication with each available LDAP domain. If there are several LDAP domains configured, then this process can slow down authentication. With many LDAP domains, the authentication can potentially have too many failed logins and result in an account lock-out.  Although using the [API token for authentication](#token-authentication) is recommended for scripting, using the session authentication method will also avoid these issues. The following python script provides an example of how to use session authentication in a script. The method used in this example can be duplicated in other scripting languages to suit your scripting requirements.  ``` try:     sessionData = None      session = requests.Session()     session.auth = ($username, $password)     session.verify = False     session.headers = {'Content-type': 'application/json'}     requests.adapters.HTTPAdapter()     session.mount('https://', requests.adapters.HTTPAdapter(pool_connections=1))      # First, login to create a Web Session Token     loginData = {        \"initParams\": {            \"organizationId\": $org_id         }     }     login = session.post(     url='https://{}/api/internal/session/realm/{}'.format($RubrikCluster, $domain_display_name),     data=json.dumps(loginData),     timeout=300)     assert login.ok and 'session' in login.json()     sessionData = login.json()['session']     session.headers.update({'Authorization': 'Bearer {}'.format(sessionData['token'])})     session.auth = None      # Issue the desired request     cluster = session.get(url='https://{}/api/v1/cluster/me'.format($RubrikCluster))     assert cluster.ok     print('Session Auth: {}'.format(cluster.json()['name']))  finally:     if sessionData:         # Delete the web sessions explicitly. Rubrik CDM supports a         # limited number of sessions per user. Once this limit is exceeded,         # a random web session is discarded. This could log out the         # user from the UI or cause another script to fail.         logoutData = {            \"tokenIds\": [                sessionData['id']             ],             \"userId\": sessionData['userId']         }         logout = session.post(             url='https://{}/api/internal/session/bulk_delete'.format($RubrikCluster),             data=json.dumps(logoutData),             timeout=300)         assert logout.ok ``` Where:     * `$username` is the name of the user account to be authenticated.     * `$password` is the password associated with the username.     * `$org_id` is the ID of the organization representing the tenant.     * `$RubrikCluster` is the IPv4 address or resolvable hostname of        the Rubrik cluster.     * `$domain_display_name` is the name of the LDAP domain.  ## SAML ID Provider Authentication  The Rubrik cluster can be integrated with a SAML ID Provider authentication domain for authentication. The Rubrik REST API provides API endpoints for managing and configuring the ID Provider authentication domain with the Rubrik cluster. The Rubrik REST API also provides API endpoints for creating the SAML authentication request and handling the SAML authentication response.  ### Add a new SAML ID Provider Authentication Domain You can add a new ID Provider by making a POST call to [/idp_auth_domain](#operation/createIdProviderAuthDomain). Adding a new ID Provider requires the ID Provider metadata XML file in base64 encoding, and a human-friendly name for the ID Provider.  **Example:** Adds a new ID Provider for use by the Rubrik cluster  ```bash curl -k -u admin:pass -X POST -d '{\"name\": \"new-idp\",   \"metadataXmlBase64\": \"1VZbj6LYFn438T9UPI+mi7slpqsnm2sBQgm...\"}'   'https://$cluster_address/api/v1/idp_auth_domain' ```  The response body includes the ID associated with this Active Directory.  ```bash {   \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",   \"name\": \"new-idp\",   \"entityId\": \"http://www.example.com/idp1\",   \"ssoUrl\": \"https://www.example.com/idp1/sso\",   \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\" } ```  ### Update an existing SAML ID Provider Authentication Domain The name and metadata associated with the ID Provider can be updated by making a PATCH request to [/idp_auth_domain/{id}](#operation/updateIdProviderAuthDomain). This API call can update either of the two parameters.  **Example:** Update name of the ID Provider  This example update the name of ID Provider \"new-idp\" as \"updated-idp\", and update metadata with new ID Provider \"http://www.example.com/idp2\"  ```bash curl -k -u admin:pass -X PATCH -d '{ \"name\": \"updated-idp\",   \"metadataXmlBase64\": \"1VZbj6AQwTIr4deKspU/zyR9fxqPPebgQ...\"}'   'https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd' ```  The response body confirms a successful update.  ```bash {   \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",   \"name\": \"updated-idp\",   \"entityId\": \"http://www.example.com/idp2\",   \"ssoUrl\": \"https://www.example.com/idp2/sso\",   \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\" } ```  ### List configured ID Provider Authentication Domains You can get a listing of all the configured ID Providers using a GET request to [/idp_auth_domain](#operation/queryIdProviderAuthDomain).  **Example:** Get the list of ID Provider authentication domains.  ```bash curl -k -u admin:pass -X GET 'https://$cluster_address/api/v1/idp_auth_domain' ```  The response body contains the ID of all the ID provider authentication domains.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",       \"name\": \"new-idp\",       \"entityId\": \"http://www.example.com/idp1\",       \"ssoUrl\": \"https://www.example.com/idp1/sso\",       \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\"     },     {       \"id\": \"9fef084b-75f8-4c03-9efa-c73b55be5da8\",       \"name\": \"another-idp\",       \"entityId\": \"http://www.example.com/idp2\",       \"ssoUrl\": \"https://www.example.com/idp2/sso\",       \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\"     }   ],   \"total\": 2 }  ```  ### Get information about a specific SAML ID Provider Authentication Domain You can also get information about a specific ID Provider using a GET request to [/idp_auth_domain/{id}](#operation/getIdProviderAuthDomain).  **Example:** Get information about a configured ID Provider.  ```bash curl -k -u admin:pass -X GET   'https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd' ```  The response body contains information about this ID provider authentication domain.  ```bash {   \"id\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",   \"name\": \"new-idp\",   \"entityId\": \"http://www.example.com/idp1\",   \"ssoUrl\": \"https://www.example.com/idp1/sso\",   \"signCert\": \"-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\" } ```  ### Delete an ID Provider Authentication Domain Any ID Provider authentication domain that is configured to a Rubrik cluster can be removed by issuing a DELETE request to [/idp_auth_domain/{id}](#operation/deleteIdProviderAuthDomain).  **Example:** Remove the ID Provider authentication domain  ```bash curl -k -u admin:pass -X DELETE https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd ```  ### Download Rubrik SAML Metadata Generate the Rubrik SAML service provider metadata file and get the URL of the file by issuing a GET request to [/saml/rubrik_metadata](#operation/configRubrikSamlMetadata).  **Example:**  Generate the Rubrik SAML metadata file without providing an address for the host at the endpoint. The cluster chooses a floating IP as the host address.  ```bash curl -k -u admin:pass -X POST -d '{}'   'https://$cluster_address/api/v1/saml/rubrik_metadata' ```  **Example:** Generate the Rubrik SAML metadata file and specify an address for the host at the endpoint.  ```bash curl -k -u admin:pass -X POST -d '{\"hostAddress\": \"my.rubrik.saml.sp.com\"}'   'https://$cluster_address/api/v1/saml/rubrik_metadata' ```  ### Check SAML SSO Status ### Send a GET request to unauthenticated endpoint [/saml/sso_status](#operation/getSamlSsoStatus) to check SAML SSO status. The status is represented by an object that contains 1) a Boolean value that determines whether or not SSO is enabled. 2) an optional String value that indicates the name of the default IdP authentication domain for SSO login. The default IdP will be configured when there is only one IdP configured in the cluster. 3) a Boolean value, isGpsLoginEnabled, that determines whether federated login is enabled.  **Example:** Check SAML SSO status  ```bash curl -k -X GET 'https://$cluster_address/api/v1/saml/sso_status' ```  ### Make SAML Authentication Request Send a POST request to [/saml/authn_request](#operation/makeSamlAuthnRequest) to generate a signed SAML authentication request for the authentication domain of a specified ID Provider. The request can include optional parameters to specify a redirection resource path  and to specify that the request is a test of the configuration for the ID Provider. The response provides the data that is required for a SAML SSO authentication request for the ID Provider. This is an unauthenticated API.  **Example:** Make the SAML authentication request for ID Provider my-idp-1  ```bash curl -k -X POST https://$cluster_address/api/v1/saml/authn_request/my-idp-1   -d '{\"redirectPath\": \"/web/bin/index.html#/welcome\", \"isForIdpTest\": false}' ```  # Principal Management  ## Searching for principals  To search for principals, send a GET request to the [`/principal`](#operation/searchPrincipalsV1) endpoint.  This endpoint only returns principals from the organization to which the currently logged-in user belongs.  All query parameters are optional. Each specified query parameters (besides the sorting parameters) will further restrict the set of results.  **Example:** ```bash curl -X GET \"https://$cluster_address/api/v1/principal? name=$name& auth_domain_id=$auth_domain_id& organization_id=$organization_id& role_id=$role_id& is_assigned_roles_or_is_local=$is_assigned_roles_or_is_local& sort_by=$sort_by& sort_order=$sort_order& limit=$limit& offset=$offset\" ```  ## Assigning roles to principals  To get a list of roles assigned to principals, send a GET request to the [`/principal/role`](#operation/getRolesForPrincipals) endpoint.  **Example:** ```bash curl -X GET -d \"https://$cluster_address/api/v1/principal/role? principals=$principal_ids\" ```  To assign roles to a set of principals, send a POST request to the [`/principal/role`](#operation/assignRolesToPrincipals) endpoint.  **Example:** ```bash curl -X POST -d '{   \"principals\": \"[$principal_id]\",   \"roles\": \"[$role_id]\" }' \"https://$cluster_address/api/v1/principal/role\" ```  To revoke roles from a set of principals, send a POST request to the [`/principal/role/bulk_revoke`](#operation/revokeRolesFromPrincipals) endpoint.  **Example:** ```bash curl -X POST -d '{   \"principals\": \"[$principal_id]\",   \"roles\": \"[$role_id]\" }' \"https://$cluster_address/api/v1/principal/role/bulk_revoke\" ```  # Role Management  This section provides details on role management on CDM.  ## Role Lifecycle Management  To create a new role, send a POST request to the [`/role`](#operation/createRole) endpoint.  **Example:** ```bash curl -X POST -d '{   \"name\": \"$role_name\",   \"description\": \"$description\" }' \"https://$cluster_address/api/v1/role\" ```  To update a new role, send a PATCH request to the [`/role/$role_id`](#operation/updateRole) endpoint.  **Example:** ```bash curl -X PATCH -d '{   \"name\": \"$role_name\",   \"description\": \"$description\" }' \"https://$cluster_address/api/v1/role/$role_id\" ```  To delete a role, send a DELETE request to the [`/role/$role_id`](#operation/deleteRole) endpoint.  **Example:** ```bash curl -X DELETE \"https://$cluster_address/api/v1/role/$role_id\" ```  To get role metadata for all roles in an organization, send a GET request to the [`/role`](#operation/getRoles) endpoint.  All query parameters are optional. The getRoles endpoint uses the organization ID of the current user session when the API call does not specify an organization ID.  **Example:** ```bash curl -X GET \"https://$cluster_address/api/v1/role? organization_id=$organization_id& name=$role_name\" ```  To get role metadata for a specific role, send a GET request to the [`/role/$role_id`](#operation/getRole) endpoint.  **Example:** ```bash curl -X GET \"https://$cluster_address/api/v1/role/$role_id\" ```   # Authorization  This section provides details on authorizing calls to the Rubrik CDM REST API.  ## Clearing the authorization cache Stale authorization information cached on the Rubrik CDM API server can cause API call failures. Clearing the cache on the node targeted by an API call can prevent this error.  To clear the cache, send a DELETE request to the [`/authorization/cache`](#operation/deleteAuthzCache) endpoint. ```bash curl -X DELETE \"https://$cluster_address/api/v1/authorization/cache\" ```  # Rubrik certificate management  This section explains how to manage certificates.  ## Retrieving all imported certificates  To retrieve all imported certificates from the cluster, send a GET request to the [`/certificate`](#operation/queryCertificates) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/certificate\" ```  The Rubrik REST API server returns an array of objects with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  ```bash {   \"certId\": \"$certId\",   \"name\": \"$certName\",   \"hasKey\": true,   \"expiration\": \"$certExpiration\",   \"usedBy\": {} } ```  ## Importing a certificate  To import a certificate, send a POST request to the [`/certificates`](#operation/importCertificate) endpoint.  ```bash curl -X POST -d '{   \"name\": \"certName\",   \"pemFile\": \"$pemFile\",   \"privateKey\": \"$privateKey\",   \"description\": \"$description\" }' \"https://$cluster_address/api/v1/certificate\" ```  The Rubrik REST API server returns an object with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  ```bash {   \"certId\": \"$certId\",   \"name\": \"$certName\",   \"hasKey\": true,   \"expiration\": \"$certExpiration\",   \"usedBy\": {} } ```  ## Retrieving a certificate  To retrieve a certificate, send a GET request to the [`/certificate/{id}`](#operation/exportCertificate) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/certificate/$cert_id\" ```  The Rubrik REST API server returns an object with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  ## Updating a certificate  To update a certificate, send a PATCH request to the [`/certificate/{id}`](#operation/updateCertificate) endpoint.  ```bash curl -X POST -d '{   \"name\": \"certName\",   \"pemFile\": \"$pemFile\",   \"description\": \"$description\" }' \"https://$cluster_address/api/v1/certificate/$cert_id\" ```  The Rubrik REST API server returns an object with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  ## Deleting a Certificate  To delete a certificate, send a DELETE request to the [`/certificate/{id}`](#operation/deleteCertificate) endpoint.  ```bash curl -X DELETE \"https://$cluster_address/api/v1/certificate/$cert_id\" ```  ## Generating a Certificate Signing Request (CSR)  To generate a CSR, send a POST request to the [`/csr`](#operation/generateCsr) endpoint.  ```bash curl -X POST -d '{   \"hostnames\": \"$hostnames\",   \"name\": \"$name\",   \"organizations\": \"$organization\",   \"organizationUnit\": \"$organizationUnit\",   \"country\": \"$country\",   \"state\": \"$state\",   \"city\": \"$city\" }' \"https://$cluster_address/api/v1/csr\" ``` Hostnames and name are required. The Rubrik REST API server will respond with the information provided in the POST request, in addition to the CSR to be signed.  ## Retrieving all outstanding Certificate Signing Requests  To retrieve all outstanding CSRs, send a GET request to the [`/csr`](#operation/getAllCsrs) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/csr\" ``` The Rubrik REST API server returns an array of objects with the csrId, the name, the CSR, and all information provided to generate the CSR.  ## Deleting a Certificate Signing Request (CSR)  To delete a CSR, send a DELETE request to the [`/csr/{id}`](#operation/deleteCsr) endpoint.  ```bash curl -X DELETE \"https://$cluster_address/api/v1/csr/$csr_id\" ```  ## Managing Rubrik Backup Service secondary cluster certificates  The Rubrik Backup Service can be setup to allow registering with multiple Rubrik clusters. See the Multicluster Rubrik Backup Service section of the Rubrik CDM User Guide for details. Certificates for replication source or replication target clusters are automatically added without calling the API in this section. To mark a certificate to be added to agents, send a POST request to [`/certificate/agent`](#operation/markAgentSecondaryCertificate).  ```bash curl -X POST \\   -d '{     \"cert_id\": \"$certId\"   }' \\   \"https://$cluster_address/api/v1/certificate/agent\" ```  To list all qualified certificates that have been [imported to the cluster](#section/Rubrik-certificate-management/Importing-a-certificate), send a GET request to [`/certificate/agent`](#operation/queryAgentSecondaryCertificate).  ```bash curl -X GET \"https://$cluster_address/api/v1/certificate/agent\" ```  To unmark a certificate so that is is no longer added to agents, send a DELETE request to [`/certificate/agent/{id}`](#operation/unmarkAgentSecondaryCertificate).  ```bash curl -X DELETE \"https://$cluster_address/api/v1/certificate/agent/$certId\" ```  # Cluster configuration history Rubrik REST API provides the `/config/history` endpoints for administrators to audit the changes made to the configuration parameters on a Rubrik cluster.  The ability to audit the configuration changes allows administrators to track the information related to the configuration changes, such as the old and new values of the configuration parameters, the user account that made the changes, the time of each change, and the name of the cluster or node where the changes were made.  The `/config/history` endpoints apply to the following configuration parameters: * Global or cluster wide configuration * Local or node specific configuration  ## Retrieving a summary of configuration changes To retrieve a list of configuration updates based on specific parameters, send a GET request to [`/config/history/list_updates`] (#operation/queryConfigurationHistoryUpdates).  ```bash curl -X GET \"https://$cluster_address/api/v1/config/history/list_updates\" ```  To retrieve information for a specific configuration parameter include the name of the parameter in the request. To retrieve information for all configuration parameters that fit within the specified filters, do not specify a parameter name.  ```bash curl -X GET \"https://$cluster_address/api/v1/config/history/list_updates?name=$config_name\" ``` The *Rubrik CDM User Guide* describes the parameters that can be configured to filter the results of the `GET /config/history/list_updates` endpoint.  The Rubrik REST API server responds with a list of JSON objects for the configuration updates that meet all specified filters.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"nodeId\": \"string\",       \"namespace\": \"string\",       \"name\": \"string\",       \"oldValue\": \"string\",       \"newValue\": \"string\",       \"apiUser\": \"string\",       \"modifiedDateTime\": \"2021-02-26T17:21:54.520Z\",       \"source\": \"string\",       \"configChangeMetadata\": \"string\"     }   ],   \"total\": 0 } ```  ## Retrieving a summary of configuration changes on a given date To retrieve the values of configuration parameters on a specific date, send a GET request to [`/config/history/ondate`] (#operation/retrieveConfigurationValues).  Specify values for the `namespace` and `on_date` query parameters that are required to send the GET request.  ```bash curl -X GET \"https://$cluster_address/api/v1/config/history/ondate?namespace=$namespace&on_date=$timestamp\" ```  To retrieve information for a specific configuration parameter include the name of the parameter in the request, along with the namespace and on_date parameters. To retrieve information for all configuration parameters that fit within the specified filters, do not specify a configuration parameter name.  The *Rubrik CDM User Guide* describes the parameters that can be configured to filter the results of the `GET /config/history/ondate` endpoint.  The Rubrik REST API server responds with a list of JSON objects for the configuration updates that meet all specified filters.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"namespace\": \"string\",       \"name\": \"string\",       \"defaultValue\": \"string\",       \"onDate\": \"2021-02-26T17:21:54.526Z\",       \"valueOnDate\": \"string\",       \"currentValue\": \"string\",       \"nodeId\": \"string\"     }   ],   \"total\": 0 } ```  # Rubrik cluster management  This section explains how to retrieve basic information about a Rubrik cluster, as well as how to update the name of a cluster.  ## Discovering Nodes **Example:** Discovering unbootstrapped nodes on a network The discover endpoint cannot function without multicast DNS. When multicast DNS is not available, manually specify hostname and IPv6 information about the Rubrik cluster to enable node discovery. To input information about unbootstrapped nodes located on this network, send a POST request to the [`/cluster/{id}/$manual_discover`](#operation/manualDiscover) endpoint.  ```bash curl -X POST \\   -d '{\"nodeInfo\": [ {\"hostname\": \"string\", \"ipv6\": \"string\" } ] }' \\   \"https://$cluster_address/api/v1/cluster/$manual_discover\" ```  The [`/cluster/{id}/$manual_discover_ipv4`](#operation/manualDiscoverIpv4) endpoint also discovers nodes over an IPv4 network.  ```bash curl -X POST \\   -d '{\"nodeInfo\": [ {\"hostname\": \"string\", \"ipv4\": \"string\" } ] }' \\   \"https://$cluster_address/api/v1/cluster/$manual_discover_ipv4\" ```  ## Retrieving Rubrik Cluster Information   **Example:** Retrieving publicly available information about a Rubrik cluster  To retrieve information about a Rubrik cluster, send a GET request to the [`/cluster/$cluster_id`](#operation/getPublicClusterInfo) endpoint. The Rubrik REST API server responds with the publicly available information for the specified Rubrik cluster.  ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id\" ```  The Rubrik REST API server returns an array with the session ID, the Rubrik cluster software version, the API version, the Rubrik cluster name, and the Rubrik cluster time zone.  ```bash {   \"id\": \"$cluster_id\",   \"version\": \"4.1.0\",   \"apiVersion\": \"1.0\",   \"name\": \"$cluster_name\",   \"timezone\": {     \"timezone\": \"$cluster_timezone\"   } } ``` To retrieve the cluster certificate, send a GET request to the [`/cluster/{id}/certificate`](#operation/getClusterCertificate) endpoint. ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/certificate\" ``` To request only the current software version of the Rubrik cluster, send a GET request to the [`/cluster/$cluster_id/version`](#operation/getClusterVersion) endpoint. ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/version\" ```  To request only the current REST API version running on the cluster, send a GET request to [`/cluster/$cluster_id/api_version`](#operation/getClusterApiVersion)  ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/api_version\" ```  To get the download link for Rubrik SNMP MIB file, send a GET request to [`/cluster/$cluster_id/snmp_mib_link`](#operation/getRubrikSnmpMibDownloadLink) ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/snmp_mib_link\" ```  To get the download link for the SYSLOG-MSG-MIB file, send a GET request to [`/cluster/$cluster_id/syslog_msg_mib_link`](#operation/getSyslogMsgSnmpMibDownloadLink) ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/syslog_msg_mib_link\" ```  To get the download link for the SYSLOG-TC-MIB file, send a GET request to [`/cluster/$cluster_id/syslog_tc_mib_link`](#operation/getSyslogTcSnmpMibDownloadLink) ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/syslog_tc_mib_link\" ```  To retrieve the encryption at rest status of the cluster, send a GET request to the [`/cluster/$cluster_id/encryption`](#operation/getEncryptionStatus) endpoint. ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/security/encryption\" ```  To retrieve the IDs of the nodes in the cluster, send a GET request to the ['/cluster/$cluster_id/node_id'](#operation/getClusterNodeIds) endpoint. ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/node_id\" ```  ## Hostnames for nodes in a Rubrik cluster  ### Retrieving hostnames for nodes in a Rubrik cluster  To retrieve the hostnames of the nodes in a Rubrik cluster, send a GET request to the ['/cluster/$cluster_id/node_hostname'](#operation/getClusterNodeHostnames) endpoint. ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/node_hostname\" ``` The Rubrik REST API server responds with an array of node ID to hostname mappings for all the nodes in the specified Rubrik cluster. ```bash [   {     \"id\": \"RVM000000000001\",     \"hostname\": \"myhost01\"   },   {     \"id\": \"RVM000000000002\",     \"hostname\": \"myhost02\"   } ] ```  ### Updating hostnames for nodes in a Rubrik cluster  To update the hostnames of the nodes in the Rubrik cluster, send a POST request to the ['/cluster/$cluster_id/node_hostname'](#operation/changeClusterNodeHostnames) endpoint. ```bash curl -X POST \\   -d '[{ \"id\": \"$id\", \"hostname\":\" \"$hostname\" }]' \\   \"https://$cluster_address/api/v1/cluster/$cluster_id/node_hostname\" ``` The Rubrik REST API server responds with an appropriate message.  ## Changing the Rubrik cluster name or time zone  To change the name or the current time zone of a Rubrik cluster, send a PATCH request to the [`/cluster/$cluster_id`](#operation/updateCluster) endpoint.  Specify the new name as the value of `$cluster_name`, and specify the new time zone as the value of `$cluster_timezone`.  **Example:** Changing the name and the time zone of a Rubrik cluster  ```bash curl -X PATCH \\   -d '{ \"clusterName\": $cluster_name, \"timezone\": { \"timezone\": $cluster_timezone } }' \\   \"https://$cluster_address/api/v1/cluster/$cluster_id\" ```  The response provides the attributes of the specified Rubrik cluster object, including the new name, and the new time zone.  ```bash {   \"id\": \"$cluster_id\",   \"version\": \"4.1.0\",   \"apiVersion\": \"1.0\",   \"name\": \"$cluster_name\",   \"timezone\": {       \"timezone\": \"$cluster_timezone\"   } } ```  ## Stage CDM software to the cluster.  Send a POST request to the [`/cluster/{id}/upgrade/stage_cdm_software`](#operation/stageCdmSoftware) endpoint.  ```bash curl -X POST \\   -d '{\"version\": \"$version\", \"packageUrl\": \"$packageUrl\", \"md5sum\": \"$md5sum\", \"size\": $size, \"skipDownload\": $skipDownload }' \\   \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/stage_cdm_software\" ```  ## Query asynchronous job status for upgrade related job  To query the job status details of an asynchronous job that is related to upgrades, issue a GET to [`/cluster/{id}/upgrade/request/{request_id}`](#operation/getAsyncRequestStatusForUpgrade).  ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/request/$request_id\" ```  ## Retrieve CDM version available for upgrade  Send a GET request to the [`/cluster/{id}/upgrade/available_version`](#operation/availableVersion) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/upgrade/available_version\" ```  ## Retrieving Rubrik cluster prechecks status. To start an on demand run of the periodic upgrade prechecks,  send a POST request to the [`/cluster/{id}/upgrade/precheck_status`](#operation/runPeriodicUpgradePrechecks) endpoint.  ```bash curl -X POST \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/ precheck_status\" ```  To retrieve the result of the latest run of periodic upgrade prechecks,  send a GET request to the [`/cluster/{id}/upgrade/precheck_status`](#operation/getPeriodicUpgradePrechecksStatus) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/ precheck_status\" ```  The Rubrik REST API server returns a response which provides the list of  failures along with start time and end time. ```bash {   \"endTime\": 1580385970715,   \"isOnDemand\": false,   \"failureResults\": [     {       \"isUserRemediable\": false,       \"errorMessage\": \"Sample error message\",       \"precheckName\": \"Sample precheck name\",       \"userRemediableAction\": \"\",       \"userRemediableActionMessage\": \"\"     }   ],   \"startTime\": 1580385904457 } ```  ## Checking if a Rubrik cluster has an existing set of Rubrik support portal credentials  Send a GET request to the [`/cluster/{id}/rubrik_support_portal_credentials`](#operation/hasRubrikSupportPortalCredentials) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/$cluster_id/rubrik_support_portal_credentials\" ```  ## Updating Rubrik support portal credentials on a Rubrik cluster  Send a POST request to the [`/cluster/{id}/rubrik_support_portal_credentials`](#operation/updateRubrikSupportPortalCredentials) endpoint.  ```bash curl -X POST \\   -d '{\"username\" : \"$username\", \"password\": \"$password\"}' \\   \"https://$cluster_address/api/v1/cluster/$cluster_id/rubrik_support_portal_credentials\" ```  ## Monitoring events on CDM  Send a GET request to the [`/cluster/me/upgrade/monitor_events`] (#operation/monitorEvents) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/cluster/me/upgrade/monitor_events\" ```  # Passwords  ## Setting password requirements  To set cluster-wide password requirements, send a PATCH request to [`/cluster/{id}/security/password_requirements`] (#operation/patchPasswordRequirements). The following parameters are optional: ```bash curl -X PATCH \\   -d '{     \"id\": \"$cluster_id\",     \"minLength\": \"$min_length\",     \"minUpperCase\": \"$min_upper_case\",     \"minLowerCase\": \"$min_lower_case\",     \"minNumerics\": \"$min_numerics\",     \"minSpecial\": \"$min_special\",     \"useZxcvbn\": \"$use_zxcvbn\" }' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\" ```  The Rubrik REST API server responds with a summary of the password requirements: ```bash {   \"id\": \"$cluster_id\",   \"minLength\": \"$min_length\",   \"maxLength\": \"$max_length\",   \"minUpperCase\": \"$min_upper_case\",   \"minLowerCase\": \"$min_lower_case\",   \"minNumerics\": \"$min_numerics\",   \"minSpecial\": \"$min_special\",   \"useZxcvbn\": \"$use_zxcvbn\" } ```  ## Getting current password requirements  To retrieve the existing cluster-wide password requirments, send a GET request to [`/cluster/{id}/security/password_requirements`] (#operation/queryPasswordRequirements)  ```bash curl -X GET \\   -d '{     \"id\": \"$cluster_id\" }' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\"  ```  The Rubrik REST API server responds with a summary of the password requirements: ```bash {   \"id\": \"$cluster_id\",   \"minLength\": \"$min_length\",   \"maxLength\": \"$max_length\",   \"minUpperCase\": \"$min_upper_case\",   \"minLowerCase\": \"$min_lower_case\",   \"minNumerics\": \"$min_numerics\",   \"minSpecial\": \"$min_special\",   \"useZxcvbn\": \"$use_zxcvbn\" } ```  ## Managing the Web Server Certificate  To retrieve the existing web server certificate signed by a CA, send a GET request to: [`/cluster/{id}/security/web_signed_cert`] (#operation/getWebSignedCertificate)  ```bash curl -X GET \\   -d '{     \"id\": \"$cluster_id\" }' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\" ``` ```bash {   \"webServerConfiguredWithCASignedCertificate\": true,   \"cert\": {     \"certId\": \"string\",     \"name\": \"string\",     \"pemFile\": \"string\",     \"hasKey\": true,     \"expiration\": \"2020-03-30T19:32:08.221Z\",     \"usedBy\": \"string\",     \"description\": \"string\"   } } ```  Set the web server certificate used by Rubrik for REST API communications by sending a PUT request to the [`/cluster/{id}/security/web_signed_cert`](#operation/setWebSignedCertificate) endpoint:  ```bash curl -X PUT \\   -d '{     \"certificateId\": \"string\"}' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\" ``` ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2020-03-30T19:09:13.400Z\",   \"endTime\": \"2020-03-30T19:09:13.400Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  To use the default, self-signed certificate, send a DELETE request to the [`/cluster/{id}/security/web_signed_cert`](#operation/resetWebSignedCertificate) endpoint.  ```bash curl -X DELETE \\   -d '{     \"id\": \"$cluster_id\" }' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\" ``` ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2020-03-30T19:31:13.024Z\",   \"endTime\": \"2020-03-30T19:31:13.025Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  ## Managing Truststores  To retrieve the existing truststore configuration, send a GET request to: [`/cluster/{id}/security/truststore`] (#operation/getTruststores)  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/cluster/{id}/security/truststore\" ``` ```bash {   \"hasMore\": false   \"data\": [     {       \"truststoreType\": \"TruststoreType\",       \"certificates\": [         {           \"certId\": \"string\",           \"name\": \"string\",           \"pemFile\": \"string\",           \"hasKey\": true,           \"expiration\": \"2020-03-30T19:32:08.221Z\",           \"usedBy\": \"string\",           \"description\": \"string\"         }       ]     }   ] } ```  To set the certificates for one or more of the truststores used by Rubrik, send a PATCH request to the [`/cluster/{id}/security/truststore`](#operation/setTruststoreCertificate) endpoint:  ```bash curl -X PATCH \\   -d '{       \"truststorePayload\": [ \\         {\"truststoreType\": \"TruststoreType\", certIds: [\"string\", \"string\"]} \\       ]}' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/truststore\" ``` ```bash OK ```  To clear the certificates for one or more of the truststores used by Rubrik, send a DELETE request to the [`/cluster/{id}/security/truststore`](#operation/unsetTruststoreCertificate) endpoint:  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/cluster/{id}/security/truststore?truststores=$truststore1,$truststore2\" ``` ```bash OK ```  ## Updating CORS support configuration  To update the CORS support configuration for a web server, send a PATCH request to [`/cluster/{id}/security/cors`](#operation/updateCorsConfiguration). ```bash curl -X PATCH \\   -d '{     \"isEnabled\": \"$is_enabled\",     \"allowedOrigins\": \"$allowed_origins\",     \"allowedHEaders\": \"$allowed_headers\" }' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/cors\" ```  ## Getting CORS support configuration  Retrieve the current CORS support configuration with a GET request to: [`/cluster/{id}/security/cors`](#operation/getCorsConfiguration). ```bash curl -X GET \\   \"https://$cluster_address/api/v1/cluster/{id}/security/cors\" ```  ## Getting FIPS enablement status  Retrieve the current FIPS enablement status with a GET request to: [`/cluster/{id}/security/fips`](#operation/getFips). ```bash curl -X GET \\   \"https://$cluster_address/api/v1/cluster/{id}/security/fips\" ```  ## Updating FIPS enablement  To update the FIPS enablement for a cluster, send a PATCH request to [`/cluster/{id}/security/fips`](#operation/updateFips). ```bash curl -X PATCH \\   -d '{     \"isEnabledInFlight\": \"$is_enabled_in_flight\" }' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/fips\" ```  ## Managing KMIP Servers To configure a new KMIP server integration, send a PUT request to the [`/cluster/{id}/security/kmip/server`](#operation/addKmipServer) endpoint. ```bash curl -X PUT \\   -d '{     \"serverAddress\": \"string\",     \"serverCertificateId\": \"string\",     \"serverPort\": 0}' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/server\"  ``` ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2020-03-31T22:10:40.912Z\",   \"endTime\": \"2020-03-31T22:10:40.912Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  For information about a configured KMIP server, send a GET request to the [`/cluster/{id}/security/kmip/server`](#operation/getKmipServer) endpoint: ```bash curl -X GET \\   \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/server?server_address=$address\" ``` ```bash [   {     \"serverAddress\": \"string\",     \"serverCertificateId\": \"string\",     \"serverPort\": 0   } ] ``` To delete an existing KMIP server integration, send a DELETE request to [`/cluster/{id}/security/kmip/server`](#operation/deleteKmipServer): ```bash curl -X DELETE \\ \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/server?server_address=$address\" ``` ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2020-03-31T22:15:26.693Z\",   \"endTime\": \"2020-03-31T22:15:26.693Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] }  ```  ## Managing the KMIP Client To configure the KMIP client, send a PUT request to [`/cluster/{id}/security/kmip/client`](#operation/setKmipClient) ```bash curl -X PUT \\   -d '{     \"username\": \"string\",     \"password\": \"string\",     \"clientCertificateId\": \"string\"     }' \\   \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/client\" ``` ```bash  ``` To retrieve information about the confiugred KMIP client, send a GET request to [`/cluster/{id}/security/kmip/client`](#operation/getKmipClient) ```bash curl -X GET \\   \"https://$cluster_address/api/v1/cluster/{id}/security/kmip/client\" ``` ```bash {   \"username\": \"string\",   \"clientCertificateId\": \"string\",   \"isPasswordSet\": true } ```  ## Manage the 2-Step Verification Global Setting ### Retrieving the 2-Step Verification global setting To retrieve the 2-Step Verification global setting for a specific Rubrik cluster, send a GET request to [`/cluster/{id}/security/totp/setting`](#operation/getTotpGlobalSetting). ```bash curl -X GET \\   \"https://$cluster_address/api/v1/cluster/{id}/security/totp/setting\" ``` The Rubrik REST API server responds with the 2-Step Verification setting for the specified Rubrik cluster. ```bash {   \"isEnforced\": true } ```  ### Updating the 2-Step Verification global setting To update the 2-Step Verification global setting for a specific Rubrik cluster, send a PUT request to [`/cluster/{id}/security/totp/setting`](#operation/updateTotpGlobalSetting). ```bash curl -X PUT \\   -d '{\"isEnforced\": true}'   \"https://$cluster_address/api/v1/cluster/{id}/security/totp/setting\" ``` The Rubrik REST API server responds with the updated 2-Step Verification  setting for the specified Rubrik cluster. ```bash {   \"isEnforced\": true } ```  # Event  ## Get latest events and event series info for event series Send a GET request to [`/event/latest`](#operation/queryLatestEventsV1)  ```bash curl -X GET \"https://$cluster_address/api/v1/event/latest\" ```  ## Get information for all events Send a GET request to [`/event`](#operation/queryEventV1)  ```bash curl -X GET \"https://$cluster_address/api/v1/event\" ```  ## Get all events and relevant information associated with an event series Send a GET request to [`/event_series/{id}`](#operation/queryEventSeriesByIdV1)  ```bash curl -X GET \"https://$cluster_address/api/v1/event_series/{id}\" ```  ## Get download link of CSV file containing summary of events Send a GET request to [`/event/csv_download_link`](#operation/getEventsCsvDownloadLink)  ```bash curl -X GET \"https://$cluster_address/api/v1//event/csv_download_link\" ```  # SLA Domains  Rubrik clusters provide automated data management and protection through SLA Domains. An SLA Domain defines the data management and protection policies for their assigned snappables (virtual machines, file systems, and applications).  To provide policy based management and protection of a snappable, add the snappable to an SLA Domain, or to multiple SLA Domains.  ## Retrieving SLA Domains  Before assigning snappables to SLA Domains, get a list of the SLA Domains that exist on a Rubrik cluster. For a new Rubrik cluster, the list shows only the default SLA Domains. When custom SLA Domains are added to the Rubrik cluster, the list is modified to include those SLA Domains.  **Example:** Retrieving SLA Domains from a Rubrik cluster  Send a GET request to [`/sla_domain`](#operation/querySlaDomain).  ```bash curl -X GET \"https://$cluster_address/api/v1/sla_domain\" ```  The Rubrik REST API server returns a `ListResponse` object of all SLA Domains. At a minimum, the `ListResponse` object includes the default SLA Domains: Gold, Silver, and Bronze.  ```bash {   \"data\": [     {       \"id\": \"$gold_sla_id\",       \"name\": \"Gold\"     },     {       \"id\": \"$silver_sla_id\",       \"name\": \"Silver\"     },     {       \"id\": \"$bronze_sla_id\",       \"name\": \"Bronze\"     }   ],   \"hasMore\": false,   \"total\": 3 } ```  To obtain more details about a specific SLA domain send a GET request with the `id` of one of the SLA Domains to the `/sla_domain/{id}` endpoint:  [`/sla_domain/{id}`](#operation/getSlaDomain)  ```bash curl -X GET \"https://$cluster_address/api/v1/sla_domain/$bronze_sla_id\" ``` The Rubrik REST API server responds with the details of the specified SLA Domain.  ```bash {   \"id\": \"$bronze_sla_id\",   \"primaryClusterId\": \"$cluster_id\",   \"name\": \"Bronze\",   \"frequencies\": [     {       \"timeUnit\": \"Daily\",       \"frequency\": 1,       \"retention\": 32     },     {       \"timeUnit\": \"Monthly\",       \"frequency\": 1,       \"retention\": 12     },     {       \"timeUnit\": \"Yearly\",       \"frequency\": 1,       \"retention\": 2     }   ],   \"allowedBackupWindows\": [],   \"firstFullAllowedBackupWindows\": [],   \"archivalSpecs\": [],   \"replicationSpecs\": [     {       \"locationId\": \"$repl_location_id\",       \"retentionLimit\": 0     }   ],   \"numDbs\": 0,   \"numFilesets\": 7,   \"numLinuxHosts\": 3,   \"numWindowsHosts\": 2,   \"numVms\": 1,   \"isDefault\": false,   \"uiColor\": \"#cc8366\" } ```  ## Working with SLA Domains  To work with an SLA Domain, obtain the `id` of that SLA Domain. As described in [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains), start by sending a GET request to [`/sla_domain`](#operation/querySlaDomain).  The Rubrik REST API server responds with a `ListResponse` object that contains all of the SLA Domains on the specfied Rubrik cluster. From that list object, find the data array element that has the `name` value of the selected SLA Domain. In the same array element as the `name` value, note the value of the `id` string.  ## Creating SLA Domains  To create an SLA domain send a POST request to [`/sla_domain`](#operation/createSlaDomain). Include the attributes for the SLA Domain in the request body.  The following table describes the required and optional attributes to include in the request body when creating an SLA Domain.  | Attribute | Req'd | JSON Type | Description | | ------ | --- | ----- | ----------- | | `name` | Yes | String | Name of the SLA Domain.  | | `frequencies` | Yes | Array | Each member defines a policy by specifying: `timeUnit`, `frequency`, and `retention`. Requires at least one member in the array.  | | `allowedBackupWindows` | Yes | Array | Each member defines a backup window using values for `startTimeAttributes` and `durationInHours`. The time specified in `startTimeAttributes` uses the Rubrik cluster time zone. To specify multiple backup windows, add an array member for each window. To create an SLA Domain without a backup window, specify a null array value: `[]`.  | | `firstFullAllowedBackupWindows` | Yes | Array | Each member defines a period when first full backups are allowed by specifying: `startTimeAttributes` and `durationInHours`. Several first full backup windows can be specified by adding an array member for each one. Create an SLA Domain without a first full backup window by specifying a null array value: `[]`.  | | `localRetentionLimit` | No | String | Specify an integer value to set the number of days to retain a local copy of a snapshot. When an archival location is specified, specify `0` to enable Instant Archiving. | | `archivalSpecs` | No | Array | Defines the archival location for the SLA Domain by specifying: `locationId` and `archivalThreshold`. Currently limited to one array member. | | `replicationSpecs` | No | Array | Defines the replication location for the SLA Domain by specifying: `locationId` and `retentionLimit`. Currently limited to one array member. |  **Example:** Creating an SLA Domain for daily backups  Create an SLA Domain that takes a backup once a day and retains the backup for seven days. Do not set a backup window or a first full backup window. Do not include archival or replication.  ```bash curl -X POST \\   -d '{   \"name\": \"Daily SLA\",   \"frequencies\": [     {       \"timeUnit\": \"Day\",       \"frequency\": 1,       \"retention\": 7     }   ],   \"allowedBackupWindows\": [],   \"firstFullAllowedBackupWindows\": [] }' \\   \"https://$cluster_address/api/v1/sla_domain\" ``` The response confirms the attributes of the SLA Domain and provides the `id` of the new SLA Domain.  ```bash {   \"id\": \"$sla_id\",   \"name\": \"Daily SLA\",   \"frequencies\": [     {       \"timeUnit\": \"Day\",       \"frequency\": 1,       \"retention\": 7     }   ],   \"allowedBackupWindows\": [],   \"firstFullAllowedBackupWindows\": [] } ``` ## Modifying SLA Domains  To modify the attributes of an SLA domain send a PUT request to [`/sla_domain/{id}`](#operation/updateSlaDomain). Include in the request body the new attributes.  **Example:** Modifying the daily backup SLA Domain  Change the SLA Domain that was created in [Creating SLA Domains](#section/SLA-Domains/Creating-SLA-Domains) to increase the retention to 14 days.  ```bash curl -X PUT \\   -d '{   \"name\": \"Daily SLA\",   \"frequencies\": [     {       \"timeUnit\": \"Day\",       \"frequency\": 1,       \"retention\": 14     }   ],   \"allowedBackupWindows\": [],   \"firstFullAllowedBackupWindows\": [] }' \\   \"https://$cluster_address/api/v1/sla_domain/$sla_id\" ``` The response confirms the new attribute.  ```bash {   \"id\": \"$sla_id\",   \"name\": \"Daily SLA\",   \"frequencies\": [     {       \"timeUnit\": \"Day\",       \"frequency\": 1,       \"retention\": 14     }   ],   \"allowedBackupWindows\": [],   \"firstFullAllowedBackupWindows\": [] } ``` ## Patching SLA Domains  To patch the attributes of an SLA domain, send a PATCH request to [`/sla_domain/{id}`](#operation/patchSlaDomain). Include in the request body only the attributes that needs to be patched.  **Example:** Patching the daily backup SLA Domain  Patch the SLA Domain that was created in [Creating SLA Domains] (#section/SLA-Domains/Creating-SLA-Domains) to change the archival specifications.  ```bash curl -X PATCH \\   -d '{   \"archivalSpecs\": [     {         \"locationId\": \"some-valid-archived-location-id\",         \"archivalThreshold\": 14     }   ]}' \\   \"https://$cluster_address/api/v1/sla_domain/$sla_id\" ``` The response confirms the new attribute and also includes the other attributes that were not changed.  ```bash {   \"id\": \"$sla_id\",   \"name\": \"Daily SLA\",   \"frequencies\": [     {       \"timeUnit\": \"Day\",       \"frequency\": 1,       \"retention\": 7     }   ],   \"archivalSpecs\": [     {       \"locationId\": \"some-valid-archived-location-id\",       \"archivalThreshold\": 14     }   ],   \"allowedBackupWindows\": [],   \"firstFullAllowedBackupWindows\": [] } ``` ## Deleting SLA Domains  To delete an SLA domain send a DELETE request to [`/sla_domain/{id}`](#operation/deleteSlaDomain).  **Example:** Deleting an SLA Domain  Delete an SLA Domain with the `id` of `$sla_id`.  ```bash curl -X DELETE \"https://$cluster_address/api/v1/sla_domain/$sla_id\" ``` The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  ## Inherited protection  The Rubrik REST API uses the reserved value `INHERIT` with the `configuredSlaDomainId` string to identify a snappable that derives its protection policy from a parent object. Examples of this: * VMware virtual machine inherits from vCenter Server * SQL Server database inherits from SQL Server instance  Every snappable that can be protected through an SLA Domain is represented by an object that has a `configuredSlaDomainId` attribute and an `effectiveSlaDomainId` attribute. The `configuredSlaDomainId` attribute contains either the value of a direct SLA Domain assignment or the reserved value `INHERIT`.  The `effectiveSlaDomainId` attribute contains the value of the SLA Domain setting that the Rubrik cluster actually applies to the snappable. When the value of the `configuredSlaDomainId` attribute is `INHERIT`, the value of the `effectiveSlaDomainId` attribute is derived from a parent object of the snappable. In all other cases, the value of the `effectiveSlaDomainId` attribute is the same as the value of the `configuredSlaDomainId` attribute.   ## SLA Domain assignments  To assign a snappable to an SLA Domain, use the endpoint that is provided for that type of snappable. * VMware virtual machines   Send a PATCH request to  [`/vmware/vm/{id}`](#operation/updateVm). [VMware virtual machines](#section/VMware-virtual-machines) provides more information about this. * Linux or Windows filesets   Send a PATCH request to  [`/fileset/{id}`](#operation/updateFileset). [Filesets](#section/Filesets) provides more information about this. * SQL Server databases   Send a PATCH request to  [`/mssql/db/{id}`](#operation/updateMssqlDb). [SQL Server databases](#section/SQL-Server-databases) provides more information about this.  ## Assigning SLA Domain to downloaded snapshots  To assign an SLA Domain to a list of snapshots at their downloaded locations, send a POST request to the [`/sla_domain/assign_to_downloaded_snapshots`] (#operation/assignSlaToDownloadedSnapshots) endpoint.  **Example:** Assigning an SLA Domain with ID $slaId to list of snapshots -              $s1Id, $s2Id of object $snappableId  ```bash curl -X POST \\   -d '{    \"slaDomainId\": $slaId    \"objectId\": $snappableId    \"snapshotIds\": [$s1Id, $s2Id]}' \\    \"https://$cluster_address/api/v1/sla_domain/assign_to_downloaded_snapshots\" ```  ```bash {   \"responses\": [     {       \"id\": \"string\",       \"status\": \"string\",       \"progress\": 0,       \"startTime\": \"2019-10-29T22:11:35.256Z\",       \"endTime\": \"2019-10-29T22:11:35.256Z\",       \"nodeId\": \"string\",       \"error\": {         \"message\": \"string\"       },       \"links\": [         {           \"href\": \"string\",           \"rel\": \"string\"         }       ]     }   ] } ```  The Rubrik REST API server responds with HTTP response code 200 and the response body containing the details of the async request.  # Virtual machines  The Rubrik cluster protects virtual machines running in a VMware vSphere environment through the VADP APIs. The Rubrik cluster also works with the Rubrik Backup Service running on the virtual machine to provide:  * Optimal performance when restoring files and folders to the virtual machine * Application consistent snapshots of a Windows virtual machine   ## vCenter servers  A Rubrik cluster normally protects and manages virtual machines through the vCenter Server that administers those virtual machines. After a vCenter server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the virtual machines that are administered by that vCenter server.  ### Retrieving vCenter Servers  Request a list of the vCenter servers that are registered with a Rubrik cluster by sending a GET request to  [`/vmware/vcenter`](#operation/queryVcenter).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vcenter\" ```  The Rubrik REST API server responds with the first page of a `ListResponse` object.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$vcenter_id0\",       \"hostname\": \"$vcenter_address0\",       \"username\": \"$vcenter_admin0\",       \"configuredSlaDomainId\": \"INHERIT\",       \"primaryClusterId\": \"$cluster_id\",       \"caCerts\": \"$ca_certs0\"     },     {       \"id\": \"$vcenter_id1\",       \"hostname\": \"$vcenter_address1\",       \"username\": \"$vcenter_admin1\",       \"configuredSlaDomainId\": \"INHERIT\",       \"primaryClusterId\": \"$cluster_id\",       \"caCerts\": \"$ca_certs1\"     }   ],   \"total\": 2 } ``` Depending on the number of registered vCenter Servers, all of the entries on the list may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.   ### Adding a vCenter server  To add a vCenter server, send a POST request to [`/vmware/vcenter`](#operation/createVcenter). Include in the body of the request the address of the vCenter server and credentials for a user account (`username`) that has the required permissions. The Rubrik User Guide provides details about creating an account with the required permissions.  ```bash curl -X POST \\   -d '{     \"hostname\": \"$vcenter_address\",     \"username\": \"$vcenter_admin\",     \"password\": \"$vcenter_password\" }' \\   \"https://$cluster_address/api/v1/vmware/vcenter\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$request_id\",   \"status\": \"RUNNING\",   \"error\": \"None\",   \"progress\": \"$request_progress\"   \"links\": [     {       href: \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       rel: \"self\"     }   ] } ```  Using the information provided in the task object, send a GET request to the [`/vmware/vcenter/request/{id}`](#operation/getVcenterAsyncRequestStatus) endpoint to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the task finished successfully.  ### Retrieve vCenter Server details Get the details for a vCenter Server that is registered with a Rubrik cluster by sending a GET request to [`/vmware/vcenter/{id}`](#operation/getVcenter).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vcenter/{id}\" ```  The Rubrik REST API server responds with the details of the specified vCenter Server object.  ```bash {   \"id\": \"$id\",   \"hostname\": \"$vcenter_address0\",   \"username\": \"$vcenter_admin0\",   \"configuredSlaDomainId\": \"INHERIT\",   \"primaryClusterId\": \"$cluster_id\" } ```  ### Modifying a vCenter Server entry  To change the information that a Rubrik cluster stores for a vCenter Server, send a PUT request to [`/vmware/vcenter/{id}`](#operation/updateVcenter). All of the members of the `VcenterConfig` object must be in the PUT request. Using the new values, include in the body of the PUT request each member (`{string : value}`) of the `VcenterConfig` object: * `\"hostname\": \"$vcenter_address\"` * `\"username\": \"$vcenter_admin\"` * `\"password\": \"$vcenter_password\"`  To change the configured SLA that is configured for a vCenter Server or to change CA certificates for the vCenter, send a PATCH request to[`/vmware/vcenter/{id}`](#operation/patchVcenter).  ```bash curl -X PUT \\   -d '{     \"hostname\": \"$vcenter_address\",     \"username\": \"$vcenter_admin\",     \"password\": \"$vcenter_password\" }' \\   \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\" ```  The Rubrik REST API server sends a response, with the updated details of the vCenter Server entry in the response body.  ```bash {   \"id\": \"$vcenter_id\",   \"hostname\": \"$vcenter_address\",   \"username\": \"$vcenter_admin\",   \"configuredSlaDomainId\": \"INHERIT\",   \"primaryClusterId\": \"$cluster_id\",   \"caCerts\": \"$ca_certs\" } ``` ### Removing a vCenter Server entry  To remove a vCenter Server entry from a Rubrik cluster, first unmount any Live Mount and Instant Recovery virtual machines for the vCenter Server. Then send a DELETE request to [`/vmware/vcenter/{id}`](#operation/deleteVcenter).  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\" ``` The Rubrik REST API server initiates the asynchronous delete task and responds with a task object.  ```bash {     \"id\": \"$request_id\",     \"status\": \"RUNNING\",     \"error\": \"None\",     \"progress\": 0,     \"startTime\": \"$start_timestamp\",     \"endTime\": \"$end_timestamp\",     \"links\": [       {         \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",         \"rel\": \"self\"       }     ]   } ``` Using the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the removal of the vCenter Server object finished successfully.  ### Force refresh of virtual machine on a vCenter Force a refresh of the metadata for a single virtual machine by sending a POST request to [`/vmware/vcenter/{id}`](#operation/createRefreshVmV1).  ```bash curl -X POST \\   -d '{     \"vmMoid\": \"$vm_moid\" }' \\   \"https://$cluster_address/api/v1/vmware/vcenter/{id}/refresh_vm\" ```  The Rubrik REST API server responds with a 204 response.    ### Metadata refresh  The Rubrik cluster regularly refreshes the metadata of the registered vCenter Servers. As part of a refresh operation, the Rubrik cluster discovers any changes or additions to the virtual machines that are administered by the vCenter Servers. Instead of waiting for a regular refresh, a metadata refresh can be manually initiated by sending a POST request to [`/vmware/vm/refresh`](#operation/createRefresh), using the Rubrik cluster ID (`$cluster_address`) and the vCenter Server ID (`$vcenter_id`).  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id/refresh\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$request_id\",   \"status\": \"RUNNING\",   \"error\": \"None\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  Using the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the metadata refresh completed successfully.  ## ESXi hypervisors  Retrieve a list of all available ESXi hypervisors in the vSphere environment by sending a GET request to [`/vmware/host`](#operation/queryVmwareHost).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/host?primary_cluster_id=$cluster_id\" ``` The value of `primary_cluster_id` is the `id` of a Rubrik cluster. Use `local` to retrieve a list for the Rubrik cluster that is hosting the current session.  The Rubrik REST API server responds with the first page of a `ListResponse` object.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$esxi_id\",       \"name\": \"$esxi_name\",       \"datacenterId\": \"$datacenter_id\",       \"computeClusterId\": \"$compute_cluster_id\",       \"datastores\": [       ...       ],       \"configuredSlaDomainId\": \"INHERIT\",       \"primaryClusterId\": \"$cluster_id\"     }     ],   \"total\": 1 } ```  Retrieve more details for an ESXi hypervisor by sending a GET request to [`/vmware/host/{id}`](#operation/getVmwareHost)  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/vmware/host/$esxi_id\" ```  The Rubrik REST API server responds with the details for the specified ESXi hypervisor.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  ```bash {   \"id\": \"$esxi_id\",   \"moid\": \"$moid\",   \"name\": \"$esxi_name\",   \"computeClusterId\": \"$compute_cluster_id\",   \"datacenter\": {     \"id\": \"$datacenter_id\",     \"name\": \"$datacenter_name\",     \"vcenterId\": \"$vcenter_id\",     \"configuredSlaDomainId\": \"INHERIT\",     \"primaryClusterId\": \"$cluster_id\"   },   \"datastores\": [     ...   ],   \"virtualMachines\": [     ...   ],   \"configuredSlaDomainId\": \"INHERIT\",   \"primaryClusterId\": \"$cluster_id\" } ```  Additionally, To change the SLA Domain that is configured for an ESXi hypervisor, send a PATCH request on [`/vmware/host`](#operation/updateVmwareHost)  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/vmware/host/$snapshot_id\" ```  Retrieve datastore details for an ESXi hypervisor by sending a GET request to [`/vmware/host/{id}/datastore`](#operation/getVmwareHostDatastore) ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/host/$esxi_id/datastore\" ```   ## Virtual machine protection  After a vCenter Server is registered, the Rubrik cluster acquires metadata for the virtual machines that are administered through that vCenter Server. Using the metadata, assign Rubrik cluster protection to the virtual machines.  The typical protection workflow involves the following tasks: 1. Find the virtual machine resource object. 2. (Optional) Enable scripts on the virtual machine. 3. (Optional) Exclude specified vmdk files for the virtual machine. 4. Assign the virtual machine to an SLA Domain. 5. (Optional) Get the configuration used to force a full snapshot of the    virtual machine. 6. (Optional) Request a forced full snapshot for the virtual machine.  ### Finding virtual machines Get a list of the virtual machine objects known to the Rubrik cluster by sending a GET request to [`/vmware/vm`](#operation/queryVm). The Rubrik REST API server returns a response that includes a `ListResponse` object. Use query parameters as part of the GET request, to filter the list and to work with the `ListResponse` object.  A GET request that is sent to the [`/vmware/vm`](#operation/queryVm) endpoint accepts the query parameters that are described in the following table. | Parameter | Description | | --------- | ----------- | | `effective_sla_domain_id` | SLA Domain applied to the virtual machine, either directly or derived. Use `UNPROTECTED` for virtual machines that do not have a derived or direct SLA Domain. | | `primary_cluster_id` | The `id` of the primary Rubrik cluster for the virtual machine. Use `local` for the Rubrik cluster that is hosting the Rubrik REST API session. | | `limit` | Maximum number of a elements to include in the `data` array of the response. | | `offset` | Index reference point to use when determining the elements to include in the response. | | `is_relic` | Relic status of the virtual machine. `true` to specify only relic virtual machines. `false` to exclude relic virtual machines. Do not include the parameter to include both relic and non-relic virtual machines. | | `name` | String value to match in any part of the name of a virtual machine.  | | `moid` | String value to match in any part of the MOID of a virtual machine.  | | `sla_assignment` | SLA Domain assignment status of the virtual machine. Use `derived` for virtual machines that derive protection status from another resource object. Use `direct` for virtual machines that have a directly assigned SLA Domain. Use `unassigned` for virtual machines that do not have a direct or derived SLA Domain. | | `guest_os_name` | Filter by vm guest os name using infix search. | | `sort_by` | Perform an ASCII sort of the elements in the `ListResponse` object data array by a specified object value: `effective_sla_domain_id`, `name`, `moid`, `folderPath`, or `infraPath`. | | sort_order | Sort order for the elements in the ListResponse object data array. Use `asc` for ascending sort or `desc` for descending sort. |   **Example:** Retrieving a list of virtual machine resource objects  Retrieve a list of unprotected virtual machine resource objects that have 'test' in their name. Limit the first page of the response to the first object.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm?effective_sla_domain_id=UNPROTECTED&limit=1&offset=0&name=test\" ``` The Rubrik REST API server responds with a `ListResponse` object. The first page has the first object of the 156 objects that matched the query parameters.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$vm_id\",       \"moid\": \"$vm_moid\",       \"name\": \"abctest123\",       \"vcenterId\": \"$vcenter_id\",       \"hostName\": \"$esxi_host_name\",       \"hostId\": \"$esxi_host_id\",       \"clusterName\": \"$vcenter_cluster_name\",       \"powerStatus\": \"poweredOn\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"slaAssignment\": \"Unassigned\",       \"ipAddress\": \"$vm_ip\",       \"toolsInstalled\": true,       \"primaryClusterId\": \"$cluster_id\",       \"isReplicationEnabled\": false,       \"folderPath\": [         ...       ],       \"infraPath\": [         ...       ],       \"vmwareToolsInstalled\": true,       \"isRelic\": false,       \"maxNestedVsphereSnapshots\": -1,       \"snapshotConsistencyMandate\": \"UNKNOWN\",       \"physicalStorage\": 0,       \"guestCredentialAuthorizationStatus\": \"PENDING\"     }   ],   \"total\": 156 } ```  ### Retrieving more details for a virtual machine To get detailed information for a specified virtual machine object, send a GET request to [`/vmware/vm/{id}`](#operation/getVm).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id\" ``` The Rubrik REST API server responds with the details for the virtual machine object.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  ```bash {   \"id\": \"$vm_id\",   \"moid\": \"$vm_moid\",   \"name\": \"abctest123\",   \"powerStatus\": \"poweredOn\",   \"configuredSlaDomainId\": \"INHERIT\",   \"effectiveSlaDomain\": {     ...   },   \"slaAssignment\": \"Unassigned\",   \"blackoutWindowStatus\": {     \"isGlobalBlackoutActive\": false,     \"isSnappableBlackoutActive\": false   },   \"blackoutWindows\": {     ...     ],     \"snappableBlackoutWindows\": []   },   \"currentHost\": {     ...   },   \"virtualDiskIds\": [     ...   ],   \"snapshots\": [],   \"ipAddress\": \"$vm_ip\",   \"toolsInstalled\": true,   \"snapshotCount\": 0,   \"snapshotConsistencyMandate\": \"\",   \"maxNestedVsphereSnapshots\": -1,   \"primaryClusterId\": \"$cluster_id\",   \"isReplicationEnabled\": false,   \"isRelic\": false,   \"physicalStorage\": 0,   \"guestOsName\": \"$guest_os\",   \"guestCredentialAuthorizationStatus\": \"PENDING\",   \"isArrayIntegrationPossible\": false,   \"isArrayIntegrationEnabled\": false } ```  ### Register Rubrik Backup Service  To register Rubrik Backup Service running on a specified virtual machine, send a POST request to [`/vmware/vm/{id}/register_agent`](#operation/vmRegisterAgent).  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id/register_agent\" ``` The Rubrik REST API server responds with an HTTP 204 response when the registration is successful.   ### Enabling scripts  A virtual machine object can be configured to start scripts on the guest operating system. A script can be started before the backup (`preBackupScript`), after the snapshot completes (`postSnapScript`), and after the backup task completes (`postBackupScript`). The *Rubrik User Guide* provides information about script requirements.  To configure a virtual machine object to start scripts, send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm). Since this is a PATCH request, only the elements of the virtual machine object that are modified or added should be included in the request body. All three script members are shown in the request body in this model, but all are optional.  ```bash curl -X PATCH \\  -d '{       \"preBackupScript\": {         \"scriptPath\": \"$pre_script_path\",         \"timeoutMs\": 10000,         \"failureHandling\": \"abort\"       },       \"postSnapScript\": {         \"scriptPath\": \"$postsnap_script_path\",         \"timeoutMs\": 10000,         \"failureHandling\": \"abort\"       },       \"postBackupScript\": {         \"scriptPath\": \"$postbackup_script_path\",         \"timeoutMs\": 10000,         \"failureHandling\": \"abort\"       }     }' \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id\" ```  The Rubrik REST API server sends an HTTP 200 response that includes the modified or added members in the response body.  #### Manually starting a virtual machine script  For testing or to run a script before running a backup, manually trigger the script by sending a POST request to [`/vmware/vm/{id}/guest_script/run`](#operation/runGuestOsScript). To manually start a script, the script must first be a part of the configuration of the virtual machine object. Use the value of the `phase` member to identify the script, as follows: * Use `PreBackup` for the script identified by the `preBackupScript` member. * Use `PostSnap` for the script identified by the `postSnapScript` member. * Use `PostBackup` for the script identified by the `postBackupScript` member.  ```bash curl -X POST \\   -d '{     \"phase\": \"PreBackup\" }' \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id/guest_script/run\" ``` The Rubrik REST API server responds with an HTTP 204 response when the script finishes with a 0 exit code.   ### Excluding a VMDK file  The Rubrik cluster can be configured to ignore some of the VMDK files of a virtual machine while protecting the other VMDK files of that virtual machine. To exclude a VMDK file, send a GET request to [`/vmware/vm/virtual_disk/{id}`](#operation/getVirtualDisk) using the `$disk_id` of the VMDK file.  To get the `$disk_id` values, send a GET request to [`/vmware/vm/{id}`](#operation/getVm). The response body has the `disk_id` values for the virtual machine in the `virtualDiskIds` array.  After identifying the `$disk_id` for a VMDK file, obtain the current state of the VMDK file.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\" ``` The Rubrik REST API server responds with the value of `excludeFromSnapshots`.  ```bash {   \"id\": \"$disk_id\",   \"excludeFromSnapshots\": false } ``` When the value is `false` the Rubrik cluster is not configured to exclude the VMDK file. Change this value to `true` to instruct the Rubrik cluster to exclude the VMDK file from all subsequent snapshots of the virtual machine.  Send a PATCH request to [`/vmware/vm/virtual_disk/{id}`](#operation/updateVirtualDisk) to change the value of `excludeFromSnapshots` to `true` and exclude the VMDK file.  ```bash curl -X PATCH \\   -d '{     \"excludeFromSnapshots\": true }' \\   \"https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\" ```  The Rubrik REST API server responds with the updated `excludeFromSnapshots` value for the VMDK file.  ```bash {   \"id\": \"$disk_id\",   \"excludeFromSnapshots\": true } ```  ### Assigning a virtual machine to an SLA Domain To protect a virtual machine through the rules and policies of an SLA Domain send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm) with the value of `configuredSlaDomainId` set to the `$sla_domain_id`.  **Note:** [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains) describes how to retrieve the SLA Domain objects on a Rubrik cluster.  ```bash curl -X PATCH -d \\   '{     \"configuredSlaDomainId\": \"$sla_domain_id\"   }' \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id\" ``` The Rubrik REST API server responds with confirmation of the assignment.  ```bash {   \"id\": \"$vm_id\",   \"configuredSlaDomainId\": \"$sla_domain_id\" } ``` ### Getting the configuration used to force a full snapshot of a virtual machine  To retrieve the configuration of a virtual machine that is used to force a full snapshot of the virtual machine, send a GET request to [`/vmware/vm/{id}/request/force_full_snapshot`](#operation/getVmForceFullSpec).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/{id}/request/force_full_snapshot\" ```  The Rubrik REST API server responds with the force full snapshot object which contains the latest configuration of the virtual machine.  ```bash {   \"vmId\": \"$vm_id\",   \"virtualDiskInfos\": [     {       \"virtualDiskId\": \"$disk_id\",       \"shouldDedupe\": false     },     {       \"virtualDiskId\": \"$disk_id\",       \"shouldDedupe\": true     }   ] } ``` ### Requesting a forced full snapshot for a virtual machine  To force a full snapshot of a virtual machine, send a POST request to [`/vmware/vm/{id}/request/force_full_snapshot`](#operation/requestVmForceFullSnapshot).  ```bash curl -X POST \"https://$cluster_address/api/v1/vmware/vm/{id}/request/force_full_snapshot\" ```  The Rubrik REST API server persists the configuration for forcing a full snapshot until the next backup job, which takes a full snapshot and clears the configuration.  ```bash {   \"vmId\": \"$vm_id\",   \"virtualDiskInfos\": [     {       \"virtualDiskId\": \"$disk_id\",       \"shouldDedupe\": false     },     {       \"virtualDiskId\": \"$disk_id\",       \"shouldDedupe\": true     }   ] } ``` ## Snapshot management  Managing snapshots includes the following possible actions: * Retrieving snapshot information * Retrieving snapshot information for multiple virtual machines * Retrieving snapshot details * Retrieving missed snapshot information * Creating on-demand snapshots * Expiring individual snapshots * Expiring all snapshots for a virtual machine  ### Retrieving snapshot information  To retrieve a list of the snapshots for a virtual machine, send a GET request to [`/vmware/vm/{id}/snapshot`](#operation/querySnapshot).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\" ``` The Rubrik REST API server responds with a `ListResponse` object.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"date\": \"$timestamp0\",       \"indexState\": 0,       \"cloudState\": 0,       \"vmName\": \"$vm_name\",       \"replicationLocationIds\": [],       \"id\": \"$snapshot_id0\",       \"consistencyLevel\": \"$consistency_level0\",       \"archivalLocationIds\": [],       \"isOnDemandSnapshot\": false     },     {       \"date\": \"$timestamp1\",       \"indexState\": 0,       \"cloudState\": 0,       \"vmName\": \"$vm_name\",       \"replicationLocationIds\": [],       \"id\": \"$snapshot_id1\",       \"consistencyLevel\": \"$consistency_level1\",       \"archivalLocationIds\": [],       \"isOnDemandSnapshot\": true     }  ],  \"total\": 2 } ``` Each member of the data array includes the `id` of a snapshot. Use this value (`$snapshot_id`) to perform tasks with the snapshot, such as: * Browsing for data in the snapshot * Downloading data from the snapshot * Restoring data from the snapshot * Exporting data from the snapshot * Mounting a virtual machine from the snapshot  ### Retrieving snapshot information for a batch of virtual machines  To retrieve lists of snapshots for a batch of virtual machines, send a POST request to [`/vmware/vm/snapshots`](#operation/querySnapshotsForVms). This reuqest taks a list of virtual mahine IDs.  ```bash curl -X POST \\   -d '{      \"vm_ids\": [\"vmId_1\", \"vmId_2\"]      }'\\       \"https://$cluster_address/api/v1/vmware/vm/snapshots\" ```  The Rubrik REST API server responds with a `BatchVmSnapshotSummaries` object.  ```bash {   \"responses\":   [     {       \"vmId\": \"vmId_1\",       \"VmSnapshotSummaries\":       [         {           \"date\": \"$timestamp0\",           \"indexState\": 0,           \"cloudState\": 0,           \"vmName\": \"$vm_name\",           \"replicationLocationIds\": [],           \"id\": \"$snapshot_id0\",           \"consistencyLevel\": \"$consistency_level0\",           \"archivalLocationIds\": [],           \"isOnDemandSnapshot\": false         }       ]     },     {       \"vmId\": \"vmId_2\",       \"VmSnapshotSummaries\":       [         {           \"date\": \"$timestamp0\",           \"indexState\": 0,           \"cloudState\": 0,           \"vmName\": \"$vm_name\",           \"replicationLocationIds\": [],           \"id\": \"$snapshot_id0\",           \"consistencyLevel\": \"$consistency_level0\",           \"archivalLocationIds\": [],           \"isOnDemandSnapshot\": false         }       ]     }   ] } ```  ### Retrieving snapshot details  To retrieve details for a specified snapshot send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\" ``` The Rubrik REST API server responds with the details of the specified snapshot.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  ```bash {   \"date\": \"$timestamp\",   \"indexState\": 0,   \"virtualMachine\": {    ...   },   \"vmName\": \"$vm_name\",   \"isCorrupt\": false,   \"replicationLocationIds\": [],   \"archivalLocationIds\": [],   \"snapshotDiskIds\": [     \"$vmdk_id\"   ],   \"isOnDemandSnapshot\": false,   \"cloudState\": 0,   \"id\": \"$snapshot_id\",   \"consistencyLevel\": \"1\",   \"config\": \"[]\" } ```  ### Retrieving missed snapshot information  The Rubrik cluster stores information for missed snapshots. *Missed snapshots* are snapshot tasks that are not completed as required by the rules and policies of an SLA Domain.  Retrieve missed snapshot information for a virtual machine by sending  a GET request to [`/vmware/vm/{id}/missed_snapshot`](#operation/missedSnapshots).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/$vm_id/missed_snapshot\" ``` The Rubrik REST API server responds with a `ListResponse` object.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"archivalLocationType\": [         \"missed\"       ],       \"missedSnapshotTime\": \"$timestamp0\"     },     {       \"archivalLocationType\": [         \"missed\"       ],       \"missedSnapshotTime\": \"$timestamp1\"     }   ],   \"total\": 2 } ```  ### Creating on-demand snapshots  On-demand snapshots can be created for both protected and unprotected virtual machines. To create an on-demand snapshot of a virtual machine send a POST request to [`/vmware/vm/{id}/snapshot`](#operation/createOnDemandBackup).  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\" ``` The Rubrik REST API server initiates the asynchronous snapshot task and responds with a task object.  ```bash {   \"id\": \"$request_id\",   \"status\": \"ACQUIRING\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       \"rel\": \"self\"     }   ] } ``` Using the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the on-demand snapshot finished successfully.   ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\" ``` The Rubrik REST API server sends a task object with `status=\"SUCCEEDED\"`.  The task object for a successful snapshot includes the URI for the snapshot: `https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id`.  ```bash {   \"id\":\"$request_id\",   \"status\":\"SUCCEEDED\",   \"startTime\":\"$timestamp0\",   \"endTime\":\"$timestamp1\",   \"links\":[     {       \"href\":\"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\",       \"rel\":\"result\"     },    {       \"href\":\"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       \"rel\":\"self\"    }   ] } ```  ### Expiring individual snapshots  On-demand snapshots and snapshots for unprotected virtual machines can be expired by using the snapshot `id`. To expire an individual snapshot, send a DELETE request to [`/vmware/vm/snapshot/{id}`](#operation/deleteVmwareSnapshot). Include the query parameter `location` to specify whether to expire all copies of the snapshot, or only the local copy. Use `location=local` to expire only the copy of the snapshot on the specified Rubrik cluster. Use `location=all` to expire all copies of the snapshot, including replicas and archival copies.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id?location=$snapshot_location\" ``` The Rubrik REST API server expires the specified snapshot and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  The Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified snapshot is not one of the following: * On-demand snapshot * Snapshot for an unprotected virtual machine  ### Expiring all snapshots for a virtual machine  All snapshots for an unprotected virtual machine can be expired by using the virtual machine `id`. To expire all snapshots for an unprotected virtual machine, send a DELETE request to [`/vmware/vm/{id}/snapshot`](#operation/deleteVmwareSnapshots). The Rubrik cluster expires all snapshots, replicas, and archival snapshots for the specified virtual machine.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\" ``` The Rubrik REST API server expires all snapshots for the specified virtual machine in all locations and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  The Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified virtual machine is protected through an SLA Domain assignment.     ## Data recovery To recover a file or folder from a snapshot, retrieve the `id` of the file or folder using either search or browse. Then use the `id` with one of the recovery methods: * Download the file or folder * Restore the file or folder to the source location * Export the file or folder to another host  ### Searching for data in snapshots  Search for files and folders across all indexed snapshots of a virtual machine by using the virtual machine `id`. Send a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with the `path` query parameter. Use a path segment string or a name segment string for the value of `path`.  **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.  The Rubrik REST API server uses the rules described in the following table when matching the value of `path` with folders and files in the indexed snapshots. | Type | Rule | Description | | ---- | ---- | ----------- | | Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\\`, and `\\` matches both `/` and `\\`. | | Path segments | Path segments match all files and folders that begin with the same path segment. | For example, '/abc/x' matches files and folders at '/abc/' or '\\abc\\\\' with a filename or folder name that starts with 'x'. | | Name segments | Name segments match all files and folders that begin with the same name segment. | For example, 'xyz' matches files and folders with a filename or folder name that starts with 'xyz', in all path locations. | | Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `>` and the lesser than symbol `<` are not allowed. | | Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\\temp`. |  **Example:** Searching for files and folders  Search for all files and folders in '/usr/local/' with a name that starts with the later 'g'.  Send a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with `path=/usr/local/g`.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm/$vm_id/search?path=%2Fusr%2Flocal%2Fg\" ``` The Rubrik REST API server responds with a `ListResponse` object. The data array has two members, a directory at: `/usr/local/games` and a file at: `/usr/local/gamehints`.   ```bash {   \"hasMore\": false,   \"data\": [     {       \"path\": \"/usr/local/games\",       \"filename\": \"games\",       \"fileVersions\": [         {           \"lastModified\": \"$timestamp0\",           \"size\": 4096,           \"snapshotId\": \"$snapshot_id0\",           \"fileMode\": \"directory\",           \"source\": \"cloud\"         }       ]     },     {     \"path\": \"/usr/local/gamehints\",     \"filename\": \"gamehints\",     \"fileVersions\": [       {         \"lastModified\": \"$timestamp1\",         \"size\": 14480,         \"snapshotId\": \"$snapshot_id1\",         \"fileMode\": \"file\",         \"source\": \"cloud\"       },       {         \"lastModified\": \"$timestamp2\",         \"size\": 14480,         \"snapshotId\": \"$snapshot_id2\",         \"fileMode\": \"file\",         \"source\": \"cloud\"       }     ]    }   ],   \"total\": 2 } ```  ### Browsing for data in snapshots  Browse for files and folders with an indexed snapshot by using the snapshot `id`. Send a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with the `path` query parameter.  Use a path segment string for the value of `path`. The response provides a ListResponse object that includes all of the files and folders in the directory that is specified by the value of `path`.  **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.  The Rubrik REST API server uses the rules described in the following table when matching the value of `path` with the path in the specified snapshot. | Type | Rule | Description | | ---- | ---- | ----------- | | Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\\`, and `\\` matches both `/` and `\\`. | | Path description | The path description must end in a directory name, without an ending slash. | For example, '/abc/x' returns all files and folders in the directory at '/abc/x', but '/abc/x/' returns an HTTP 422 response. | | Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `>` and the lesser than symbol `<` are not allowed. | | Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\\temp`. |  **Example:** Browsing for files and folders  Retrieve a ListResponse object with all of the files and folders in '/home'.  Send a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with `path=/home`.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/browse?path=%2Fhome&offset=0\" ``` The Rubrik REST API server responds with a `ListResponse` object. The data array has two members, the directory: `ubuntu` and the file: `ubuntu.tar`.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"filename\": \"ubuntu\",       \"path\": \"ubuntu\",       \"lastModified\": \"$timestamp0\",       \"size\": 31892819777,       \"fileMode\": \"directory\",       \"statusMessage\": \"\"     },     {       \"filename\": \"ubuntu.tar\",       \"path\": \"ubuntu.tar\",       \"lastModified\": \"$timestamp1\",       \"size\": 4746675383,       \"fileMode\": \"file\",       \"statusMessage\": \"\"     }   ],   \"total\": 2 } ``` ### Downloading data from a snapshot  Data can be retrieved from a snapshot by creating a download link for an individual file and folder from the snapshot. To have the Rubrik cluster create a download link, send a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadFileJob). Include in the request body the string/value pair: `\"path\":\"$path\"`, where `$path` is the full path to the file or folder. When `$path` refers to a folder, the Rubrik cluster creates a ZIP file of the folder and all that it contains.  The basic download work flow is: 1. Send a POST request to start the asynchronous download task. 2. Send a GET request to poll the task status. 3. When the task succeeds, use the download link provided in the response body to retrieve the file or folder.  **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.  ```bash curl -X POST -d \\ '{    \"path\": \"$full_source_path\"  }' \\  'https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download_file' ``` The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$download_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Restoring data from a snapshot  To restore a file or folder to the source virtual machine send a POST request to [`/vmware/vm/snapshot/{id}/restore_file`](#operation/createRestoreFileJob). With the request, include a request body. The following table describes the members of the request body.  | Name | Description | | ---- | ----------- | | `path` | Full path of the file or folder. | | `domainName` | Authentication domain for the credentials being used to authenticate and authorize the action. | | `username` | Username of account to authenticate and authorize the action. | | `password` | Password for the account to authenticate and authorize the action. | | `restorePath` | Full path location for the restore of the file or folder. The action can create a directory at the end of the specified path, but cannot create directories that are specified within the path. | | `shouldUseAgent` | Instruct the Rubrik cluster to restore the file using Rubrik Backup Service running on virtual machine. Use `true` to restore using RBS and `false` to restore using `VMware tools`. | | `shouldSaveCredentials` | Instruct the Rubrik cluster to save the credentials included in the request. Use `true` to save the credentials and `false` to use the credentials only for the current request. | | `shouldRestoreXAttrs` | Instruct the Rubrik cluster to restore the extended attributes of all files and folders included in the `path`. When restoring to a Linux host, extended attributes are restored. When restoring to a Windows host, alternate data streams (ADS) are restored. Use `true` to restore this metadata and `false` otherwise. |  ```bash curl -X POST -d \\ '{    \"path\": \"$full_source_path\",    \"domainName\": \"$auth_domain\",    \"username\": \"$username\",    \"password\": \"$password\",    \"restorePath\": \"$full_restore_path\",    \"shouldUseAgent\" : true,    \"shouldSaveCredentials\": true,    \"shouldRestoreXAttrs\": true  }' \\  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/restore_file\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$restore_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```   ## Snapshot mount operations Snapshot mount operations include the following possible actions: * Retrieving a snapshot from an archival location * Mounting a snapshot by using Instant Recovery * Mounting a snapshot by using Live Mount * Mounting a snapshot for a batch of virtual machines using Live Mount * Exporting a snapshot * Downloading a snapshot from an archival location and then exporting it * Changing the properties of a mounted virtual machine * Removing a virtual machine mount * Migrating a datastore for a virtual machine from Live Mount or Instant Recovery  ### Retrieving a snapshot from an archival location  To work with a snapshot that is stored only at an archival location, first download the snapshot to the Rubrik cluster by sending a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadSnapshotFromCloud).  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download\" ``` The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$snap_download_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Mounting a snapshot by using Instant Recovery  Replace a source virtual machine from a snapshot by using the Instant Recovery feature. To use Instant Recovery, send a POST request to [`/vmware/vm/snapshot/{id}/instant_recover`](#operation/createInstantRecovery). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. | | `vmName` | Assigns a specified name to the virtual machine. | | `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |  ```bash curl -X POST -d \\   '{     \"vmName\": \"$vm_name\",     \"hostId\": \"$esxi_id\",     \"removeNetworkDevices\": true    }' \\    \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/instant_recover\" ``` The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$instant_recovery_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Mounting a snapshot by using Live Mount  Mount a new virtual machine from a snapshot by using the Live Mount feature. To use Live Mount, send a POST request to [`/vmware/vm/snapshot/{id}/mount`](#operation/createMountV1). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. | | `vmName` | Assigns a specified name to the virtual machine. | | `dataStoreName` | Obsolete paraemeter. | | `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. | | `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. | | `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. |   ```bash curl -X POST \\   -d '{      \"hostId\": \"$esxi_id\",      \"vmName\": \"$vm_name\",      \"dataStoreName\": \"$datastore_name\",      \"disableNetwork\": $network_state,      \"removeNetworkDevices\": $network_devices_state,      \"powerOn\": $power_state    }'\\     \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$live_mount_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Mounting a snapshot for a batch of virtual machines using Live Mount  Mount a snapshot each for a batch of virtual machines. Send a POST request to [`/vmware/vm/batch_mount`](#operation/batchMountSnapshot). This request requires a snapshots parameter to identify the virtual machine and the snapshot of the virtual machine to mount. The following parameters are available to identify the snapshot: `snapshotId`, `snapshotBeforeDate`, and `snapshotAfterDate`. One of the parameters must be configured to identify the snapshot to be mounted.  | Name | Required | Type | Description | | ---- | -------- | ---- | ----------- | | `vmId` | Required | String | The `id` of the virtual machine. | | `snapshotId` | Optional | String | The `id` of the snapshot to mount. | | `snapshotBeforeDate` | Optional | Date | If the snapshotId is not specified, mount the newest snapshot before the date specified for this parameter. | | `snapshotAfterDate` | Optional | Date | If the snapshotId and the snapshotBeforeDate are not specified, mount the oldest snapshot after the date specified for this parameter. | | `config` | Required | Object | [Properties of the /vmware/vm/snapshot/{id}/mount endpoint.](#mounting-a-snapshot-by-using-live-mount) |  ```bash curl -X POST \\   -d '{      \"snapshots\": [        {          \"vmId\": \"$vm_id\",          \"snapshotBeforeDate\": \"$timestamp\",          \"config\": {            \"hostId\": \"$esxi_id\",            \"vmName\": \"$vm_name\",            \"dataStoreName\": \"$datastore_name\",            \"disableNetwork\": $network_state,            \"removeNetworkDevices\": $network_devices_state,            \"powerOn\": $power_state          }        }      ]      }'\\       \"https://$cluster_address/api/v1/vmware/vm/batch_mount\" ```  The Rubrik REST API server initiates a batch of mount jobs and resonds with objects tracking the job status.  ```bash {   \"responses\": [     {       \"id\": \"$live_mount_task_id\",       \"status\": \"QUEUED\",       \"progress\": 0,       \"startTime\": \"$timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/vmware/request/$request_id\",           \"rel\": \"self\"         }       ]     }   ] } ``` ### Retrieving the ID of the mount  After a mount task successfully completes, the `id` of the mount object can be retrieved by sending a GET request to [`/vmware/vm/request/{id}`](#operation/getAsyncRequestStatus) and using the `$request_id` value from the original request object for the Live Mount.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\" ``` The Rubrik REST API server responds with a request object that includes the `id` of the mount object.  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\",       \"rel\": \"result\"     },     {       \"href\": \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"SUCCEEDED\" } ``` ### Retrieving active mounts  To retrieve a list of all of the active mounts for a Rubrik cluster, send a GET request to [`/vmware/vm/snapshot/mount`](#operation/queryMountV1).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount\" ``` The Rubrik REST API server responds with a ListResponse object.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$mount_id\",       \"snapshotDate\": \"$snapshot_timestamp\",       \"vmId\": \"$source_vm_id\",       \"mountedVmId\": \"$mounted_vm_id\",       \"hostId\": \"$esxi_id\",       \"isReady\": true     }   ],   \"total\": 1 } ``` ### Retrieving the details for a mount  To retrieve details about a specific mount, send a GET request to [`/vmware/vm/snapshot/mount/{id}`](#operation/getMountV1).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\" ``` The Rubrik REST API server responds with the details.  ```bash {   \"snapshotDate\": \"$timestamp\",   \"vmId\": \"$source_vm_id\",   \"isReady\": true,   \"hostId\": \"$esxi_id\",   \"id\": \"$mount_id\",   \"mountedVmId\": \"$mounted_vm_id\" } ```  ### Exporting a snapshot  To export a snapshot send a POST request to [`/vmware/vm/snapshot/{id}/export`](#operation/createExportV1). This request requires a snapshot `id` and the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | `datastoreId` | The `id` of a datastore for the specified ESXi hypervisor. | | `vmName` | Assigns a specified name to the virtual machine. | | `hostId` | The `id` of an ESXi hypervisor. | | `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. | | `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. | | `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. | | `unregisterVm` | Determines whether to add the exported virtual machine to the vCenter Server inventory. Use `true` to remove the exported virtual machine from the associated vCenter Server inventory. Use `false` to add the exported virtual machine to the associated vCenter Server inventory. |   ```bash curl -X  -d \\  '{    \"datastoreId\": \"string\",    \"vmName\": \"string\",    \"hostId\": \"string\",    \"disableNetwork\": true,    \"removeNetworkDevices\": true,    \"powerOn\": true,    \"unregisterVm\": true  }' \\  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/export\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$export_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Exporting a snapshot from an archival location  To export a snapshot from an archival location, send a POST request to [`/vmware/vm/snapshot/{id}/export_with_download`] (#operation/createExportWithDownloadFromCloudV1). This request requries a snapshot `id` and the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | `datastoreId` | `id` of a datastore for the specified ESXi hypervisor. | | `vmName` | Assigns a name to the virtual machine. | | `hostId` | `id` of an ESXi hypervisor. | | `disableNetwork` | Determines if the virtual machine has access to the                      network. `true` mounts the snapshot with network                      access disabled. `false` allows the virtual machine                      to access the network. | | `removeNetworkDevices` | Determines if the virtual machine includes network                            devices. `true` removes network devices from                            the virtual machine.`false` keeps the existing                            network devices. | | `powerOn` | Determines if the virtual machine is powered on after               mounting. `true` powers on the virtual machine. `false`               leaves the virtual machine powered off after mounting. | | `unregisterVm` | Determines if the exported virtual machine is added to                    the vCenter Server inventory. `true` removes the exported                    virtual machine from the associated vCenter Server                    inventory. `false` adds the exported virtual machine                    to the associated vCenter Server inventory. |  ```bash curl -X  -d \\  '{    \"datastoreId\": \"string\",    \"vmName\": \"string\",    \"hostId\": \"string\",    \"disableNetwork\": true,    \"removeNetworkDevices\": true,    \"powerOn\": true,    \"unregisterVm\": true  }' \\  \"https://$cluster_address/api/v1/vmware/vm/snapshot/$id/export_with_download\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$download_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\":          \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Changing power status of a mounted virtual machine  To change the power status of a mounted virtual machine send a PATCH request to [`/vmware/vm/snapshot/mount/{id}`](#operation/updateMount). Include in the request body, the member `\"powerStatus\": $power_state`. For `$power_state`, use `true` to power on the virtual machine, or use `false` to power off the virtual machine.  ```bash curl -X PATCH \\   -d '{     \"powerStatus\": $power_state }' \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\" ```  The Rubrik REST API server responds with the mount details.  ```bash {   \"powerStatus\": \"$power_state\",   \"id\": \"$mount_id\",   \"snapshotDate\": \"$timestamp\",   \"vmId\": \"$vm_id\",   \"mountedVmId\": \"$mounted_vm_id\",   \"hostId\": \"$esxi_id\",   \"isReady\": true,   \"mountRequestId\": \"$mount_request_id\",   \"unmountRequestId\": \"$unmount_request_id\" } ```  ### Removing a virtual machine mount  To remove a Live Mount send a DELETE request to [`/vmware/vm/snapshot/mount/{id}`](#operation/createUnmount). To remove a mount object after live migration of the virtual machine include the query parameter `force=true`.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\" ``` The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$delete_mount_task_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Get recoverable ranges for a CDP-enabled virtual machine  For a list of time ranges to which a CDP-enabled virtual machine can recover, send a GET request to [`/vmware/vm/{id}/recoverable_range`](#operation/getVmwareRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch. Any point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/$vm_id/recoverable_range ```  ```bash {   \"data\": [     \"beginTime\": \"2018-01-01T12:34:56.789Z\",     \"endTime\": \"2018-01-01T12:34:56.789Z\"   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Get missed recoverable ranges for a CDP-enabled virtual machine  For a list of time ranges to which a CDP-enabled virtual machine cannot recover to, send a GET request to [`/vmware/vm/{id}/missed_recoverable_range`](#operation/getVmwareMissedRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch. Any point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/$vm_id/missed_recoverable_range ```  ```bash {   \"data\": [     \"beginTime\": \"2018-01-01T12:34:56.789Z\",     \"endTime\": \"2018-01-01T12:34:56.789Z\"   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Migrating a datastore for a virtual machine from Live Mount or Instant Recovery  Send a POST request to [`/vmware/vm/snapshot/mount/{id}/relocate`](#operation/relocateMount) to migrate a datastore for a virtual machine created from Live Mount or Instant Recovery.   ### Get compute cluster information  VMware compute cluster can be found by a GET on [`/vmware/compute_cluster`](#operation/queryComputeCluster).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster\" ```  ```bash {   \"data\": [     {       \"id\": \"compute_cluster_id\",       \"name\": \"compute_cluster_name\",       \"configuredSlaDomainId\": \"configured_sla_domain_id\",       \"configuredSlaDomainName\": \"configured_sla_domain_name\",       \"primaryClusterId\": \"primary_cluster_id\",       \"datacenterId\": \"datacenter_id\",       \"effectiveSlaDomainId\": \"effective_sla_domain_id\",       \"effectiveSlaDomainName\": \"effective_sla_domain_name\",       \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",       \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  Further details are acquired from GET [`/vmware/compute_cluster/{id}`](#operation/getComputeCluster).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\" ```  ```bash {   \"id\": \"compute_cluster_id\",   \"name\": \"compute_cluster_name\",   \"configuredSlaDomainId\": \"configured_sla_domain_id\",   \"configuredSlaDomainName\": \"configured_sla_domain_name\",   \"primaryClusterId\": \"primary_cluster_id\",   \"datacenterId\": \"datacenter_id\",   \"effectiveSlaDomainId\": \"effective_sla_domain_id\",   \"effectiveSlaDomainName\": \"effective_sla_domain_name\",   \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",   \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"   \"moid\": \"compute_cluster_moid\",   \"hosts\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"configuredSlaDomainId\": \"string\",       \"configuredSlaDomainName\": \"string\",       \"primaryClusterId\": \"string\",       \"datacenterId\": \"string\",       \"computeClusterId\": \"string\",       \"datastores\": [         {           \"id\": \"string\",           \"name\": \"string\",           \"capacity\": 0,           \"dataStoreType\": \"string\",           \"dataCenterName\": \"string\",           \"isLocal\": true          }       ],       \"effectiveSlaDomainId\": \"string\",       \"effectiveSlaDomainName\": \"string\",       \"effectiveSlaSourceObjectId\": \"string\",       \"effectiveSlaSourceObjectName\": \"string\"     }   ], \"virtualMachines\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"configuredSlaDomainId\": \"string\",       \"configuredSlaDomainName\": \"string\",       \"primaryClusterId\": \"string\",       \"slaAssignment\": \"Derived\",       \"effectiveSlaDomainId\": \"string\",       \"effectiveSlaDomainName\": \"string\",       \"effectiveSlaSourceObjectId\": \"string\",       \"effectiveSlaSourceObjectName\": \"string\",       \"moid\": \"string\",       \"vcenterId\": \"string\",       \"hostName\": \"string\",       \"hostId\": \"string\",       \"clusterName\": \"string\",       \"snapshotConsistencyMandate\": \"UNKNOWN\",       \"powerStatus\": \"string\",       \"protectionDate\": \"2018-10-02T20:33:03.833Z\",       \"ipAddress\": \"string\",       \"agentStatus\": {         \"agentStatus\": \"string\",         \"disconnectReason\": \"string\"       },       \"toolsInstalled\": true,       \"isReplicationEnabled\": true,       \"folderPath\": [         {           \"id\": \"string\",           \"managedId\": \"string\",           \"name\": \"string\"         }       ],       \"infraPath\": [         {           \"id\": \"string\",           \"managedId\": \"string\",           \"name\": \"string\"         }       ],       \"vmwareToolsInstalled\": true,       \"isRelic\": true,       \"guestCredentialAuthorizationStatus\": \"string\",       \"cloudInstantiationSpec\": {         \"imageRetentionInSeconds\": 0       },       \"parentAppInfo\": {         \"id\": \"string\",         \"isProtectedThruHierarchy\": true       }     }   ] } ```  configuredSlaDomainId could be updated by a PATCH [`/vmware/compute_cluster/{id}`](#operation/updateComputeCluster).  ```bash curl -X PATCH \\   -d '{     \"sla_assignable\": $sla_domain }' \\   \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\" ```  ```bash {   \"id\": \"compute_cluster_id\",   \"name\": \"compute_cluster_name\",   \"configuredSlaDomainId\": \"configured_sla_domain_id\",   \"configuredSlaDomainName\": \"configured_sla_domain_name\",   \"primaryClusterId\": \"primary_cluster_id\",   \"datacenterId\": \"datacenter_id\",   \"effectiveSlaDomainId\": \"effective_sla_domain_id\",   \"effectiveSlaDomainName\": \"effective_sla_domain_name\",   \"effectiveSlaSourceObjectId\": \"effective_sla_source_object_id\",   \"effectiveSlaSourceObjectName\": \"effective_sla_source_object_name\"   \"moid\": \"compute_cluster_moid\",   \"hosts\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"configuredSlaDomainId\": \"string\",       \"configuredSlaDomainName\": \"string\",       \"primaryClusterId\": \"string\",       \"datacenterId\": \"string\",       \"computeClusterId\": \"string\",       \"datastores\": [         {           \"id\": \"string\",           \"name\": \"string\",           \"capacity\": 0,           \"dataStoreType\": \"string\",           \"dataCenterName\": \"string\",           \"isLocal\": true          }       ],       \"effectiveSlaDomainId\": \"string\",       \"effectiveSlaDomainName\": \"string\",       \"effectiveSlaSourceObjectId\": \"string\",       \"effectiveSlaSourceObjectName\": \"string\"     }   ], \"virtualMachines\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"configuredSlaDomainId\": \"string\",       \"configuredSlaDomainName\": \"string\",       \"primaryClusterId\": \"string\",       \"slaAssignment\": \"Derived\",       \"effectiveSlaDomainId\": \"string\",       \"effectiveSlaDomainName\": \"string\",       \"effectiveSlaSourceObjectId\": \"string\",       \"effectiveSlaSourceObjectName\": \"string\",       \"moid\": \"string\",       \"vcenterId\": \"string\",       \"hostName\": \"string\",       \"hostId\": \"string\",       \"clusterName\": \"string\",       \"snapshotConsistencyMandate\": \"UNKNOWN\",       \"powerStatus\": \"string\",       \"protectionDate\": \"2018-10-02T20:33:03.833Z\",       \"ipAddress\": \"string\",       \"agentStatus\": {         \"agentStatus\": \"string\",         \"disconnectReason\": \"string\"       },       \"toolsInstalled\": true,       \"isReplicationEnabled\": true,       \"folderPath\": [         {           \"id\": \"string\",           \"managedId\": \"string\",           \"name\": \"string\"         }       ],       \"infraPath\": [         {           \"id\": \"string\",           \"managedId\": \"string\",           \"name\": \"string\"         }       ],       \"vmwareToolsInstalled\": true,       \"isRelic\": true,       \"guestCredentialAuthorizationStatus\": \"string\",       \"cloudInstantiationSpec\": {         \"imageRetentionInSeconds\": 0       },       \"parentAppInfo\": {         \"id\": \"string\",         \"isProtectedThruHierarchy\": true       }     }   ] } ```  ### Query asynchronous job status for VMware compute cluster  To query the job status details of an asynchronous job that is related to an VMware compute cluster with a GET to [`/vmware/compute_cluster/request/{id}`](#operation/getAsyncRequestStatusForComputeCluster).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/request/$job_id\" ```  ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2018-10-02T20:33:03.933Z\",   \"endTime\": \"2018-10-02T20:33:03.933Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  ### VMware IO filters operations  All IO filters on a specific VMware compute cluster can be found with a GET on [`/vmware/compute_cluster/{id}/io_filter`](#operation/getIoFilters).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/io_filter\" ```  ```bash {   \"data\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"version\": \"string\",       \"vendor\": \"string\",       \"releaseDate\": \"string\",       \"summary\": \"string\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  Install the latest version of Rubrik IO filter to a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/install_io_filter`](#operation/installIoFilter).  ```bash curl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/install_io_filter\" ```  ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2018-10-02T20:33:03.933Z\",   \"endTime\": \"2018-10-02T20:33:03.933Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  Uninstall the Rubrik IO filter from a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/uninstall_io_filter`](#operation/uninstallIoFilter).  ```bash curl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/uninstall_io_filter\" ```  ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2018-10-02T20:33:03.933Z\",   \"endTime\": \"2018-10-02T20:33:03.933Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  Update the Rubrik IO filter to the latest version for a specific VMware compute cluster with a POST on [`/vmware/compute_cluster/{id}/upgrade_io_filter`](#operation/upgradeIoFilter).  ```bash curl -X POST \"https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/upgrade_io_filter\" ```  ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2018-10-02T20:33:03.933Z\",   \"endTime\": \"2018-10-02T20:33:03.933Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  ### Getting Live CDP fields for a batch of CDP-enabled virtual machines  Send a POST request to [`/vmware/vm/cdp`](#operation/getVmwareCdpLiveInfo). The request takes a list of virtual machine IDs that correspond to CDP-enabled virtual machines as a mandatory parameter named 'ids'.  ```bash curl -X POST \\   -d '{      \"ids\": [\"id_1\", \"id_2\"]      }'\\       \"https://$cluster_address/api/v1/vmware/vm/cdp\" ```  The Rubrik REST API server responds with a `ListResponse` object.  ```bash {   \"hasMore\": false,   \"data\": [     {     \"vmId\": \"id_1\",     \"localRecoveryPoint\": \"2018-01-01T12:34:56.789Z\",     \"remoteRecoveryPoint\": \"2018-01-01T12:34:56.789Z\"     },     {     \"vmId\": \"id_2\",     \"localRecoveryPoint\": \"\",     \"remoteRecoveryPoint\": \"\"     }   ]   \"total\": 2 } ``` ### Getting CDP State fields for a batch of CDP-enabled virtual machines  Send a POST request to [`/vmware/vm/cdp_state`](#operation/getVmwareCdpStateInfo). The request takes a list of virtual machine IDs that correspond to CDP-enabled virtual machines as a mandatory parameter named 'ids'.  ```bash curl -X POST \\   -d '{      \"ids\": [\"id_1\", \"id_2\"]      }'\\       \"https://$cluster_address/api/v1/vmware/vm/cdp_state\" ```  The Rubrik REST API server responds with a `ListResponse` object.  ```bash {   \"hasMore\": false,   \"data\": [     {     \"vmId\": \"id_1\",     \"localStatus\": \"Active\",     \"replicationStatus\": \"Healthy\",     \"healthPercentage\": \"85%\"     },     {     \"vmId\": \"id_2\",     \"localStatus\": \"Active\",     \"replicationStatus\": \"Healthy\",     \"healthPercentage\": \"100%\"     }   ]   \"total\": 2 } ```  ### Getting recoverable ranges for a batch of CDP-enabled virtual machines  To get the recoverable time ranges for a batch of CDP-enabled virtual machines, send a POST request to [`/vmware/vm/recoverable_range`] (#operation/getVmwareVmRecoverableRangesInBatch). The request takes a list of virtual machine IDs, and optionally a \"before_time\" and \"after_time\" as a filter of the time range. The returned recoverable range timestamps are specified as milliseconds from epoch.  ```bash curl -X POST \\   -d '{      \"vmIds\": [\"vmId_1\", \"vmId_2\"]      }'\\       \"https://$cluster_address/api/v1/vmware/vm/recoverable_range\" ```  The Rubrik REST API server responds with a `BatchVmwareVmRecoverableRanges` object.  ```bash {   \"responses\":   [     {       \"vmId\": \"vmId_1\",       \"recoverableRanges\":       [         {           \"beginTime\": \"2018-01-01T12:34:56.789Z\",           \"endTime\": \"2018-01-01T12:38:56.789Z\"         }       ]     },     {       \"vmId\": \"vmId_2\",       \"recoverableRanges\":       [         {           \"beginTime\": \"2018-01-01T12:34:57.789Z\",           \"endTime\": \"2018-01-01T12:38:57.789Z\"         }       ]     }   ] } ```  ### Getting missed recoverable ranges for a batch of CDP-enabled ### virtual machines  To get the missed recoverable time ranges for a batch of CDP-enabled virtual machines, send a POST request to [`/vmware/vm/missed_recoverable_range`] (#operation/getVmwareVmMissedRecoverableRangesInBatch). The request takes a list of virtual machine IDs, and optionally a \"before_time\" and \"after_time\" as a filter of the time range. The returned missed recoverable range timestamps are specified as milliseconds from epoch. If no filters being specified, the missed recoverable range will be calculated based on the retention window, i.e. from retention time to the current time  ```bash curl -X POST \\   -d '{      \"vmIds\": [\"vmId_1\", \"vmId_2\"]      }'\\       \"https://$cluster_address/api/v1/vmware/vm/missed_recoverable_range\" ```  The Rubrik REST API server responds with a `BatchVmwareVmMissedRecoverableRanges` object.  ```bash {   \"responses\":   [     {       \"vmId\": \"vmId_1\",       \"missedRecoverableRanges\":       [         {           \"beginTime\": \"2018-01-01T12:34:56.789Z\",           \"endTime\": \"2018-01-01T12:38:56.789Z\"         }       ]     },     {       \"vmId\": \"vmId_2\",       \"missedRecoverableRanges\":       [         {           \"beginTime\": \"2018-01-01T12:34:57.789Z\",           \"endTime\": \"2018-01-01T12:38:57.789Z\"         }       ]     }   ] } ```  ## Get VMware Hierarchy Objects Send a GET request to [`/vmware/hierarchy/export`](#operation/getVmwareHierarchyExport). The request takes an optional root ID for the hierarchy. This endpoint is used to retrieve the set of objects that are valid recovery targets during a VMware Virtual Machine Export operations. This is limited to VMware Clusters, Hosts, and Resource Pools. The available options for the root ID are None (return top level objects), Clusters (return child Hosts and Resource Pools), Standalone Hosts (return child Resource Pools), or Resource Pools (return child Resource Pools).  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/hierarchy/export\" ```  The Rubrik REST API server responds with a `ListResponse` object. ```bash {   \"hasMore\": true,     \"data\": [       {         \"id\": \"string\",         \"name\": \"string\",         \"objectType\": \"string\",         \"location\": \"string\",         \"hasChildren\": true,         \"datastores\": [         ...         ],         \"recoverableTo\": true,       },     ] } ```  ## Get VMware Hierarchy Object Send a GET request to [`/vmware/hierarchy/{id}/export`](#operation/getVmwareHierarchyObject). The request takes an ID for the hierarchy object. This endpoint is used to retrieve the VMware Hierarchy object that are valid recovery targets during a VMware Virtual Machine Export operations. This is limited to VMware Clusters, Hosts, and Resource Pools. The available options for the ID are Compute Cluster ID , Standalone Hosts ID, or Resource Pools ID.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/hierarchy/{id}/export\" ```  The Rubrik REST API server responds with a `VmwareHierarchyInfo` object. ```bash {   \"responses\":   {    \"id\": \"string\",     \"name\": \"string\",     \"objectType\": \"string\",     \"location\": \"string\",     \"hasChildren\": true,     \"datastores\": [     ...     ],     \"recoverableTo\": true,   } } ```  ## Get VMware User-Configured Network List Send a GET request to [`/vmware/vcenter/{id}/networks`](#operation/getNetworks). The request takes an ID for the vCenter server for which to retrieve the user-configured networks and returns the networks' names and IDs.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vcenter/{id}/networks\" ```  The Rubrik REST API server responds with a `NetworkInfo` object. ```bash {   \"hasMore\": false,   \"data\": [     {     \"id\": \"network_id\",     \"name\": \"network_name\"     }   ]   \"total\": 1 } ```  ## Set Network for HotAdd Backups and Recoveries Send a POST request to [`/vmware/vcenter/{id}/hotadd/network`](#operation/setHotAddNetwork). The request takes an ID for the vCenter server and a user-configured network ID. It can also optionally take the information about static IP configuration. This static IP configuration requires the IP address range and the subnet mask, optionally taking in a gateway and list of DNS servers.  ```bash curl -X POST \\ -d '{   \"hotadd_network_info\": {     \"network_id\":\"string\",     \"static_ip_info\": {       \"ip_addresses\":[\"list\", \"of\", \"ips\"],       \"subnet_mask\":\"string\",       \"gateway\":\"string\",       \"dns_servers\":[\"list\", \"of\", \"dns\", \"servers\"]     }   } }' \\  \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/network\" ```  The Rubrik REST API server responds with an HTTP 204 response when the network is set up properly.  ## Get Network Information for HotAdd Backups and Recoveries Send a GET request to [`/vmware/vcenter/{id}/hotadd/network`](#operation/getHotAddNetwork). The request takes an ID for the vCenter server.  ```bash curl -x GET \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/network\" ```  The Rubrik REST API server responds with a `HotAddNetworkConfigWithName` object. ```bash {   \"networkName\": \"$networkName\",   \"staticIpConfig\": {     \"ip_addresses\": [\"list\", \"of\", \"ips\"],     \"subnet_mask\": \"$subnet_mask\",     \"gateway\": \"$gateway\",     \"dns_servers\": [\"list\", \"of\", \"dns\", \"servers\"]   } } ```  ## Bulk creating on-demand snapshots On-demand snapshots can be created for both protected and unprotected virtual machines. To create an on-demand snapshot of a set of virtual machines, send a POST request to [`/vmware/vm/snapshot/bulk`](#operation/bulkCreateOnDemandBackup).  ```bash curl -X POST \\   -d '{      \"vms\": [        {          \"vmId\": \"$vm_id\"        }      ],      }'\\       \"https://$cluster_address/api/v1/vmware/vm/snapshot/bulk\" ```  The Rubrik REST API server initiates the asynchronous snapshot tasks and responds with objects tracking the job status. ```bash {   \"responses\": [     {       \"id\": \"$request_id\",       \"status\": \"QUEUED\",       \"progress\": 0,       \"startTime\": \"$timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/vmware/vm/snapshot/bulk\",           \"rel\": \"self\"         }       ]     }   ] } ```  ## Get VMware HotAdd proxy virtual machine list To retrieve the list of VMware HotAdd proxy virtual machines, send a GET request to the [`/vmware/vcenter/hotadd/vm`](#operation/queryHotAddProxyVm) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vcenter/hotadd/vm\" ```  The Rubrik REST API server responds with a `ListResponse` object. ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"vcenterName\": \"string\",       \"computeClusterName\": \"string\",       \"hostName\": \"string\",       \"datastoreName\": \"string\",       \"networkInfo\": {         \"networkName\":\"string\",         \"staticIpConfig\": {           \"ip_addresses\":[\"list\", \"of\", \"ips\"],           \"subnet_mask\":\"string\",           \"gateway\":\"string\",           \"dns_server\":\"string\"         }       },       \"status\": \"OK\",       \"UsedPortCount\": 0,     },   ] } ```  ## Get Number of HotAdd Proxies Needed for Vcenter Send a GET request to [`/vmware/vcenter/{id}/hotadd/needed`](#operation/getNumProxiesNeeded). The request takes an ID for the vCenter server for which to return the number of HotAdd proxies needed.  ```bash curl -X GET \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/needed\" ```  The Rubrik cluster returns the number of proxies needed. ```bash {   \"needed\": 7 } ```  ## Get Ingest and Export Bandwidth Limits Using HotAdd for Vcenter. Send a GET request to [`/vmware/vcenter/{id}/hotadd/bandwidth`](#operation/getHotAddBandwidth). The request takes the vCenter server ID and returns the ingest and export bandwidth limits for that vCenter, when using HotAdd.  ```bash curl -X GET \\ \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/bandwidth\" ```  The Rubrik cluster returns the bandwidth limits in Mbps. ```bash {   \"ingestLimit\": 7,   \"exportLimit\": 7 } ```  ## Set Ingest and Export Bandwidth Limits Using HotAdd for Vcenter. Send a POST request to [`/vmware/vcenter/{id}/hotadd/bandwidth`](#operation/setHotAddBandwidth). The request takes an ID for the vCenter server and the bandwidth limits to update. Setting a bandwidth limit to 0 clears the limit in that direction.  ```bash curl -X POST \\ -d '{   \"hot_add_bandwidth_info\": {     \"ingestLimit\": 0,     \"exportLimit\": 0   } }' \\ \"https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/bandwidth\" ```  The Rubrik REST API server responds with an HTTP 204 response when the bandwidth limits are set properly.  ### Get preferred CDP network protocol  To retrieve the currently preferred network protocol (IPv4 or IPv6) used for CDP data transfer, send a GET request to [`/vmware/config/cdp/get_preferred_cdp_network_protocol`](#operation/getPreferredCdpNetworkProtocol).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/config/cdp/get_preferred_cdp_network_protocol\" ```  The Rubrik REST API server responds with the preferred CDP network protocol.  ```bash {   \"preferredCdpNetworkProtocol\": \"IPv4\" } ```  The configuration of VMware ESX subnets take priority over this setting. When a valid IPv6 ESX subnet is defined, CDP uses IPv6 for data transfer even when the preferred protocol is IPv4.  ### Set preferred CDP network protocol  Set the preferred network protocol (IPv4 or IPv6) used for CDP data transfer by sending a PATCH request to [`/vmware/config/cdp/set_preferred_cdp_network_protocol`](#operation/setPreferredCdpNetworkProtocol).  ```bash curl -X PATCH \\   \"https://$cluster_address/api/v1/vmware/config/cdp/set_preferred_cdp_network_protocol\" ```  The Rubrik REST API server responds with the updated preferred CDP network protocol.  ```bash {   \"preferredCdpNetworkProtocol\": \"IPv4\" } ```  ## Migrate cluster associated with Rubrik Backup Service  See the [host section](#section/Hosts/Migrate-cluster-associated-with-Rubrik-Backup-Service) for more details. To migrate the primary cluster for the Rubrik Backup Service on a virtual machine, send a POST request to [`/vmware/vm/make_primary`](#operation/vmMakePrimary).  ```bash curl -X POST \\   -d '{     \"ids\": [       \"$vm_id1\",       ...     ] }' \\   \"https://$cluster_address/api/v1/vmware/vm/make_primary\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$request_id\",   \"status\": \"RUNNING\",   \"error\": \"None\",   \"progress\": \"$request_progress\"   \"links\": [     {       href: \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       rel: \"self\"     }   ] } ```  ### Get VMware Networks for virtual machine recovery  To get all the available VMware networks for the specified compute resource, send a GET request to [`/vmware/config/recovery/networks`](#operation/getVmwareRecoveryNetworks).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vmware/config/recovery/networks\" ```  The Rubrik REST API server returns a collection of all the available recovery networks `VmwareNetworkInfo` for the compute resource specified by the `compute_resource_id` parameter.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"computeResourceId\": string,       \"computeResourceType\": string,     },   ],   \"total\": 1, } ```  # Legal Hold  ### Get summary of snapshots which are placed under legal hold Send a GET request to [`/legal_hold/snapshot`](#operation/queryLegalHold).  ```bash curl -X GET \"https://$cluster_address/api/v1/legal_hold/snapshot\" ```  ```bash {   \"data\": [     {       \"objectId\": \"$object_id\",       \"objectName\": \"$object_name\",       \"objectType\": \"$object_type\",       \"snapshotId\": \"$snapshot_id\",       \"snapshotTime\": \"2019-11-12T10:35:12.784Z\",       \"placeOnHoldTime\": \"2019-11-13T11:11:06.456Z\",       \"locationsPresent\": [         \"$location1_id\",         \"$location2_id\"       ],       \"isOnDemandSnapshot\": true     }   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Place a snapshot on legal hold To place a snapshot under legal hold, send a POST request to [`/legal_hold/snapshot`](#operation/applyLegalHold).  ```bash curl -X POST \\   -d '{ \"snapshotId\": \"$snapshot_id\", \"holdConfig\": {\"isHoldInPlace\": true} }' \\    \"https://$cluster_address/api/v1/legal_hold/snapshot\" ```  The rubrik REST API server responds with the legal hold summary object if request succeeds.  ```bash {   \"objectId\": \"$object_id\",   \"objectName\": \"$object_name\",   \"objectType\": \"$object_type\",   \"snapshotId\": \"$snapshot_id\",   \"snapshotTime\": \"2019-11-12T10:35:12.784Z\",   \"placeOnHoldTime\": \"2019-11-13T11:11:06.456Z\",   \"locationsPresent\": [     \"$location1_id\",     \"$location2_id\"   ],   \"isOnDemandSnapshot\": true } ```  ### Get objects which are part of legal hold Send a GET request to [`/legal_hold/object`](#operation/getLegalHoldObjects) to retrieve a list of objects with snapshots that are under a legal hold.  ```bash curl -X GET \"https://$cluster_address/api/v1/legal_hold/object\" ```  ```bash {   \"data\": [     {       \"objectId\": \"$object_id\",       \"objectName\": \"$object_name\",       \"objectType\": \"$object_type\",       \"numberOfSnapshotsHeld\": 1     }   ],   \"hasMore\": false,   \"total\": 1 } ```  To return a list of the snapshots for a specific object that are under legal hold, send a GET request to [`/legal_hold/snapshot`](#operation/queryLegalHold) with the ID of the object in the object_id parameter.  ```bash curl -X GET \"https://$cluster_address/api/v1/legal_hold/snapshot?object_id=$object_id\" ```  ```bash {   \"data\": [     {       \"objectId\": \"$object_id\",       \"objectName\": \"$object_name\",       \"objectType\": \"$object_type\",       \"snapshotId\": \"$snapshot_id\",       \"snapshotTime\": \"2019-11-12T10:35:12.784Z\",       \"placeOnHoldTime\": \"2019-11-13T11:11:06.456Z\",       \"locationsPresent\": \"\",       \"isOnDemandSnapshot\": true     }   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Dissolve legal hold To remove a legal hold from a collection of object snapshots, send a POST request to [`/legal_hold/object/{id}/dissolve`](#operation/dissolveLegalHoldSnapshots).  ```bash curl -X POST \\   -d '{ \"snapshotIds\": [\"$snapshot_id\"] }' \\   \"https://$cluster_address/api/v1/legal_hold/object/$object_id/dissolve\" ```  The Rubrik REST API server responds with the list of snapshots on which legal hold has been dissolved.  ```bash {   \"dissolvedSnapshotIds\": [     \"$snapshot_id\"   ] } ```  # Cloud Utilization  Rubrik clusters can utilize the cloud for storage and compute for snapshot archival and data consolidation on archival locations.  ## Forecasting cloud utilization  To forecast the cloud utilization according to specified SLA domain parameters, send a POST request to: [`/cloud_utilization/cloud_out_forecast`](#operation/doCloudOutForecast).  **Example:** Forecasting cloud utilization  ```bash curl -X POST -d '{   \"cloudOutForecastRequest\": {     \"slaParameters\": {       \"frequencies\": {         \"monthly\": {           \"frequency\": 1,           \"retention\": 12         },         \"yearly\": {           \"frequency\": 1,           \"retention\": 2         }       },       \"archivalSpecs\": {         \"locationId\": \"75892476-c158-45fb-8ea9-365c634da294\",         \"archivalThreshold\": 1       }     },     \"consolidationFilter\": \"ForecastWithConsolidation\",     \"granularity\": Year,     \"forecastPeriodInGranularityUnit\": 3   } }' \"https://$cluster_address/api/v1/cloud_utilization/cloud_out_forecast\" ```  The response gives the forecast result summary.  ```bash {   \"assumptions\": {     \"logicalDataSizeInGB\": 1000.0,     \"annualGrowthRateInPercent\": 7.0,     \"compressionFactor\": 2.5,     \"frequencyChangeRates\": {       \"monthlyChangeRateInPercent\": 10.0,       \"yearlyChangeRateInPercent\": 30.0     }   },   \"locationForecast\": {     \"locationName\": \"S3:s3-location-name\",     \"locationType\": \"S3\",     \"locationRegion\": \"us-west-2\",     \"instanceType\": \"m5.2xlarge\",     \"storageForecast\": {       \"forecastWithConsolidation\": {         \"storageUsedInGB\": [1000, 1100, 1105],         \"storageCostInUSD\": [276, 304, 305],         \"dataRetrievalCostInUSD\": [0, 0, 0],         \"perStorageClassForecast\": [           {             \"storageClass\": \"STANDARD\",             \"storageUsedInGB\": [900, 1150, 1450],             \"storageCostInUSD\": [176, 304, 376]           }         ]       }     },     \"computeForecast\": {       \"forecastWithConsolidation\": {         \"computeDurationInHrs\": [0, 11, 12],         \"computeCostInUSD\": [0, 8, 9]       }     }   } } ```  # User-defined tag  Rubrik CDM clusters can manage user-defined tags attached to the compute resources created by CloudOn and CloudOut.  Resource tags are associated with a cloud archival location, such as AWS or Azure. Rubrik CDM allows a maximum of 10 resource tags for each archival location. Check with the cloud provider for additional restrictions on resource tags.  If a compute resource supports tagging during creation by the cloud provider, user-defined resource tags are attached at resource creation time. Otherwise, user-defined resource tags are attached to the compute resource after creation.  * Compute Instances: Bolt, Converter, Transient instances, Converted Instances * Disks/Snapshots: EBS Volumes/Snapshots, Managed Disks/Snapshot * Images: AMIs, Images  ## Query existing user-defined tags on a CDM cluster  To query existing user-defined tags on a CDM cluster, send a GET request to the [`/user_defined_tag`](#operation/queryUserDefinedTag) endpoint.  **Example:** Query existing user-defined tags on a CDM cluster  ```bash curl -X GET \"https://$cluster_address/api/v1/user_defined_tag\" ```  ```json {         \"resourceTags\": [{                 \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",                 \"key\": \"department\",                 \"value\": \"engineering\",                 \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",                 \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\"         }] } ```  ## Create a new user-defined tag on a CDM cluster  To create a new user-defined tag on a CDM cluster, send a POST request to the [`/user_defined_tag`](#operation/createUserDefinedTag) endpoint.  **Example:** Create a new user-defined tags on a CDM cluster  ```bash curl -X POST \\   -d '{           \"key\": \"department\",           \"value\": \"engineering\",           \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\"     }' \\   \"https://$cluster_address/api/v1/user_defined_tag\" ```  ```json {         \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",         \"key\": \"department\",         \"value\": \"engineering\",         \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",         \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\" } ```  ## Delete existing user-defined tags on a CDM cluster  To delete existing user-defined tags on a CDM cluster, send a DELETE request to the [`/user_defined_tag`](#operation/deleteUserDefinedTagBulk) endpoint.  **Example:** Delete existing user-defined tags on a CDM cluster  ```bash curl -X DELETE \"https://$cluster_address/api/v1/user_defined_tag?ids=$id\" ```  ```json {         \"ids\": [\"38400000-8cf0-11bd-b23e-10b96e4ef00d\"] } ```  ## Get information about a user-defined tag on a CDM cluster  To fetch an existing user-defined tag on a CDM cluster, send a GET request to the [`/user_defined_tag/{id}`](#operation/getUserDefinedTag) endpoint.  **Example:** To fetch an existing user-defined tag on a CDM cluster  ```bash curl -X GET \"https://$cluster_address/api/v1/user_defined_tag/$id\" ```  ```json {         \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",         \"key\": \"department\",         \"value\": \"engineering\",         \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",         \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\" } ```  ## Update information about an existing user-defined tag on a CDM cluster  To update an existing user-defined tag on a CDM cluster, send a PATCH request to the [`/user_defined_tag/{id}`](#operation/updateUserDefinedTag) endpoint.  **Example:** To update an existing user-defined tag on a CDM cluster  ```bash curl -X PATCH \\  -d '{\"value\": \"engineering\"}' \\  \"https://$cluster_address/api/v1/user_defined_tag/$id\" ``` ```json {         \"id\": \"38400000-8cf0-11bd-b23e-10b96e4ef00d\",         \"key\": \"department\",         \"value\": \"engineering\",         \"lastUpdateTime\": \"2021-01-31T11:54:24 UTC\",         \"scopeRefId\": \"a0ef0663-7a7c-4027-9972-061780e52fee\" } ```  ## Delete a existing user-defined tag on a CDM cluster  To delete an existing user-defined tag on a CDM cluster, send a DELETE request to the [`/user_defined_tag/{id}`](#operation/deleteUserDefinedTag) endpoint.  **Example:** To delete an existing user-defined tag on a CDM cluster  ```bash curl -X DELETE \"https://$cluster_address/api/v1/user_defined_tag/$id\" ```    # Hosts  Rubrik clusters can protect file system data and application data through direct interaction with a host operating system. This method of protection does not require a virtual environment API. Instead, the Rubrik cluster works with the Rubrik Backup Service software that is running on supported Linux hosts and Windows hosts.  In some situations, the Rubrik cluster can directly interact with hosts without the Rubrik Backup Service, for example when providing protection of data on a network share.  ## Rubrik Backup Service  The Rubrik Backup Service software must be installed on a host to enable file system level protection and direct protection of supported applications. The Rubrik Backup Service software is signed by a specific Rubrik cluster and can only be used with that Rubrik cluster.  The following URLs provide access to the Rubrik Backup Service software on a Rubrik cluster: * Linux: https://$cluster_address/connector/rubrik-agent.x86_64.rpm * Windows: https://$cluster_address/connector/RubrikBackupService.zip  **IMPORTANT:** The Rubrik User Guide describes how to install the Rubrik Backup Service software, and lists the permissions and settings that are required to allow the Rubrik Backup Service to provide support for specific operating systems, applications, and clusters.  ## Registering a host After installing the Rubrik Backup Service on a host, register the host with the Rubrik cluster. Registering initiates secure communication between the Rubrik cluster and the Rubrik Backup Service on the host. After a host is registered, the Rubrik Backup Service on the host sends detailed information about the host to the Rubrik cluster.  The Rubrik Backup Service scans a registered host for protectable objects, such as: applications, databases, and Windows clusters. The Rubrik Backup Service sends the results of the scan to the Rubrik cluster.  To register a host, send a POST request to [`/host`](#operation/registerHost) and include `hostname: $hostname`. The `$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.  ```bash curl -X POST \\   -d '{     \"hostname\": \"$hostname\" }' \\   \"https://$cluster_address/api/v1/host\" ```  To register the host and discover protection points of the host in the background, send a POST request to [`/host/background`](#operation/registerHostAsync) and include `hostname: $hostname`. The`$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.  ```bash curl -X POST \\   -d '{     \"hostname\": \"$hostname\" }' \\   \"https://$cluster_address/api/v1/host/background\" ``` The Rubrik REST API server responds with the details for the host, including the connection status.  ```bash {   \"id\": \"$host_id\",   \"name\": \"$hostname\",   \"hostname\": \"$hostname\", (deprecated)   \"primaryClusterId\": \"$cluster_id\",   \"agentId\": \"$agent_id\",   \"operatingSystem\": \"$os_version\",   \"operatingSystemType\": \"$os_type\",   \"status\": \"Connected\",   \"compressionEnabled\": false } ```  To register bulk hosts in the background, send a POST request to [`/host/bulk_background`](#operation/bulkRegisterHostAsync) and include `hostname: $hostname`. The`$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.  ``` curl -X POST \\   -d '{     [{\"hostname\": \"$hostname1\"}, {\"hostname\": \"$hostname2\"}] }' \\   \"https://$cluster_address/api/v1/host/bulk_background\" ```  The `status` field in the response is returned as `Refreshing` until the host has finished discovering all the mssql instances, oracle DBs, etc. After this step, status is returned as `Connected` and all discovery is done for the host  For background hosts, the connection status is returned as `Refreshing` until the host is fully registered. After this step, that status is returned as `Connected` and all discovery is done for the host  ## Retrieving host information  To retrieve a current list of the hosts that are registered with a Rubrik cluster, send a GET request to [`/host`](#operation/queryHost).  ```bash curl -X GET \"https://$cluster_address/api/v1/host\" ```  The Rubrik REST API server responds with a ListResponse object that contains the first page of the current list.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$host_id0\",       \"name\": \"$hostname0\",       \"hostname\": \"$hostname0\", (deprecated)       \"primaryClusterId\": \"$cluster_id\",       \"operatingSystem\": \"$os_version0\",       \"operatingSystemType\": \"$os_type0\",       \"status\": \"Connected\"     },     {       \"id\": \"$host_id1\",       \"name\": \"$hostname1\",       \"hostname\": \"$hostname1\", (deprecated)       \"primaryClusterId\": \"$cluster_id\",       \"operatingSystem\": \"$os_version1\",       \"operatingSystemType\": \"$os_type1\",       \"status\": \"Connected\"     }   ],   \"total\": 2 } ``` Depending on the number of registered hosts, the complete list of registered hosts may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.   To retrieve the details for a specified host, send a GET request to [`/host/{id}`](#operation/getHost).  Adding a host will cause Rubrik to communicate with the remote Rubrik agent and get detailed information about the host.  ```bash curl -X GET \"https://$cluster_address/api/v1/host/$host_id0\" ``` The Rubrik REST API server responds with the details of the specified host.  ```bash   {     \"id\": \"$host_id0\",     \"name\": \"$hostname0\",     \"hostname\": \"$hostname0\", (deprecated)     \"primaryClusterId\": \"$cluster_id\",     \"agentId\": \"$agent_id\",     \"operatingSystem\": \"$os_version0\",     \"operatingSystemType\": \"$os_type0\",     \"status\": \"Connected\",     \"compressionEnabled\": false   } ```  ## Adding a host without the Rubrik Backup Service  A host without the Rubrik Backup Service can be added by setting the `hasAgent` flag to `false`. This can be used to register a host that will be accessed through network shares.  ```bash curl -X POST \\   -d '{ \\     \"hostname\": \"$hostname\",     \"hasAgent\": \"false\" }' \\   \"https://$cluster_address/api/v1/host\" ```  ## Modifying a registered host  To change the FQDN or IPv4 address that the Rubrik cluster uses to connect with a registered host, send a PATCH request to [`/host`](#operation/updateHost). Use the value of `hostname` to specify the new FQDN or IPv4 address of the host. Optionally, also use this PATCH request to specify whether to compress the data that is transmitted to and from the host. Set the value of `compressionEnabled` to `true` to enable compression or set the value to `false` to turn compression off.   ```bash curl -X POST \\   -d '{     \"hostname\": \"$hostname\",     \"compressionEnabled\": true }' \\   \"https://$cluster_address/api/v1/host/$host_id\" ```  The Rubrik REST API server responds with a confirmation of the new details of the registered host.  ```bash  {   \"id\": \"$host_id\",   \"name\": \"$hostname\",   \"hostname\": \"$hostname\", (deprecated)   \"primaryClusterId\": \"$cluster_id\",   \"agentId\": \"$agent_id\",   \"operatingSystem\": \"$os_version\",   \"operatingSystemType\": \"$os_type\",   \"status\": \"Connected\",   \"compressionEnabled\": true  } ``` ## Removing a host  Remove a host from the Rubrik cluster when the host no longer requires protection. The Rubrik cluster moves all of the unexpired backups for the host filesets of the host to Unmanaged Objects.  To remove a host send a DELETE request to [`/host/{id}`](#operation/deleteHost).  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/host/$host_id\" ```  The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  ## Refreshing a Host  Refresh a host when changes made on the host do not appear in the Rubrik web UI. The refresh requests updated information from the Rubrik Backup Service that is running on the host.  To refresh a host send a POST request to [`/host/{id}/refresh`](#operation/refreshHost)  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/host/$host_id/refresh\" ```  The Rubrik REST API server responds with HTTP response code 200 and includes the updated properties of the host object in the response body.  ## Updating a Host Certificate  When a host has a new certificate that is not registered with Rubrik the Rubrik cluster will not communicate with that host until the certificate is updated. In order to do that send a PUT request to [`/host/certificate/{id}`](#operation/updateCertificateHost)  ```bash curl -X PUT \\   \"https://$cluster_address/api/v1/host/certificate/$host_id\" ```  The Rubrik REST API server responds with the details of the specified host.  ## Migrate cluster associated with Rubrik Backup Service  Hosts can register with multiple clusters but can only communicate or back up to a single cluster. Such a cluster is the primary cluster for that host. See the Multicluster Rubrik Backup Service section of the Rubrik CDM User Guide for details. To change the primary cluster to the current cluster, for Rubrik Backup Service on a host, send a POST request to [`/host/make_primary`](#operation/hostMakePrimary).  ```bash curl -X POST \\   -d '{     \"ids\": [       \"$host_id1\",       ...     ] }' \\   \"https://$cluster_address/api/v1/host/make_primary\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  ```bash {   \"id\": \"$request_id\",   \"status\": \"RUNNING\",   \"error\": \"None\",   \"progress\": \"$request_progress\"   \"links\": [     {       href: \"https://$cluster_address/api/v1/vmware/vm/request/$request_id\",       rel: \"self\"     }   ] } ```  To migrate the Rubrik Backup Service on a virtual machine, see the [corresponding virtual machine API](#section/Virtual-machines/Migrate-cluster-associated-with-Rubrik-Backup-Service).  Alternatively, in a disaster recovery scenario, when migrating the primary cluster for all hosts *and* virtual machines from an old cluster to this one, send a POST request to [`/host/make_primary`](#operation/hostMakePrimary) with oldPrimaryClusterUuid specified. Note that the hosts and virtual machines must already have been registered on this cluster.  ```bash curl -X POST \\   -d '{     \"oldPrimaryClusterUuid\": \"12345678-90ab-cdef-1234-567890abcdef\" }' \\   \"https://$cluster_address/api/v1/host/make_primary\" ```  ## Windows Server Failover Clustering nodes  To begin working with Windows Server Failover Clustering (WSFC) clusters, register each WSFC node with the Rubrik cluster as described in [`Registering a host`](#section/Hosts/Registering-a-host). The scan performed by the Rubrik Backup Service on each WSFC node detects the WSFC cluster and provides information about the WSFC cluster to the Rubrik cluster.  To view WSFC cluster information, send a GET request to [`/windows_cluster`](#operation/queryWindowsCluster).  **Note:** The variable `$cluster_address` refers to the FQDN or IPv4 address of the Rubrik cluster.  ```bash curl -X GET \"https://$cluster_address/api/v1/windows_cluster\" ``` The Rubrik REST API server responds with a ListResponse object that contains the first page of the list of WSFC clusters.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$wsfc_id\",       \"name\": \"$wsfc_name\",       \"fqdn\": \"$wsfc_fqdn\",       \"hostIds\": [         \"$wsfc_node_id0\",         \"$wsfc_node_id1\"       ],       \"primaryClusterId\": \"$cluster_id\"     }   ],   \"total\": 1 } ```  To retrieve detailed information about a WSFC cluster, send a GET request to: [`/windows_cluster/{id}`](#operation/getWindowsCluster), where `$cluster_id` is the `id` of the WSFC cluster.   ```bash curl -X GET \"https://$cluster_address/api/v1/windows_cluster/$cluster_id\" ```  The Rubrik REST API server responds with the details for the specified WSFC cluster.  ```bash {   \"name\": \"$wsfc_name\",   \"id\": \"$wsfc_id\",   \"naturalId\": \"$cluster_natural_id\",   \"hostIds\": [   \"$wsfc_node_id0\",   \"$wsfc_node_id1\"   ],   \"fqdn\": \"$wsfc_fqdn\",   \"primaryClusterId\": \"$cluster_id\" } ```  ## Bulk Update Host Shares  To update a list of Host shares in bulk, send a PATCH request to the [`/host/share/bulk`](#operation/bulkUpdateHostShare) endpoint with a bulk_update_properties to complete an update.  ```bash curl -X PATCH \\   -d '[     {       \"shareId\": \"$share_id\",       \"updateProperties\": {         \"exportPoint\": \"$export_point\",         \"username\": \"$username\",         \"password\": \"$password\",         \"domain\": \"$domain\",         \"hostShareParameters\": {           \"isNetAppSnapDiffEnabled\": true,           \"isIsilonChangelistEnabled\": true         }       }     }   ]' \\   \"https://$cluster_address/api/v1/host/share/bulk\" ```  The Rubrik REST API server responds with the details of the updated Host shares.  ## Discover shares on NAS host  To retrieve a current list of shares (NFS/SMB) on a specific NAS host, send a GET request to [`/host/{id}/nas_share_discover`](#operation/discoverNasShares)  ```bash curl -X GET \"https://$cluster_address/api/v1/host/{id}/nas_share_discover\" ```  The Rubrik REST API server responds with a List object that contains all discovered shares on the NAS host.  ```bash {   [     {       \"shareType\": \"NFS\",       \"exportPoint\": \"/ifs/data/dir1\",     },     {       \"shareType\": \"SMB\",       \"exportPoint\": \"ifs_data\",     }   ] } ```  ## Bulk add NAS shares  To add NAS shares in bulk without validating their share credentials, send a POST request to [`/host/share/bulk`](#operation/bulkAddHostShares)  ```bash curl -X POST \\   -d '{ \\     [ \\       { \\         \"shareType\": \"$share_type\", \\         \"exportPoint\": \"$export_point\" \\       },       { \\         \"shareType\": \"$share_type\", \\         \"exportPoint\": \"$export_point\" \\       }, \\     ] \\   }' \\   \"https://$cluster_address/api/v1/host/share/bulk\" ```  The Rubrik REST API server responds with details of added shares.  ## Getting a list of volumes on a Volume Group host  To retrieve a list of all volumes on a Volume Group host, send a GET request to [`/host/{id}/volume`](#operation/queryHostVolume)  ```bash curl -X GET \"https://$cluster_address/api/v1/host/{id}/volume\" ```  The Rubrik REST API server responds with summary information for each volume on the specified Volume Group host.  ``` {   \"hasMore\": true,   \"data\": [     {       \"id\": \"string\",       \"fileSystemType\": \"NTFS\",       \"mountPoints\": [         \"string\"       ],       \"size\": 0,       \"naturalId\": \"string\",       \"volumeGroupId\": \"string\",       \"isCurrentlyPresentOnSystem\": true     }   ],   \"total\": 0 } ```  ## Remote RBS management The Rubrik Backup Service (RBS) management endpoints provide the capability to install/uninstall/upgrade RBS on remote hosts.  ### Retrieving the Rubrik Backup Service host information  To get the Rubrik Backup Service host information, send a GET request to [`/host/rbs`](#operation/getRbsHostInfo).  ```bash curl -X GET \\   -d '{     \"name\": \"$hostname\",     \"username\": \"$username\",     \"password\": \"$password\",     \"operationTimeout\": 600 }' \\   \"https://$cluster_address/api/v1/host/rbs\" ```   The Rubrik REST API server responds with summary information for Rubrik Backup Service host.  ``` {   \"name\": \"$hostname\",   \"agentId\": \"$rbsAgentId\",   \"agentVersion\": \"$rbsVersion\",   \"osInfo\": \"$osInfo\",   \"osType\": \"$osType\",   \"status\": \"Installed\" } ```  ### Installing Rubrik Backup Service on a host  To install Rubrik Backup Service on a host, send a POST request to [`/host/rbs/install`](#operation/rbsInstall).  Install Rubrik Backup Service on a host with operationMode as Synchronous. ```bash curl -X POST \\   -d '{     \"name\": \"$hostname\",     \"username\": \"$username\",     \"password\": \"$password\",     \"operationTimeout\": 600,     \"operationMode\": Synchronous }' \\   \"https://$cluster_address/api/v1/host/rbs/install\" ```  The Rubrik REST API server responds with the summary of Rubrik Backup Service on the host. ```bash {   \"rbsHostSummary\": {     \"name\": \"$hostname\",     \"agentId\": \"$rbsAgentId\",     \"agentVersion\": \"$rbsVersion\",     \"osInfo\": \"$osInfo\",     \"osType\": \"$osType\",     \"status\": \"Installed\"   } } ```  Install Rubrik Backup Service on a host with operationMode as Asynchronous. ```bash curl -X POST \\   -d '{     \"name\": \"$hostname\",     \"username\": \"$username\",     \"password\": \"$password\",     \"operationTimeout\": 600,     \"operationMode\": Asynchronous }' \\   \"https://$cluster_address/api/v1/host/rbs/install\" ```  The Rubrik REST API server initiates the asynchronous task and responds with a task object.  ```bash {   \"asyncRequestStatus\": {     \"id\": \"$id\",     \"status\": \"$status\",     \"progress\": 0,     \"startTime\": \"2021-03-24T23:27:41.493Z\",     \"endTime\": \"2021-03-24T23:27:41.493Z\",     \"nodeId\": \"$nodeId\",     \"error\": {       \"message\": \"$message\"     },     \"links\": [       {         \"href\": \"$href\",         \"rel\": \"$rel\"       }     ]   } } ```  ### Uninstalling Rubrik Backup Service from a host  To uninstall Rubrik Backup Service from a host, send a POST request to [`/host/rbs/uninstall`](#operation/rbsUninstall).  Uninstall Rubrik Backup Service from a host with operationMode as Synchronous. ```bash curl -X POST \\   -d '{     \"name\": \"$hostname\",     \"username\": \"$username\",     \"password\": \"$password\",     \"operationTimeout\": 600,     \"operationMode\": Synchronous }' \\   \"https://$cluster_address/api/v1/host/rbs/uninstall\" ```  The Rubrik REST API server responds with the summary of Rubrik Backup Service on the host. ```bash {   \"rbsHostSummary\": {     \"name\": \"$hostname\",     \"status\": \"NotInstalled\"   } } ```  Uninstall Rubrik Backup Service from a host with operationMode as Asynchronous. ```bash curl -X POST \\   -d '{     \"name\": \"$hostname\",     \"username\": \"$username\",     \"password\": \"$password\",     \"operationTimeout\": 600,     \"operationMode\": Asynchronous }' \\   \"https://$cluster_address/api/v1/host/rbs/uninstall\" ```  The Rubrik REST API server initiates the asynchronous task and responds with a task object. ```bash {   \"asyncRequestStatus\": {     \"id\": \"$id\",     \"status\": \"$status\",     \"progress\": 0,     \"startTime\": \"2021-03-24T23:27:41.493Z\",     \"endTime\": \"2021-03-24T23:27:41.493Z\",     \"nodeId\": \"$nodeId\",     \"error\": {       \"message\": \"$message\"     },     \"links\": [       {         \"href\": \"$href\",         \"rel\": \"$rel\"       }     ]   } }  ### Upgrading Rubrik Backup Service on a host  To upgrade Rubrik Backup Service on a host, send a POST request to [`/host/rbs/upgrade`](#operation/rbsUpgrade).  Upgrade Rubrik Backup Service on a host with operationMode as Synchronous. ```bash curl -X POST \\   -d '{     \"name\": \"$hostname\",     \"username\": \"$username\",     \"password\": \"$password\",     \"operationTimeout\": 600,     \"operationMode\": Synchronous }' \\   \"https://$cluster_address/api/v1/host/rbs/upgrade\" ```  The Rubrik REST API server responds with the summary of Rubrik Backup Service on the host. ```bash {   \"rbsHostSummary\": {     \"name\": \"$hostname\",     \"agentId\": \"$rbsAgentId\",     \"agentVersion\": \"$rbsVersion\",     \"osInfo\": \"$osInfo\",     \"osType\": \"$osType\",     \"status\": \"Installed\"   } } ```  Upgrade Rubrik Backup Service on a host with operationMode as Asynchronous. ```bash curl -X POST \\   -d '{     \"name\": \"$hostname\",     \"username\": \"$username\",     \"password\": \"$password\",     \"operationTimeout\": 600,     \"operationMode\": Asynchronous }' \\   \"https://$cluster_address/api/v1/host/rbs/upgrade\" ```  The Rubrik REST API server initiates the asynchronous task and responds with a task object.  ```bash {   \"asyncRequestStatus\": {     \"id\": \"$id\",     \"status\": \"$status\",     \"progress\": 0,     \"startTime\": \"2021-03-24T23:27:41.493Z\",     \"endTime\": \"2021-03-24T23:27:41.493Z\",     \"nodeId\": \"$nodeId\",     \"error\": {       \"message\": \"$message\"     },     \"links\": [       {         \"href\": \"$href\",         \"rel\": \"$rel\"       }     ]   } } ```  # Failover cluster  This REST API is used to manage failover cluster objects of UnixLike hosts.  ### Add a new failover cluster Add a new failover cluster by making a POST call to [/failover_cluster](#operation/createFailoverCluster).  ```bash curl -X POST \\   -d '{     \"name\": \"$name\",     \"hostIds\": [ \"$hostId\" ],     \"configuredSlaDomainId\": \"$configuredSlaDomainId\"}'\\   \"https://$cluster_address/api/v1/failover_cluster\" ```  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"2020-04-20T17:30:30.743Z\",   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"nodes\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"connectionStatus\": \"Connected\",       \"operatingSystem\": \"$operatingSystem\"     }   ],   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"Derived\",   \"operatingSystemType\": \"$operatingSystemType\",   \"numNodes\": $numNodes,   \"numApps\": 0 }  ```  ### Get all failover clusters Get a listing of all failover clusters using a GET request to [/failover_cluster](#operation/queryFailoverCluster).  ```bash curl -X GET \"https://$cluster_address/api/v1/failover_cluster?sort_order=asc\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",       \"nodes\": [         {           \"id\": \"$id\",           \"name\": \"$name\",           \"connectionStatus\": \"Connected\",           \"operatingSystem\": \"$operatingSystem\"         },         {           \"id\": \"$id\",           \"name\": \"$name\",           \"connectionStatus\": \"Connected\",           \"operatingSystem\": \"$operatingSystem\"         }       ],       \"connectionStatus\": \"Connected\",       \"slaAssignment\": \"$slaAssignment\",       \"operatingSystemType\": \"$operatingSystemType\"     }   ],   \"total\": 1 } ```  ### Get information about a specific failover cluster Get information about a specific failover cluster using a GET request to [/failover_cluster/{id}](#operation/getFailoverCluster).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id\" ```  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": false,   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": false,   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"nodes\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"connectionStatus\": \"Connected\",       \"operatingSystem\": \"$operatingSystem\"     },     {       \"id\": \"$id\",       \"name\": \"$name\",       \"connectionStatus\": \"Connected\",       \"operatingSystem\": \"$operatingSystem\"     }   ],   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"$slaAssignment\",   \"operatingSystemType\": \"$operatingSystemType\",   \"numNodes\": $numNodes,   \"numApps\": $numApps } ```  ### Update the parameters of an existing failover cluster The parameters associated with the failover cluster can be updated by making a PATCH request to [/failover_cluster/{id}](#operation/updateFailoverCluster)  ```bash curl -X PATCH \\   -d '{     \"name\": \"$name\",     \"hostIds\": [ \"$hostId\" ],     \"configuredSlaDomainId\": \"$configuredSlaDomainId\"}'\\   \"https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id\" ```  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"2020-04-20T18:26:56.893Z\",   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"nodes\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"connectionStatus\": \"Connected\",       \"operatingSystem\": \"$operatingSystem\"     }   ],   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"Derived\",   \"operatingSystemType\": \"$operatingSystemType\",   \"numNodes\": $numNodes,   \"numApps\": $numApps } ```  ### Delete a specific failover cluster Any failover cluster can be removed by issuing a DELETE request to [/failover_cluster/{id}](#operation/deleteFailoverCluster).  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id?preserve_snapshots=false\" ```  ### Bulk delete a failover cluster A list of failover clusters can be removed by issuing a DELETE request to [/failover_cluster/bulk](#operation/bulkDeleteFailoverCluster).  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/failover_cluster/bulk?ids=$failover_cluster_id1,$failover_cluster_id2&preserve_snapshots=false\" ```  # Failover cluster App  Use this REST API to manage failover cluster app objects.  ### Add a new failover cluster app Add a new failover cluster app by making a POST call to [/failover_cluster/failover_cluster_app](#operation/createFailoverClusterApp).  Use either the virtualIps or nodeOrders options in the failoverClusterAppSource request parameter to create a failover cluster app.  ```bash curl -X POST \\   -d '{     \"name\": \"$name\",     \"failoverClusterType\": \"Windows\",     \"failoverClusterId\": \"$failoverClusterId\",     \"failoverClusterAppSource\": {       \"virtualIps\": [         \"$virtualIp\"       ],       \"nodeOrders\": [         {           \"nodeId\": \"$nodeId\",           \"nodeName\": \"$nodeName\",           \"order\": 0         }       ]     },     \"configuredSlaDomainId\": \"string\"}'\\   \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app\" ```  Response when a failover cluster app is created using the virtualIps option in the failoverClusterAppSource request parameter.  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"2020-04-21T17:32:44.266Z\",   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"failoverClusterType\": \"Windows\",   \"failoverClusterId\": \"$failoverClusterId\",   \"failoverClusterAppSource\": {     \"virtualIps\": [       \"$virtualIp\"     ]   },   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"Derived\",   \"operatingSystemType\": \"$operatingSystemType\",   \"failoverClusterName\": \"$failoverClusterName\" } ```  Response when a failover cluster app is created using the nodeOrders option in the failoverClusterAppSource request parameter.  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"2020-04-21T17:32:44.266Z\",   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"failoverClusterType\": \"Windows\",   \"failoverClusterId\": \"$failoverClusterId\",   \"failoverClusterAppSource\": {     \"nodeOrders\": [       {         \"nodeId\": \"$nodeId\",         \"nodeName\": \"$nodeName\",         \"order\": 0       }     ]   },   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"Derived\",   \"operatingSystemType\": \"$operatingSystemType\",   \"failoverClusterName\": \"$failoverClusterName\" } ```  ### Get all failover cluster apps Get a listing of all failover cluster apps using a GET request to [/failover_cluster/failover_cluster_app](#operation/queryFailoverClusterApp).  ```bash curl -X GET \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app?sort_order=asc\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",       \"failoverClusterType\": \"UnixLike\",       \"failoverClusterId\": \"$failoverClusterId\",       \"failoverClusterAppSource\": {         \"virtualIps\": [           \"$virtualIp\"         ]       },       \"connectionStatus\": \"Connected\",       \"slaAssignment\": \"$slaAssignment\",       \"operatingSystemType\": \"Linux\",       \"failoverClusterName\": \"$failoverClusterName\"     }   ],   \"total\": 1 } ```   ### Get information about a specific failover cluster app Get information about a specific failover cluster app using a GET request to [/failover_cluster/failover_cluster_app/{id}](#operation/getFailoverClusterApp).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id\" ```  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"2020-04-21T18:00:46.694Z\",   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"failoverClusterType\": \"Windows\",   \"failoverClusterId\": \"$failoverClusterId\",   \"failoverClusterAppSource\": {     \"virtualIps\": [       \"$virtualIp\"     ],   },   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"Derived\",   \"operatingSystemType\": \"$operatingSystemType\",   \"failoverClusterName\": \"$failoverClusterName\",   \"filesets\": [     {       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"forceFull\": true,       \"forceFullPartitionIds\": [         0       ],       \"allowBackupNetworkMounts\": true,       \"allowBackupHiddenFoldersInNetworkMounts\": true,       \"useWindowsVss\": true,       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": true,       \"slaLastUpdateTime\": \"2020-04-21T18:00:46.694Z\",       \"hostName\": \"$hostName\",       \"templateId\": \"$templateId\",       \"templateName\": \"$templateName\",       \"operatingSystemType\": \"$operatingSystemType\",       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"isEffectiveSlaDomainRetentionLocked\": true,       \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",       \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",       \"includes\": [         \"$includes\"       ],       \"excludes\": [         \"$excludes\"       ],       \"exceptions\": [         \"$exceptions\"       ],       \"isRelic\": true,       \"isPassthrough\": true,       \"enableSymlinkResolution\": true,       \"enableHardlinkSupport\": true,       \"failoverClusterAppId\": \"$failoverClusterAppId\",       \"failoverClusterAppName\": \"$failoverClusterAppName\",       \"pendingSlaDomain\": {         \"objectId\": \"$objectId\",         \"pendingSlaDomainId\": \"$pendingSlaDomainId\",         \"pendingSlaDomainName\": \"$pendingSlaDomainName\",         \"isPendingSlaDomainRetentionLocked\": true       },       \"protectionDate\": \"2020-04-21T18:00:46.694Z\",       \"snapshotCount\": 0,       \"archivedSnapshotCount\": 0,       \"snapshots\": [         {           \"id\": \"$id\",           \"date\": \"2020-04-21T18:00:46.694Z\",           \"expirationDate\": \"2020-04-21T18:00:46.694Z\",           \"sourceObjectType\": \"$sourceObjectType\",           \"isOnDemandSnapshot\": true,           \"isCustomRetentionApplied\": true,           \"cloudState\": 0,           \"consistencyLevel\": \"$consistencyLevel\",           \"indexState\": 0,           \"replicationLocationIds\": [             \"$replicationLocationIds\"           ],           \"archivalLocationIds\": [             \"$archivalLocationIds\"           ],           \"slaId\": \"$slaId\",           \"slaName\": \"$slaName\",           \"isRetainedByRetentionLockSla\": true,           \"cloudStorageTier\": \"Hot\",           \"isPlacedOnLegalHold\": true,           \"snapshotRetentionInfo\": {             \"localInfo\": {               \"id\": \"$id\",               \"name\": \"$name\",               \"isSnapshotPresent\": true,               \"isExpirationDateCalculated\": true,               \"expirationTime\": \"2020-04-21T18:00:46.694Z\",               \"snapshotFrequency\": \"$snapshotFrequency\",               \"isExpirationInformationUnavailable\": true             },             \"archivalInfos\": [               {                 \"id\": \"$id\",                 \"name\": \"$name\",                 \"isSnapshotPresent\": true,                 \"isExpirationDateCalculated\": true,                 \"expirationTime\": \"2020-04-21T18:00:46.694Z\",                 \"snapshotFrequency\": \"$snapshotFrequency\",                 \"isExpirationInformationUnavailable\": true               }             ],             \"replicationInfos\": [               {                 \"id\": \"$id\",                 \"name\": \"$name\",                 \"isSnapshotPresent\": true,                 \"isExpirationDateCalculated\": true,                 \"expirationTime\": \"2020-04-21T18:00:46.694Z\",                 \"snapshotFrequency\": \"$snapshotFrequency\",                 \"isExpirationInformationUnavailable\": true               }             ],             \"cloudNativeLocationInfo\": [               {                 \"id\": \"$id\",                 \"name\": \"$name\",                 \"isSnapshotPresent\": true,                 \"isExpirationDateCalculated\": true,                 \"expirationTime\": \"2020-04-21T18:00:46.694Z\",                 \"snapshotFrequency\": \"$snapshotFrequency\",                 \"isExpirationInformationUnavailable\": true               }             ]           },           \"filesetName\": \"$filesetName\",           \"fileCount\": 0,           \"snapdiffUsed\": true         }       ],       \"localStorage\": 0,       \"archiveStorage\": 0,       \"preBackupScript\": \"$preBackupScript\",       \"postBackupScript\": \"$postBackupScript\",       \"backupScriptTimeout\": 0,       \"backupScriptErrorHandling\": \"$backupScriptErrorHandling\"     }   ] } ```  ### Update the parameters of an existing failover cluster app The parameters associated with the failover cluster app can be updated by making a PATCH request to [/failover_cluster/failover_cluster_app/{id}](#operation/updateFailoverClusterApp)  Use either the virtualIps or nodeOrders options in the failoverClusterAppSource request parameter to update a failover cluster app.  ```bash curl -X PATCH \\   -d '{     \"name\": \"$name\",     \"failoverClusterType\": \"Windows\",     \"failoverClusterId\": \"$failoverClusterId\",     \"failoverClusterAppSource\": {       \"virtualIps\": [         \"$virtualIp\"       ],       \"nodeOrders\": [         {           \"nodeId\": \"$nodeId\",           \"nodeName\": \"$nodeName\",           \"order\": 0         }       ]     },     \"configuredSlaDomainId\": \"string\"}'\\   \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id\" ```  Response when a failover cluster app is updated using the virtualIps option in the failoverClusterAppSource request parameter.  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"2020-04-21T18:24:20.126Z\",   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"failoverClusterType\": \"Windows\",   \"failoverClusterId\": \"$failoverClusterId\",   \"failoverClusterAppSource\": {     \"virtualIps\": [       \"$virtualIp\"     ],   },   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"Derived\",   \"operatingSystemType\": \"$operatingSystemType\",   \"failoverClusterName\": \"$failoverClusterName\" } ```  Response when a failover cluster app is updated using the nodeOrders option in the failoverClusterAppSource request parameter.  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"2020-04-21T18:24:20.126Z\",   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"failoverClusterType\": \"Windows\",   \"failoverClusterId\": \"$failoverClusterId\",   \"failoverClusterAppSource\": {     \"nodeOrders\": [       {         \"nodeId\": \"$nodeId\",         \"nodeName\": \"$nodeName\",         \"order\": 0       }     ]   },   \"connectionStatus\": \"Connected\",   \"slaAssignment\": \"Derived\",   \"operatingSystemType\": \"$operatingSystemType\",   \"failoverClusterName\": \"$failoverClusterName\" } ```  ### Delete a specific failover cluster app Remove any failover cluster app by issuing a DELETE request to [/failover_cluster/failover_cluster_app/{id}](#operation/deleteFailoverClusterApp).  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id?preserve_snapshots=false\" ```  ### Bulk delete a failover cluster apps Specify a list of failover cluster applications to remove by issuing a DELETE request to [/failover_cluster/failover_cluster_app//bulk](#operation/bulkDeleteFailoverClusterApp).  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/bulk?ids=$failover_cluster_app_id1,$failover_cluster_app_id2&preserve_snapshots=false\" ```  # Failover cluster hierarchy  This REST API is used to get failover cluster hierarchy objects.  ### Get summary of a hierarchy object Get a summary of a hierarchy object by making a GET call to [/failover_cluster/hierarchy/{id}](#operation/getFailoverClusterHierarchyObject).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_app_id\" ```  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": false,   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": false,   \"effectiveSlaSourceObjectId\": \"Global:::All\",   \"objectType\": \"FailoverClusterApp\",   \"descendentCount\": {     \"failoverCluster\": 0,     \"failoverClusterApp\": 0,     \"fileset\": 1   },   \"isDeleted\": false,   \"numNodes\": 0,   \"failoverClusterType\": \"UnixLike\",   \"failoverClusterAppConnectionStatus\": \"Connected\",   \"failoverClusterAppName\": \"$failoverClusterAppName\",   \"failoverClusterAppSource\": {     \"virtualIps\": [       \"$virtualIp\"     ]   },   \"slaAssignment\": \"$slaAssignment\",   \"filesets\": [     {       \"allowBackupNetworkMounts\": false,       \"allowBackupHiddenFoldersInNetworkMounts\": false,       \"useWindowsVss\": false,       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"hostName\": \"$hostName\",       \"templateId\": \"$templateId\",       \"templateName\": \"$templateName\",       \"operatingSystemType\": \"UnixLike\",       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"includes\": [         \"$includes\"       ],       \"excludes\": [],       \"exceptions\": [],       \"isRelic\": false,       \"isPassthrough\": false,       \"enableSymlinkResolution\": false,       \"enableHardlinkSupport\": false,       \"failoverClusterAppId\": \"$failoverClusterAppId\",       \"failoverClusterAppName\": \"$failoverClusterAppName\"     }   ] } ```  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id\" ```  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": false,   \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",   \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",   \"isEffectiveSlaDomainRetentionLocked\": false,   \"effectiveSlaSourceObjectId\": \"Global:::All\",   \"objectType\": \"HostFailoverCluster\",   \"descendentCount\": {     \"failoverCluster\": 0,     \"failoverClusterApp\": 1,     \"fileset\": 1   },   \"isDeleted\": false,   \"numNodes\": 2,   \"nodes\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"connectionStatus\": \"Connected\",       \"operatingSystem\": \"$operatingSystem\"     },     {       \"id\": \"$id\",       \"name\": \"$name\",       \"connectionStatus\": \"Connected\",       \"operatingSystem\": \"$operatingSystem\"     }   ],   \"failoverClusterConnectionStatus\": \"Connected\",   \"failoverClusterName\": \"$failoverClusterName\",   \"numFailoverClusterApps\": 1,   \"slaAssignment\": \"$slaAssignment\",   \"operatingSystemType\": \"$operatingSystemType\" } ```  ### Get list of immediate descendant objects Get a list of immediate descendant objects using a GET request to [/failover_cluster/hierarchy/{id}/children](#operation/getFailoverClusterHierarchyChildren).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/failover_cluster/hierarchy/root/children\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"effectiveSlaSourceObjectId\": \"Global:::All\",       \"objectType\": \"HostFailoverCluster\",       \"descendentCount\": {         \"failoverCluster\": 0,         \"failoverClusterApp\": 1,         \"fileset\": 1       },       \"isDeleted\": false,       \"numNodes\": 2,       \"nodes\": [         {           \"id\": \"$id\",           \"name\": \"$name\",           \"connectionStatus\": \"Connected\",           \"operatingSystem\": \"$operatingSystem\"         },         {           \"id\": \"$id\",           \"name\": \"$name\",           \"connectionStatus\": \"Connected\",           \"operatingSystem\": \"$operatingSystem\"         }       ],       \"failoverClusterConnectionStatus\": \"Connected\",       \"failoverClusterName\": \"$failoverClusterName\",       \"numFailoverClusterApps\": $numFailoverClusterApps,       \"slaAssignment\": \"$slaAssignment\",       \"operatingSystemType\": \"$operatingSystemType\"     }   ],   \"total\": 1 } ```  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id/children\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"effectiveSlaSourceObjectId\": \"Global:::All\",       \"objectType\": \"FailoverClusterApp\",       \"descendentCount\": {         \"failoverCluster\": 0,         \"failoverClusterApp\": 0,         \"fileset\": 1       },       \"isDeleted\": false,       \"numNodes\": 0,       \"failoverClusterType\": \"UnixLike\",       \"failoverClusterAppConnectionStatus\": \"Connected\",       \"failoverClusterAppName\": \"$failoverClusterAppName\",       \"failoverClusterAppSource\": {         \"virtualIps\": [           \"$virtualIp\"         ]       },       \"slaAssignment\": \"$slaAssignment\",       \"filesets\": [         {           \"allowBackupNetworkMounts\": false,           \"allowBackupHiddenFoldersInNetworkMounts\": false,           \"useWindowsVss\": false,           \"id\": \"$id\",           \"name\": \"$name\",           \"configuredSlaDomainId\": \"$configuredSlaDomainId\",           \"configuredSlaDomainName\": \"$configuredSlaDomainName\",           \"configuredSlaDomainType\": \"ProtectionSla\",           \"primaryClusterId\": \"$primaryClusterId\",           \"isConfiguredSlaDomainRetentionLocked\": false,           \"hostName\": \"$hostName\",           \"templateId\": \"$templateId\",           \"templateName\": \"$templateName\",           \"operatingSystemType\": \"UnixLike\",           \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",           \"isEffectiveSlaDomainRetentionLocked\": false,           \"includes\": [             \"$includes\"           ],           \"excludes\": [],           \"exceptions\": [],           \"isRelic\": false,           \"isPassthrough\": false,           \"enableSymlinkResolution\": false,           \"enableHardlinkSupport\": false,           \"failoverClusterAppId\": \"$failoverClusterAppId\",           \"failoverClusterAppName\": \"$failoverClusterAppName\"         }       ]     }   ],   \"total\": 1 } ```  ### Get list of descendant objects Get a list of descendant objects using a GET request to [/failover_cluster/hierarchy/{id}/descendants](#operation/getFailoverClusterHierarchyDescendants).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id/descendants\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"effectiveSlaSourceObjectId\": \"Global:::All\",       \"objectType\": \"FailoverClusterApp\",       \"descendentCount\": {         \"failoverCluster\": 0,         \"failoverClusterApp\": 0,         \"fileset\": 1       },       \"isDeleted\": false,       \"numNodes\": 0,       \"failoverClusterType\": \"UnixLike\",       \"failoverClusterAppConnectionStatus\": \"Connected\",       \"failoverClusterAppName\": \"$failoverClusterAppName\",       \"failoverClusterAppSource\": {         \"virtualIps\": [           \"$virtualIp\"         ]       },       \"slaAssignment\": \"$slaAssignment\",       \"filesets\": [         {           \"allowBackupNetworkMounts\": false,           \"allowBackupHiddenFoldersInNetworkMounts\": false,           \"useWindowsVss\": false,           \"id\": \"$id\",           \"name\": \"$name\",           \"configuredSlaDomainId\": \"$configuredSlaDomainId\",           \"configuredSlaDomainName\": \"$configuredSlaDomainName\",           \"configuredSlaDomainType\": \"ProtectionSla\",           \"primaryClusterId\": \"$primaryClusterId\",           \"isConfiguredSlaDomainRetentionLocked\": false,           \"hostName\": \"$hostName\",           \"templateId\": \"$templateId\",           \"templateName\": \"$templateName\",           \"operatingSystemType\": \"UnixLike\",           \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",           \"isEffectiveSlaDomainRetentionLocked\": false,           \"includes\": [             \"$includes\"           ],           \"excludes\": [],           \"exceptions\": [],           \"isRelic\": false,           \"isPassthrough\": false,           \"enableSymlinkResolution\": false,           \"enableHardlinkSupport\": false,           \"failoverClusterAppId\": \"$failoverClusterAppId\",           \"failoverClusterAppName\": \"$failoverClusterAppName\"         }       ]     },     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"effectiveSlaDomainId\": \"$effectiveSlaDomainId\",       \"effectiveSlaDomainName\": \"$effectiveSlaDomainName\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",       \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",       \"objectType\": \"Fileset\",       \"descendentCount\": {         \"failoverCluster\": 0,         \"failoverClusterApp\": 0,         \"fileset\": 0       },       \"isDeleted\": false,       \"numNodes\": 0,       \"slaAssignment\": \"$slaAssignment\"     }   ],   \"total\": 2 } ```  # Filesets  A fileset defines a set of files and folders on a Linux, Unix, or Windows host, or on NAS shares. The Rubrik cluster uses the filesets that are specified for a host or a NAS share to determine the data to protect on that host or share.  The Rubrik cluster interprets a fileset based on the values provided in the Include, Exclude, and Do Not Exclude arrays of the fileset template that the fileset is based on. The Rubrik cluster uses the values of the arrays to determine the files and folders in a fileset. The Do Not Exclude array specifies objects that should not be excluded from the fileset by the values in the Exclude array.  ## Fileset workflow To protect data through filesets perform the following tasks: 1. Obtain and install the Rubrik Backup Service software on the host. The *Rubrik CDM User Guide* describes this task. 2. Add the host to the Rubrik cluster. The [Hosts](#section/Hosts) section describes this task. 3. Create a fileset template that defines a set of file system data to protect. The [Fileset templates](#fileset-templates) section describes this task. 4. Use a fileset template to assign a fileset to a host. 5. Assign the host fileset to an SLA Domain.  ## Fileset templates A fileset template encompasses a set of file system metadata that is needed to define filesets. The metadata includes the file system paths on the host that need protection or paths that do not need protection. The metadata varies with the type of the host or the NAS share to which the template applies.  ### Retrieving fileset templates To retrieve the current list of fileset templates, send a GET request to the [`/fileset_template`](#operation/queryFilesetTemplate) endpoint.  ```bash curl -X GET \\ \"https://$cluster_address/api/v1/fileset_template\" ```  The Rubrik REST API server responds with a ListResponse object containing the first page of the current list of fileset templates.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"allowBackupNetworkMounts\": false,       \"allowBackupHiddenFoldersInNetworkMounts\": false,       \"useWindowsVss\": false,       \"name\": \"$fileset_name\",       \"includes\": [         \"/users\"       ],       \"excludes\": [],       \"exceptions\": [],       \"operatingSystemType\": \"$os_type1\",       \"isArrayEnabled\": true,       \"id\": \"$fileset_template_id0\",       \"primaryClusterId\": \"$cluster_id\",       \"isArchived\": false,       \"hostCount\": 0,       \"shareCount\": 0     }    ],    \"total\": 1  } ```  To retrieve the details of a specific fileset template, send a GET request to the [`fileset_template/{id}`](#operation/getFilesetTemplate) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\" ```  The Rubrik REST API server responds with the details of the fileset template identified by the value of the `{id}` path parameter.  ### Creating a fileset template Create a fileset template to simplify creating identical filesets for multiple hosts.  Operations for a fileset object are described in the [Fileset](#fileset) section.  To create a fileset-template, send a POST request to [`/fileset_template`](#operation/createFilesetTemplate) with the required details: `name`, `includes`, and `operatingSystemType` or `shareType`.  ```bash curl -X POST \\   -d '{     \"name\": \"Users\",     \"includes\": [\"C:\\\\Users\"],     \"operatingSystemType\": \"$os_type1\"     }' \\   \"https://$cluster_address/api/v1/fileset_template\" ``` To create a fileset template for a specific type of NAS share, replace `operatingSystemType` with `shareType` in the above payload. For example, `\"shareType\":\"NFS\"`.  The Rubrik REST API server responds with the new fileset template object.  ```bash {   \"allowBackupNetworkMounts\": true,   \"allowBackupHiddenFoldersInNetworkMounts\": true,   \"useWindowsVss\": true,   \"name\": \"Users\",   \"includes\": [     \"C:\\\\users\"   ],   \"excludes\": [],   \"exceptions\": [],   \"operatingSystemType\": \"$os_type1\",   \"isArrayEnabled\": false,   \"id\": \"$fileset_template_id1\",   \"primaryClusterId\": \"$cluster_id\",   \"isArchived\": false,   \"hostCount\": 0,   \"shareCount\": 0 } ```  ### Updating a fileset template To modify the values of a specific fileset template, send a PATCH request to the [`/fileset_template/{id}`](#operation/updateFilesetTemplate) endpoint.  ```bash curl -X PATCH \\   -d '{         \"id\": \"$fileset_template_id0\",         \"allowBackupNetworkMounts\": true      }' \\   \"https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\" ```  The Rubrik REST API server responds with the details of the updated fileset template.  ```bash {       \"allowBackupNetworkMounts\": true,       \"allowBackupHiddenFoldersInNetworkMounts\": false,       \"useWindowsVss\": false,       \"name\": \"$fileset_name\",       \"includes\": [         \"/users\"       ],       \"excludes\": [],       \"exceptions\": [],       \"operatingSystemType\": \"$os_type2\",       \"isArrayEnabled\": true,       \"id\": \"$fileset_template_id0\",       \"primaryClusterId\": \"$cluster_id\",       \"isArchived\": false,       \"hostCount\": 0,       \"shareCount\": 0     } ```  ### Deleting a fileset template To delete a specific fileset template and all the associated filesets, send a DELETE request to the [`/fileset_template/{id}`](#operation/deleteFilesetTemplate) endpoint.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\" ```  ## Fileset A fileset is an instance of the fileset template that is assigned to a specific host.  ### Retrieving filesets To retrieve the current list of filesets, send a GET request to the [`/fileset`](#operation/queryFileset) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/fileset\" ``` The Rubrik REST API server responds with a ListResponse object containing the first page of the current list of filesets.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"allowBackupNetworkMounts\": true,       \"allowBackupHiddenFoldersInNetworkMounts\": true,       \"useWindowsVss\": true,       \"id\": \"string\",       \"name\": \"string\",       \"configuredSlaDomainId\": \"string\",       \"configuredSlaDomainName\": \"string\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"string\",       \"isConfiguredSlaDomainRetentionLocked\": true,       \"slaLastUpdateTime\": \"2021-03-03T18:42:24.766Z\",       \"hostId\": \"string\",       \"shareId\": \"string\",       \"hostName\": \"string\",       \"templateId\": \"string\",       \"templateName\": \"string\",       \"operatingSystemType\": \"string\",       \"effectiveSlaDomainId\": \"string\",       \"isEffectiveSlaDomainRetentionLocked\": true,       \"effectiveSlaDomainName\": \"string\",       \"effectiveSlaDomainPolarisManagedId\": \"string\",       \"includes\": [         \"string\"       ],       \"excludes\": [         \"string\"       ],       \"exceptions\": [         \"string\"       ],       \"isRelic\": true,       \"arraySpec\": {         \"proxyHostId\": \"string\"       },       \"isPassthrough\": true,       \"enableSymlinkResolution\": true,       \"enableHardlinkSupport\": true,       \"failoverClusterAppId\": \"string\",       \"failoverClusterAppName\": \"string\",       \"pendingSlaDomain\": {         \"objectId\": \"string\",         \"pendingSlaDomainId\": \"string\",         \"pendingSlaDomainName\": \"string\",         \"isPendingSlaDomainRetentionLocked\": true       },       \"snapMirrorLabelForFullBackup\": \"string\",       \"snapMirrorLabelForIncrementalBackup\": \"string\"     }   ],   \"total\": 0 } ```  To retrieve the details of a specific fileset, send a GET request to the [`/fileset/{id}`](#operation/getFileset) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/fileset/$fileset_id\" ```  The Rubrik REST API server responds with the details of the fileset identified by the value of the {id} path parameter.  ### Creating a fileset To create a fileset, send a POST request to [`/fileset`](#operation/createFileset) with the required details: the `hostId` or `shareId`, and the `templateId`. See [Retrieving fileset templates](#retrieving-fileset-templates) for information on obtaining a template ID, to create a fileset.  ```bash curl -X POST \\   -d '{     \"templateId\": \"$fileset_template_id\",     \"hostId\": \"$host_id\" }' \\   \"https://$cluster_address/api/v1/fileset\" ``` To create a fileset for a NAS share, replace `hostId` with `shareId` in the above payload. For example, `\"shareId\": \"$share_id\"`.  The Rubrik REST API server responds with the new fileset object.  ```bash {   \"configuredSlaDomainId\": \"UNPROTECTED\",   \"forceFull\": false,   \"forceFullPartitionIds\": [],   \"allowBackupNetworkMounts\": true,   \"allowBackupHiddenFoldersInNetworkMounts\": false,   \"useWindowsVss\": false,   \"id\": \"$fileset_id\",   \"name\": \"$fileset_name\",   \"configuredSlaDomainName\": \"Unprotected\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$cluster_id\",   \"isConfiguredSlaDomainRetentionLocked\": false,   \"hostId\": \"$host_id\",   \"hostName\": \"$hostname\",   \"templateId\": \"$fileset_template_id\",   \"templateName\": \"$fileset_template_name\",   \"operatingSystemType\": \"UnixLike\",   \"effectiveSlaDomainId\": \"UNPROTECTED\",   \"isEffectiveSlaDomainRetentionLocked\": false,   \"effectiveSlaDomainName\": \"Unprotected\",   \"includes\": [     \"$location_to_protect\"   ],   \"excludes\": [],   \"exceptions\": [],   \"isRelic\": false,   \"isPassthrough\": false,   \"enableSymlinkResolution\": false,   \"enableHardlinkSupport\": false,   \"snapshotCount\": 0,   \"archivedSnapshotCount\": 0,   \"snapshots\": [] } ``` ### Updating a fileset To update the values of a specific fileset, send a PATCH request to the [`/fileset/{id}`](#operation/updateFileset) endpoint. The request payload includes the properties to be updated.  ```bash curl -X PATCH \\   -d '{            \"configuredSlaDomainId\": \"string\",            \"forceFull\": true,            \"forceFullPartitionIds\": [                        0             ],             \"snapMirrorLabelForFullBackup\": \"string\",             \"snapMirrorLabelForIncrementalBackup\": \"string\"        }' \\   \"https://$cluster_address/api/v1/fileset/$fileset_id\" ```  The Rubrik REST API server responds with the details of the updated fileset.  ### Deleting a fileset To delete a specific fileset, send a DELETE request to the [`/fileset/{id}`](#operation/deleteFileset) endpoint.  By default, the Rubrik cluster preserves the snapshots of the fileset to be deleted.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/fileset/$fileset_id\" ``` To delete the snapshots of the fileset along with the fileset, set the `preserve_snapshots` query parameter to `false` in the DELETE request.  ```bash curl -X DELETE \\ \"https://$cluster_address/api/v1/fileset/$fileset_id?preserve_snapshots=false\" ``` The Rubrik REST API server deletes the specified fileset and the snapshots associated with the fileset.  ## On-demand backups of host filesets ### Creating on-demand snapshot To initiate an on-demand snapshot of a fileset, send a POST request to the [`/fileset/{id}/snapshot`](#operation/createFilesetBackupJob) endpoint.  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/fileset/$fileset_id/snapshot\" ```  The Rubrik REST API responds with the ID for the on-demand snapshot request along with other details about the request, like the status and the time at which the request was received.  ```bash {   \"id\": \"$request_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"2021-03-04T20:07:55.169Z\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",       \"rel\": \"self\"     }   ] } ``` ### Retrieving snapshot ID To retrieve the snapshot ID, retrieve the status of the on-demand snapshot request by sending a GET request to the [`/fileset/request/{id}`](#operation/getFilesetAsyncRequestStatus) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/fileset/request/$request_id\" ```  The Rubrik REST API server responds with the status of the on-demand snapshot request. If the snapshot has completed successfully, the response includes the ID for the snapshot in the reference link to the snapshot.  ```bash {   \"id\": \"$request_id\",   \"status\": \"SUCCEEDED\",   \"startTime\": \"2021-03-04T20:07:55.169Z\",   \"endTime\": \"2021-03-04T20:12:54.792Z\",   \"nodeId\": \"$node_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/fileset/$snapshot_id/snapshot\",       \"rel\": \"result\"     },     {       \"href\": \"https://$cluster_address/api/v1/fileset/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving snapshot details To retrieve information about a specific snapshot, send a GET request to the [`/fileset/snapshot/{id}`](#operation/getFilesetSnapshot) endpoint. By default, the flag to return verbose information about the fileset is set to `false`. Change the value of the `verbose` flag to `true` to get detailed information about the fileset.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id?verbose=false\" ``` The Rubrik REST API responds with the details of the specified fileset snapshot.  ```bash {   \"id\": \"$snapshot_id\",   \"date\": \"2021-03-04T20:08:00.000Z\",   \"sourceObjectType\": \"Fileset\",   \"isOnDemandSnapshot\": true,   \"isCustomRetentionApplied\": false,   \"cloudState\": 0,   \"indexState\": 1,   \"replicationLocationIds\": [],   \"archivalLocationIds\": [],   \"slaId\": \"UNPROTECTED\",   \"slaName\": \"Unprotected\",   \"isRetainedByRetentionLockSla\": false,   \"isPlacedOnLegalHold\": false,   \"snapshotRetentionInfo\": {     \"localInfo\": {       \"id\": \"$cluster_id\",       \"name\": \"LOCAL\",       \"isSnapshotPresent\": true,       \"isExpirationDateCalculated\": true,       \"snapshotFrequency\": \"Forever\"     },     \"archivalInfos\": [],     \"replicationInfos\": [],     \"cloudNativeLocationInfo\": []   },   \"filesetName\": \"$fileset_name\",   \"fileCount\": 10,   \"lastModified\": \"2021-02-24T14:13:33+0000\",   \"size\": 23572 } ```  ### Deleting fileset snapshots To delete a specific fileset snapshot, send a DELETE request to the [`/fileset/snapshot/{id}`](#operation/deleteFilesetSnapshot) endpoint, where `{id}` is the ID of the snapshot.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\" ``` The Rubrik REST API deletes the specified fileset snapshot.  To delete all the snapshots of a specific fileset, send a DELETE request to the [`/fileset/{id}/snapshot`](#operation/deleteFilesetSnapshots) endpoint, where `{id}` is the ID of the fileset.  ```bash curl -X DELETE \"https://$cluster_address/api/v1/fileset/$fileset_id/snapshot\" ``` The Rubrik REST API deletes all the snapshots of the specified fileset.  ## SLA Domain protection of host filesets  To assign an SLA to a fileset, send a PATCH request to the [`/fileset/{id}`](#operation/updateFileset) endpoint.  ```bash curl -X PATCH \\   -d '{      \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\   \"https://$cluster_address/api/v1/fileset/$fileset_id\" ``` The Rubrik REST API server responds with the details of the updated fileset.  ```bash {   \"id\": \"$fileset_id\",   \"excludes\": [],   \"operatingSystemType\": \"Windows\",   \"includes\": [     \"C:\\\\Users\"   ],   \"hostId\": \"$host_id\",   \"templateId\": \"$fileset_template_id\",   \"configuredSlaDomainId\": \"$sla_domain_id\" } ```  ### Retrieving missed snapshots To retrieve the details of snapshots that were missed for a fileset, send a GET request to the [`/fileset/{id}/missed_snapshot`](#operation/getMissedFilesetSnapshots) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/fileset/$fileset_id/missed_snapshot\" ``` The Rubrik REST API server responds with the details of snapshots that were missed, for the specified fileset.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"archivalLocationType\": [         \"LOCAL\"       ],       \"missedSnapshotTime\": \"2021-03-04T07:59:59.999Z\",       \"missedSnapshotTimeUnits\": [         {           \"timeUnit\": \"Daily\",           \"frequency\": 1,           \"retention\": 2         }       ]     }   ],   \"total\": 1 } ```  ## Search & Recovery ### Searching at fileset-level To search for specific file within a fileset, send a GET request to the [`/fileset/{id}/search`](#operation/searchFileset) endpoint. Specify a path prefix or a filename prefix in the `path` query parameter.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/fileset/$fileset_id/search?path=$path\" ```  The Rubrik REST API server responds with the details of the files that match the search query.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"path\": \"$path_to_file\",       \"filename\": \"$filename\",       \"fileVersions\": [         {           \"snapshotId\": \"$snapshot_id\",           \"lastModified\": \"2014-07-17T02:02:54+0000\",           \"size\": 533120,           \"fileMode\": \"file\",           \"source\": \"cloud\"         }       ]     }   ],   \"total\": 1 } ``` ### Searching at host-level To search for specific file at the host-level, send a GET request to the [`/host/{id}/search`](#operation/searchHost) endpoint. Specify a path prefix or a filename prefix in the `path` query parameter.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/host/$host_id/search?path=$path\" ```  The Rubrik REST API server responds with the details of the files that match the search query.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"path\": \"$path_to_file\",       \"filename\": \"$filename\",       \"fileVersions\": [         {           \"snapshotId\": \"$snapshot_id\",           \"lastModified\": \"2014-07-17T02:02:54+0000\",           \"size\": 533120,           \"fileMode\": \"file\",           \"source\": \"cloud\"         }       ]     }   ],   \"total\": 1 } ```  ### Browsing files in a snapshot To list all files and folders within a snapshot, send a GET request to the [`/fileset/snapshot/{id}/browse`](#operation/browseFilesetSnapshot) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/browse?path=$absolute_file_path\" ```  The Rubrik REST API server responds with the details of all the files and folders available at the specified path in the snapshot.  ```bash {   \"hasMore\": false,   \"data\": [     {       \"filename\": \"$filename\",       \"path\": \"$path_relative_to_absolute_file_path\",       \"lastModified\": \"2016-12-01T23:26:59+0000\",       \"size\": 529024,       \"fileMode\": \"file\",       \"statusMessage\": \"\"     }   ],   \"total\": 1 } ``` ### Download options There are two options for downloading the files of a fileset snapshot: download the entire snapshot or download specific files from the snapshot.  To download the entire snapshot from an archival location, send a POST request to the [`/fileset/snapshot/{id}/download`](#operation/createDownloadFilesetSnapshotFromCloud) endpoint.   ```bash curl -X POST \\   \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download\" ```  To download files from a specific location in a snapshot, send a POST request to the [`/fileset/snapshot/{id}/download_file`](#operation/createFilesetDownloadFileJob) endpoint.  ```bash curl -X POST -d \\ '{     \"sourceDir\": \"$path_to_download_from\"  }' \\   \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file\" ```  The Rubrik REST API server initiates an async download job and returns a job instance ID.  ```bash {   \"id\": \"$job_instance_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"2021-03-05T18:19:27.584Z\",   \"links\": [     {       \"href\": \"https://$cluster_address//api/v1/fileset/request/$job_instance_id\",       \"rel\": \"self\"     }   ] } ```  To retrieve the download location, send a GET request to the [`fileset/request/{id}`](#operation/getFilesetAsyncRequestStatus) endpoint where, `{id}` is the `$job_instance_id`.  ```bash curl -X GET \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\" ```  The Rubrik REST API server responds with the status of the download job. The response includes a download link when the job completes successfully.  ```bash {   \"id\": \"$job_instance_id\",   \"status\": \"SUCCEEDED\",   \"startTime\": \"2021-03-05T18:01:43.755Z\",   \"endTime\": \"2021-03-05T18:02:48.481Z\",   \"nodeId\": \"$node_id\",   \"links\": [     {       \"href\": \"$download_url\",       \"rel\": \"result\"     },     {       \"href\": \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\",       \"rel\": \"self\"     }   ] } ```  ### Recovery options To restore files from a fileset snapshot on to the source host, send a POST request to the [`/fileset/snapshot/{id}/restore_file`](#operation/createFilesetRestoreFileJob) endpoint.  ```bash curl -X POST -d \\   '{     \"sourceDir\": \"$source_of_restore\",     \"destinationDir\": \"$destination_of_restore\"   }' \\   \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/restore_file\" ```  To restore files from a fileset snapshot on to a host other than the source host, send a POST request to the [`/fileset/snapshot/{id}/export_file`](#operation/createFilesetExportFileJob).  ```bash curl -X POST -d \\   '{     \"sourceDir\": \"$source_of_restore\",     \"destinationDir\": \"$destination_of_restore\",     \"hostId\": \"$destination_host_id\"   }' \\   \"https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/export_file\" ```  The Rubrik REST API server initiates an async restore job and returns a job instance ID.  ```bash {   \"id\": \"$job_instance_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"2021-03-05T18:19:27.584Z\",   \"links\": [     {       \"href\": \"https://$cluster_address//api/v1/fileset/request/$job_instance_id\",       \"rel\": \"self\"     }   ] } ```  To check the progress of the request, send a GET request to the [`fileset/request/{id}`](#operation/getFilesetAsyncRequestStatus) endpoint where, `{id}` is the `$job_instance_id`.  ```bash curl -X GET \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\" ```  The Rubrik REST API server responds with the status of the restore job.  ```bash {   \"id\": \"$job_instance_id\",   \"status\": \"SUCCEEDED\",   \"startTime\": \"2021-03-05T18:01:43.755Z\",   \"endTime\": \"2021-03-05T18:02:48.481Z\",   \"nodeId\": \"$node_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/fileset/request/$job_instance_id\",       \"rel\": \"self\"     }   ] } ```  #  host hierarchy  This REST API is used to get host/share hierarchy objects.  ### Get summary of a hierarchy object Get a summary of a hierarchy object by making a GET call to [/host/hierarchy/{id}]\\ (#operation/getHostHierarchyObject).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/host/hierarchy/{id}\" ```  The Rubrik REST API server returns a host hierarchy object contains the ID, objectType, status, descendantCount, primaryClusterId, name, alias, operatingSystem, operatingSystemType shareType, vendorType, hostId, exportPoint, filesets and isSnapdiff.  ### Get list of immediate descendant objects Get a list of immediate descendant objects using a GET request to [/host/hierarchy/{id}/children]\\ (#operation/getHostHierarchyChildren).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/host/hierarchy/{id}/children\" ```  The Rubrik REST API server returns a list of host hierarchy objects.  # Directories  A HDFS directory defines a set of files and folders on a HDFS cluster.  The Rubrik cluster uses the directorys that are assigned to a HDFS cluster to determine the data to protect on that cluster.  The Rubrik cluster interprets a directory based on the values provided in the Include, Exclude, and Do Not Exclude arrays. The Rubrik cluster applies a set of rules to the values provided in these arrays and permits several types of values to be added to the arrays. The Do Not Exclude array specifies objects that should not be excluded from the directory by the values in the Exclude array.  ## Directory workflow The basic workflow to follow when using directorys to protect data in host file systems is: 1. Obtain and install the Rubrik Backup Service software on the HDFS cluster. The Rubrik user guide describes this task. 2. Add the HDFS cluster to the Rubrik cluster. The [Hosts](#section/Hosts) section describes this task. 3. Create a directory template that defines a set of file system data to protect. 4. Use a directory template to assign a directory to a host. 5. Assign the host directory to an SLA Domain.  ## Directory templates  First, create a directory template. A directory template can be used to create directory instances for various HDFS clusters. Performing a POST on [`/hdfs_template`](#operation/createHdfsTemplate)  with the necessary details will create a directory template.  ```bash curl -X POST \\   -d '{     \"name\": \"Users\",     \"includes\": [\"/Users\"]}' \\   \"https://$cluster_address/api/v1/hdfs_template\" ```  ```bash {   \"id\": \"$directory_template_id\",   \"name\": \"Users\",   \"excludes\": [],   \"includes\": [     \"/Users\"   ] } ```  To get the details of a directory template, use GET on the [`/hdfs_template/{id}`](#operation/getHdfsTemplate) endpoint.  ```bash curl -X GET \\   -d '{     \"id\": \"$directory_template_id\" }' \\   \"https://$cluster_address/api/v1/hdfs_template\" ```  ```bash {   \"id\": \"$host_id\",   \"hostname\": \"$hostname\",   \"status\": \"Connected\" } ```  To get the current list of all directory templates matching a query, use GET on the [`/hdfs_template`](#operation/queryHdfsTemplate) endpoint.  ```bash curl -X POST \\   -d '{     \"hostname\": \"$hostname\" }' \\   \"https://$cluster_address/api/v1/hdfs_template\" ```  ```bash {   \"id\": \"$host_id\",   \"hostname\": \"$hostname\",   \"status\": \"Connected\" } ```  Modify with PATCH on the [`/hdfs_template/{id}`](#operation/updateHdfsTemplate) endpoint.  ```bash curl -X PATCH \\   -d '{     \"id\": \"$directory_template_id\" }' \\   \"https://$cluster_address/api/v1/hdfs_template\" ```  ```bash {   \"id\": \"$host_id\",   \"hostname\": \"$hostname\",   \"status\": \"Connected\" } ```  Delete with the [`/hdfs_template/{id}`](#operation/deleteHdfsTemplate) endpoint.  ```bash curl -X DELETE \\   -d '{     \"id\": \"$directory_template_id\" }' \\   \"https://$cluster_address/api/v1/hdfs_template\" ``` ## Directory  Create a directory using a directory template. The directory is an instance of the template that is assigned to a specific HDFS cluster.  To get the current list of HDFS clusters, use GET on the [`/hdfs`](#operation/queryHdfs) endpoint.  ```bash curl -X POST \\   -d '{     \"hostname\": \"$hostname\" }' \\   \"https://$cluster_address/api/v1/hdfs\" ```  ```bash {   \"id\": \"$host_id\",   \"hostname\": \"$hostname\",   \"status\": \"Connected\" } ```  To get the current further details of HDFS clusters, use GET on the [`/hdfs/{id}`](#operation/getHdfs) endpoint.  ```bash curl -X POST \\   -d '{     \"hostname\": \"$hostname\" }' \\   \"https://$cluster_address/api/v1/hdfs\" ```  ```bash {   \"id\": \"$host_id\",   \"hostname\": \"$hostname\",   \"status\": \"Connected\" } ```  A directory can be created with a POST on [`/hdfs`](#operation/createHdfs).  ```bash curl -X POST \\   -d '{     \"templateId\": \"$directory_template_id\",     \"hostId\": \"$host_id\" }' \\   \"https://$cluster_address/api/v1/hdfs\" ```  ```bash {   \"id\": \"$directory_id\",   \"excludes\": [],   \"includes\": [     \"/Users\"   ],   \"hostId\": \"$host_id\",   \"templateId\": \"$directory_template_id\",   \"configuredSlaDomainId\": \"UNPROTECTED\" } ```  A directory can be deleted with a DELETE on [`/hdfs`](#operation/deleteHdfs).  ```bash curl -X POST \\   -d '{     \"templateId\": \"directory_template_id\",     \"hostId\": \"$host_id\" }' \\   \"https://$cluster_address/api/v1/hdfs\" ```  ```bash {   \"id\": \"$directory_id\",   \"excludes\": [],   \"includes\": [     \"/Users\"   ],   \"hostId\": \"$host_id\",   \"templateId\": \"$directory_template_id\",   \"configuredSlaDomainId\": \"UNPROTECTED\" } ``` ## On demand backups of HDFS cluster directorys  To create an on-demand snapshot, use POST on [`/hdfs/{id}/snapshot`](#operation/createHdfsBackupJob).  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/hdfs/$directory_id/snapshot\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/hdfs/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  After taking a snapshot, retrieve the `$snapshot_id` by querying [`/hdfs/request`](#operation/getHdfsAsyncRequestStatus).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/hdfs/request/$request_id\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\",       \"rel\": \"result\"     },     {       \"href\": \"https://$cluster_address/api/v1/hdfs/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"SUCCEEDED\" } ```   After taking a snapshot, retrieve the `$snapshot_id` from the request.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/hdfs/request/$request_id\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\",       \"rel\": \"result\"     },     {       \"href\": \"https://$cluster_address/api/v1/hdfs/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"SUCCEEDED\" } ```  For more information about a specific snapshot, send a GET request to the [`/hdfs/snapshot/{id}`](#operation/getHdfsSnapshot) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\" ```  ```bash {   \"id\": \"$snapshot_id\"   \"date\": <timestamp1>,   \"expirationDate\": <timestamp2>,   \"sourceObjectType\": \"Hdfs\",   \"isOnDemandSnapshot\": true,   \"cloudState\": 2,   \"consistencyLevel\": \"none\",   \"indexState\": 1,   \"replicationLocationIds\": [     \"$replication_location_id\"   ],   \"archivalLocationIds\": [     \"$archival_location_id\"   ],   \"slaId\": \"$sla_id\",   \"slaName\": \"sla\",   \"directoryName\": \"directory\",   \"fileCount\": 10,   \"lastModified\": <timestamp3>,   \"size\": 533120 } ```  To delete a specific snapshot, send a DELETE request to the [`/hdfs/snapshot/{id}`](#operation/deleteHdfsSnapshot) endpoint, where `{id}` is the ID of the snapshot.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\" ```  ```bash { } ```  Delete all snapshots for a specific HDFS cluster with a DELETE on [`/hdfs/{id}/snapshot`](#operation/deleteHdfsSnapshots).  ```bash curl -X DELETE \"https://$cluster_address/api/v1/hdfs/$id/snapshot\" ``` ## SLA Domain protection of host directorys  Assign a directory to an SLA with a PATCH [`/hdfs/{id}`](#operation/updateHdfs).  ```bash curl -X PATCH \\   -d '{     \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\   \"https://$cluster_address/api/v1/hdfs/$directory_id\" ```  ```bash {   \"id\": \"$directory_id\",   \"excludes\": [],   \"includes\": [     \"/Users\"   ],   \"hostId\": \"$host_id\",   \"templateId\": \"$directory_template_id\",   \"configuredSlaDomainId\": \"$sla_domain_id\" } ```  List missed snapshots with a GET on [`/hdfs/{id}/missed_snapshot`](#operation/getMissedHdfsSnapshots).  ```bash curl -X GET \"https://$cluster_address/api/v1/hdfs/$id/missed_snapshot\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"missedSnapshotTime\": \"2000-01-02T11:08:40.420Z\"     }   ],   \"total\": 1 } ```  ## Search & Recovery  Once snapshots have been taken, they can be used to search for files and recover.  File search can be performed on a specific directory using its `$directory_id` with a GET on [`/hdfs/{id}/search`](#operation/searchHdfs) and specifying the file path with the `path` query parameter.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/hdfs/$directory_id/search?path=home\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"path\": \"/home\",       \"filename\": \"home\",       \"fileVersions\": [         {           \"snapshotId\": \"$snapshot_id\",           \"lastModified\": \"2014-07-17T02:02:54+0000\",           \"size\": 533120         }       ]     }   ],   \"total\": 1 } ```  Files within a snapshot can be browsed by using GET on [`/hdfs/snapshot/{id}/browse`](#operation/browseHdfsSnapshot).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/browse?path=%2Fhome&offset=0\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"filename\": \"ubuntu\",       \"path\": \"ubuntu\",       \"lastModified\": \"2016-12-01T23:26:59+0000\",       \"size\": 529024,     }   ],   \"total\": 1 } ```  Files from a snapshot can also be restored to a host with POST on [`/hdfs/snapshot/{id}/restore_file`](#operation/createHdfsRestoreFileJob).  ```bash curl -X POST -d \\   '{     \"sourceDir\": \"/foo.txt\",     \"destinationDir\": \"/bar.txt\"   }' \\   \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/restore_file\" ```  Files can also be restored to a different host with POST on [`/hdfs/snapshot/{id}/export_file`](#operation/createHdfsExportFileJob).  ```bash curl -X POST -d \\   '{     \"sourceDir\": \"/foo.txt\",     \"destinationDir\": \"/bar.txt\",     \"hostId\": \"$host_id\"   }' \\   \"https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/export_file\" ```  # SQL Server databases  Version 3.0 added support for Microsoft SQL backups. First add the hosts hosting the Microsoft SQL databases as specified in the [host protection](#section/Hosts) section. Once the host has been added, instances and databases will be auto-discovered.  ## Instances  Microsoft SQL instances can be found by a GET on [`/mssql/instance`](#operation/queryMssqlInstance)  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/instance\" ```  ```bash {   \"data\": [     {       \"id\": \"$instance_id\",       \"name\": \"$instance_name\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"INHERIT\",       \"effectiveSlaDomainName\": \"Inherit\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  Further details are acquired from [`/mssql/instance/{id}`](#operation/getMssqlInstance).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/instance/$instance_id\" ```  ```bash {   \"data\": [     {       \"id\": \"$instance_id\",       \"name\": \"$instance_name\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  The Rubrik cluster auto-detects most fields of the Microsoft SQL instance. However, certain fields such as the `clusterInstanceAddress` can be overridden with a PATCH to [`/mssql/instance/{id}`](#operation/updateMssqlInstance).  ```bash curl -X PATCH \\   -d '{     \"clusterInstanceAddress\": \"1.1.1.1\"   }' \\   \"https://$cluster_address/api/v1/mssql/instance/$instance_id\" ```  ```bash {   \"data\": [     '{       \"id\": \"$instance_id\",       \"name\": \"$instance_name\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"clusterInstanceAddress\": \"1.1.1.1\"   }' \\     }   ],   \"hasMore\": false,   \"total\": 1 } ```  The total number of SQL Server Instances can be found by GET on [/mssql/instance/count](#operation/countMssqlInstanceV1).    ```bash   curl -X GET \"https://$cluster_address/api/v1/mssql/instance/count\"   ```    ```bash   {     \"count\": $total_number_of_instances   }   ```  ## Databases  All Microsoft SQL databases on an instance can be found with a GET on  [`/mssql/db`](#operation/queryMssqlDb).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db?instance_id=$instance_id\" ```  ```bash {   \"data\": [     {       \"id\": \"$db_id\",       \"name\": \"$db_name\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"instanceId\": \"$instance_id\"       \"instanceName\": \"$instance_name\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  Further details are acquired from [`/mssql/db/{id}`](#operation/getMssqlDb).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id\" ```  ```bash {   \"data\": [     {       \"id\": \"$db_id\",       \"name\": \"$db_name\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"instanceId\": \"$instance_id\"       \"instanceName\": \"$instance_name\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  The total number of SQL Server Databases can be found by GET on  [/mssql/db/count](#operation/countMssqlDbV1).    ```bash   curl -X GET \"https://$cluster_address/api/v1/mssql/db/count?root_id=$host_id\"   ```    ```bash   {     \"numTotal\": 15,     \"numProtected\": 2,     \"numNoSla\": 0,     \"numDoNotProtect\": 13   }   ```  Snappable Id of a SQL Server database can be found by GET on [/mssql/db/{id}/snappable_id](#operation/mssqlGetSnappableIdV1).    ```bash   curl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id/snappable_id\"   ```    ```bash   {     \"snappableId\": \"$snappable_id\"   }   ```  The properties of SQL Server database can be updated by PATCH on [/mssql/db/bulk](#operation/bulkUpdateMssqlDbV1).  ```bash curl -X PATCH \"https://$cluster_address/api/v1/mssql/db/bulk\" -d\\ '[   {       \"databaseId\": \"$db_id\",       \"updateProperties\": {          \"logBackupFrequencyInSeconds\": 2000,          \"logRetentionHours\": 180,          \"copyOnly\": true,          \"maxDataStreams\": 8,          \"isPaused\": true,          \"shouldForceFull\": true    }  } ]' ```  ```bash [   {     \"id\": \"MssqlDatabase:::5d1da757-95d0-4740-9851-53c25c3dda2d\",     \"name\": \"simple_rec\",     \"configuredSlaDomainId\": \"ea82adf1-fa12-4b33-89af-9c2a08802a5d\",     \"configuredSlaDomainName\": \"Gold\",     \"configuredSlaDomainType\": \"ProtectionSla\",     \"primaryClusterId\": \"977dbc71-8137-4de5-be23-67251f0b63c1\",     \"isConfiguredSlaDomainRetentionLocked\": false,     \"effectiveSlaDomainId\": \"ea82adf1-fa12-4b33-89af-9c2a08802a5d\",     \"effectiveSlaDomainName\": \"Gold\",     \"isEffectiveSlaDomainRetentionLocked\": false,     \"effectiveSlaSourceObjectId\": \"MssqlDatabase:::5d1da757-95d0-4740-9851-53c25c3dda2d\",     \"effectiveSlaSourceObjectName\": \"simple_rec\",     \"slaAssignment\": \"Direct\",     \"retentionSlaDomainId\": \"ea82adf1-fa12-4b33-89af-9c2a08802a5d\",     \"rootProperties\": {       \"rootType\": \"Host\",       \"rootId\": \"Host:::151e41d1-5395-4940-98ec-17460eae8949\",       \"rootName\": \"10.0.46.37\"     },     \"instanceId\": \"MssqlInstance:::442b9524-9e45-4b03-aa66-eec1f3d0c470\",     \"instanceName\": \"SQLEXPRESS\",     \"isRelic\": false,     \"copyOnly\": true,     \"logBackupFrequencyInSeconds\": 2000,     \"logBackupRetentionHours\": 180,     \"isLiveMount\": false,     \"isLogShippingSecondary\": false,     \"recoveryModel\": \"FULL\",     \"state\": \"ONLINE\",     \"hasPermissions\": true,     \"isInAvailabilityGroup\": false,     \"replicas\": [       {         \"instanceId\": \"MssqlInstance:::442b9524-9e45-4b03-aa66-eec1f3d0c470\",         \"instanceName\": \"SQLEXPRESS\",         \"recoveryModel\": \"FULL\",         \"state\": \"ONLINE\",         \"hasPermissions\": true,         \"isStandby\": false,         \"recoveryForkGuid\": \"83145A93-8921-4318-8508-B9ABE1D3B0F6\",         \"isArchived\": false,         \"isDeleted\": false,         \"rootProperties\": {           \"rootType\": \"Host\",           \"rootId\": \"Host:::151e41d1-5395-4940-98ec-17460eae8949\",           \"rootName\": \"10.0.46.37\"         }       }     ],     \"unprotectableReasons\": [],     \"numMissedSnapshot\": 0,     \"lastSnapshotTime\": \"2020-09-07T13:36:33.000Z\",     \"includeBackupTaskInfo\": false,     \"isOnline\": true,     \"blackoutWindowStatus\": {       \"isGlobalBlackoutActive\": false,       \"isSnappableBlackoutActive\": true     },     \"blackoutWindows\": {       \"globalBlackoutWindows\": [],       \"snappableBlackoutWindows\": [         {           \"startTime\": \"2020-09-13T11:02:04+0000\"         }       ]     },     \"snapshotCount\": 2,     \"isLocal\": true,     \"isStandby\": false,     \"latestRecoveryPoint\": \"2020-09-07T14:11:54.000Z\",     \"oldestRecoveryPoint\": \"2020-09-07T12:47:38.000Z\",     \"protectionDate\": \"2020-08-26T07:43:26.429Z\",     \"recoveryForkGuid\": \"83145A93-8921-4318-8508-B9ABE1D3B0F6\",     \"maxDataStreams\": 8,     \"localStorage\": 1363475,     \"archiveStorage\": 0   } ] ```  ## Availability Groups  To get the details of a SQL Server Availability Group, GET on [`/mssql/availability_group/{id}`](#operation/getMssqlAvailabilityGroupV1).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/availability_group/$availability_group_id\" ```  ```bash {   \"id\": \"$availability_group_id\",   \"name\": \"$availability_group_name\",   \"configuredSlaDomainId\": \"$sla_id\",   \"configuredSlaDomainName\": \"$sla_name\",   \"configuredSlaDomainType\": \"$sla_type\",   \"primaryClusterId\": \"$primary_cluster_id\",   \"isConfiguredSlaDomainRetentionLocked\": $is_sla_retention_locked,   \"effectiveSlaDomainId\": \"$sla_id\",   \"effectiveSlaDomainName\": \"$sla_name\",   \"isEffectiveSlaDomainRetentionLocked\": $is_sla_retention_locked,   \"slaAssignment\": \"$sla_assignment\",   \"logBackupFrequencyInSeconds\": $log_backup_frequenct,   \"logRetentionHours\": $log_backup_retention,   \"copyOnly\": $copy_only } ```  To get a summary of all SQL Server Availability Groups, GET on [`/mssql/availability_group`](#operation/queryMssqlAvailabilityGroupV1).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/availability_group\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"id\": \"$availability_group_id\",       \"name\": \"$availability_group_name\",       \"configuredSlaDomainId\": \"$sla_id\",       \"configuredSlaDomainName\": \"$sla_name\",       \"configuredSlaDomainType\": \"$sla_type\",       \"primaryClusterId\": \"$primary_cluster_id\",       \"isConfiguredSlaDomainRetentionLocked\": $is_sla_retention_locked,       \"effectiveSlaDomainId\": \"$sla_id\",       \"effectiveSlaDomainName\": \"$sla_name\",       \"isEffectiveSlaDomainRetentionLocked\": $is_sla_retention_locked,       \"slaAssignment\": \"$sla_assignment\",       \"logBackupFrequencyInSeconds\": $log_backup_frequenct,       \"logRetentionHours\": $log_backup_retention,       \"copyOnly\": $copy_only     }   ],   \"total\": 1 } ```  To update a SQL Server Availability Group, PATCH on [`/mssql/availability_group/{id}`](#operation/updateMssqlAvailabilityGroupV1).  ```bash curl -X PATCH \"https://$cluster_address/api/v1/mssql/availability_group/$availability_group_id\" -d\\  '{     \"logBackupFrequencyInSeconds\": $log_backup_freq,     \"logRetentionHours\": $log_backup_retention,     \"copyOnly\": $copy_only,     \"configuredSlaDomainId\\\": \"$sla_id\"   }' ```  ```bash {   \"id\": \"$availability_group_id\",   \"name\": \"$availability_group_name\",   \"configuredSlaDomainId\": \"$sla_id\",   \"configuredSlaDomainName\": \"$sla_name\",   \"configuredSlaDomainType\": \"$sla_type\",   \"primaryClusterId\": \"$primary_cluster_id\",   \"isConfiguredSlaDomainRetentionLocked\": $is_sla_retention_locked,   \"effectiveSlaDomainId\": \"$sla_id\",   \"effectiveSlaDomainName\": \"$sla_name\",   \"isEffectiveSlaDomainRetentionLocked\": $is_sla_retention_locked,   \"slaAssignment\": \"$sla_assignment\",   \"logBackupFrequencyInSeconds\": $log_backup_frequenct,   \"logRetentionHours\": $log_backup_retention,   \"copyOnly\": $copy_only } ```  ## Protection  To create an on-demand snapshot, POST on [`/mssql/db/{id}/snapshot`](#operation/createOnDemandMssqlBackup).  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  Once the snapshot has been taken, the `$snapshot_id` can be retrieved from the request with [`/mssql/request/{id}`](#operation/getMssqlAsyncRequestStatus).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/mssql/request/$request_id\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\",       \"rel\": \"result\"     },     {       \"href\": \"https://$cluster_address/api/v1/mssql/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"SUCCEEDED\" } ```  The `$snapshot_id` can be used to extract further information on the snapshot with a GET on [`/mssql/db/snapshot/{id}`](#operation/getMssqlDbSnapshot).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\" ```  ```bash {   \"id\": \"$snapshot_id\",   \"date\": \"2017-02-02T18:53:12.718Z\",   \"isOnDemandSnapshot\": true } ```  To create an on-demand log backup, POST on [`/mssql/db/{id}/log_backup`](#operation/createOnDemandMssqlLogBackup).  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/log_backup\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  To protect a specific database under an SLA, perform a PATCH on [`/mssql/db/{id}`](#operation/updateMssqlDb)  ```bash curl -X PATCH \\   -d '{     \"configuredSlaDomainId\": \"$sla_domain_id\" }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id\" ```  ```bash {   \"id\": \"$db_id\",   \"name\": \"$db_name\",   \"configuredSlaDomainId\": \"$sla_domain_id\",   \"configuredSlaDomainName\": \"$sla_domain_name\",   \"effectiveSlaDomainId\": \"$sla_domain_id\",   \"effectiveSlaDomainName\": \"sla_domain_name\",   \"instanceId\": \"$instance_id\"   \"instanceName\": \"$instance_name\" } ```  List all snapshots for a database with a GET on [`/mssql/db/{id}/snapshot`](#operation/queryMssqlDbSnapshot).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$snapshot_id\",       \"date\": \"2017-02-02T18:53:12.718Z\",       \"isOnDemandSnapshot\": true     }   ],   \"total\": 1 } ```  Point-in-time recovery is supported when log backups are taken. The range of recoverable times can be listed with a GET on [`/mssql/db/{id}/recoverable_range`](#operation/getMssqlDbRecoverableRanges).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"beginTime\": \"2017-02-02T18:53:12.694Z\",       \"endTime\": \"2017-02-02T20:53:12.694Z\"     }   ],   \"total\": 1 } ```  ## Download The Rubrik REST API server provides endpoints to browse and download snapshots and logs for a specific SQL Server database.  ### Browsing SQL Server snapshots To view a list of snapshots and log backups of a specific SQL Server database, send a POST request to the  [`/mssql/db/{id}/browse`](#operation/browseMssqlBackupFiles) endpoint where, `{id}` is the ID of the SQL Server database.  This POST call fetches metadata based on a timestamp or the log sequence number (LSN) provided in the request payload.  To fetch a list of snapshots and log backups that are required to recover to a point in time, specify the point in time using either the `date` or the `lsnpoint` attribute of the `recoveryPoint` attribute. Both `date` and `lsnPoint` cannot be used at the same time.  ```bash curl -X POST -d \\   '{          \"recoveryPoint\": {\"date\": \"2019-08-15T10:40\"}    }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/browse ```  To fetch a list of snapshots and log backups that fit within a range, specify the range by using a combination of the `startPoint` and `endPoint` attributes. Within the `startPoint` and `endPoint` attributes, specify values for either the `lsnPoint` or the `date` attributes, not for both.  ```bash curl -X POST -d \\   '{          \"startPoint\": {\"date\": \"2019-08-15T10:40\"},          \"endPoint\": {\"date\": \"2019-08-15T10:45:47\"}     }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/browse ```  To recover to a point in time, use the `recoveryPoint` attribute; do not define a range using the `startPoint` and `endPoint` attributes.  To fetch a list of snapshots and log backups that fit within a range, specify the beginning of a range using the `startPoint` attribute and specify the end of the range using the `endPoint` attribute. When specifying a range, do not specify a `recoveryPoint`.  The Rubrik REST API server responds with the list of the log and database snapshots that fit within the parameters specified in the request.  ```bash {   \"items\": [     {       \"backupId\": \"e8f0c6ee-fafc-4740-b9c9-deadba9815df\",       \"backupType\": \"Log\",       \"path\": \"testdb/logs/2019-08-15T10-40-58Z.trn\",       \"date\": \"2019-08-15T10:40:58.000Z\",       \"lsn\": \"45000000219000001\",       \"recoveryForkGuid\": \"03F633D8-6B5A-48F5-97F0-401440F124FD\",       \"backupSize\": 86528     },     {       \"backupId\": \"5e3de1ce-f5ab-4787-a057-accec64fe7af\",       \"backupType\": \"Snapshot\",       \"path\": \"testdb/snapshot-2019-08-15T10-45-31Z/\",       \"date\": \"2019-08-15T10:45:47.000Z\",       \"lsn\": \"45000000221300001\",       \"recoveryForkGuid\": \"03F633D8-6B5A-48F5-97F0-401440F124FD\",       \"backupSize\": 16777216     },     {       \"backupId\": \"c57d1908-c085-43ef-9a7f-fcb482994bf7\",       \"backupType\": \"Log\",       \"path\": \"testdb/logs/2019-08-15T10-46-03Z.trn\",       \"date\": \"2019-08-15T10:46:03.000Z\",       \"lsn\": \"45000000222300001\",       \"recoveryForkGuid\": \"03F633D8-6B5A-48F5-97F0-401440F124FD\",       \"backupSize\": 86528     }   ] }  ```  ### Downloading all SQL Server snapshots and logs To initiate a request to build a zip file containing the snapshots and log backups that are required to recover to a specific point in time, or a range of time, send a POST request to the [`/mssql/db/{id}/download_files`](#operation/createDownloadMssqlBackupFiles) endpoint.  The usage of parameters for this POST call is identical to the usage described for the [browse API call](#browsing-sql-server-snapshots).  ```bash curl -X POST -d \\   '{ \"startPoint\": {\"date\": \"2019-08-15T10:40\"}, \"endPoint\": {\"date\": \"2019-08-15T10:45:47\"} }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/download_files ```  The Rubrik REST API server responds with the details of the asynchronous task that is initiated by the POST API call.  ```bash {   \"id\": \"$request_id\",   \"status\": \"$request_status\",   \"progress\": 0,   \"startTime\": \"2021-03-23T20:38:05.511Z\",   \"endTime\": \"2021-03-23T20:38:05.511Z\",   \"nodeId\": \"$node_id\",   \"error\": {     \"message\": \"$error_message\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  To check the status of the download request, send a GET request to the (`/mssql/request/{id}`)[#operation/getMssqlAsyncRequestStatus] endpoint where, `{id}` is the `$request_id`.  The Rubrik REST API server responds with the link to download the zip file when the zip file is ready for download.  ### Downloading specific SQL Server snapshots and logs To initiate a request to build a zip file containing specific snapshots and log backups, send a POST request to the [`/mssql/db/{id}/download_files_by_id`](#operation/createDownloadMssqlBackupFilesById) endpoint with the object IDs for the snapshots and logs to be downloaded.  ```bash curl -X POST -d \\   '{ \"items\": [\"e8f0c6ee-fafc-4740-b9c9-deadba9815df\", \"c57d1908-c085-43ef-9a7f-fcb482994bf7\"] }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/download_files_by_id\" ```  The Rubrik REST API server responds with the details of the asynchronous task that is initiated by the POST API call.  ```bash {   \"id\": \"$request_id\",   \"status\": \"$request_status\",   \"progress\": 0,   \"startTime\": \"2021-03-23T20:38:05.511Z\",   \"endTime\": \"2021-03-23T20:38:05.511Z\",   \"nodeId\": \"$node_id\",   \"error\": {     \"message\": \"$error_message\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ``` To check the status of the download request, send a GET request to the (`/mssql/request/{id}`)[#operation/getMssqlAsyncRequestStatus] endpoint where, `{id}` is the `$request_id`.  The Rubrik REST API server responds with the link to download the zip file when the zip file is ready for download.  The zip file uses the naming convention of `$database_name`- `$random_string`.zip.  The path to the log backup files inside the zip file is of the form `$database_name`/logs/`$database_name`-`$timestamp`.trn. For example, if the `$database_name` is `BigDatabase`, the log backup file is located at `BigDatabase/logs/BigDatabase-2021-03-23T03-15-55Z.trn` inside the downloaded zip file.  The path to the database snapshot files inside the zip file is of the form `$database_name`/snapshot-`$timestamp`/`$snapshot_files`. For example, if the `$database_name` is `BigDatabase` and a snapshot filename is `snapshot.mdf`, then the  location of the file inside the downloaded zip file is `BigDatabase/snapshot-2021-03-23T03-15-55Z/snapshot.mdf`.   Make an asynchronous POST request to the [`/mssql/db/{id}/download`](#operation/downloadFromArchive) endpoint to download snapshots and logs from archival for a given database and recovery point.  ```bash curl -X POST -d \\   '{ \"recoveryPoint\": { \"timestampMs\": 12345 } }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/download\" ```  A 'missed snapshot' occurs when a snapshot that is required by SLA Domain policy cannot be created. To retrieve information about missed snapshots, send a GET request to the [`/mssql/db/{id}/missed_snapshot`](#operation/getMissedMssqlDbSnapshots) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/missed_snapshot\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"missedSnapshotTime\": \"2000-01-02T11:08:40.420Z\"     }   ],   \"total\": 1 } ```  To retrieve the recoverable time ranges that were missed for a specified database, send a GET request to the [`/mssql/db/{id}/missed_recoverable_range`](#operation/getMssqlDbMissedRecoverableRanges) endpoint.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/missed_recoverable_range\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"beginTime\": \"2017-02-02T18:53:12.694Z\",       \"endTime\": \"2017-02-02T20:53:12.694Z\"     }   ],   \"total\": 1 } ```  Delete all snapshots for a specific database with a DELETE on [`/mssql/db/{id}/snapshot`](#operation/deleteMssqlDbSnapshots).  ```bash curl -X DELETE \"https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\" ```  Assign SLA properties to multiple objects with a POST to [`mssql/sla_domain/assign`](#operation/assignMssqlSlaProperties).  ```bash curl -X POST -d \\   '{     \"ids\": [\"$id1\", \"$id2\"],     \"copyOnly\": true,     \"configuredSlaDomainId\": \"$slaDomainId\"   }' \\   \"https://$cluster_address/api/v1/mssql/sla_domain/assign\" ```  To take on demand snapshot of multiple SQL Server databases, perform POST on  [`/mssql/db/bulk/snapshot`](#operation/createOnDemandMssqlBatchBackupV1).  ```bash curl -X POST \"https://$cluster_address/api/v1/mssql/db/bulk/snapshot\" -d\\ '{    \"slaId\": \"$sla_id\",    \"databaseIds\": [      \"$db_id_1\",      \"$db_id_2\"    ],    \"instanceIds\": [      \"$instance_id_3\"    ],    \"hostIds\": [      \"$host_id_4\",      \"$host_id_5\",      \"$host_id_6\",    ],    \"windowsClusterIds\": [      \"$windows_cluster_id_7\"    ],    \"availabilityGroupIds\": [      \"$availability_group_id_8\"    ],    \"forceFullSnapshot\": true  }' ``` ```bash {   \"id\": \"$mssql_multi_host_batch_backup_job_id\",   \"status\": \"$job_status\",   \"progress\": $job_progress,   \"startTime\": \"$job_start_time\",   \"links\": [     {       \"href\": \"$link1\",       \"rel\": \"self\"     }   ]  ```  Get the details of on demand backup job of SQL Server databases by performing  GET on  [`/mssql/db/bulk/snapshot/{id}`](#operation/getOnDemandMssqlBatchBackupResultV1).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/bulk/snapshot/$mssql_multi_host_batch_backup_job_id\" ```  ```bash {   \"id\": \"$mssql_multi_host_batch_backup_job_id\",   \"successfulSnapshots\": [     {       \"databaseId\": \"$db_id\",       \"snapshotId\": \"$snapshot_id\"     }   ],   \"failedSnapshots\": [     {       \"databaseId\": \"$db_id_2\",       \"error\": \"$error\"     }   ],   \"canceledSnapshots\": [] } ```   To delete all the downloaded snapshots and logs for a SQL Server database,  perform DELETE on  [`mssql/db/{id}/recoverable_range/download`](#operation/deleteDownloadedMssqlDbRecoverableRangesV1).  ```bash curl -X DELETE \"https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range_download\" ``` ```bash {   \"jobInstanceId\": \"$expire_mssql_download_ranges_job_id\" } ```  To get the deletion status of downloaded recoverable range, perform GET on  [`/mssql/db/recoverable_range/download/{id}`](#operation/getDeleteMssqlDbRecoverableRangesStatusV1).  ```bash curl -X GET \\ \"https://$cluster_address/api/v1/mssql/db/recoverable_range/download/$expire_mssql_download_ranges_job_id\" ```  ```bash {   \"id\": \"$expire_mssql_download_ranges_job_id\"   \"status\": \"SUCCEEDED\",   \"startTime\": \"$job_start_time\",   \"endTime\": \"$job_end_time\",   \"jobType\": \"EXPIRE_MSSQL_DOWNLOADED_RANGES\",   \"nodeId\": \"$node_id\",   \"isDisabled\": $is_disabled,   \"archived\": $archived } ```  To get the default SQL Server database backup properties, perform GET on  [`/mssql/db/defaults`](#operation/getDefaultDbPropertiesV1).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/defaults\" ```  ```bash {   \"logBackupFrequencyInSeconds\": $log_backup_frequency,   \"cbtStatus\": $cbt_status,   \"logRetentionTimeInHours\": $log_retention_time } ```  To update the default SQL Server database backup properties, perform PATCH on  [`/mssql/db/defaults`](#operation/updateDefaultDbPropertiesV1).  ```bash curl -X PATCH \"https://$cluster_address/api/v1/mssql/db/defaults\" -d\\  '{     \"logBackupFrequencyInSeconds\": 900,     \"cbtStatus\": true,     \"logRetentionTimeInHours\": 168   }' ```  ```bash {   \"logBackupFrequencyInSeconds\": 900,   \"cbtStatus\": true,   \"logRetentionTimeInHours\": 168 } ```  ## Restore  Perform a restore with a POST on [`/mssql/db/{id}/restore`](#operation/createRestoreMssqlDb) specifying the timestamp as the recovery point.  ```bash curl -X POST -d \\   '{     \"recoveryPoint\": {       \"timestampMs\": 12345     }   }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/restore\" ```  A database can also be exported to another instance with a POST on [`/mssql/db/{id}/export`](#operation/createExportMssqlDb).  ```bash curl -X POST -d \\   '{     \"recoveryPoint\": {       \"timestampMs\": 12345     },     \"targetInstanceId\": \"$instance_id\",     \"targetDatabaseName\": \"$db_name\"   }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/export\" ```  List of all the database files which are needed to restore a SQL Server  database can be found by GET on  [/mssql/db/{id}/restore_files](#operation/mssqlGetRestoreFilesV1).    ```bash   curl -X GET \"https://$cluster_address/api/v1mssql/db/$db_id/restore_files?time=$time_to_restore\"   ```    ```bash   [     {       \"logicalName\": \"$logical_file_name\",       \"originalPath\": \"$original_file_path\",       \"originalName\": \"$original_file_name\",       \"fileType\": \"Data\",       \"fileId\": $file_id     },     {       \"logicalName\": \"$logical_file_name\",       \"originalPath\": \"$original_file_path\",       \"originalName\": \"$original_file_name\",       \"fileType\": \"Log\",       \"fileId\": $file_id     }   ]   ```  An estimate of resources needed for restoring a SQL Server database can be  found by GET on  [/mssql/db/{id}/restore_estimate](#operation/mssqlRestoreEstimateV1).    ```bash   curl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id/restore_estimate?time=$time_to_restore\"   ```    ```bash   {     \"bytesFromCloud\": $bytes_from_cloud   }   ```  Get compatible instances for recovery of a SQL Server database by performing  GET on  [/mssql/db/{id}/compatible_instance](#operation/getCompatibleMssqlInstancesV1).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/$db_id/compatible_instance?recovery_type=$recovery_type\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"logBackupFrequencyInSeconds\": $log_backup_frequency,       \"logRetentionHours\": $log_backup_retention,       \"copyOnly\": $copy_only,       \"id\": \"$instance_id\",       \"internalTimestamp\": $internal_timestamp,       \"name\": \"$instance_name\",       \"primaryClusterId\": \"$cluster_id\",       \"rootProperties\": {         \"rootType\": \"$root_type\",         \"rootId\": \"$root_id\",         \"rootName\": \"$root_name\"       },       \"version\": \"$version\",       \"configuredSlaDomainId\": \"$sla_domain_id\",       \"configuredSlaDomainType\": \"$sla_type\",       \"configuredSlaDomainName\": \"$sla_name\",       \"isRetentionLocked\": $is_retention_locked,       \"unprotectableReasons\": []     }   ],   \"total\": 1 } ```  ## Live Mount  Perform a Live Mount with a POST on [`/mssql/db/{id}/mount`](#operation/createMssqlMount), specifying the timestamp as the recovery point.  ```bash curl -X POST -d \\   '{     \"recoveryPoint\": {       \"timestampMs\": 12345     },     \"mountedDatabaseName\": \"$db_name\"   }' \\   \"https://$cluster_address/api/v1/mssql/db/$db_id/mount\" ```  All current Live Mounts can be found with a GET on [`/mssql/db/mount`](#operation/queryMssqlMount).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/mount\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$mount_id\",       \"sourceDatabaseId\": \"$source_db_id\",       \"sourceRecoveryPoint\": {         \"timestampMs\": 12345       },       \"targetInstanceId\": \"$target_instance_id\",       \"creationDate\": \"2017-02-02T18:53:12.694Z\",       \"isReady\": true,       \"mountedDatabaseId\": \"$mounted_db_id\"     }   ],   \"total\": 1 } ```  Further details for a single Live Mount are acquired from [`/mssql/db/mount/{id}`](#operation/getMssqlMount).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/mount/$mount_id\" ```  ```bash {   \"id\": \"$mount_id\",   \"sourceDatabaseId\": \"$source_db_id\",   \"sourceRecoveryPoint\": {     \"timestampMs\": 12345   },   \"targetInstanceId\": \"$target_instance_id\",   \"creationDate\": \"2017-02-02T18:53:12.694Z\",   \"isReady\": true,   \"mountedDatabaseId\": \"$mounted_db_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/$source_db_id\",       \"rel\": \"sourceDatabase\"     },     {       \"href\": \"https://$cluster_address/api/v1/mssql/instance/$target_instance_id\",       \"rel\": \"targetInstance\"     },     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/$mounted_db_id\",       \"rel\": \"mountedDatabase\"     }   ], } ```  Delete a Live Mount with a DELETE on [`/mssql/db/mount/{id}`](#operation/createMssqlUnmount).  ```bash curl -X DELETE \"https://$cluster_address/api/v1/mssql/db/mount/$mount_id\" ```  ## Log Shipping  Create a Log Shipping Configuration with a POST on [`/mssql/db/{id}/log_shipping`](#operation/createLogShippingConfiguration).  ```bash curl -X POST -d \\   '{     \"config\": {       \"targetInstanceId\": \"$target_instance_id\",       \"targetDatabaseName\": \"$db_name\",       \"state\": \"$state\"     }   }' \\   \"https://$cluster_address/api/v1/mssql/db/{id}/log_shipping\" ```  All current Log Shipping Configurations can be found with a GET on [`/mssql/db/log_shipping`](#operation/queryLogShippingConfigurations).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/log_shipping\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$log_shipping_id\",       \"lastAppliedPoint\": \"2017-02-02T18:53:12.694Z\",       \"location\": \"$host_name/$instance_name\",       \"primaryDatabaseId\": \"$primary_db_id\",       \"primaryDatabaseName\": \"$primary_database_name\",       \"secondaryDatabaseName\": \"$secondary_database_name\",       \"secondaryDatabaseId\": \"$secondary_database_id\",       \"state\": \"$state\",       \"status\": \"OK\"     }   ],   \"total\": 1 } ```  Further details for a single Log Shipping configuration are acquired from [`/mssql/db/log_shipping/{id}`](#operation/getLogShippingConfiguration).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/db/log_shipping/{id}\" ```  ```bash {   \"id\": \"$log_shipping_id\",   \"lastAppliedPoint\": \"2017-02-02T18:53:12.694Z\",   \"location\": \"$host_name/$instance_name\",   \"primaryDatabaseId\": \"$primary_db_id\",   \"primaryDatabaseName\": \"$primary_database_name\",   \"secondaryDatabaseName\": \"$secondary_database_name\",   \"secondaryDatabaseId\": \"$secondary_database_id\",   \"state\": \"$state\",   \"status\": \"OK\"   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/$primary_db_id\",       \"rel\": \"primaryDatabase\"     },     {       \"href\": \"https://$cluster_address/api/v1/mssql/instance/$secondary_instance_id\",       \"rel\": \"secondaryInstance\"     },     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/$secondary_db_id\",       \"rel\": \"secondaryDatabase\"     }   ], } ```  Update a Log Shipping Configuration with a PATCH on [`/mssql/db/log_shipping/{id}`](#operation/updateLogShippingConfiguration).  ```bash curl -X PATCH -d \\   '{     \"config\": {       \"state\": \"$state\"     }   }' \\   \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  Delete a Log Shipping Configuration with a DELETE on [`/mssql/db/log_shipping/{id}`](#operation/deleteLogShippingConfiguration).  ```bash curl -X DELETE \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id?delete_secondary_database=true\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  Reseed a Log Shipping Configuration with a POST on [`/mssql/db/log_shipping/{id}/reseed`](#operation/reseedSecondary)  ```bash curl -X POST -d \\   '{     \"config\": {       \"state\": \"$state\"     }   }' \\   \"https://$cluster_address/api/v1/mssql/db/log_shipping/$id/reseed\" ```  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/mssql/db/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  # Hierarchy  This REST API is used to get SQL Server hierarchy objects.  ### Get list of immediate descendant objects Get a list of immediate descendant objects using a GET request to [/mssql/hierarchy/{id}/children]\\ (#operation/getMssqlHierarchyChildren).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}/children\" ```  ```bash {   \"data\": [     {       \"id\": \"$database_id\",       \"name\": \"$database_name\",       \"objectType\": \"MssqlDatabase\",       \"descendantCount\": {},       \"hasPermissions\": true,       \"isInAvailabilityGroup\": false,       \"isLiveMount\": false,       \"isLogShippingSecondary\": false,       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"INHERIT\",       \"effectiveSlaDomainName\": \"Inherit\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Get list of descendant objects Get a list of descendant objects using a GET request to [/mssql/hierarchy/{id}/descendants]\\ (#operation/getMssqlHierarchyDescendants).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}/descendants\" ```  ```bash {   \"data\": [     {       \"id\": \"$database_id\",       \"name\": \"$database_name\",       \"objectType\": \"MssqlDatabase\",       \"descendantCount\": {},       \"hasPermissions\": true,       \"isInAvailabilityGroup\": false,       \"isLiveMount\": false,       \"isLogShippingSecondary\": false,       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"effectiveSlaDomainId\": \"INHERIT\",       \"effectiveSlaDomainName\": \"Inherit\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Get an object Get an object in the hierarchy using a GET request to [/mssql/hierarchy/{id}]\\ (#operation/getMssqlHierarchyObject).  ```bash curl -X GET \"https://$cluster_address/api/v1/mssql/hierarchy/{id}\" ```  ```bash {   \"id\": \"$database_id\",   \"name\": \"$database_name\",   \"objectType\": \"MssqlDatabase\",   \"descendantCount\": {},   \"hasPermissions\": true,   \"isInAvailabilityGroup\": false,   \"isLiveMount\": false,   \"isLogShippingSecondary\": false,   \"configuredSlaDomainId\": \"INHERIT\",   \"configuredSlaDomainName\": \"Inherit\",   \"effectiveSlaDomainId\": \"INHERIT\",   \"effectiveSlaDomainName\": \"Inherit\" } ``` ## Host configurations  ### Retrieving SQL Server host configurations To retrieve all the SQL Server host configurations, send a GET request to  [`/mssql/host/configuration`](#operation/queryMssqlHostConfig).  ```bash curl -X GET \"https://$cluster_address/api/v1//mssql/host/configuration\" ```  The Rubrik REST API server responds with a list of all the SQL Server host  configurations. ```bash {   \"data\": [     {       \"hostId\": \"hostId\",       \"enableDatabaseBatchSnapshots\": \"Enabled\",       \"enableVdi\": \"Enabled\",       \"enableVdiDb\": \"Enabled\",       \"enableGroupFetch\": \"Enabled\",       \"enableCbtBackup\": \"Enabled\",       \"physicalHostLogBackupThrottleMaxRefCount\": 10,       \"throttlePhysicalHostMaxRefCount\": 3,       \"fileTransferParallelism\": 8,       \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,       \"fileRestoreReadParallelism\": 16,       \"fileRestoreWriteParallelism\": 4     }   ],   \"hasMore\": false,   \"total\": 1 } ```  To retrieve the configuration of a specific SQL Server host, send a GET  request to  [`/mssql/host/configuration/{host_id}`](#operation/getMssqlHostConfig).  ```bash curl -X GET \"https://$cluster_address/api/v1//mssql/host/configuration/{host_id}\" ```  The Rubrik REST API server responds with the configuration details of the  specified SQL Server host.  ```bash {   \"enableDatabaseBatchSnapshots\": \"Enabled\",   \"enableVdi\": \"Enabled\",   \"enableVdiDb\": \"Enabled\",   \"enableGroupFetch\": \"Enabled\",   \"enableCbtBackup\": \"Enabled\",   \"physicalHostLogBackupThrottleMaxRefCount\": 10,   \"throttlePhysicalHostMaxRefCount\": 3,   \"fileTransferParallelism\": 8,   \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,   \"fileRestoreReadParallelism\": 16,   \"fileRestoreWriteParallelism\": 4 } ```   ### Creating a SQL Server host configuration To create a new SQL Server host configuration, send a POST request to  [`/mssql/host/configuration`](#operation/createMssqlHostConfig).  ```bash curl -X POST -d \\  '{    \"hostId\": \"hostId\",    \"enableDatabaseBatchSnapshots\": \"Enabled\",    \"enableVdi\": \"Enabled\",    \"enableVdiDb\": \"Enabled\",    \"enableGroupFetch\": \"Enabled\",    \"enableCbtBackup\": \"Enabled\",    \"physicalHostLogBackupThrottleMaxRefCount\": 10,    \"throttlePhysicalHostMaxRefCount\": 3,    \"fileTransferParallelism\": 8,    \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,    \"fileRestoreReadParallelism\": 16,    \"fileRestoreWriteParallelism\": 4  }' \\ \"https://$cluster_address/api/v1/mssql/host/configuration\" ```  The Rubrik REST API server responds with the details of the new SQL Server  host configuration. ```bash {   \"hostId\": \"hostId\",   \"enableDatabaseBatchSnapshots\": \"Enabled\",   \"enableVdi\": \"Enabled\",   \"enableVdiDb\": \"Enabled\",   \"enableGroupFetch\": \"Enabled\",   \"enableCbtBackup\": \"Enabled\",   \"physicalHostLogBackupThrottleMaxRefCount\": 10,   \"throttlePhysicalHostMaxRefCount\": 3,   \"fileTransferParallelism\": 8,   \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,   \"fileRestoreReadParallelism\": 16,   \"fileRestoreWriteParallelism\": 4 } ```  ### Updating a SQL Server host configuration To update the configuration of a specific SQL Server host, send a PATCH  request to  [`/mssql/host/configuration/{host_id}`](#operation/updateMssqlHostConfig).  ```bash curl -X PATCH -d \\  '{    \"enableDatabaseBatchSnapshots\": true,    \"enableVdi\": true,    \"enableVdiDb\": false,    \"enableGroupFetch\": false,    \"enableCbtBackup\": false,    \"physicalHostLogBackupThrottleMaxRefCount\": 10,    \"throttlePhysicalHostMaxRefCount\": 3,    \"fileTransferParallelism\": 8,    \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,    \"fileRestoreReadParallelism\": 16,    \"fileRestoreWriteParallelism\": 4  }' \\ \"https://$cluster_address/api/v1//mssql/host/configuration/{host_id}\" ```  The Rubrik REST API server responds with the updated configuration details of  the specified SQL Server host.  ```bash {   \"enableDatabaseBatchSnapshots\": \"Enabled\",   \"enableVdi\": \"Enabled\",   \"enableVdiDb\": \"Enabled\",   \"enableGroupFetch\": \"Enabled\",   \"enableCbtBackup\": \"Enabled\",   \"physicalHostLogBackupThrottleMaxRefCount\": 10,   \"throttlePhysicalHostMaxRefCount\": 3,   \"fileTransferParallelism\": 8,   \"mssqlDefaultMaxDataStreamsPerDatabase\": 2,   \"fileRestoreReadParallelism\": 16,   \"fileRestoreWriteParallelism\": 4 } ```  ### Deleting a SQL Server host configuration To delete a specific SQL Server host configuration, send a DELETE request to  [`/mssql/host/configuration/{host_id}`](#operation/deleteMssqlHostConfig).  ```bash curl -X DELETE \"https://$cluster_address/api/v1/mssql/host/configuration/{host_id}\" ```  The Rubrik REST API server deletes the specified SQL Server host configuration.  # Oracle Databases  ## Delete Downloaded Oracle Db Snapshots and Log Snapshots  To request an asynchronous job to expire downloaded database snapshots taken during a specified time period as well as log snapshots that contain any logs with timestamps within that time period, send a DELETE request to the [`/oracle/db/{id}/downloaded_snapshots`](#operation/deleteDownloadedSnapshots) endpoint with optional query parameters before_time and after_time.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/oracle/db/{id}/downloaded_snapshots?before_time=2016-01-01T01:23:45.678&after_time=2016-01-01T01:23:45.678\"   ``` An async request is returned and can be polled to retrieve the job status.  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/internal/oracle/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  ## Provide Estimate for Restore Operation Download  To request the number of bytes that must be downloaded for a restore operation for an Oracle database, send a GET request to the [`/oracle/db/{id}/restore_estimate`](#operation/oracleRestoreEstimate) endpoint with the snapshot ID or the time to be restored to.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/oracle/db/{id}/restore_estimate?recovery_time=2016-01-01T01:23:45.678\" ``` An OracleRestoreEstimateResult object is returned which stores the number of bytes which are needed to restore.  ```bash {   \"bytesToRestore\": \"$bytesToRestore\", } ```  ## Bulk Update Oracle Databases  To update a list of Oracle Databases in bulk, send a PATCH request to the [`/oracle/db/bulk`](#operation/bulkUpdateOracleDb) endpoint with a bulk_update_properties to complete a update.  ```bash curl -X PATCH \\   -d '{     \"ids\": \"$ids\",     \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",     \"logRetentionHours\": \"$logRetentionHours\",     \"hostLogRetentionHours\": \"$hostLogRetentionHours\",     \"numChannels\": \"$numChannels\",     \"hostMount\": \"string\",     \"configuredSlaDomainIdDeprecated\": \"string\",     \"nodeOrder\": [       {         \"nodeName\": \"string\",         \"order\": 0       }     ]   }' \\   \"https://$cluster_address/api/v1/oracle/db/bulk\" ```  A BulkOracleDbDetails object contains an array of OracleDbDetail is returned.  ## Bulk Update Oracle Hosts  To update a list of Oracle hosts in bulk, send a PATCH request to the [`/oracle/host/bulk`](#operation/bulkUpdateOracleHost) endpoint with a bulk_update_properties to complete a update.  ```bash curl -X PATCH \\   -d '{     \"ids\": \"$ids\",     \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",     \"logRetentionHours\": \"$logRetentionHours\",     \"hostLogRetentionHours\": \"$hostLogRetentionHours\",     \"numChannels\": \"$numChannels\",     \"hostMount\": \"string\",     \"configuredSlaDomainIdDeprecated\": \"string\",     \"nodeOrder\": [       {         \"nodeName\": \"string\",         \"order\": 0       }     ]   }' \\   \"https://$cluster_address/api/v1/oracle/host/bulk\" ```  A BulkOracleHostDetails object contains an array of OracleHostDetail is returned.  ## Bulk Update Oracle RACs  To update a list of Oracle RACs in bulk, send a PATCH request to the [`/oracle/rac/bulk`](#operation/bulkUpdateOracleRac) endpoint with a bulk_update_properties to complete a update.  ```bash curl -X PATCH \\   -d '{     \"ids\": \"$ids\",     \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",     \"logRetentionHours\": \"$logRetentionHours\",     \"hostLogRetentionHours\": \"$hostLogRetentionHours\",     \"numChannels\": \"$numChannels\",     \"hostMount\": \"string\",     \"configuredSlaDomainIdDeprecated\": \"string\",     \"nodeOrder\": [       {         \"nodeName\": \"string\",         \"order\": 0       }     ]   }' \\   \"https://$cluster_address/api/v1/oracle/rac/bulk\" ```  A BulkOracleRacDetails object contains an array of OracleRacDetail is returned.  ## Trigger a ORACLE_VALIDATE_BACKUP job to validate backups of selected recovery point on a choosing Oracle host  To request an asynchronous job to validate backups of selected recovery point on a choosing Oracle host or Oracle RAC, send a POST request to the [`/oracle/db/{id}/validate`](#operation/createOracleValidateBackupJob) endpoint with a OracleValidateConfig.  ```bash curl -X POST \\   -d '{     \"config\": {       \"recoveryPoint\": { \"timestampMs\": 12345 },       \"targetOracleHostOrRacId\": \"54321\":,       \"sgaMaxSize\": 4,       \"targetOracleHome\": \"/fullpath/for/oracleHome\",       \"targetMountPath\": \"/fullpath/for/mountPath\",       \"numChannels\": 4     }   }' \\   \"https://$cluster_address/api/v1/oracle/db/{id}/validate   ``` An async request is returned and can be polled to retrieve the job status.  ```bash {   \"id\": \"$request_id\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/internal/oracle/request/$request_id\",       \"rel\": \"self\"     }   ],   \"status\": \"QUEUED\" } ```  ## Get a download link of example Advanced Recovery Options file  To get a link to download an example Advanced Recovery Options file, send a GET request to the [`/oracle/aco_example_download_link`](#operation/getExampleAcoDownloadLink) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/oracle/aco_example_download_link\" ```  An OracleFileDownloadLink object is returned which has a link to download the sample Advanced Recovery Options file.  ## Update Oracle Data Guard Group  To update an Oracle Data Guard group, send a PATCH request to the [`/oracle/data_guard_group/{id}`](#operation/updateOracleDataGuardGroup) endpoint. Edit the update_properties field with the properties to be updated.  ```bash curl -X PATCH \\   -d '{     \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",     \"logRetentionHours\": \"$logRetentionHours\",     \"hostLogRetentionHours\": \"$hostLogRetentionHours\",     \"numChannels\": \"$numChannels\",     \"hostMount\": \"string\",     \"shouldBackupFromPrimaryOnly\": false,     \"preferredDGMemberUniqueNames\": [\"unique_name\"]     ]   }' \\   \"https://$cluster_address/api/v1/oracle/data_guard_group/{id}\" ```  The Rubrik REST API server responds with an OracleDbDetail object containing information about the Data Guard group. ```bash {   \"id\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",   \"name\": \"rbk\",   \"configuredSlaDomainId\": \"INHERIT\",   \"configuredSlaDomainName\": \"Inherit\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",   \"isConfiguredSlaDomainRetentionLocked\": false,   \"effectiveSlaDomainId\": \"UNPROTECTED\",   \"effectiveSlaDomainName\": \"Unprotected\",   \"isEffectiveSlaDomainRetentionLocked\": false,   \"effectiveSlaSourceObjectId\": \"Global:::All\",   \"slaAssignment\": \"Unassigned\",   \"retentionSlaDomainId\": \"UNPROTECTED\",   \"infraPath\": [],   \"isRelic\": false,   \"numTablespaces\": 0,   \"logBackupFrequencyInMinutes\": 0,   \"numMissedSnapshot\": 0,   \"includeBackupTaskInfo\": true,   \"isDbLocalToTheCluster\": true,   \"hostLogRetentionHours\": 0,   \"isArchiveLogModeEnabled\": true,   \"dbUniqueName\": \"DG_rbk\",   \"dataGuardType\": \"DataGuardGroup\",   \"dataGuardGroupMembers\": [     {       \"dbUniqueName\": \"rbk\",       \"role\": \"PRIMARY\",       \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",       \"standaloneHostName\": \"oel75-121-dg-primary-20210421023956\"     }   ],   \"logRetentionHours\": 720,   \"numChannels\": 1,   \"hostMount\": \"/var/rubrik/oracle\",   \"tablespaces\": [],   \"snapshotCount\": 0,   \"isLiveMount\": false,   \"hostsInfo\": [     {       \"id\": \"Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\",       \"hostname\": \"10.0.188.224\",       \"oracleSysDbaUser\": \"oracle\",       \"oracleQueryUser\": \"oracle\"     }   ],   \"shouldBackupFromPrimaryDGGroupMemberOnly\": true,   \"preferredDGMemberUniqueNames\": [] } ```  ## Retrieving Oracle databases ### Retrieving a summary of all Oracle databases  To get a list of Oracle databases, send a GET request to the [`/oracle/db`](#operation/queryOracleDbV1) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/oracle/db\" ```  The Rubrik REST API server responds with a list of OracleDbSummary objects containing information about the databases.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\",       \"name\": \"rbk\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",       \"isConfiguredSlaDomainRetentionLocked\": false,       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"isEffectiveSlaDomainRetentionLocked\": false,       \"effectiveSlaSourceObjectId\": \"Global:::All\",       \"slaAssignment\": \"Unassigned\",       \"retentionSlaDomainId\": \"UNPROTECTED\",       \"infraPath\": [         {           \"name\": \"oel75-121-dg-primary-20210421023956\",           \"id\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\"         }       ],       \"isRelic\": false,       \"numTablespaces\": 5,       \"numMissedSnapshot\": 0,       \"includeBackupTaskInfo\": false,       \"isDbLocalToTheCluster\": true,       \"hostLogRetentionHours\": 0,       \"sid\": \"rbk\",       \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",       \"numInstances\": 1,       \"instances\": [         {           \"hostName\": \"10.0.188.224\",           \"instanceSid\": \"rbk\"         }       ],       \"isArchiveLogModeEnabled\": true,       \"standaloneHostName\": \"oel75-121\",       \"archiveLogDestinations\": [         \"\"       ],       \"isPrimary\": true,       \"dbUniqueName\": \"rbk\",       \"databaseRole\": \"PRIMARY\",       \"dataGuardType\": \"DataGuardMember\",       \"dataGuardGroupId\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",       \"dataGuardGroupName\": \"DG_rbk\"     }   ],   \"total\": 1 } ```  ### Retrieving detailed information for a specific Oracle database  To get detailed information about an Oracle Database, send a GET request to the [`/oracle/db/{id}`](#operation/getOracleDbV1) endpoint where, {id} is the ID of the Oracle database.  ```bash curl -X GET \"https://$cluster_address/api/v1/oracle/db/$oracle_database_id\" ```  The Rubrik REST API server responds with an OracleDbDetail object containing information about the specified  database.  ```bash {   \"id\": \"OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\",   \"name\": \"rbk\",   \"configuredSlaDomainId\": \"INHERIT\",   \"configuredSlaDomainName\": \"Inherit\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",   \"isConfiguredSlaDomainRetentionLocked\": false,   \"effectiveSlaDomainId\": \"UNPROTECTED\",   \"effectiveSlaDomainName\": \"Unprotected\",   \"isEffectiveSlaDomainRetentionLocked\": false,   \"effectiveSlaSourceObjectId\": \"Global:::All\",   \"slaAssignment\": \"Unassigned\",   \"retentionSlaDomainId\": \"UNPROTECTED\",   \"infraPath\": [     {       \"name\": \"oel75-121-dg-primary-20210421023956\",       \"id\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\"     }   ],   \"isRelic\": false,   \"numTablespaces\": 5,   \"logBackupFrequencyInMinutes\": 0,   \"numMissedSnapshot\": 0,   \"includeBackupTaskInfo\": true,   \"isDbLocalToTheCluster\": true,   \"hostLogRetentionHours\": 0,   \"sid\": \"rbk\",   \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",   \"numInstances\": 1,   \"instances\": [     {       \"hostName\": \"10.0.188.224\",       \"instanceSid\": \"rbk\"     }   ],   \"isArchiveLogModeEnabled\": true,   \"standaloneHostName\": \"oel75-121-dg-primary-20210421023956\",   \"archiveLogDestinations\": [     \"\"   ],   \"isPrimary\": true,   \"dbUniqueName\": \"rbk\",   \"databaseRole\": \"PRIMARY\",   \"dataGuardType\": \"DataGuardMember\",   \"dataGuardGroupId\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",   \"dataGuardGroupName\": \"DG_rbk\",   \"logRetentionHours\": 720,   \"numChannels\": 1,   \"hostMount\": \"/var/rubrik/oracle\",   \"tablespaces\": [     \"SYSAUX\",     \"SYSTEM\",     \"UNDOTBS1\",     \"USERS\",     \"TEMP\"   ],   \"snapshotCount\": 0,   \"oracleHome\": \"/u01/app/oracle/product/12.1.0.2/dbhome_1\",   \"isLiveMount\": false,   \"hostsInfo\": [     {       \"id\": \"Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\",       \"hostname\": \"10.0.188.224\",       \"oracleSysDbaUser\": \"oracle\",       \"oracleQueryUser\": \"oracle\"     }   ] } ```  ## Updating Oracle Database  To update an Oracle database, send a PATCH request to the [`/oracle/db/{id}`](#operation/updateOracleDbV1) endpoint. Edit the update_properties field with the properties to be updated.  ```bash curl -X PATCH \\   -d '{     \"logBackupFrequencyInMinutes\": \"$logBackupFrequencyInMinutes\",     \"logRetentionHours\": \"$logRetentionHours\",     \"hostLogRetentionHours\": \"$hostLogRetentionHours\",     \"numChannels\": \"$numChannels\",     \"hostMount\": \"$hostMount\"     ]   }' \\   \"https://$cluster_address/api/v1/oracle/db/$oracle_database_id\" ```  The Rubrik REST API server responds with an OracleDbDetail object containing information about the updated database. ```bash {   \"id\": \"OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\",   \"name\": \"rbk\",   \"configuredSlaDomainId\": \"INHERIT\",   \"configuredSlaDomainName\": \"Inherit\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"55a8c22c-424c-41ee-91e0-94c282281e4b\",   \"isConfiguredSlaDomainRetentionLocked\": false,   \"effectiveSlaDomainId\": \"UNPROTECTED\",   \"effectiveSlaDomainName\": \"Unprotected\",   \"isEffectiveSlaDomainRetentionLocked\": false,   \"effectiveSlaSourceObjectId\": \"Global:::All\",   \"slaAssignment\": \"Unassigned\",   \"retentionSlaDomainId\": \"UNPROTECTED\",   \"infraPath\": [     {       \"name\": \"oel75-121-dg-primary-20210421023956\",       \"id\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\"     }   ],   \"isRelic\": false,   \"numTablespaces\": 5,   \"logBackupFrequencyInMinutes\": 0,   \"numMissedSnapshot\": 0,   \"includeBackupTaskInfo\": true,   \"isDbLocalToTheCluster\": true,   \"hostLogRetentionHours\": 0,   \"sid\": \"rbk\",   \"standaloneHostId\": \"OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\",   \"numInstances\": 1,   \"instances\": [     {       \"hostName\": \"10.0.188.224\",       \"instanceSid\": \"rbk\"     }   ],   \"isArchiveLogModeEnabled\": true,   \"standaloneHostName\": \"oel75-121-dg-primary-20210421023956\",   \"archiveLogDestinations\": [     \"\"   ],   \"isPrimary\": true,   \"dbUniqueName\": \"rbk\",   \"databaseRole\": \"PRIMARY\",   \"dataGuardType\": \"DataGuardMember\",   \"dataGuardGroupId\": \"OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\",   \"dataGuardGroupName\": \"DG_rbk\",   \"logRetentionHours\": 720,   \"numChannels\": 1,   \"hostMount\": \"/var/rubrik/oracle\",   \"tablespaces\": [     \"SYSAUX\",     \"SYSTEM\",     \"UNDOTBS1\",     \"USERS\",     \"TEMP\"   ],   \"snapshotCount\": 0,   \"oracleHome\": \"/u01/app/oracle/product/12.1.0.2/dbhome_1\",   \"isLiveMount\": false,   \"hostsInfo\": [     {       \"id\": \"Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\",       \"hostname\": \"10.0.188.224\",       \"oracleSysDbaUser\": \"oracle\",       \"oracleQueryUser\": \"oracle\"     }   ] } ```  ## Get Oracle Advanced Cloning Options (ACO) parameters  To get a list of supported ACO parameter names, send a GET request to the [`/oracle/aco_parameter_list`](#operation/getAcoParameterList) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/oracle/aco_parameter_list\" ```  The Rubrik REST API server responds with an OracleAcoParameterList object which contains the list of supported ACO parameter names.  ## Validate an Oracle Advanced Cloning Options (ACO) config file  To validate an ACO file, send a POST request to the [`/oracle/validate_aco_file`](#operation/validateOracleAcoFile) endpoint. Send the base 64 encoded string of the ACO file contents in the body and a boolean determining whether the ACO file is for a Live Mount or not, as a query parameter. ```bash curl -X POST \\   -d '{     \"aco_contents_base64\": \"$aco_contents_base64\"   }' \\   \"https://$cluster_address/api/v1/oracle/validate_aco_file?is_live_mount={is_live_mount} ```  The Rubrik REST API server validates the given ACO file contents and returns an OracleAcoValidationResult containing the validation result of the ACO file given.  # vApps  The Rubrik cluster protects vApps running in a VMware vCloud Director environment through the vCloud Director REST APIs. The Rubrik cluster must connect to the underlying vCenter servers to protect vApps.  ## vApp Templates  The Rubrik cluster protects vApp template objects through the vCloud Director APIs.  ## vCloud Director server  A Rubrik cluster protects and manages vApps and vApp templates through the vCloud Director server that administers those vApps. After a vCloud Director server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the vApps administered under the server.  ### Retrieving details for a vApp template snapshot export  To retrieve the options available for exporting a specified vApp template snapshot to an organization vDC and available storage policies, send a GET request to [`/vcd/vapp/template/snapshot/{snapshot_id}/export/options`](#operation/getVappTemplateSnapshotExportOptions).  To filter the results of the GET request sent to the  [`/vcd/vapp/template/snapshot/{snapshot_id}/export/options`](#operation/getVappTemplateSnapshotExportOptions) endpoint, configure the following query parameters before sending the request.  | Parameter  | Required | Type   | Description | | ---------- | -------- | ------ | ----------- | |`catalog_id`| Required | string | ID of the target Catalog object.| |`name`      | Required | string | Name of template object to be created. This is used to verify the existence of a template with the given name. Templates must have unique names. |`org_vdc_id`| Optional | string | ID assigned to a target organization VDC object. This parameter is required when advanced export options are used.  A vApp template export targets a catalog and requires a valid storage policy and organization vDC. There are three options available for export of a vApp template -  * **OriginalVdcExportOptions** - This option is used to export to the original organization vDC of the vApp template   when the snapshot was taken. Only available when the catalog to export is under the same organization as the original   organization vDC and the vDC is still active.   `org_vdc_id` is not required when using this option. * **DefaultCatalogExportOptions** - This option is used to export to the vDC corresponding to the default storage policy   of the catalog. This option is unavailable for catalogs that do not have storage policies.   `org_vdc_id` is not required when using this option. * **AdvancedExportOptions** - This option is used to export to a specific organization vDC under the same organization   as the Catalog to export. The GET request returns the choices of storage policies available.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/vcd/vapp/template/snapshot/$snapshot_id/export/options?catalog_id=$catalog_id&name=$template_name\" ```  The Rubrik REST API responds with a `VappTemplateExportOptionsUnion` object which has fields for all the above options.  **Note:** To shorten the example, the response uses ellipses to replace some members.  ```bash {   \"hasMore\": false,   \"originalVdcExportOptions\" :     {       \"orgVdcId\": \"$org_vdc_id1\",       \"availableStoragePolicies\": [         ...       ]     },    \"defaultCatalogExportOptions\" :     {       \"orgVdcId\": \"$org_vdc_id1\",       \"availableStoragePolicies\": [         ...       ]     },    \"advancedExportOptions\" :     {       \"orgVdcId\": \"$org_vdc_id1\",       \"availableStoragePolicies\": [         ...       ]     } } ```  ### Exporting a vApp template snapshot  To create a new vApp template in a catalog using the export feature, send a POST request to the  [`/vcd/vapp/template/snapshot/{snapshot_id}/export`](#operation/createVappTemplateSnapshotExport) endpoint. The request takes the snapshot_id as a path parameter. The request payload includes the parameters described in the  following table.  | Name            | Required | Type   | Description | | --------------- | -------- | ------ | ----------- | |`name`           | Required | string | Name of vApp template to be created.| |`catalogId`      | Required | string | ID of the Catalog where the vApp template is created.| |`orgVdcId`       | Required | string | ID of the organization vDC where the vApp template is created.| |`storagePolicyId`| Required | string | ID of the organization vDC storage policy to be used. In case a storage policy ID is not provided, the default storage policy of the organization vDC is used.  **Note:** The Catalog and organization vDC must belong to the same organization. When providing a storage policy, that storage policy must be present in the organization vDC.  ```bash curl -X POST -d \\   '{     \"name\": \"$template_name\",     \"catalogId\": \"$catalog_id\",     \"orgVdcId\": \"$org_vdc_id\"    }' \\    \"https://$cluster_address/api/v1/vcd/vapp/template/snapshot/$snapshot_id/export\" ```  The Rubrik REST API server initiates the asynchronous request task and responds with the the details of the AsyncRequestStatus request.  ```bash {   \"id\": \"$request_id\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$timestamp\",   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$request_id\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving summary of vApps  To retrieve the summary information for all vCD vApp objects, send a GET request to the [`/vcd/vapp`](#operation/queryVcdVappsV1) endpoint. The parameters described in the following table are available to  filter the results of the GET request.  | Name                     | Required | Type    | Description | | ------------------------ | -------- | ------- | ----------- | |`sort_by`                 | Optional | string  | Attribute to sort the vCD vApp list on.| |`sort_order`              | Optional | string  | Order for sorting the results, either ascending or descending.| |`limit`                   | Optional | int     | Limit the number of matches returned.| |`offset`                  | Optional | int     | Number of matches to ignore from the beginning of the results.| |`name`                    | Optional | string  | Search for a vCD vApp object by name.| |`is_relic`                | Optional | boolean | Filter by isRelic field of vCD vApp object. Returns both relic and non-relic vApps when this value is not specified.| |`effective_sla_domain_id` | Optional | string  | SLA Domain applied to the virtual machine, either directly or derived.| |`primary_cluster_id`      | Optional | string  | Filter by primary cluster ID, or **local**.| |`sla_assignment`          | Optional | string  | Filter by SLA assignment type.| |`include_backup_task_info`| Optional | boolean | Include backup task information in response.|   ```bash  curl -X GET \"https://$cluster_address/api/v1/vcd/vapp\"  ```  The Rubrik REST API server responds with a list of vApp objects that fit the specified parameters. The response is a  List of VcdVappSummary objects.   ```bash  {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$vappId\",       \"name\": \"$vappName\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": true,       \"slaLastUpdateTime\": \"$slaLastUpdateTime\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"isEffectiveSlaDomainRetentionLocked\": true,       \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",       \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",       \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",       \"slaAssignment\": \"Derived\",       \"retentionSlaDomainId\": \"$retentionSlaDomainId\",       \"vcdClusterId\": \"$vcdId\",       \"vcdClusterName\": \"$vcdClusterName\",       \"infraPath\": [         ...       ],       \"isRelic\": true,       \"numMissedSnapshot\": 0,       \"lastSnapshotTime\": \"$lastSnapshotTime\",       \"includeBackupTaskInfo\": true,       \"currentBackupTaskInfo\": {         \"taskStatus\": \"Queued\",         \"queueTime\": \"$queueTime\",         \"expectedEndTime\": \"$expectedEndTime\"       },       \"isTemplate\": true,       \"catalogId\": \"$catalogId\",       \"pendingSlaDomain\": {         \"objectId\": \"$objectId\",         \"pendingSlaDomainId\": \"$pendingSlaDomain\",         \"pendingSlaDomainName\": \"$pendingSlaDomainName\",         \"isPendingSlaDomainRetentionLocked\": true       }     }   ],   \"total\": 0 }  ```  ### Retrieving details for a specific vApp  To retrieve detailed information about a specific vApp, send a GET request to [`/vcd/vapp/{id}`](#operation/getVcdVappV1), where {id} is the ID of a vApp object.   ```bash  curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/{id}\"  ```  The Rubrik REST API server responds with the details (VcdVappDetail) of the specified vApp object.   ```bash {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2021-03-16T04:37:38.913Z\",   \"endTime\": \"2021-03-16T04:37:38.913Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] }  ```  ### Updating vApp  To make changes to the parameters of a specified vApp object, send a PATCH request to [`/vcd/vapp/{id}`](#operation/updateVcdVappV1), where {id} is the ID of the vApp object to be updated. The request payload of the PATCH request includes the parameters to be updated.  | Name |  Description | Notes |   | ---- | ------------ | ----- | | configured_sla_domain_id | ID of the SLA Domain object that manages protection for the specified vApp object. Existing snapshots of the vApp object will be retained with the configuration of the specified SLA Domain. | optional | | is_paused | Boolean value that indicates whether protection activity is paused for the specified vApp. Set to &#39;true&#39; when protection activity is paused and &#39;false&#39; when protection activity is not paused. Protection activity includes: backup, replication, and archiving. | optional | | is_best_effort_synchronization_enabled | Boolean value that indicates whether the Rubrik cluster should attempt taking synchronized snapshots across all child Virtual Machines of the vApp object. | optional | | vcd_vm_moids_to_exclude_from_snapshot | Array containing vCloud Director Virtual Machine moids that will be excluded from the vApp snapshots. | optional |  ```bash  curl -X PATCH -d \\   '{     \"configuredSlaDomainId\": \"$sla_domain_id\",     \"isPaused\": \"true\",     \"isBestEffortSynchronizationEnabled\": \"true\",     \"vcdVmMoidsToExcludeFromSnapshot\": \"$vm_moids_to_exclude\"    }' \\    \"https://$cluster_address/api/v1/vcd/vapp/{id}\"  ```  The Rubrik REST API server responds with the details (VcdVappDetail) of the updated vApp object.   ```bash {   \"configuredSlaDomainId\": \"INHERIT\",   \"isPaused\": true,   \"isBestEffortSynchronizationEnabled\": true,   \"vcdVmMoidsToExcludeFromSnapshot\": [     ...   ],   \"id\": \"$vappId\",   \"name\": \"$name\",   \"configuredSlaDomainName\": \"Inherit\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"$slaLastUpdateTime\",   \"effectiveSlaDomainId\": \"UNPROTECTED\",   \"effectiveSlaDomainName\": \"Unprotected\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"effectiveSlaSourceObjectName\",   \"slaAssignment\": \"Derived\",   \"retentionSlaDomainId\": \"$retentionSlaDomainId\",   \"vcdClusterId\": \"$vcdClusterId\",   \"vcdClusterName\": \"$vcdClusterName\",   \"infraPath\": [     ...   ],   \"isRelic\": true,   \"numMissedSnapshot\": 0,   \"lastSnapshotTime\": \"$lastSnapshotTime\",   \"includeBackupTaskInfo\": true,   \"currentBackupTaskInfo\": {     \"taskStatus\": \"Queued\",     \"queueTime\": \"$queueTime\",     \"expectedEndTime\": \"$expectedEndTime\"   },   \"isTemplate\": true,   \"catalogId\": \"$catalogId\",   \"pendingSlaDomain\": {     \"objectId\": \"$objectId\",     \"pendingSlaDomainId\": \"$pendingSlaDomainId\",     \"pendingSlaDomainName\": \"$pendingSlaDomainName\",     \"isPendingSlaDomainRetentionLocked\": true   },   \"networks\": [     ...   ],   \"vms\": [     ...   ] }  ```  ### Retrieving summary information for all vApp snapshots  ## vApp snapshots  To retrieve summary information for each of the snapshot objects of a specified vApp object, send a GET request to [`/vcd/vapp/{id}/snapshot`](#operation/queryVappSnapshotV1), where {id} is the ID of the vApp object.   ```bash  curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/{id}/snapshot\"  ```  The Rubrik REST API server responds with the details of all the snapshots of the specified vApp.  The response is a List of VcdVappSnapshotSummary objects.   ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$vappId\",       \"date\": \"$date\",       \"expirationDate\": \"$expirationDate\",       \"sourceObjectType\": \"$sourceObjectType\",       \"isOnDemandSnapshot\": true,       \"isCustomRetentionApplied\": true,       \"cloudState\": 0,       \"consistencyLevel\": \"#consistencyLevel\",       \"indexState\": 0,       \"replicationLocationIds\": [         \"string\"       ],       \"archivalLocationIds\": [         \"string\"       ],       \"slaId\": \"$slaId\",       \"slaName\": \"$slaName\",       \"isRetainedByRetentionLockSla\": true,       \"cloudStorageTier\": \"Hot\",       \"isPlacedOnLegalHold\": true,       \"snapshotRetentionInfo\": {         \"localInfo\": {           \"id\": \"string\",           \"name\": \"string\",           \"isSnapshotPresent\": true,           \"isExpirationDateCalculated\": true,           \"expirationTime\": \"$expirationTime\",           \"snapshotFrequency\": \"$snapshotFrequency\",           \"isExpirationInformationUnavailable\": true         },         \"archivalInfos\": [           {             \"id\": \"$id\",             \"name\": \"$name\",             \"isSnapshotPresent\": true,             \"isExpirationDateCalculated\": true,             \"expirationTime\": \"$expirationTime\",             \"snapshotFrequency\": \"$snapshotFrequency\",             \"isExpirationInformationUnavailable\": true           }         ],         \"replicationInfos\": [           {             \"id\": \"$id\",             \"name\": \"$name\",             \"isSnapshotPresent\": true,             \"isExpirationDateCalculated\": true,             \"expirationTime\": \"$expirationTime\",             \"snapshotFrequency\": \"$snapshotFrequency\",             \"isExpirationInformationUnavailable\": true           }         ],         \"cloudNativeLocationInfo\": [           {             \"id\": \"$id\",             \"name\": \"$name\",             \"isSnapshotPresent\": true,             \"isExpirationDateCalculated\": true,             \"expirationTime\": \"$expirationTime\",             \"snapshotFrequency\": \"$snapshotFrequency\",             \"isExpirationInformationUnavailable\": true           }         ]       },       \"parentSnapshotId\": \"$parentSnapshotId\",       \"vappName\": \"$vappName\",       \"isSynchronized\": true,       \"vmSnapshots\": [         {           \"vcenterVmId\": \"$vcenterVmId\",           \"vmSnapshotId\": \"$vmSnapshotId\",           \"vmName\": \"$vmName\",           \"vcdVmMoid\": \"$vcdVmMoid\",           \"indexState\": 0         }       ]     }   ],   \"total\": 0 }  ```  ## Creating an on-demand snapshot for a vApp  To create an on-demand snapshot for a specified vApp object, send a POST request to [`/vcd/vapp/{id}/snapshot`](#operation/createOnDemandSnapshotV1), where {id} is the ID of the vApp object.   ```bash  curl -X POST -d \"https://$cluster_address/api/v1/vcd/vapp/$id/snapshot\"  ```  The Rubrik REST API server initiates an asynchronous job to create an on-demand snapshot and returns the details of the AsyncRequestStatus request.   ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",       \"rel\": \"self\"     }   ] }  ```  ### Deleting all snapshots of a vApp object  To delete all snapshots for a specified vApp object, send a DELETE request to [`/vcd/vapp/{id}/snapshot`](#operation/deleteVappSnapshotsV1), where {id} is the ID of the vApp object whose snapshot needs to be deleted.   ```bash  curl -X DELETE -d \"https://$cluster_address/api/v1/vcd/vapp/$id/snapshot\"  ```  The Rubrik REST API server deletes all snapshots of the specified vApp.   ```bash {\"Snapshots deleted successfully.\"}  ```  ## Retrieving details about a specific vApp snapshot  To retrieve detailed information about a specified snapshot for a vApp object, send a GET request to [`/vcd/vapp/snapshot/{id}`](#operation/getVappSnapshotV1), where {id} is the ID of the snapshot object whose details are required.  ```bash  curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/{id}\"  ```  The Rubrik REST API server fetches details (VcdVappSnapshotDetail) of the specified vApp snapshot.   ```bash {   \"id\": \"$id\",   \"date\": \"$date\",   \"expirationDate\": \"$expirationDate\",   \"sourceObjectType\": \"$sourceObjectType\",   \"isOnDemandSnapshot\": true,   \"isCustomRetentionApplied\": true,   \"cloudState\": 0,   \"consistencyLevel\": \"$consistencyLevel\",   \"indexState\": 0,   \"replicationLocationIds\": [     \"string\"   ],   \"archivalLocationIds\": [     \"string\"   ],   \"slaId\": \"$slaId\",   \"slaName\": \"$slaName\",   \"isRetainedByRetentionLockSla\": true,   \"cloudStorageTier\": \"Hot\",   \"isPlacedOnLegalHold\": true,   \"snapshotRetentionInfo\": {     \"localInfo\": {       \"id\": \"string\",       \"name\": \"string\",       \"isSnapshotPresent\": true,       \"isExpirationDateCalculated\": true,       \"expirationTime\": \"$expirationTime\",       \"snapshotFrequency\": \"$snapshotFrequency\",       \"isExpirationInformationUnavailable\": true     },     \"archivalInfos\": [       {         \"id\": \"$id\",         \"name\": \"$name\",         \"isSnapshotPresent\": true,         \"isExpirationDateCalculated\": true,         \"expirationTime\": \"$expirationTime\",         \"snapshotFrequency\": \"$snapshotFrequency\",         \"isExpirationInformationUnavailable\": true       }     ],     \"replicationInfos\": [       {         \"id\": \"$id\",         \"name\": \"$name\",         \"isSnapshotPresent\": true,         \"isExpirationDateCalculated\": true,         \"expirationTime\": \"$expirationTime\",         \"snapshotFrequency\": \"$snapshotFrequency\",         \"isExpirationInformationUnavailable\": true       }     ],     \"cloudNativeLocationInfo\": [       {         \"id\": \"$id\",         \"name\": \"$name\",         \"isSnapshotPresent\": true,         \"isExpirationDateCalculated\": true,         \"expirationTime\": \"$expirationTime\",         \"snapshotFrequency\": \"$snapshotFrequency\",         \"isExpirationInformationUnavailable\": true       }     ]   },   \"parentSnapshotId\": \"$parentSnapshotId\",   \"vappName\": \"$vappName\",   \"isSynchronized\": true,   \"vmSnapshots\": [     {       \"vcenterVmId\": \"$vcenterVmId\",       \"vmSnapshotId\": \"$vmSnapshotId\",       \"vmName\": \"$vmName\",       \"vcdVmMoid\": \"$vcdVmMoid\",       \"indexState\": 0,       \"networkConnections\": [         {           \"nicIndex\": 0,           \"macAddress\": \"$macAddress\",           \"addressingMode\": \"DHCP\",           \"ipAddress\": \"$ipAddress\",           \"vappNetworkName\": \"vappNetworkName\",           \"isConnected\": true,           \"networkAdapterType\": \"$networkAdapterType\"         }       ]     }   ],   \"networks\": [     {       \"name\": \"$name\",       \"parentNetworkId\": \"$parentNetworkId\",       \"isDeployed\": true     }   ],   \"excludedVcdVmMoids\": [     $excludedVcdVmMoids   ] }  ```  ### Deleting a specific vApp snapshot object  To delete an on-demand snapshot or a snapshot from a vApp that is not assigned to an SLA Domain, send a DELETE request to [`/vcd/vapp/snapshot/{id}`](#operation/deleteVappSnapshotV1), where {id}  is the ID assigned to a snapshot object.  ```bash  curl -X DELETE -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/{id}?location=$snapshot_location\"  ```  The Rubrik REST API server deletes the specified vApp snapshot at the location (\"all\" or \"local\") specified.    ```bash {\"Snapshot successfully deleted.\"}  ```  ### Retrieving details about missed snapshots for a vApp object  To retrieve the timestamp for each missed snapshot for a specified vApp, send a GET request to [`/vcd/vapp/{id}/missed_snapshot`](#operation/vcdMissedSnapshotsV1). where {id} is the id of the vapp.   ```bash   curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/$id/missed_snapshot\"   ```  The Rubrik REST API server fetches details about all missed snapshots (List of MissedSnapshot) of the specified vApp.    ```bash {   \"hasMore\": true,   \"data\": [     {       \"archivalLocationType\": [         \"string\"       ],       \"missedSnapshotTime\": \"$missedSnapshotTime\",       \"missedSnapshotTimeUnits\": [         {           \"timeUnit\": \"Minute\",           \"frequency\": 0,           \"retention\": 0,           \"dayOfTime\": \"Monday\"         }       ]     }   ],   \"total\": 0 }   ```  ### Retrieving exportable network configurations  To retrieve the summary information for the vApp networks that are available for network connections from the virtual machines in the exported vApp snapshot, send a GET request to [`/vcd/vapp/snapshot/{snapshot_id}/export/options`](#operation/getVappSnapshotExportOptionsV1). This API requires the snapshot_id of the vApp snapshot object to export. It also requires the `export_mode`, `target_vapp_id` and the `target_org_vdc_id1`.  ```bash   curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/export/options?export_mode=$export_mode\"   ```  The Rubrik REST API server fetches VappExportOptions for the specified snapshot and export mode specified.    ```bash {   \"restorableNetworks\": [     {       \"name\": \"$name\",       \"parentNetworkId\": \"$parentNetworkId\",       \"isDeployed\": true,       \"newName\": \"$newName\"     }   ],   \"targetVappNetworks\": [     {       \"name\": \"$name\",       \"parentNetworkId\": \"$parentNetworkId\",       \"isDeployed\": true     }   ],   \"availableStoragePolicies\": [     {       \"name\": \"$name\",       \"id\": \"$id\"     }   ],   \"allChildVmsWithDefaultNetworkConnections\": [     {       \"name\": \"$name\",       \"vcdMoid\": \"$vcdMoid\",       \"storagePolicyId\": \"$storagePolicyId\",       \"networkConnections\": [         {           \"nicIndex\": 0,           \"macAddress\": \"$macAddress\",           \"addressingMode\": \"DHCP\",           \"ipAddress\": \"$ipAddress\",           \"vappNetworkName\": \"$vappNetworkName\",           \"isConnected\": true,           \"networkAdapterType\": \"$networkAdapterType\"         }       ]     }   ] }   ```  ### Exporting vApp snapshot  To export the specified vApp snapshot into a new vApp or an existing vApp, send a POST request to [`/vcd/vapp/snapshot/{snapshot_id}/export`](#operation/createVappExportV1), where {snapshot_id} is the ID assigned to the vApp snapshot object.  ```bash     curl -X POST -d \\     '{       \"exportMode\": \"$exportMode\",       \"newVappParams\": {         \"name\": \"$name\",         \"orgVdcId\": \"$orgVdcId\"       },       \"targetVappId\": \"$targetVappId\",       \"networksToRestore\": [         {           \"name\": \"$name\",           \"parentNetworkId\": \"$parentNetworkId\",           \"isDeployed\": true,           \"newName\": \"$newName\"         }       ],       \"vmsToExport\": [         {           \"name\": \"$name\",           \"vcdMoid\": \"$vcdMoid\",           \"storagePolicyId\": \"$storagePolicyId\",           \"networkConnections\": [             {               \"nicIndex\": 0,               \"macAddress\": \"$macAddress\",               \"addressingMode\": \"DHCP\",               \"ipAddress\": \"$ipAddress\",               \"vappNetworkName\": \"$vappNetworkName\",               \"isConnected\": true,               \"networkAdapterType\": \"$networkAdapterType\"             }           ]         }       ],       \"shouldPowerOnVappAfterExport\": false     }' \\     \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/export\" ```  The Rubrik REST API server initiates an asynchronous job to export vApp snapshot and returns the details of the AsyncRequestStatus request.  ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Recovering vApp objects of virtual machines  To instantly recover the specified vApp, send a POST request to [`/vcd/vapp/snapshot/{snapshot_id}/instant_recover`](#operation/createVappInstantRecoveryV1), where {snapshot_id} is the ID assigned to the vApp snapshot object.  ```bash     curl -X POST -d \\     '{       \"vmsToRestore\": [         {           \"name\": \"$name\",           \"vcdMoid\": \"$vcdMoid\",           \"storagePolicyId\": \"$storagePolicyId\",           \"networkConnections\": [             {               \"nicIndex\": 0,               \"macAddress\": \"$macAddress\",               \"addressingMode\": \"DHCP\",               \"ipAddress\": \"$ipAddress\",               \"vappNetworkName\": \"$vappNetworkName\",               \"isConnected\": true,               \"networkAdapterType\": \"$networkAdapterType\"             }           ]         }       ],       \"shouldPowerOnVmsAfterRecovery\": false     }' \\     \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/instant_recover\" ```  The Rubrik REST API server initiates an asynchronous job to Instant Recover vApp snapshot and returns the details of the AsyncRequestStatus request.  ```bash {   \"id\": \"$requestId\",   \"status\": \"$status\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving Instant Recovery information  To retrieve the available vApp network connections and the default vApp network connection for the virtual machines in a vApp snapshot, send a GET request to [`/vcd/vapp/snapshot/{snapshot_id}/instant_recover/options`](#operation/getVappSnapshotInstantRecoveryOptionsV1), where {snapshot_id} is the ID of the vApp snapshot object.  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/instant_recover/options\" ```  The Rubrik REST API server fetches VappInstantRecoveryOptions for the specified snapshot.  ```bash {   \"restorableVms\": [     {       \"name\": \"$name\",       \"vcdMoid\": \"$vcdMoid\",       \"storagePolicyId\": \"$storagePolicyId\",       \"networkConnections\": [         {           \"nicIndex\": 0,           \"macAddress\": \"$macAddress\",           \"addressingMode\": \"DHCP\",           \"ipAddress\": \"$ipAddress\",           \"vappNetworkName\": \"$vappNetworkName\",           \"isConnected\": true,           \"networkAdapterType\": \"$networkAdapterType\"         }       ]     }   ],   \"availableVappNetworks\": [     {       \"name\": \"$name\",       \"parentNetworkId\": \"$parentNetworkId\",       \"isDeployed\": true     }   ] } ```  ### Retrieving vApp job status  To retrieves the details of a specified asynchronous job for a vApp, send a GET request to [`/vcd/vapp/request/{id}`](#operation/getVappAsyncRequestStatusV1), where {id} is the ID assigned to an asynchronous job.  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/request/{id}\" ```  The Rubrik REST API server fetches status of a vApp asynchronous job (AsyncRequestStatus).  ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Searching for a file in a vApp snapshot  To search for a file through snapshots of all virtual machines that are part of the vApp, send a GET request to [`/vcd/vapp/{id}/search`](#operation/searchVappV1), where {id} is the ID of the vApp. It also requires a `path` parameter. The parameter takes either a path prefix or a filename prefix.  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/vapp/$id/search/options?path=$path\" ```  The Rubrik REST API server searches a file through snapshots of all virtual machines and returns list of  AppSearchResponse.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"path\": \"$path\",       \"filename\": \"$filename\",       \"fileVersions\": [         {           \"lastModified\": \"$lastModified\",           \"size\": 0,           \"snapshotId\": \"$snapshotId\",           \"fileMode\": \"$fileMode\",           \"source\": \"$source\"         }       ],       \"childObjectId\": \"$childObjectId\",       \"childObjectName\": \"$childObjectName\"     }   ],   \"total\": 0 } ```  ### Downloading snapshot from archive  To retrieve a snapshot that is not available locally, from an archival location, send a POST request to [`/vcd/vapp/snapshot/{id}/download`](#operation/createVcdVappDownloadSnapshotFromCloudV1)z where {id} is the ID of the snapshot which needs to be downloaded.  ```bash     curl -X POST -d \"https://$cluster_address/api/v1/vcd/vapp/snapshot/$id/download\" ```  The Rubrik REST API server initiates an asynchronous job to download vApp snapshot from archive and returns the  details of the AsyncRequestStatus request.  ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/vapp/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving summary for all vCD Clusters  To retrieve the summary information for all vCD cluster objects, send a GET request to [`/vcd/cluster`](#operation/queryVcdClusterV1). The parameters described in the following table are available to filter the results of the GET request.  | Name       | Required | Type   | Description | | ---------- | -------- | ------ | ----------- | |`name`      | Optional | string | Search for a vCD Cluster object by name.| |`status`    | Optional | string | Filter the results using the status value of the vCD Cluster objects.| |`sort_by`   | Optional | string | Attribute to sort the results on.| |`sort_order`| Optional | string | Order for sorting the results, either ascending or descending.|  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster\" ```  The Rubrik REST API server fetches VcdClusterSummary for all vCD instances on the Rubrik cluster.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"INHERIT\",       \"configuredSlaDomainName\": \"Inherit\",       \"configuredSlaDomainType\": \"ProtectionSla\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": true,       \"slaLastUpdateTime\": \"$slaLastUpdateTime\",       \"hostname\": \"$hostname\",       \"username\": \"$username\",       \"caCerts\": \"$caCerts\",       \"connectionStatus\": {         \"status\": \"Disconnected\",         \"message\": \"string\"       }     }   ],   \"total\": 0 } ```  ### Adding a vCD Cluster  To create a vCD Cluster object by providing the address of the vCD Cluster and the credentials for an account on the vCD Cluster that has administrator privileges, send a POST request to [`/vcd/cluster`](#operation/createVcdClusterV1).  ```bash     curl -X POST -d \\     '{       \"hostname\": \"$hostname\",       \"username\": \"$username\",       \"caCerts\": \"$caCerts\",       \"password\": \"$password\"     }' \\     \"https://$cluster_address/api/v1/vcd/cluster\" ```  The Rubrik REST API server attempts to add vCD to the Rubrik cluster and returns AsyncRequestStatus of request.  ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving VimServers of a vCD Cluster  To retrieve the VimServer representation of the vCenter Servers that are attached to a specified vCD Cluster object, send a GET request to [`/vcd/cluster/{id}/vimserver`](#operation/queryVcdVimServerV1), where {id} is the ID assigned to the vCD cluster. It also need two parameters `sort_by` and `sort_order` which decide the order of the results.  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster/$id/vimserver\" ```  The Rubrik REST API server fetches VimserverSummary for all Vim servers belonging to a vCD.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"vcenterId\": \"$vcenterId\",       \"vcdClusterId\": \"$vcdClusterId\",       \"vcdClusterName\": \"$vcdClusterName\",       \"hostname\": \"$hostname\",       \"connectionStatus\": {         \"status\": \"Disconnected\",         \"message\": \"string\"       }     }   ],   \"total\": 0 } ```  ### Refreshing a vCD Cluster  To refresh the metadata for a specified vCD Cluster object, send a POST request to [`/vcd/cluster/{id}/refresh`](#operation/refreshVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object.  ```bash     curl -X POST -d \"https://$cluster_address/api/v1/vcd/cluster/$id/refresh\" ```  The Rubrik REST API server initiates an asynchronous job to refresh a vCD and returns the details of the AsyncRequestStatus request.  ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving vCD Cluster details  To retrieve detailed information for a vCD Cluster object, send a GET request to [`/vcd/cluster/{id}`](#operation/getVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object.  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster/{id}\" ```  The Rubrik REST API server fetches VcdClusterDetail for the specified vCD instance.  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"$slaLastUpdateTime\",   \"hostname\": \"$hostname\",   \"username\": \"$username\",   \"caCerts\": \"$caCerts\",   \"connectionStatus\": {     \"status\": \"Disconnected\",     \"message\": \"string\"   } } ```  ### Changing vCD Cluster object  To modify the hostname and credentials of a specified vCD Cluster object, send a PATCH request to [`/vcd/cluster/{id}`](#operation/updateVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object. It also requires a parameter named `patch_properties` which contains the updated hostname and credentials for a specified vCD Cluster object.  ```bash     curl -X PATCH -d \\     '{       \"hostname\": \"$hostname\",       \"username\": \"$username\",       \"password\": \"$password\",       \"caCerts\": \"$caCerts\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\"     }' \\     \"https://$cluster_address/api/v1/vcd/cluster/{id}\" ```  The Rubrik REST API server updates and fetches the updated VcdClusterDetail for the specified vCD instance.  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"ProtectionSla\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"$slaLastUpdateTime\",   \"hostname\": \"$hostname\",   \"username\": \"$username\",   \"caCerts\": \"$caCerts\",   \"connectionStatus\": {     \"status\": \"Disconnected\",     \"message\": \"string\"   } } ```  ### Removing a vCD Cluster  To remove a vCD Cluster object, send a DELETE request to [`/vcd/cluster/{id}`](#operation/deleteVcdClusterV1), where {id} is the ID of assigned to a vCD Cluster object.  ```bash     curl -X DELETE -d \"https://$cluster_address/api/v1/vcd/cluster/{id}\" ```  The Rubrik REST API server initiates an asynchronous job to delete a vCD instance and returns the details of the AsyncRequestStatus request.  ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving details of jobs on vCD cluster  To retrieve the details of a specified asynchronous job for a vCD Cluster, send a GET request to [`/vcd/cluster/request/{id}`](#operation/getVcdClusterAsyncRequestStatusV1), where {id} is the ID assigned to an asynchronous job.  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/cluster/request/{id}\" ```  The Rubrik REST API server fetches details of the specifed asynchronous job and returns the AsyncRequestStatus request.  ```bash {   \"id\": \"$requestId\",   \"status\": \"QUEUED\",   \"progress\": 0,   \"startTime\": \"$startTime\",   \"endTime\": \"$endTime\",   \"nodeId\": \"$nodeId\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"https://$cluster_address/api/v1/vcd/cluster/request/$requestId\",       \"rel\": \"self\"     }   ] } ```  ### Retrieving summary of a vCD hierarchy object  To retrieve details of the specified object in the vCD hierarchy, send a GET request to [`/vcd/hierarchy/{id}`](#operation/getVcdHierarchyObjectV1), where {id} is the ID of the vCD hierarchy object.  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/hierarchy/{id}\" ```  The Rubrik REST API server fetches VcdHierarchyObjectSummary for the specified vCD object.  ```bash {   \"id\": \"$id\",   \"name\": \"$name\",   \"configuredSlaDomainId\": \"$configuredSlaDomainId\",   \"configuredSlaDomainName\": \"$configuredSlaDomainName\",   \"configuredSlaDomainType\": \"$configuredSlaDomainType\",   \"primaryClusterId\": \"$primaryClusterId\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"slaLastUpdateTime\": \"$slaLastUpdateTime\",   \"effectiveSlaDomainId\": \"UNPROTECTED\",   \"effectiveSlaDomainName\": \"Unprotected\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",   \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",   \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",   \"slaAssignment\": \"Derived\",   \"retentionSlaDomainId\": \"$retentionSlaDomainId\",   \"infraPath\": [     ...   ],   \"slaPath\": [     ...   ],   \"isRelic\": true,   \"isDeleted\": true,   \"objectType\": \"Cluster\",   \"descendantCount\": {     \"vcdCluster\": 0,     \"connectedVimServer\": 0,     \"disconnectedVimServer\": 0,     \"org\": 0,     \"orgVdc\": 0,     \"catalog\": 0,     \"vApp\": 0   },   \"connectionStatus\": {     \"status\": \"Disconnected\",     \"message\": \"string\"   },   \"ipAddress\": \"$ipAddress\",   \"vcenterId\": \"$vcenterId\",   \"extendedAttributes\": {     \"vappAtributes\": {       \"isVappTemplate\": true     }   },   \"pendingSlaDomain\": {     \"objectId\": \"$objectId\",     \"pendingSlaDomainId\": \"$pendingSlaDomainId\",     \"pendingSlaDomainName\": \"$pendingSlaDomainName\",     \"isPendingSlaDomainRetentionLocked\": true   } } ```  ### Retrieving immediate descendant objects  To retrieve the list of immediate descendant objects for the specified parent, send a GET request to [`/vcd/hierarchy/{id}/children`](#operation/getVcdHierarchyChildrenV1), where {id} is the ID of the parent vCD hierarchy object. The parameters described in the following table are available to filter the results of the GET request.  | Name                    | Required | Type    | Description | | ----------------------- | -------- | ------- | ----------- | |`id`                     | Required | string  | ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.| |`sort_by`                | Optional | string  | Attribute to sort the results on.| |`sort_order`             | Optional | string  | Order for sorting the results, either ascending or descending.| |`limit`                  | Optional | int     | Limit the number of matches returned.| |`offset`                 | Optional | int     | Number of matches to ignore from the beginning of the results.| |`name`                   | Optional | string  | Search object by object name.| |`is_relic`               | Optional | boolean | Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.| |`effective_sla_domain_id`| Optional | string  | Filter by ID of effective SLA domain.| |`object_type`            | Optional | string  | Filter by node object type. | |`primary_cluster_id`     | Optional | string  | Filter by primary cluster ID, or **local**.| |`sla_assignment`         | Optional | string  | Filter by SLA assignment type.| |`snappable_status`       | Optional | string  | Filters vCD hierarchy objects based on the specified query value.|  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/hierarchy/$id/children\" ```  The Rubrik REST API server fetches VcdHierarchyObjectSummary for all children (immediate descendants)  of the specified vCD object.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"$configuredSlaDomainType\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": true,       \"slaLastUpdateTime\": \"$slaLastUpdateTime\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"isEffectiveSlaDomainRetentionLocked\": true,       \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",       \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",       \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",       \"slaAssignment\": \"Derived\",       \"retentionSlaDomainId\": \"$retentionSlaDomainId\",       \"infraPath\": [         ...       ],       \"slaPath\": [         ...       ],       \"isRelic\": true,       \"isDeleted\": true,       \"objectType\": \"Cluster\",       \"descendantCount\": {         \"vcdCluster\": 0,         \"connectedVimServer\": 0,         \"disconnectedVimServer\": 0,         \"org\": 0,         \"orgVdc\": 0,         \"catalog\": 0,         \"vApp\": 0       },       \"connectionStatus\": {         \"status\": \"Disconnected\",         \"message\": \"string\"       },       \"ipAddress\": \"$ipAddress\",       \"vcenterId\": \"$vcenterId\",       \"extendedAttributes\": {         \"vappAtributes\": {           \"isVappTemplate\": true         }       },       \"pendingSlaDomain\": {         \"objectId\": \"$objectId\",         \"pendingSlaDomainId\": \"$pendingSlaDomainId\",         \"pendingSlaDomainName\": \"$pendingSlaDomainName\",         \"isPendingSlaDomainRetentionLocked\": true       }     }   ],   \"total\": 0 } ```  ### Retrieving list of descendant objects  To retrieve the list of descendant objects for the specified parent, send a GET request to [`/vcd/hierarchy/{id}/descendants`](#operation/getVcdHierarchyDescendantsV1), where {id} is the ID of the parent vCD hierarchy object. The parameters described in the following table are available to filter the results of the GET request.  | Name                    | Required | Type    | Description | | ----------------------- | -------- | ------- | ----------- | |`id`                     | Required | string  | ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.| |`sort_by`                | Optional | string  | Attribute to sort the results on.| |`sort_order`             | Optional | string  | Order for sorting the results, either ascending or descending.| |`limit`                  | Optional | int     | Limit the number of matches returned.| |`offset`                 | Optional | int     | Number of matches to ignore from the beginning of the results.| |`name`                   | Optional | string  | Search object by object name.| |`is_relic`               | Optional | boolean | Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.| |`effective_sla_domain_id`| Optional | string  | Filter by ID of effective SLA domain.| |`object_type`            | Optional | string  | Filter by node object type. | |`primary_cluster_id`     | Optional | string  | Filter by primary cluster ID, or **local**.| |`sla_assignment`         | Optional | string  | Filter by SLA assignment type.| |`snappable_status`       | Optional | string  | Filters vCD hierarchy objects based on the specified query value.|  ```bash     curl -X GET -d \"https://$cluster_address/api/v1/vcd/hierarchy/$id/descendants\" ```  The Rubrik REST API server fetches VcdHierarchyObjectSummary for all descendants of specified vCD object.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$id\",       \"name\": \"$name\",       \"configuredSlaDomainId\": \"$configuredSlaDomainId\",       \"configuredSlaDomainName\": \"$configuredSlaDomainName\",       \"configuredSlaDomainType\": \"$configuredSlaDomainType\",       \"primaryClusterId\": \"$primaryClusterId\",       \"isConfiguredSlaDomainRetentionLocked\": true,       \"slaLastUpdateTime\": \"$slaLastUpdateTime\",       \"effectiveSlaDomainId\": \"UNPROTECTED\",       \"effectiveSlaDomainName\": \"Unprotected\",       \"isEffectiveSlaDomainRetentionLocked\": true,       \"effectiveSlaDomainPolarisManagedId\": \"$effectiveSlaDomainPolarisManagedId\",       \"effectiveSlaSourceObjectId\": \"$effectiveSlaSourceObjectId\",       \"effectiveSlaSourceObjectName\": \"$effectiveSlaSourceObjectName\",       \"slaAssignment\": \"Derived\",       \"retentionSlaDomainId\": \"$retentionSlaDomainId\",       \"infraPath\": [         ...       ],       \"slaPath\": [         ...       ],       \"isRelic\": true,       \"isDeleted\": true,       \"objectType\": \"Cluster\",       \"descendantCount\": {         \"vcdCluster\": 0,         \"connectedVimServer\": 0,         \"disconnectedVimServer\": 0,         \"org\": 0,         \"orgVdc\": 0,         \"catalog\": 0,         \"vApp\": 0       },       \"connectionStatus\": {         \"status\": \"Disconnected\",         \"message\": \"string\"       },       \"ipAddress\": \"$ipAddress\",       \"vcenterId\": \"$vcenterId\",       \"extendedAttributes\": {         \"vappAtributes\": {           \"isVappTemplate\": true         }       },       \"pendingSlaDomain\": {         \"objectId\": \"$objectId\",         \"pendingSlaDomainId\": \"$pendingSlaDomainId\",         \"pendingSlaDomainName\": \"$pendingSlaDomainName\",         \"isPendingSlaDomainRetentionLocked\": true       }     }   ],   \"total\": 0 } ```  # Blackout Windows  ## Get Global Blackout Window Status Send a GET request to ['/blackout_window`](#operation/getBlackoutWindowStatus)  ```bash curl -X GET \"https://$cluster_address/api/v1/blackout_window\" ```  ## Start or Stop the Global Blackout Window in local Rubrik Cluster Send a PATCH request to [`/blackout_window`](#operation/toggleBlackoutWindow)  ```bash curl -X PATCH \\   -d '{ \\    \"isGlobalBlackoutActive\": true \\    }' \\   \"https://$cluster_address/api/v1/blackout_window\" ```  # Managed Volumes  ## Create Script to Unify Managed Volume Export View  To request an asynchronous job to generate a script to create a directory to view all files in all channels of a managed volume export, send a POST request to the [`/managed_volume/snapshot/export/{id}/script`](#operation/createManagedVolumeGenerateScriptJob) endpoint with the ID of the snapshot export.  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/managed_volume/snapshot/export/{id}/script\" ``` An asynchronous request is returned and can be polled to retrieve the job status.  ```bash {   \"id\":\"$request_id\",   \"links\": [     {       \"href\":\"https://$cluster_address/api/v1/managed_volume/request/$request_id\",       \"rel\":\"result\"     },   \"status\":\"QUEUED\" } ```  # Archival  ## Create Script to Refresh data sources in a Reader location  Send a POST request to the [`/archive/location/{location_id}/reader/refresh/data_sources`](#operation/refreshArchivalLocationDataSources) endpoint to request an asynchronous job that refreshes the metadata for a list of data sources from a specified reader location. The POST request must provide the ID of the reader location and a list of the IDs of the data sources in the archival location.  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/archive/location/{location_id}/reader/refresh/data_sources\" ``` An asynchronous request is returned and can be polled to retrieve the job status.  ```bash {   \"id\":\"$request_id\",   \"links\": [     {       \"href\":\"https://$cluster_address/api/v1/archive/request/$request_id\",       \"rel\":\"result\"     },   \"status\":\"QUEUED\" } ```  ## Get the ID of the customer AWS account that owns the archival location  Send a GET request to the [`/archive/aws/s3/{id}/account_id`](#operation/getAwsAccountId) endpoint to request the ID of the AWS customer account for the S3 archival location. Returns an error when the location given is not an AWS S3 archival location.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/archive/aws/s3/{id}/account_id\" ``` Returns the ID of the AWS account.  ## Disable archival location for archiving and modifications.  Send a POST request to the [`/archive/location/{location_id}/owner/disable`](#operation/disableArchivalLocation) endpoint to disable the specified active archival location. The POST request must include the ID of the active location.  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/archive/location/{location_id}/owner/disable\" ``` Returns empty response body  ## Enable archival location for archiving and modifications.  Send a POST request to the [`/archive/location/{location_id}/owner/enable`](#operation/enableArchivalLocation) endpoint to enable archiving and other operations that were previously disabled on the specified archival location with the disable operation. The POST request must include the ID of the specified location.  ```bash curl -X POST \\   \"https://$cluster_address/api/v1/archive/location/{location_id}/owner/enable\" ``` Returns empty response body  # Replication  ## Enable Source Specific Replication Pause Send a POST request to [`/replication/location_pause/enable`] (#operation/enablePerLocationPause)  ```bash curl -X POST \\   -d '{ \\    \"sourceClusterUuids\": [\"510ae3f4-d733-4545-9ea4-fe702401fdca\"], \\    \"shouldCancelImmediately\": true \\    }' \\   \"https://$cluster_address/api/v1/replication/location_pause/enable\" ```  ## Disable Source Specific Replication Pause Send a POST request to [`/replication/location_pause/disable`] (#operation/disablePerLocationPause)  ```bash curl -X POST \\   -d '{ \\    \"sourceClusterUuids\": [\"510ae3f4-d733-4545-9ea4-fe702401fdca\"], \\    \"shouldSkipOldSnapshots\": true \\    }' \\   \"https://$cluster_address/api/v1/replication/location_pause/disable\" ```  # Unmanaged object  An unmanaged object is an object that is not currently assigned an active SLA.  ### Get all unmanaged reader object summaries Get a listing of all unmanaged reader object summaries using a GET request to [/unmanaged_object/reader_object](#operation/queryUnmanagedReaderObject).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/unmanaged_object/reader_object\" ``` The Rubrik REST API server returns a `ListResponse` object of unmanaged reader object summaries. ```bash {   \"data\": [     {       \"id\": \"$vm1_managed_id\",       \"name\": \"$vm1_name\",       \"objectType\": \"VirtualMachine\",       \"physicalLocation\": [         {           \"managedId\": \"$location1_managed_id\",           \"name\": \"$location1_name\"         }       ],       \"unmanagedStatus\": \"Unprotected\",       \"autoSnapshotCount\": 20,       \"manualSnapshotCount\": 0,       \"localStorage\": 100,       \"archiveStorage\": 0,       \"retentionSlaDomainId\": \"$gold_sla_id\",       \"retentionSlaDomainName\": \"Gold\"     }   ],   \"hasMore\": false,   \"total\": 1 } ``` ### Get all unmanaged object summaries Get a list of all objects with unmanaged snapshots using a GET request to [/unmanaged_object](#operation/queryUnmanagedObjectV1).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/unmanaged_object\" ``` The Rubrik REST API server returns a `ListResponse` object of objects with  unmanaged snapshots. ```bash {   \"data\": [     {       \"id\": \"$vm1_managed_id\",       \"name\": \"$vm1_name\",       \"objectType\": \"VirtualMachine\",       \"physicalLocation\": [         {           \"managedId\": \"$location1_managed_id\",           \"name\": \"$location1_name\"         }       ],       \"unmanagedStatus\": \"Unprotected\",       \"snapshotCount\": 20,       \"localStorage\": 100,       \"archiveStorage\": 0,       \"retentionSlaDomainId\": \"$gold_sla_id\",       \"retentionSlaDomainName\": \"Gold\"     }   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Get summary of all snapshots for a given object Get summary of all snapshots for a given object using a GET request to [/unmanaged_object/{id}/snapshot](#operation/queryUnmanagedObjectSnapshotsV1). ```bash curl -X GET \\   \"https://$cluster_address/api/v1/unmanaged_object/{id}/snapshot\" ``` The Rubrik REST API server return a `ListResponse` object of snapshot summaries for the given object. ```bash {   \"data\": [     {       \"id\": \"$snapshot_id\",       \"date\": \"<timestamp>\",       \"snapshotType\": \"PolicyBased\",       \"snapshotRetentionInfo\": {         \"localInfo\": {           \"id\": \"location_id\",           \"name\": \"local_cluster\",           \"isSnapshotPresent\": true,           \"isExpirationDateCalculated\": true,           \"expirationTime\": \"<timestamp2>\"         },         \"archivalInfos\": [],         \"replicationInfos\": []       }     }   ],   \"hasMore\": false,   \"total\": 1 } ```  ### Assign a retention SLA to unmanaged object. Assign a retention SLA to an unmanaged object to expire existing snapshots in a structured manner.  Send a POST request to [/unmanaged_object/assign_retention_sla](#operation/assignToRetentionSlaAsync).  **Example:** Assigning a retention SLA Domain with ID $slaId to a list of unmanaged objects - $snap1Id, $snap2Id  ```bash curl -X POST \\   -d '{     \"slaDomainId\": $slaId,     \"managedIds\": [$snap1Id, $snap2Id]   }' \\   \"https://$cluster_address/api/v1/unmanaged_object/assign_retention_sla\" ```  ### Bulk tier existing snapshots to cold storage Schedules a job to tier existing snapshots of the selected objects to cold storage.  Send a POST request to [/unmanaged_object/snapshot/bulk_archive_tier](#operation/bulkTierExistingSnapshots)  **Example:** Tier existing snapshots for the objects - $object1Id, $object2Id  ```bash curl -X POST \\   -d '{     \"objectIds\": [$object1Id, $object2Id]   }' \\   \"https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier\" ```  **Example:** Tier existing snapshots for the objects - $object1Id, $object2Id only in archival location $archivalLocationId  ```bash curl -X POST \\   -d '{     \"objectIds\": [$object1Id, $object2Id],     \"locationId\": $archivalLocationId   }' \\   \"https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier\"  An asynchronous request is returned and can be polled to retrieve the job status.  ```bash {   \"id\":\"$request_id\",   \"links\": [     {       \"href\":\"https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier/request/$request_id\",       \"rel\":\"result\"     },   \"status\":\"QUEUED\" } ```  # Data Source  A data source is an object whose snapshots can be taken.  ### Delete given snapshots for an object Delete snapshots identified by the given snapshot IDs for the specified object using a POST request to [ `/data_source/{id}/snapshot/bulk_delete` ](#operation/bulkDeleteSnapshotsForObject).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/data_source/{id}/snapshot/bulk_delete\" ```  ### Delete all snapshots for given objects Delete all snapshots for given objects using a POST request to [`/data_source/snapshot/bulk_delete`](#operation/bulkDeleteSnapshots).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/data_source/snapshot/bulk_delete\" ```  ### Get information of expired snapshots which were explicitly assigned a SLA domain To get information on snapshots that expired according to their assigned SLA domain, send a GET request to [`/data_source/{id}/expired_custom_retention_snapshots`](#operation/expiredCustomRetentionSnapshots).  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/data_source/{id}/expired_custom_retention_snapshots\" ```  # SAP HANA databases  ## Get SAP HANA database summary  Request a list of SAP HANA discovered databases by sending a GET request to [`/sap_hana/db`](#operation/querySapHanaDatabases).  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/db\" ```  ```bash {   \"data\": [     {       \"id\": \"$db_id\",       \"name\": \"$db_name\",       \"dbStatus\": \"ACTIVE\",       \"dbType\": \"TENANT\",       \"dataPathType\": \"GCP\"       \"logBackupJobFrequencyMins\": 30       \"sapHanaSystemId\": \"$sap_hana_system_id\",       \"sid\": \"SC1\",       \"instanceNumber\": \"03\",       \"primaryClusterId\": \"$cluster_id\",       \"isRelic\": False,       \"isArchived\": False     }   ],   \"hasMore\": false,   \"total\": 1 } ```  Further details are acquired from [`/sap_hana/db/{id}`](#operation/getSapHanaDatabase).  ``` curl -X GET \"https://$cluster_address/api/v1/sap_hana/db/$db_id\" ```  ```bash {       \"id\": \"$db_id\",       \"name\": \"$db_name\",       \"dbStatus\": \"ACTIVE\",       \"dbType\": \"TENANT\",       \"dataPathType\": \"GCP\"       \"logBackupJobFrequencyMins\": 30       \"sapHanaSystemId\": \"$sap_hana_system_id\",       \"sid\": \"SC1\",       \"instanceNumber\": \"03\",       \"primaryClusterId\": \"$cluster_id\",       \"isRelic\": False,       \"isArchived\": False,       \"previousFailedBackupPrefixes\": [         \"abcd\", \"defg\"       ],       \"snapShotCount\": 3 } ```  Update SLA Domain assigned to SAP HANA database by using [`/sap_hana/db/{id}`](#operation/patchSapHanaDatabase). The API returns with the summary of the SAP HANA database.  ```bash curl -X PATCH \"https://$cluster_address/api/v1/sap_hana/db/$db_id\" ```  ```bash {       \"id\": \"$db_id\",       \"name\": \"$db_name\",       \"dbStatus\": \"ACTIVE\",       \"dbType\": \"TENANT\",       \"dataPathType\": \"GCP\"       \"logBackupJobFrequencyMins\": 30       \"sapHanaSystemId\": \"$sap_hana_system_id\",       \"sid\": \"SC1\",       \"instanceNumber\": \"03\",       \"primaryClusterId\": \"$cluster_id\",       \"isRelic\": False,       \"isArchived\": False,       \"previousFailedBackupPrefixes\": [         \"abcd\", \"defg\"       ],       \"snapShotCount\": 3 } ```  ## System copy restore  System copy restore is a type of restore that is used across different SAP HANA databases.  ### Configuring system copy restore  To initiate a task to configure a system copy restore on a SAP HANA database, send a POST request to [`/sap_hana/db/{id}/configure_restore`](#operation/configureSapHanaRestore) where, {id} is the ID of the target SAP HANA database.  ```bash curl -X POST \\   -d '{     \"source_config\": {         \"snappable_id\": \"$source_db_id\"       }     }' \\ \"https://$cluster_address/api/v1/sap_hana/db/$target_db_id/configure_restore\" ```  The Rubrik REST API server initiates the configuration task and responds with a request object.  ```bash {       \"id\": \"$request_id\",       \"status\": \"QUEUED\",       \"error\": \"None\",       \"progress\": 0,       \"startTime\": \"$start_timestamp\",       \"endTime\": \"$end_timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",           \"rel\": \"self\"         }       ] } ```  ### Unconfiguring system copy restore  To initiate a task to reset the configuration for a system copy restore on a SAP HANA database, send a POST request to [`/sap_hana/db/{id}/unconfigure_restore`](#operation/unconfigureSapHanaRestore) where, {id} is the ID of the target SAP HANA database.  ```bash curl -X POST \"https://$cluster_address/api/v1/sap_hana/db/$target_db_id/unconfigure_restore\" ``` The Rubrik REST API server initiates the task to reset the configuration for the system copy restore and responds with a request object.  ```bash {       \"id\": \"$request_id\",       \"status\": \"QUEUED\",       \"error\": \"None\",       \"progress\": 0,       \"startTime\": \"$start_timestamp\",       \"endTime\": \"$end_timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",           \"rel\": \"self\"         }       ] } ```  ## SAP HANA system apis  Request a list of SAP HANA systems on a cluster by sending a GET request to [`/sap_hana/system`](#operation/querySapHanaSystems).  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/system\" ```  ```bash {   \"data\": [     {       \"id\": \"$system_id\",       \"sid\": \"SC1\",       \"numDbs\": 3,       \"containerType\": \"SINGLE_CONTAINER\",       \"instanceNumber\": \"03\",       \"status\": \"OK\",       \"username\": \"$system_username\",     }   ],   \"hasMore\": false,   \"total\": 1 } ```  Adds an entry for SAP HANA system to database. To add a SAP HANA system entry, send a POST request to [`/sap_hana/system`](#operation/addSapHanaSystem).  ```bash curl -X POST \\   -d '{     \"username\": \"$username\",     \"password\": \"$password\",     \"sid\": \"$sid\",     \"instance\": \"$instance\",     \"hostIdList\": [       \"$host_id\"     ],     \"dataPathSpec\": {       \"$dataPathType\": \"GCP\"     } }' \\   \"https://$cluster_address/api/v1/sap_hana/system\" ``` The Rubrik REST API server responds with the ID of the added SAP HANA system and the status of the scheduled system refresh job.  ```bash {       \"id\": \"$system_id\",       \"sid\": \"SC1\",       \"numDbs\": 3,       \"containerType\": \"SINGLE_CONTAINER\",       \"instanceNumber\": \"03\",       \"status\": \"OK\",       \"username\": \"$system_username\", } ```  Further details are acquired by [`/sap_hana/system/{id}`](#operation/getSapHanaSystem).  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/system/$db_id\" ```  ```bash {       \"id\": \"$system_id\",       \"sid\": \"SC1\",       \"numDbs\": 3,       \"containerType\": \"SINGLE_CONTAINER\",       \"instanceNumber\": \"03\",       \"status\": \"OK\",       \"username\": \"$system_username\", } ```  Update the SlA Domain assigned to the SAP HANA system by calling the [`/sap_hana/system/{id}`](#operation/patchSapHanaSystem) endpoint. The API returns the summary of the SAP HANA system.  ```bash curl -X PATCH \"https://$cluster_address/api/v1/sap_hana/system/$db_id\" ```  ```bash {       \"id\": \"$system_id\",       \"sid\": \"SC1\",       \"numDbs\": 3,       \"containerType\": \"SINGLE_CONTAINER\",       \"instanceNumber\": \"03\",       \"status\": \"OK\",       \"username\": \"$system_username\", } ```  Delete a SAP HANA system by calling the [`/sap_hana/system/{id}`](#operation/deleteSapHanaSystem) endpoint. The API initiates a delete job and responds with a request object.  ```bash curl -X DELETE \"https://$cluster_address/api/v1/sap_hana/system/$id\" ```  ```bash {       \"id\": \"$request_id\",       \"status\": \"RUNNING\",       \"error\": \"None\",       \"progress\": 0,       \"startTime\": \"$start_timestamp\",       \"endTime\": \"$end_timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/system/request/$request_id\",           \"rel\": \"self\"         }       ] } ```  Using the information provided in the request object, send a GET request to the [`/sap_hana/system/request/{id}`](#operation/getSapHanaSystemAsyncRequestStatus) endpoint to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the task finished successfully.  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/system/request/$id\" ```  ```bash {       \"id\": \"$request_id\",       \"status\": \"SUCCEEDED\",       \"error\": \"None\",       \"progress\": 0,       \"startTime\": \"$start_timestamp\",       \"endTime\": \"$end_timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/system/request/$request_id\",           \"rel\": \"self\"         }       ] } ```  Refresh the metadata of a SAP HANA system object by calling the [`/sap_hana/system/{id}/refresh`](#operation/createSapHanaSystemRefresh) endpoint. The API initiates a refresh job and responds with a request object.  ```bash curl -X POST \"https://$cluster_address/api/v1/sap_hana/system/$id/refresh\" ```  ```bash {       \"id\": \"$request_id\",       \"status\": \"RUNNING\",       \"error\": \"None\",       \"progress\": 0,       \"startTime\": \"$start_timestamp\",       \"endTime\": \"$end_timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/system/request/$request_id\",           \"rel\": \"self\"         }       ] } ```  Create a full data snapshot of a SAP HANA system object by sending a POST request to the [`/sap_hana/db/{id}/snapshot`](#operation/createOnDemandSapHanaBackup) endpoint. The API initiates a data backup job and responds with a request object.  ```bash curl -X POST \"https://$cluster_address/api/v1/sap_hana/db/{id}/snapshot\" ```  ```bash {       \"id\": \"$request_id\",       \"status\": \"QUEUED\",       \"error\": \"None\",       \"progress\": 0,       \"startTime\": \"$start_timestamp\",       \"endTime\": \"$end_timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",           \"rel\": \"self\"         }       ] } ```  Using the information provided in the request object, send a GET request to the [`/sap_hana/db/request/{id}`](#operation/getSapHanaDbAsyncRequestStatus)) endpoint to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the task finished successfully. The response also includes the `$snapshot_id`.  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/db/request/{id}\" ```  ```bash {       \"id\": \"$request_id\",       \"status\": \"SUCCEEDED\",       \"error\": \"None\",       \"progress\": 0,       \"startTime\": \"$start_timestamp\",       \"endTime\": \"$end_timestamp\",       \"links\": [         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/db/snapshot/$snapshot_id\",           \"rel\": \"result\"         },         {           \"href\": \"https://$cluster_address/api/v1/sap_hana/db/request/$request_id\",           \"rel\": \"self\"         }       ] } ```  Request a list of summary of snapshots of a SAP HANA database by sending a GET request to the [`/sap_hana/db/{id}/snapshot`](#operation/querySapHanaDbSnapshot) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/db/{id}/snapshot\" ```  ```bash {   \"data\": [     {       \"id\": \"$db_id\",       \"date\": \"2019-12-16T23:21:53.377Z\",       \"sourceObjectType\": \"SapHanaDatabase\",       \"isOnDemandSnapshot\": true,       \"isCustomRetentionApplied\": false       \"cloudState\": 0       \"replicationLocationIds\": [         \"string\"       ],       \"archivalLocationIds\": [         \"string\"       ],       \"slaId\": \"string\",       \"slaName\": \"string\",       \"isRetainedByRetentionLockSla\": true,       \"backupId\": 949363200000,       \"backupType\": \"FULL\",       \"sapHanaStartTime\": \"2019-12-16T23:21:53.377Z\",       \"sapHanaEndTime\": \"2019-12-16T23:21:53.377Z\",       \"rubrikSnapshotStartTime\": \"2019-12-16T23:21:53.377Z\",       \"rubrikSnapshotEndTime\": \"2019-12-16T23:21:53.377Z\",       \"backupPrefix\": \"RUBRIK_949363200000_ON_DEMAND\",       \"isExternalBackup\": false,       \"isRubrikTriggeredOnDemandBackup\": false     }   ],   \"hasMore\": false,   \"total\": 1 } ```  Request SAP HANA database snapshot details by sending a GET request to the [`/sap_hana/db/snapshot/{id}`](#operation/getSapHanaDbSnapshot) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/db/snapshot/{id}\" ```  ```bash {       \"isCorrupt\": false,       \"id\": \"$db_id\",       \"date\": \"2019-12-16T23:21:53.377Z\",       \"sourceObjectType\": \"SapHanaDatabase\",       \"isOnDemandSnapshot\": true,       \"isCustomRetentionApplied\": false       \"cloudState\": 0       \"replicationLocationIds\": [         \"string\"       ],       \"archivalLocationIds\": [         \"string\"       ],       \"slaId\": \"string\",       \"slaName\": \"string\",       \"isRetainedByRetentionLockSla\": true,       \"backupId\": 949363200000,       \"backupType\": \"FULL\",       \"sapHanaStartTime\": \"2019-12-16T23:21:53.377Z\",       \"sapHanaEndTime\": \"2019-12-16T23:21:53.377Z\",       \"rubrikSnapshotStartTime\": \"2019-12-16T23:21:53.377Z\",       \"rubrikSnapshotEndTime\": \"2019-12-16T23:21:53.377Z\",       \"backupPrefix\": \"RUBRIK_949363200000_ON_DEMAND\",       \"isExternalBackup\": false,       \"isRubrikTriggeredOnDemandBackup\": false } ```  Request details of recoverable ranges of a SAP HANA database by sending a GET request to the [`/sap_hana/db/{id}/recoverable_range`](#operation/getSapHanaDbRecoverableRanges) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/db/{id}/recoverable_range\" ```  ```bash {   \"hasMore\": false,   \"data\": [     {       \"beginTime\": \"2017-02-02T18:53:12.694Z\",       \"endTime\": \"2017-02-02T20:53:12.694Z\"     }   ],   \"total\": 1 } ```  Delete a full snapshot with a DELETE request to the  [`/sap_hana/db/snapshot/{id}`](#operation/deleteSapHanaDbSnapshot) endpoint  ```bash curl -X DELETE \"https://$cluster_address/api/v1/sap_hana/db/snapshot/{id}\" ``` Request details of missed snapshots of a SAP HANA database by sending a GET request to the [`/sap_hana/db/{id}/missed_snapshot`](#operation/getMissedSapHanaDbSnapshots) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/sap_hana/db/{id}/missed_snapshot\" ```  ```bash {   \"hasMore\": true,   \"data\": [     {       \"archivalLocationType\": [         \"string\"       ],       \"missedSnapshotTime\": \"2020-08-06T14:23:13.666Z\",       \"missedSnapshotTimeUnits\": [         {           \"timeUnit\": \"Minute\",           \"frequency\": 0,           \"retention\": 0,           \"dayOfTime\": \"Monday\"         }       ]     }   ],   \"total\": 0 } ```  # Volume Groups  Rubrik clusters can protect Windows volumes on a host as a Volume Group.  ## Getting a list of Volume Groups  To retrieve a current list of Volume Groups, send a GET request to [`/volume_group`](#operation/queryVolumeGroup).  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group\" ```  The Rubrik REST API server responds with a list of summary objects of Volume Groups.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"configuredSlaDomainId\": \"string\",       \"configuredSlaDomainName\": \"string\",       \"primaryClusterId\": \"string\",       \"isConfiguredSlaDomainRetentionLocked\": true,       \"effectiveSlaDomainId\": \"string\",       \"effectiveSlaDomainName\": \"string\",       \"isEffectiveSlaDomainRetentionLocked\": true,       \"effectiveSlaDomainPolarisManagedId\": \"string\",       \"effectiveSlaSourceObjectId\": \"string\",       \"effectiveSlaSourceObjectName\": \"string\",       \"slaAssignment\": \"Derived\",       \"hostname\": \"string\",       \"hostId\": \"string\",       \"isRelic\": true     }   ],   \"total\": 0 } ```  ## Getting Volume Group Details  To retrieve the details of a Volume Group, send a GET request to [`/volume_group/{id}`](#operation/getVolumeGroup)  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group/{id}\" ```  The Rubrik REST API server responds with the details of the Volume Group.  ```bash {   \"id\": \"string\",   \"name\": \"string\",   \"configuredSlaDomainId\": \"string\",   \"configuredSlaDomainName\": \"string\",   \"primaryClusterId\": \"string\",   \"isConfiguredSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainId\": \"string\",   \"effectiveSlaDomainName\": \"string\",   \"isEffectiveSlaDomainRetentionLocked\": true,   \"effectiveSlaDomainPolarisManagedId\": \"string\",   \"effectiveSlaSourceObjectId\": \"string\",   \"effectiveSlaSourceObjectName\": \"string\",   \"slaAssignment\": \"Derived\",   \"hostname\": \"string\",   \"hostId\": \"string\",   \"isRelic\": true,   \"blackoutWindowStatus\": {     \"isGlobalBlackoutActive\": true,     \"isSnappableBlackoutActive\": true   },   \"blackoutWindows\": {     \"globalBlackoutWindows\": [       {         \"startTime\": \"string\",         \"endTime\": \"string\"       }     ],     \"snappableBlackoutWindows\": [       {         \"startTime\": \"string\",         \"endTime\": \"string\"       }     ]   },   \"isPaused\": true,   \"volumes\": [     {       \"id\": \"string\",       \"fileSystemType\": \"NTFS\",       \"mountPoints\": [         \"string\"       ],       \"size\": 0,       \"naturalId\": \"string\",       \"volumeGroupId\": \"string\",       \"isCurrentlyPresentOnSystem\": true     }   ] } ```  ## Patching Volume Group Details  To modify the details of a Volume Group, send a PATCH request to [`/volume_group/{id}`](#operation/patchVolumeGroup)  ```bash curl -X POST \"https://$cluster_address/api/v1/volume_group/{id}\" ```  ## Getting a list of all snapshots of a Volume Group  To get a list of all snapshots of a Volume Group, send a GET request to [`/volume_group/{id}/snapshot`](#operation/queryVolumeGroupSnapshot)  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group/{id}/snapshot\" ```  The Rubrik REST API server responses with a list of snapshots of the Volume Group.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"string\",       \"date\": \"2019-12-16T23:21:53.446Z\",       \"expirationDate\": \"2019-12-16T23:21:53.446Z\",       \"sourceObjectType\": \"string\",       \"isOnDemandSnapshot\": true,       \"cloudState\": 0,       \"consistencyLevel\": \"string\",       \"indexState\": 0,       \"replicationLocationIds\": [         \"string\"       ],       \"archivalLocationIds\": [         \"string\"       ],       \"slaId\": \"string\",       \"slaName\": \"string\",       \"isRetainedByRetentionLockSla\": true,       \"cloudStorageTier\": \"Hot\",       \"volumeGroupId\": \"string\",       \"name\": \"string\",       \"includedVolumes\": [         {           \"id\": \"string\",           \"fileSystemType\": \"NTFS\",           \"mountPoints\": [             \"string\"           ],           \"size\": 0         }       ]     }   ],   \"total\": 0 } ```  ## Creating on-demand snapshot of a Volume Group  To create an on-demand snapshot of a Volume Group, send a POST request to [`/volume_group/{id}/snapshot`](#operation/createOnDemandVolumeGroupBackup)  ```bash curl -X POST \"https://$cluster_address/api/v1/volume_group/{id}/snapshot\" ```  The Rubrik REST API server initiates the asynchronous snapshot task and responds with a task object.  ``` {   \"id\": \"string\",   \"status\": \"string\",   \"progress\": 0,   \"startTime\": \"2019-12-16T23:21:53.450Z\",   \"endTime\": \"2019-12-16T23:21:53.450Z\",   \"nodeId\": \"string\",   \"error\": {     \"message\": \"string\"   },   \"links\": [     {       \"href\": \"string\",       \"rel\": \"string\"     }   ] } ```  ## Getting the forced full snapshot configuration of a Volume Group  To retrieve the configuration used to force a full snapshot of a Volume Group, send a GET request to [`/volume_group/{id}/request/force_full_snapshot`](#operation/getVolumeGroupForceFullSpec)  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group/{id}/request/force_full_snapshot\" ```  The Rubrik REST API server responds with the Volume Group force full response object. The response object contains the latest configuration, unless it was cleared by a backup job of the Volume Group or it was never set.  ```bash {   \"volumeGroupId\": \"VolumeGroup:::fe9470a4-4057-4357-ac1f-ae99ff735439\",   \"volumeInfos\": [     {       \"volumeId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",       \"shouldDedupe\": false     },     {       \"volumeId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",       \"shouldDedupe\": true     }   ] } ```  ## Requesting a forced full snapshot for a Volume Group  To request a forced full snapshot of a Volume Group, send a POST request to [`/volume_group/{id}/request/force_full_snapshot`](#operation/requestVolumeGroupForceFullSnapshot)  ```bash curl -X POST \"https://$cluster_address/api/v1/volume_group/{id}/request/force_full_snapshot\" ```  The Rubrik REST API server persists the configuration for forcing a full snapshot until the next backup job, which takes a full snapshot and clears the configuration.  ``` {   \"volumeGroupId\": \"VolumeGroup:::fe9470a4-4057-4357-ac1f-ae99ff735439\",   \"volumeInfos\": [     {       \"volumeId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",       \"shouldDedupe\": false     },     {       \"volumeId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",       \"shouldDedupe\": true     }   ] } ```  ## Getting details of a Volume Group snapshot  To get the details of a Volume Group snapshot, send a GET request to [`/volume_group/snapshot/{id}`](#operation/getVolumeGroupSnapshot)  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group/snapshot/{id}\" ```  The The Rubrik REST API server responds with the details of a snapshot.  ``` {   \"id\": \"string\",   \"date\": \"2019-12-16T23:21:53.395Z\",   \"expirationDate\": \"2019-12-16T23:21:53.395Z\",   \"sourceObjectType\": \"string\",   \"isOnDemandSnapshot\": true,   \"cloudState\": 0,   \"consistencyLevel\": \"string\",   \"indexState\": 0,   \"replicationLocationIds\": [     \"string\"   ],   \"archivalLocationIds\": [     \"string\"   ],   \"slaId\": \"string\",   \"slaName\": \"string\",   \"isRetainedByRetentionLockSla\": true,   \"cloudStorageTier\": \"Hot\",   \"volumeGroupId\": \"string\",   \"name\": \"string\",   \"includedVolumes\": [     {       \"id\": \"string\",       \"fileSystemType\": \"NTFS\",       \"mountPoints\": [         \"string\"       ],       \"size\": 0     }   ] } ```  ## Getting summary information of all Volume Group mounts  To get summary information of all Volume Group mounts, send a GET request to [`/volume_group/snapshot/mount`](#operation/queryVolumeGroupSnapshotMount)  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group/snapshot/mount\" ```  The Rubrik REST API server returns summary information for all mounts.  ``` {   \"hasMore\": true,   \"data\": [     {       \"id\": \"string\",       \"name\": \"string\",       \"sourceVolumeGroupId\": \"string\",       \"sourceHostId\": \"string\",       \"sourceHostName\": \"string\",       \"snapshotDate\": \"2019-12-16T23:21:53.377Z\",       \"snapshotSourceVersion\": \"WithLayoutInfo\",       \"mountedDate\": \"2019-12-16T23:21:53.377Z\",       \"mountedVolumes\": [         {           \"id\": \"string\",           \"originalMountPoints\": [             \"string\"           ],           \"size\": 0,           \"fileSystemType\": \"NTFS\",           \"smbPath\": \"string\",           \"hostMountedPath\": \"string\"         }       ],       \"targetHostId\": \"string\",       \"targetHostName\": \"string\",       \"mountRequestId\": \"string\",       \"unmountRequestId\": \"string\",       \"isReady\": true,       \"restoreScriptSmbPath\": \"string\"     }   ],   \"total\": 0 } ```  ## Getting summary information of one mount  To retrieve summary information of one Volume Group mount, send a GET request to [`/volume_group/snapshot/mount/{id}`](#operation/getVolumeGroupSnapshotMount)  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group/snapshot/mount/{id}\" ```  The Rubrik REST API server returns summary information of the mount.  ``` {   \"id\": \"string\",   \"name\": \"string\",   \"sourceVolumeGroupId\": \"string\",   \"sourceHostId\": \"string\",   \"sourceHostName\": \"string\",   \"snapshotDate\": \"2019-12-16T23:21:53.387Z\",   \"snapshotSourceVersion\": \"WithLayoutInfo\",   \"mountedDate\": \"2019-12-16T23:21:53.388Z\",   \"mountedVolumes\": [     {       \"id\": \"string\",       \"originalMountPoints\": [         \"string\"       ],       \"size\": 0,       \"fileSystemType\": \"NTFS\",       \"smbPath\": \"string\",       \"hostMountedPath\": \"string\"     }   ],   \"targetHostId\": \"string\",   \"targetHostName\": \"string\",   \"mountRequestId\": \"string\",   \"unmountRequestId\": \"string\",   \"isReady\": true,   \"restoreScriptSmbPath\": \"string\" }  ```   ## Getting summary information of the latest snapshot of a Volume Group  Send a GET request to [`/volume_group/{id}/latest_snapshot`]\\ (#operation/queryVolumeGroupLatestSnapshot) to receive a summary of the latest snapshot of a Volume Group.  ```bash curl -X GET \"https://$cluster_address/api/v1/volume_group/{id}/latest_snapshot\" ```  The Rubrik REST API server returns summary information of the snapshot. ```bash [   {     \"id\": \"string\",     \"date\": \"2019-12-16T23:21:53.446Z\",     \"expirationDate\": \"2019-12-16T23:21:53.446Z\",     \"sourceObjectType\": \"string\",     \"isOnDemandSnapshot\": true,     \"cloudState\": 0,     \"consistencyLevel\": \"string\",     \"indexState\": 0,     \"replicationLocationIds\": [       \"string\"     ],     \"archivalLocationIds\": [       \"string\"     ],     \"slaId\": \"string\",     \"slaName\": \"string\",     \"isRetainedByRetentionLockSla\": true,     \"cloudStorageTier\": \"Hot\",     \"volumeGroupId\": \"string\",     \"name\": \"string\",     \"includedVolumes\": [       {         \"id\": \"string\",         \"fileSystemType\": \"NTFS\",         \"mountPoints\": [           \"string\"         ],         \"size\": 0       }     ]   } ] ```  # Snapshot Stats  ### Return storage stats of a snapshot To receive the storage statistics of a snapshot, send a GET request to  [`/snapshot/{id}/storage/stats`]\\ (#operation/getSnapshotStorageStatsV1).  ```bash curl -X GET \"https://$cluster_address/api/v1/snapshot/{id}/storage/stats\" ```  # Hierarchy  ### Return the list of descendant objects with SLA conflicts in bulk To bulk get the list of descendant objects with SLA conflicts, send a POST  request to  [`/hierarchy/bulk_sla_conflicts`]\\ (#operation/bulkHierarchySlaConflictsV1).  ```bash curl -X POST \"https://$cluster_address/api/v1/hierarchy/bulk_sla_conflicts\" ```  # Backup Verification  Backup verification checks the validity of a backup based on the specified snapshot ID and object ID.  ### Verify the validity of a given snapshot Verify the validity of the snapshot identified by the specified snapshot ID and object ID. [ `/backup/verify` ](#operation/verifySnapshot).  ```bash curl -X POST \\   -d '{     \"objectId\": \"$objectId\",     \"snapshotIdsOpt\": \"$snapshotIdsOpt\",     \"locationIdOpt\": \"$locationIdOpt\",     \"shouldVerifyAfterOpt\": \"$shouldVerifyAfterOpt\" }' \\   \"https://$cluster_address/api/v1/backup/verify/\" ```  ### Get asynchronous request details for Backup Verification Get the details of an asynchronous request for a backup verification job. [ `/backup/verify/{id}` ](#operation/getBackupVerificationAsyncRequestStatus).  ```bash curl -X GET \"https://$cluster_address/api/v1/backup/verify/$id\" ```  ### Reschedule unsuccessful backup tasks [ `/backup/retry` ](#operation/createBackupRemediationAsyncTask).  ```bash curl -X POST \\   -d '{     \"spec\": [       {         \"objectId\": \"$objectId\",         \"eventSeriesId\": \"$eventSeriesId\"       }     ],     \"config\": {       \"runNow\": \"$runNow\"     }   }' \\   \"https://$cluster_address/api/v1/backup/retry/\" ```  ### Get status of reschedule operation [ `/backup/retry/{id}` ](#operation/getBackupRemediationAsyncTaskStatus).  ```bash curl -X GET \"https://$cluster_address/api/v1/backup/retry/$id\" ```  # Exclusion pattern  An exclusion pattern is a regular expression pattern that enables Rubrik clusters to exclude files and folders, with names that match the regular expression pattern, from search results. Once created, the Rubrik cluster applies the exclusion pattern to the global search results and the snapshot level search results. The exclusion patterns also exclude matching files and folders from the recovery process.  A Rubrik cluster can apply the exclusion pattern on a particular [Fileset](#section/Filesets) or on all the filesets associated with a particular [Host](#section/Hosts).  The exclusion patterns are either mutable or immutable. By default, the exclusion patterns are mutable or editable upon creation.  The Rubrik REST API exposes endpoints to:  * create a single exclusion pattern * create multiple exclusion patterns, in bulk * get details of all the existing exclusion patterns * view details of a specific exclusion pattern * update an existing exclusion pattern * delete a single exclusion pattern * delete multiple exclusion patterns, in bulk  ## Adding an exclusion pattern To create a new exclusion pattern, send a POST request to [/exclusion_pattern](#operation/createExclusionPattern). The request payload must include the following attributes required to create an exclusion pattern: * `sourceId` - The ID for a fileset or a host to which the pattern will apply. * `pattern` - The regular expression pattern.  ```bash curl -X POST \\   -d '{     \"sourceId\": \"$sourceId\",     \"pattern\": \"$pattern\" }' \\   \"https://$cluster_address/api/v1/exclusion_pattern\" ```  The Rubrik REST API server responds with the details of the new exclusion pattern.  ```bash {   \"id\": \"$id\",   \"sourceId\": \"$sourceId\",   \"pattern\": \"$pattern\",   \"isMutable\": true,   \"patternStatus\": \"Queued\",   \"isActive\": true,   \"primaryClusterId\": \"$primaryClusterId\" } ```  ## Bulk adding exclusion patterns To create exclusion patterns in bulk, send a POST request to [/exclusion_pattern/bulk](#operation/bulkCreateExclusionPattern). The request payload must be an array. The array contains one set of required attributes for every exclusion pattern that will be created. See [Adding an exclusion pattern](#adding-an-exclusion-pattern) for a list of required attributes.  ```bash curl -X POST \\   -d '{     [{ \"sourceId\": \"$sourceId1\", \"pattern\": \"$pattern1\"}, { \"sourceId\": \"$sourceId2\", \"pattern\": \"$pattern2\"}] }' \\   \"https://$cluster_address/api/v1/exclusion_pattern/bulk\" ```  The Rubrik REST API server responds with the details of the new exclusion patterns.  ```bash {   \"exclusionPatternDetails\": [     {       \"id\": \"$id\",       \"sourceId\": \"$sourceId1\",       \"pattern\": \"$pattern1\",       \"isMutable\": true,       \"patternStatus\": \"Queued\",       \"isActive\": true,       \"primaryClusterId\": \"$primaryClusterId\"     },     {       \"id\": \"$id\",       \"sourceId\": \"$sourceId2\",       \"pattern\": \"$pattern2\",       \"isMutable\": true,       \"patternStatus\": \"Queued\",       \"isActive\": true,       \"primaryClusterId\": \"$primaryClusterId\"     }   ] } ```  ## Retrieving all exclusion patterns To retrieve a summary of all the exclusion patterns that have been added to the Rubrik cluster, send a GET request to [/exclusion_pattern](#operation/queryExclusionPattern). The GET /exclusion_pattern endpoint exposes a number of parameters to filter the list of exclusion patterns returned by the endpoint. The endpoint can be used with or without any of the available parameters.  ```bash curl -X GET \"https://$cluster_address/api/v1/exclusion_pattern\" ```  The Rubrik REST API server responds with a ListResponse object that contains the current list of exclusion patterns and their details.  ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"$id\",       \"sourceId\": \"$sourceId\",       \"pattern\": \"$pattern\",       \"isMutable\": true,       \"patternStatus\": \"Applied\",       \"isActive\": true,       \"primaryClusterId\": \"$primaryClusterId\"     }   ],   \"total\": 1 } ```  ## Retrieving a specific exclusion pattern To retrieve the details of a specific exclusion pattern, send a GET request to [/exclusion_pattern/{id}](#operation/getExclusionPattern). The {id} represents the ID for the exclusion pattern and has the form - ExclusionPattern:::{uuid}.  ```bash curl -X GET \\   \"https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\" ```  The Rubrik REST API server responds with the details of the specified exclusion pattern.  ```bash {   \"id\": \"$exclusion_pattern_id\",   \"sourceId\": \"$sourceId\",   \"pattern\": \"$pattern\",   \"isMutable\": true,   \"patternStatus\": \"Applied\",   \"isActive\": true,   \"primaryClusterId\": \"$primaryClusterId\" } ```  ## Updating an exclusion pattern To update a specific exclusion pattern, send a POST request to [/exclusion_pattern/{id}](#operation/updateExclusionPattern). Note that the Rubrik cluster allows updating only the exclusion patterns that have `\"isMutable\": true`. The {id} represents the ID for the exclusion pattern to be updated and has the form - ExclusionPattern:::{uuid}.  The attributes that can be updated are all or a subset of the following attributes:  * pattern * isActive * isMutable  ```bash curl -X POST \\   -d '{     \"pattern\": \"$pattern\",     \"isActive\": false,     \"isMutable\": true }' \\   \"https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\" ```  The Rubrik REST API server responds with the details of the updated exclusion pattern.  ```bash {   \"id\": \"$exclusion_pattern_id\",   \"sourceId\": \"$sourceId\",   \"pattern\": \"$pattern\",   \"isMutable\": true,   \"patternStatus\": \"Queued\",   \"isActive\": true,   \"primaryClusterId\": \"$primaryClusterId\" } ```  ## Deleting an exclusion pattern To delete a specific exclusion pattern, send a DELETE request to [/exclusion_pattern/{id}](#operation/deleteExclusionPattern). Note that the Rubrik cluster only allows the deletion of the exclusion patterns that have `\"isMutable\": true`. The {id} represents the ID for the exclusion pattern to be deleted and has the form - ExclusionPattern:::{uuid}.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\" ``` The Rubrik REST API server responds with a 204 HTTP response code to indicate the successful deletion of the specified exclusion pattern.  ## Bulk deleting exclusion patterns To delete exclusion patterns in bulk, send a DELETE request to [/exclusion_pattern/bulk](#operation/bulkDeleteExclusionPattern) with the IDs for the exclusion patterns to be deleted. Note that the Rubrik cluster only allows the deletion of the exclusion patterns that have `\"isMutable\": true`.  ```bash curl -X DELETE \\   \"https://$cluster_address/api/v1/exclusion_pattern/bulk?ids=$exclusion_pattern_id1,$exclusion_pattern_id2\" ``` The Rubrik REST API server responds with a 204 HTTP response code to indicate the successful deletion of the specified exclusion patterns.  # Hyper-V VMs   ## Getting the forced full snapshot configuration of a Hyperv VM  To retrieve the configuration used to force a full snapshot of a Hyperv virtual machine, send a GET request to: [`/hyperv/vm/{id}/request/force_full_snapshot`](#operation/getHypervVirtualMachineForceFullSpec)  ```bash curl -X GET \"https://$cluster_address/api/v1/hyperv/vm/{id}/request/force_full_snapshot\" ```  The Rubrik REST API server responds with the Hyperv virtual machine force full response object. The response object contains the latest configuration, unless it was cleared by a backup job of the Hyperv virtual machine or was never set.  ```bash {   \"vmId\": \"HypervVirtualMachine:::fe9470a4-4057-4357-ac1f-ae99ff735439\",   \"virtualDiskInfos\": [     {       \"virtualDiskId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",       \"shouldDedupe\": false     },     {       \"virtualDiskId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",       \"shouldDedupe\": true     }   ] } ```  ## Requesting a forced full snapshot for a Hyperv VM  To request a forced full snapshot of a Hyperv virtual machine, send a POST request to: [`/hyperv/vm/{id}/request/force_full_snapshot`](#operation/requestHypervVirtualMachineForceFullSnapshot)  ```bash curl -X POST \"https://$cluster_address/api/v1/hyperv/vm/{id}/request/force_full_snapshot\" ```  The Rubrik REST API server persists the configuration to force a full snapshot until the next backup job, which takes a full snapshot and clears the configuration.  ```bash {   \"vmId\": \"HypervVirtualMachine:::fe9470a4-4057-4357-ac1f-ae99ff735439\",   \"virtualDiskInfos\": [     {       \"virtualDiskId\": \"872bdd28-4d5d-4831-8698-59d692a822fc\",       \"shouldDedupe\": false     },     {       \"virtualDiskId\": \"39f61483-9cf5-11e9-80b9-00155d094203\",       \"shouldDedupe\": true     }   ] } ```  # Health monitor The Rubrik REST API endpoints for health monitor will allow users to get insight into the health of individual nodes or the entire Rubrik cluster. Currently, the endpoints support following operations: * Retrieve a list of available health monitor policies. * Enforce health monitor policies on one or more nodes of the Rubrik cluster. * Retrieve the status of the health monitor policies.  ## Get health monitor policies To retrieve a list of health monitor policies, send GET request to GET ['/health_monitor/policies'](#operation/getPolicies) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/health_monitor/policies\" ``` The Rubrik REST API server responds with a list of the available health monitor policies. Following output displays the response for Sdfs policy. ```bash [   {     \"policyId\": \"Sdfs\",     \"policyType\": \"CHECKER\",     \"policyName\": \"Sdfs Check\",     \"description\": \"Verify /sd is accessible and the SDFS service is responding\",     \"script\": \"$policyScript\",     \"scope\": \"NODE\",     \"runInState\": [       \"OK\",       \"BAD\"     ],     \"isEnabled\": true,     \"isHidden\": false,     \"scheduleFreqInSec\": 20,     \"causes\": [],     \"remedies\": [],     \"configParams\": [],     \"notificationConfig\": {       \"name\": \"Sdfs Check Failure\",       \"notificationType\": \"DIAGNOSTIC\",       \"notificationMessage\": \"Sdfs check failed\",       \"criticalDetails\": {         \"numFailures\": 150,         \"failureWindow\": 3000,         \"action\": {           \"actionString\": \"$criticalActionScript\",           \"isEnabled\": true         }       },       \"warnDetails\": {         \"numFailures\": 75,         \"failureWindow\": 2000,         \"action\": {           \"actionString\": \"$warnActionScript\",           \"isEnabled\": true         }       }     },     \"dependencies\": []   } ]  ```  ## Run health monitor Policies To enforce health monitor policies on selected nodes or the entire Rubrik cluster send a POST Request to ['/health_monitor/$runPolicy'](#operation/runPolicies) endpoint.  ```bash curl -X POST   -d '{     \"policyIds\": [\"policy_id1\", \"policy_id2\"],     \"nodeIds\": [\"node_id1, node_id2\"]}' \\   \"https://$cluster_address>/api/v1/health_monitor/runPolicy\" ``` The Rubrik REST API server responds with the result of running the health monitor policies. Following output displays the Sdfs policy enforcement response. ``` [   {     \"nodeId\": \"$node_id1\",     \"checkResults\": [       {         \"nodeId\": \"$node_id1\",         \"policyId\": \"Sdfs\",         \"isCheckPassed\": true       }     ]   },   {     \"nodeId\": \"$node_id2\",     \"checkResults\": [       {         \"nodeId\": \"$node_id2\",         \"policyId\": \"Sdfs\",         \"isCheckPassed\": true       }     ]   },   {     \"nodeId\": \"$node_id3\",     \"checkResults\": [       {         \"nodeId\": \"$node_id3\",         \"policyId\": \"Sdfs\",         \"isCheckPassed\": true       }     ]   }  ``` ## Health monitor policy enforcement status To retrieve the status of the policy enforcement, send a GET request to GET ['/health_monitor/policyStatus'](#operation/getPolicyStatus) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/health_monitor/policyStatus? node_ids=<node_id1,node_id2>&policy_ids=policy_id1,policy_id2&has_detailed_status=true\" ``` The Rubrik REST API server responds with the status of running the policies on the selected nodes or the entire Rubrik cluster. ``` [   {     \"nodeId\": \"$node_id1\",     \"checkResults\": [       {         \"nodeId\": \"$node_id1\",         \"policyId\": \"Sdfs\",         \"isCheckPassed\": true,         \"checkOutput\": \"Passed last 12 attempts.\"       }     ]   },   {     \"nodeId\": \"$node_id2\",     \"checkResults\": [       {         \"nodeId\": \"$node_id2\",         \"policyId\": \"Sdfs\",         \"isCheckPassed\": true,         \"checkOutput\": \"Passed last 12 attempts.\"       }     ]   },   {     \"nodeId\": \"$node_id3\",     \"checkResults\": [       {         \"nodeId\": \"$node_id3\",         \"policyId\": \"Sdfs\",         \"isCheckPassed\": true,         \"checkOutput\": \"Passed last 12 attempts.\"       }     ]   } ] ```  # Job Monitoring  ## Get summary information for protection and recovery jobs that are currently ## running, scheduled to run, or completed in the last 24 hours. To get summary information for protection and recovery jobs that are currently running, scheduled to run, or completed in the last 24 hours, send a GET request to [`/job_monitoring`](#operation/getJobMonitoringInfo) endpoint with optional query parameters. The optional query parameters are job_event_status, job_type, is_first_full, nclude_log_related_job, object_type, object_name, node_name, effective_sla_domain_id, last_update_time, after_id, sort_by, sort_order and limit. The default sort sort_by is start time with sort_order as asc.  ```bash curl -X GET \"https://$cluster_address/api/v1/job_monitoring?job_event_status=Active,Queued&limit=1&sort_by=StartTime&sort_order=asc\" ```  The list of jobs matching the filters is returned. ```bash {   \"jobMonitoringInfoList\": [     {       \"jobMonitoringState\": \"Active\",       \"jobStatus\": \"Queued\",       \"jobType\": \"Replication\",       \"objectId\": \"ObjectId,       \"objectType\": \"VmwareVirtualMachine\",       \"objectName\": \"object name\",       \"locationId\": \"location id\",       \"locationName\": \"location name\",       \"slaDomainId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",       \"slaDomainName\": \"Sla name\",       \"startTime\": \"2019-10-28T22:15:14.868Z\",       \"isFirstFullSnapshot\": false,       \"retryCount\": 0,       \"eventSeriesId\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",       \"duration\": 1802576,       \"nodeId\": \"node_id\",       \"warningCount\": 0,       \"lastUpdatedTime\": \"2019-10-28T22:15:15.088Z\"     }   ],   \"jobEventStatus\": [\"Active\",\"Queued\"],   \"shouldIncludeLogRelatedJob\": false,   \"afterId\": \"afterId\",   \"hasMore\": true } ``` ## Get job summary information for protection and recovery jobs separated by ## job type that have been scheduled, are currently running, or completed in ## the past 24 hours. To get job summary information for protection and recovery jobs separated by job type that have been scheduled, are currently running, or completed in the past 24 hours,send a GET request to [`/job_monitoring/summary_by_job_type`](#operation/getMonitoringJobCountByJobType) with the required job_monitoring_state parameter.  ```bash curl -X GET \"https://$cluster_address/api/v1/job_monitoring/summary_by_job_type?job_monitoring_state=Active\" ```  The reponse is the the number of jobs for the given state separated by job_type.  ```bash {   \"jobMonitoringState\": \"Active\",   \"objectCounts\": {     \"total\": 37,     \"archival\": 10,     \"backup\": 15,     \"instantiate\": 0,     \"recovery\": 0,     \"replication\": 12,     \"logBackup\": 0,     \"logArchival\": 0,     \"logReplication\": 0,     \"logShipping\": 0   } } ``` ## Get job summary information separated by job state for all running jobs, ## jobs that have been scheduled, and jobs that are complete, for protection ## and recovery jobs in the past 24 hours. To get job summary information separated by job state for all running jobs, jobs that have been scheduled, and jobs that are complete, for protection and recovery jobs in the past 24 hours, send a GET request to [`/job_monitoring/get_summary_by_job_state`](#operation/getMonitoringJobCountByJobState) with the optional parameter job_types to get the count only for a specific state.  ```bash curl -X GET \"https://$cluster_address/api/v1/job_monitoring/get_summary_by_job_state\" ```  The response is the number of jobs in each state.  ```bash {   \"jobTypes\": [     \"Instantiate\",     \"LogReplication\",     \"Archival\",     \"Replication\",     \"LogBackup\",     \"LogShipping\",     \"Backup\",     \"Recovery\",     \"LogArchival\"   ],   \"objectCounts\": {     \"total\": 52,     \"failure\": 2,     \"active\": 15,     \"scheduled\": 10,     \"success\": 25   } } ```  ## Get a link to to download the job summary information as a CSV file, with ## the same filters as in the `GET /job_monitoring/` API. To get a link to to download the job summary information as a CSV file, send a GET request to [`/job_monitoring/csv_download_link`](#operation/getJobMonitoringInfoCsvDownloadLink)  with require parameter job_monitoring_state.  ```bash curl -X GET \"https://$cluster_address/api/v1/job_monitoring/csv_download_link?job_monitoring_state=Active\" ```  The link to the file is returned.  ```bash {   \"downloadLink\": \"https://$cluster_address/report_dir/name.csv\",   \"jobMonitoringState\": \"Active\" } ```  ## Create an email subscription to the monitoring page with user-specified ## job states. To create an email subscription to the monitoring page, send a POST request to [`/job_monitoring/subscription`](#operation/createMonitoringSubscription)  with required parameter subscription_request.  ```bash curl -X POST -d '{   \"timeAttributes\": \"$timeAttributes\",   \"emailAddresses\": \"$emailAddresses\",   \"attachments\": \"$attachments\",   \"jobStates\": \"$jobStates\" }' \"https://$cluster_address/api/v1/job_monitoring/subscription\" ```  The summary of the created monitoring email subscription is returned.  ```bash {   \"timeAttributes\": {\"dailyScheduleHour\": 7},   \"emailAddresses\": [\"abcde@rubrik.com\"],   \"attachments\": [\"Csv\"],   \"jobStates\": [\"Active\"],   \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",   \"status\": \"Active\",   \"owner\": {     \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",     \"userName\": \"Owner\"   } } ```  ## Get all monitoring page email subscriptions. To get all email subscriptions to the monitoring page, send a GET request to [`/job_monitoring/subscription`] (#operation/getMonitoringSubscriptions)  with no parameters.  ```bash curl -X GET \"https://$cluster_address/api/v1/job_monitoring/subscription\" ```  A summary of all unarchived email subscriptions for monitoring   page in a list of summaries sorted by creation time (earliest   created first).   Each summary contains information for each subscription   -- Time attributes - when to send the email   -- Email addresses - who to send the email   -- Attachments - what attachments should the email include   -- Job states - which job states to include in the email       (Failure, Scheduled, Success, Active, Canceled).   -- Id - the tring that identifies the subscription   -- Status - the status of the subscription       (Active, Suspended, or Unknown)   -- Owner - information about the owner of the subscription     -- user id - unique id used to identify the owner     -- user name - human-readable name of user        the time schedule to send the subscription  ```bash [   {     \"timeAttributes\": {\"dailyScheduleHour\": 7},     \"emailAddresses\": [\"abcde@rubrik.com\"],     \"attachments\": [\"Csv\"],     \"jobStates\": [\"Active\"],     \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",     \"status\": \"Suspended\",     \"owner\": {       \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",       \"userName\": \"Owner\"     }   },   {     \"timeAttributes\": {\"dailyScheduleHour\": 20},     \"emailAddresses\": [\"dummy@rubrik.com\"],     \"attachments\": [\"Csv\"],     \"jobStates\": [\"Failure\", \"Canceled\"],     \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",     \"status\": \"Active\",     \"owner\": {       \"userId\": \"499aeb71-f114-45a5-8456-91b9f6c45ddd\",       \"userName\": \"Owner\"     }   }, ] ```  ## Get a monitoring page email subscription. To get an email subscription to the monitoring page, send a GET request to [`/job_monitoring/subscription/{subscription_id}`] (#operation/getMonitoringSubscription)  with required parameter subscription_id.  ```bash curl -X GET \"https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\" ```  The summary of the created monitoring email subscription is returned.  ```bash {   \"timeAttributes\": {\"dailyScheduleHour\": 7},   \"emailAddresses\": [\"abcde@rubrik.com\"],   \"attachments\": [\"Csv\"],   \"jobStates\": [\"Active\"],   \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",   \"status\": \"Active\",   \"owner\": {     \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",     \"userName\": \"Owner\"   } } ```  ## Update an existing monitoring page email subscription. To update an email subscription to the monitoring page, send a PATCH request to [`/job_monitoring/subscription/{subscription_id}`] (#operation/updateMonitoringSubscription)  with required parameter subscription_id.  ```bash curl -X PATCH -d '{   \"timeAttributes\": \"$timeAttributes\",   \"emailAddresses\": \"$emailAddresses\",   \"attachments\": \"$attachments\",   \"jobStates\": \"$jobStates\",   \"id\": \"$id\",   \"assumeOwnership\": \"$assumeOwnership\" }' \"https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\" ```  The summary of the updated monitoring email subscription is returned.  ```bash {   \"timeAttributes\": {\"dailyScheduleHour\": 7},   \"emailAddresses\": [\"abcde@rubrik.com\"],   \"attachments\": [\"Csv\"],   \"jobStates\": [\"Active\"],   \"id\": \"b3a00c13-74de-4508-80cd-822d5f2960fe\",   \"status\": \"Active\",   \"owner\": {     \"userId\": \"6d29f271-d706-47a5-a706-f4411ae5555a\",     \"userName\": \"Owner\"   } } ```  ## Delete an existing monitoring page email subscription. To delete an email subscription to the monitoring page, send a DELETE request to [`/job_monitoring/subscription/{subscription_id}`] (#operation/deleteMonitoringSubscription)  with required parameter subscription_id.  ```bash curl -X DELETE \"https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\" ```  # Rubrik syslog management  Rubrik CDM clusters include the capability to add export rules to forward syslog information to remote servers.  # Managing the Rubrik cluster syslog settings  To view all the currently configured syslog export rules, send a GET request to the [`/syslog/export`](#operation/getSyslogExportRules) endpoint.  **Example:** Retrieving the currently configured syslog export rules for a Rubrik cluster.  ```bash curl -X GET \"https://$cluster_address/api/v1/syslog/export\" ```  To add a new syslog export rule, send a POST request to the [`/syslog/export`](#operation/addSyslogExportRule) endpoint.  **Example:** Adding a new syslog export rule for a Rubrik cluster  ```bash curl -X POST \"https://$cluster_address/api/v1/syslog/export\" ```  To retrieve a syslog export rule, send a GET request with the export rule ID to the [`/syslog/export/{id}`](#operation/getSyslogExportRule) endpoint.  To modify a syslog export rule, send a PATCH request with the export rule ID to the [`/syslog/export/{id}`](#operation/updateSyslogExportRule) endpoint.  To remove a syslog export rule, send a DELETE request with the export rule ID to the [`/syslog/export/{id}`](#operation/deleteSyslogExportRule) endpoint.  **Example:** Managing individual syslog export rules for a Rubrik cluster  ```bash curl -X GET \"https://$cluster_address/api/v1/syslog/export/{id}\" curl -X PATCH \"https://$cluster_address/api/v1/syslog/export/{id}\" curl -X DELETE \"https://$cluster_address/api/v1/syslog/export/{id}\" ```  To test a syslog export rule, send a POST request with the export rule information to the [`/syslog/export/test`](#operation/testSyslogExportRule) endpoint.  **Example:** Testing a syslog export rule for a Rubrik cluster  ```bash curl -X POST \"https://$cluster_address/api/v1/syslog/export/test\" ```  # Rubrik user management  Rubrik CDM clusters include the capability to manage access to resources using local users.  # Managing the Rubrik local user account lockout  To view the current local user account lockout configuration, send a GET request to the [`/user/lockout`](#operation/getUserAccountLockoutSettings) endpoint.  **Example:** Retrieving the current local user account lockout configuration for a Rubrik cluster  ```bash curl -X GET \"https://$cluster_address/api/v1/user/lockout\" ```  To update the lockout configuration, send a PATCH request to the [`/user/lockout`](#operation/manageUserAccountLockoutSettings) endpoint.  **Example:** Updating the local user account lockout configuration for a Rubrik cluster.  ```bash curl -X PATCH \"https://$cluster_address/api/v1/user/lockout\" ```  ## Unlocking a locked user To unlock a locked user, send a POST request to the [`/user/{id}/unlock`](#operation/unlockUser) endpoint  **Example:** Unlocking a locked local user on CDM cluster ```bash curl -X POST \"https://$cluster_address/api/v1/user/{id}/unlock\" ```  # Configuring users with TOTP as 2FA  To fetch the TOTP status for an account, send a GET request to the [`/user/{id}/totp/status`](#operation/getTotpStatus) endpoint.  **Example:** Retrieving TOTP status  ```bash curl -X GET \"https://$cluster_address/api/v1/user/{id}/totp/status\" ```  To configure and enable TOTP for an account, send a PUT request to the [`/user/{id}/totp/config`](#operation/setupTotp) endpoint.  **Example:** Configure TOTP ```bash curl -X PUT \"https://$cluster_address/api/v1/user/{id}/totp/config\" ```  To reset and disable TOTP for an account, send a DELETE request to the [`/user/{id}/totp/config`](#operation/resetTotp) endpoint.  **Example:** Reset TOTP ```bash curl -X DELETE \"https://$cluster_address/api/v1/user/{id}/totp/config\" ```  To generate TOTP secret for an account, send a POST request to the [`/user/{id}/totp/new_secret`](#operation/generateTotpSecret) endpoint.  **Example:** Generate TOTP secret ```bash curl -X POST \"https://$cluster_address/api/v1/user/{id}/totp/new_secret\" ```  # MFA Servers  An MFA Server is a server that Rubrik can be configured with in order to support integrations with external multi-factor authentication services.  ## Adding a server To add an MFA Server to the cluster, send a POST request to the [`/mfa/rsa/server`](#operation/createRsaMfaServer) endpoint.  ```bash curl -X POST -d \\   '   {   \"name\": \"string\",   \"timeout\": 0,   \"baseUrl\": \"string\",   \"clientId\": \"string\",   \"assurancePolicyName\": \"string\",   \"ldapUsernameAttribute\": \"string\",   \"certificateId\": \"string\",   \"restApiKey\": \"string\",   \"restApiAccessId\": \"string\"   }   ' \\   \"https://$cluster_address/api/v1/mfa/rsa/server\" ``` ```bash {   \"name\": \"string\",   \"timeout\": 0,   \"baseUrl\": \"string\",   \"clientId\": \"string\",   \"assurancePolicyName\": \"string\",   \"ldapUsernameAttribute\": \"string\",   \"certificateId\": \"string\",   \"id\": \"string\" } ``` ## Getting MFA Servers To get all MFA Servers configured on the cluster, leverage a GET request on the [`/mfa/rsa/server`](#operation/queryRsaMfaServers) endpoint.  ```bash curl -X GET \"https://$cluster_address/api/v1/mfa/rsa/server\" ``` ```bash {   \"hasMore\": true,   \"data\": [     {       \"name\": \"string\",       \"timeout\": 0,       \"baseUrl\": \"string\",       \"clientId\": \"string\",       \"assurancePolicyName\": \"string\",       \"ldapUsernameAttribute\": \"string\",       \"certificateId\": \"string\",       \"id\": \"string\"     }   ],   \"total\": 0 } ```  ## Deleting MFA Server Integrations In order to delete a specific MFA Server integration, make a DELETE call to the [`/mfa/rsa/server/{id}`](#operation/deleteRsaMfaServer) endpoint.  ```bash curl -X DELETE \\   -d '{     \"id\": \"$server_id\" }' \\   \"https://$cluster_address/api/v1/mfa/rsa/server/{id}\" ```  ## Getting an MFA Server In order to retrieve a specific MFA server integration, make a GET call to the [`/mfa/rsa/server/{id}`](#operation/getRsaMfaServer) endpoint.  ```bash curl -X POST \\   -d '{     \"id\": \"server_id\" }' \\   \"https://$cluster_address/api/v1/mfa/rsa/server/{id}\" ``` ```bash {   \"name\": \"string\",   \"timeout\": 0,   \"baseUrl\": \"string\",   \"clientId\": \"string\",   \"assurancePolicyName\": \"string\",   \"ldapUsernameAttribute\": \"string\",   \"certificateId\": \"string\",   \"id\": \"string\" } ```  ## Updating an MFA Server In order to update a specific MFA Server integration, make a PATCH call to the [`/mfa/rsa/server/{id}`](#operation/updateRsaMfaServer) endpoint.  ```bash curl -X PATCH \\   -d '{ {   \"name\": \"string\",   \"timeout\": 0,   \"baseUrl\": \"string\",   \"restApiKey\": \"string\",   \"clientId\": \"string\",   \"assurancePolicyName\": \"string\",   \"restApiAccessId\": \"string\",   \"ldapUsernameAttribute\": \"string\",   \"certificateId\": \"string\" }     ' \\   \"https://$cluster_address/api/v1/mfa/rsa/server/{id}\" ``` ```bash {   \"name\": \"string\",   \"timeout\": 0,   \"baseUrl\": \"string\",   \"clientId\": \"string\",   \"assurancePolicyName\": \"string\",   \"ldapUsernameAttribute\": \"string\",   \"certificateId\": \"string\",   \"id\": \"string\" } ```  # Legal  ## Copyright  Rubrik REST API - Copyright © 2017-2021 Rubrik Inc. All rights reserved.  This documentation may be used free of charge. Selling without prior written consent is prohibited. Obtain permission before redistributing. In all cases, this copyright notice and disclaimer must remain intact.   ## Disclaimer  THE CONTENTS OF THIS DOCUMENTATION ARE PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENTATION ARE SUITABLE FOR ANY PURPOSE; THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENTATION OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.  ## Trademarks  Rubrik, the Rubrik logo, Rubrik Envision, and Rubrik Edge are trademarks or registered trademarks of Rubrik, Inc. in the U.S. and/or other countries. All other trademarks are the property of their respective owners.  # Report Config  ## Update the config parameters related to Reports Send a PATCH request to [`/report/config`](#operation/setReportConfig) This request updates the configuration parameters related to the reporting framework. `cleanupReportJobInstanceForLogJobs` specifies an interval in days. Log jobs in report job instances are retained for the specified interval.  ```bash curl -X PATCH \"https://$cluster_address/api/v1/report/config\" ```  ## Get summary information for backup compliance based on each 24 hour time period Send a GET request to [`/report/compliance_summary`](#operation/getComplianceSummaryV1)  ```bash curl -X GET \"https://$cluster_address/api/v1/report/compliance_summary\" ```  ## Get summary information for backup compliance based on snapshot range Send a GET request to  [`/report/compliance_summary_sla`](#operation/getComplianceSummarySLAV1)  ```bash curl -X GET \"https://$cluster_address/api/v1/report/compliance_summary_sla\" ```  #Database log backup report  #Get the database log report summary  To get the database log report summary, send a GET request to the [`/database/log_report`](#operation/queryLogReport) end point  **Example:** Retrieving the database log report summary  ```bash curl -X GET \"https://$cluster_address/api/v1/database/log_report\" ``` ```bash {   \"total\": 1,   \"data\": [     {       \"effectiveSlaDomainName\": \"sla_name\",       \"id\": \"$db_id\",       \"name\": \"$db_name\",       \"location\": \"$location_name\",       \"databaseType\": \"$db_type\",       \"primaryClusterId\": \"$cluster_id\",       \"logBackupFrequency\": 3600,       \"lastSnapshotTime\": \"2020-11-10T22:21:43.000Z\",       \"effectiveSlaDomainId\": \"$sla_id\"     }   ],   \"hasMore\": false } ```  #Get the database log report properties  To get the database log report properties, send a GET request to the [`/database/log_report/defaults`](#operation/queryReportProperties) end point   **Example:** Retrieving the database log report properties  ```bash curl -X GET \"https://$cluster_address/api/v1/database/log_report/defaults\" ``` ```bash {   \"logDelayNotificationFrequencyInMin\": 720,   \"logDelayThresholdInMin\": 720,   \"enableDelayNotification\": false } ```  #Update the database log report properties  To update the database log report properties, send a PATCH request to the [`/database/log_report/defaults`](#operation/updateReportProperties) end point   **Example:** Update the database log report properties  ```bash curl -X PATCH \"https://$cluster_address/api/v1/database/log_report/defaults\" -d\\ '{     \"logDelayNotificationFrequencyInMin\": 360,     \"logDelayThresholdInMin\": 120,     \"enableDelayNotification\": true  }' ```  # Organization  ## Create a list of Rubrik Envoy objects To create a list of Rubrik Envoy objects, send a POST request to the [`/organization/{id}/envoy/bulk`](#operation/bulkCreateEnvoys) endpoint. The request takes an ID for the Organization and the information about the Rubrik Envoy objects.  ```bash curl -X POST \"https://$cluster_address/api/v1/organization/{id}/envoy/bulk\" ```  The Rubrik REST API server responds with a `ListResponse` object. ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"string\",       \"ipAddress\": \"string\",       \"port\": 1234,       \"organizationId\": \"string\",       \"status\": \"Connected\",     },   ] } ```  ## Remove a list of Rubrik Envoy objects To remove a list of Rubrik Envoy objects, send a DELETE request to the [`/organization/{id}/envoy/bulk`](#operation/bulkDeleteEnvoys) endpoint. The request takes an ID for the Organization and a list of IDs for Rubrik Envoy objects.  ```bash curl -X DELETE \"https://$cluster_address/api/v1/organization/{id}/envoy/bulk\" ```  The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  ## Update a list of Rubrik Envoy objects To update a list of Rubrik Envoy objects, send a PATCH request to the [`/organization/{id}/envoy/bulk`](#operation/bulkUpdateEnvoys) endpoint. The request takes an ID for the Organization and the information about the Rubrik Envoy objects.  ```bash curl -X PATCH \"https://$cluster_address/api/v1/organization/{id}/envoy/bulk\" ```  The Rubrik REST API server responds with a `ListResponse` object. ```bash {   \"hasMore\": true,   \"data\": [     {       \"id\": \"string\",       \"ipAddress\": \"string\",       \"port\": 1234,       \"organizationId\": \"string\",       \"status\": \"Connected\",     },   ] } ``` 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from './ApiClient';
import ActionDetails from './model/ActionDetails';
import ActivityLogSummaryV1 from './model/ActivityLogSummaryV1';
import ActivityLogSummaryV1ListResponse from './model/ActivityLogSummaryV1ListResponse';
import AdaptiveThrottlingSettingsVmwareFields from './model/AdaptiveThrottlingSettingsVmwareFields';
import AdvancedLdapConfiguration from './model/AdvancedLdapConfiguration';
import AdvancedUiConfigAttributes from './model/AdvancedUiConfigAttributes';
import AgentSecondaryCertificateInfo from './model/AgentSecondaryCertificateInfo';
import AgentSecondaryCertificateInfoListResponse from './model/AgentSecondaryCertificateInfoListResponse';
import AgentStatus from './model/AgentStatus';
import AppSearchResponse from './model/AppSearchResponse';
import AppSearchResponseListResponse from './model/AppSearchResponseListResponse';
import ApplyLegalHoldDefinition from './model/ApplyLegalHoldDefinition';
import ArchivalSpec from './model/ArchivalSpec';
import ArchivalSpecV2 from './model/ArchivalSpecV2';
import ArchivalTieringSpec from './model/ArchivalTieringSpec';
import AsyncRequestStatus from './model/AsyncRequestStatus';
import AuthDomainType from './model/AuthDomainType';
import AvailableVersionInfo from './model/AvailableVersionInfo';
import AwsEc2InstanceSlaObjectCount from './model/AwsEc2InstanceSlaObjectCount';
import BackupTaskDiagnosticInfo from './model/BackupTaskDiagnosticInfo';
import BackupWindow from './model/BackupWindow';
import BaseGuestCredential from './model/BaseGuestCredential';
import BaseGuestCredentialDetail from './model/BaseGuestCredentialDetail';
import BaseOnDemandSnapshotConfig from './model/BaseOnDemandSnapshotConfig';
import BaseSnapshotDetail from './model/BaseSnapshotDetail';
import BaseSnapshotSummary from './model/BaseSnapshotSummary';
import BatchAsyncRequest from './model/BatchAsyncRequest';
import BatchAsyncRequestStatus from './model/BatchAsyncRequestStatus';
import BatchMountSnapshotJobConfig from './model/BatchMountSnapshotJobConfig';
import BatchVmSnapshotSummaries from './model/BatchVmSnapshotSummaries';
import BatchVmwareCdpLiveInfo from './model/BatchVmwareCdpLiveInfo';
import BatchVmwareCdpStateInfo from './model/BatchVmwareCdpStateInfo';
import BatchVmwareVmMissedRecoverableRanges from './model/BatchVmwareVmMissedRecoverableRanges';
import BatchVmwareVmMissedRecoverableRangesRequest from './model/BatchVmwareVmMissedRecoverableRangesRequest';
import BatchVmwareVmRecoverableRanges from './model/BatchVmwareVmRecoverableRanges';
import BatchVmwareVmRecoverableRangesRequest from './model/BatchVmwareVmRecoverableRangesRequest';
import BlackoutWindow from './model/BlackoutWindow';
import BlackoutWindowResponseInfo from './model/BlackoutWindowResponseInfo';
import BlackoutWindowStatus from './model/BlackoutWindowStatus';
import BlackoutWindows from './model/BlackoutWindows';
import BooleanResponse from './model/BooleanResponse';
import BootstrappableNodeInfoV1 from './model/BootstrappableNodeInfoV1';
import BootstrappableNodeIpv4Info from './model/BootstrappableNodeIpv4Info';
import BrowseResponse from './model/BrowseResponse';
import BrowseResponseListResponse from './model/BrowseResponseListResponse';
import BulkDeleteObjectSnapshotsConfig from './model/BulkDeleteObjectSnapshotsConfig';
import BulkDeleteSnapshotsConfig from './model/BulkDeleteSnapshotsConfig';
import BulkOnDemandSnapshotJobConfig from './model/BulkOnDemandSnapshotJobConfig';
import BulkOracleDbDetails from './model/BulkOracleDbDetails';
import BulkOracleHostDetails from './model/BulkOracleHostDetails';
import BulkOracleRacDetails from './model/BulkOracleRacDetails';
import BulkShareAddResponse from './model/BulkShareAddResponse';
import BulkSlaConflictsSummary from './model/BulkSlaConflictsSummary';
import BulkTierSnapshotsConfig from './model/BulkTierSnapshotsConfig';
import CdpLocalStatus from './model/CdpLocalStatus';
import CdpReplicationStatus from './model/CdpReplicationStatus';
import CdpState from './model/CdpState';
import CertificateImportRequest from './model/CertificateImportRequest';
import CertificateListSortAttributes from './model/CertificateListSortAttributes';
import CertificatePatchRequest from './model/CertificatePatchRequest';
import CertificateSummary from './model/CertificateSummary';
import CertificateSummaryListResponse from './model/CertificateSummaryListResponse';
import CloudInstantiationSpec from './model/CloudInstantiationSpec';
import CloudOutComputeForecastSummaries from './model/CloudOutComputeForecastSummaries';
import CloudOutComputeForecastSummary from './model/CloudOutComputeForecastSummary';
import CloudOutForecastRequest from './model/CloudOutForecastRequest';
import CloudOutForecastSlaParameters from './model/CloudOutForecastSlaParameters';
import CloudOutForecastSummary from './model/CloudOutForecastSummary';
import CloudOutStorageForecastSummaries from './model/CloudOutStorageForecastSummaries';
import CloudOutStorageForecastSummary from './model/CloudOutStorageForecastSummary';
import CloudStorageColdTier from './model/CloudStorageColdTier';
import CloudStorageRehydrationSpeed from './model/CloudStorageRehydrationSpeed';
import ClusterApiVersion from './model/ClusterApiVersion';
import ClusterCertificate from './model/ClusterCertificate';
import ClusterGeolocation from './model/ClusterGeolocation';
import ClusterHostGroupInfo from './model/ClusterHostGroupInfo';
import ClusterInfo from './model/ClusterInfo';
import ClusterTimezone from './model/ClusterTimezone';
import ClusterUpdate from './model/ClusterUpdate';
import ClusterVersion from './model/ClusterVersion';
import ClusterVisibilityConfig from './model/ClusterVisibilityConfig';
import ClusterVisibilityInfo from './model/ClusterVisibilityInfo';
import CommunityUserCredentials from './model/CommunityUserCredentials';
import ComplianceRangeFilter from './model/ComplianceRangeFilter';
import ComplianceSummarySLAV1 from './model/ComplianceSummarySLAV1';
import ComplianceSummaryStatus from './model/ComplianceSummaryStatus';
import ComplianceSummaryV1 from './model/ComplianceSummaryV1';
import ComputeClusterDetail from './model/ComputeClusterDetail';
import ComputeClusterSummary from './model/ComputeClusterSummary';
import ComputeClusterSummaryListResponse from './model/ComputeClusterSummaryListResponse';
import ComputeClusterUpdate from './model/ComputeClusterUpdate';
import ConfigChangeSource from './model/ConfigChangeSource';
import ConfigParam from './model/ConfigParam';
import ConfigurationSummary from './model/ConfigurationSummary';
import ConfigurationSummaryListResponse from './model/ConfigurationSummaryListResponse';
import ConfigurationUpdateSummary from './model/ConfigurationUpdateSummary';
import ConfigurationUpdateSummaryListResponse from './model/ConfigurationUpdateSummaryListResponse';
import ConfiguredSlaType from './model/ConfiguredSlaType';
import CorsConfiguration from './model/CorsConfiguration';
import CorsConfigurationPatch from './model/CorsConfigurationPatch';
import CountResponse from './model/CountResponse';
import CreateNewVappParams from './model/CreateNewVappParams';
import CreateVappNetworkParams from './model/CreateVappNetworkParams';
import CsrRequest from './model/CsrRequest';
import CsrSummary from './model/CsrSummary';
import CsrSummaryListResponse from './model/CsrSummaryListResponse';
import DataCenterSummary from './model/DataCenterSummary';
import DataGuardGroupMember from './model/DataGuardGroupMember';
import DataGuardType from './model/DataGuardType';
import DataStoreSummary from './model/DataStoreSummary';
import DatabaseType from './model/DatabaseType';
import DbLogReportProperties from './model/DbLogReportProperties';
import DbLogReportPropertiesUpdate from './model/DbLogReportPropertiesUpdate';
import DbLogReportSummary from './model/DbLogReportSummary';
import DbLogReportSummaryListResponse from './model/DbLogReportSummaryListResponse';
import DbLogReportSummaryListSortAttribute from './model/DbLogReportSummaryListSortAttribute';
import DiagnosticTaskStatus from './model/DiagnosticTaskStatus';
import DisablePerLocationPause from './model/DisablePerLocationPause';
import DiscoveredNasShare from './model/DiscoveredNasShare';
import DissolveLegalHoldDefinition from './model/DissolveLegalHoldDefinition';
import DissolveLegalHoldResponse from './model/DissolveLegalHoldResponse';
import DownloadFileJobConfig from './model/DownloadFileJobConfig';
import DownloadJobInfo from './model/DownloadJobInfo';
import DownloadMssqlBackupFilesByIdJobConfig from './model/DownloadMssqlBackupFilesByIdJobConfig';
import DownloadedSnapshotSlaAssignmentInfo from './model/DownloadedSnapshotSlaAssignmentInfo';
import EffectiveSlaHolder from './model/EffectiveSlaHolder';
import EnablePerLocationPause from './model/EnablePerLocationPause';
import EncryptionStatus from './model/EncryptionStatus';
import EnvoyBulkUpdate from './model/EnvoyBulkUpdate';
import EnvoyCreate from './model/EnvoyCreate';
import EnvoyDetail from './model/EnvoyDetail';
import EnvoyDetailList from './model/EnvoyDetailList';
import EnvoyIdList from './model/EnvoyIdList';
import EnvoySummary from './model/EnvoySummary';
import EnvoyUpdate from './model/EnvoyUpdate';
import EnvoyUserInfo from './model/EnvoyUserInfo';
import EventCsvDownloadResponse from './model/EventCsvDownloadResponse';
import EventNotification from './model/EventNotification';
import EventSeriesStatusV1 from './model/EventSeriesStatusV1';
import EventSeriesSummaryV1 from './model/EventSeriesSummaryV1';
import EventSeverityV1 from './model/EventSeverityV1';
import EventStatusV1 from './model/EventStatusV1';
import EventSummaryV1 from './model/EventSummaryV1';
import EventTypeV1 from './model/EventTypeV1';
import EventsAndSeriesSummariesResponse from './model/EventsAndSeriesSummariesResponse';
import EventsAndSeriesSummariesV1 from './model/EventsAndSeriesSummariesV1';
import ExampleEnum from './model/ExampleEnum';
import ExclusionPatternCreateConfig from './model/ExclusionPatternCreateConfig';
import ExclusionPatternDetail from './model/ExclusionPatternDetail';
import ExclusionPatternDetailList from './model/ExclusionPatternDetailList';
import ExclusionPatternDetailListResponse from './model/ExclusionPatternDetailListResponse';
import ExclusionPatternUpdateConfig from './model/ExclusionPatternUpdateConfig';
import ExistingSnapshotRetention from './model/ExistingSnapshotRetention';
import ExpiredCustomRetentionSnapshotInfo from './model/ExpiredCustomRetentionSnapshotInfo';
import ExpiredCustomRetentionSnapshots from './model/ExpiredCustomRetentionSnapshots';
import ExportMssqlDbJobConfig from './model/ExportMssqlDbJobConfig';
import ExportSnapshotJobConfigV1 from './model/ExportSnapshotJobConfigV1';
import FailoverClusterAppConfig from './model/FailoverClusterAppConfig';
import FailoverClusterAppConnectionStatus from './model/FailoverClusterAppConnectionStatus';
import FailoverClusterAppDetail from './model/FailoverClusterAppDetail';
import FailoverClusterAppSource from './model/FailoverClusterAppSource';
import FailoverClusterAppSummary from './model/FailoverClusterAppSummary';
import FailoverClusterAppSummaryListResponse from './model/FailoverClusterAppSummaryListResponse';
import FailoverClusterConfig from './model/FailoverClusterConfig';
import FailoverClusterConnectionStatus from './model/FailoverClusterConnectionStatus';
import FailoverClusterDetail from './model/FailoverClusterDetail';
import FailoverClusterHierarchyObjectDescendentCount from './model/FailoverClusterHierarchyObjectDescendentCount';
import FailoverClusterHierarchyObjectSortAttribute from './model/FailoverClusterHierarchyObjectSortAttribute';
import FailoverClusterHierarchyObjectSummary from './model/FailoverClusterHierarchyObjectSummary';
import FailoverClusterHierarchyObjectSummaryListResponse from './model/FailoverClusterHierarchyObjectSummaryListResponse';
import FailoverClusterNode from './model/FailoverClusterNode';
import FailoverClusterNodeConnectionStatus from './model/FailoverClusterNodeConnectionStatus';
import FailoverClusterNodeOrder from './model/FailoverClusterNodeOrder';
import FailoverClusterNodeOsType from './model/FailoverClusterNodeOsType';
import FailoverClusterObjectType from './model/FailoverClusterObjectType';
import FailoverClusterOsType from './model/FailoverClusterOsType';
import FailoverClusterSummary from './model/FailoverClusterSummary';
import FailoverClusterSummaryListResponse from './model/FailoverClusterSummaryListResponse';
import FailoverClusterType from './model/FailoverClusterType';
import FileSystemType from './model/FileSystemType';
import FileVersion from './model/FileVersion';
import FilesetArraySpec from './model/FilesetArraySpec';
import FilesetCreate from './model/FilesetCreate';
import FilesetDetail from './model/FilesetDetail';
import FilesetDownloadFileJobConfig from './model/FilesetDownloadFileJobConfig';
import FilesetExportFileJobConfig from './model/FilesetExportFileJobConfig';
import FilesetOptions from './model/FilesetOptions';
import FilesetRestoreFileJobConfig from './model/FilesetRestoreFileJobConfig';
import FilesetSnapshotDetail from './model/FilesetSnapshotDetail';
import FilesetSnapshotSummary from './model/FilesetSnapshotSummary';
import FilesetSnapshotVerbose from './model/FilesetSnapshotVerbose';
import FilesetSummary from './model/FilesetSummary';
import FilesetSummaryListResponse from './model/FilesetSummaryListResponse';
import FilesetTemplateCreate from './model/FilesetTemplateCreate';
import FilesetTemplateDetail from './model/FilesetTemplateDetail';
import FilesetTemplateDetailListResponse from './model/FilesetTemplateDetailListResponse';
import FilesetTemplatePatch from './model/FilesetTemplatePatch';
import FilesetUpdate from './model/FilesetUpdate';
import FipsStatus from './model/FipsStatus';
import FipsStatusPatch from './model/FipsStatusPatch';
import ForceFullVolumeInfo from './model/ForceFullVolumeInfo';
import ForecastAssumptions from './model/ForecastAssumptions';
import ForecastConsolidationFilter from './model/ForecastConsolidationFilter';
import ForecastGranularity from './model/ForecastGranularity';
import FrequencyChangeRates from './model/FrequencyChangeRates';
import FrequencyConfig from './model/FrequencyConfig';
import FullyQualifiedDomainNameInfo from './model/FullyQualifiedDomainNameInfo';
import GenericCsrRequest from './model/GenericCsrRequest';
import GlobalBlackoutWindowStatus from './model/GlobalBlackoutWindowStatus';
import HdfsBaseConfig from './model/HdfsBaseConfig';
import HdfsConfig from './model/HdfsConfig';
import HdfsCreate from './model/HdfsCreate';
import HdfsDetail from './model/HdfsDetail';
import HdfsExportFileJobConfig from './model/HdfsExportFileJobConfig';
import HdfsHost from './model/HdfsHost';
import HdfsRestoreFileJobConfig from './model/HdfsRestoreFileJobConfig';
import HdfsSnapshotDetail from './model/HdfsSnapshotDetail';
import HdfsSnapshotSummary from './model/HdfsSnapshotSummary';
import HdfsSummary from './model/HdfsSummary';
import HdfsSummaryListResponse from './model/HdfsSummaryListResponse';
import HdfsTemplateCreate from './model/HdfsTemplateCreate';
import HdfsTemplateDetail from './model/HdfsTemplateDetail';
import HdfsTemplateDetailListResponse from './model/HdfsTemplateDetailListResponse';
import HdfsTemplatePatch from './model/HdfsTemplatePatch';
import HdfsUpdate from './model/HdfsUpdate';
import HealthMonitorPolicy from './model/HealthMonitorPolicy';
import HierarchyObjectIds from './model/HierarchyObjectIds';
import HoldConfig from './model/HoldConfig';
import HostConfigurationPropertyEnabled from './model/HostConfigurationPropertyEnabled';
import HostDetail from './model/HostDetail';
import HostFilterStatus from './model/HostFilterStatus';
import HostGroupInfo from './model/HostGroupInfo';
import HostHierarchyObjectDescendantCount from './model/HostHierarchyObjectDescendantCount';
import HostHierarchyObjectSortAttribute from './model/HostHierarchyObjectSortAttribute';
import HostHierarchyObjectSummary from './model/HostHierarchyObjectSummary';
import HostHierarchyObjectSummaryListResponse from './model/HostHierarchyObjectSummaryListResponse';
import HostInfo from './model/HostInfo';
import HostMakePrimaryRequest from './model/HostMakePrimaryRequest';
import HostObjectType from './model/HostObjectType';
import HostOperatingSystemType from './model/HostOperatingSystemType';
import HostRbsStatus from './model/HostRbsStatus';
import HostRegister from './model/HostRegister';
import HostShareDetail from './model/HostShareDetail';
import HostShareParameters from './model/HostShareParameters';
import HostSharePatch from './model/HostSharePatch';
import HostShareUpdate from './model/HostShareUpdate';
import HostShareVendorType from './model/HostShareVendorType';
import HostSummary from './model/HostSummary';
import HostSummaryListResponse from './model/HostSummaryListResponse';
import HostUiFilterStatus from './model/HostUiFilterStatus';
import HostUpdate from './model/HostUpdate';
import HostVfdInstallConfig from './model/HostVfdInstallConfig';
import HostVfdState from './model/HostVfdState';
import HostVolumeSummary from './model/HostVolumeSummary';
import HostVolumeSummaryListResponse from './model/HostVolumeSummaryListResponse';
import HotAddBandwidthInfo from './model/HotAddBandwidthInfo';
import HotAddNetworkConfigWithId from './model/HotAddNetworkConfigWithId';
import HotAddNetworkConfigWithName from './model/HotAddNetworkConfigWithName';
import HotAddProxiesNeededInfo from './model/HotAddProxiesNeededInfo';
import HotAddProxyVmInfo from './model/HotAddProxyVmInfo';
import HotAddProxyVmInfoListResponse from './model/HotAddProxyVmInfoListResponse';
import HotAddProxyVmStatusType from './model/HotAddProxyVmStatusType';
import HypervVirtualDiskForceFullInfo from './model/HypervVirtualDiskForceFullInfo';
import HypervVirtualMachineForceFullRequest from './model/HypervVirtualMachineForceFullRequest';
import HypervVirtualMachineForceFullResponse from './model/HypervVirtualMachineForceFullResponse';
import HypervVmSlaObjectCount from './model/HypervVmSlaObjectCount';
import IdNamePair from './model/IdNamePair';
import IdProviderAuthDomainInfo from './model/IdProviderAuthDomainInfo';
import IdProviderAuthDomainInfoUpdate from './model/IdProviderAuthDomainInfoUpdate';
import IdProviderAuthDomainSummary from './model/IdProviderAuthDomainSummary';
import IdProviderAuthDomainSummaryListResponse from './model/IdProviderAuthDomainSummaryListResponse';
import IdProviderSamlInfo from './model/IdProviderSamlInfo';
import IdProviderSamlInfoUpdate from './model/IdProviderSamlInfoUpdate';
import InstantRecoveryJobConfig from './model/InstantRecoveryJobConfig';
import InternalJobInstanceDetail from './model/InternalJobInstanceDetail';
import IoFilterStatus from './model/IoFilterStatus';
import IoFilterSummary from './model/IoFilterSummary';
import IoFilterSummaryListResponse from './model/IoFilterSummaryListResponse';
import JobMonitoringCsvDownloadResponse from './model/JobMonitoringCsvDownloadResponse';
import JobMonitoringInfo from './model/JobMonitoringInfo';
import JobMonitoringJobProgressInfo from './model/JobMonitoringJobProgressInfo';
import JobMonitoringObjectsCountByState from './model/JobMonitoringObjectsCountByState';
import JobMonitoringObjectsCountByType from './model/JobMonitoringObjectsCountByType';
import JobMonitoringResponse from './model/JobMonitoringResponse';
import JobMonitoringRetryStatus from './model/JobMonitoringRetryStatus';
import JobMonitoringState from './model/JobMonitoringState';
import JobMonitoringStatus from './model/JobMonitoringStatus';
import JobMonitoringStream from './model/JobMonitoringStream';
import JobMonitoringStreamingResponse from './model/JobMonitoringStreamingResponse';
import JobMonitoringSummaryByState from './model/JobMonitoringSummaryByState';
import JobMonitoringSummaryByType from './model/JobMonitoringSummaryByType';
import JobMonitoringTaskType from './model/JobMonitoringTaskType';
import JobScheduledResponse from './model/JobScheduledResponse';
import KmipClientConfiguration from './model/KmipClientConfiguration';
import KmipClientDetail from './model/KmipClientDetail';
import KmipServerConfiguration from './model/KmipServerConfiguration';
import KmipServerDetail from './model/KmipServerDetail';
import KuprHostRegister from './model/KuprHostRegister';
import KuprHostUpdate from './model/KuprHostUpdate';
import LdapDomainName from './model/LdapDomainName';
import LdapDomainNameListResponse from './model/LdapDomainNameListResponse';
import LdapServiceInfo from './model/LdapServiceInfo';
import LdapServiceInfoUpdate from './model/LdapServiceInfoUpdate';
import LdapServiceSummary from './model/LdapServiceSummary';
import LdapServiceSummaryListResponse from './model/LdapServiceSummaryListResponse';
import LegalHoldDownloadConfig from './model/LegalHoldDownloadConfig';
import LegalHoldObjectSortAttribute from './model/LegalHoldObjectSortAttribute';
import LegalHoldSnapshotSortAttribute from './model/LegalHoldSnapshotSortAttribute';
import LegalHoldSummary from './model/LegalHoldSummary';
import LegalHoldSummaryListResponse from './model/LegalHoldSummaryListResponse';
import Link from './model/Link';
import LocalUserAccountLockoutConfig from './model/LocalUserAccountLockoutConfig';
import LocalUserAccountLockoutStatus from './model/LocalUserAccountLockoutStatus';
import LocationPathPoint from './model/LocationPathPoint';
import LsnRecoveryPoint from './model/LsnRecoveryPoint';
import ManagedHierarchyObjectAncestor from './model/ManagedHierarchyObjectAncestor';
import ManagedHierarchyObjectSummary from './model/ManagedHierarchyObjectSummary';
import ManagedObjectDescendantCountVcdVappFields from './model/ManagedObjectDescendantCountVcdVappFields';
import ManagedObjectPendingSlaInfo from './model/ManagedObjectPendingSlaInfo';
import ManagedVolumeSlaObjectCount from './model/ManagedVolumeSlaObjectCount';
import ManualDiscoveryNodeInfo from './model/ManualDiscoveryNodeInfo';
import ManualDiscoveryNodeIpv4Info from './model/ManualDiscoveryNodeIpv4Info';
import MfaServerConfig from './model/MfaServerConfig';
import MissedSnapshot from './model/MissedSnapshot';
import MissedSnapshotDayOfTimeUnit from './model/MissedSnapshotDayOfTimeUnit';
import MissedSnapshotListResponse from './model/MissedSnapshotListResponse';
import MissedSnapshotTimeUnitConfig from './model/MissedSnapshotTimeUnitConfig';
import MonitoringEmailSubscriptionRequest from './model/MonitoringEmailSubscriptionRequest';
import MonitoringEmailSubscriptionUpdate from './model/MonitoringEmailSubscriptionUpdate';
import MonitoringRowType from './model/MonitoringRowType';
import MonitoringSubscriptionSummary from './model/MonitoringSubscriptionSummary';
import MonthlyConfig from './model/MonthlyConfig';
import MountExportSnapshotJobCommonOptions from './model/MountExportSnapshotJobCommonOptions';
import MountMssqlDbConfig from './model/MountMssqlDbConfig';
import MountSnapshotJobConfigForBatchV1 from './model/MountSnapshotJobConfigForBatchV1';
import MountSnapshotJobConfigV1 from './model/MountSnapshotJobConfigV1';
import MssqlAvailabilityGroupDetail from './model/MssqlAvailabilityGroupDetail';
import MssqlAvailabilityGroupSummary from './model/MssqlAvailabilityGroupSummary';
import MssqlAvailabilityGroupSummaryListResponse from './model/MssqlAvailabilityGroupSummaryListResponse';
import MssqlAvailabilityGroupUpdate from './model/MssqlAvailabilityGroupUpdate';
import MssqlBackup from './model/MssqlBackup';
import MssqlBackupJobConfig from './model/MssqlBackupJobConfig';
import MssqlBackupSelection from './model/MssqlBackupSelection';
import MssqlBackupType from './model/MssqlBackupType';
import MssqlBackups from './model/MssqlBackups';
import MssqlBatchBackupCanceledSummary from './model/MssqlBatchBackupCanceledSummary';
import MssqlBatchBackupFailureSummary from './model/MssqlBatchBackupFailureSummary';
import MssqlBatchBackupJobConfig from './model/MssqlBatchBackupJobConfig';
import MssqlBatchBackupSuccessSummary from './model/MssqlBatchBackupSuccessSummary';
import MssqlBatchBackupSummary from './model/MssqlBatchBackupSummary';
import MssqlCbtEffectiveStatusType from './model/MssqlCbtEffectiveStatusType';
import MssqlCbtStatusType from './model/MssqlCbtStatusType';
import MssqlDatabaseFileType from './model/MssqlDatabaseFileType';
import MssqlDatabaseListSortAttribute from './model/MssqlDatabaseListSortAttribute';
import MssqlDatabaseRecoveryModel from './model/MssqlDatabaseRecoveryModel';
import MssqlDbDefaults from './model/MssqlDbDefaults';
import MssqlDbDefaultsUpdate from './model/MssqlDbDefaultsUpdate';
import MssqlDbDetail from './model/MssqlDbDetail';
import MssqlDbFileExportPath from './model/MssqlDbFileExportPath';
import MssqlDbReplica from './model/MssqlDbReplica';
import MssqlDbReplicaAvailabilityInfo from './model/MssqlDbReplicaAvailabilityInfo';
import MssqlDbSlaObjectCount from './model/MssqlDbSlaObjectCount';
import MssqlDbSnapshotDetail from './model/MssqlDbSnapshotDetail';
import MssqlDbSnapshotSummary from './model/MssqlDbSnapshotSummary';
import MssqlDbSnapshotSummaryListResponse from './model/MssqlDbSnapshotSummaryListResponse';
import MssqlDbSummary from './model/MssqlDbSummary';
import MssqlDbSummaryListResponse from './model/MssqlDbSummaryListResponse';
import MssqlDbUpdate from './model/MssqlDbUpdate';
import MssqlDbUpdateId from './model/MssqlDbUpdateId';
import MssqlDownloadFromArchiveConfig from './model/MssqlDownloadFromArchiveConfig';
import MssqlHierarchyObjectDescendantCount from './model/MssqlHierarchyObjectDescendantCount';
import MssqlHierarchyObjectSummary from './model/MssqlHierarchyObjectSummary';
import MssqlHierarchyObjectSummaryListResponse from './model/MssqlHierarchyObjectSummaryListResponse';
import MssqlHierarchyObjectType from './model/MssqlHierarchyObjectType';
import MssqlHostCbtEffectiveStatusType from './model/MssqlHostCbtEffectiveStatusType';
import MssqlHostCbtStatusType from './model/MssqlHostCbtStatusType';
import MssqlHostConfiguration from './model/MssqlHostConfiguration';
import MssqlHostConfigurationWithHostId from './model/MssqlHostConfigurationWithHostId';
import MssqlHostConfigurationWithHostIdListResponse from './model/MssqlHostConfigurationWithHostIdListResponse';
import MssqlInstanceDetail from './model/MssqlInstanceDetail';
import MssqlInstanceShortSummary from './model/MssqlInstanceShortSummary';
import MssqlInstanceSummary from './model/MssqlInstanceSummary';
import MssqlInstanceSummaryListResponse from './model/MssqlInstanceSummaryListResponse';
import MssqlInstanceUpdate from './model/MssqlInstanceUpdate';
import MssqlLogShippingCreateConfig from './model/MssqlLogShippingCreateConfig';
import MssqlLogShippingDetail from './model/MssqlLogShippingDetail';
import MssqlLogShippingLinks from './model/MssqlLogShippingLinks';
import MssqlLogShippingListSortAttribute from './model/MssqlLogShippingListSortAttribute';
import MssqlLogShippingOkState from './model/MssqlLogShippingOkState';
import MssqlLogShippingReseedConfig from './model/MssqlLogShippingReseedConfig';
import MssqlLogShippingStatus from './model/MssqlLogShippingStatus';
import MssqlLogShippingStatusInfo from './model/MssqlLogShippingStatusInfo';
import MssqlLogShippingSummary from './model/MssqlLogShippingSummary';
import MssqlLogShippingSummaryListResponse from './model/MssqlLogShippingSummaryListResponse';
import MssqlLogShippingTargetStateOptions from './model/MssqlLogShippingTargetStateOptions';
import MssqlLogShippingUpdate from './model/MssqlLogShippingUpdate';
import MssqlMissedRecoverableRange from './model/MssqlMissedRecoverableRange';
import MssqlMissedRecoverableRangeError from './model/MssqlMissedRecoverableRangeError';
import MssqlMissedRecoverableRangeListResponse from './model/MssqlMissedRecoverableRangeListResponse';
import MssqlMountDetail from './model/MssqlMountDetail';
import MssqlMountLinks from './model/MssqlMountLinks';
import MssqlMountSummary from './model/MssqlMountSummary';
import MssqlMountSummaryListResponse from './model/MssqlMountSummaryListResponse';
import MssqlRecoverableRange from './model/MssqlRecoverableRange';
import MssqlRecoverableRangeListResponse from './model/MssqlRecoverableRangeListResponse';
import MssqlRecoveryPoint from './model/MssqlRecoveryPoint';
import MssqlRestoreEstimateResult from './model/MssqlRestoreEstimateResult';
import MssqlRestoreFile from './model/MssqlRestoreFile';
import MssqlRootProperties from './model/MssqlRootProperties';
import MssqlScriptDetail from './model/MssqlScriptDetail';
import MssqlSlaDomainAssignInfo from './model/MssqlSlaDomainAssignInfo';
import MssqlSlaDomainInfo from './model/MssqlSlaDomainInfo';
import MssqlSlaPatchProperties from './model/MssqlSlaPatchProperties';
import MssqlSlaRelatedProperties from './model/MssqlSlaRelatedProperties';
import MssqlSnappableId from './model/MssqlSnappableId';
import NasBaseConfig from './model/NasBaseConfig';
import NasConfig from './model/NasConfig';
import NasSharesToAdd from './model/NasSharesToAdd';
import NasVendorType from './model/NasVendorType';
import NetworkInfo from './model/NetworkInfo';
import NetworkInfoListResponse from './model/NetworkInfoListResponse';
import NodeHostnameInfo from './model/NodeHostnameInfo';
import NodeHostnameInfoListResponse from './model/NodeHostnameInfoListResponse';
import NodeId from './model/NodeId';
import NodePolicyCheckResult from './model/NodePolicyCheckResult';
import NodeStatusEnum from './model/NodeStatusEnum';
import NotificationConfig from './model/NotificationConfig';
import NotificationDetails from './model/NotificationDetails';
import NotificationTypeEnum from './model/NotificationTypeEnum';
import NutanixVmSlaObjectCount from './model/NutanixVmSlaObjectCount';
import ObjectHoldSummary from './model/ObjectHoldSummary';
import ObjectHoldSummaryListResponse from './model/ObjectHoldSummaryListResponse';
import ObjectHolder from './model/ObjectHolder';
import ObjectTypeV1 from './model/ObjectTypeV1';
import OperatingSystemFamily from './model/OperatingSystemFamily';
import OperationMode from './model/OperationMode';
import OracleAcoParameterDetail from './model/OracleAcoParameterDetail';
import OracleAcoParameterList from './model/OracleAcoParameterList';
import OracleAcoValidationResult from './model/OracleAcoValidationResult';
import OracleAcoValueErrorDetail from './model/OracleAcoValueErrorDetail';
import OracleBulkUpdate from './model/OracleBulkUpdate';
import OracleDataGuardGroupUpdate from './model/OracleDataGuardGroupUpdate';
import OracleDbDetail from './model/OracleDbDetail';
import OracleDbSummary from './model/OracleDbSummary';
import OracleDbSummaryListResponse from './model/OracleDbSummaryListResponse';
import OracleFileDownloadLink from './model/OracleFileDownloadLink';
import OracleHostDetail from './model/OracleHostDetail';
import OracleHostSummary from './model/OracleHostSummary';
import OracleInstanceProperties from './model/OracleInstanceProperties';
import OracleLastValidationResult from './model/OracleLastValidationResult';
import OracleNodeOrder from './model/OracleNodeOrder';
import OracleNodeProperties from './model/OracleNodeProperties';
import OracleNonSlaProperties from './model/OracleNonSlaProperties';
import OracleRacDetail from './model/OracleRacDetail';
import OracleRacSummary from './model/OracleRacSummary';
import OracleRecoveryApiValidationErrors from './model/OracleRecoveryApiValidationErrors';
import OracleRecoveryPoint from './model/OracleRecoveryPoint';
import OracleRestoreEstimateResult from './model/OracleRestoreEstimateResult';
import OracleUpdate from './model/OracleUpdate';
import OracleUpdateCommon from './model/OracleUpdateCommon';
import OracleValidateConfig from './model/OracleValidateConfig';
import ParentAppInfo from './model/ParentAppInfo';
import PasswordRequirementsPatchRequest from './model/PasswordRequirementsPatchRequest';
import PasswordRequirementsSummary from './model/PasswordRequirementsSummary';
import PatternStatus from './model/PatternStatus';
import PerLocationCloudOutForecastSummary from './model/PerLocationCloudOutForecastSummary';
import PerStorageClassCloudOutStorageForecastSummary from './model/PerStorageClassCloudOutStorageForecastSummary';
import PolicyCheckResult from './model/PolicyCheckResult';
import PolicyScopeEnum from './model/PolicyScopeEnum';
import PolicyTypeEnum from './model/PolicyTypeEnum';
import PrecheckFailureResult from './model/PrecheckFailureResult';
import PrecheckStatusNextRunInfo from './model/PrecheckStatusNextRunInfo';
import PrecheckStatusResponse from './model/PrecheckStatusResponse';
import PreferredCdpNetworkProtocol from './model/PreferredCdpNetworkProtocol';
import PreferredCdpNetworkProtocolObject from './model/PreferredCdpNetworkProtocolObject';
import PrincipalSearchSortAttribute from './model/PrincipalSearchSortAttribute';
import PrincipalSummaryV1 from './model/PrincipalSummaryV1';
import PrincipalSummaryV1ListResponse from './model/PrincipalSummaryV1ListResponse';
import PrincipalType from './model/PrincipalType';
import PrincipalWithRoleInfo from './model/PrincipalWithRoleInfo';
import ProtectedObjectsCount from './model/ProtectedObjectsCount';
import QuarterlyConfig from './model/QuarterlyConfig';
import RbsHostOperationRequest from './model/RbsHostOperationRequest';
import RbsHostOperationResponse from './model/RbsHostOperationResponse';
import RbsHostSummary from './model/RbsHostSummary';
import RbsHostUserConfig from './model/RbsHostUserConfig';
import ReaderRefreshDataSourcesRequest from './model/ReaderRefreshDataSourcesRequest';
import RefreshableObjectConnectionStatus from './model/RefreshableObjectConnectionStatus';
import RefreshableObjectConnectionStatusType from './model/RefreshableObjectConnectionStatusType';
import RelocateMountConfig from './model/RelocateMountConfig';
import RemediationRequest from './model/RemediationRequest';
import RemediationRequestRunConfig from './model/RemediationRequestRunConfig';
import RemediationRequestSpec from './model/RemediationRequestSpec';
import RemediationResponse from './model/RemediationResponse';
import ReplicationSpec from './model/ReplicationSpec';
import ReplicationType from './model/ReplicationType';
import ReportConfigPatch from './model/ReportConfigPatch';
import ReportConfigResponse from './model/ReportConfigResponse';
import ReportableObjectType from './model/ReportableObjectType';
import RequestErrorInfo from './model/RequestErrorInfo';
import RequestFailedException from './model/RequestFailedException';
import ResourceTagDefinition from './model/ResourceTagDefinition';
import ResourceTagDeleteResponse from './model/ResourceTagDeleteResponse';
import ResourceTagDetail from './model/ResourceTagDetail';
import ResourceTagGetResponse from './model/ResourceTagGetResponse';
import ResourceTagUpdate from './model/ResourceTagUpdate';
import RestoreFileJobConfig from './model/RestoreFileJobConfig';
import RestoreMssqlDbJobConfig from './model/RestoreMssqlDbJobConfig';
import RoleAssignmentRequest from './model/RoleAssignmentRequest';
import RoleInfo from './model/RoleInfo';
import RoleInfoCreate from './model/RoleInfoCreate';
import RoleInfoListResponse from './model/RoleInfoListResponse';
import RoleInfoUpdate from './model/RoleInfoUpdate';
import RoleInfoWithPrincipals from './model/RoleInfoWithPrincipals';
import RoleListSortAttributes from './model/RoleListSortAttributes';
import RsaMfaServerConfig from './model/RsaMfaServerConfig';
import RsaMfaServerConfigUpdate from './model/RsaMfaServerConfigUpdate';
import RsaMfaServerConfigWithoutSecrets from './model/RsaMfaServerConfigWithoutSecrets';
import RsaMfaServerDetail from './model/RsaMfaServerDetail';
import RsaMfaServerDetailListResponse from './model/RsaMfaServerDetailListResponse';
import RubrikMibFileDownloadLink from './model/RubrikMibFileDownloadLink';
import RubrikSamlMetadataDetail from './model/RubrikSamlMetadataDetail';
import RubrikSamlMetadataInfo from './model/RubrikSamlMetadataInfo';
import RubrikSamlMetadataSummary from './model/RubrikSamlMetadataSummary';
import RunPolicyArg from './model/RunPolicyArg';
import SamlSsoAuthnRequestDetail from './model/SamlSsoAuthnRequestDetail';
import SamlSsoAuthnRequestInfo from './model/SamlSsoAuthnRequestInfo';
import SamlSsoStatus from './model/SamlSsoStatus';
import SapHanaAddSystemResponse from './model/SapHanaAddSystemResponse';
import SapHanaDataPathSpec from './model/SapHanaDataPathSpec';
import SapHanaDataPathType from './model/SapHanaDataPathType';
import SapHanaDatabaseDetail from './model/SapHanaDatabaseDetail';
import SapHanaDatabaseListSortAttribute from './model/SapHanaDatabaseListSortAttribute';
import SapHanaDatabasePatch from './model/SapHanaDatabasePatch';
import SapHanaDatabaseSnapshotDetail from './model/SapHanaDatabaseSnapshotDetail';
import SapHanaDatabaseSnapshotSummary from './model/SapHanaDatabaseSnapshotSummary';
import SapHanaDatabaseSnapshotSummaryListResponse from './model/SapHanaDatabaseSnapshotSummaryListResponse';
import SapHanaDatabaseSummary from './model/SapHanaDatabaseSummary';
import SapHanaDatabaseSummaryListResponse from './model/SapHanaDatabaseSummaryListResponse';
import SapHanaHost from './model/SapHanaHost';
import SapHanaPatchSystemResponse from './model/SapHanaPatchSystemResponse';
import SapHanaRecoverableRange from './model/SapHanaRecoverableRange';
import SapHanaRecoverableRangeListResponse from './model/SapHanaRecoverableRangeListResponse';
import SapHanaRestoreSourceConfig from './model/SapHanaRestoreSourceConfig';
import SapHanaSslInfo from './model/SapHanaSslInfo';
import SapHanaSystemConfig from './model/SapHanaSystemConfig';
import SapHanaSystemDataPathSpec from './model/SapHanaSystemDataPathSpec';
import SapHanaSystemInfo from './model/SapHanaSystemInfo';
import SapHanaSystemListSortAttribute from './model/SapHanaSystemListSortAttribute';
import SapHanaSystemPatch from './model/SapHanaSystemPatch';
import SapHanaSystemSummary from './model/SapHanaSystemSummary';
import SapHanaSystemSummaryListResponse from './model/SapHanaSystemSummaryListResponse';
import ScriptErrorAction from './model/ScriptErrorAction';
import SearchResponse from './model/SearchResponse';
import SearchResponseListResponse from './model/SearchResponseListResponse';
import SessionSummary from './model/SessionSummary';
import SlaAssignable from './model/SlaAssignable';
import SlaAssignment from './model/SlaAssignment';
import SlaConflictsSummary from './model/SlaConflictsSummary';
import SlaDayOfMonth from './model/SlaDayOfMonth';
import SlaDayOfQuarter from './model/SlaDayOfQuarter';
import SlaDayOfWeek from './model/SlaDayOfWeek';
import SlaDayOfYear from './model/SlaDayOfYear';
import SlaDomainDefinition from './model/SlaDomainDefinition';
import SlaDomainPatchDefinition from './model/SlaDomainPatchDefinition';
import SlaDomainSummary from './model/SlaDomainSummary';
import SlaDomainSummaryListResponse from './model/SlaDomainSummaryListResponse';
import SlaFrequency from './model/SlaFrequency';
import SlaFrequencyV2 from './model/SlaFrequencyV2';
import SlaMonth from './model/SlaMonth';
import SlaObjectCounts from './model/SlaObjectCounts';
import SlaStartTimeAttributes from './model/SlaStartTimeAttributes';
import SlaTimeUnit from './model/SlaTimeUnit';
import Snappable from './model/Snappable';
import SnappablePrivilegeStatus from './model/SnappablePrivilegeStatus';
import SnappableRecoveryInfo from './model/SnappableRecoveryInfo';
import SnapshotCloudStorageTier from './model/SnapshotCloudStorageTier';
import SnapshotEventSeries from './model/SnapshotEventSeries';
import SnapshotLocationRetentionInfo from './model/SnapshotLocationRetentionInfo';
import SnapshotRetentionInfo from './model/SnapshotRetentionInfo';
import SnapshotSortAttribute from './model/SnapshotSortAttribute';
import SnapshotStorageStats from './model/SnapshotStorageStats';
import SnapshotSummary from './model/SnapshotSummary';
import SnapshotSummaryListResponse from './model/SnapshotSummaryListResponse';
import SnapshotType from './model/SnapshotType';
import SoftwareAvailability from './model/SoftwareAvailability';
import SortColumn from './model/SortColumn';
import SortOrder from './model/SortOrder';
import StageCdmSoftwareInfo from './model/StageCdmSoftwareInfo';
import StaticIpInfo from './model/StaticIpInfo';
import Status from './model/Status';
import StringResponse from './model/StringResponse';
import SubscriptionAttachmentType from './model/SubscriptionAttachmentType';
import SubscriptionOwner from './model/SubscriptionOwner';
import SubscriptionScheduleTimeAttributes from './model/SubscriptionScheduleTimeAttributes';
import SubscriptionStatus from './model/SubscriptionStatus';
import SupportDataConfig from './model/SupportDataConfig';
import SupportDataType from './model/SupportDataType';
import SupportDataTypeConfig from './model/SupportDataTypeConfig';
import SupportDataTypeStatus from './model/SupportDataTypeStatus';
import SyslogExportRuleFull from './model/SyslogExportRuleFull';
import SyslogExportRulePartial from './model/SyslogExportRulePartial';
import SyslogExportRuleSummary from './model/SyslogExportRuleSummary';
import SyslogExportRuleSummaryListResponse from './model/SyslogExportRuleSummaryListResponse';
import SyslogFacility from './model/SyslogFacility';
import SyslogMsgMibFileDownloadLink from './model/SyslogMsgMibFileDownloadLink';
import SyslogServerTestResult from './model/SyslogServerTestResult';
import SyslogSeverity from './model/SyslogSeverity';
import SyslogTcMibFileDownloadLink from './model/SyslogTcMibFileDownloadLink';
import TelemetryConfig from './model/TelemetryConfig';
import TelemetryLevel from './model/TelemetryLevel';
import TotpConfigUpdateRequest from './model/TotpConfigUpdateRequest';
import TotpGlobalSetting from './model/TotpGlobalSetting';
import TotpGlobalSettingUpdate from './model/TotpGlobalSettingUpdate';
import TotpSecret from './model/TotpSecret';
import TotpStatus from './model/TotpStatus';
import TransportLayerProtocol from './model/TransportLayerProtocol';
import TruststorePayload from './model/TruststorePayload';
import TruststoreSummary from './model/TruststoreSummary';
import TruststoreSummaryListResponse from './model/TruststoreSummaryListResponse';
import TruststoreType from './model/TruststoreType';
import UnmanagedObjectDetails from './model/UnmanagedObjectDetails';
import UnmanagedObjectDetailsListResponse from './model/UnmanagedObjectDetailsListResponse';
import UnmanagedObjectSlaAssignmentInfo from './model/UnmanagedObjectSlaAssignmentInfo';
import UnmanagedObjectSortAttribute from './model/UnmanagedObjectSortAttribute';
import UnmanagedObjectStatus from './model/UnmanagedObjectStatus';
import UnmanagedObjectSummary from './model/UnmanagedObjectSummary';
import UnmanagedObjectSummaryListResponse from './model/UnmanagedObjectSummaryListResponse';
import UnmanagedObjectType from './model/UnmanagedObjectType';
import UnmanagedSnapshotType from './model/UnmanagedSnapshotType';
import UpdateMountConfig from './model/UpdateMountConfig';
import UserActionV1 from './model/UserActionV1';
import VappAttributes from './model/VappAttributes';
import VappExportMode from './model/VappExportMode';
import VappExportOptions from './model/VappExportOptions';
import VappExportSnapshotJobConfig from './model/VappExportSnapshotJobConfig';
import VappInstantRecoveryJobConfig from './model/VappInstantRecoveryJobConfig';
import VappInstantRecoveryOptions from './model/VappInstantRecoveryOptions';
import VappNetworkMode from './model/VappNetworkMode';
import VappNetworkSummary from './model/VappNetworkSummary';
import VappTemplateExportJobConfig from './model/VappTemplateExportJobConfig';
import VappTemplateExportOptions from './model/VappTemplateExportOptions';
import VappTemplateExportOptionsUnion from './model/VappTemplateExportOptionsUnion';
import VappVmDetail from './model/VappVmDetail';
import VappVmIpAddressingMode from './model/VappVmIpAddressingMode';
import VappVmNetworkConnection from './model/VappVmNetworkConnection';
import VappVmRestoreSpec from './model/VappVmRestoreSpec';
import VappVmSummary from './model/VappVmSummary';
import VcdClusterBaseConfig from './model/VcdClusterBaseConfig';
import VcdClusterConfig from './model/VcdClusterConfig';
import VcdClusterDetail from './model/VcdClusterDetail';
import VcdClusterListSortAttribute from './model/VcdClusterListSortAttribute';
import VcdClusterPatch from './model/VcdClusterPatch';
import VcdClusterSummary from './model/VcdClusterSummary';
import VcdClusterSummaryListResponse from './model/VcdClusterSummaryListResponse';
import VcdConnectionStatus from './model/VcdConnectionStatus';
import VcdHierarchyObjectAttributes from './model/VcdHierarchyObjectAttributes';
import VcdHierarchyObjectDescendantCount from './model/VcdHierarchyObjectDescendantCount';
import VcdHierarchyObjectSortAttribute from './model/VcdHierarchyObjectSortAttribute';
import VcdHierarchyObjectSummary from './model/VcdHierarchyObjectSummary';
import VcdHierarchyObjectSummaryListResponse from './model/VcdHierarchyObjectSummaryListResponse';
import VcdObjectType from './model/VcdObjectType';
import VcdOrgVdcStorageProfile from './model/VcdOrgVdcStorageProfile';
import VcdVappDetail from './model/VcdVappDetail';
import VcdVappObjectSortAttribute from './model/VcdVappObjectSortAttribute';
import VcdVappPatch from './model/VcdVappPatch';
import VcdVappSlaObjectCount from './model/VcdVappSlaObjectCount';
import VcdVappSnapshotDetail from './model/VcdVappSnapshotDetail';
import VcdVappSnapshotSummary from './model/VcdVappSnapshotSummary';
import VcdVappSnapshotSummaryDetailSharedFields from './model/VcdVappSnapshotSummaryDetailSharedFields';
import VcdVappSnapshotSummaryListResponse from './model/VcdVappSnapshotSummaryListResponse';
import VcdVappSummary from './model/VcdVappSummary';
import VcdVappSummaryListResponse from './model/VcdVappSummaryListResponse';
import VcdVmSnapshotDetail from './model/VcdVmSnapshotDetail';
import VcdVmSnapshotSummary from './model/VcdVmSnapshotSummary';
import VcenterConfig from './model/VcenterConfig';
import VcenterConnectionConfig from './model/VcenterConnectionConfig';
import VcenterDetail from './model/VcenterDetail';
import VcenterPatch from './model/VcenterPatch';
import VcenterPreAddConfig from './model/VcenterPreAddConfig';
import VcenterPreAddInfo from './model/VcenterPreAddInfo';
import VcenterSummary from './model/VcenterSummary';
import VcenterSummaryListResponse from './model/VcenterSummaryListResponse';
import VerificationParameters from './model/VerificationParameters';
import VerificationResponse from './model/VerificationResponse';
import VimserverSummary from './model/VimserverSummary';
import VimserverSummaryListResponse from './model/VimserverSummaryListResponse';
import VirtualDiskDetail from './model/VirtualDiskDetail';
import VirtualDiskUpdate from './model/VirtualDiskUpdate';
import VirtualMachineDetail from './model/VirtualMachineDetail';
import VirtualMachineScriptDetail from './model/VirtualMachineScriptDetail';
import VirtualMachineSummary from './model/VirtualMachineSummary';
import VirtualMachineSummaryListResponse from './model/VirtualMachineSummaryListResponse';
import VirtualMachineUpdate from './model/VirtualMachineUpdate';
import VirtualMachineUpdateWithSecret from './model/VirtualMachineUpdateWithSecret';
import VmForceFullRequest from './model/VmForceFullRequest';
import VmForceFullResponse from './model/VmForceFullResponse';
import VmGuestScriptRunConfig from './model/VmGuestScriptRunConfig';
import VmPathPoint from './model/VmPathPoint';
import VmSnapshotDetail from './model/VmSnapshotDetail';
import VmSnapshotDiskDetail from './model/VmSnapshotDiskDetail';
import VmSnapshotSummaries from './model/VmSnapshotSummaries';
import VmSnapshotSummary from './model/VmSnapshotSummary';
import VmSnapshotSummaryListResponse from './model/VmSnapshotSummaryListResponse';
import VmwareAdaptiveThrottlingSettings from './model/VmwareAdaptiveThrottlingSettings';
import VmwareCdpLiveInfo from './model/VmwareCdpLiveInfo';
import VmwareCdpStateInfo from './model/VmwareCdpStateInfo';
import VmwareHierarchyInfo from './model/VmwareHierarchyInfo';
import VmwareHierarchyInfoListResponse from './model/VmwareHierarchyInfoListResponse';
import VmwareHierarchyObjectType from './model/VmwareHierarchyObjectType';
import VmwareHostDatastoreDetail from './model/VmwareHostDatastoreDetail';
import VmwareHostDetail from './model/VmwareHostDetail';
import VmwareHostSummary from './model/VmwareHostSummary';
import VmwareHostSummaryListResponse from './model/VmwareHostSummaryListResponse';
import VmwareHostUpdate from './model/VmwareHostUpdate';
import VmwareNetworkCollection from './model/VmwareNetworkCollection';
import VmwareNetworkDeviceInfo from './model/VmwareNetworkDeviceInfo';
import VmwareNetworkInfo from './model/VmwareNetworkInfo';
import VmwareNetworkType from './model/VmwareNetworkType';
import VmwareRecoverableRange from './model/VmwareRecoverableRange';
import VmwareRecoverableRangeListResponse from './model/VmwareRecoverableRangeListResponse';
import VmwareVNicBindingInfo from './model/VmwareVNicBindingInfo';
import VmwareVdiskForceFullInfo from './model/VmwareVdiskForceFullInfo';
import VmwareVmMissedRecoverableRanges from './model/VmwareVmMissedRecoverableRanges';
import VmwareVmMountDetailV1 from './model/VmwareVmMountDetailV1';
import VmwareVmMountSummaryV1 from './model/VmwareVmMountSummaryV1';
import VmwareVmMountSummaryV1ListResponse from './model/VmwareVmMountSummaryV1ListResponse';
import VmwareVmRecoverableRanges from './model/VmwareVmRecoverableRanges';
import VolumeGroupDetail from './model/VolumeGroupDetail';
import VolumeGroupForceFullRequest from './model/VolumeGroupForceFullRequest';
import VolumeGroupForceFullResponse from './model/VolumeGroupForceFullResponse';
import VolumeGroupListSortAttribute from './model/VolumeGroupListSortAttribute';
import VolumeGroupMountListSortAttribute from './model/VolumeGroupMountListSortAttribute';
import VolumeGroupMountSummary from './model/VolumeGroupMountSummary';
import VolumeGroupMountSummaryListResponse from './model/VolumeGroupMountSummaryListResponse';
import VolumeGroupOnDemandSnapshotConfig from './model/VolumeGroupOnDemandSnapshotConfig';
import VolumeGroupPatch from './model/VolumeGroupPatch';
import VolumeGroupReleaseVersion from './model/VolumeGroupReleaseVersion';
import VolumeGroupRestoreVolumeSpec from './model/VolumeGroupRestoreVolumeSpec';
import VolumeGroupRestoreVolumesConfig from './model/VolumeGroupRestoreVolumesConfig';
import VolumeGroupSnapshotDetail from './model/VolumeGroupSnapshotDetail';
import VolumeGroupSnapshotSummary from './model/VolumeGroupSnapshotSummary';
import VolumeGroupSnapshotSummaryListResponse from './model/VolumeGroupSnapshotSummaryListResponse';
import VolumeGroupSnapshotVolumeSummary from './model/VolumeGroupSnapshotVolumeSummary';
import VolumeGroupSummary from './model/VolumeGroupSummary';
import VolumeGroupSummaryListResponse from './model/VolumeGroupSummaryListResponse';
import VolumeMountInfo from './model/VolumeMountInfo';
import WebServerCertificatePayload from './model/WebServerCertificatePayload';
import WebServerCertificateSummary from './model/WebServerCertificateSummary';
import WeeklyConfig from './model/WeeklyConfig';
import WindowsClusterDetail from './model/WindowsClusterDetail';
import WindowsClusterSummary from './model/WindowsClusterSummary';
import WindowsClusterSummaryListResponse from './model/WindowsClusterSummaryListResponse';
import YearlyConfig from './model/YearlyConfig';
import ArchiveApi from './api/ArchiveApi';
import AuthorizationApi from './api/AuthorizationApi';
import BackupApi from './api/BackupApi';
import BlackoutWindowApi from './api/BlackoutWindowApi';
import CertificateApi from './api/CertificateApi';
import CertificateAgentApi from './api/CertificateAgentApi';
import CloudUtilizationApi from './api/CloudUtilizationApi';
import ClusterApi from './api/ClusterApi';
import ConfigHistoryApi from './api/ConfigHistoryApi';
import CsrApi from './api/CsrApi';
import DataSourceApi from './api/DataSourceApi';
import DatabaseLogReportApi from './api/DatabaseLogReportApi';
import EventApi from './api/EventApi';
import EventSeriesApi from './api/EventSeriesApi';
import ExclusionPatternApi from './api/ExclusionPatternApi';
import FailoverClusterApi from './api/FailoverClusterApi';
import FailoverClusterFailoverClusterAppApi from './api/FailoverClusterFailoverClusterAppApi';
import FailoverClusterHierarchyApi from './api/FailoverClusterHierarchyApi';
import FilesetApi from './api/FilesetApi';
import FilesetTemplateApi from './api/FilesetTemplateApi';
import HdfsApi from './api/HdfsApi';
import HdfsTemplateApi from './api/HdfsTemplateApi';
import HealthMonitorApi from './api/HealthMonitorApi';
import HierarchyApi from './api/HierarchyApi';
import HostApi from './api/HostApi';
import HostHierarchyApi from './api/HostHierarchyApi';
import HostShareApi from './api/HostShareApi';
import HypervVmApi from './api/HypervVmApi';
import IdpAuthDomainApi from './api/IdpAuthDomainApi';
import JobMonitoringApi from './api/JobMonitoringApi';
import LdapServiceApi from './api/LdapServiceApi';
import LegalHoldApi from './api/LegalHoldApi';
import ManagedVolumeApi from './api/ManagedVolumeApi';
import MfaRsaApi from './api/MfaRsaApi';
import MssqlApi from './api/MssqlApi';
import OracleApi from './api/OracleApi';
import OrganizationApi from './api/OrganizationApi';
import PrincipalApi from './api/PrincipalApi';
import ReplicationApi from './api/ReplicationApi';
import ReportsApi from './api/ReportsApi';
import RoleApi from './api/RoleApi';
import SamlApi from './api/SamlApi';
import SapHanaApi from './api/SapHanaApi';
import SessionApi from './api/SessionApi';
import SlaDomainApi from './api/SlaDomainApi';
import SnapshotApi from './api/SnapshotApi';
import UnmanagedObjectApi from './api/UnmanagedObjectApi';
import UserApi from './api/UserApi';
import UserDefinedTagApi from './api/UserDefinedTagApi';
import VcdClusterApi from './api/VcdClusterApi';
import VcdHierarchyApi from './api/VcdHierarchyApi';
import VcdVappApi from './api/VcdVappApi';
import VmwareComputeClusterApi from './api/VmwareComputeClusterApi';
import VmwareConfigApi from './api/VmwareConfigApi';
import VmwareHierarchyApi from './api/VmwareHierarchyApi';
import VmwareHostApi from './api/VmwareHostApi';
import VmwareVcenterApi from './api/VmwareVcenterApi';
import VmwareVmApi from './api/VmwareVmApi';
import VolumeGroupApi from './api/VolumeGroupApi';
import WindowsClusterApi from './api/WindowsClusterApi';


/**
*  Copyright © 2017-2021 Rubrik Inc. [Legal](#section/Legal)  # Introduction  Welcome to the Rubrik™ REST API documentation.  The Rubrik REST API provides a RESTful interface for working with Rubrik clusters and Rubrik Edge virtual appliances. The Rubrik REST API can be used to query, configure, and control nearly all of the operations of the Rubrik software.  Through authenticated and encrypted interaction with the Rubrik REST API server, perform any of the operations that are available through the Rubrik web UI and many bulk-type operations that might otherwise be difficult or impossible to perform.  This documentation provides reference information and examples of typical workflows for the Rubrik REST API. For more detailed information about working with Rubrik clusters and Rubrik Edge virtual appliances refer to the *Rubrik User Guide*.  A quick way to become familiar with the Rubrik REST API, is to use the Rubrik REST API Explorer. [OpenAPI](#section/OpenAPI) describes this tool.  Refer to the [changelog](#section/Changelog) to see information about changes within this version of the Rubrik REST API.  # Changelog   Revisions are listed with the most recent revision first.   ### Changes to V1 API in Rubrik Version 6.0.0  ## Feature additions/improvements:  * Added optional fields: id(type: string) and networkType(type:    VmwareNetworkType Enum) to VmwareNetworkInfo, which is used by:    &#x60;Get /vmware/vm/{id}/snapshot&#x60;    &#x60;Get /vmware/config/recovery/networks&#x60;  * Added new optional field &#x60;maxLocalRetentionLimit&#x60; to    &#x60;CloudOutForecastSlaParameters&#x60;.  * Added following new endpoints for health monitor:    &#x60;POST /health_monitor/run_policy&#x60;    &#x60;GET /health_monitor/policies&#x60;    &#x60;GET /health_monitor/policy_status&#x60;  * Added new endpoints &#x60;POST /sap_hana/db/{id}/configure_restore&#x60; and    &#x60;/sap_hana/db/{id}/unconfigure_restore&#x60; to configure and unconfigure    system copy restore on the target SAP HANA database.  * Added new endpoint &#x60;POST /sla_domain/assign_to_downloaded_snapshots&#x60; to    assign retention SLA only to snapshots at downloaded locations.  * Copied the following endpoints from the internal Rubrik REST API listing    to the v1 listing:    &#x60;GET /oracle/db&#x60;    &#x60;GET /oracle/db/{id}&#x60;    &#x60;PATCH /oracle/db/{id}&#x60;    Added a new optional parameter &#x60;is_data_guard_group&#x60; to &#x60;GET /oracle/db&#x60;.  * Added new optional fields &#x60;advancedRecoveryConfigMap&#x60;, &#x60;preScriptPath&#x60;,    &#x60;postScriptPath&#x60;, and &#x60;shouldStopRecoveryOnPreScriptFailure&#x60; to    &#x60;ExportOracleDbConfig&#x60; and &#x60;MountOracleDbConfig&#x60; which specify the    Advanced Cloning Options (ACO) map, pre script path, post script path,    and whether to stop the recovery on pre-script failure, respectively.  * Added new endpoint &#x60;POST /oracle/validate_aco_file&#x60; to validate the given    Advanced Cloning Options (ACO) file and retrieve the validation results.  * Added new endpoint &#x60;GET /oracle/aco_parameter_list&#x60; to fetch the list of    supported Advanced Cloning Options (ACO) parameter names.  * Added new endpoint &#x60;PATCH /oracle/data_guard_group/{id}&#x60; to update the SLA    and user settings for a Data Guard group.  * Added new endpoints to get and change hostnames of nodes in a Rubrik cluster.    &#39;GET /cluster/{id}/node_hostname&#39;,    &#39;POST /cluster/{id}/node_hostname&#39;.  * Added a new object &#x60;NodeHostnameInfo&#x60; used by    &#x60;GET /cluster/{id}/node_hostname&#x60; and &#x60;POST /cluster/{id}/node_hostname&#x60;.  * Added new endpoint to get Rubrik Backup Service details for a host.    &#x60;GET /host/rbs&#x60;  * Added new endpoint to install Rubrik Backup Service on a host.    &#x60;POST /host/rbs/install&#x60;  * Added new endpoint to uninstall Rubrik Backup Service from a host.    &#x60;POST /host/rbs/uninstall&#x60;  * Added new endpoint to upgrade Rubrik Backup Service on a host.    &#x60;POST /host/rbs/upgrade&#x60;  * Added new endpoints for user-defined tags management    &#x60;GET /user_defined_tag&#x60;    &#x60;POST /user_defined_tag&#x60;    &#x60;DELETE /user_defined_tag&#x60;    &#x60;GET /user_defined_tag/{id}&#x60;    &#x60;PATCH /user_defined_tag/{id}&#x60;    &#x60;DELETE /user_defined_tag/{id}&#x60;  * Added new optional field &#39;numChannels&#39; to &#39;OracleValidateConfig&#39; object.    This field specifies the number of channels used when validating Oracle    backups.  * Added new endpoint for batch VM snpshots query.    &#x60;POST /vmware/vm/snapshots&#x60;  * Added new endpoints for SQL Server host configuration.    &#x60;GET /mssql/host/configuration&#x60;,    &#x60;POST /mssql/host/configuration&#x60;,    &#x60;GET /mssql/host/configuration/{host_id}&#x60;,    &#x60;PATCH /mssql/host/configuration/{host_id}&#x60;,    &#x60;DELETE /mssql/host/configuration/{host_id}&#x60;  * Added new optional field &#x60;dataRetrievalCostInUSD&#x60; to    &#x60;CloudOutStorageForecastSummary&#x60;.  * Added &#x60;POST /cloud_utilization/cloud_out_forecast&#x60; endpoint to forecast cloud    utilization for archival use case.  * Changed &#x60;lastUpdatedTime&#x60; to be required in  * Changed &#x60;retryStatus&#x60; to be required in    &#x60;JobMonitoringInfo&#x60; which is used in endpoints &#x60;GET /job_monitoring&#x60;    and &#x60;GET /polaris/job_monitoring&#x60;.  * Changed &#x60;lastUpdatedTime&#x60; to be required in    &#x60;JobMonitoringInfo&#x60; which is used in endpoints &#x60;GET /job_monitoring&#x60;    and &#x60;GET /polaris/job_monitoring&#x60;.  * Added a new endpoint to bulk tier existing snapshots    &#x60;POST /unmanaged_object/snapshot/bulk_archive_tier&#x60;  * Added new field &#x60;snapshotVerificationInfo&#x60; to    &#x60;VerificationResponse&#x60; to include event information    about snapshots.  * Added new optional fields &#x60;errorInfo&#x60; and    &#x60;retryStatus&#x60; to &#x60;JobMonitoringInfo&#x60; to include backup    failure remediation status.  * Added new optional fields &#x60;snapMirrorLabelForFullBackup&#x60; and    &#x60;snapMirrorLabelForIncrementalBackup&#x60; to &#x60;FilesetSummary&#x60;, &#x60;FilesetUpdate&#x60;    and &#x60;FilesetCreate&#x60; to support SnapMirror destination volume    backup.    &#x60;FilesetSummary&#x60; is used by endpoints:     &#x60;GET /v1/fileset&#x60;,     &#x60;GET /v1/fileset/{id}&#x60;.    &#x60;FilesetUpdate&#x60; is used by endpoints:     &#x60;PATCH /v1/fileset/{id}&#x60;.    &#x60;FilesetCreate&#x60; is used by endpoints:     &#x60;POST /internal/fileset/bulk&#x60;,     &#x60;POST /v1/fileset&#x60;.  * Added new values of &#x60;IoFilterStatus&#x60; and &#x60;HostUiFilterStatus&#x60;    to help distinguish cluster and ESXi host states when there is    a mismatch between the installed IO filter and ESXi host versions,    instead of defaulting to Unsupported.  * Added new endpoints &#x60;GET /cluster/{id}/security/totp/setting&#x60; and    &#x60;PUT /cluster/{id}/security/totp/setting&#x60; for retreiving and    updating the 2-Step Verification global setting, respectively.  * Added new optional field &#x60;computeVisibilityFilter&#x60; to    &#x60;GET /vmware/vcenter/{id}&#x60;, &#x60;POST /vmware/vcenter&#x60; and &#x60;PUT /vmware/vcenter&#x60;     to specify compute resource visibility.  ## New features:  * Added new endpoint for querying LDAP domain names.    &#x60;GET /ldap_service/domain_name&#x60;  * Added new endpoints for supporting truststores    &#x60;GET /v1/cluster/{id}/security/truststore&#x60;    &#x60;DELETE /v1/cluster/{id}/security/truststore&#x60;    &#x60;PATCH /v1/cluster/{id}/security/truststore&#x60;  * Added new field &#x60;isOnSnapMirrorDestVolume&#x60; to HostHierarchyObjectSummary    returned by &#x60;GET /host/hierarchy/{id}/children&#x60;.  * Added new endpoint, &#x60;GET /volume_group/{id}/request/force_full_snapshot&#x60;.    This endpoint retrieves the configuration used to force a full snapshot    of a Volume Group.  * Added new endpoint, &#x60;POST /volume_group/{id}/request/force_full_snapshot&#x60;.    This endpoint requests to force a full snapshot of a Volume Group.  * Added new endpoint, &#x60;POST /archive/location/{id}/owner/disable&#x60; to disable    archival location.  * Added new endpoint, &#x60;POST /archive/location/{id}/owner/enable&#x60; to enable    archival location.  * Added new optional field &#x60;dataPathSpec&#x60; to &#x60;SapHanaSystemConfig&#x60; include    details of SAP HANA system data path  * Copied the following endpoints from the internal Rubrik REST API listing   to the v1 listings:      * &#x60;GET /vcd/hierarchy/{id}&#x60; to get summary of a vCD hierarchy object.      * &#x60;GET /vcd/hierarchy/{id}/children&#x60; to get immediate descendant objects.      * &#x60;GET /vcd/hierarchy/{id}/descendants&#x60; to get list of descendant objects.      * &#x60;GET /vcd/cluster&#x60; to get summary for all vCD Clusters.      * &#x60;POST /vcd/cluster&#x60; to add a vCD Cluster.      * &#x60;GET /vcd/cluster/{id}/vimserver&#x60; to get VimServers of a vCD Cluster.      * &#x60;POST /vcd/cluster/{id}/refresh&#x60; to refresh a vCD Cluster.      * &#x60;GET /vcd/cluster/{id}&#x60; to get vCD Cluster details.      * &#x60;PATCH /vcd/cluster/{id}&#x60; to modify the hostname and credentials of a       specified vCD Cluster object.      * &#x60;DELETE /vcd/cluster/{id}&#x60; to remove vCD Cluster.      * &#x60;GET /vcd/cluster/request/{id}&#x60; to get vCD Cluster job status.      * &#x60;GET /vcd/vapp&#x60; to get summary for vApps.      * &#x60;GET /vcd/vapp/{id}&#x60; to get vApp details.      * &#x60;PATCH /vcd/vapp/{id}&#x60; to make changes to the parameters of a       specified vApp object.      * &#x60;GET /vcd/vapp/{id}/snapshot&#x60; to retrieve summary information for each       of the snapshot objects of a specified vApp object.      * &#x60;POST /vcd/vapp/{id}/snapshot&#x60; to start an asynchronous job to create       an on-demand snapshot for a specified vApp object.      * &#x60;DELETE /vcd/vapp/{id}/snapshot&#x60; to delete all snapshots of vApp.      * &#x60;GET /vcd/vapp/snapshot/{id}&#x60; to get vApp snapshot details.      * &#x60;DELETE /vcd/vapp/snapshot/{id}&#x60; to delete vApp snapshot.      * &#x60;GET /vcd/vapp/{id}/missed_snapshot&#x60; to get details about missed       snapshots for a vApp.      * &#x60;GET /vcd/vapp/snapshot/{snapshot_id}/export/options&#x60; to get       exportable network configurations.      * &#x60;POST /vcd/vapp/snapshot/{snapshot_id}/export&#x60; to export vApp snapshot.      * &#x60;POST /vcd/vapp/snapshot/{snapshot_id}/instant_recover&#x60; to instant       Recovery of vApp virtual machines.      * &#x60;GET /vcd/vapp/snapshot/{snapshot_id}/instant_recover/options&#x60; to get       Instant Recovery information.      * &#x60;GET /vcd/vapp/request/{id}&#x60; to retrieve the details of a specified       asynchronous job for a vApp.      * &#x60;GET /vcd/vapp/{id}/search&#x60; to search for a file from a vApp.      * &#x60;POST /vcd/vapp/snapshot/{id}/download&#x60; to download snapshot from       archive.  * Added new endpoint, &#x60;GET /hyperv/vm/{id}/request/force_full_snapshot&#x60;.    This endpoint retrieves the configuration used to force a full snapshot    of a Hyper-V virtual machine.  * Added new endpoint, &#x60;POST /hyperv/vm/{id}/request/force_full_snapshot&#x60;.    This endpoint requests to force a full snapshot of a Hyper-V virtual machine.  * Added new endpoint, &#x60;GET /vmware/vm/{id}/request/force_full_snapshot&#x60;.   This endpoint retrieves the configuration used to force a full snapshot   of a VMware virtual machine.  * Added new endpoint &#x60;POST /vmware/vm/{id}/request/force_full_snapshot&#x60;.   This endpoint requests to force a full snapshot of a VMware virtual machine. ### Changes to V1 API in Rubrik Version 5.3.2  ## Feature additions/improvements:  * Modified instanceName field in the &#x60;GET /mssql/db&#x60; endpoint by adding    the network name for SQL Server databases belonging to a cluster    instance.   ### Changes to V1 API in Rubrik Version 5.3.1  ## Feature additions/improvements:  * Added &#x60;GET /exclusion_pattern&#x60;    endpoint to get all exclusion patterns.  * Added &#x60;GET /exclusion_pattern/{id}&#x60;    endpoint to get a exclusion pattern by id.  * Added &#x60;POST /exclusion_pattern&#x60;    endpoint to create a new exclusion pattern.  * Added &#x60;POST /exclusion_pattern/bulk&#x60;    endpoint to bulk create new exclusion patterns.  * Added &#x60;PATCH /exclusion_pattern/{id}&#x60;    endpoint to update a exclusion pattern.  * Added &#x60;DELETE /exclusion_pattern/{id}&#x60;    endpoint to delete a exclusion pattern.  * Added &#x60;DELETE /exclusion_pattern/bulk&#x60;    endpoint to bulk delete exclusion patterns.  * Added new optional field &#x60;keyProtection&#x60; to &#x60;EncryptionStatus&#x60;    to support returning key protection status via v1 API    &#x60;GET /cluster/{id}/security/encryption&#x60;.  * Added &#x60;Post /vmware/vm/snapshot/{id}/export_with_download&#x60; endpoint to export    a vm snapshot from an archival location.  * Added new field &#x60;index&#x60; to &#x60;JobMonitoringObjectsCountByType&#x60;, which contains    the total count of all Index jobs.  * Added &#x60;Index&#x60; to &#x60;JobMonitoringTaskType&#x60;.  * Added new optional field &#x60;isTotpEnforced&#x60; to &#x60;LdapServiceInfo&#x60;,    &#x60;LdapServiceSummary&#x60;, and &#x60;LdapServiceInfoUpdate&#x60; to support    TOTP enforcement for LDAP services in followin APIs.    &#x60;POST /v1/ldap_service&#x60;    &#x60;GET /v1/ldap_service&#x60;    &#x60;GET /v1/ldap_service/{id}&#x60;    &#x60;PATCH /v1/ldap_service/{id}&#x60;    &#x60;PUT /v1/ldap_service/{id}&#x60;  * Added new optional field &#x60;isTotpEnabled&#x60; as a query param in API    &#x60;GET /v1/principal&#x60; for fetch users with TOTP enabled.  * Added new optional fields &#x60;mfaServerName&#x60;, &#x60;isTotpEnabled&#x60;, and    &#x60;isTotpEnforced&#x60; to &#x60;PrincipalSummaryV1&#x60; as part of response from    API &#x60;GET /v1/principal&#x60; for rendering principals&#39; MFA status.  * Modified &#x60;AgentConnectStatus&#x60; enum to add value SecondaryCluster for    multicluster Rubrik Backup Service support. This will be the status on a    cluster that is not the primary.  * Added new endpoint and optional fields for VMware network selection.     GET /vmware/config/recovery/networks for getting recovery networks.   ## New features:  * Added new endpoints for supporting TOTP configuration.    &#x60;GET /user/{id}/totp/status&#x60;    &#x60;PUT /user/{id}/totp/config&#x60;    &#x60;DELETE /user/{id}/totp/config&#x60;    &#x60;POST /user/{id}/totp/new_secret&#x60;  * Added new endpoints for supporting multicluster Rubrik Backup Service.    &#x60;POST /vmware/vm/make_primary&#x60;    &#x60;POST /host/make_primary&#x60;  * Added new endpoints for managing multicluster Rubrik Backup Service    certificates.    &#x60;GET /certificate/agent&#x60;    &#x60;POST /certificate/agent&#x60;    &#x60;DELETE /certificate/agent/{id}&#x60;   ### Changes to V1 API in Rubrik Version 5.3.0  ## Deprecation:  * Deprecated &#x60;SnapshotCloudStorageTier&#x60; enum value Cold. It will be left,    but will be mapped internally to the new value, AzureArchive,    which is recommended as a replacement.  * Removed signature and sigAlg return fields from &#x60;SamlSsoAuthnRequestDetail&#x60;,    which were wrongly introduced in 5.1.  * Removed &#x60;GET /vmware/resource_pool&#x60; endpoint, which doesn&#39;t have backend implementation.  * Removed &#x60;GET /vmware/resource_pool/{id}&#x60; endpoint, which doesn&#39;t have backend implementation.  ## New features:  * Added &#x60;Deleted&#x60; as new failover cluster node connection status in    FailoverClusterNodeConnectionStatus. The FailoverClusterNodeConnectionStatus    is in FailoverClusterNode object and is used by    &#x60;GET /failover_cluster&#x60;,    &#x60;GET /failover_cluster/{id}&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}/children&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}/descendants&#x60; endpoints.  * Added &#x60;POST /cluster/{id}/manual_discover_ll_ipv4&#x60; endpoint to allow discovery of new    nodes over link local ipv4 network.  * Added new optional field &#x60;groupMaxLevel&#x60; to &#x60;AdvancedLdapConfiguration&#x60;    included in &#x60;LdapServiceSummary&#x60;, &#x60;LdapServiceInfo&#x60; and &#x60;LdapServiceInfoUpdate&#x60;    objects used by endpoints:    &#x60;GET /ldap_service&#x60;,    &#x60;POST /ldap_service&#x60;,    &#x60;GET /ldap_service/{id}&#x60;,    &#x60;PUT /ldap_service/{id}&#x60;,    &#x60;PATCH /ldap_service/{id}&#x60;.  * Added &#x60;is_on_demand&#x60; as an optional parameter to &#x60;GET /job_monitoring&#x60;  * Added &#x60;GET /cluster/{id}/syslog_msg_mib_link&#x60; and    &#x60;GET /cluster/{id}/syslog_tc_mib_link&#x60; endpoints to allow downloading syslog    SNMP MIB files.  * Added &#x60;POST /vmware/vm/missed_recoverable_range&#x60; endpoint to get missed recoverable    ranges for a list of virtual machines.  * Added &#x60;GET /backup/retry/{id}&#x60; endpoint to get status of reschedule    operation.  * Added &#x60;POST /backup/retry&#x60; endpoint to reschedule unsuccessful backup tasks.  * Added &#x60;POST /vmware/vm/recoverable_range&#x60; endpoint to get recoverable ranges    for a list of virtual machines.  * Added endpoint &#x60;POST /hierarchy/bulk_sla_conflicts&#x60;. Bulk get the list of    descendant objects with SLA conflicts.  * Added endpoint &#x60;GET /snapshot/{id}/storage/stats&#x60;. Returns storage stats    for a snapshot.  * Added optional query parameter &#x60;include_expired&#x60; to &#x60;GET /certificate&#x60;    endpoint, excluded expired certs by default after the change.  * Added endpoint    &#x60;GET /job_monitoring/subscription&#x60;. Gets all subscriptions to    monitoring page.  * Modified &#x60;SnapshotCloudStorageTier&#x60;, enum adding values AzureArchive, Glacier,    and GlacierDeepArchive.  * Added endpoint    &#x60;GET /backup/verify/{id}&#x60;. Get asynchronous request    details for a Backup Verification job.  * Added new optional field &#x60;privateKey&#x60; to &#x60;CertificateImportRequest&#x60;    object sent to &#x60;POST /certificate&#x60;. Using this field will fail the request    if the provided private key is not successfully parsed.  * Added endpoint    &#x60;DELETE /job_monitoring/subscription/{subscription_id}&#x60;. Delete a    monitoring page email subscription.  * Added endpoint    &#x60;PATCH /job_monitoring/subscription/{subscription_id}&#x60;. Update a    monitoring email subscription.  * Added endpoint    &#x60;GET /job_monitoring/subscription/{subscription_id}&#x60;. Get a    specific monitoring email subscription by id.  * Added endpoint    &#x60;POST /job_monitoring/subscription&#x60;. Create an email subscription    to the job monitoring page.  * Added new endpoint &#x60;POST /backup/verify&#x60;     Verifies the validity of a snapshot.  * Added endpoint &#x60;PATCH /organization/{id}/envoy/bulk&#x60;. Update a list of    Rubrik Envoy objects.  * Added new field &#x60;isGpsLoginEnabled&#x60; to &#x60;SamlSsoStatus&#x60; returned by    &#x60;GET /saml/sso_status&#x60;  * Added endpoint &#x60;GET /oracle/aco_example_download_link&#x60;. Get a download link    for an example Advanced Recovery Options file.  * Added endpoint &#x60;POST /organization/{id}/envoy/bulk&#x60;. Create a list of Rubrik    Envoy objects.  * Added endpoint &#x60;Delete /organization/{id}/envoy/bulk&#x60;. Remove a list of    Rubrik Envoy objects.  * Added organization ID parameter to the response object    IdProviderAuthDomainSummary.  * Added endpoint &#x60;GET /vmware/vcenter/hotadd/vm&#x60;. Gets details about     all HotAdd proxy virtual machines.  * Added endpoint &#x60;POST /sap_hana/system/{id}/refresh&#x60;. Initiates an     asynchronous job to refresh SAP HANA system metadata.  * Added new field &#x60;vcenterName&#x60; to &#x60;VritualMachineDetail&#x60; returned by    &#x60;GET /vmware/vm/{id}&#x60;.  * Added endpoint &#x60;DELETE /sap_hana/system/{id}&#x60;. Initiates an asynchronous     job to delete a SAP HANA system object.  * Added endpoint &#x60;GET /sap_hana/system/request/{id}&#x60;. Gets details about     a SAP HANA system related asynchronous request.  * Added endpoint &#x60;POST /sap_hana/db/{id}/snapshot&#x60;. Initiates a job to     take an on-demand full snapshot of a SAP HANA database.  * Added endpoint &#x60;GET /sap_hana/db/request/{id}&#x60;. Gets details about     a SAP HANA database related request.  * Added endpoint &#x60;GET /sap_hana/db/{id}/snapshot&#x60;. Returns a list of     summary of snapshots of a SAP HANA database.  * Added endpoint &#x60;GET /sap_hana/db/snapshot/{id}&#x60;. Gets details about     a SAP HANA database snapshot.  * Added the &#x60;POST /oracle/db/{id}/validate&#x60; to trigger an validation job on Oracle backups.  * Added new values &#x60;RetentionSlaDomainName&#x60; , &#x60;ObjectType&#x60;, &#x60;SnapshotCount&#x60;,    &#x60;AutoSnapshotCount&#x60; and  &#x60;ManualSnapshotCount&#x60; to    &#x60;UnmanagedObjectSortAttribute&#x60; field of the    &#x60;GET /unmanaged_object/reader_object&#x60; endpont.  * Added new values &#x60;RetentionSlaDomainName&#x60; , &#x60;ObjectType&#x60;, &#x60;SnapshotCount&#x60;,    &#x60;AutoSnapshotCount&#x60; and  &#x60;ManualSnapshotCount&#x60; to    &#x60;UnmanagedObjectSortAttribute&#x60; field of the &#x60;GET /unmanaged_object&#x60; endpont.  * Added the &#x60;POST /replication/location_pause/disable&#x60; to     resume replication from source cluster(s).  * Added the &#x60;POST /replication/location_pause/enable&#x60; to     pause replication from source cluster(s).  * Added endpoint &#x60;POST /sap_hana/system&#x60;. Adds new entry for SAP HANA system     and stores in database.  * Added endpoint &#x60;GET /sap_hana/db&#x60;. Returns summary of all discovered     SAP HANA databases.  * Added endpoint &#x60;GET /sap_hana/db/{id}&#x60; Returns summary of SAP HANA database     with given ID.  * Added &#x60;AggregateSapHanaDb&#x60;, &#x60;SapHanaDb&#x60; and &#x60;SapHanaSystem&#x60; to the     &#x60;object_type&#x60; filtering field of the &#x60;GET /event/latest&#x60; endpoint.  * Added the new optional field &#x60;failoverClusterAppName&#x60; to FilesetSummary     returned by &#x60;GET /fileset&#x60; and &#x60;GET /fileset/{id}&#x60;.  * Added the &#x60;GET /user/lockout&#x60; endpoint to     get the status of local user account lockout.  * Added the &#x60;PATCH /user/lockout&#x60; endpoint to     update the local user account lockout config.  * Added the &#x60;POST /user/{id}/unlock&#x60; endpoint to unlock local user.  * Added the &#x60;GET /cluster/{id}/upgrade/precheck_status&#x60; endpoint to     get the result of the latest run of periodic upgrade prechecks.  * Added the &#x60;POST /cluster/{id}/upgrade/precheck_status&#x60; endpoint to     start an on-demand run of the periodic upgrade prechecks.  * Added the &#x60;GET /cluster/{id}/rubrik_support_portal_credentials&#x60;     endpoint to check if the cluster already has credentials     for the Rubrik support portal.  * Added the &#x60;POST /cluster/{id}/rubrik_support_portal_credentials&#x60;     endpoint to update Rubrik support portal credentials for     the cluster.  * Added the &#x60;GET /vmware/vcenter/{id}/networks&#x60; endpoint to get the     networks in a vCenter.  * Added new field &#x60;isOracleHost&#x60; to HostDetail    returned by &#x60;GET /host/{id}&#x60;.  * Added the &#x60;POST /vmware/vcenter/{id}/hotadd/network&#x60; endpoint to set    the network for a HotAdd proxy virtual machine.  * Added new endpoint &#x60;GET /host/{id}/nas_share_discover&#x60;. Returns all    shares on the NAS host specified by &#39;id&#39;.  * Added new endpoint &#x60;POST /host/share/bulk&#x60; to allow adding NAS    shares in bulk without validating their share credentials.  * Added &#x60;GET /volume_group&#x60; to retrieve a current list of Volume Groups.  * Added &#x60;GET /volume_group/{id}&#x60; to retrieve the details of a Volume Group.  * Added &#x60;PATCH /volume_group/{id}&#x60; to modify the details of a Volume Group.  * Added &#x60;GET /volume_group/{id}/snapshot&#x60; to retrieve the details of all    snapshots of a Volume Group.  * Added &#x60;POST /volume_group/{id}/snapshot&#x60; to create an on-demand snapshot    of a Volume Group.  * Added &#x60;GET /volume_group/snapshot/{id}&#x60; to get the details of a Volume    Group snapshot.  * Added &#x60;GET /volume_group/snapshot/mount&#x60; to retrieve summary information    of all Volume Group mounts.  * Added &#x60;GET /volume_group/snapshot/mount/{id}&#x60; to retrieve summary    information of one Volume Group mount.  * Added &#x60;GET /host/{id}/volume&#x60; to retrieve a list of all volumes on a    Volume Group host.  * Made field &#x60;restoreScriptSmbPath&#x60; optional in &#x60;VolumeGroupMountSummary&#x60;.    This change affects the endpoints &#x60;/volume_group/snapshot/mount&#x60; and    &#x60;/volume_group/snapshot/mount/{id}&#x60;.  * Added endpoint &#x60;GET /mfa/rsa/server&#x60; to get all MFA servers.  * Added endpoint &#x60;POST /mfa/rsa/server&#x60; to create a new MFA server.  * Added endpoint &#x60;GET /mfa/rsa/server/{id}&#x60; to get a specific MFA server.  * Added endpoint &#x60;PATCH /mfa/rsa/server/{id}&#x60; to update an MFA server.  * Added endpoint &#x60;DELETE /mfa/rsa/server/{id}&#x60; to delete an MFA server.  * Added endpoint &#x60;PUT /cluster/{id}/security/web_signed_cert&#x60;     to set the web server certificate.  * Added endpoint &#x60;DELETE /cluster/{id}/security/web_signed_cert&#x60;     to use the default, self-signed web server certificate.  * Added endpoint &#x60;PUT /cluster/{id}/security/kmip/client&#x60; to configure     the KMIP client on Rubrik.  * Added endpoint &#x60;GET /cluster/{id}/security/kmip/client&#x60; to get     the KMIP client configuration.  * Added endpoint &#x60;GET /cluster/{id}/security/kmip/server&#x60; to get the     KMIP server configurations.  * Added endpoint &#x60;PUT /cluster/{id}/security/kmip/server&#x60; to configure a     KMIP server.  * Added endpoint &#x60;DELETE /cluster/{id}/security/kmip/server&#x60; to delete a     configured KMIP server.  * Added endpoint &#x60;GET /database/log_report&#x60; to retrieve the database log     report summary.  * Added endpoint &#x60;POST /unmanaged_object/assign_retention_sla&#x60; to assign     a retention SLA to unmanaged objects asynchronously.  * Added endpoint &#x60;GET /sap_hana/db/{id}/recoverable_range&#x60;. Gets details     about recoverable ranges of a SAP HANA database.  * Added new  field &#x60;legalHoldDownloadConfig&#x60; to &#x60;MssqlBackupSelection&#x60; and    &#x60;DownloadMssqlBackupFilesByIdJobConfig&#x60;. An optional Boolean that specifies    whether the download is in response to a Legal Hold. This change affects    endpoints &#x60;/mssql/db/{id}/download_files_by_id&#x60;,    &#x60;/mssql/db/{id}/download_files&#x60; and &#x60;/mssql/db/{id}/browse&#x60;.  * Added new field &#x60;canUnmount&#x60; to &#x60;VolumeGroupMountSummary&#x60;, an optional    boolean value that indicates if the logged-in user has the authority    to remove the specified mount.  * Added &#x60;GET /vmware/vcenter/{id}/hotadd/needed&#x60; endpoint to get the     number of HotAdd proxies needed for a vCenter.  * Added endpoint &#x60;DELETE /sap_hana/db/snapshot/{id}&#x60;. Initiates a request    to delete a full snapshot of a SAP HANA database.  * Added new field &#x60;needsMigration&#x60; to &#x60;VolumeGroupSummary&#x60;. This change    affects the endpoints &#x60;GET /volume_group&#x60; and &#x60;GET /volume_group/{id}&#x60;.  * Added new fields &#x60;usedFastVhdx&#x60; and &#x60;fileSizeInBytes&#x60; to    &#x60;VolumeGroupSnapshotSummary&#x60;. This change affects the endpoints    &#x60;GET /volume_group/{id}/snapshot&#x60; and &#x60;GET /volume_group/snapshot/{id}&#x60;.  * Added endpoint &#x60;GET /cluster/me/upgrade/monitor_events&#x60; to get notifications    about events occurring at CDM.  * Added endpoint &#x60;GET /volume_group/{id}/latest_snapshot&#x60; to retrieve summary    information of the latest snapshot of a Volume Group.  * Added &#x60;GET /vmware/vcenter/{id}/hotadd/bandwidth&#x60; endpoint to get the    HotAdd bandwidth limits for a vCenter.  * Added &#x60;POST /vmware/vcenter/{id}/hotadd/bandwidth&#x60; endpoint to set the    HotAdd bandwidth limits for a vCenter.  * Added field &#x60;isVmc&#x60; returned by &#x60;GET /vmware/vcenter&#x60; to retrieve summary    information of a vCenter.  * Added new optional field &#x60;unreadable&#x60; to &#x60;BrowseResponse&#x60;, which is used by    &#x60;GET /browse&#x60;.  * Added new endpoint &#x60;GET /config/history/list_updates&#x60; Returns a list of    filtered configuration updates.  * Added new endpoint &#x60;GET /config/history/ondate&#x60; Returns a list of    configurations and their values on a given date.  * Added new field &#x60;dataToTransfer&#x60; to &#x60;EventSeriesSummaryV1&#x60;, an optional    integer value that represents the amount of data that needs to be    transferred by the job corresponding to the event.  * Added new field &#x60;estimatedTimeRemaining&#x60; to &#x60;EventSeriesSummaryV1&#x60;, an    optional string value that represents the estimated time remaining until    the job corresponding to the event has completed. The estimated time has    millisecond granularity.  * Added endpoint &#x60;GET /sap_hana/db/{id}/missed_snapshot&#x60; Returns a list of     summary information for the missed snapshots of a SAP HANA database.  * Added new field &#x60;forceFull&#x60; to &#x60;VolumeGroupSummary&#x60;. This change    affects the endpoints &#x60;GET /volume_group&#x60; and &#x60;GET /volume_group/{id}&#x60;.  * Modified afterId in response of &#x60;GET /event/latest&#x60; and &#x60;GET /event&#x60;    to point to each individual event in the list response instead of having    all afterId values in the list response point to the last event in the    list.  * Copied &#x60;GET /mssql/availability_group&#x60; endpoint from internal to v1 to get    all SQL Server availability groups.  * Copied &#x60;GET /mssql/availability_group/{id}&#x60; endpoint from internal to v1 to    get details of a SQL Server availability group.  * Copied &#x60;PATCH /mssql/availability_group/{id}&#x60; endpoint from internal to    v1 to update a SQL Server availability group.  * Copied &#x60;PATCH /mssql/db/bulk&#x60; endpoint from internal to v1 to update multiple    SQL Server databases.  * Copied &#x60;POST /mssql/db/bulk/snapshot&#x60; endpoint from internal to v1 to take on    demand snapshot of multiple SQL Server databases.  * Copied &#x60;GET /mssql/db/bulk/snapshot/{id}&#x60; endpoint from internal to v1 to get    details of on demand snapshot of multiple SQL Server databases.  * Copied &#x60;GET /mssql/db/count&#x60; endpoint from internal to v1 to get the count of    SQL Server databases.  * Copied &#x60;GET /mssql/instance/count&#x60; endpoint from internal to v1 to get the    count of SQL Server instances.  * Copied &#x60;DELETE /mssql/db/{id}/recoverable_range/download&#x60; endpoint from    internal to v1 to delete downloaded recoverable ranges of a SQL Server    database.  * Copied &#x60;GET /mssql/db/recoverable_range/download/{id}&#x60; endpoint from    internal to v1 to get the status of delete downloaded recoverable range job.  * Copied &#x60;GET /mssql/db/{id}/compatible_instance&#x60; endpoint from internal to v1    to get compatible instances for the recovery of a SQL Server database.  * Copied &#x60;GET /mssql/db/{id}/restore_estimate&#x60; endpoint from internal to v1 to    get size estimate for restore or export of a SQL Server database.  * Copied &#x60;GET /mssql/db/{id}/restore_files&#x60; endpoint from internal to v1 to get    all data files to be restored for an export or restore operation on a SQL    Server database.  * Copied &#x60;GET /mssql/db/{id}/snappable_id&#x60; endpoint from internal to v1 to get    the snappable id of a SQL Server database.  * Copied &#x60;GET /mssql/db/defaults&#x60; endpoint from internal to v1 to get the    default properties for SQL Server databases.  * Copied &#x60;PATCH /mssql/db/defaults&#x60; endpoint from internal to v1 to update the  * Added new field &#x60;instanceChildrenInfo&#x60; to the response from the v1 endpoint    &#x60;GET /mssql/hierarchy/root/children&#x60;. The new field is an array of type    &#x60;MssqlInstanceShortSummary&#x60; that contains the managed identifier, the name and    active node for a Windows Failover Cluster instance.  * Added enums for the &#x60;sort_by&#x60; parameter in &#x60;GET /mssql/db&#x60;.  * Added &#x60;POST /cluster/{id}/manual_discover_ipv4&#x60; endpoint to allow discovery of new    nodes over IPv4 network.  ## Breaking changes:  * Added new field &#x60;nodeName&#x60; in FailoverClusterNodeOrder object used by    &#x60;PATCH /failover_cluster/failover_cluster_app/{id}&#x60; and    &#x60;POST /failover_cluster/failover_cluster_app&#x60; endpoints.    The &#x60;nodeName&#x60; is the name of the failover cluster node.  * Renamed the field &#x60;vips&#x60; in FailoverClusterAppSource object to    &#x60;virtualIps&#x60;. The FailoverClusterAppSource is used by    &#x60;GET /failover_cluster/failover_cluster_app&#x60;,    &#x60;GET /failover_cluster/failover_cluster_app/{id}&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}/children&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}/descendants&#x60;,    &#x60;PATCH /failover_cluster/failover_cluster_app/{id}&#x60; and    &#x60;POST /failover_cluster/failover_cluster_app&#x60; endpoints.  * Removed &#x60;POST /cluster/{id}/manual_discover_ll_ipv4&#x60;  ### Changes to V1 API in Rubrik Version 5.2.2  ## New features:  * Added optional field isOnDemand to &#x60;EventSeriesSummaryV1&#x60;.    The parameter indicates if the job associated with the event    series is a on demand job.   ### Changes to V1 API in Rubrik Version 5.2.1  ## New features:  * Added optional query parameters limit and offset to support pagination for    GET /role endpoint.   ### Changes to V1 API in Rubrik Version 5.2.0  ## Deprecation:  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /mssql/db/{id}/snapshot&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /mssql/db/snapshot/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /vmware/vm/{id}/snapshot&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /vmware/vm/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /vmware/vm/snapshot/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /hdfs/snapshot/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /hdfs&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;POST /hdfs&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /hdfs/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;PATCH /hdfs/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /fileset/snapshot/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /fileset&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;POST /fileset&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /fileset/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;PATCH /fileset/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  * Deprecating &#x60;slaId&#x60; field returned by &#x60;GET /failover_cluster/     failover_cluster_app/{id}&#x60;.     See **snapshotRetentionInfo** to track retention for     snapshots.  ## New features:  * Added new endpoint   &#x60;GET /data_source/{id}/expired_custom_retention_snapshots&#x60;.    Get all expired snapshots which were explicitly assigned a SLA domain.  * Added new field &#x60;parentSnapshotId&#x60; to FilesetSnapshotDetail returned by    &#x60;GET /fileset/snapshot/{id}&#x60;.  * Added new field &#x60;parentSnapshotId&#x60; to HdfsSnapshotDetail returned by    &#x60;GET /hdfs/snapshot/{id}&#x60;.  * Added new field &#x60;parentSnapshotId&#x60; to MssqlDbSnapshotSummary returned by    &#x60;GET /mssql/db/{id}/snapshot&#x60;.  * Added new field &#x60;parentSnapshotId&#x60; to MssqlDbSnapshotDetail returned by    &#x60;GET /mssql/db/snapshot/{id}&#x60;.  * Added new field &#x60;parentSnapshotId&#x60; to VmSnapshotSummary returned by    &#x60;GET /vmware/vm/{id}/snapshot&#x60;.  * Added new field &#x60;parentSnapshotId&#x60; to VmSnapshotDetail returned by    &#x60;GET /vmware/vm/snapshot/{id}&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlHierarchyObjectSummary    returned by &#x60;GET /mssql/hierarchy/{id}&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlHierarchyObjectSummary    returned by &#x60;GET /mssql/hierarchy/{id}/descendants&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlHierarchyObjectSummary    returned by &#x60;GET /mssql/hierarchy/{id}/children&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlDbDetail    returned by &#x60;GET /mssql/db/{id}&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlDbDetail    returned by &#x60;PATCH /mssql/db/{id}&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlDbDetail    returned by &#x60;PATCH /mssql/db/bulk&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlDbSnapshotDetail    returned by &#x60;GET /mssql/db/snapshot/{id}&#x60;.  * Added new field &#x60;retentionSlaDomanId&#x60; to MssqlDbSummary    returned by &#x60;GET /mssql/db&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to ComputeClusterDetail    returned by &#x60;PATCH /vmware/compute_cluster/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VmwareHostDetail    returned by &#x60;PATCH /vmware/host/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VmwareVmMountDetailV1    returned by &#x60;PATCH /vmware/vm/snapshot/mount/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VmwareVmMountSummary    returned by &#x60;GET /vmware/vm/snapshot/mount&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to BulkOracleDbDetails    returned by &#x60;PATCH /oracle/db/bulk&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to ComputeClusterDetail    returned by &#x60;GET /vmware/compute_cluster/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to UnmanagedObjectDetails    returned by &#x60;GET /unmanaged_object&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to UnmanagedObjectSummary    returned by &#x60;GET /unmanaged_object/reader_object&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VirtualMachineDetail    returned by &#x60;GET /vmware/vm/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VirtualMachineDetail    returned by &#x60;PATCH /vmware/vm/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VirtualMachineSummary    returned by &#x60;GET /vmware/vm&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VmSnapshotDetail    returned by &#x60;GET /vmware/vm/snapshot/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VmwareHostDetail    returned by &#x60;GET /vmware/host/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to VmwareVmMountDetailV1    returned by &#x60;GET /vmware/vm/snapshot/mount/{id}&#x60;.  * Added new field &#x60;retentionSlaDomainId&#x60; to UnmanagedObjectSummary    returned by &#x60;GET /unmanaged_object&#x60;.  * Added new endpoint &#x60;GET /report/compliance_summary_sla&#x60;. Returns the    compliance summary information for all protected objects based on a    SLA Domain-based requirement of whether the last expected snapshot was taken.    Currently behind flag, will not return correct information    until flag is flipped.  * Added endpoint &#x60;GET /cluster/{id}/upgrade/available_version&#x60; which       retrieves a list of Rubrik CDM versions available to upgrade the Rubrik       cluster.  * Added endpoint &#x60;GET /cluster/{id}/upgrade/request/${request_id}&#x60; to    query the status of an asynchronous upgrade related request.  * Added endpoint &#x60;POST /cluster/{id}/upgrade/stage_cdm_software&#x60; which    allows staging CDM software for upgrades on the cluster.  * Added new field &#x60;hasSnapshotsWithPolicy&#x60; to UnmanagedObjectDetails returned    by GET &#x60;/unmanaged_object&#x60;.  * Added new field &#x60;hasSnapshotsWithPolicy&#x60; to UnmanagedObjectSummary returned    by GET &#x60;/unmanaged_object&#x60;.  * Added new field &#x60;hasSnapshotsWithPolicy&#x60; to UnmanagedObjectSummary returned    by GET &#x60;/unmanaged_object/reader_object&#x60;  * Added new field &#x60;slaLastUpdateTime&#x60; to BulkOracleDbDetails    returned by &#x60;PATCH /oracle/db/bulk&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to BulkOracleHostDetails    returned by &#x60;PATCH /oracle/host/bulk&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to BulkOracleRacDetails    returned by &#x60;PATCH /oracle/rac/bulk&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to ComputeClusterDetail    returned by &#x60;GET /vmware/compute_cluster/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to ComputeClusterDetail    returned by &#x60;PATCH /vmware/compute_cluster/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to ComputeClusterSummary    returned by &#x60;GET /vmware/compute_cluster&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterAppDetail    returned by &#x60;GET /failover_cluster/failover_cluster_app/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterAppSummary    returned by &#x60;GET /failover_cluster/failover_cluster_app&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterAppSummary    returned by POST &#x60;/failover_cluster/failover_cluster_app&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterAppSummary    returned by &#x60;PATCH /failover_cluster/failover_cluster_app/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterDetail    returned by POST &#x60;/failover_cluster&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterDetail    returned by &#x60;GET /failover_cluster/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterDetail    returned by &#x60;PATCH /failover_cluster/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterHierarchyObjectSummary    returned by &#x60;GET /failover_cluster/hierarchy/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterHierarchyObjectSummary    returned by &#x60;GET /failover_cluster/hierarchy/{id}/children&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterHierarchyObjectSummary    returned by &#x60;GET /failover_cluster/hierarchy/{id}/descendants&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FailoverClusterSummary    returned by &#x60;GET /failover_cluster&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FilesetDetail    returned by &#x60;POST /fileset&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FilesetDetail    returned by &#x60;GET /fileset/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FilesetDetail    returned by &#x60;PATCH /fileset/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to FilesetSummary    returned by &#x60;GET /fileset&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to HdfsDetail    returned by &#x60;POST /hdfs&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to HdfsDetail    returned by &#x60;GET /hdfs/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to HdfsDetail    returned by &#x60;PATCH /hdfs/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to HdfsSummary    returned by &#x60;GET /hdfs&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to HostHierarchyObjectSummary    returned by &#x60;GET /host/hierarchy/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to HostHierarchyObjectSummary    returned by &#x60;GET /host/hierarchy/{id}/children&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VcenterDetail    returned by &#x60;GET /vmware/vcenter/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VcenterSummary    returned by &#x60;GET /vmware/vcenter&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VcenterSummary    returned by &#x60;PATCH /vmware/vcenter/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VcenterSummary    returned by &#x60;PUT /vmware/vcenter/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VirtualMachineDetail  * Added &#x60;PATCH /host/share/bulk&#x60; endpoint to update multiple network shares.  * Added new field &#x60;isCustomRetentionApplied&#x60; to SnapshotSummary returned by    &#x60;GET /unmanaged_object/{id}/snapshot&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VirtualMachineDetail    returned by &#x60;GET /vmware/vm/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VirtualMachineDetail    returned by &#x60;PATCH /vmware/vm/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VirtualMachineSummary    returned by &#x60;GET /vmware/vm&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VmSnapshotDetail    returned by &#x60;GET /vmware/vm/snapshot/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VmwareHostDetail    returned by &#x60;GET /vmware/host/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VmwareHostDetail    returned by &#x60;PATCH /vmware/host/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VmwareHostSummary    returned by &#x60;GET /vmware/host&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VmwareVmMountDetailV1    returned by &#x60;GET /vmware/vm/snapshot/mount/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VmwareVmMountDetailV1    returned by &#x60;PATCH /vmware/vm/snapshot/mount/{id}&#x60;.  * Added new field &#x60;slaLastUpdateTime&#x60; to VmwareVmMountSummary    returned by &#x60;GET /vmware/vm/snapshot/mount&#x60;.  * Added new field &#x60;isCustomRetentionApplied&#x60; to SnapshotSummary returned by    &#x60;GET /unmanaged_object/{id}/snapshot&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to BulkOracleDbDetails returned by   &#x60;PATCH /oracle/db/bulk&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to BulkOracleHostDetails returned    by &#x60;PATCH /oracle/host/bulk&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to BulkOracleRacDetails returned by   &#x60;PATCH /oracle/rac/bulk&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to ComputeClusterDetail returned by   &#x60;GET /vmware/compute_cluster/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to ComputeClusterDetail returned by   &#x60;PATCH /vmware/compute_cluster/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to ComputeClusterSummary returned    by &#x60;GET /vmware/compute_cluster&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FailoverClusterAppDetail    returned by &#x60;GET /failover_cluster/failover_cluster_app/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FailoverClusterAppSummary    returned by &#x60;GET /failover_cluster/failover_cluster_app&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FailoverClusterAppSummary    returned by &#x60;POST /failover_cluster/failover_cluster_app&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FailoverClusterAppSummary    returned by &#x60;PATCH /failover_cluster/failover_cluster_app/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FailoverClusterDetail returned    by &#x60;POST /failover_cluster&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FailoverClusterDetail returned    by &#x60;GET /failover_cluster/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FailoverClusterDetail returned    by &#x60;PATCH /failover_cluster/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to    FailoverClusterHierarchyObjectSummary returned by    &#x60;GET /failover_cluster/hierarchy/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to    FailoverClusterHierarchyObjectSummary returned by    &#x60;GET /failover_cluster/hierarchy/{id}/children&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to    FailoverClusterHierarchyObjectSummary returned by    &#x60;GET /failover_cluster/hierarchy/{id}/descendants&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to  FailoverClusterSummary returned    by &#x60;GET /failover_cluster&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FilesetDetail returned by   &#x60;POST /fileset&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FilesetDetail returned by   &#x60;GET /fileset/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FilesetDetail returned by   &#x60;PATCH /fileset/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to FilesetSummary returned by   &#x60;GET /fileset&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to HdfsDetail returned by   &#x60;POST /hdfs&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to HdfsDetail returned by   &#x60;GET /hdfs/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to HdfsDetail returned by   &#x60;PATCH /hdfs/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to HdfsSummary returned by   &#x60;GET /hdfs&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to HostHierarchyObjectSummary    returned by &#x60;GET /host/hierarchy/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to HostHierarchyObjectSummary    returned by &#x60;GET /host/hierarchy/{id}/children&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to UnmanagedObjectDetails returned    by &#x60;GET /unmanaged_object&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to UnmanagedObjectSummary returned    by &#x60;GET /unmanaged_object&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to UnmanagedObjectSummary returned    by &#x60;GET /unmanaged_object/reader_object&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VcenterDetail returned by    &#x60;GET /vmware/vcenter/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VcenterSummary returned by    &#x60;GET /vmware/vcenter&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VcenterSummary returned by    &#x60;PATCH /vmware/vcenter/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VcenterSummary returned by    &#x60;PUT /vmware/vcenter/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VirtualMachineDetail returned by    &#x60;GET /vmware/vm/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VirtualMachineDetail returned by   &#x60;PATCH /vmware/vm/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VirtualMachineSummary returned    by &#x60;GET /vmware/vm&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VmSnapshotDetail returned by   &#x60;GET /vmware/vm/snapshot/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VmwareHostDetail returned by   &#x60;GET /vmware/host/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VmwareHostDetail returned by   &#x60;PATCH /vmware/host/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VmwareHostSummary returned by   &#x60;GET /vmware/host&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VmwareVmMountDetailV1 returned    by &#x60;GET /vmware/vm/snapshot/mount/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VmwareVmMountDetailV1 returned    by &#x60;PATCH /vmware/vm/snapshot/mount/{id}&#x60;.  * Added new Field &#x60;configuredSlaDomainType&#x60; to VmwareVmMountSummary returned by   &#x60;GET /vmware/vm/snapshot/mount&#x60;.  * Added new field &#x60;isCustomRetentionApplied&#x60; to FilesetSnapshotDetail returned    by &#x60;GET /fileset/snapshot/{id}&#x60;.  * Added new field &#x60;isCustomRetentionApplied&#x60; to HdfsSnapshotDetail returned by    &#x60;GET /hdfs/snapshot/{id}&#x60;.  * Added new field &#x60;isCustomRetentionApplied&#x60; to MssqlDbSnapshotSummary returned    by &#x60;GET /mssql/db/{id}/snapshot&#x60;.  * Added new field &#x60;isCustomRetentionApplied&#x60; to MssqlDbSnapshotDetail returned    by &#x60;GET /mssql/db/snapshot/{id}&#x60;.  * Added new field &#x60;isCustomRetentionApplied&#x60; to VmSnapshotSummary returned by    &#x60;GET /vmware/vm/{id}/snapshot&#x60;.  * Added new field &#x60;isCustomRetentionApplied&#x60; to VmSnapshotDetail returned by    &#x60;GET /vmware/vm/snapshot/{id}&#x60;.  * Added endpoint &#x60;POST /cluster/{id}/manual_discover&#x60;, which allows    the customer to manually input data that would be learned using    mDNS discovery. Returns same output as the &#x60;discover&#x60; endpoint.  * Added new endpoint &#x60;POST /data_source/{id}/snapshot/bulk_delete&#x60;.     Delete given snapshots for an object.  * Added new endpoint &#x60;POST /data_source/snapshot/bulk_delete&#x60;.     Delete all snapshots for given objects.  * Added new field &#x60;snapshotFrequency&#x60; to &#x60;snapshotLocationRetentionInfo&#x60; field    of &#x60;SnapshotRetentionInfo&#x60; field of FilesetSnapshotDetail returned by    &#x60;GET /fileset/snapshot/{id}&#x60;.  * Added new field &#x60;snapshotFrequency&#x60; to &#x60;snapshotLocationRetentionInfo&#x60; field    of &#x60;SnapshotRetentionInfo&#x60; field of HdfsSnapshotDetail returned by    &#x60;GET/hdfs/snapshot/{id}&#x60;.  * Added new field &#x60;snapshotFrequency&#x60; to &#x60;snapshotLocationRetentionInfo&#x60; field    of &#x60;SnapshotRetentionInfo&#x60; field of MssqlDbSnapshotSummary returned by    &#x60;GET /mssql/db/{id}/snapshot&#x60;.  * Added new field &#x60;snapshotFrequency&#x60; to &#x60;snapshotLocationRetentionInfo&#x60; field    of &#x60;SnapshotRetentionInfo&#x60; field of MssqlDbSnapshotDetail returned by    &#x60;GET /mssql/db/snapshot/{id}&#x60;.  * Added new field &#x60;snapshotFrequency&#x60; to &#x60;snapshotLocationRetentionInfo&#x60; field    of &#x60;SnapshotRetentionInfo&#x60; field of VmSnapshotSummary returned by    &#x60;GET /vmware/vm/{id}/snapshot&#x60;.  * Added new field &#x60;snapshotFrequency&#x60; to &#x60;snapshotLocationRetentionInfo&#x60; field    of &#x60;SnapshotRetentionInfo&#x60; field of VmSnapshotDetail returned by    &#x60;GET /vmware/vm/snapshot/{id}&#x60;.  * Added new field &#x60;SnapshotRetentionInfo&#x60; to FilesetSnapshotDetail returned by    &#x60;GET /fileset/snapshot/{id}&#x60;.  * Added new field &#x60;SnapshotRetentionInfo&#x60; to HdfsSnapshotDetail returned by    &#x60;GET /hdfs/snapshot/{id}&#x60;.  * Added new field &#x60;SnapshotRetentionInfo&#x60; to MssqlDbSnapshotSummary returned by    &#x60;GET /mssql/db/{id}/snapshot&#x60;.  * Added new field &#x60;SnapshotRetentionInfo&#x60; to MssqlDbSnapshotDetail returned by    &#x60;GET /mssql/db/snapshot/{id}&#x60;.  * Added new field &#x60;SnapshotRetentionInfo&#x60; to VmSnapshotSummary returned by    &#x60;GET /vmware/vm/{id}/snapshot&#x60;.  * Added new field &#x60;SnapshotRetentionInfo&#x60; to VmSnapshotDetail returned by    &#x60;GET /vmware/vm/snapshot/{id}&#x60;.  * Added new endpoint &#x60;GET /unmanaged_object/{id}/snapshot&#x60;. Returns summary    of all the snapshots for a given object.  * Added new endpoint &#x60;GET /unmanaged_object&#x60;. Returns the summary of all the    objects with unmanaged snapshots.  * Added new endpoint &#x60;GET /report/compliance_summary&#x60;. Returns the summary of    snapshot compliance based on a time-based requirement of at least one    snapshot in each 24 hour report period for each protected object.    This endpoint ignores the policies assigned to protected objects through SLA    Domains.  * Added new endpoint &#x60;GET /cluster/{id}/node_id&#x60;. Returns the IDs of the    nodes in the cluster.  * Added new endpoint &#x60;GET /role&#x60;. Returns role metadata for all roles in an    organization.  * Added new endpoint &#x60;POST /role&#x60;. Create a new role.  * Added new endpoint &#x60;GET /role/{id}&#x60;. Get role metadata and the list of    principals assigned to a specific role.  * Added new endpoint &#x60;PATCH /role/{id}&#x60;. Update metadata for a specific role.  * Added new endpoint &#x60;DELETE /role/{id}&#x60;. Delete a role.  * Added new endpoint &#x60;GET /principal&#x60;. Get principals.  * Added new endpoint &#x60;GET /principal/role&#x60;. Get list of roles assigned to    principals.  * Added new endpoint &#x60;POST /principal/role&#x60;. Assign roles to principals.  * Added new endpoint &#x60;POST /principal/role/bulk_revoke&#x60;. Revoke roles from    principals.  * Added &#x60;DELETE /certificate/{id}&#x60; endpoint to delete a certificate.  * Added &#x60;PATCH /cluster/{id}/security/cors&#x60; endpoint to update the current CORS    support configuration for a web server.  * Added &#x60;GET /cluster/{id}/security/cors&#x60; endpoint to get the current CORS    support configuration for a web server.  * Added new optional field &#x60;failoverClusterAppId&#x60; to FilesetSummary and    FilesetCreate in &#x60;POST /fileset&#x60;, &#x60;GET /fileset&#x60; and &#x60;PATCH /fileset/{id}&#x60;    endpoints to enable clustered fileset backup.  * Added &#x60;GET /unmanaged_object/reader_object&#x60; endpoint to get all    unmanaged objects that are recovered from reader archival locations.  * Added &#x60;GET /failover_cluster&#x60; endpoint to get all failover clusters.  * Added &#x60;POST /failover_cluster&#x60; endpoint to create a failover cluster.  * Added &#x60;GET /failover_cluster/{id}&#x60; endpoint to retrieve a failover    cluster by id.  * Added &#x60;PATCH /failover_cluster/{id}&#x60; endpoint to update a failover cluster.  * Added &#x60;DELETE /failover_cluster/{id}&#x60; endpoint to delete a failover cluster.  * Added &#x60;GET /failover_cluster/failover_cluster_app&#x60; endpoint to get all    failover cluster apps.  * Added &#x60;POST /failover_cluster/failover_cluster_app&#x60; endpoint to create a    failover cluster app.  * Added &#x60;GET /failover_cluster/failover_cluster_app/{id}&#x60; endpoint to retrieve    a failover cluster app by ID.  * Added &#x60;PATCH /failover_cluster/failover_cluster_app/{id}&#x60; endpoint to update    a failover cluster app.  * Added &#x60;DELETE /failover_cluster/failover_cluster_app/{id}&#x60; endpoint to delete    a failover cluster app.  * Added &#x60;GET /legal_hold/snapshot&#x60; endpoint to get snapshots under legal hold.  * Added &#x60;POST /legal_hold/snapshot&#x60; endpoint to apply legal hold on a snapshot.  * Added &#x60;GET /legal_hold/object&#x60; endpoint to get all objects with snasphot    under legal hold.  * Added &#x60;POST /legal_hold/snapshot/dissolve&#x60; to dissolve legal hold from    snapshots.  * Added optional field &#x60;shouldUseAgent&#x60; to &#x60;RestoreFileJobConfig&#x60;.    in &#x60;POST /vmware/vm/snapshot/{id}/restore_file&#x60; to specify    whether to use Rubrik Backup Service to restore file. Default value is true.  * Added &#x60;America/Costa_Rica&#x60;and &#x60;America/St_Johns&#x60; as supported cluster time    zones.  * Added &#x60;GET /failover_cluster/hierarchy/{id}&#x60; to get summary of a    failover cluster hierarchy object.  * Added &#x60;GET /failover_cluster/hierarchy/{id}/children&#x60; to get list of    immediate descendant objects.  * Added &#x60;GET /failover_cluster/hierarchy/{id}/descendants&#x60; to get list of    descendant objects.  * Added &#x60;GET /job_monitoring&#x60; to get job summary information, with options    to filter and sort the results for protection and recovery jobs that are    currently running, scheduled to run or completed in the past 24 hours.  * Added &#x60;GET /job_monitoring/summary_by_job_type&#x60; to get job summary    information separated by job type for all jobs that are currently running,    scheduled to run or completed in the past 24 hours.  * Added &#x60;GET /job_monitoring/summary_by_job_state&#x60; to get job summary    information separated by job state for all running jobs, jobs that have    been scheduled and jobs that are complete, for protection and recovery    jobs in the past 24 hours.  * Added &#x60;GET /job_monitoring/csv_download_link&#x60; which returns a link to    download job summary information with the same filters as the    &#x60;GET /job_monitoring&#x60; API.  * Added optional field &#39;legalHoldDownloadConfig&#39; to    &#39;FilesetDownloadFileJobConfig&#39;, &#39;DownloadFileJobConfig&#39;.    This is an optional argument containing a Boolean parameter to depict if    the download is being triggered for Legal Hold use case.  * Added optional field isPlacedOnLegalHold to BaseSnapshotSummary.    The Boolean parameter specifies whether the snapshot is placed under a    Legal Hold.  * Added &#x60;POST /mssql/db/{id}/browse&#x60; endpoint to list backups, which includes    both snapshots and logs.  * Added &#x60;POST /mssql/db/{id}/download_files&#x60; endpoint to download a list of    backup files specified by time range or point in time.  * Added &#x60;POST /mssql/db/{id}/download_files_by_id&#x60; endpoint to download a list    of backup files specified by ID.  * Added &#x60;PATCH /report/config&#x60; to set the number of days for which the report    job instances for log jobs are retained.  * Added ISO8601 format date as a way of specifying time in MssqlRecoveryPoint.  * Added primaryDatabaseLogBackupFrequency parameter to the response objects    MssqlLogShippingSummary and MssqlLogShippingDetail.  * Added targetInstanceName parameter to MssqlMountSummary  * Added &#x60;POST /mssql/db/{id}/download&#x60; endpoint to download the logs/snapshots    required to restore a SQL database to a given recovery point.  * Added the optional fields uid, surname, and emailAddress to the    GenericCsrRequest (renamed from CsrRequest) and renamed WebCsrRequest    to CsrRequest.  * Added new endpoints &#x60;PATCH /oracle/db/bulk&#x60;,    &#x60;PATCH /oracle/host/bulk&#x60;, and &#x60;PATCH /oracle/rac/bulk&#x60; for bulk    updating an array of IDs with &#x60;OracleProperties&#x60;.  * Added an optional query parameter    &#x60;should_apply_to_existing_snapshots&#x60; to &#x60;PATCH /sla_domain/{id}&#x60; to    apply the new SLA configuration to existing snapshots of data sources    retained by the specified SLA Domain.  * Added an optional query parameter    &#x60;should_apply_to_existing_snapshots&#x60; to &#x60;PUT /sla_domain/{id}&#x60; to    apply the new SLA configuration to existing snapshots of data sources    retained by the specified SLA Domain.  * Added optional field &#39;shouldForce&#39; to &#39;UpdateMountConfig&#39; in PATCH    vmware/vm/snapshot/mount/{id} endpoint. Use this field to forcibly power    down a virtual machine mounted with Storage vMotion.  * Added a new optional field &#x60;isOracleHost&#x60; to &#x60;HostRegister&#x60; in &#x60;POST /host&#x60;.    and &#x60;HostUpdate&#x60; in &#x60;PATCH /host/{id}&#x60; to indicate if we should discover    Oracle information during registration and host refresh.  * Added a new model &#x60;EventCsvDownloadResponse&#x60; and REST API endpoints    &#x60;/event/csv_download_link&#x60; for downloading CSV file for event summary    information in the Activity log UI page.  * Added &#x60;GET /host/hierarchy/{id}&#x60; to get summary of a    host/share hierarchy object.  * Added &#x60;GET /host/hierarchy/{id}/children&#x60; to get list of    immediate descendant objects.  * Added &#x60;isInVmc&#x60; in &#x60;GET /vmware/vm/{id}&#x60; and &#x60;PATCH /vmware/vm/{id}&#x60;.    to return whether the virtual machine is in a VMC setup.  * Added &#x60;pendingSlaDomain&#x60; field to &#x60;GET /vmware/vm/{id}&#x60; and    &#x60;PATCH /vmware/vm/{id}&#x60; to indicate a pending SLA Domain assignment    on the Virtual Machine.  * Added &#x60;pendingSlaDomain&#x60; field to &#x60;GET /mssql/hierarchy/{id}&#x60;,    &#x60;GET /mssql/hierarchy/{id}/children&#x60;, and    &#x60;GET /mssql/hierarchy/{id}/descendants&#x60; to indicate a pending SLA    Domain assignment on the MSSQL object.  * Added &#x60;pendingSlaDomain&#x60; field to &#x60;GET /fileset&#x60;,    &#x60;POST /fileset&#x60;, &#x60;GET /fileset/{id}&#x60;, and &#x60;PATCH /fileset/{id}&#x60;    to indicate a pending SLA Domain assignment on the Fileset.  * Added &#x60;pendingSlaDomain&#x60; field to the objects referenced by the    &#x60;filesets&#x60; field in the response objects of    &#x60;GET /failover_cluster/hierarchy/{id}&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}/children&#x60;,    &#x60;GET /failover_cluster/hierarchy/{id}/descendants&#x60;,    &#x60;GET /host/hierarchy/{id}&#x60;, and &#x60;GET /host/hierarchy/{id}/children&#x60;    to indicate a pending SLA Domain assignment on the object.  * Added endpoint &#x60;POST /vmware/vcenter/{id}/refresh_vm&#x60; which     allows refreshing metadata for a single virtual machine in a vCenter.  * Added optional field &#x60;shouldForceFull&#x60; to the body parameter of    &#x60;PATCH /mssql/db/{id}&#x60; to enable requiring a full snapshot for a specified     SQL Server database.  * Added &#x60;LinuxHost&#x60;, &#x60;WindowsHost&#x60; and &#x60;NasHost&#x60; to the    &#x60;object_type&#x60; filtering field of the &#x60;GET /event/latest&#x60; endpoint.   ### Changes to V1 API in Rubrik Version 5.1.1  ## Breaking changes:   ## New features:  * Added &#x60;has_instances&#x60; parameter to GET &#x60;/mssql/hierarchy/{id}/descendants&#x60;.    and GET &#x60;/mssql/hierarchy/{id}/children&#x60;. Added &#x60;hasInstances&#x60; field in the    response object.   ### Changes to V1 API in Rubrik Version 5.1.0  ## Deprecation:   ## New features:  * Added &#x60;GET /archive/aws/s3/{id}/account_id&#x60; endpoint to get the    account ID of the AWS data location.  * Added &#x60;DELETE /authorization/cache&#x60; endpoint to clear cached authorization    information.  * Added the &#x60;GET /syslog/export&#x60; endpoint to get all syslog export rules.  * Added the &#x60;POST /syslog/export&#x60; endpoint to add a syslog export rule.  * Added the &#x60;GET /syslog/export/{id}&#x60; endpoint to get a syslog export rule.  * Added the &#x60;PATCH /syslog/export/{id}&#x60; endpoint to update a syslog export    rule.  * Added the &#x60;DELETE /syslog/export/{id}&#x60; endpoint to delete a syslog export    rule.  * Added the &#x60;POST /syslog/export/test&#x60; endpoint to test a syslog export rule.  * Added stubs for the &#x60;GET /event/latest&#x60; endpoint to V1 to    facilitate a future migration from internal to V1.  * Added stubs for the &#x60;GET /event_series/{id}&#x60; endpoint to V1    to facilitate a future migration from internal to V1.  * Added stubs for the &#x60;GET /event&#x60; endpoint to V1 to facilitate    a future migration from internal to V1.  * Added optional query parameter &#39;snappableStatus&#39; to /vmware/vcenter,    /vmware/compute_cluster, /vmware/host,  /host, /mssql/instance, and    /windows_cluster. This parameter enables a user to fetch the set of    protectable objects from the list of objects visible to that user.  * Added optional field &#x60;alias&#x60; to HostSummary, HostRegister, and HostUpdate    schemas. This field will allow the user to specify an alias for each host    which can be used for search.  * Added &#x60;POST /archive/location/{location_id}/reader/refresh/data_sources&#x60;.    endpoint to refresh the metadata of a list of given data sources from    the given reader location.  * Added &#x60;POST /managed_volume/snapshot/export/{id}/script&#x60; endpoint to    generate a script to create a directory to view all files in all channels    of a managed volume snapshot export.  * Moved the &#x60;GET /blackout_window&#x60; endpoint from internal to V1.  * Moved the &#x60;PATCH /blackout_window&#x60; endpoint from internal to V1.  * Added &#x60;GET /certificate&#x60; endpoint to get all imported certificates.  * Added &#x60;POST /certificate&#x60; endpoint to import a certificate.  * Added &#x60;GET /certificate/{id}&#x60; endpoint to retrieve a certificate by id.  * Added &#x60;PATCH /certificate/{id}&#x60; endpoint to update a certificate.  * Added &#x60;GET /csr&#x60; endpoint to get all outstanding    Certificate-Signing-Requests.  * Added &#x60;POST /csr&#x60; endpoint to generate a Certificate-Signing-Request.  * Added &#39;DELETE /oracle/db/{id}/downloaded__snapshots&#39; endpoint    to delete downloaded Oracle db snapshots and log snapshots.  * Added unauthenticated endpoint &#x60;GET /saml/sso_status&#x60; to check    SAML SSO status. For example, we can check whether SSO is enabled or not.  * Added optional field archivalTieringSpec to ArchivalSpecV2 to support    archival tiering. This enables the user to configure either Instant Tiering    or Smart Tiering (with a corresponding minimum accessible duration) on an    SLA domain with archival configured to an Azure archival location.  * Updated endpoint /mssql/db to have a new optional query paramter,    indicating if backup task information should be included.  * Added the &#x60;IoFilterSummary&#x60; object with &#x60;id&#x60;, &#x60;name&#x60;, &#x60;version&#x60;, &#x60;vendor&#x60;.    fields and &#x60;summary&#x60;, &#x60;releaseDate&#x60; optional fields.  * Added &#x60;GET /vmware/computer_cluster/request/{id}&#x60; endpoint to get the details    of an asynchronous request that involves a VMware compute cluster.  * Added &#x60;PATCH /vmware/computer_cluster/{id}&#x60; endpoint to update    the configuredSlaDomainId for a VMware compute cluster with a specific ID.  * Added &#x60;GET /vmware/compute_cluster/{id}/io_filter&#x60; to get the ioFilters on    the VMware compute cluster with a specific ID.  * Added &#x60;POST /vmware/compute_cluster/{id}/install_io_filter&#x60; endpoint to    install the Rubrik ioFilter to the VMware compute cluster with a specific    ID.  * Added &#x60;POST /vmware/compute_cluster/{id}/uninstall_io_filter&#x60; endpoint to    uninstall the Rubrik ioFilter from the VMware compute cluster with a    specific ID.  * Added &#x60;POST /vmware/compute_cluster/{id}/upgrade_io_filter&#x60; endpoint to    upgrade the Rubrik ioFilter to the latest version for the VMware compute    cluster with a specific ID.  * Moved the &#x60;GET /vmware/compute_cluster&#x60; endpoint from internal to V1.  * Moved the &#x60;GET /vmware/compute_cluster/{id}&#x60; endpoint from internal to V1.  * Added endpoint /saml/authn_request/{idp_name} for making SAML  * Added an optional field &#39;isRetentionLocked&#39; to &#39;POST /sla_domain&#39;,    &#39;PUT /sla_domain/{id}&#39; and &#39;PATCH /sla_domain/{id}&#39; to allow users to manage    the Retention Lock capabilities of an SLA Domain.  * Added endpoint &#39;POST /saml/authn_request/{idp_name}&#39; for making SAML    authentication request for a given ID Provider.  * Added endpoint &#39;POST /saml/rubrik_metadata&#39; for downloading Rubrik SAML    metadata file.  * Added a series of new endpoints /idp_auth_domain for managing SAML    Id Provider integration.  * Moved the &#39;connectionStatus&#39; field from VcenterDetail to VcenterSummary.  * Added new optional query parameters &#39;data_sources&#39; and &#39;snapshot_ids&#39; to    &#39;GET /sla_domain&#39; endpoint. This allows users to filter SLA Domains based    on whether they can be assigned to specified data sources and snapshots.  * Changed the existing endpoints &#x60;GET /mssql/db/&#x60; &#x60;GET /mssql/instance&#x60;.    &#x60;GET /mssql/db/{id}&#x60; &#x60;PATCH /mssql/db/{id}&#x60; &#x60;GET /mssql/db/snapshot/{id}&#x60;.    &#x60;GET /mssql/instance/{id}&#x60; &#x60;GET /mssql/instance/{id}&#x60; to return an    unprotectable reason as a string in the &#39;unprotectableReason&#39; field instead    of a JSON struct.  * Added a &#x60;PUT /host/certificate/{id}&#x60; endpoint to update the    certificate of the given host  * Added &#x60;GET /vcd/vapp/template/snapshot/{snapshot_id}/export&#x60; to get    available options for a vApp template snapshot export.  * Added &#x60;POST /vcd/vapp/template/snapshot/{snapshot_id}/export&#x60; to queue    export of a vApp template snapshot.  * Added continuous data protection state for each VMware virtual machine.  * Added optional field &#39;isIoFilterInstalled&#39; to vCenter summary. Returns true    if any Rubrik IO filters are installed on any compute clusters that are    a part of the vCenter.  * Added optional field &#x60;cloudStorageTier&#x60; to &#x60;BaseSnapshotSummary&#x60;, to indicate    the current storage tier of the archived copy of a snapshot.  * Added &#x60;POST &#x60; /vmware/vm/cdp endpoint to get live CDP info for a list of    virtual machines.  * Added &#x60;POST &#x60; /vmware/vm/cdp_state endpoint to get CDP state info for a list    of virtual machines.  * Added the optional field isEffectiveSlaDomainRetentionLocked to    FilesetSummary. The field is a Boolean that specifies whether the effective    SLA Domain of a fileset is retention locked.  * Added optional field isEffectiveSlaDomainRetentionLocked to &#x60;Snappable&#x60;.    The parameter depicts if the effective SLA domain for the data source is    a Retention Lock SLA Domain.  * Added optional field isConfiguredSlaDomainRetentionLocked to SlaAssignable.    The parameter depicts if the configured SLA domain for the object is a    Retention Lock SLA Domain.  * Added optional parameter &#x60;ignore_connection_status&#x60; to &#x60;GET /vmware/vcenter&#x60;.    to skip calculating connection status.  * Added required fields: isCdpEnabled(type: boolean) and cdpState(type:    CdpState Enum) to VirtualMachineDetails.  * Moved the GET &#x60;/mssql/hierarchy/{id}/descendants&#x60; and    GET &#x60;/mssql/hierarchy/{id}/children&#x60; endpoints from internal to v1.    Added the &#x60;is_relic&#x60;, &#x60;is_live_mount&#x60; &#x60;is_clustered&#x60;, and    &#x60;is_log_shipping_secondary&#x60;.    parameters. Changed acceptable values of &#x60;object_type&#x60; and &#x60;sort_by&#x60;.    parameters. Added &#x60;hasPermissions&#x60;, &#x60;isInAvailabilityGroup&#x60;,    &#x60;descendantSlaDomains&#x60;, &#x60;instanceChildren&#x60;,    &#x60;unprotectableReasons&#x60;, &#x60;isLiveMount&#x60;, &#x60;isLogShippingSecondary&#x60;,    &#x60;hostStatus&#x60;, &#x60;cbtEnabled&#x60;, &#x60;cbtEffectiveStatus&#x60;, &#x60;isClustered&#x60; and    &#x60;clusterInstanceAddress&#x60; fields in the    response object. Removed &#x60;replicaCount&#x60; field in the response object.    Added support for returning non-availability databases.    Changed &#x60;object_type&#x60; query parameter to take a comma-separated list of    object types.    Added the GET &#x60;/mssql/hierarchy/{id}&#x60; endpoint to get a specific hierarchy    object.  * Added the POST &#x60;/mssql/sla_domain/assign&#x60; endpoint to assign SLA properties    to SQL Server objects.  * Added isRetentionLocked to MssqlInstanceSummary.   ### Changes to V1 API in Rubrik Version 5.0.3  ## Deprecation:   ## New features and improvements:  * Added a new optional field &#39;oracleQueryUser&#39; to HostRegister, HostUpdate    and HostDetail objects, for setting the Oracle username for account with    query privileges on the host. This applies the following endpoints:    POST /host/bulk, PATCH /host/{id}, and GET /host/{id}.   ### Changes to V1 API in Rubrik Version 5.0.2  ## Deprecation:   ## New features and improvements:  * Added &#x60;GET /oracle/db/{id}/restore_estimate&#x60; endpoint to provide an    estimate of the amount of data that must be downloaded for a restore    operation.  * Introduced optional field &#x60;logicalSize&#x60; to &#x60;VirtualMachineDetail&#x60;. This    field gives the sum of logical sizes of all the disks in the virtual    machine.  * Added optional parameter &#x60;ignore_connection_status&#x60; to    &#x60;GET /vmware/vcenter/{id}&#x60;. Set this parameter to skip calculating    connection status.   ### Changes to V1 API in Rubrik Version 5.0.1  ## Deprecation:   ## New features and improvements:  * Added &#x60;GET /cluster/{id}/security/encryption&#x60; endpoint to provide encryption    at rest status of the cluster.  * Added &#x60;GET /vmware/host/{id}/datastore&#x60; endpoint to get the details    of datastores for an ESXi host.  * Added &#x60;POST /vmware/vm/mount/{id}/relocate&#x60; endpoint to migrate datastore    for a virtual machine from Live Mount or Instant Recovery.  * Added &#x60;America/Santiago&#x60;, &#x60;Australia/Adelaide&#x60; and &#x60;Australia/Brisbane&#x60; as    supported cluster time zones.   ### Changes to V1 API in Rubrik Version 5.0.0  ## Deprecation:  * Deprecating query paramter &#x60;hostname&#x60; of &#x60;GET /host&#x60; and response property    &#x60;hostname&#x60; of &#x60;GET /host&#x60;, &#x60;POST /host&#x60;, &#x60;PUT /host/certificate/{id}&#x60;,    &#x60;GET /host/{id}&#x60;, &#x60;PATCH /host/{id}&#x60;, and &#x60;POST /host/{id}/refresh&#x60;.    Use &#x60;name&#x60; instead. Support for &#x60;hostname&#x60; is present in v1 and removed in v2.  * Deprecating response property &#x60;isArchived&#x60; of &#x60;GET /mssql/db&#x60;,    &#x60;GET /mssql/db/{id}&#x60;, and &#x60;PATCH /mssql/db/{id}&#x60;. Use    &#x60;isDeleted&#x60; instead. Support for &#x60;isArchived&#x60; is present in v1 and removed in v2.  * Deprecating parameter &#x60;datastoreName&#x60; of &#x60;Post /vmware/vm/snapshot/{id}/mount&#x60;.   ## New features:  * Added a new PUT endpoint to /ldap_service/{id}.  * Added /cluster/{id}/snmp_mib_link endpoint.  * Added a new optional field &#39;oracleSysDbaUser&#39; to /host/{id} POST endpoint    during register host for setting the Oracle username for account with sysdba    privileges on this host.  * Added a new optional field &#39;oracleSysDbaUser&#39; to /host/{id} endpoint for    changing the Oracle username for account with sysdba privileges on this    host.  * Added a new optional field &#39;mfaServerId&#39; to /ldap_service endpoint for    associating a configured MFA server.  * Added a new /sla_domain endpoint with the same functionality as /v1, but    added support for weekly and quarterly time units and modify the config of    monthly and yearly.  * Added a new optional field &#39;isArrayEnabled&#39; to &#39;FilesetTemplateCreate&#39;    for creation of storage array-enabled fileset templates. We also include    this new field in &#39;FilesetTemplateDetail&#39;.  * Added a new optional field &#39;arraySpec&#39; to &#39;FilesetCreate&#39; for    creation of storage array-enabled filesets. We also include    this new field in the responses of the &#x60;GET /fileset/{id}&#x60; and    &#x60;GET /fileset&#x60; endpoints.  * Added ability to use the /host/{id} endpoint to specify a host level    setting for enabling or disabling CBT backups of SQL Server databases,    along with new optional fields &#39;mssqlCbtEnabled&#39;, &#39;mssqlCbtEffectiveStatus&#39;    and &#39;mssqlCbtDriverInstalled&#39;.  * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster    to remove the CBT driver from a Windows host that has CBT backups of SQL    Server databases disabled.  * Added new optional field &#39;isPassthrough&#39; to &#39;POST /fileset&#39; endpoint to    indicate if we want to take a direct archive backup.  * Added a new field unprotectable_reasons to GET /mssql/db/{id} and    GET /mssql/instance/{id}. This field keeps track of the reasons that a    SQL Server database or instance cannot be protected by Rubrik.  * Added ability to use the /host/{id} endpoint to specify a host level    setting for enabling or disabling VFD backups of volumes on Windows hosts.  * Added ability to use the /host/{id} endpoint to instruct the Rubrik cluster    to remove the VFD driver from a Windows host that has VFD backups of volumes    disabled.  * Added new optional field &#39;isOverwrite&#39; to ExportMssqlDbJobConfig for    &#39;POST /mssql/db/{id}/export&#39; endpoint to enable overwriting an existing    database while using the export operation.  * Added a new optional field &#39;allowOverwrite&#39; to the    &#39;POST /mssql/db/{id}/export&#39; endpoint to allow overwriting an existing    database during the export.  * Added a new field &#39;hasAttachingDisk&#39; to &#39;GET /vmware/vm/snapshot/mount&#39; and    &#39;GET /vmware/vm/snapshot/mount/{id}&#39; that indicates to the user whether    this is an attaching disk mount job.  * Added a new field &#39;attachingDiskCount&#39; to &#39;GET /vmware/vm/snapshot/mount&#39;    and &#39;GET /vmware/vm/snapshot/mount/{id}&#39; that indicate to the user how many    disks are attached.  * Removed optional field &#39;clusterInstanceAddress&#39; from    &#39;PATCH /mssql/instance/{id}&#39; endpoint since host-centric discovery for    cluster instances eliminates the need to edit the instance address.  * Added new field &#x60;missedSnapshotTimeUnits&#x60; in &#x60;MissedSnapshot&#x60;.  * Added new field &#39;vmxFileContent&#39; in getSnapshotDetail  * Added new optional fields &#39;organizationId&#39; and &#39;organizationName&#39; to    &#x60;/host/{id}&#x60; and &#x60;/host&#x60; endpoints to get the organization a host is    assigned to due to Envoy.  * Added new field &#39;vmwareTagList&#39; in getSnapshotDetail  * Added new endpoint GET /cluster/{id}/certificate to get the cluster cert.  * Added new optional field PATCH /vmware/vm/{id} to indicate whether or not    to refresh the in-memory cache after updates to a virtual machine record.  * Added new field &#39;shouldRecoverTags&#39; in MountSnapshotJobConfigV1  * Added new field &#39;shouldRecoverTags&#39; in InstantRecoveryJobConfig  * Added new field &#39;shouldRecoverTags&#39; in ExportSnapshotJobConfig  * Added a new optional field &#39;operating_system&#39; to &#39;GET /host&#39;.  * Added a new optional field &#39;apiEndpoint&#39; to &#39;NasBaseConfig&#39;.  * Added new optional field &#39;enableSymlinkResolution&#39; to FilesetSummary in    &#39;POST /fileset&#39;, \&quot;GET /fileset\&quot; and \&quot;PATCH /fileset/{id}\&quot; endpoints to    indicate if we want to resolve symlinks during metadata scan.  * Added new optional field &#39;enableHardlinkSupport&#39; to FilesetSummary and    FilesetCreate in &#39;POST /fileset&#39;, \&quot;GET /fileset\&quot; and \&quot;PATCH /fileset/{id}\&quot;    endpoints to enable recognition and deduplication of hardlinks in    fileset backup.   ## Improvements:  * Added optional &#39;apiToken&#39; and &#39;apiEndpoint&#39; fields to NasConfig to support    Pure FlashBlade devices.  * Added a new field &#39;guestOsName&#39; to GET /vmware/vm. This allows users to    filter virtual machines based on the guest operating system name.  * Enhanced GET /vmware/vm/snapshot/{id} response by adding disk details    such as fileName and deviceKey.  * Added isMountAllowed field to the response of GET    /mssql/db/{id}/recoverable_range. This helps identify which recoverable    ranges support Live Mount, which is affected by whether a database snapshot    contains filestreams.  * Added optional query parameters limit and offset to support pagination for    GET /mssql/db endpoint.  * Added optional query parameters sortOrder and sortBy to enable users to    sort the results of GET /mssql/db endpoint by effectiveSlaDomainId and name.   ### Changes to V1 API in Rubrik Version 4.2  ## Breaking changes:  * The input field OperatingSystemType value &#x60;Linux&#x60; is replaced by &#x60;UnixLike&#x60;.    in FilesetTemplateCreateDefinition, used by POST /fileset-template, and    in FilesetTemplatePatchDefinition, used by PATCH /fileset_template/{id}.  * The input field operating_system_type value &#x60;Linux&#x60; is replaced by &#x60;UnixLike&#x60;.    in GET /fileset-template and GET /host.   ## New features:  * Added a new /ldap_service endpoint for managing Active Directory integration.  * Added a new optional field &#39;nasBaseConfig&#39; to GET /api/v1/host. This field    allows NAS (Isilon/NetApp) api credential to be displayed and edited.  * GET /host/{id}/search now returns search results for filesets, Windows volume    groups, and storage array volume groups belonging to the host. Previously,    the endpoint would only return fileset search results.  * Added endpoints for actions related to log shipping configurations:    POST /mssql/db/{id}/log_shipping to create, GET /mssql/db/log_shipping to    query, GET /mssql/db/log_shipping/{id} to retrieve individual details,    DELETE /mssql/db/log_shipping/{id} to delete, and POST    /mssql/db/log_shipping/{id}/reseed to reseed an unhealthy secondary    database.  * Added &#x60;Africa/Johannesburg&#x60;, &#x60;Africa/Lagos&#x60; and &#x60;Africa/Nairobi&#x60; as    supported cluster time zones.  ## Improvements:  * Added 2 new optional fields &#x60;apiHostname&#x60; and &#x60;zoneName&#x60; to POST /host    and GET /host. These fields allow different zones to be configured for    Isilon NAS.  * Added a new field &#39;geolocation&#39; to GET /cluster/{id} and PATCH /cluster/{id}.    These allow users to view and modify the geolocation of the cluster,    respectively.  * Added a new field &#x60;guestOsType&#x60; to the &#x60;VirtualMachineDetail&#x60;.    object used in response of &#x60;GET /vmware/vm/{id}&#x60;.  * Added an optional organizationId field to the HostRegister request in POST    /host to allow users with the global admin RBAC role to add a host to an    organization specified by the value of the organizationId field.  * Added canLiveMount field to the responses of &#x60;GET /mssql/db/snapshot/{id}&#x60;.    and &#x60;GET /mssql/db/{id}/snapshot&#x60;.  * Added an optional field &#x60;agentStatus&#x60; to &#x60;VirtualMachineSummary&#x60; object used    in response of &#x60;GET /vmware/vm&#x60; endpoint. This allows user to check the    Rubrik Backup Service connection status of the corresponding VMware VM.  * Added the &#x60;POST /vmware/vm/{id}/register_agent&#x60; endpoint.  * Added a new field &#39;createDatastoreOnly&#39; to POST    /vmware/vm/snapshot/{id}/mount. This allows user to mount snapshot to vmware    datastore only, without create a virtual machine.  * Added a new field &#x60;numWindowsVolumeGroups&#x60; to the &#x60;SlaDomainDetail&#x60; and    &#x60;SlaDomainSummary&#x60; objects used in response to &#x60;GET /sla_domain&#x60; endpoints.  * Added new optional field &#39;shouldRefreshCacheAfterUpdate&#39; for PATCH    /vmware/vm/{id} to indicate whether or not to refresh the in-memory cache    after updates to a virtual machine record.   ### Changes to V1 API in Rubrik Version 4.1   ## Breaking changes:  * The &#39;allowedBackupWindow&#39; and &#39;firstFullBackupWindow&#39; input field for    /sla_domain now take the cluster time zone instead of UTC.   ## New features:  * Added POST /host/{id}/refresh endpoint to refresh hosts without    registering them again  * Added GET /fileset/snapshot/{id} endpoint to retrieve details of a    fileset snapshot.  * Added POST /mssql/db/{id}/log_backup endpoint for taking on-demand    log backup of SQL Server databases.  * Added a new optional query parameter &#39;is_agentless&#39; to    GET /windows_cluster. This allows users to filter all clusters that    do not have any hosts with Rubrik connectors installed. If this    parameter is omitted, all clusters are returned.  * Added a new field &#39;isAgentless&#39; to GET /windows_cluster. This indicates    whether all the hosts on this windows cluster do not have Rubrik connector    installed. If even one host has Rubrik connector installed, this will    be set to false.  * Added a new optional &#39;organization_id&#39; query parameter on POST /session.    This allows users to specify the organization to which they intend to    authenticate. If this parameter is omitted, an organization is chosen    automatically.  * Added a new &#39;organizationId&#39; field to the response on POST /session. This    indicates the organization to which the user has authenticated.  * Added a new field &#39;moid&#39; on GET /vmware/vm. This allows users to search    VMWare VMs by Managed Object ID. The list of results of the call can now    additionally be sorted in ascending/descending order by moid.  * Added new fields &#39;replicas&#39; and &#39;availabilityGroupId&#39; on GET /mssql/db    and GET /mssql/db/{id}. If a database is an availability database,    it will have some number of replicas, which are copies of the database    running on different instances. Otherwise, there will only be one    replica, which represents the single copy of the database. The field    &#39;availabilityGroupId&#39; will be set only for availability databases    and points to the availability group of the database. Also deprecated    several fields on these endpoints, as they should now be accessed via    the &#39;replicas&#39; field.  * Added a field &#39;cloudInstantiationSpec&#39; on GET /vmware/vm and PATCH    /vmware/vm/{id} to allow enabling/disabling/updating specs for automatic    conversion to cloud image on a per VM basis  * Added a new optional query parameter &#39;availabilityGroupId&#39; to GET /mssql/db,    in order to filter databases by their availability group ID.  * Added a new field &#39;timezone&#39; to GET /cluster/{id} and PATCH /cluster/{id}.    These calls show and change, the current time zone setting of the cluster.  * Add a new field &#39;ignoreErrors&#39; to POST /vmware/vm/snapshot/{id}/restore_file    that will let job to ignore file errors during restore jobs.  * Added &#x60;Asia/Kolkata&#x60; and &#x60;Asia/Kathmandu&#x60; as supported cluster time zones.   ### Changes to V1 API in Rubrik version 4.0   New features:  * Added a new field &#39;name&#39; on GET /sla_domain. This allows users to search    SLA Domains by name. Users can also sort the SLA Domain summary results    in ascending/descending order by name  * The Rubrik cluster generates a unique ID for each virtual machine when a    vCenter Server is added. When a virtual machine changes to another vCenter    Server or unregisters and registers with the same vCenter Server, a new    unique ID is generated for that virtual machine. When this happens, the    virtual machine object associated with the original ID becomes a relic.    In this release we have added the option conflictResolutionAuthz to    add/edit vCenter endpoints of the Rubrik REST APIs. This option can take    either &#39;AllowAutoConflictResolution&#39; to authorize the linking of relic    virtual machine objects with the current virtual machine object of a    specific virtual machine, and makes the collective snapshot history    available through the current object. Or it can take &#39;NoConflictResolution&#39;    to not allow linking. Default value is &#39;NoConflictResolution&#39;.  * Introduced endpoints for SQL Server Live Mounts: POST /mssql/db/{id}/mount,    GET /mssql/db/mount, GET /mssql/db/mount/{id}, and    DELETE /mssql/db/mount/{id}. These allow users to create, query for, and    delete Live Mounts for SQL Server databases.  * Added the isLiveMount field to the response of GET /mssql/db. Added an    optional is_live_mount query parameter to filter by this field.  * Added links field to the paginated responses of    GET /vmware/vm, /vmware/vm/mount and /fileset endpoints. This allows users    to navigate between pages by following the href in links.prev and links.next.  * Introduced optional caCerts parameter for the vCenter post/put/patch    endpoints to specify trusted CA certs to use when connecting to a vCenter    server and associated ESX hosts.  * Modified PATCH /mssql/instance/{id} endpoint to support SQL db    auto-protection, added fields configuredSlaDomainId,    logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the PATCH    request, as well as configuredSlaDomainId, configuredSlaDomainName,    logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the GET and    PATCH responses.  * Added GET /vmware/vcenter/{id} endpoint to allow fetching details of a    single vCenter server, including its refresh and delete status.  * Introduced optional parameter keepMacAddresses to    POST /vmware/vm/snapshot/{id}/mount, /vmware/vm/snapshot/{id}/export, and    /vmware/vm/snapshot/{id}/instant_recovery endpints.    This allows new VMs to have the same MAC address as their source VMs.  * Introduced optional parameters offset and limit to support    pagination for Browse end-point.  * Added &#x60;nodeId&#x60; to &#x60;AsyncRequestStatus&#x60; to improve debugging job failures.    ### Changes to V1 API in Rubrik version 3.2   New features:  * Added an option to preserve the virtual machine moid during instant recovery.    Use this option cautiously. It will permanently overwrite the source    virtual machine. The source virtual machine cannot be recovered if the    operation fails. It will not create a new virtual machine and rename    the original one so we could fall back to the original in case of a failure    in the process. This is not exposed in the Web UI and the API user should    be careful to not destroy the original virtual machine by accident.  * Introduced shareId into /fileset endpoints to support    the creation of filesets based on network shares.  * Introduced optional config parameter for all on demand    snapshot endpoints. The config parameter includes an optional slaId field.    The policies of the specified SLA Domain determine the retention of backups    on the local Rubrik cluster, the retention target, and the archival location.  * Introduced optional parameters to endpoint /mssql/db/{id}/export,    so that physical filenames and logical filenames can be changed    for exported databases. These two parameters are newFilename and    newLogicalName.  * Introduced optional config parameter for the VM patch endpoint    (PATCH /vmware/vm/{id}) to specify a guest credential for a    specific VM.  * Introduced optional query parameters to endpoint /host, to    support infix searching by hostname and sort order of results.  * Introduced slaId and slaName field to all snapshot summary/details object.    These fields specify the SLA Domain object that is associated with the    snapshot.  Bug Fixes:  * Made path parameter required in GET /fileset/snapshot/{id}/browse    and GET /vmware/vm/snapshot/{id}/browse. Previously, an error was    thrown when path wasn&#39;t passed in. This solves that bug.   ### Changes to V1 API in Rubrik version 3.1  Initial GA release  # Overview # The Rubrik REST API provides a means to work with Rubrik clusters and Rubrik Edge virtual appliances using text-based representations of the resource objects that are managed by the Rubrik software.  In its simplest form, the RESTful architecture used by the Rubrik REST API has the following workflow: 1. Client authenticates with the Rubrik REST API server and starts a session. 2. Client sends an HTTP request to the URI for a resource object. 3. Server handles the request and sends an HTTP response with a JSON formatted response body.  This overview section provides a basic description of the HTTP requests and responses used with the Rubrik REST API. The [Authentication](#section/Authentication) section provides information about how a client authenticates with the Rubrik REST API server.  ## Documentation conventions  The descriptions in this documentation use &#39;Rubrik cluster&#39; to refer to both Rubrik clusters and Rubrik Edge virtual appliances.  The documentation uses a dollar symbol to indicate a variable in body text and code samples. Some examples: * &#x60;$cluster_address&#x60; to represent a Rubrik cluster IP or resolvable host name * &#x60;$snapshot_id&#x60; to represent the ID of a specific snapshot * &#x60;$request_id&#x60; to represent the ID of a specific asynchronous request  To shorten the path shown in a code sample, the documentation sometimes replaces a longer variable form with the variable form &#x60;{id}&#x60;. This variable form represents the &#x60;id&#x60; value for an associated member string in a response body or request URL.  The documentation use the term &#39;snappable&#39; to refer to all objects that have data that can be protected by a Rubrik cluster or a Rubrik Edge appliance. For example, all of the following are &#39;snappables&#39;: * Virtual machines * File systems * SQL Server databases  ## Versioning  The Rubrik REST API structures the request URL to include the version of the API. This ensures that backwards incompatible improvements in a new version are not unintentionally used with an earlier version of the API.  The URL of a request includes a segment that identifies the version of the API. In the URL, the version segment always follows immediately after the Rubrik REST API server name or IPv4 address.  For example, for a Rubrik cluster with the server address &#x60;$cluster_address&#x60; a request to the cluster endpoint for Rubrik REST API v1 would look like this: &#x60;https://$cluster_address/api/v1/cluster&#x60;  In this URL, the &#x60;v1&#x60; represents the version number for Rubrik REST API v1.  The Rubrik REST API increments the version number when the new version includes a change that is not backward compatible.  Examples of changes that are not backward compatible include: * Resource type removed * Required parameter added to an existing resource type * Required parameter removed from an existing resource type * Renamed resource or parameter * Authentication requirement added for a previously unauthenticated resource  When the Rubrik REST API has changes that are not backward compatible, those changes appear in a new version. For example, incompatible changes to v1 appear in v2. The Rubrik REST API server makes v2 endpoints available on the path: &#x60;https://$cluster_address/api/v2/&#x60;. The Rubrik REST API server continues to provide the v1 endpoints on the path: &#x60;https://$cluster_address/api/v1/&#x60;.  ### Changes within a version  Backward compatible changes can be added to the Rubrik REST API as part of an update of the Rubrik CDM software on a Rubrik cluster or Rubrik Edge appliance. When this occurs, the version number remains the same and the URL segment that identifies the API version does not change. The [Changelog](#section/Changelog) that is provided in the docs for each version of the Rubrik REST API describes the changes that are made within that version.  Examples of backward compatible changes include: * New API resource added * New optional request parameters added to existing resources * New properties added to existing responses  ## Architecture  The Rubrik REST API architecture centers around logical entities called *resource objects*. Resource objects can be discrete entities or can contain a hierarchy of other, dependent, resource objects. A dependent, or child, resource object is referenced through the parent object.  For example, a virtualization environment is a resource object that contains virtual machines as child resource objects. The virtual machines, in turn, contain snapshots as child resource objects. To address this hierarchy, the path to a snapshot must include the parent objects. As shown here those parent objects are the virtualization environment (&#x60;vmware&#x60;) and the virtual machine (&#x60;vm&#x60;): &#x60;/vmware/vm/snapshot&#x60;.  When a request addresses a specific resource object the path must include the  &#x60;id&#x60; of that specific object.  For example, to address a specific snapshot with the &#x60;id&#x60; value of &#x60;123-456&#x60; the path would be: &#x60;/vmware/vm/snapshot/123-456&#x60;.  The full URL for the request would be: &#x60;https://$cluster_address/api/v1/vmware/vm/snapshot/123-456&#x60;  The path in this example points to a specific snapshot with the &#x60;id&#x60; value of &#x60;123-456&#x60;.  The &#x60;id&#x60; is an opaque value which is generated by the Rubrik REST API. It does not follow any specific format.  ### API base path  Each endpoint in the Rubrik REST API exists on one of two possible base paths: * &#x60;https://$cluster_address/api/v1/&#x60; * &#x60;https://$cluster_address/api/internal/&#x60;  The &#x60;/api/v1&#x60; base path provides the most commonly used endpoints. Rubrik considers these endpoints to be stable. Rubrik designs new releases of the Rubrik REST API to provide as much backward compatibility for these endpoints as possible. After an upgrade to a new version of the Rubrik CDM software, or to a new version of the Rubrik REST API, existing calls to endpoints on the &#x60;/api/v1&#x60; base path will normally continue to work.  The primary purpose of the &#x60;/api/internal&#x60; base path is to provide endpoints that are used by the Rubrik cluster. These endpoints are *internal* in the sense that the Rubrik CDM software uses them to provide a wide variety of cloud data management features. The evolution and improvement of the Rubrik CDM software can cause changes to these endpoints, removal of these endpoints, or addition of new &#x60;/api/internal&#x60; endpoints. Rubrik does not attempt to make the &#x60;/api/internal&#x60; endpoints backward compatible.  ### Requests  To perform a task, the Rubrik REST API uses an HTTP request. Most requests perform one of these actions: * Get an instance of an object from a list * Add an instance of an object to a list * Perform an operation on an object using the &#x60;id&#x60; of the object.  The following table describes the HTTP method and endpoint excerpts for some typical HTTP requests.  **Note:** The endpoints shown here would be appended to the base URL: &#x60;https://$cluster_address/vmware&#x60;.  | Method | Endpoint | Description | | ------ | --- | ----------- | | GET | &#x60;/vm/snapshot&#x60; | Returns a list of snapshots. | | POST | &#x60;/vm/snapshot&#x60; | Creates a new snapshot resource object. | | GET | &#x60;/vm/snapshot/{id}&#x60; | Returns information about the snapshot that is identified by &#x60;id&#x60;. | | PATCH | &#x60;/vm/snapshot/mount/{id}&#x60; | Changes the power status of the mounted snapshot that is identified by &#x60;id&#x60;. | | PUT | &#x60;/vcenter/{id}&#x60; | Provides a request body with a complete update of the properties of the vCenter Server object that is identified by &#x60;id&#x60;. | | DELETE | &#x60;/vm/snapshot/{id}&#x60; | Deletes the snapshot that is identified by &#x60;id&#x60;. | | GET | &#x60;/vm/{id}/missed_snapshot&#x60; | Returns the value of &#x60;missed_snapshot&#x60; for a snapshot that is identified by &#x60;id&#x60;. | | POST | &#x60;/vm/snapshot/{id}/mount&#x60; | Performs a &#x60;mount&#x60; operation using the snapshot that is identified by &#x60;id&#x60;. |  #### Reserved ID alias  The alias &#x60;me&#x60; can be used with some endpoints as a shorthand replacement for the current, or local, value of that resource object type. For example, for the resource object type &#x60;/cluster&#x60; the alias &#x60;me&#x60; can be substituted for the &#x60;id&#x60; of the Rubrik cluster that is hosting the current session. For the resource object type &#x60;/session&#x60; the alias &#x60;me&#x60; can be substituted for the &#x60;id&#x60; of the current session.  In filters, use the alias &#x60;local&#x60; to refer to the Rubrik cluster that is hosting the current session.  #### Timestamp  The Rubrik REST API uses a timestamp to express all time values. The timestamp meets the standards of ISO 8601 and uses Coordinated Universal Time (UTC). Timestamps take the form: YYYY-MM-DDTHH:MM:SSZ, with YYYY for the four digit year value, MM for the two digit month value, DD for the two digit day of the month value, HH for the two digit hour value using a 24-hour clock, MM for the two digit minute value, and SS for the two digit second value. The T stands for time and the Z stands for Zulu time, another name for UTC.  **Example:** Timestamp in a JSON-formatted response body  &#x60;&#x60;&#x60;bash {   \&quot;createdTimestamp\&quot;: \&quot;2016-02-11T18:02:24Z\&quot; } &#x60;&#x60;&#x60;  ### Responses  The Rubrik REST API server responds to all requests by sending an HTTP response message. The response contains a status code and, when appropriate, a JSON object in the response body.  #### Status codes  The Rubrik REST API server includes an HTTP status code with every response. The following table describes the status codes supported by the Rubrik REST API server.  | Status code | Description | | ----------- | ----------- | | 200&amp;nbsp;OK | Request succeeded. Not used for a DELETE request, or for a POST request that creates a resource. | | 201&amp;nbsp;Created | POST request to create a resource object succeeded. | | 202&amp;nbsp;Accepted | Request was successfully accepted for further processing. | | 204&amp;nbsp;No&amp;nbsp;Content | Request succeeded and the response body is empty. Used for successful DELETE requests and for successful POST requests that do not return content. | | 400&amp;nbsp;Bad&amp;nbsp;Request | Request failed because it was malformed. The request may be garbled, or it may be missing required parameters. | | 401&amp;nbsp;Unauthorized | The requestor has insufficient authorization to perform the requested action. | | 403&amp;nbsp;Forbidden | The requested action is blocked in the current context. | | 404&amp;nbsp;Not&amp;nbsp;Found | The request references a resource object that is unknown to the Rubrik REST API server. | | 415&amp;nbsp;Unsupported Media Type | The HTTP header of the request specifies a media type that is not supported by the Rubrik REST API server. | | 422&amp;nbsp;Unprocessable Entity | The request specifies a correct media type and contains correct syntax but cannot be processed because of semantical errors. | | 500&amp;nbsp;Internal Server Error | The Rubrik REST API server encountered an unhandled error. | | 503&amp;nbsp;Service Unavailable Error | The Rubrik REST API server is temporarily unavailable. |  #### Response body  The JSON object included in a response body can contain members (&#x60;{string : value}&#x60;) and arrays (&#x60;[elements]&#x60;). Also, members and arrays can be nested within members and arrays.  When a response includes a resource object, the object always includes an &#x60;id&#x60; member in the form &#x60;id : $id&#x60;. The value of the &#x60;id&#x60; member is the unique ID of the resource.  When a response includes a large array (or list) of elements, the Rubrik REST API server encloses the array in a &#x60;ListResponse&#x60; structure. The &#x60;ListResponse&#x60; structure breaks a lengthy array into &#39;pages&#39; of information to make the information easier to manage. Refer to &#39;Working with lists&#39; for information about managing arrays with large numbers of values.  #### Status code 400 responses  The Rubrik REST API server sends a response containing the HTTP status code &#39;400 Bad Request&#39; when the server cannot process the request. This can be caused by malformed request syntax, invalid request message framing, or deceptive request routing.  The Rubrik REST API server returns a &#39;400 Bad Request&#39; when: * Request does not conform with the format specified in OpenAPI definition files. For example, the request is missing required fields. * Request is malformed. For example, the request has a malformed &#x60;id&#x60;. * Request contains unsupported &#x60;enum&#x60; values.  #### Status code 422 responses  The Rubrik REST API server sends a response containing the HTTP status code &#39;422 Unproccessable entity&#39; when the request is syntactically correct but has semantic errors.  For example, when a request refers to an archival location that is not available. Although the request is properly formed, the Rubrik REST API server cannot act on the request because of the missing archival location, and the server returns &#39;422 Unproccessable entity&#39;.  The Rubrik REST API server also returns &#39;422 Unproccessable entity&#39; when invalid credentials are submitted during login. In that situation, the request may be correctly formed but the action cannot be completed by using the supplied values.  The following table describes the members of a &#39;422 Unproccessable entity&#39; response object.  | Member | Optional | Description | | ------ | --- | ----------- | | &#x60;type&#x60; | No | Error category. Possible values include: vcenter_error, oracle_error, rubrik_error | | &#x60;message&#x60; | No | Plain text explanation of the cause of the error. | | &#x60;code&#x60; | Yes | A short text string representing the cause of the error. | | &#x60;param&#x60; | Yes | The request member that is the source of the error, such as &#x60;backup_window&#x60;. |  ## Working with lists  When a request returns a large list of elements, the response array can be encapsulated within a &#x60;ListResponse&#x60; object. The &#x60;ListResponse&#x60; object is a pagination structure for the elements in the response array. The &#x60;ListResponse&#x60; object allows the response array to be addressed through smaller subsets of the array, or &#39;pages&#39;.  To work with a &#x60;ListResponse&#x60; object, form a request that calls for a specific page of the results by specifying an offset value and a limit. The response includes the elements from the list starting at the offset value and continuing to the limit. When the limit is very large, or unspecified, the Rubrik REST API server returns as many elements as can be handled by the available memory.  The &#x60;ListResponse&#x60; object consists of the members described in the following table.  | Member | Optional | Description | | ------ | --- | ----------- | | &#x60;hasMore&#x60; | No | Indicates whether the array contains elements that are not provided by the current response. &#x60;true&#x60; if more elements are available for the original request and &#x60;false&#x60; if the last element is in the current response. | | &#x60;data&#x60; | No | An array of the requested elements. Can be all or some of the elements requested. The elements can be members, arrays, or objects. | | &#x60;total&#x60; | Yes | Total number of elements. | | &#x60;links&#x60; | Yes | When &#x60;hasMore&#x60; is true, provides a request URL for the next page of results. When appropriate, also provides a request URL for the previous page of results. The request URLs provided by &#x60;links&#x60; retain the query parameters from the original request. For example, a request URL would retain a value specified by &#x60;limit&#x60; and a value specified by &#x60;search&#x60;. The exception to this is the value specified by &#x60;offset&#x60;, which the Rubrik REST API server uses to specify next and previous pages. |  Control the contents of a &#x60;ListResponse&#x60; object by including the following optional query parameters with the original request: * &#x60;limit&#x60; Defines the maximum number of a elements to include in the &#x60;data&#x60; array of the response. Available memory may prevent the return of all elements for very large &#x60;limit&#x60; values. When that occurs, the response includes &#x60;\&quot;hasMore\&quot;: true&#x60;. * &#x60;offset&#x60; Index reference point to use when determining the elements to include in a response. Include the next element after the index number specified by &#x60;offset&#x60;. The default value is &#x60;0&#x60;, which means the list page that is provided in the response starts with first element in the list.  For example, if the total number of elements in response to a query are 100, and the request includes the following query parameters: &#x60;limit&#x3D;10&#x60; and &#x60;offset&#x3D;30&#x60;, then the response will include a list page with elements 31-40.  When the &#x60;ListResponse&#x60; object provides &#x60;next&#x60; and &#x60;prev&#x60;, use the URL specified by &#x60;next&#x60; to request the next page of elements or use the URL specified by &#x60;prev&#x60; to request the previous page of elements.  **Example:** Request for all snapshots from a Rubrik cluster  The initial request uses the query parameter &#x60;limit&#x3D;1&#x60;.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot?limit&#x3D;1\&quot; &#x60;&#x60;&#x60;  The response returns the first element and &#x60;\&quot;hasMore\&quot;: true&#x60; indicates that more than one snapshot meets the request.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;1\&quot;,       \&quot;name\&quot;: \&quot;Windows2012\&quot;     }   ],   \&quot;links\&quot;: {     \&quot;next\&quot;: {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot?limit&#x3D;1&amp;offset&#x3D;1\&quot;     }   } }  &#x60;&#x60;&#x60;  To obtain the next element, the request is reissued with the query parameters set to: &#x60;limit&#x3D;1&amp;offset&#x3D;1&#x60;. This could also be achieved by using the URL specified by &#x60;next&#x60; to request the next page.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot?limit&#x3D;1&amp;offset&#x3D;1\&quot; &#x60;&#x60;&#x60;  The response returns the second element in the array. Since there are elements before and after the element in the response, the &#x60;links&#x60; member contains both a &#x60;next&#x60; request URL and a &#x60;prev&#x60; request URL.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;2\&quot;,       \&quot;name\&quot;: \&quot;Windows2016\&quot;     }   ],   \&quot;links\&quot;: {     \&quot;prev\&quot;: {        \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot?limit&#x3D;1&amp;offset&#x3D;0\&quot;,       \&quot;rel\&quot;: \&quot;prev\&quot;     },     \&quot;next\&quot;: {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot?limit&#x3D;1&amp;offset&#x3D;2\&quot;,       \&quot;rel\&quot;: \&quot;next\&quot;     }   } } &#x60;&#x60;&#x60;  ## Asynchronous requests  The Rubrik REST API server uses asynchronous (async) API requests for tasks that take longer to run. By using async requests the Rubrik REST API server avoids blocking the requestor from performing other tasks while the async tasks run.  The response to an async request includes a task object in the response body. The following table describes the members of a task object.  | Member | Optional | Description | | ------ | --- | ----------- | | &#x60;id&#x60; | No |  ID assigned to the task.  | | &#x60;status&#x60; | No |  Status of the task: &#39;RUNNING&#39;, &#39;SUCCEEDED&#39;, &#39;CANCELED&#39;, or &#39;FAILED&#39;.   | | &#x60;error&#x60; | No | Message describing reason for canceled or failed task, or &#39;None&#39;. | | &#x60;startTime&#x60; | Yes | Timestamp when the Rubrik cluster schedules the task. | | &#x60;endTime&#x60; | Yes | Timestamp when the task ends. | | &#x60;progress&#x60; | Yes | Percentage of the task that is complete. | | &#x60;links&#x60; | No | Polling request array that provides information about how to poll the task. |  The following table describes the polling request array in the &#x60;links&#x60; member.  | Member | Optional | Description | | ------ | --- | ----------- | | &#x60;href&#x60; | No | URL to send requests to when polling the task. | | &#x60;rel&#x60; | No | Provides a value of &#39;self&#39; to indicate that the array refers to the resource represented by the parent JSON object. |  When an async task is completed the Rubrik REST API server adds a second array to the &#x60;links&#x60; member in the response that is sent. The second array provides information about how to request the result of the async task.  The following table describes the results array in the &#x60;links&#x60; member.  | Member | Optional | Description | | ------ | --- | ----------- | | &#x60;href&#x60; | No | URL to send a request to for the result of the task. | | &#x60;rel&#x60; | No | Provides a value of &#39;result&#39; to indicate that the array refers to the resource represented by the parent JSON object. |  **Example:** Starting a mount task and polling the task status  To initiate a mount operation, send a POST request to the mount endpoint. Include an object containing the details of the snapshot.  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns a task object for the mount operation. The task object describes the task status as &#39;RUNNING&#39; and provides the &#x60;links&#x60; member which contains the polling request array.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  Using the information provided in the task object, send a GET request to poll the task status.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;error\&quot;: \&quot;None\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  Continue to poll the task object until the status changes to &#39;SUCCEEDED&#39;.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot; &#x60;&#x60;&#x60;  When the task object status changes to &#39;SUCCEEDED&#39;, the &#x60;links&#x60; member of the request includes a results array that provides a URL for the task results.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot;,   \&quot;error\&quot;: \&quot;None\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/$mounted_vm_id\&quot;,       \&quot;rel\&quot;: \&quot;result\&quot;     }   ] } &#x60;&#x60;&#x60;  # OpenAPI The Rubrik REST API specification conforms to the OpenAPI 2.0 Specification. Tools that work with the OpenAPI 2.0 Specification can be used with the Rubrik REST API specification.  Development releases (pre-1.0) of the Rubrik REST API specification made reference to &#39;swagger&#39;. The previous release of the OpenAPI 2.0 Specification was named the Swagger 1.2 Specification.  Download the Rubrik REST API specification for your tools. [Download](./api-docs)  ## Rubrik REST API Explorer The Rubrik REST API Explorer is a browser-based API client hosted by the Rubrik cluster. The Explorer has the Rubrik REST API specification built in. You can use the Explorer to try out Rubrik REST API calls and view the responses.  **IMPORTANT:** The Explorer interacts with the Rubrik cluster through the API calls you make. Use care when making calls that modify or delete configurations and data.  To access the Rubrik REST API Explorer, click: [Rubrik REST API Explorer](./playground/)  # Authentication  The Rubrik REST API server requires that all API calls use the HTTPS protocol. To meet the security requirements of that protocol, the Rubrik REST API server uses a self-signed certificate. A Certificate Authority cannot validate a self-signed certificate. Configure client tools to ignore the certificate validation error.  The Rubrik REST API server requires authentication and authorization for each API call, except calls made to the following endpoints:  * [/cluster/me/version](#operation/getClusterVersion) * [/cluster/me/api_version](#operation/getClusterApiVersion)  ## Authentication session Rubrik REST API server authenticates a session using either of the following methods:  * BasicAuth * Token  The Rubrik REST API server requires that you use an authorized username and password for the Rubrik cluster. Usernames are managed by either the Rubrik cluster or by your LDAP service.  ### BasicAuth authentication  BasicAuth authentication uses the HTTP Basic Authentication method and requires you to include the user credentials with each API call. Since each API call made using the BasicAuth method is separately authenticated, you do not need to manage the session state. You also do not need to log out of a session, since this method does not create a session.  To use the BasicAuth method, provide the user credentials in the &#39;Authorization&#39; header of an API call.  Use the string &#x60;Basic&#x60; followed by the Base64 encoding of &#x60;&lt;username:password&gt;&#x60; as the user credentials, where &#x60;&lt;username:password&gt;&#x60; is the username for an Admin account on the host Rubrik cluster, a colon, and the account password.  **Example:** Using curl to retrieve a session ID  This example uses the local Admin username &#39;admin&#39; and the password &#39;pass&#39; to retrieve: a session ID, the Rubrik server software version, and the API version.  The curl command shown here takes &#x60;&lt;username:password&gt;&#x60;, adds &#39;Basic &#39; to the string, and Base64 encodes the result.   The command includes the following arguments:  * &#x60;-k&#x60; to bypass an alert about the self-signed certificate  * &#x60;-u&#x60; to flag the &#x60;&lt;username:password&gt;&#x60; string  * &#x60;-X&#x60; to flag the HTTP method &#x60;GET&#x60;  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X GET \&quot;https://$cluster_address/api/v1/cluster/me\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server returns the following response body. &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$cluster_id\&quot;,   \&quot;version\&quot;: \&quot;3.1.0\&quot;,   \&quot;apiVersion\&quot;: \&quot;1.0\&quot; } &#x60;&#x60;&#x60;  ### Token authentication  Token authentication creates a token at the beginning of a session and then uses that token to authenticate the API calls that are made during the session. The token remains valid for the session - normally 30 minutes after the last activity. You can close a session and invalidate the session token at any time by making a DELETE call to &#x60;/session/{id}&#x60; where &#x60;{id}&#x60; is the session ID or &#x60;me&#x60; for the current session ID.  **Example:** Token authentication in a session  This example uses the local Admin username &#39;admin&#39; and the password &#39;pass&#39;. To open a session, first use the [BasicAuth](#section/BasicAuth) method to authenticate a POST call to [/session](#operation/createSession).  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X POST \&quot;https://$cluster_address/api/v1/session\&quot; &#x60;&#x60;&#x60;  The response body includes an array with the session token.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$session_id\&quot;,   \&quot;token\&quot;: \&quot;$token_id\&quot;,   \&quot;userId\&quot;: \&quot;$user_id\&quot; } &#x60;&#x60;&#x60; For all subsequent calls during the session, include the token in the Authorization header using the form: &#x60;Authorization: Bearer $token_id&#x60; where &#x60;$token_id&#x60; is the value of the &#x60;token&#x60; member from the response array.  In this curl command, the GET request to [/cluster](#operation/getPublicClusterInfo) uses &#x60;-H&#x60; to provide the &#x60;Authorization: Bearer $token_id&#x60; value.  &#x60;&#x60;&#x60;bash curl -k -H \&quot;Authorization: Bearer $token_id\&quot; -X GET   \&quot;https://$cluster_address/api/v1/cluster/me\&quot; &#x60;&#x60;&#x60;  The response body contains an array with the session ID, the Rubrik cluster software version, and the API version.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$cluster_id\&quot;,   \&quot;version\&quot;: \&quot;3.1.0\&quot;,   \&quot;apiVersion\&quot;: \&quot;1.0\&quot; } &#x60;&#x60;&#x60;  To close the session and invalidate the session token, make a DELETE call to [/session](#operation/deleteSession) using the value of the &#x60;id&#x60; key or use &#x60;me&#x60;. The alias &#x60;me&#x60; represents the session specified in the Authorization header.  &#x60;&#x60;&#x60;bash curl -k -H \&quot;Authorization: Bearer $token_id\&quot; -X DELETE   \&quot;https://$cluster_address/api/v1/session/me\&quot; &#x60;&#x60;&#x60;  ## LDAP Authentication  The Rubrik cluster can be integrated with an LDAP service for authentication. The API endpoints provide support for adding, updating and deleting a specific LDAP service as well as list all of the configured LDAP services.  ### Add a new LDAP service You can add a new LDAP service by making a POST call to [/ldap_service](#operation/createLdapService). Adding a new LDAP service requires information about the dynamic DNS name of the service, an administrative user who is authorized to create a computer user account as well as search for all the LDAP objects needed for use by the Rubrik cluster. The Rubrik cluster resolves the dynamic DNS name using DNS SRV records while honoring the advertised priority values.  **Example:** Adds a new LDAP service for use by the Rubrik cluster  This example adds an LDAP service that uses a dynamic DNS name of *example.com*, with a bind administrator user of *Administrator* with a password of *VerySafe*.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X POST -d &#39;{\&quot;dynamicDnsName\&quot;: \&quot;example.com\&quot;,   \&quot;bindUserName\&quot;: \&quot;Administrator\&quot;, \&quot;bindUserPassword\&quot;: \&quot;VerySafe\&quot;}&#39;   &#39;https://$cluster_address/api/v1/ldap_service&#39; &#x60;&#x60;&#x60;  The response body includes the ID associated with this LDAP service.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,   \&quot;domainType\&quot;: \&quot;AD\&quot;,   \&quot;name\&quot;: \&quot;example.com\&quot;,   \&quot;serviceAccount\&quot;: \&quot;cluster10-c8D7A54$\&quot;,   \&quot;initialRefreshStatus\&quot;: \&quot;ongoing\&quot; } &#x60;&#x60;&#x60;  The parameters associated with the LDAP service can be updated by making a PATCH request to [/ldap_service/{id}](#operation/patchLdapService) or a PUT request to [/ldap_service/{id}](#operation/putLdapService).  For example, you could add a prioritized list of authentication servers that supercede the LDAP servers advertised for the dynamic DNS name. These authentication servers can even be proxies that connect to the actual LDAP servers.  **Example:** Add two new LDAP services  This example adds two LDAP servers called ad-proxy1.example.com and ad-proxy2.cloud.example.com.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X PATCH -d &#39;{ \&quot;authServers\&quot;: [\&quot;ldap://ad-proxy1.example.com:389\&quot;, \&quot;ldap://ad-proxy2.example.com:389\&quot;]}&#39; https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd &#x60;&#x60;&#x60;  The response body confirms a successful update.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,   \&quot;domainType\&quot;: \&quot;AD\&quot;,   \&quot;name\&quot;: \&quot;example.com\&quot;,   \&quot;initialRefreshStatus\&quot;: \&quot;success\&quot; } &#x60;&#x60;&#x60;  ### List configured LDAP services You can get a listing of all the configured authentication domains using a GET request to [/ldap_service](#operation/queryLdapService).  **Example:** Get the list of LDAP services.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X GET &#39;https://$cluster_address/api/v1/ldap_service&#39; &#x60;&#x60;&#x60;  The response body will contain the ID of all the authentication realms.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,       \&quot;domainType\&quot;: \&quot;AD\&quot;,       \&quot;name\&quot;: \&quot;example.com\&quot;,       \&quot;serviceAccount\&quot;: \&quot;cluster10-c8D7A54$\&quot;,       \&quot;initialRefreshStatus\&quot;: \&quot;success\&quot;     },     {       \&quot;id\&quot;: \&quot;9fef084b-75f8-4c03-9efa-c73b55be5da8\&quot;,       \&quot;domainType\&quot;: \&quot;LOCAL\&quot;,       \&quot;name\&quot;: \&quot;local\&quot;,       \&quot;initialRefreshStatus\&quot;: \&quot;success\&quot;     }   ],   \&quot;total\&quot;: 2 }  &#x60;&#x60;&#x60;  ### Get information about a specific LDAP service  You can also get information about a specific LDAP service using a GET request to [/ldap_service/{id}](#operation/getLdapService).  **Example:** Get information about a configured LDAP service.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X GET   &#39;https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd&#39; &#x60;&#x60;&#x60;  The response body will contain information about the specified LDAP service.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,   \&quot;domainType\&quot;: \&quot;AD\&quot;,   \&quot;name\&quot;: \&quot;example.com\&quot;,   \&quot;serviceAccount\&quot;: \&quot;cluster10-c8D7A54$\&quot;,   \&quot;initialRefreshStatus\&quot;: \&quot;success\&quot; } &#x60;&#x60;&#x60;  ### Delete an LDAP service Any LDAP service that is configured to a Rubrik cluster can be removed by issuing a DELETE request to [/ldap_service/{id}](#operation/deleteLdapService).  **Example:** Remove an LDAP service  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X DELETE https://$cluster_address/api/v1/ldap_service/499aeb71-f114-45a5-8456-91b9f6c45ddd  &#x60;&#x60;&#x60;  ## LDAP domain authentication Scripts that automate calls to the Rubrik REST API endpoints must include one of the available authentication methods: the HTTP Basic method, the session method, or the API token method.  When the HTTP Basic method is used, and authentication is through an LDAP domain, issues can arise when the Rubrik cluster is configured with multiple LDAP domains. With this method, the authentication server first attempts to authenticate through the Rubrik cluster local domain. If that authentication attempt does not succeed, the authentication server attempts authentication with each available LDAP domain. If there are several LDAP domains configured, then this process can slow down authentication. With many LDAP domains, the authentication can potentially have too many failed logins and result in an account lock-out.  Although using the [API token for authentication](#token-authentication) is recommended for scripting, using the session authentication method will also avoid these issues. The following python script provides an example of how to use session authentication in a script. The method used in this example can be duplicated in other scripting languages to suit your scripting requirements.  &#x60;&#x60;&#x60; try:     sessionData &#x3D; None      session &#x3D; requests.Session()     session.auth &#x3D; ($username, $password)     session.verify &#x3D; False     session.headers &#x3D; {&#39;Content-type&#39;: &#39;application/json&#39;}     requests.adapters.HTTPAdapter()     session.mount(&#39;https://&#39;, requests.adapters.HTTPAdapter(pool_connections&#x3D;1))      # First, login to create a Web Session Token     loginData &#x3D; {        \&quot;initParams\&quot;: {            \&quot;organizationId\&quot;: $org_id         }     }     login &#x3D; session.post(     url&#x3D;&#39;https://{}/api/internal/session/realm/{}&#39;.format($RubrikCluster, $domain_display_name),     data&#x3D;json.dumps(loginData),     timeout&#x3D;300)     assert login.ok and &#39;session&#39; in login.json()     sessionData &#x3D; login.json()[&#39;session&#39;]     session.headers.update({&#39;Authorization&#39;: &#39;Bearer {}&#39;.format(sessionData[&#39;token&#39;])})     session.auth &#x3D; None      # Issue the desired request     cluster &#x3D; session.get(url&#x3D;&#39;https://{}/api/v1/cluster/me&#39;.format($RubrikCluster))     assert cluster.ok     print(&#39;Session Auth: {}&#39;.format(cluster.json()[&#39;name&#39;]))  finally:     if sessionData:         # Delete the web sessions explicitly. Rubrik CDM supports a         # limited number of sessions per user. Once this limit is exceeded,         # a random web session is discarded. This could log out the         # user from the UI or cause another script to fail.         logoutData &#x3D; {            \&quot;tokenIds\&quot;: [                sessionData[&#39;id&#39;]             ],             \&quot;userId\&quot;: sessionData[&#39;userId&#39;]         }         logout &#x3D; session.post(             url&#x3D;&#39;https://{}/api/internal/session/bulk_delete&#39;.format($RubrikCluster),             data&#x3D;json.dumps(logoutData),             timeout&#x3D;300)         assert logout.ok &#x60;&#x60;&#x60; Where:     * &#x60;$username&#x60; is the name of the user account to be authenticated.     * &#x60;$password&#x60; is the password associated with the username.     * &#x60;$org_id&#x60; is the ID of the organization representing the tenant.     * &#x60;$RubrikCluster&#x60; is the IPv4 address or resolvable hostname of        the Rubrik cluster.     * &#x60;$domain_display_name&#x60; is the name of the LDAP domain.  ## SAML ID Provider Authentication  The Rubrik cluster can be integrated with a SAML ID Provider authentication domain for authentication. The Rubrik REST API provides API endpoints for managing and configuring the ID Provider authentication domain with the Rubrik cluster. The Rubrik REST API also provides API endpoints for creating the SAML authentication request and handling the SAML authentication response.  ### Add a new SAML ID Provider Authentication Domain You can add a new ID Provider by making a POST call to [/idp_auth_domain](#operation/createIdProviderAuthDomain). Adding a new ID Provider requires the ID Provider metadata XML file in base64 encoding, and a human-friendly name for the ID Provider.  **Example:** Adds a new ID Provider for use by the Rubrik cluster  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X POST -d &#39;{\&quot;name\&quot;: \&quot;new-idp\&quot;,   \&quot;metadataXmlBase64\&quot;: \&quot;1VZbj6LYFn438T9UPI+mi7slpqsnm2sBQgm...\&quot;}&#39;   &#39;https://$cluster_address/api/v1/idp_auth_domain&#39; &#x60;&#x60;&#x60;  The response body includes the ID associated with this Active Directory.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,   \&quot;name\&quot;: \&quot;new-idp\&quot;,   \&quot;entityId\&quot;: \&quot;http://www.example.com/idp1\&quot;,   \&quot;ssoUrl\&quot;: \&quot;https://www.example.com/idp1/sso\&quot;,   \&quot;signCert\&quot;: \&quot;-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\&quot; } &#x60;&#x60;&#x60;  ### Update an existing SAML ID Provider Authentication Domain The name and metadata associated with the ID Provider can be updated by making a PATCH request to [/idp_auth_domain/{id}](#operation/updateIdProviderAuthDomain). This API call can update either of the two parameters.  **Example:** Update name of the ID Provider  This example update the name of ID Provider \&quot;new-idp\&quot; as \&quot;updated-idp\&quot;, and update metadata with new ID Provider \&quot;http://www.example.com/idp2\&quot;  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X PATCH -d &#39;{ \&quot;name\&quot;: \&quot;updated-idp\&quot;,   \&quot;metadataXmlBase64\&quot;: \&quot;1VZbj6AQwTIr4deKspU/zyR9fxqPPebgQ...\&quot;}&#39;   &#39;https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd&#39; &#x60;&#x60;&#x60;  The response body confirms a successful update.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,   \&quot;name\&quot;: \&quot;updated-idp\&quot;,   \&quot;entityId\&quot;: \&quot;http://www.example.com/idp2\&quot;,   \&quot;ssoUrl\&quot;: \&quot;https://www.example.com/idp2/sso\&quot;,   \&quot;signCert\&quot;: \&quot;-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\&quot; } &#x60;&#x60;&#x60;  ### List configured ID Provider Authentication Domains You can get a listing of all the configured ID Providers using a GET request to [/idp_auth_domain](#operation/queryIdProviderAuthDomain).  **Example:** Get the list of ID Provider authentication domains.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X GET &#39;https://$cluster_address/api/v1/idp_auth_domain&#39; &#x60;&#x60;&#x60;  The response body contains the ID of all the ID provider authentication domains.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,       \&quot;name\&quot;: \&quot;new-idp\&quot;,       \&quot;entityId\&quot;: \&quot;http://www.example.com/idp1\&quot;,       \&quot;ssoUrl\&quot;: \&quot;https://www.example.com/idp1/sso\&quot;,       \&quot;signCert\&quot;: \&quot;-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\&quot;     },     {       \&quot;id\&quot;: \&quot;9fef084b-75f8-4c03-9efa-c73b55be5da8\&quot;,       \&quot;name\&quot;: \&quot;another-idp\&quot;,       \&quot;entityId\&quot;: \&quot;http://www.example.com/idp2\&quot;,       \&quot;ssoUrl\&quot;: \&quot;https://www.example.com/idp2/sso\&quot;,       \&quot;signCert\&quot;: \&quot;-----BEGIN CERTIFICATE-----\\nMIIDrDCCtchA...\\n-----END CERTIFICATE-----\&quot;     }   ],   \&quot;total\&quot;: 2 }  &#x60;&#x60;&#x60;  ### Get information about a specific SAML ID Provider Authentication Domain You can also get information about a specific ID Provider using a GET request to [/idp_auth_domain/{id}](#operation/getIdProviderAuthDomain).  **Example:** Get information about a configured ID Provider.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X GET   &#39;https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd&#39; &#x60;&#x60;&#x60;  The response body contains information about this ID provider authentication domain.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,   \&quot;name\&quot;: \&quot;new-idp\&quot;,   \&quot;entityId\&quot;: \&quot;http://www.example.com/idp1\&quot;,   \&quot;ssoUrl\&quot;: \&quot;https://www.example.com/idp1/sso\&quot;,   \&quot;signCert\&quot;: \&quot;-----BEGIN CERTIFICATE-----\\nMIIDrDCCApSg...\\n-----END CERTIFICATE-----\&quot; } &#x60;&#x60;&#x60;  ### Delete an ID Provider Authentication Domain Any ID Provider authentication domain that is configured to a Rubrik cluster can be removed by issuing a DELETE request to [/idp_auth_domain/{id}](#operation/deleteIdProviderAuthDomain).  **Example:** Remove the ID Provider authentication domain  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X DELETE https://$cluster_address/api/v1/idp_auth_domain/499aeb71-f114-45a5-8456-91b9f6c45ddd &#x60;&#x60;&#x60;  ### Download Rubrik SAML Metadata Generate the Rubrik SAML service provider metadata file and get the URL of the file by issuing a GET request to [/saml/rubrik_metadata](#operation/configRubrikSamlMetadata).  **Example:**  Generate the Rubrik SAML metadata file without providing an address for the host at the endpoint. The cluster chooses a floating IP as the host address.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X POST -d &#39;{}&#39;   &#39;https://$cluster_address/api/v1/saml/rubrik_metadata&#39; &#x60;&#x60;&#x60;  **Example:** Generate the Rubrik SAML metadata file and specify an address for the host at the endpoint.  &#x60;&#x60;&#x60;bash curl -k -u admin:pass -X POST -d &#39;{\&quot;hostAddress\&quot;: \&quot;my.rubrik.saml.sp.com\&quot;}&#39;   &#39;https://$cluster_address/api/v1/saml/rubrik_metadata&#39; &#x60;&#x60;&#x60;  ### Check SAML SSO Status ### Send a GET request to unauthenticated endpoint [/saml/sso_status](#operation/getSamlSsoStatus) to check SAML SSO status. The status is represented by an object that contains 1) a Boolean value that determines whether or not SSO is enabled. 2) an optional String value that indicates the name of the default IdP authentication domain for SSO login. The default IdP will be configured when there is only one IdP configured in the cluster. 3) a Boolean value, isGpsLoginEnabled, that determines whether federated login is enabled.  **Example:** Check SAML SSO status  &#x60;&#x60;&#x60;bash curl -k -X GET &#39;https://$cluster_address/api/v1/saml/sso_status&#39; &#x60;&#x60;&#x60;  ### Make SAML Authentication Request Send a POST request to [/saml/authn_request](#operation/makeSamlAuthnRequest) to generate a signed SAML authentication request for the authentication domain of a specified ID Provider. The request can include optional parameters to specify a redirection resource path  and to specify that the request is a test of the configuration for the ID Provider. The response provides the data that is required for a SAML SSO authentication request for the ID Provider. This is an unauthenticated API.  **Example:** Make the SAML authentication request for ID Provider my-idp-1  &#x60;&#x60;&#x60;bash curl -k -X POST https://$cluster_address/api/v1/saml/authn_request/my-idp-1   -d &#39;{\&quot;redirectPath\&quot;: \&quot;/web/bin/index.html#/welcome\&quot;, \&quot;isForIdpTest\&quot;: false}&#39; &#x60;&#x60;&#x60;  # Principal Management  ## Searching for principals  To search for principals, send a GET request to the [&#x60;/principal&#x60;](#operation/searchPrincipalsV1) endpoint.  This endpoint only returns principals from the organization to which the currently logged-in user belongs.  All query parameters are optional. Each specified query parameters (besides the sorting parameters) will further restrict the set of results.  **Example:** &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/principal? name&#x3D;$name&amp; auth_domain_id&#x3D;$auth_domain_id&amp; organization_id&#x3D;$organization_id&amp; role_id&#x3D;$role_id&amp; is_assigned_roles_or_is_local&#x3D;$is_assigned_roles_or_is_local&amp; sort_by&#x3D;$sort_by&amp; sort_order&#x3D;$sort_order&amp; limit&#x3D;$limit&amp; offset&#x3D;$offset\&quot; &#x60;&#x60;&#x60;  ## Assigning roles to principals  To get a list of roles assigned to principals, send a GET request to the [&#x60;/principal/role&#x60;](#operation/getRolesForPrincipals) endpoint.  **Example:** &#x60;&#x60;&#x60;bash curl -X GET -d \&quot;https://$cluster_address/api/v1/principal/role? principals&#x3D;$principal_ids\&quot; &#x60;&#x60;&#x60;  To assign roles to a set of principals, send a POST request to the [&#x60;/principal/role&#x60;](#operation/assignRolesToPrincipals) endpoint.  **Example:** &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;principals\&quot;: \&quot;[$principal_id]\&quot;,   \&quot;roles\&quot;: \&quot;[$role_id]\&quot; }&#39; \&quot;https://$cluster_address/api/v1/principal/role\&quot; &#x60;&#x60;&#x60;  To revoke roles from a set of principals, send a POST request to the [&#x60;/principal/role/bulk_revoke&#x60;](#operation/revokeRolesFromPrincipals) endpoint.  **Example:** &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;principals\&quot;: \&quot;[$principal_id]\&quot;,   \&quot;roles\&quot;: \&quot;[$role_id]\&quot; }&#39; \&quot;https://$cluster_address/api/v1/principal/role/bulk_revoke\&quot; &#x60;&#x60;&#x60;  # Role Management  This section provides details on role management on CDM.  ## Role Lifecycle Management  To create a new role, send a POST request to the [&#x60;/role&#x60;](#operation/createRole) endpoint.  **Example:** &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;name\&quot;: \&quot;$role_name\&quot;,   \&quot;description\&quot;: \&quot;$description\&quot; }&#39; \&quot;https://$cluster_address/api/v1/role\&quot; &#x60;&#x60;&#x60;  To update a new role, send a PATCH request to the [&#x60;/role/$role_id&#x60;](#operation/updateRole) endpoint.  **Example:** &#x60;&#x60;&#x60;bash curl -X PATCH -d &#39;{   \&quot;name\&quot;: \&quot;$role_name\&quot;,   \&quot;description\&quot;: \&quot;$description\&quot; }&#39; \&quot;https://$cluster_address/api/v1/role/$role_id\&quot; &#x60;&#x60;&#x60;  To delete a role, send a DELETE request to the [&#x60;/role/$role_id&#x60;](#operation/deleteRole) endpoint.  **Example:** &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/role/$role_id\&quot; &#x60;&#x60;&#x60;  To get role metadata for all roles in an organization, send a GET request to the [&#x60;/role&#x60;](#operation/getRoles) endpoint.  All query parameters are optional. The getRoles endpoint uses the organization ID of the current user session when the API call does not specify an organization ID.  **Example:** &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/role? organization_id&#x3D;$organization_id&amp; name&#x3D;$role_name\&quot; &#x60;&#x60;&#x60;  To get role metadata for a specific role, send a GET request to the [&#x60;/role/$role_id&#x60;](#operation/getRole) endpoint.  **Example:** &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/role/$role_id\&quot; &#x60;&#x60;&#x60;   # Authorization  This section provides details on authorizing calls to the Rubrik CDM REST API.  ## Clearing the authorization cache Stale authorization information cached on the Rubrik CDM API server can cause API call failures. Clearing the cache on the node targeted by an API call can prevent this error.  To clear the cache, send a DELETE request to the [&#x60;/authorization/cache&#x60;](#operation/deleteAuthzCache) endpoint. &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/authorization/cache\&quot; &#x60;&#x60;&#x60;  # Rubrik certificate management  This section explains how to manage certificates.  ## Retrieving all imported certificates  To retrieve all imported certificates from the cluster, send a GET request to the [&#x60;/certificate&#x60;](#operation/queryCertificates) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/certificate\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns an array of objects with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  &#x60;&#x60;&#x60;bash {   \&quot;certId\&quot;: \&quot;$certId\&quot;,   \&quot;name\&quot;: \&quot;$certName\&quot;,   \&quot;hasKey\&quot;: true,   \&quot;expiration\&quot;: \&quot;$certExpiration\&quot;,   \&quot;usedBy\&quot;: {} } &#x60;&#x60;&#x60;  ## Importing a certificate  To import a certificate, send a POST request to the [&#x60;/certificates&#x60;](#operation/importCertificate) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;name\&quot;: \&quot;certName\&quot;,   \&quot;pemFile\&quot;: \&quot;$pemFile\&quot;,   \&quot;privateKey\&quot;: \&quot;$privateKey\&quot;,   \&quot;description\&quot;: \&quot;$description\&quot; }&#39; \&quot;https://$cluster_address/api/v1/certificate\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns an object with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  &#x60;&#x60;&#x60;bash {   \&quot;certId\&quot;: \&quot;$certId\&quot;,   \&quot;name\&quot;: \&quot;$certName\&quot;,   \&quot;hasKey\&quot;: true,   \&quot;expiration\&quot;: \&quot;$certExpiration\&quot;,   \&quot;usedBy\&quot;: {} } &#x60;&#x60;&#x60;  ## Retrieving a certificate  To retrieve a certificate, send a GET request to the [&#x60;/certificate/{id}&#x60;](#operation/exportCertificate) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/certificate/$cert_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns an object with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  ## Updating a certificate  To update a certificate, send a PATCH request to the [&#x60;/certificate/{id}&#x60;](#operation/updateCertificate) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;name\&quot;: \&quot;certName\&quot;,   \&quot;pemFile\&quot;: \&quot;$pemFile\&quot;,   \&quot;description\&quot;: \&quot;$description\&quot; }&#39; \&quot;https://$cluster_address/api/v1/certificate/$cert_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns an object with the certId, the name, the description, the certificate, whether the certificate has a private key, the expiration time, and what objects are using the certificate.  ## Deleting a Certificate  To delete a certificate, send a DELETE request to the [&#x60;/certificate/{id}&#x60;](#operation/deleteCertificate) endpoint.  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/certificate/$cert_id\&quot; &#x60;&#x60;&#x60;  ## Generating a Certificate Signing Request (CSR)  To generate a CSR, send a POST request to the [&#x60;/csr&#x60;](#operation/generateCsr) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;hostnames\&quot;: \&quot;$hostnames\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;organizations\&quot;: \&quot;$organization\&quot;,   \&quot;organizationUnit\&quot;: \&quot;$organizationUnit\&quot;,   \&quot;country\&quot;: \&quot;$country\&quot;,   \&quot;state\&quot;: \&quot;$state\&quot;,   \&quot;city\&quot;: \&quot;$city\&quot; }&#39; \&quot;https://$cluster_address/api/v1/csr\&quot; &#x60;&#x60;&#x60; Hostnames and name are required. The Rubrik REST API server will respond with the information provided in the POST request, in addition to the CSR to be signed.  ## Retrieving all outstanding Certificate Signing Requests  To retrieve all outstanding CSRs, send a GET request to the [&#x60;/csr&#x60;](#operation/getAllCsrs) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/csr\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server returns an array of objects with the csrId, the name, the CSR, and all information provided to generate the CSR.  ## Deleting a Certificate Signing Request (CSR)  To delete a CSR, send a DELETE request to the [&#x60;/csr/{id}&#x60;](#operation/deleteCsr) endpoint.  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/csr/$csr_id\&quot; &#x60;&#x60;&#x60;  ## Managing Rubrik Backup Service secondary cluster certificates  The Rubrik Backup Service can be setup to allow registering with multiple Rubrik clusters. See the Multicluster Rubrik Backup Service section of the Rubrik CDM User Guide for details. Certificates for replication source or replication target clusters are automatically added without calling the API in this section. To mark a certificate to be added to agents, send a POST request to [&#x60;/certificate/agent&#x60;](#operation/markAgentSecondaryCertificate).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;cert_id\&quot;: \&quot;$certId\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/certificate/agent\&quot; &#x60;&#x60;&#x60;  To list all qualified certificates that have been [imported to the cluster](#section/Rubrik-certificate-management/Importing-a-certificate), send a GET request to [&#x60;/certificate/agent&#x60;](#operation/queryAgentSecondaryCertificate).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/certificate/agent\&quot; &#x60;&#x60;&#x60;  To unmark a certificate so that is is no longer added to agents, send a DELETE request to [&#x60;/certificate/agent/{id}&#x60;](#operation/unmarkAgentSecondaryCertificate).  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/certificate/agent/$certId\&quot; &#x60;&#x60;&#x60;  # Cluster configuration history Rubrik REST API provides the &#x60;/config/history&#x60; endpoints for administrators to audit the changes made to the configuration parameters on a Rubrik cluster.  The ability to audit the configuration changes allows administrators to track the information related to the configuration changes, such as the old and new values of the configuration parameters, the user account that made the changes, the time of each change, and the name of the cluster or node where the changes were made.  The &#x60;/config/history&#x60; endpoints apply to the following configuration parameters: * Global or cluster wide configuration * Local or node specific configuration  ## Retrieving a summary of configuration changes To retrieve a list of configuration updates based on specific parameters, send a GET request to [&#x60;/config/history/list_updates&#x60;] (#operation/queryConfigurationHistoryUpdates).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/config/history/list_updates\&quot; &#x60;&#x60;&#x60;  To retrieve information for a specific configuration parameter include the name of the parameter in the request. To retrieve information for all configuration parameters that fit within the specified filters, do not specify a parameter name.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/config/history/list_updates?name&#x3D;$config_name\&quot; &#x60;&#x60;&#x60; The *Rubrik CDM User Guide* describes the parameters that can be configured to filter the results of the &#x60;GET /config/history/list_updates&#x60; endpoint.  The Rubrik REST API server responds with a list of JSON objects for the configuration updates that meet all specified filters.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;nodeId\&quot;: \&quot;string\&quot;,       \&quot;namespace\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;oldValue\&quot;: \&quot;string\&quot;,       \&quot;newValue\&quot;: \&quot;string\&quot;,       \&quot;apiUser\&quot;: \&quot;string\&quot;,       \&quot;modifiedDateTime\&quot;: \&quot;2021-02-26T17:21:54.520Z\&quot;,       \&quot;source\&quot;: \&quot;string\&quot;,       \&quot;configChangeMetadata\&quot;: \&quot;string\&quot;     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ## Retrieving a summary of configuration changes on a given date To retrieve the values of configuration parameters on a specific date, send a GET request to [&#x60;/config/history/ondate&#x60;] (#operation/retrieveConfigurationValues).  Specify values for the &#x60;namespace&#x60; and &#x60;on_date&#x60; query parameters that are required to send the GET request.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/config/history/ondate?namespace&#x3D;$namespace&amp;on_date&#x3D;$timestamp\&quot; &#x60;&#x60;&#x60;  To retrieve information for a specific configuration parameter include the name of the parameter in the request, along with the namespace and on_date parameters. To retrieve information for all configuration parameters that fit within the specified filters, do not specify a configuration parameter name.  The *Rubrik CDM User Guide* describes the parameters that can be configured to filter the results of the &#x60;GET /config/history/ondate&#x60; endpoint.  The Rubrik REST API server responds with a list of JSON objects for the configuration updates that meet all specified filters.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;namespace\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;defaultValue\&quot;: \&quot;string\&quot;,       \&quot;onDate\&quot;: \&quot;2021-02-26T17:21:54.526Z\&quot;,       \&quot;valueOnDate\&quot;: \&quot;string\&quot;,       \&quot;currentValue\&quot;: \&quot;string\&quot;,       \&quot;nodeId\&quot;: \&quot;string\&quot;     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  # Rubrik cluster management  This section explains how to retrieve basic information about a Rubrik cluster, as well as how to update the name of a cluster.  ## Discovering Nodes **Example:** Discovering unbootstrapped nodes on a network The discover endpoint cannot function without multicast DNS. When multicast DNS is not available, manually specify hostname and IPv6 information about the Rubrik cluster to enable node discovery. To input information about unbootstrapped nodes located on this network, send a POST request to the [&#x60;/cluster/{id}/$manual_discover&#x60;](#operation/manualDiscover) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{\&quot;nodeInfo\&quot;: [ {\&quot;hostname\&quot;: \&quot;string\&quot;, \&quot;ipv6\&quot;: \&quot;string\&quot; } ] }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/$manual_discover\&quot; &#x60;&#x60;&#x60;  The [&#x60;/cluster/{id}/$manual_discover_ipv4&#x60;](#operation/manualDiscoverIpv4) endpoint also discovers nodes over an IPv4 network.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{\&quot;nodeInfo\&quot;: [ {\&quot;hostname\&quot;: \&quot;string\&quot;, \&quot;ipv4\&quot;: \&quot;string\&quot; } ] }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/$manual_discover_ipv4\&quot; &#x60;&#x60;&#x60;  ## Retrieving Rubrik Cluster Information   **Example:** Retrieving publicly available information about a Rubrik cluster  To retrieve information about a Rubrik cluster, send a GET request to the [&#x60;/cluster/$cluster_id&#x60;](#operation/getPublicClusterInfo) endpoint. The Rubrik REST API server responds with the publicly available information for the specified Rubrik cluster.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns an array with the session ID, the Rubrik cluster software version, the API version, the Rubrik cluster name, and the Rubrik cluster time zone.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$cluster_id\&quot;,   \&quot;version\&quot;: \&quot;4.1.0\&quot;,   \&quot;apiVersion\&quot;: \&quot;1.0\&quot;,   \&quot;name\&quot;: \&quot;$cluster_name\&quot;,   \&quot;timezone\&quot;: {     \&quot;timezone\&quot;: \&quot;$cluster_timezone\&quot;   } } &#x60;&#x60;&#x60; To retrieve the cluster certificate, send a GET request to the [&#x60;/cluster/{id}/certificate&#x60;](#operation/getClusterCertificate) endpoint. &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/certificate\&quot; &#x60;&#x60;&#x60; To request only the current software version of the Rubrik cluster, send a GET request to the [&#x60;/cluster/$cluster_id/version&#x60;](#operation/getClusterVersion) endpoint. &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/version\&quot; &#x60;&#x60;&#x60;  To request only the current REST API version running on the cluster, send a GET request to [&#x60;/cluster/$cluster_id/api_version&#x60;](#operation/getClusterApiVersion)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/api_version\&quot; &#x60;&#x60;&#x60;  To get the download link for Rubrik SNMP MIB file, send a GET request to [&#x60;/cluster/$cluster_id/snmp_mib_link&#x60;](#operation/getRubrikSnmpMibDownloadLink) &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/snmp_mib_link\&quot; &#x60;&#x60;&#x60;  To get the download link for the SYSLOG-MSG-MIB file, send a GET request to [&#x60;/cluster/$cluster_id/syslog_msg_mib_link&#x60;](#operation/getSyslogMsgSnmpMibDownloadLink) &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/syslog_msg_mib_link\&quot; &#x60;&#x60;&#x60;  To get the download link for the SYSLOG-TC-MIB file, send a GET request to [&#x60;/cluster/$cluster_id/syslog_tc_mib_link&#x60;](#operation/getSyslogTcSnmpMibDownloadLink) &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/syslog_tc_mib_link\&quot; &#x60;&#x60;&#x60;  To retrieve the encryption at rest status of the cluster, send a GET request to the [&#x60;/cluster/$cluster_id/encryption&#x60;](#operation/getEncryptionStatus) endpoint. &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/security/encryption\&quot; &#x60;&#x60;&#x60;  To retrieve the IDs of the nodes in the cluster, send a GET request to the [&#39;/cluster/$cluster_id/node_id&#39;](#operation/getClusterNodeIds) endpoint. &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/node_id\&quot; &#x60;&#x60;&#x60;  ## Hostnames for nodes in a Rubrik cluster  ### Retrieving hostnames for nodes in a Rubrik cluster  To retrieve the hostnames of the nodes in a Rubrik cluster, send a GET request to the [&#39;/cluster/$cluster_id/node_hostname&#39;](#operation/getClusterNodeHostnames) endpoint. &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/node_hostname\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with an array of node ID to hostname mappings for all the nodes in the specified Rubrik cluster. &#x60;&#x60;&#x60;bash [   {     \&quot;id\&quot;: \&quot;RVM000000000001\&quot;,     \&quot;hostname\&quot;: \&quot;myhost01\&quot;   },   {     \&quot;id\&quot;: \&quot;RVM000000000002\&quot;,     \&quot;hostname\&quot;: \&quot;myhost02\&quot;   } ] &#x60;&#x60;&#x60;  ### Updating hostnames for nodes in a Rubrik cluster  To update the hostnames of the nodes in the Rubrik cluster, send a POST request to the [&#39;/cluster/$cluster_id/node_hostname&#39;](#operation/changeClusterNodeHostnames) endpoint. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;[{ \&quot;id\&quot;: \&quot;$id\&quot;, \&quot;hostname\&quot;:\&quot; \&quot;$hostname\&quot; }]&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/node_hostname\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with an appropriate message.  ## Changing the Rubrik cluster name or time zone  To change the name or the current time zone of a Rubrik cluster, send a PATCH request to the [&#x60;/cluster/$cluster_id&#x60;](#operation/updateCluster) endpoint.  Specify the new name as the value of &#x60;$cluster_name&#x60;, and specify the new time zone as the value of &#x60;$cluster_timezone&#x60;.  **Example:** Changing the name and the time zone of a Rubrik cluster  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{ \&quot;clusterName\&quot;: $cluster_name, \&quot;timezone\&quot;: { \&quot;timezone\&quot;: $cluster_timezone } }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/$cluster_id\&quot; &#x60;&#x60;&#x60;  The response provides the attributes of the specified Rubrik cluster object, including the new name, and the new time zone.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$cluster_id\&quot;,   \&quot;version\&quot;: \&quot;4.1.0\&quot;,   \&quot;apiVersion\&quot;: \&quot;1.0\&quot;,   \&quot;name\&quot;: \&quot;$cluster_name\&quot;,   \&quot;timezone\&quot;: {       \&quot;timezone\&quot;: \&quot;$cluster_timezone\&quot;   } } &#x60;&#x60;&#x60;  ## Stage CDM software to the cluster.  Send a POST request to the [&#x60;/cluster/{id}/upgrade/stage_cdm_software&#x60;](#operation/stageCdmSoftware) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{\&quot;version\&quot;: \&quot;$version\&quot;, \&quot;packageUrl\&quot;: \&quot;$packageUrl\&quot;, \&quot;md5sum\&quot;: \&quot;$md5sum\&quot;, \&quot;size\&quot;: $size, \&quot;skipDownload\&quot;: $skipDownload }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/stage_cdm_software\&quot; &#x60;&#x60;&#x60;  ## Query asynchronous job status for upgrade related job  To query the job status details of an asynchronous job that is related to upgrades, issue a GET to [&#x60;/cluster/{id}/upgrade/request/{request_id}&#x60;](#operation/getAsyncRequestStatusForUpgrade).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/request/$request_id\&quot; &#x60;&#x60;&#x60;  ## Retrieve CDM version available for upgrade  Send a GET request to the [&#x60;/cluster/{id}/upgrade/available_version&#x60;](#operation/availableVersion) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/upgrade/available_version\&quot; &#x60;&#x60;&#x60;  ## Retrieving Rubrik cluster prechecks status. To start an on demand run of the periodic upgrade prechecks,  send a POST request to the [&#x60;/cluster/{id}/upgrade/precheck_status&#x60;](#operation/runPeriodicUpgradePrechecks) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/ precheck_status\&quot; &#x60;&#x60;&#x60;  To retrieve the result of the latest run of periodic upgrade prechecks,  send a GET request to the [&#x60;/cluster/{id}/upgrade/precheck_status&#x60;](#operation/getPeriodicUpgradePrechecksStatus) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/upgrade/ precheck_status\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns a response which provides the list of  failures along with start time and end time. &#x60;&#x60;&#x60;bash {   \&quot;endTime\&quot;: 1580385970715,   \&quot;isOnDemand\&quot;: false,   \&quot;failureResults\&quot;: [     {       \&quot;isUserRemediable\&quot;: false,       \&quot;errorMessage\&quot;: \&quot;Sample error message\&quot;,       \&quot;precheckName\&quot;: \&quot;Sample precheck name\&quot;,       \&quot;userRemediableAction\&quot;: \&quot;\&quot;,       \&quot;userRemediableActionMessage\&quot;: \&quot;\&quot;     }   ],   \&quot;startTime\&quot;: 1580385904457 } &#x60;&#x60;&#x60;  ## Checking if a Rubrik cluster has an existing set of Rubrik support portal credentials  Send a GET request to the [&#x60;/cluster/{id}/rubrik_support_portal_credentials&#x60;](#operation/hasRubrikSupportPortalCredentials) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/rubrik_support_portal_credentials\&quot; &#x60;&#x60;&#x60;  ## Updating Rubrik support portal credentials on a Rubrik cluster  Send a POST request to the [&#x60;/cluster/{id}/rubrik_support_portal_credentials&#x60;](#operation/updateRubrikSupportPortalCredentials) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{\&quot;username\&quot; : \&quot;$username\&quot;, \&quot;password\&quot;: \&quot;$password\&quot;}&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/$cluster_id/rubrik_support_portal_credentials\&quot; &#x60;&#x60;&#x60;  ## Monitoring events on CDM  Send a GET request to the [&#x60;/cluster/me/upgrade/monitor_events&#x60;] (#operation/monitorEvents) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/cluster/me/upgrade/monitor_events\&quot; &#x60;&#x60;&#x60;  # Passwords  ## Setting password requirements  To set cluster-wide password requirements, send a PATCH request to [&#x60;/cluster/{id}/security/password_requirements&#x60;] (#operation/patchPasswordRequirements). The following parameters are optional: &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;id\&quot;: \&quot;$cluster_id\&quot;,     \&quot;minLength\&quot;: \&quot;$min_length\&quot;,     \&quot;minUpperCase\&quot;: \&quot;$min_upper_case\&quot;,     \&quot;minLowerCase\&quot;: \&quot;$min_lower_case\&quot;,     \&quot;minNumerics\&quot;: \&quot;$min_numerics\&quot;,     \&quot;minSpecial\&quot;: \&quot;$min_special\&quot;,     \&quot;useZxcvbn\&quot;: \&quot;$use_zxcvbn\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a summary of the password requirements: &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$cluster_id\&quot;,   \&quot;minLength\&quot;: \&quot;$min_length\&quot;,   \&quot;maxLength\&quot;: \&quot;$max_length\&quot;,   \&quot;minUpperCase\&quot;: \&quot;$min_upper_case\&quot;,   \&quot;minLowerCase\&quot;: \&quot;$min_lower_case\&quot;,   \&quot;minNumerics\&quot;: \&quot;$min_numerics\&quot;,   \&quot;minSpecial\&quot;: \&quot;$min_special\&quot;,   \&quot;useZxcvbn\&quot;: \&quot;$use_zxcvbn\&quot; } &#x60;&#x60;&#x60;  ## Getting current password requirements  To retrieve the existing cluster-wide password requirments, send a GET request to [&#x60;/cluster/{id}/security/password_requirements&#x60;] (#operation/queryPasswordRequirements)  &#x60;&#x60;&#x60;bash curl -X GET \\   -d &#39;{     \&quot;id\&quot;: \&quot;$cluster_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/password_requirements\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a summary of the password requirements: &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$cluster_id\&quot;,   \&quot;minLength\&quot;: \&quot;$min_length\&quot;,   \&quot;maxLength\&quot;: \&quot;$max_length\&quot;,   \&quot;minUpperCase\&quot;: \&quot;$min_upper_case\&quot;,   \&quot;minLowerCase\&quot;: \&quot;$min_lower_case\&quot;,   \&quot;minNumerics\&quot;: \&quot;$min_numerics\&quot;,   \&quot;minSpecial\&quot;: \&quot;$min_special\&quot;,   \&quot;useZxcvbn\&quot;: \&quot;$use_zxcvbn\&quot; } &#x60;&#x60;&#x60;  ## Managing the Web Server Certificate  To retrieve the existing web server certificate signed by a CA, send a GET request to: [&#x60;/cluster/{id}/security/web_signed_cert&#x60;] (#operation/getWebSignedCertificate)  &#x60;&#x60;&#x60;bash curl -X GET \\   -d &#39;{     \&quot;id\&quot;: \&quot;$cluster_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;webServerConfiguredWithCASignedCertificate\&quot;: true,   \&quot;cert\&quot;: {     \&quot;certId\&quot;: \&quot;string\&quot;,     \&quot;name\&quot;: \&quot;string\&quot;,     \&quot;pemFile\&quot;: \&quot;string\&quot;,     \&quot;hasKey\&quot;: true,     \&quot;expiration\&quot;: \&quot;2020-03-30T19:32:08.221Z\&quot;,     \&quot;usedBy\&quot;: \&quot;string\&quot;,     \&quot;description\&quot;: \&quot;string\&quot;   } } &#x60;&#x60;&#x60;  Set the web server certificate used by Rubrik for REST API communications by sending a PUT request to the [&#x60;/cluster/{id}/security/web_signed_cert&#x60;](#operation/setWebSignedCertificate) endpoint:  &#x60;&#x60;&#x60;bash curl -X PUT \\   -d &#39;{     \&quot;certificateId\&quot;: \&quot;string\&quot;}&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2020-03-30T19:09:13.400Z\&quot;,   \&quot;endTime\&quot;: \&quot;2020-03-30T19:09:13.400Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  To use the default, self-signed certificate, send a DELETE request to the [&#x60;/cluster/{id}/security/web_signed_cert&#x60;](#operation/resetWebSignedCertificate) endpoint.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   -d &#39;{     \&quot;id\&quot;: \&quot;$cluster_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/web_signed_cert\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2020-03-30T19:31:13.024Z\&quot;,   \&quot;endTime\&quot;: \&quot;2020-03-30T19:31:13.025Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  ## Managing Truststores  To retrieve the existing truststore configuration, send a GET request to: [&#x60;/cluster/{id}/security/truststore&#x60;] (#operation/getTruststores)  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/truststore\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false   \&quot;data\&quot;: [     {       \&quot;truststoreType\&quot;: \&quot;TruststoreType\&quot;,       \&quot;certificates\&quot;: [         {           \&quot;certId\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;,           \&quot;pemFile\&quot;: \&quot;string\&quot;,           \&quot;hasKey\&quot;: true,           \&quot;expiration\&quot;: \&quot;2020-03-30T19:32:08.221Z\&quot;,           \&quot;usedBy\&quot;: \&quot;string\&quot;,           \&quot;description\&quot;: \&quot;string\&quot;         }       ]     }   ] } &#x60;&#x60;&#x60;  To set the certificates for one or more of the truststores used by Rubrik, send a PATCH request to the [&#x60;/cluster/{id}/security/truststore&#x60;](#operation/setTruststoreCertificate) endpoint:  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{       \&quot;truststorePayload\&quot;: [ \\         {\&quot;truststoreType\&quot;: \&quot;TruststoreType\&quot;, certIds: [\&quot;string\&quot;, \&quot;string\&quot;]} \\       ]}&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/truststore\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash OK &#x60;&#x60;&#x60;  To clear the certificates for one or more of the truststores used by Rubrik, send a DELETE request to the [&#x60;/cluster/{id}/security/truststore&#x60;](#operation/unsetTruststoreCertificate) endpoint:  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/truststore?truststores&#x3D;$truststore1,$truststore2\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash OK &#x60;&#x60;&#x60;  ## Updating CORS support configuration  To update the CORS support configuration for a web server, send a PATCH request to [&#x60;/cluster/{id}/security/cors&#x60;](#operation/updateCorsConfiguration). &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;isEnabled\&quot;: \&quot;$is_enabled\&quot;,     \&quot;allowedOrigins\&quot;: \&quot;$allowed_origins\&quot;,     \&quot;allowedHEaders\&quot;: \&quot;$allowed_headers\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/cors\&quot; &#x60;&#x60;&#x60;  ## Getting CORS support configuration  Retrieve the current CORS support configuration with a GET request to: [&#x60;/cluster/{id}/security/cors&#x60;](#operation/getCorsConfiguration). &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/cors\&quot; &#x60;&#x60;&#x60;  ## Getting FIPS enablement status  Retrieve the current FIPS enablement status with a GET request to: [&#x60;/cluster/{id}/security/fips&#x60;](#operation/getFips). &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/fips\&quot; &#x60;&#x60;&#x60;  ## Updating FIPS enablement  To update the FIPS enablement for a cluster, send a PATCH request to [&#x60;/cluster/{id}/security/fips&#x60;](#operation/updateFips). &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;isEnabledInFlight\&quot;: \&quot;$is_enabled_in_flight\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/fips\&quot; &#x60;&#x60;&#x60;  ## Managing KMIP Servers To configure a new KMIP server integration, send a PUT request to the [&#x60;/cluster/{id}/security/kmip/server&#x60;](#operation/addKmipServer) endpoint. &#x60;&#x60;&#x60;bash curl -X PUT \\   -d &#39;{     \&quot;serverAddress\&quot;: \&quot;string\&quot;,     \&quot;serverCertificateId\&quot;: \&quot;string\&quot;,     \&quot;serverPort\&quot;: 0}&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/kmip/server\&quot;  &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2020-03-31T22:10:40.912Z\&quot;,   \&quot;endTime\&quot;: \&quot;2020-03-31T22:10:40.912Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  For information about a configured KMIP server, send a GET request to the [&#x60;/cluster/{id}/security/kmip/server&#x60;](#operation/getKmipServer) endpoint: &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/kmip/server?server_address&#x3D;$address\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash [   {     \&quot;serverAddress\&quot;: \&quot;string\&quot;,     \&quot;serverCertificateId\&quot;: \&quot;string\&quot;,     \&quot;serverPort\&quot;: 0   } ] &#x60;&#x60;&#x60; To delete an existing KMIP server integration, send a DELETE request to [&#x60;/cluster/{id}/security/kmip/server&#x60;](#operation/deleteKmipServer): &#x60;&#x60;&#x60;bash curl -X DELETE \\ \&quot;https://$cluster_address/api/v1/cluster/{id}/security/kmip/server?server_address&#x3D;$address\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2020-03-31T22:15:26.693Z\&quot;,   \&quot;endTime\&quot;: \&quot;2020-03-31T22:15:26.693Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] }  &#x60;&#x60;&#x60;  ## Managing the KMIP Client To configure the KMIP client, send a PUT request to [&#x60;/cluster/{id}/security/kmip/client&#x60;](#operation/setKmipClient) &#x60;&#x60;&#x60;bash curl -X PUT \\   -d &#39;{     \&quot;username\&quot;: \&quot;string\&quot;,     \&quot;password\&quot;: \&quot;string\&quot;,     \&quot;clientCertificateId\&quot;: \&quot;string\&quot;     }&#39; \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/kmip/client\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash  &#x60;&#x60;&#x60; To retrieve information about the confiugred KMIP client, send a GET request to [&#x60;/cluster/{id}/security/kmip/client&#x60;](#operation/getKmipClient) &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/kmip/client\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;username\&quot;: \&quot;string\&quot;,   \&quot;clientCertificateId\&quot;: \&quot;string\&quot;,   \&quot;isPasswordSet\&quot;: true } &#x60;&#x60;&#x60;  ## Manage the 2-Step Verification Global Setting ### Retrieving the 2-Step Verification global setting To retrieve the 2-Step Verification global setting for a specific Rubrik cluster, send a GET request to [&#x60;/cluster/{id}/security/totp/setting&#x60;](#operation/getTotpGlobalSetting). &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/totp/setting\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the 2-Step Verification setting for the specified Rubrik cluster. &#x60;&#x60;&#x60;bash {   \&quot;isEnforced\&quot;: true } &#x60;&#x60;&#x60;  ### Updating the 2-Step Verification global setting To update the 2-Step Verification global setting for a specific Rubrik cluster, send a PUT request to [&#x60;/cluster/{id}/security/totp/setting&#x60;](#operation/updateTotpGlobalSetting). &#x60;&#x60;&#x60;bash curl -X PUT \\   -d &#39;{\&quot;isEnforced\&quot;: true}&#39;   \&quot;https://$cluster_address/api/v1/cluster/{id}/security/totp/setting\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the updated 2-Step Verification  setting for the specified Rubrik cluster. &#x60;&#x60;&#x60;bash {   \&quot;isEnforced\&quot;: true } &#x60;&#x60;&#x60;  # Event  ## Get latest events and event series info for event series Send a GET request to [&#x60;/event/latest&#x60;](#operation/queryLatestEventsV1)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/event/latest\&quot; &#x60;&#x60;&#x60;  ## Get information for all events Send a GET request to [&#x60;/event&#x60;](#operation/queryEventV1)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/event\&quot; &#x60;&#x60;&#x60;  ## Get all events and relevant information associated with an event series Send a GET request to [&#x60;/event_series/{id}&#x60;](#operation/queryEventSeriesByIdV1)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/event_series/{id}\&quot; &#x60;&#x60;&#x60;  ## Get download link of CSV file containing summary of events Send a GET request to [&#x60;/event/csv_download_link&#x60;](#operation/getEventsCsvDownloadLink)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1//event/csv_download_link\&quot; &#x60;&#x60;&#x60;  # SLA Domains  Rubrik clusters provide automated data management and protection through SLA Domains. An SLA Domain defines the data management and protection policies for their assigned snappables (virtual machines, file systems, and applications).  To provide policy based management and protection of a snappable, add the snappable to an SLA Domain, or to multiple SLA Domains.  ## Retrieving SLA Domains  Before assigning snappables to SLA Domains, get a list of the SLA Domains that exist on a Rubrik cluster. For a new Rubrik cluster, the list shows only the default SLA Domains. When custom SLA Domains are added to the Rubrik cluster, the list is modified to include those SLA Domains.  **Example:** Retrieving SLA Domains from a Rubrik cluster  Send a GET request to [&#x60;/sla_domain&#x60;](#operation/querySlaDomain).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sla_domain\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns a &#x60;ListResponse&#x60; object of all SLA Domains. At a minimum, the &#x60;ListResponse&#x60; object includes the default SLA Domains: Gold, Silver, and Bronze.  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$gold_sla_id\&quot;,       \&quot;name\&quot;: \&quot;Gold\&quot;     },     {       \&quot;id\&quot;: \&quot;$silver_sla_id\&quot;,       \&quot;name\&quot;: \&quot;Silver\&quot;     },     {       \&quot;id\&quot;: \&quot;$bronze_sla_id\&quot;,       \&quot;name\&quot;: \&quot;Bronze\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 3 } &#x60;&#x60;&#x60;  To obtain more details about a specific SLA domain send a GET request with the &#x60;id&#x60; of one of the SLA Domains to the &#x60;/sla_domain/{id}&#x60; endpoint:  [&#x60;/sla_domain/{id}&#x60;](#operation/getSlaDomain)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sla_domain/$bronze_sla_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details of the specified SLA Domain.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$bronze_sla_id\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,   \&quot;name\&quot;: \&quot;Bronze\&quot;,   \&quot;frequencies\&quot;: [     {       \&quot;timeUnit\&quot;: \&quot;Daily\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 32     },     {       \&quot;timeUnit\&quot;: \&quot;Monthly\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 12     },     {       \&quot;timeUnit\&quot;: \&quot;Yearly\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 2     }   ],   \&quot;allowedBackupWindows\&quot;: [],   \&quot;firstFullAllowedBackupWindows\&quot;: [],   \&quot;archivalSpecs\&quot;: [],   \&quot;replicationSpecs\&quot;: [     {       \&quot;locationId\&quot;: \&quot;$repl_location_id\&quot;,       \&quot;retentionLimit\&quot;: 0     }   ],   \&quot;numDbs\&quot;: 0,   \&quot;numFilesets\&quot;: 7,   \&quot;numLinuxHosts\&quot;: 3,   \&quot;numWindowsHosts\&quot;: 2,   \&quot;numVms\&quot;: 1,   \&quot;isDefault\&quot;: false,   \&quot;uiColor\&quot;: \&quot;#cc8366\&quot; } &#x60;&#x60;&#x60;  ## Working with SLA Domains  To work with an SLA Domain, obtain the &#x60;id&#x60; of that SLA Domain. As described in [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains), start by sending a GET request to [&#x60;/sla_domain&#x60;](#operation/querySlaDomain).  The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object that contains all of the SLA Domains on the specfied Rubrik cluster. From that list object, find the data array element that has the &#x60;name&#x60; value of the selected SLA Domain. In the same array element as the &#x60;name&#x60; value, note the value of the &#x60;id&#x60; string.  ## Creating SLA Domains  To create an SLA domain send a POST request to [&#x60;/sla_domain&#x60;](#operation/createSlaDomain). Include the attributes for the SLA Domain in the request body.  The following table describes the required and optional attributes to include in the request body when creating an SLA Domain.  | Attribute | Req&#39;d | JSON Type | Description | | ------ | --- | ----- | ----------- | | &#x60;name&#x60; | Yes | String | Name of the SLA Domain.  | | &#x60;frequencies&#x60; | Yes | Array | Each member defines a policy by specifying: &#x60;timeUnit&#x60;, &#x60;frequency&#x60;, and &#x60;retention&#x60;. Requires at least one member in the array.  | | &#x60;allowedBackupWindows&#x60; | Yes | Array | Each member defines a backup window using values for &#x60;startTimeAttributes&#x60; and &#x60;durationInHours&#x60;. The time specified in &#x60;startTimeAttributes&#x60; uses the Rubrik cluster time zone. To specify multiple backup windows, add an array member for each window. To create an SLA Domain without a backup window, specify a null array value: &#x60;[]&#x60;.  | | &#x60;firstFullAllowedBackupWindows&#x60; | Yes | Array | Each member defines a period when first full backups are allowed by specifying: &#x60;startTimeAttributes&#x60; and &#x60;durationInHours&#x60;. Several first full backup windows can be specified by adding an array member for each one. Create an SLA Domain without a first full backup window by specifying a null array value: &#x60;[]&#x60;.  | | &#x60;localRetentionLimit&#x60; | No | String | Specify an integer value to set the number of days to retain a local copy of a snapshot. When an archival location is specified, specify &#x60;0&#x60; to enable Instant Archiving. | | &#x60;archivalSpecs&#x60; | No | Array | Defines the archival location for the SLA Domain by specifying: &#x60;locationId&#x60; and &#x60;archivalThreshold&#x60;. Currently limited to one array member. | | &#x60;replicationSpecs&#x60; | No | Array | Defines the replication location for the SLA Domain by specifying: &#x60;locationId&#x60; and &#x60;retentionLimit&#x60;. Currently limited to one array member. |  **Example:** Creating an SLA Domain for daily backups  Create an SLA Domain that takes a backup once a day and retains the backup for seven days. Do not set a backup window or a first full backup window. Do not include archival or replication.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{   \&quot;name\&quot;: \&quot;Daily SLA\&quot;,   \&quot;frequencies\&quot;: [     {       \&quot;timeUnit\&quot;: \&quot;Day\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 7     }   ],   \&quot;allowedBackupWindows\&quot;: [],   \&quot;firstFullAllowedBackupWindows\&quot;: [] }&#39; \\   \&quot;https://$cluster_address/api/v1/sla_domain\&quot; &#x60;&#x60;&#x60; The response confirms the attributes of the SLA Domain and provides the &#x60;id&#x60; of the new SLA Domain.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$sla_id\&quot;,   \&quot;name\&quot;: \&quot;Daily SLA\&quot;,   \&quot;frequencies\&quot;: [     {       \&quot;timeUnit\&quot;: \&quot;Day\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 7     }   ],   \&quot;allowedBackupWindows\&quot;: [],   \&quot;firstFullAllowedBackupWindows\&quot;: [] } &#x60;&#x60;&#x60; ## Modifying SLA Domains  To modify the attributes of an SLA domain send a PUT request to [&#x60;/sla_domain/{id}&#x60;](#operation/updateSlaDomain). Include in the request body the new attributes.  **Example:** Modifying the daily backup SLA Domain  Change the SLA Domain that was created in [Creating SLA Domains](#section/SLA-Domains/Creating-SLA-Domains) to increase the retention to 14 days.  &#x60;&#x60;&#x60;bash curl -X PUT \\   -d &#39;{   \&quot;name\&quot;: \&quot;Daily SLA\&quot;,   \&quot;frequencies\&quot;: [     {       \&quot;timeUnit\&quot;: \&quot;Day\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 14     }   ],   \&quot;allowedBackupWindows\&quot;: [],   \&quot;firstFullAllowedBackupWindows\&quot;: [] }&#39; \\   \&quot;https://$cluster_address/api/v1/sla_domain/$sla_id\&quot; &#x60;&#x60;&#x60; The response confirms the new attribute.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$sla_id\&quot;,   \&quot;name\&quot;: \&quot;Daily SLA\&quot;,   \&quot;frequencies\&quot;: [     {       \&quot;timeUnit\&quot;: \&quot;Day\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 14     }   ],   \&quot;allowedBackupWindows\&quot;: [],   \&quot;firstFullAllowedBackupWindows\&quot;: [] } &#x60;&#x60;&#x60; ## Patching SLA Domains  To patch the attributes of an SLA domain, send a PATCH request to [&#x60;/sla_domain/{id}&#x60;](#operation/patchSlaDomain). Include in the request body only the attributes that needs to be patched.  **Example:** Patching the daily backup SLA Domain  Patch the SLA Domain that was created in [Creating SLA Domains] (#section/SLA-Domains/Creating-SLA-Domains) to change the archival specifications.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{   \&quot;archivalSpecs\&quot;: [     {         \&quot;locationId\&quot;: \&quot;some-valid-archived-location-id\&quot;,         \&quot;archivalThreshold\&quot;: 14     }   ]}&#39; \\   \&quot;https://$cluster_address/api/v1/sla_domain/$sla_id\&quot; &#x60;&#x60;&#x60; The response confirms the new attribute and also includes the other attributes that were not changed.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$sla_id\&quot;,   \&quot;name\&quot;: \&quot;Daily SLA\&quot;,   \&quot;frequencies\&quot;: [     {       \&quot;timeUnit\&quot;: \&quot;Day\&quot;,       \&quot;frequency\&quot;: 1,       \&quot;retention\&quot;: 7     }   ],   \&quot;archivalSpecs\&quot;: [     {       \&quot;locationId\&quot;: \&quot;some-valid-archived-location-id\&quot;,       \&quot;archivalThreshold\&quot;: 14     }   ],   \&quot;allowedBackupWindows\&quot;: [],   \&quot;firstFullAllowedBackupWindows\&quot;: [] } &#x60;&#x60;&#x60; ## Deleting SLA Domains  To delete an SLA domain send a DELETE request to [&#x60;/sla_domain/{id}&#x60;](#operation/deleteSlaDomain).  **Example:** Deleting an SLA Domain  Delete an SLA Domain with the &#x60;id&#x60; of &#x60;$sla_id&#x60;.  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/sla_domain/$sla_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  ## Inherited protection  The Rubrik REST API uses the reserved value &#x60;INHERIT&#x60; with the &#x60;configuredSlaDomainId&#x60; string to identify a snappable that derives its protection policy from a parent object. Examples of this: * VMware virtual machine inherits from vCenter Server * SQL Server database inherits from SQL Server instance  Every snappable that can be protected through an SLA Domain is represented by an object that has a &#x60;configuredSlaDomainId&#x60; attribute and an &#x60;effectiveSlaDomainId&#x60; attribute. The &#x60;configuredSlaDomainId&#x60; attribute contains either the value of a direct SLA Domain assignment or the reserved value &#x60;INHERIT&#x60;.  The &#x60;effectiveSlaDomainId&#x60; attribute contains the value of the SLA Domain setting that the Rubrik cluster actually applies to the snappable. When the value of the &#x60;configuredSlaDomainId&#x60; attribute is &#x60;INHERIT&#x60;, the value of the &#x60;effectiveSlaDomainId&#x60; attribute is derived from a parent object of the snappable. In all other cases, the value of the &#x60;effectiveSlaDomainId&#x60; attribute is the same as the value of the &#x60;configuredSlaDomainId&#x60; attribute.   ## SLA Domain assignments  To assign a snappable to an SLA Domain, use the endpoint that is provided for that type of snappable. * VMware virtual machines   Send a PATCH request to  [&#x60;/vmware/vm/{id}&#x60;](#operation/updateVm). [VMware virtual machines](#section/VMware-virtual-machines) provides more information about this. * Linux or Windows filesets   Send a PATCH request to  [&#x60;/fileset/{id}&#x60;](#operation/updateFileset). [Filesets](#section/Filesets) provides more information about this. * SQL Server databases   Send a PATCH request to  [&#x60;/mssql/db/{id}&#x60;](#operation/updateMssqlDb). [SQL Server databases](#section/SQL-Server-databases) provides more information about this.  ## Assigning SLA Domain to downloaded snapshots  To assign an SLA Domain to a list of snapshots at their downloaded locations, send a POST request to the [&#x60;/sla_domain/assign_to_downloaded_snapshots&#x60;] (#operation/assignSlaToDownloadedSnapshots) endpoint.  **Example:** Assigning an SLA Domain with ID $slaId to list of snapshots -              $s1Id, $s2Id of object $snappableId  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{    \&quot;slaDomainId\&quot;: $slaId    \&quot;objectId\&quot;: $snappableId    \&quot;snapshotIds\&quot;: [$s1Id, $s2Id]}&#39; \\    \&quot;https://$cluster_address/api/v1/sla_domain/assign_to_downloaded_snapshots\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;responses\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;status\&quot;: \&quot;string\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;2019-10-29T22:11:35.256Z\&quot;,       \&quot;endTime\&quot;: \&quot;2019-10-29T22:11:35.256Z\&quot;,       \&quot;nodeId\&quot;: \&quot;string\&quot;,       \&quot;error\&quot;: {         \&quot;message\&quot;: \&quot;string\&quot;       },       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;string\&quot;,           \&quot;rel\&quot;: \&quot;string\&quot;         }       ]     }   ] } &#x60;&#x60;&#x60;  The Rubrik REST API server responds with HTTP response code 200 and the response body containing the details of the async request.  # Virtual machines  The Rubrik cluster protects virtual machines running in a VMware vSphere environment through the VADP APIs. The Rubrik cluster also works with the Rubrik Backup Service running on the virtual machine to provide:  * Optimal performance when restoring files and folders to the virtual machine * Application consistent snapshots of a Windows virtual machine   ## vCenter servers  A Rubrik cluster normally protects and manages virtual machines through the vCenter Server that administers those virtual machines. After a vCenter server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the virtual machines that are administered by that vCenter server.  ### Retrieving vCenter Servers  Request a list of the vCenter servers that are registered with a Rubrik cluster by sending a GET request to  [&#x60;/vmware/vcenter&#x60;](#operation/queryVcenter).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vcenter\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the first page of a &#x60;ListResponse&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$vcenter_id0\&quot;,       \&quot;hostname\&quot;: \&quot;$vcenter_address0\&quot;,       \&quot;username\&quot;: \&quot;$vcenter_admin0\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;caCerts\&quot;: \&quot;$ca_certs0\&quot;     },     {       \&quot;id\&quot;: \&quot;$vcenter_id1\&quot;,       \&quot;hostname\&quot;: \&quot;$vcenter_address1\&quot;,       \&quot;username\&quot;: \&quot;$vcenter_admin1\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;caCerts\&quot;: \&quot;$ca_certs1\&quot;     }   ],   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60; Depending on the number of registered vCenter Servers, all of the entries on the list may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.   ### Adding a vCenter server  To add a vCenter server, send a POST request to [&#x60;/vmware/vcenter&#x60;](#operation/createVcenter). Include in the body of the request the address of the vCenter server and credentials for a user account (&#x60;username&#x60;) that has the required permissions. The Rubrik User Guide provides details about creating an account with the required permissions.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$vcenter_address\&quot;,     \&quot;username\&quot;: \&quot;$vcenter_admin\&quot;,     \&quot;password\&quot;: \&quot;$vcenter_password\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vcenter\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;error\&quot;: \&quot;None\&quot;,   \&quot;progress\&quot;: \&quot;$request_progress\&quot;   \&quot;links\&quot;: [     {       href: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       rel: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  Using the information provided in the task object, send a GET request to the [&#x60;/vmware/vcenter/request/{id}&#x60;](#operation/getVcenterAsyncRequestStatus) endpoint to poll the task status. When the value of &#x60;status&#x60; in the task object is &#x60;SUCCEEDED&#x60;, the task finished successfully.  ### Retrieve vCenter Server details Get the details for a vCenter Server that is registered with a Rubrik cluster by sending a GET request to [&#x60;/vmware/vcenter/{id}&#x60;](#operation/getVcenter).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the specified vCenter Server object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;hostname\&quot;: \&quot;$vcenter_address0\&quot;,   \&quot;username\&quot;: \&quot;$vcenter_admin0\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot; } &#x60;&#x60;&#x60;  ### Modifying a vCenter Server entry  To change the information that a Rubrik cluster stores for a vCenter Server, send a PUT request to [&#x60;/vmware/vcenter/{id}&#x60;](#operation/updateVcenter). All of the members of the &#x60;VcenterConfig&#x60; object must be in the PUT request. Using the new values, include in the body of the PUT request each member (&#x60;{string : value}&#x60;) of the &#x60;VcenterConfig&#x60; object: * &#x60;\&quot;hostname\&quot;: \&quot;$vcenter_address\&quot;&#x60; * &#x60;\&quot;username\&quot;: \&quot;$vcenter_admin\&quot;&#x60; * &#x60;\&quot;password\&quot;: \&quot;$vcenter_password\&quot;&#x60;  To change the configured SLA that is configured for a vCenter Server or to change CA certificates for the vCenter, send a PATCH request to[&#x60;/vmware/vcenter/{id}&#x60;](#operation/patchVcenter).  &#x60;&#x60;&#x60;bash curl -X PUT \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$vcenter_address\&quot;,     \&quot;username\&quot;: \&quot;$vcenter_admin\&quot;,     \&quot;password\&quot;: \&quot;$vcenter_password\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server sends a response, with the updated details of the vCenter Server entry in the response body.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$vcenter_id\&quot;,   \&quot;hostname\&quot;: \&quot;$vcenter_address\&quot;,   \&quot;username\&quot;: \&quot;$vcenter_admin\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,   \&quot;caCerts\&quot;: \&quot;$ca_certs\&quot; } &#x60;&#x60;&#x60; ### Removing a vCenter Server entry  To remove a vCenter Server entry from a Rubrik cluster, first unmount any Live Mount and Instant Recovery virtual machines for the vCenter Server. Then send a DELETE request to [&#x60;/vmware/vcenter/{id}&#x60;](#operation/deleteVcenter).  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server initiates the asynchronous delete task and responds with a task object.  &#x60;&#x60;&#x60;bash {     \&quot;id\&quot;: \&quot;$request_id\&quot;,     \&quot;status\&quot;: \&quot;RUNNING\&quot;,     \&quot;error\&quot;: \&quot;None\&quot;,     \&quot;progress\&quot;: 0,     \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,     \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,     \&quot;links\&quot;: [       {         \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,         \&quot;rel\&quot;: \&quot;self\&quot;       }     ]   } &#x60;&#x60;&#x60; Using the information provided in the task object, send a GET request to poll the task status. When the value of &#x60;status&#x60; in the task object is &#x60;SUCCEEDED&#x60;, the removal of the vCenter Server object finished successfully.  ### Force refresh of virtual machine on a vCenter Force a refresh of the metadata for a single virtual machine by sending a POST request to [&#x60;/vmware/vcenter/{id}&#x60;](#operation/createRefreshVmV1).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;vmMoid\&quot;: \&quot;$vm_moid\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}/refresh_vm\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a 204 response.    ### Metadata refresh  The Rubrik cluster regularly refreshes the metadata of the registered vCenter Servers. As part of a refresh operation, the Rubrik cluster discovers any changes or additions to the virtual machines that are administered by the vCenter Servers. Instead of waiting for a regular refresh, a metadata refresh can be manually initiated by sending a POST request to [&#x60;/vmware/vm/refresh&#x60;](#operation/createRefresh), using the Rubrik cluster ID (&#x60;$cluster_address&#x60;) and the vCenter Server ID (&#x60;$vcenter_id&#x60;).  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id/refresh\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;error\&quot;: \&quot;None\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  Using the information provided in the task object, send a GET request to poll the task status. When the value of &#x60;status&#x60; in the task object is &#x60;SUCCEEDED&#x60;, the metadata refresh completed successfully.  ## ESXi hypervisors  Retrieve a list of all available ESXi hypervisors in the vSphere environment by sending a GET request to [&#x60;/vmware/host&#x60;](#operation/queryVmwareHost).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/host?primary_cluster_id&#x3D;$cluster_id\&quot; &#x60;&#x60;&#x60; The value of &#x60;primary_cluster_id&#x60; is the &#x60;id&#x60; of a Rubrik cluster. Use &#x60;local&#x60; to retrieve a list for the Rubrik cluster that is hosting the current session.  The Rubrik REST API server responds with the first page of a &#x60;ListResponse&#x60; object.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$esxi_id\&quot;,       \&quot;name\&quot;: \&quot;$esxi_name\&quot;,       \&quot;datacenterId\&quot;: \&quot;$datacenter_id\&quot;,       \&quot;computeClusterId\&quot;: \&quot;$compute_cluster_id\&quot;,       \&quot;datastores\&quot;: [       ...       ],       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;     }     ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Retrieve more details for an ESXi hypervisor by sending a GET request to [&#x60;/vmware/host/{id}&#x60;](#operation/getVmwareHost)  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/vmware/host/$esxi_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details for the specified ESXi hypervisor.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$esxi_id\&quot;,   \&quot;moid\&quot;: \&quot;$moid\&quot;,   \&quot;name\&quot;: \&quot;$esxi_name\&quot;,   \&quot;computeClusterId\&quot;: \&quot;$compute_cluster_id\&quot;,   \&quot;datacenter\&quot;: {     \&quot;id\&quot;: \&quot;$datacenter_id\&quot;,     \&quot;name\&quot;: \&quot;$datacenter_name\&quot;,     \&quot;vcenterId\&quot;: \&quot;$vcenter_id\&quot;,     \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,     \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;   },   \&quot;datastores\&quot;: [     ...   ],   \&quot;virtualMachines\&quot;: [     ...   ],   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot; } &#x60;&#x60;&#x60;  Additionally, To change the SLA Domain that is configured for an ESXi hypervisor, send a PATCH request on [&#x60;/vmware/host&#x60;](#operation/updateVmwareHost)  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/vmware/host/$snapshot_id\&quot; &#x60;&#x60;&#x60;  Retrieve datastore details for an ESXi hypervisor by sending a GET request to [&#x60;/vmware/host/{id}/datastore&#x60;](#operation/getVmwareHostDatastore) &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/host/$esxi_id/datastore\&quot; &#x60;&#x60;&#x60;   ## Virtual machine protection  After a vCenter Server is registered, the Rubrik cluster acquires metadata for the virtual machines that are administered through that vCenter Server. Using the metadata, assign Rubrik cluster protection to the virtual machines.  The typical protection workflow involves the following tasks: 1. Find the virtual machine resource object. 2. (Optional) Enable scripts on the virtual machine. 3. (Optional) Exclude specified vmdk files for the virtual machine. 4. Assign the virtual machine to an SLA Domain. 5. (Optional) Get the configuration used to force a full snapshot of the    virtual machine. 6. (Optional) Request a forced full snapshot for the virtual machine.  ### Finding virtual machines Get a list of the virtual machine objects known to the Rubrik cluster by sending a GET request to [&#x60;/vmware/vm&#x60;](#operation/queryVm). The Rubrik REST API server returns a response that includes a &#x60;ListResponse&#x60; object. Use query parameters as part of the GET request, to filter the list and to work with the &#x60;ListResponse&#x60; object.  A GET request that is sent to the [&#x60;/vmware/vm&#x60;](#operation/queryVm) endpoint accepts the query parameters that are described in the following table. | Parameter | Description | | --------- | ----------- | | &#x60;effective_sla_domain_id&#x60; | SLA Domain applied to the virtual machine, either directly or derived. Use &#x60;UNPROTECTED&#x60; for virtual machines that do not have a derived or direct SLA Domain. | | &#x60;primary_cluster_id&#x60; | The &#x60;id&#x60; of the primary Rubrik cluster for the virtual machine. Use &#x60;local&#x60; for the Rubrik cluster that is hosting the Rubrik REST API session. | | &#x60;limit&#x60; | Maximum number of a elements to include in the &#x60;data&#x60; array of the response. | | &#x60;offset&#x60; | Index reference point to use when determining the elements to include in the response. | | &#x60;is_relic&#x60; | Relic status of the virtual machine. &#x60;true&#x60; to specify only relic virtual machines. &#x60;false&#x60; to exclude relic virtual machines. Do not include the parameter to include both relic and non-relic virtual machines. | | &#x60;name&#x60; | String value to match in any part of the name of a virtual machine.  | | &#x60;moid&#x60; | String value to match in any part of the MOID of a virtual machine.  | | &#x60;sla_assignment&#x60; | SLA Domain assignment status of the virtual machine. Use &#x60;derived&#x60; for virtual machines that derive protection status from another resource object. Use &#x60;direct&#x60; for virtual machines that have a directly assigned SLA Domain. Use &#x60;unassigned&#x60; for virtual machines that do not have a direct or derived SLA Domain. | | &#x60;guest_os_name&#x60; | Filter by vm guest os name using infix search. | | &#x60;sort_by&#x60; | Perform an ASCII sort of the elements in the &#x60;ListResponse&#x60; object data array by a specified object value: &#x60;effective_sla_domain_id&#x60;, &#x60;name&#x60;, &#x60;moid&#x60;, &#x60;folderPath&#x60;, or &#x60;infraPath&#x60;. | | sort_order | Sort order for the elements in the ListResponse object data array. Use &#x60;asc&#x60; for ascending sort or &#x60;desc&#x60; for descending sort. |   **Example:** Retrieving a list of virtual machine resource objects  Retrieve a list of unprotected virtual machine resource objects that have &#39;test&#39; in their name. Limit the first page of the response to the first object.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm?effective_sla_domain_id&#x3D;UNPROTECTED&amp;limit&#x3D;1&amp;offset&#x3D;0&amp;name&#x3D;test\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object. The first page has the first object of the 156 objects that matched the query parameters.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$vm_id\&quot;,       \&quot;moid\&quot;: \&quot;$vm_moid\&quot;,       \&quot;name\&quot;: \&quot;abctest123\&quot;,       \&quot;vcenterId\&quot;: \&quot;$vcenter_id\&quot;,       \&quot;hostName\&quot;: \&quot;$esxi_host_name\&quot;,       \&quot;hostId\&quot;: \&quot;$esxi_host_id\&quot;,       \&quot;clusterName\&quot;: \&quot;$vcenter_cluster_name\&quot;,       \&quot;powerStatus\&quot;: \&quot;poweredOn\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Unassigned\&quot;,       \&quot;ipAddress\&quot;: \&quot;$vm_ip\&quot;,       \&quot;toolsInstalled\&quot;: true,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;isReplicationEnabled\&quot;: false,       \&quot;folderPath\&quot;: [         ...       ],       \&quot;infraPath\&quot;: [         ...       ],       \&quot;vmwareToolsInstalled\&quot;: true,       \&quot;isRelic\&quot;: false,       \&quot;maxNestedVsphereSnapshots\&quot;: -1,       \&quot;snapshotConsistencyMandate\&quot;: \&quot;UNKNOWN\&quot;,       \&quot;physicalStorage\&quot;: 0,       \&quot;guestCredentialAuthorizationStatus\&quot;: \&quot;PENDING\&quot;     }   ],   \&quot;total\&quot;: 156 } &#x60;&#x60;&#x60;  ### Retrieving more details for a virtual machine To get detailed information for a specified virtual machine object, send a GET request to [&#x60;/vmware/vm/{id}&#x60;](#operation/getVm).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details for the virtual machine object.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$vm_id\&quot;,   \&quot;moid\&quot;: \&quot;$vm_moid\&quot;,   \&quot;name\&quot;: \&quot;abctest123\&quot;,   \&quot;powerStatus\&quot;: \&quot;poweredOn\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;effectiveSlaDomain\&quot;: {     ...   },   \&quot;slaAssignment\&quot;: \&quot;Unassigned\&quot;,   \&quot;blackoutWindowStatus\&quot;: {     \&quot;isGlobalBlackoutActive\&quot;: false,     \&quot;isSnappableBlackoutActive\&quot;: false   },   \&quot;blackoutWindows\&quot;: {     ...     ],     \&quot;snappableBlackoutWindows\&quot;: []   },   \&quot;currentHost\&quot;: {     ...   },   \&quot;virtualDiskIds\&quot;: [     ...   ],   \&quot;snapshots\&quot;: [],   \&quot;ipAddress\&quot;: \&quot;$vm_ip\&quot;,   \&quot;toolsInstalled\&quot;: true,   \&quot;snapshotCount\&quot;: 0,   \&quot;snapshotConsistencyMandate\&quot;: \&quot;\&quot;,   \&quot;maxNestedVsphereSnapshots\&quot;: -1,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,   \&quot;isReplicationEnabled\&quot;: false,   \&quot;isRelic\&quot;: false,   \&quot;physicalStorage\&quot;: 0,   \&quot;guestOsName\&quot;: \&quot;$guest_os\&quot;,   \&quot;guestCredentialAuthorizationStatus\&quot;: \&quot;PENDING\&quot;,   \&quot;isArrayIntegrationPossible\&quot;: false,   \&quot;isArrayIntegrationEnabled\&quot;: false } &#x60;&#x60;&#x60;  ### Register Rubrik Backup Service  To register Rubrik Backup Service running on a specified virtual machine, send a POST request to [&#x60;/vmware/vm/{id}/register_agent&#x60;](#operation/vmRegisterAgent).  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id/register_agent\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with an HTTP 204 response when the registration is successful.   ### Enabling scripts  A virtual machine object can be configured to start scripts on the guest operating system. A script can be started before the backup (&#x60;preBackupScript&#x60;), after the snapshot completes (&#x60;postSnapScript&#x60;), and after the backup task completes (&#x60;postBackupScript&#x60;). The *Rubrik User Guide* provides information about script requirements.  To configure a virtual machine object to start scripts, send a PATCH request to [&#x60;/vmware/vm/{id}&#x60;](#operation/updateVm). Since this is a PATCH request, only the elements of the virtual machine object that are modified or added should be included in the request body. All three script members are shown in the request body in this model, but all are optional.  &#x60;&#x60;&#x60;bash curl -X PATCH \\  -d &#39;{       \&quot;preBackupScript\&quot;: {         \&quot;scriptPath\&quot;: \&quot;$pre_script_path\&quot;,         \&quot;timeoutMs\&quot;: 10000,         \&quot;failureHandling\&quot;: \&quot;abort\&quot;       },       \&quot;postSnapScript\&quot;: {         \&quot;scriptPath\&quot;: \&quot;$postsnap_script_path\&quot;,         \&quot;timeoutMs\&quot;: 10000,         \&quot;failureHandling\&quot;: \&quot;abort\&quot;       },       \&quot;postBackupScript\&quot;: {         \&quot;scriptPath\&quot;: \&quot;$postbackup_script_path\&quot;,         \&quot;timeoutMs\&quot;: 10000,         \&quot;failureHandling\&quot;: \&quot;abort\&quot;       }     }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server sends an HTTP 200 response that includes the modified or added members in the response body.  #### Manually starting a virtual machine script  For testing or to run a script before running a backup, manually trigger the script by sending a POST request to [&#x60;/vmware/vm/{id}/guest_script/run&#x60;](#operation/runGuestOsScript). To manually start a script, the script must first be a part of the configuration of the virtual machine object. Use the value of the &#x60;phase&#x60; member to identify the script, as follows: * Use &#x60;PreBackup&#x60; for the script identified by the &#x60;preBackupScript&#x60; member. * Use &#x60;PostSnap&#x60; for the script identified by the &#x60;postSnapScript&#x60; member. * Use &#x60;PostBackup&#x60; for the script identified by the &#x60;postBackupScript&#x60; member.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;phase\&quot;: \&quot;PreBackup\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id/guest_script/run\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with an HTTP 204 response when the script finishes with a 0 exit code.   ### Excluding a VMDK file  The Rubrik cluster can be configured to ignore some of the VMDK files of a virtual machine while protecting the other VMDK files of that virtual machine. To exclude a VMDK file, send a GET request to [&#x60;/vmware/vm/virtual_disk/{id}&#x60;](#operation/getVirtualDisk) using the &#x60;$disk_id&#x60; of the VMDK file.  To get the &#x60;$disk_id&#x60; values, send a GET request to [&#x60;/vmware/vm/{id}&#x60;](#operation/getVm). The response body has the &#x60;disk_id&#x60; values for the virtual machine in the &#x60;virtualDiskIds&#x60; array.  After identifying the &#x60;$disk_id&#x60; for a VMDK file, obtain the current state of the VMDK file.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the value of &#x60;excludeFromSnapshots&#x60;.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$disk_id\&quot;,   \&quot;excludeFromSnapshots\&quot;: false } &#x60;&#x60;&#x60; When the value is &#x60;false&#x60; the Rubrik cluster is not configured to exclude the VMDK file. Change this value to &#x60;true&#x60; to instruct the Rubrik cluster to exclude the VMDK file from all subsequent snapshots of the virtual machine.  Send a PATCH request to [&#x60;/vmware/vm/virtual_disk/{id}&#x60;](#operation/updateVirtualDisk) to change the value of &#x60;excludeFromSnapshots&#x60; to &#x60;true&#x60; and exclude the VMDK file.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;excludeFromSnapshots\&quot;: true }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the updated &#x60;excludeFromSnapshots&#x60; value for the VMDK file.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$disk_id\&quot;,   \&quot;excludeFromSnapshots\&quot;: true } &#x60;&#x60;&#x60;  ### Assigning a virtual machine to an SLA Domain To protect a virtual machine through the rules and policies of an SLA Domain send a PATCH request to [&#x60;/vmware/vm/{id}&#x60;](#operation/updateVm) with the value of &#x60;configuredSlaDomainId&#x60; set to the &#x60;$sla_domain_id&#x60;.  **Note:** [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains) describes how to retrieve the SLA Domain objects on a Rubrik cluster.  &#x60;&#x60;&#x60;bash curl -X PATCH -d \\   &#39;{     \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with confirmation of the assignment.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$vm_id\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot; } &#x60;&#x60;&#x60; ### Getting the configuration used to force a full snapshot of a virtual machine  To retrieve the configuration of a virtual machine that is used to force a full snapshot of the virtual machine, send a GET request to [&#x60;/vmware/vm/{id}/request/force_full_snapshot&#x60;](#operation/getVmForceFullSpec).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/{id}/request/force_full_snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the force full snapshot object which contains the latest configuration of the virtual machine.  &#x60;&#x60;&#x60;bash {   \&quot;vmId\&quot;: \&quot;$vm_id\&quot;,   \&quot;virtualDiskInfos\&quot;: [     {       \&quot;virtualDiskId\&quot;: \&quot;$disk_id\&quot;,       \&quot;shouldDedupe\&quot;: false     },     {       \&quot;virtualDiskId\&quot;: \&quot;$disk_id\&quot;,       \&quot;shouldDedupe\&quot;: true     }   ] } &#x60;&#x60;&#x60; ### Requesting a forced full snapshot for a virtual machine  To force a full snapshot of a virtual machine, send a POST request to [&#x60;/vmware/vm/{id}/request/force_full_snapshot&#x60;](#operation/requestVmForceFullSnapshot).  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/vmware/vm/{id}/request/force_full_snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server persists the configuration for forcing a full snapshot until the next backup job, which takes a full snapshot and clears the configuration.  &#x60;&#x60;&#x60;bash {   \&quot;vmId\&quot;: \&quot;$vm_id\&quot;,   \&quot;virtualDiskInfos\&quot;: [     {       \&quot;virtualDiskId\&quot;: \&quot;$disk_id\&quot;,       \&quot;shouldDedupe\&quot;: false     },     {       \&quot;virtualDiskId\&quot;: \&quot;$disk_id\&quot;,       \&quot;shouldDedupe\&quot;: true     }   ] } &#x60;&#x60;&#x60; ## Snapshot management  Managing snapshots includes the following possible actions: * Retrieving snapshot information * Retrieving snapshot information for multiple virtual machines * Retrieving snapshot details * Retrieving missed snapshot information * Creating on-demand snapshots * Expiring individual snapshots * Expiring all snapshots for a virtual machine  ### Retrieving snapshot information  To retrieve a list of the snapshots for a virtual machine, send a GET request to [&#x60;/vmware/vm/{id}/snapshot&#x60;](#operation/querySnapshot).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;date\&quot;: \&quot;$timestamp0\&quot;,       \&quot;indexState\&quot;: 0,       \&quot;cloudState\&quot;: 0,       \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,       \&quot;replicationLocationIds\&quot;: [],       \&quot;id\&quot;: \&quot;$snapshot_id0\&quot;,       \&quot;consistencyLevel\&quot;: \&quot;$consistency_level0\&quot;,       \&quot;archivalLocationIds\&quot;: [],       \&quot;isOnDemandSnapshot\&quot;: false     },     {       \&quot;date\&quot;: \&quot;$timestamp1\&quot;,       \&quot;indexState\&quot;: 0,       \&quot;cloudState\&quot;: 0,       \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,       \&quot;replicationLocationIds\&quot;: [],       \&quot;id\&quot;: \&quot;$snapshot_id1\&quot;,       \&quot;consistencyLevel\&quot;: \&quot;$consistency_level1\&quot;,       \&quot;archivalLocationIds\&quot;: [],       \&quot;isOnDemandSnapshot\&quot;: true     }  ],  \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60; Each member of the data array includes the &#x60;id&#x60; of a snapshot. Use this value (&#x60;$snapshot_id&#x60;) to perform tasks with the snapshot, such as: * Browsing for data in the snapshot * Downloading data from the snapshot * Restoring data from the snapshot * Exporting data from the snapshot * Mounting a virtual machine from the snapshot  ### Retrieving snapshot information for a batch of virtual machines  To retrieve lists of snapshots for a batch of virtual machines, send a POST request to [&#x60;/vmware/vm/snapshots&#x60;](#operation/querySnapshotsForVms). This reuqest taks a list of virtual mahine IDs.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;vm_ids\&quot;: [\&quot;vmId_1\&quot;, \&quot;vmId_2\&quot;]      }&#39;\\       \&quot;https://$cluster_address/api/v1/vmware/vm/snapshots\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;BatchVmSnapshotSummaries&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;responses\&quot;:   [     {       \&quot;vmId\&quot;: \&quot;vmId_1\&quot;,       \&quot;VmSnapshotSummaries\&quot;:       [         {           \&quot;date\&quot;: \&quot;$timestamp0\&quot;,           \&quot;indexState\&quot;: 0,           \&quot;cloudState\&quot;: 0,           \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,           \&quot;replicationLocationIds\&quot;: [],           \&quot;id\&quot;: \&quot;$snapshot_id0\&quot;,           \&quot;consistencyLevel\&quot;: \&quot;$consistency_level0\&quot;,           \&quot;archivalLocationIds\&quot;: [],           \&quot;isOnDemandSnapshot\&quot;: false         }       ]     },     {       \&quot;vmId\&quot;: \&quot;vmId_2\&quot;,       \&quot;VmSnapshotSummaries\&quot;:       [         {           \&quot;date\&quot;: \&quot;$timestamp0\&quot;,           \&quot;indexState\&quot;: 0,           \&quot;cloudState\&quot;: 0,           \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,           \&quot;replicationLocationIds\&quot;: [],           \&quot;id\&quot;: \&quot;$snapshot_id0\&quot;,           \&quot;consistencyLevel\&quot;: \&quot;$consistency_level0\&quot;,           \&quot;archivalLocationIds\&quot;: [],           \&quot;isOnDemandSnapshot\&quot;: false         }       ]     }   ] } &#x60;&#x60;&#x60;  ### Retrieving snapshot details  To retrieve details for a specified snapshot send a GET request to [&#x60;/vmware/vm/snapshot/{id}&#x60;](#operation/getSnapshot).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details of the specified snapshot.  **Note:** To shorten the example, the response uses ellipsis to replace some members.  &#x60;&#x60;&#x60;bash {   \&quot;date\&quot;: \&quot;$timestamp\&quot;,   \&quot;indexState\&quot;: 0,   \&quot;virtualMachine\&quot;: {    ...   },   \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,   \&quot;isCorrupt\&quot;: false,   \&quot;replicationLocationIds\&quot;: [],   \&quot;archivalLocationIds\&quot;: [],   \&quot;snapshotDiskIds\&quot;: [     \&quot;$vmdk_id\&quot;   ],   \&quot;isOnDemandSnapshot\&quot;: false,   \&quot;cloudState\&quot;: 0,   \&quot;id\&quot;: \&quot;$snapshot_id\&quot;,   \&quot;consistencyLevel\&quot;: \&quot;1\&quot;,   \&quot;config\&quot;: \&quot;[]\&quot; } &#x60;&#x60;&#x60;  ### Retrieving missed snapshot information  The Rubrik cluster stores information for missed snapshots. *Missed snapshots* are snapshot tasks that are not completed as required by the rules and policies of an SLA Domain.  Retrieve missed snapshot information for a virtual machine by sending  a GET request to [&#x60;/vmware/vm/{id}/missed_snapshot&#x60;](#operation/missedSnapshots).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id/missed_snapshot\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;archivalLocationType\&quot;: [         \&quot;missed\&quot;       ],       \&quot;missedSnapshotTime\&quot;: \&quot;$timestamp0\&quot;     },     {       \&quot;archivalLocationType\&quot;: [         \&quot;missed\&quot;       ],       \&quot;missedSnapshotTime\&quot;: \&quot;$timestamp1\&quot;     }   ],   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60;  ### Creating on-demand snapshots  On-demand snapshots can be created for both protected and unprotected virtual machines. To create an on-demand snapshot of a virtual machine send a POST request to [&#x60;/vmware/vm/{id}/snapshot&#x60;](#operation/createOnDemandBackup).  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server initiates the asynchronous snapshot task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;ACQUIRING\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60; Using the information provided in the task object, send a GET request to poll the task status. When the value of &#x60;status&#x60; in the task object is &#x60;SUCCEEDED&#x60;, the on-demand snapshot finished successfully.   &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server sends a task object with &#x60;status&#x3D;\&quot;SUCCEEDED\&quot;&#x60;.  The task object for a successful snapshot includes the URI for the snapshot: &#x60;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id&#x60;.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;:\&quot;$request_id\&quot;,   \&quot;status\&quot;:\&quot;SUCCEEDED\&quot;,   \&quot;startTime\&quot;:\&quot;$timestamp0\&quot;,   \&quot;endTime\&quot;:\&quot;$timestamp1\&quot;,   \&quot;links\&quot;:[     {       \&quot;href\&quot;:\&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id\&quot;,       \&quot;rel\&quot;:\&quot;result\&quot;     },    {       \&quot;href\&quot;:\&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       \&quot;rel\&quot;:\&quot;self\&quot;    }   ] } &#x60;&#x60;&#x60;  ### Expiring individual snapshots  On-demand snapshots and snapshots for unprotected virtual machines can be expired by using the snapshot &#x60;id&#x60;. To expire an individual snapshot, send a DELETE request to [&#x60;/vmware/vm/snapshot/{id}&#x60;](#operation/deleteVmwareSnapshot). Include the query parameter &#x60;location&#x60; to specify whether to expire all copies of the snapshot, or only the local copy. Use &#x60;location&#x3D;local&#x60; to expire only the copy of the snapshot on the specified Rubrik cluster. Use &#x60;location&#x3D;all&#x60; to expire all copies of the snapshot, including replicas and archival copies.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id?location&#x3D;$snapshot_location\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server expires the specified snapshot and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  The Rubrik REST API server responds with HTTP response code 422 &#39;Unprocessable Entity&#39;, when the specified snapshot is not one of the following: * On-demand snapshot * Snapshot for an unprotected virtual machine  ### Expiring all snapshots for a virtual machine  All snapshots for an unprotected virtual machine can be expired by using the virtual machine &#x60;id&#x60;. To expire all snapshots for an unprotected virtual machine, send a DELETE request to [&#x60;/vmware/vm/{id}/snapshot&#x60;](#operation/deleteVmwareSnapshots). The Rubrik cluster expires all snapshots, replicas, and archival snapshots for the specified virtual machine.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server expires all snapshots for the specified virtual machine in all locations and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  The Rubrik REST API server responds with HTTP response code 422 &#39;Unprocessable Entity&#39;, when the specified virtual machine is protected through an SLA Domain assignment.     ## Data recovery To recover a file or folder from a snapshot, retrieve the &#x60;id&#x60; of the file or folder using either search or browse. Then use the &#x60;id&#x60; with one of the recovery methods: * Download the file or folder * Restore the file or folder to the source location * Export the file or folder to another host  ### Searching for data in snapshots  Search for files and folders across all indexed snapshots of a virtual machine by using the virtual machine &#x60;id&#x60;. Send a GET request to [&#x60;/vmware/vm/{id}/search&#x60;](#operation/searchVm) with the &#x60;path&#x60; query parameter. Use a path segment string or a name segment string for the value of &#x60;path&#x60;.  **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [&#x60;/vmware/vm/snapshot/{id}&#x60;](#operation/getSnapshot) as described in the &#39;Retrieving snapshot information&#39; section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of &#x60;indexState&#x60;. A value of &#x60;1&#x60; means the snapshot has been indexed. A value of &#x60;0&#x60; means the snapshot has not been indexed.  The Rubrik REST API server uses the rules described in the following table when matching the value of &#x60;path&#x60; with folders and files in the indexed snapshots. | Type | Rule | Description | | ---- | ---- | ----------- | | Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, &#x60;/&#x60; matches both &#x60;/&#x60; and &#x60;\\&#x60;, and &#x60;\\&#x60; matches both &#x60;/&#x60; and &#x60;\\&#x60;. | | Path segments | Path segments match all files and folders that begin with the same path segment. | For example, &#39;/abc/x&#39; matches files and folders at &#39;/abc/&#39; or &#39;\\abc\\\\&#39; with a filename or folder name that starts with &#39;x&#39;. | | Name segments | Name segments match all files and folders that begin with the same name segment. | For example, &#39;xyz&#39; matches files and folders with a filename or folder name that starts with &#39;xyz&#39;, in all path locations. | | Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol &#x60;&gt;&#x60; and the lesser than symbol &#x60;&lt;&#x60; are not allowed. | | Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the &#39;temp&#39; folder on the &#39;D&#39; drive of a Windows virtual machine, use: &#x60;D:\\temp&#x60;. |  **Example:** Searching for files and folders  Search for all files and folders in &#39;/usr/local/&#39; with a name that starts with the later &#39;g&#39;.  Send a GET request to [&#x60;/vmware/vm/{id}/search&#x60;](#operation/searchVm) with &#x60;path&#x3D;/usr/local/g&#x60;.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm/$vm_id/search?path&#x3D;%2Fusr%2Flocal%2Fg\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object. The data array has two members, a directory at: &#x60;/usr/local/games&#x60; and a file at: &#x60;/usr/local/gamehints&#x60;.   &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;path\&quot;: \&quot;/usr/local/games\&quot;,       \&quot;filename\&quot;: \&quot;games\&quot;,       \&quot;fileVersions\&quot;: [         {           \&quot;lastModified\&quot;: \&quot;$timestamp0\&quot;,           \&quot;size\&quot;: 4096,           \&quot;snapshotId\&quot;: \&quot;$snapshot_id0\&quot;,           \&quot;fileMode\&quot;: \&quot;directory\&quot;,           \&quot;source\&quot;: \&quot;cloud\&quot;         }       ]     },     {     \&quot;path\&quot;: \&quot;/usr/local/gamehints\&quot;,     \&quot;filename\&quot;: \&quot;gamehints\&quot;,     \&quot;fileVersions\&quot;: [       {         \&quot;lastModified\&quot;: \&quot;$timestamp1\&quot;,         \&quot;size\&quot;: 14480,         \&quot;snapshotId\&quot;: \&quot;$snapshot_id1\&quot;,         \&quot;fileMode\&quot;: \&quot;file\&quot;,         \&quot;source\&quot;: \&quot;cloud\&quot;       },       {         \&quot;lastModified\&quot;: \&quot;$timestamp2\&quot;,         \&quot;size\&quot;: 14480,         \&quot;snapshotId\&quot;: \&quot;$snapshot_id2\&quot;,         \&quot;fileMode\&quot;: \&quot;file\&quot;,         \&quot;source\&quot;: \&quot;cloud\&quot;       }     ]    }   ],   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60;  ### Browsing for data in snapshots  Browse for files and folders with an indexed snapshot by using the snapshot &#x60;id&#x60;. Send a GET request to  [&#x60;/vmware/vm/snapshot/{id}/browse&#x60;](#operation/browseVmwareSnapshot) with the &#x60;path&#x60; query parameter.  Use a path segment string for the value of &#x60;path&#x60;. The response provides a ListResponse object that includes all of the files and folders in the directory that is specified by the value of &#x60;path&#x60;.  **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [&#x60;/vmware/vm/snapshot/{id}&#x60;](#operation/getSnapshot) as described in the &#39;Retrieving snapshot information&#39; section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of &#x60;indexState&#x60;. A value of &#x60;1&#x60; means the snapshot has been indexed. A value of &#x60;0&#x60; means the snapshot has not been indexed.  The Rubrik REST API server uses the rules described in the following table when matching the value of &#x60;path&#x60; with the path in the specified snapshot. | Type | Rule | Description | | ---- | ---- | ----------- | | Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, &#x60;/&#x60; matches both &#x60;/&#x60; and &#x60;\\&#x60;, and &#x60;\\&#x60; matches both &#x60;/&#x60; and &#x60;\\&#x60;. | | Path description | The path description must end in a directory name, without an ending slash. | For example, &#39;/abc/x&#39; returns all files and folders in the directory at &#39;/abc/x&#39;, but &#39;/abc/x/&#39; returns an HTTP 422 response. | | Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol &#x60;&gt;&#x60; and the lesser than symbol &#x60;&lt;&#x60; are not allowed. | | Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the &#39;temp&#39; folder on the &#39;D&#39; drive of a Windows virtual machine, use: &#x60;D:\\temp&#x60;. |  **Example:** Browsing for files and folders  Retrieve a ListResponse object with all of the files and folders in &#39;/home&#39;.  Send a GET request to  [&#x60;/vmware/vm/snapshot/{id}/browse&#x60;](#operation/browseVmwareSnapshot) with &#x60;path&#x3D;/home&#x60;.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/browse?path&#x3D;%2Fhome&amp;offset&#x3D;0\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object. The data array has two members, the directory: &#x60;ubuntu&#x60; and the file: &#x60;ubuntu.tar&#x60;.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;filename\&quot;: \&quot;ubuntu\&quot;,       \&quot;path\&quot;: \&quot;ubuntu\&quot;,       \&quot;lastModified\&quot;: \&quot;$timestamp0\&quot;,       \&quot;size\&quot;: 31892819777,       \&quot;fileMode\&quot;: \&quot;directory\&quot;,       \&quot;statusMessage\&quot;: \&quot;\&quot;     },     {       \&quot;filename\&quot;: \&quot;ubuntu.tar\&quot;,       \&quot;path\&quot;: \&quot;ubuntu.tar\&quot;,       \&quot;lastModified\&quot;: \&quot;$timestamp1\&quot;,       \&quot;size\&quot;: 4746675383,       \&quot;fileMode\&quot;: \&quot;file\&quot;,       \&quot;statusMessage\&quot;: \&quot;\&quot;     }   ],   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60; ### Downloading data from a snapshot  Data can be retrieved from a snapshot by creating a download link for an individual file and folder from the snapshot. To have the Rubrik cluster create a download link, send a POST request to [&#x60;/vmware/vm/snapshot/{id}/download&#x60;](#operation/createDownloadFileJob). Include in the request body the string/value pair: &#x60;\&quot;path\&quot;:\&quot;$path\&quot;&#x60;, where &#x60;$path&#x60; is the full path to the file or folder. When &#x60;$path&#x60; refers to a folder, the Rubrik cluster creates a ZIP file of the folder and all that it contains.  The basic download work flow is: 1. Send a POST request to start the asynchronous download task. 2. Send a GET request to poll the task status. 3. When the task succeeds, use the download link provided in the response body to retrieve the file or folder.  **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [&#x60;/vmware/vm/snapshot/{id}&#x60;](#operation/getSnapshot) as described in the &#39;Retrieving snapshot information&#39; section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of &#x60;indexState&#x60;. A value of &#x60;1&#x60; means the snapshot has been indexed. A value of &#x60;0&#x60; means the snapshot has not been indexed.  &#x60;&#x60;&#x60;bash curl -X POST -d \\ &#39;{    \&quot;path\&quot;: \&quot;$full_source_path\&quot;  }&#39; \\  &#39;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download_file&#39; &#x60;&#x60;&#x60; The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$download_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Restoring data from a snapshot  To restore a file or folder to the source virtual machine send a POST request to [&#x60;/vmware/vm/snapshot/{id}/restore_file&#x60;](#operation/createRestoreFileJob). With the request, include a request body. The following table describes the members of the request body.  | Name | Description | | ---- | ----------- | | &#x60;path&#x60; | Full path of the file or folder. | | &#x60;domainName&#x60; | Authentication domain for the credentials being used to authenticate and authorize the action. | | &#x60;username&#x60; | Username of account to authenticate and authorize the action. | | &#x60;password&#x60; | Password for the account to authenticate and authorize the action. | | &#x60;restorePath&#x60; | Full path location for the restore of the file or folder. The action can create a directory at the end of the specified path, but cannot create directories that are specified within the path. | | &#x60;shouldUseAgent&#x60; | Instruct the Rubrik cluster to restore the file using Rubrik Backup Service running on virtual machine. Use &#x60;true&#x60; to restore using RBS and &#x60;false&#x60; to restore using &#x60;VMware tools&#x60;. | | &#x60;shouldSaveCredentials&#x60; | Instruct the Rubrik cluster to save the credentials included in the request. Use &#x60;true&#x60; to save the credentials and &#x60;false&#x60; to use the credentials only for the current request. | | &#x60;shouldRestoreXAttrs&#x60; | Instruct the Rubrik cluster to restore the extended attributes of all files and folders included in the &#x60;path&#x60;. When restoring to a Linux host, extended attributes are restored. When restoring to a Windows host, alternate data streams (ADS) are restored. Use &#x60;true&#x60; to restore this metadata and &#x60;false&#x60; otherwise. |  &#x60;&#x60;&#x60;bash curl -X POST -d \\ &#39;{    \&quot;path\&quot;: \&quot;$full_source_path\&quot;,    \&quot;domainName\&quot;: \&quot;$auth_domain\&quot;,    \&quot;username\&quot;: \&quot;$username\&quot;,    \&quot;password\&quot;: \&quot;$password\&quot;,    \&quot;restorePath\&quot;: \&quot;$full_restore_path\&quot;,    \&quot;shouldUseAgent\&quot; : true,    \&quot;shouldSaveCredentials\&quot;: true,    \&quot;shouldRestoreXAttrs\&quot;: true  }&#39; \\  \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/restore_file\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$restore_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;   ## Snapshot mount operations Snapshot mount operations include the following possible actions: * Retrieving a snapshot from an archival location * Mounting a snapshot by using Instant Recovery * Mounting a snapshot by using Live Mount * Mounting a snapshot for a batch of virtual machines using Live Mount * Exporting a snapshot * Downloading a snapshot from an archival location and then exporting it * Changing the properties of a mounted virtual machine * Removing a virtual machine mount * Migrating a datastore for a virtual machine from Live Mount or Instant Recovery  ### Retrieving a snapshot from an archival location  To work with a snapshot that is stored only at an archival location, first download the snapshot to the Rubrik cluster by sending a POST request to [&#x60;/vmware/vm/snapshot/{id}/download&#x60;](#operation/createDownloadSnapshotFromCloud).  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$snap_download_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Mounting a snapshot by using Instant Recovery  Replace a source virtual machine from a snapshot by using the Instant Recovery feature. To use Instant Recovery, send a POST request to [&#x60;/vmware/vm/snapshot/{id}/instant_recover&#x60;](#operation/createInstantRecovery). This request requires a snapshot &#x60;id&#x60; and can optionally include the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | &#x60;hostId&#x60; | The &#x60;id&#x60; of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. | | &#x60;vmName&#x60; | Assigns a specified name to the virtual machine. | | &#x60;removeNetworkDevices&#x60; | Determines whether the virtual machine has network devices. Use &#x60;true&#x60; to remove network devices from the virtual machine. Use &#x60;false&#x60; to keep the existing network devices. |  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,     \&quot;hostId\&quot;: \&quot;$esxi_id\&quot;,     \&quot;removeNetworkDevices\&quot;: true    }&#39; \\    \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/instant_recover\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$instant_recovery_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Mounting a snapshot by using Live Mount  Mount a new virtual machine from a snapshot by using the Live Mount feature. To use Live Mount, send a POST request to [&#x60;/vmware/vm/snapshot/{id}/mount&#x60;](#operation/createMountV1). This request requires a snapshot &#x60;id&#x60; and can optionally include the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | &#x60;hostId&#x60; | The &#x60;id&#x60; of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. | | &#x60;vmName&#x60; | Assigns a specified name to the virtual machine. | | &#x60;dataStoreName&#x60; | Obsolete paraemeter. | | &#x60;disableNetwork&#x60; | Determines whether the virtual machine has access to the network. Use &#x60;true&#x60; to Mount the snapshot with network access disabled. Use &#x60;false&#x60; to allow the virtual machine to access the network. | | &#x60;removeNetworkDevices&#x60; | Determines whether the virtual machine has network devices. Use &#x60;true&#x60; to remove network devices from the virtual machine. Use &#x60;false&#x60; to keep the existing network devices. | | &#x60;powerOn&#x60; | Determines whether the virtual machine is powered on after mounting. Use &#x60;true&#x60; to power on the virtual machine. Use &#x60;false&#x60; to leave the virtual machine powered off after mounting. |   &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;hostId\&quot;: \&quot;$esxi_id\&quot;,      \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,      \&quot;dataStoreName\&quot;: \&quot;$datastore_name\&quot;,      \&quot;disableNetwork\&quot;: $network_state,      \&quot;removeNetworkDevices\&quot;: $network_devices_state,      \&quot;powerOn\&quot;: $power_state    }&#39;\\     \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$live_mount_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Mounting a snapshot for a batch of virtual machines using Live Mount  Mount a snapshot each for a batch of virtual machines. Send a POST request to [&#x60;/vmware/vm/batch_mount&#x60;](#operation/batchMountSnapshot). This request requires a snapshots parameter to identify the virtual machine and the snapshot of the virtual machine to mount. The following parameters are available to identify the snapshot: &#x60;snapshotId&#x60;, &#x60;snapshotBeforeDate&#x60;, and &#x60;snapshotAfterDate&#x60;. One of the parameters must be configured to identify the snapshot to be mounted.  | Name | Required | Type | Description | | ---- | -------- | ---- | ----------- | | &#x60;vmId&#x60; | Required | String | The &#x60;id&#x60; of the virtual machine. | | &#x60;snapshotId&#x60; | Optional | String | The &#x60;id&#x60; of the snapshot to mount. | | &#x60;snapshotBeforeDate&#x60; | Optional | Date | If the snapshotId is not specified, mount the newest snapshot before the date specified for this parameter. | | &#x60;snapshotAfterDate&#x60; | Optional | Date | If the snapshotId and the snapshotBeforeDate are not specified, mount the oldest snapshot after the date specified for this parameter. | | &#x60;config&#x60; | Required | Object | [Properties of the /vmware/vm/snapshot/{id}/mount endpoint.](#mounting-a-snapshot-by-using-live-mount) |  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;snapshots\&quot;: [        {          \&quot;vmId\&quot;: \&quot;$vm_id\&quot;,          \&quot;snapshotBeforeDate\&quot;: \&quot;$timestamp\&quot;,          \&quot;config\&quot;: {            \&quot;hostId\&quot;: \&quot;$esxi_id\&quot;,            \&quot;vmName\&quot;: \&quot;$vm_name\&quot;,            \&quot;dataStoreName\&quot;: \&quot;$datastore_name\&quot;,            \&quot;disableNetwork\&quot;: $network_state,            \&quot;removeNetworkDevices\&quot;: $network_devices_state,            \&quot;powerOn\&quot;: $power_state          }        }      ]      }&#39;\\       \&quot;https://$cluster_address/api/v1/vmware/vm/batch_mount\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates a batch of mount jobs and resonds with objects tracking the job status.  &#x60;&#x60;&#x60;bash {   \&quot;responses\&quot;: [     {       \&quot;id\&quot;: \&quot;$live_mount_task_id\&quot;,       \&quot;status\&quot;: \&quot;QUEUED\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ]     }   ] } &#x60;&#x60;&#x60; ### Retrieving the ID of the mount  After a mount task successfully completes, the &#x60;id&#x60; of the mount object can be retrieved by sending a GET request to [&#x60;/vmware/vm/request/{id}&#x60;](#operation/getAsyncRequestStatus) and using the &#x60;$request_id&#x60; value from the original request object for the Live Mount.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a request object that includes the &#x60;id&#x60; of the mount object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\&quot;,       \&quot;rel\&quot;: \&quot;result\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot; } &#x60;&#x60;&#x60; ### Retrieving active mounts  To retrieve a list of all of the active mounts for a Rubrik cluster, send a GET request to [&#x60;/vmware/vm/snapshot/mount&#x60;](#operation/queryMountV1).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/mount\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a ListResponse object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$mount_id\&quot;,       \&quot;snapshotDate\&quot;: \&quot;$snapshot_timestamp\&quot;,       \&quot;vmId\&quot;: \&quot;$source_vm_id\&quot;,       \&quot;mountedVmId\&quot;: \&quot;$mounted_vm_id\&quot;,       \&quot;hostId\&quot;: \&quot;$esxi_id\&quot;,       \&quot;isReady\&quot;: true     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60; ### Retrieving the details for a mount  To retrieve details about a specific mount, send a GET request to [&#x60;/vmware/vm/snapshot/mount/{id}&#x60;](#operation/getMountV1).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details.  &#x60;&#x60;&#x60;bash {   \&quot;snapshotDate\&quot;: \&quot;$timestamp\&quot;,   \&quot;vmId\&quot;: \&quot;$source_vm_id\&quot;,   \&quot;isReady\&quot;: true,   \&quot;hostId\&quot;: \&quot;$esxi_id\&quot;,   \&quot;id\&quot;: \&quot;$mount_id\&quot;,   \&quot;mountedVmId\&quot;: \&quot;$mounted_vm_id\&quot; } &#x60;&#x60;&#x60;  ### Exporting a snapshot  To export a snapshot send a POST request to [&#x60;/vmware/vm/snapshot/{id}/export&#x60;](#operation/createExportV1). This request requires a snapshot &#x60;id&#x60; and the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | &#x60;datastoreId&#x60; | The &#x60;id&#x60; of a datastore for the specified ESXi hypervisor. | | &#x60;vmName&#x60; | Assigns a specified name to the virtual machine. | | &#x60;hostId&#x60; | The &#x60;id&#x60; of an ESXi hypervisor. | | &#x60;disableNetwork&#x60; | Determines whether the virtual machine has access to the network. Use &#x60;true&#x60; to Mount the snapshot with network access disabled. Use &#x60;false&#x60; to allow the virtual machine to access the network. | | &#x60;removeNetworkDevices&#x60; | Determines whether the virtual machine has network devices. Use &#x60;true&#x60; to remove network devices from the virtual machine. Use &#x60;false&#x60; to keep the existing network devices. | | &#x60;powerOn&#x60; | Determines whether the virtual machine is powered on after mounting. Use &#x60;true&#x60; to power on the virtual machine. Use &#x60;false&#x60; to leave the virtual machine powered off after mounting. | | &#x60;unregisterVm&#x60; | Determines whether to add the exported virtual machine to the vCenter Server inventory. Use &#x60;true&#x60; to remove the exported virtual machine from the associated vCenter Server inventory. Use &#x60;false&#x60; to add the exported virtual machine to the associated vCenter Server inventory. |   &#x60;&#x60;&#x60;bash curl -X  -d \\  &#39;{    \&quot;datastoreId\&quot;: \&quot;string\&quot;,    \&quot;vmName\&quot;: \&quot;string\&quot;,    \&quot;hostId\&quot;: \&quot;string\&quot;,    \&quot;disableNetwork\&quot;: true,    \&quot;removeNetworkDevices\&quot;: true,    \&quot;powerOn\&quot;: true,    \&quot;unregisterVm\&quot;: true  }&#39; \\  \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/export\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$export_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Exporting a snapshot from an archival location  To export a snapshot from an archival location, send a POST request to [&#x60;/vmware/vm/snapshot/{id}/export_with_download&#x60;] (#operation/createExportWithDownloadFromCloudV1). This request requries a snapshot &#x60;id&#x60; and the parameters that are described in the following table.  | Name | Description | | ---- | ----------- | | &#x60;datastoreId&#x60; | &#x60;id&#x60; of a datastore for the specified ESXi hypervisor. | | &#x60;vmName&#x60; | Assigns a name to the virtual machine. | | &#x60;hostId&#x60; | &#x60;id&#x60; of an ESXi hypervisor. | | &#x60;disableNetwork&#x60; | Determines if the virtual machine has access to the                      network. &#x60;true&#x60; mounts the snapshot with network                      access disabled. &#x60;false&#x60; allows the virtual machine                      to access the network. | | &#x60;removeNetworkDevices&#x60; | Determines if the virtual machine includes network                            devices. &#x60;true&#x60; removes network devices from                            the virtual machine.&#x60;false&#x60; keeps the existing                            network devices. | | &#x60;powerOn&#x60; | Determines if the virtual machine is powered on after               mounting. &#x60;true&#x60; powers on the virtual machine. &#x60;false&#x60;               leaves the virtual machine powered off after mounting. | | &#x60;unregisterVm&#x60; | Determines if the exported virtual machine is added to                    the vCenter Server inventory. &#x60;true&#x60; removes the exported                    virtual machine from the associated vCenter Server                    inventory. &#x60;false&#x60; adds the exported virtual machine                    to the associated vCenter Server inventory. |  &#x60;&#x60;&#x60;bash curl -X  -d \\  &#39;{    \&quot;datastoreId\&quot;: \&quot;string\&quot;,    \&quot;vmName\&quot;: \&quot;string\&quot;,    \&quot;hostId\&quot;: \&quot;string\&quot;,    \&quot;disableNetwork\&quot;: true,    \&quot;removeNetworkDevices\&quot;: true,    \&quot;powerOn\&quot;: true,    \&quot;unregisterVm\&quot;: true  }&#39; \\  \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/$id/export_with_download\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$download_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;:          \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Changing power status of a mounted virtual machine  To change the power status of a mounted virtual machine send a PATCH request to [&#x60;/vmware/vm/snapshot/mount/{id}&#x60;](#operation/updateMount). Include in the request body, the member &#x60;\&quot;powerStatus\&quot;: $power_state&#x60;. For &#x60;$power_state&#x60;, use &#x60;true&#x60; to power on the virtual machine, or use &#x60;false&#x60; to power off the virtual machine.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;powerStatus\&quot;: $power_state }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the mount details.  &#x60;&#x60;&#x60;bash {   \&quot;powerStatus\&quot;: \&quot;$power_state\&quot;,   \&quot;id\&quot;: \&quot;$mount_id\&quot;,   \&quot;snapshotDate\&quot;: \&quot;$timestamp\&quot;,   \&quot;vmId\&quot;: \&quot;$vm_id\&quot;,   \&quot;mountedVmId\&quot;: \&quot;$mounted_vm_id\&quot;,   \&quot;hostId\&quot;: \&quot;$esxi_id\&quot;,   \&quot;isReady\&quot;: true,   \&quot;mountRequestId\&quot;: \&quot;$mount_request_id\&quot;,   \&quot;unmountRequestId\&quot;: \&quot;$unmount_request_id\&quot; } &#x60;&#x60;&#x60;  ### Removing a virtual machine mount  To remove a Live Mount send a DELETE request to [&#x60;/vmware/vm/snapshot/mount/{id}&#x60;](#operation/createUnmount). To remove a mount object after live migration of the virtual machine include the query parameter &#x60;force&#x3D;true&#x60;.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$delete_mount_task_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vcenter/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Get recoverable ranges for a CDP-enabled virtual machine  For a list of time ranges to which a CDP-enabled virtual machine can recover, send a GET request to [&#x60;/vmware/vm/{id}/recoverable_range&#x60;](#operation/getVmwareRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch. Any point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/$vm_id/recoverable_range &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     \&quot;beginTime\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;,     \&quot;endTime\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Get missed recoverable ranges for a CDP-enabled virtual machine  For a list of time ranges to which a CDP-enabled virtual machine cannot recover to, send a GET request to [&#x60;/vmware/vm/{id}/missed_recoverable_range&#x60;](#operation/getVmwareMissedRecoverableRanges). The time range start and end timestamps are specified as milliseconds from epoch. Any point-in-time recovery operation from version 2 of the API can use the time ranges returned by this API call for any CDP-enabled virtual machine.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/$vm_id/missed_recoverable_range &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     \&quot;beginTime\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;,     \&quot;endTime\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Migrating a datastore for a virtual machine from Live Mount or Instant Recovery  Send a POST request to [&#x60;/vmware/vm/snapshot/mount/{id}/relocate&#x60;](#operation/relocateMount) to migrate a datastore for a virtual machine created from Live Mount or Instant Recovery.   ### Get compute cluster information  VMware compute cluster can be found by a GET on [&#x60;/vmware/compute_cluster&#x60;](#operation/queryComputeCluster).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/compute_cluster\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;compute_cluster_id\&quot;,       \&quot;name\&quot;: \&quot;compute_cluster_name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;configured_sla_domain_id\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;configured_sla_domain_name\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;primary_cluster_id\&quot;,       \&quot;datacenterId\&quot;: \&quot;datacenter_id\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;effective_sla_domain_id\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;effective_sla_domain_name\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;effective_sla_source_object_id\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;effective_sla_source_object_name\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Further details are acquired from GET [&#x60;/vmware/compute_cluster/{id}&#x60;](#operation/getComputeCluster).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;compute_cluster_id\&quot;,   \&quot;name\&quot;: \&quot;compute_cluster_name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;configured_sla_domain_id\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;configured_sla_domain_name\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;primary_cluster_id\&quot;,   \&quot;datacenterId\&quot;: \&quot;datacenter_id\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;effective_sla_domain_id\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;effective_sla_domain_name\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;effective_sla_source_object_id\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;effective_sla_source_object_name\&quot;   \&quot;moid\&quot;: \&quot;compute_cluster_moid\&quot;,   \&quot;hosts\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;string\&quot;,       \&quot;datacenterId\&quot;: \&quot;string\&quot;,       \&quot;computeClusterId\&quot;: \&quot;string\&quot;,       \&quot;datastores\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;,           \&quot;capacity\&quot;: 0,           \&quot;dataStoreType\&quot;: \&quot;string\&quot;,           \&quot;dataCenterName\&quot;: \&quot;string\&quot;,           \&quot;isLocal\&quot;: true          }       ],       \&quot;effectiveSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;string\&quot;     }   ], \&quot;virtualMachines\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;string\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;string\&quot;,       \&quot;moid\&quot;: \&quot;string\&quot;,       \&quot;vcenterId\&quot;: \&quot;string\&quot;,       \&quot;hostName\&quot;: \&quot;string\&quot;,       \&quot;hostId\&quot;: \&quot;string\&quot;,       \&quot;clusterName\&quot;: \&quot;string\&quot;,       \&quot;snapshotConsistencyMandate\&quot;: \&quot;UNKNOWN\&quot;,       \&quot;powerStatus\&quot;: \&quot;string\&quot;,       \&quot;protectionDate\&quot;: \&quot;2018-10-02T20:33:03.833Z\&quot;,       \&quot;ipAddress\&quot;: \&quot;string\&quot;,       \&quot;agentStatus\&quot;: {         \&quot;agentStatus\&quot;: \&quot;string\&quot;,         \&quot;disconnectReason\&quot;: \&quot;string\&quot;       },       \&quot;toolsInstalled\&quot;: true,       \&quot;isReplicationEnabled\&quot;: true,       \&quot;folderPath\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;managedId\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;         }       ],       \&quot;infraPath\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;managedId\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;         }       ],       \&quot;vmwareToolsInstalled\&quot;: true,       \&quot;isRelic\&quot;: true,       \&quot;guestCredentialAuthorizationStatus\&quot;: \&quot;string\&quot;,       \&quot;cloudInstantiationSpec\&quot;: {         \&quot;imageRetentionInSeconds\&quot;: 0       },       \&quot;parentAppInfo\&quot;: {         \&quot;id\&quot;: \&quot;string\&quot;,         \&quot;isProtectedThruHierarchy\&quot;: true       }     }   ] } &#x60;&#x60;&#x60;  configuredSlaDomainId could be updated by a PATCH [&#x60;/vmware/compute_cluster/{id}&#x60;](#operation/updateComputeCluster).  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;sla_assignable\&quot;: $sla_domain }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/compute_cluster/$compute_clustere_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;compute_cluster_id\&quot;,   \&quot;name\&quot;: \&quot;compute_cluster_name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;configured_sla_domain_id\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;configured_sla_domain_name\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;primary_cluster_id\&quot;,   \&quot;datacenterId\&quot;: \&quot;datacenter_id\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;effective_sla_domain_id\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;effective_sla_domain_name\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;effective_sla_source_object_id\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;effective_sla_source_object_name\&quot;   \&quot;moid\&quot;: \&quot;compute_cluster_moid\&quot;,   \&quot;hosts\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;string\&quot;,       \&quot;datacenterId\&quot;: \&quot;string\&quot;,       \&quot;computeClusterId\&quot;: \&quot;string\&quot;,       \&quot;datastores\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;,           \&quot;capacity\&quot;: 0,           \&quot;dataStoreType\&quot;: \&quot;string\&quot;,           \&quot;dataCenterName\&quot;: \&quot;string\&quot;,           \&quot;isLocal\&quot;: true          }       ],       \&quot;effectiveSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;string\&quot;     }   ], \&quot;virtualMachines\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;string\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;string\&quot;,       \&quot;moid\&quot;: \&quot;string\&quot;,       \&quot;vcenterId\&quot;: \&quot;string\&quot;,       \&quot;hostName\&quot;: \&quot;string\&quot;,       \&quot;hostId\&quot;: \&quot;string\&quot;,       \&quot;clusterName\&quot;: \&quot;string\&quot;,       \&quot;snapshotConsistencyMandate\&quot;: \&quot;UNKNOWN\&quot;,       \&quot;powerStatus\&quot;: \&quot;string\&quot;,       \&quot;protectionDate\&quot;: \&quot;2018-10-02T20:33:03.833Z\&quot;,       \&quot;ipAddress\&quot;: \&quot;string\&quot;,       \&quot;agentStatus\&quot;: {         \&quot;agentStatus\&quot;: \&quot;string\&quot;,         \&quot;disconnectReason\&quot;: \&quot;string\&quot;       },       \&quot;toolsInstalled\&quot;: true,       \&quot;isReplicationEnabled\&quot;: true,       \&quot;folderPath\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;managedId\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;         }       ],       \&quot;infraPath\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;managedId\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;         }       ],       \&quot;vmwareToolsInstalled\&quot;: true,       \&quot;isRelic\&quot;: true,       \&quot;guestCredentialAuthorizationStatus\&quot;: \&quot;string\&quot;,       \&quot;cloudInstantiationSpec\&quot;: {         \&quot;imageRetentionInSeconds\&quot;: 0       },       \&quot;parentAppInfo\&quot;: {         \&quot;id\&quot;: \&quot;string\&quot;,         \&quot;isProtectedThruHierarchy\&quot;: true       }     }   ] } &#x60;&#x60;&#x60;  ### Query asynchronous job status for VMware compute cluster  To query the job status details of an asynchronous job that is related to an VMware compute cluster with a GET to [&#x60;/vmware/compute_cluster/request/{id}&#x60;](#operation/getAsyncRequestStatusForComputeCluster).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/compute_cluster/request/$job_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;endTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  ### VMware IO filters operations  All IO filters on a specific VMware compute cluster can be found with a GET on [&#x60;/vmware/compute_cluster/{id}/io_filter&#x60;](#operation/getIoFilters).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/io_filter\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;version\&quot;: \&quot;string\&quot;,       \&quot;vendor\&quot;: \&quot;string\&quot;,       \&quot;releaseDate\&quot;: \&quot;string\&quot;,       \&quot;summary\&quot;: \&quot;string\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Install the latest version of Rubrik IO filter to a specific VMware compute cluster with a POST on [&#x60;/vmware/compute_cluster/{id}/install_io_filter&#x60;](#operation/installIoFilter).  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/install_io_filter\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;endTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  Uninstall the Rubrik IO filter from a specific VMware compute cluster with a POST on [&#x60;/vmware/compute_cluster/{id}/uninstall_io_filter&#x60;](#operation/uninstallIoFilter).  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/uninstall_io_filter\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;endTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  Update the Rubrik IO filter to the latest version for a specific VMware compute cluster with a POST on [&#x60;/vmware/compute_cluster/{id}/upgrade_io_filter&#x60;](#operation/upgradeIoFilter).  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/vmware/compute_cluster/$compute_cluster_id/upgrade_io_filter\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;endTime\&quot;: \&quot;2018-10-02T20:33:03.933Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Getting Live CDP fields for a batch of CDP-enabled virtual machines  Send a POST request to [&#x60;/vmware/vm/cdp&#x60;](#operation/getVmwareCdpLiveInfo). The request takes a list of virtual machine IDs that correspond to CDP-enabled virtual machines as a mandatory parameter named &#39;ids&#39;.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;ids\&quot;: [\&quot;id_1\&quot;, \&quot;id_2\&quot;]      }&#39;\\       \&quot;https://$cluster_address/api/v1/vmware/vm/cdp\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {     \&quot;vmId\&quot;: \&quot;id_1\&quot;,     \&quot;localRecoveryPoint\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;,     \&quot;remoteRecoveryPoint\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;     },     {     \&quot;vmId\&quot;: \&quot;id_2\&quot;,     \&quot;localRecoveryPoint\&quot;: \&quot;\&quot;,     \&quot;remoteRecoveryPoint\&quot;: \&quot;\&quot;     }   ]   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60; ### Getting CDP State fields for a batch of CDP-enabled virtual machines  Send a POST request to [&#x60;/vmware/vm/cdp_state&#x60;](#operation/getVmwareCdpStateInfo). The request takes a list of virtual machine IDs that correspond to CDP-enabled virtual machines as a mandatory parameter named &#39;ids&#39;.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;ids\&quot;: [\&quot;id_1\&quot;, \&quot;id_2\&quot;]      }&#39;\\       \&quot;https://$cluster_address/api/v1/vmware/vm/cdp_state\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {     \&quot;vmId\&quot;: \&quot;id_1\&quot;,     \&quot;localStatus\&quot;: \&quot;Active\&quot;,     \&quot;replicationStatus\&quot;: \&quot;Healthy\&quot;,     \&quot;healthPercentage\&quot;: \&quot;85%\&quot;     },     {     \&quot;vmId\&quot;: \&quot;id_2\&quot;,     \&quot;localStatus\&quot;: \&quot;Active\&quot;,     \&quot;replicationStatus\&quot;: \&quot;Healthy\&quot;,     \&quot;healthPercentage\&quot;: \&quot;100%\&quot;     }   ]   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60;  ### Getting recoverable ranges for a batch of CDP-enabled virtual machines  To get the recoverable time ranges for a batch of CDP-enabled virtual machines, send a POST request to [&#x60;/vmware/vm/recoverable_range&#x60;] (#operation/getVmwareVmRecoverableRangesInBatch). The request takes a list of virtual machine IDs, and optionally a \&quot;before_time\&quot; and \&quot;after_time\&quot; as a filter of the time range. The returned recoverable range timestamps are specified as milliseconds from epoch.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;vmIds\&quot;: [\&quot;vmId_1\&quot;, \&quot;vmId_2\&quot;]      }&#39;\\       \&quot;https://$cluster_address/api/v1/vmware/vm/recoverable_range\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;BatchVmwareVmRecoverableRanges&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;responses\&quot;:   [     {       \&quot;vmId\&quot;: \&quot;vmId_1\&quot;,       \&quot;recoverableRanges\&quot;:       [         {           \&quot;beginTime\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;,           \&quot;endTime\&quot;: \&quot;2018-01-01T12:38:56.789Z\&quot;         }       ]     },     {       \&quot;vmId\&quot;: \&quot;vmId_2\&quot;,       \&quot;recoverableRanges\&quot;:       [         {           \&quot;beginTime\&quot;: \&quot;2018-01-01T12:34:57.789Z\&quot;,           \&quot;endTime\&quot;: \&quot;2018-01-01T12:38:57.789Z\&quot;         }       ]     }   ] } &#x60;&#x60;&#x60;  ### Getting missed recoverable ranges for a batch of CDP-enabled ### virtual machines  To get the missed recoverable time ranges for a batch of CDP-enabled virtual machines, send a POST request to [&#x60;/vmware/vm/missed_recoverable_range&#x60;] (#operation/getVmwareVmMissedRecoverableRangesInBatch). The request takes a list of virtual machine IDs, and optionally a \&quot;before_time\&quot; and \&quot;after_time\&quot; as a filter of the time range. The returned missed recoverable range timestamps are specified as milliseconds from epoch. If no filters being specified, the missed recoverable range will be calculated based on the retention window, i.e. from retention time to the current time  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;vmIds\&quot;: [\&quot;vmId_1\&quot;, \&quot;vmId_2\&quot;]      }&#39;\\       \&quot;https://$cluster_address/api/v1/vmware/vm/missed_recoverable_range\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;BatchVmwareVmMissedRecoverableRanges&#x60; object.  &#x60;&#x60;&#x60;bash {   \&quot;responses\&quot;:   [     {       \&quot;vmId\&quot;: \&quot;vmId_1\&quot;,       \&quot;missedRecoverableRanges\&quot;:       [         {           \&quot;beginTime\&quot;: \&quot;2018-01-01T12:34:56.789Z\&quot;,           \&quot;endTime\&quot;: \&quot;2018-01-01T12:38:56.789Z\&quot;         }       ]     },     {       \&quot;vmId\&quot;: \&quot;vmId_2\&quot;,       \&quot;missedRecoverableRanges\&quot;:       [         {           \&quot;beginTime\&quot;: \&quot;2018-01-01T12:34:57.789Z\&quot;,           \&quot;endTime\&quot;: \&quot;2018-01-01T12:38:57.789Z\&quot;         }       ]     }   ] } &#x60;&#x60;&#x60;  ## Get VMware Hierarchy Objects Send a GET request to [&#x60;/vmware/hierarchy/export&#x60;](#operation/getVmwareHierarchyExport). The request takes an optional root ID for the hierarchy. This endpoint is used to retrieve the set of objects that are valid recovery targets during a VMware Virtual Machine Export operations. This is limited to VMware Clusters, Hosts, and Resource Pools. The available options for the root ID are None (return top level objects), Clusters (return child Hosts and Resource Pools), Standalone Hosts (return child Resource Pools), or Resource Pools (return child Resource Pools).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/hierarchy/export\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object. &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,     \&quot;data\&quot;: [       {         \&quot;id\&quot;: \&quot;string\&quot;,         \&quot;name\&quot;: \&quot;string\&quot;,         \&quot;objectType\&quot;: \&quot;string\&quot;,         \&quot;location\&quot;: \&quot;string\&quot;,         \&quot;hasChildren\&quot;: true,         \&quot;datastores\&quot;: [         ...         ],         \&quot;recoverableTo\&quot;: true,       },     ] } &#x60;&#x60;&#x60;  ## Get VMware Hierarchy Object Send a GET request to [&#x60;/vmware/hierarchy/{id}/export&#x60;](#operation/getVmwareHierarchyObject). The request takes an ID for the hierarchy object. This endpoint is used to retrieve the VMware Hierarchy object that are valid recovery targets during a VMware Virtual Machine Export operations. This is limited to VMware Clusters, Hosts, and Resource Pools. The available options for the ID are Compute Cluster ID , Standalone Hosts ID, or Resource Pools ID.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/hierarchy/{id}/export\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;VmwareHierarchyInfo&#x60; object. &#x60;&#x60;&#x60;bash {   \&quot;responses\&quot;:   {    \&quot;id\&quot;: \&quot;string\&quot;,     \&quot;name\&quot;: \&quot;string\&quot;,     \&quot;objectType\&quot;: \&quot;string\&quot;,     \&quot;location\&quot;: \&quot;string\&quot;,     \&quot;hasChildren\&quot;: true,     \&quot;datastores\&quot;: [     ...     ],     \&quot;recoverableTo\&quot;: true,   } } &#x60;&#x60;&#x60;  ## Get VMware User-Configured Network List Send a GET request to [&#x60;/vmware/vcenter/{id}/networks&#x60;](#operation/getNetworks). The request takes an ID for the vCenter server for which to retrieve the user-configured networks and returns the networks&#39; names and IDs.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}/networks\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;NetworkInfo&#x60; object. &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {     \&quot;id\&quot;: \&quot;network_id\&quot;,     \&quot;name\&quot;: \&quot;network_name\&quot;     }   ]   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ## Set Network for HotAdd Backups and Recoveries Send a POST request to [&#x60;/vmware/vcenter/{id}/hotadd/network&#x60;](#operation/setHotAddNetwork). The request takes an ID for the vCenter server and a user-configured network ID. It can also optionally take the information about static IP configuration. This static IP configuration requires the IP address range and the subnet mask, optionally taking in a gateway and list of DNS servers.  &#x60;&#x60;&#x60;bash curl -X POST \\ -d &#39;{   \&quot;hotadd_network_info\&quot;: {     \&quot;network_id\&quot;:\&quot;string\&quot;,     \&quot;static_ip_info\&quot;: {       \&quot;ip_addresses\&quot;:[\&quot;list\&quot;, \&quot;of\&quot;, \&quot;ips\&quot;],       \&quot;subnet_mask\&quot;:\&quot;string\&quot;,       \&quot;gateway\&quot;:\&quot;string\&quot;,       \&quot;dns_servers\&quot;:[\&quot;list\&quot;, \&quot;of\&quot;, \&quot;dns\&quot;, \&quot;servers\&quot;]     }   } }&#39; \\  \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/network\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with an HTTP 204 response when the network is set up properly.  ## Get Network Information for HotAdd Backups and Recoveries Send a GET request to [&#x60;/vmware/vcenter/{id}/hotadd/network&#x60;](#operation/getHotAddNetwork). The request takes an ID for the vCenter server.  &#x60;&#x60;&#x60;bash curl -x GET \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/network\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;HotAddNetworkConfigWithName&#x60; object. &#x60;&#x60;&#x60;bash {   \&quot;networkName\&quot;: \&quot;$networkName\&quot;,   \&quot;staticIpConfig\&quot;: {     \&quot;ip_addresses\&quot;: [\&quot;list\&quot;, \&quot;of\&quot;, \&quot;ips\&quot;],     \&quot;subnet_mask\&quot;: \&quot;$subnet_mask\&quot;,     \&quot;gateway\&quot;: \&quot;$gateway\&quot;,     \&quot;dns_servers\&quot;: [\&quot;list\&quot;, \&quot;of\&quot;, \&quot;dns\&quot;, \&quot;servers\&quot;]   } } &#x60;&#x60;&#x60;  ## Bulk creating on-demand snapshots On-demand snapshots can be created for both protected and unprotected virtual machines. To create an on-demand snapshot of a set of virtual machines, send a POST request to [&#x60;/vmware/vm/snapshot/bulk&#x60;](#operation/bulkCreateOnDemandBackup).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{      \&quot;vms\&quot;: [        {          \&quot;vmId\&quot;: \&quot;$vm_id\&quot;        }      ],      }&#39;\\       \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/bulk\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous snapshot tasks and responds with objects tracking the job status. &#x60;&#x60;&#x60;bash {   \&quot;responses\&quot;: [     {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;QUEUED\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vmware/vm/snapshot/bulk\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ]     }   ] } &#x60;&#x60;&#x60;  ## Get VMware HotAdd proxy virtual machine list To retrieve the list of VMware HotAdd proxy virtual machines, send a GET request to the [&#x60;/vmware/vcenter/hotadd/vm&#x60;](#operation/queryHotAddProxyVm) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vcenter/hotadd/vm\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object. &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;vcenterName\&quot;: \&quot;string\&quot;,       \&quot;computeClusterName\&quot;: \&quot;string\&quot;,       \&quot;hostName\&quot;: \&quot;string\&quot;,       \&quot;datastoreName\&quot;: \&quot;string\&quot;,       \&quot;networkInfo\&quot;: {         \&quot;networkName\&quot;:\&quot;string\&quot;,         \&quot;staticIpConfig\&quot;: {           \&quot;ip_addresses\&quot;:[\&quot;list\&quot;, \&quot;of\&quot;, \&quot;ips\&quot;],           \&quot;subnet_mask\&quot;:\&quot;string\&quot;,           \&quot;gateway\&quot;:\&quot;string\&quot;,           \&quot;dns_server\&quot;:\&quot;string\&quot;         }       },       \&quot;status\&quot;: \&quot;OK\&quot;,       \&quot;UsedPortCount\&quot;: 0,     },   ] } &#x60;&#x60;&#x60;  ## Get Number of HotAdd Proxies Needed for Vcenter Send a GET request to [&#x60;/vmware/vcenter/{id}/hotadd/needed&#x60;](#operation/getNumProxiesNeeded). The request takes an ID for the vCenter server for which to return the number of HotAdd proxies needed.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/needed\&quot; &#x60;&#x60;&#x60;  The Rubrik cluster returns the number of proxies needed. &#x60;&#x60;&#x60;bash {   \&quot;needed\&quot;: 7 } &#x60;&#x60;&#x60;  ## Get Ingest and Export Bandwidth Limits Using HotAdd for Vcenter. Send a GET request to [&#x60;/vmware/vcenter/{id}/hotadd/bandwidth&#x60;](#operation/getHotAddBandwidth). The request takes the vCenter server ID and returns the ingest and export bandwidth limits for that vCenter, when using HotAdd.  &#x60;&#x60;&#x60;bash curl -X GET \\ \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/bandwidth\&quot; &#x60;&#x60;&#x60;  The Rubrik cluster returns the bandwidth limits in Mbps. &#x60;&#x60;&#x60;bash {   \&quot;ingestLimit\&quot;: 7,   \&quot;exportLimit\&quot;: 7 } &#x60;&#x60;&#x60;  ## Set Ingest and Export Bandwidth Limits Using HotAdd for Vcenter. Send a POST request to [&#x60;/vmware/vcenter/{id}/hotadd/bandwidth&#x60;](#operation/setHotAddBandwidth). The request takes an ID for the vCenter server and the bandwidth limits to update. Setting a bandwidth limit to 0 clears the limit in that direction.  &#x60;&#x60;&#x60;bash curl -X POST \\ -d &#39;{   \&quot;hot_add_bandwidth_info\&quot;: {     \&quot;ingestLimit\&quot;: 0,     \&quot;exportLimit\&quot;: 0   } }&#39; \\ \&quot;https://$cluster_address/api/v1/vmware/vcenter/{id}/hotadd/bandwidth\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with an HTTP 204 response when the bandwidth limits are set properly.  ### Get preferred CDP network protocol  To retrieve the currently preferred network protocol (IPv4 or IPv6) used for CDP data transfer, send a GET request to [&#x60;/vmware/config/cdp/get_preferred_cdp_network_protocol&#x60;](#operation/getPreferredCdpNetworkProtocol).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/config/cdp/get_preferred_cdp_network_protocol\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the preferred CDP network protocol.  &#x60;&#x60;&#x60;bash {   \&quot;preferredCdpNetworkProtocol\&quot;: \&quot;IPv4\&quot; } &#x60;&#x60;&#x60;  The configuration of VMware ESX subnets take priority over this setting. When a valid IPv6 ESX subnet is defined, CDP uses IPv6 for data transfer even when the preferred protocol is IPv4.  ### Set preferred CDP network protocol  Set the preferred network protocol (IPv4 or IPv6) used for CDP data transfer by sending a PATCH request to [&#x60;/vmware/config/cdp/set_preferred_cdp_network_protocol&#x60;](#operation/setPreferredCdpNetworkProtocol).  &#x60;&#x60;&#x60;bash curl -X PATCH \\   \&quot;https://$cluster_address/api/v1/vmware/config/cdp/set_preferred_cdp_network_protocol\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the updated preferred CDP network protocol.  &#x60;&#x60;&#x60;bash {   \&quot;preferredCdpNetworkProtocol\&quot;: \&quot;IPv4\&quot; } &#x60;&#x60;&#x60;  ## Migrate cluster associated with Rubrik Backup Service  See the [host section](#section/Hosts/Migrate-cluster-associated-with-Rubrik-Backup-Service) for more details. To migrate the primary cluster for the Rubrik Backup Service on a virtual machine, send a POST request to [&#x60;/vmware/vm/make_primary&#x60;](#operation/vmMakePrimary).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;ids\&quot;: [       \&quot;$vm_id1\&quot;,       ...     ] }&#39; \\   \&quot;https://$cluster_address/api/v1/vmware/vm/make_primary\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;error\&quot;: \&quot;None\&quot;,   \&quot;progress\&quot;: \&quot;$request_progress\&quot;   \&quot;links\&quot;: [     {       href: \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       rel: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Get VMware Networks for virtual machine recovery  To get all the available VMware networks for the specified compute resource, send a GET request to [&#x60;/vmware/config/recovery/networks&#x60;](#operation/getVmwareRecoveryNetworks).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vmware/config/recovery/networks\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns a collection of all the available recovery networks &#x60;VmwareNetworkInfo&#x60; for the compute resource specified by the &#x60;compute_resource_id&#x60; parameter.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;computeResourceId\&quot;: string,       \&quot;computeResourceType\&quot;: string,     },   ],   \&quot;total\&quot;: 1, } &#x60;&#x60;&#x60;  # Legal Hold  ### Get summary of snapshots which are placed under legal hold Send a GET request to [&#x60;/legal_hold/snapshot&#x60;](#operation/queryLegalHold).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/legal_hold/snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;objectId\&quot;: \&quot;$object_id\&quot;,       \&quot;objectName\&quot;: \&quot;$object_name\&quot;,       \&quot;objectType\&quot;: \&quot;$object_type\&quot;,       \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;,       \&quot;snapshotTime\&quot;: \&quot;2019-11-12T10:35:12.784Z\&quot;,       \&quot;placeOnHoldTime\&quot;: \&quot;2019-11-13T11:11:06.456Z\&quot;,       \&quot;locationsPresent\&quot;: [         \&quot;$location1_id\&quot;,         \&quot;$location2_id\&quot;       ],       \&quot;isOnDemandSnapshot\&quot;: true     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Place a snapshot on legal hold To place a snapshot under legal hold, send a POST request to [&#x60;/legal_hold/snapshot&#x60;](#operation/applyLegalHold).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{ \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;, \&quot;holdConfig\&quot;: {\&quot;isHoldInPlace\&quot;: true} }&#39; \\    \&quot;https://$cluster_address/api/v1/legal_hold/snapshot\&quot; &#x60;&#x60;&#x60;  The rubrik REST API server responds with the legal hold summary object if request succeeds.  &#x60;&#x60;&#x60;bash {   \&quot;objectId\&quot;: \&quot;$object_id\&quot;,   \&quot;objectName\&quot;: \&quot;$object_name\&quot;,   \&quot;objectType\&quot;: \&quot;$object_type\&quot;,   \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;,   \&quot;snapshotTime\&quot;: \&quot;2019-11-12T10:35:12.784Z\&quot;,   \&quot;placeOnHoldTime\&quot;: \&quot;2019-11-13T11:11:06.456Z\&quot;,   \&quot;locationsPresent\&quot;: [     \&quot;$location1_id\&quot;,     \&quot;$location2_id\&quot;   ],   \&quot;isOnDemandSnapshot\&quot;: true } &#x60;&#x60;&#x60;  ### Get objects which are part of legal hold Send a GET request to [&#x60;/legal_hold/object&#x60;](#operation/getLegalHoldObjects) to retrieve a list of objects with snapshots that are under a legal hold.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/legal_hold/object\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;objectId\&quot;: \&quot;$object_id\&quot;,       \&quot;objectName\&quot;: \&quot;$object_name\&quot;,       \&quot;objectType\&quot;: \&quot;$object_type\&quot;,       \&quot;numberOfSnapshotsHeld\&quot;: 1     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  To return a list of the snapshots for a specific object that are under legal hold, send a GET request to [&#x60;/legal_hold/snapshot&#x60;](#operation/queryLegalHold) with the ID of the object in the object_id parameter.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/legal_hold/snapshot?object_id&#x3D;$object_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;objectId\&quot;: \&quot;$object_id\&quot;,       \&quot;objectName\&quot;: \&quot;$object_name\&quot;,       \&quot;objectType\&quot;: \&quot;$object_type\&quot;,       \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;,       \&quot;snapshotTime\&quot;: \&quot;2019-11-12T10:35:12.784Z\&quot;,       \&quot;placeOnHoldTime\&quot;: \&quot;2019-11-13T11:11:06.456Z\&quot;,       \&quot;locationsPresent\&quot;: \&quot;\&quot;,       \&quot;isOnDemandSnapshot\&quot;: true     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Dissolve legal hold To remove a legal hold from a collection of object snapshots, send a POST request to [&#x60;/legal_hold/object/{id}/dissolve&#x60;](#operation/dissolveLegalHoldSnapshots).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{ \&quot;snapshotIds\&quot;: [\&quot;$snapshot_id\&quot;] }&#39; \\   \&quot;https://$cluster_address/api/v1/legal_hold/object/$object_id/dissolve\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the list of snapshots on which legal hold has been dissolved.  &#x60;&#x60;&#x60;bash {   \&quot;dissolvedSnapshotIds\&quot;: [     \&quot;$snapshot_id\&quot;   ] } &#x60;&#x60;&#x60;  # Cloud Utilization  Rubrik clusters can utilize the cloud for storage and compute for snapshot archival and data consolidation on archival locations.  ## Forecasting cloud utilization  To forecast the cloud utilization according to specified SLA domain parameters, send a POST request to: [&#x60;/cloud_utilization/cloud_out_forecast&#x60;](#operation/doCloudOutForecast).  **Example:** Forecasting cloud utilization  &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;cloudOutForecastRequest\&quot;: {     \&quot;slaParameters\&quot;: {       \&quot;frequencies\&quot;: {         \&quot;monthly\&quot;: {           \&quot;frequency\&quot;: 1,           \&quot;retention\&quot;: 12         },         \&quot;yearly\&quot;: {           \&quot;frequency\&quot;: 1,           \&quot;retention\&quot;: 2         }       },       \&quot;archivalSpecs\&quot;: {         \&quot;locationId\&quot;: \&quot;75892476-c158-45fb-8ea9-365c634da294\&quot;,         \&quot;archivalThreshold\&quot;: 1       }     },     \&quot;consolidationFilter\&quot;: \&quot;ForecastWithConsolidation\&quot;,     \&quot;granularity\&quot;: Year,     \&quot;forecastPeriodInGranularityUnit\&quot;: 3   } }&#39; \&quot;https://$cluster_address/api/v1/cloud_utilization/cloud_out_forecast\&quot; &#x60;&#x60;&#x60;  The response gives the forecast result summary.  &#x60;&#x60;&#x60;bash {   \&quot;assumptions\&quot;: {     \&quot;logicalDataSizeInGB\&quot;: 1000.0,     \&quot;annualGrowthRateInPercent\&quot;: 7.0,     \&quot;compressionFactor\&quot;: 2.5,     \&quot;frequencyChangeRates\&quot;: {       \&quot;monthlyChangeRateInPercent\&quot;: 10.0,       \&quot;yearlyChangeRateInPercent\&quot;: 30.0     }   },   \&quot;locationForecast\&quot;: {     \&quot;locationName\&quot;: \&quot;S3:s3-location-name\&quot;,     \&quot;locationType\&quot;: \&quot;S3\&quot;,     \&quot;locationRegion\&quot;: \&quot;us-west-2\&quot;,     \&quot;instanceType\&quot;: \&quot;m5.2xlarge\&quot;,     \&quot;storageForecast\&quot;: {       \&quot;forecastWithConsolidation\&quot;: {         \&quot;storageUsedInGB\&quot;: [1000, 1100, 1105],         \&quot;storageCostInUSD\&quot;: [276, 304, 305],         \&quot;dataRetrievalCostInUSD\&quot;: [0, 0, 0],         \&quot;perStorageClassForecast\&quot;: [           {             \&quot;storageClass\&quot;: \&quot;STANDARD\&quot;,             \&quot;storageUsedInGB\&quot;: [900, 1150, 1450],             \&quot;storageCostInUSD\&quot;: [176, 304, 376]           }         ]       }     },     \&quot;computeForecast\&quot;: {       \&quot;forecastWithConsolidation\&quot;: {         \&quot;computeDurationInHrs\&quot;: [0, 11, 12],         \&quot;computeCostInUSD\&quot;: [0, 8, 9]       }     }   } } &#x60;&#x60;&#x60;  # User-defined tag  Rubrik CDM clusters can manage user-defined tags attached to the compute resources created by CloudOn and CloudOut.  Resource tags are associated with a cloud archival location, such as AWS or Azure. Rubrik CDM allows a maximum of 10 resource tags for each archival location. Check with the cloud provider for additional restrictions on resource tags.  If a compute resource supports tagging during creation by the cloud provider, user-defined resource tags are attached at resource creation time. Otherwise, user-defined resource tags are attached to the compute resource after creation.  * Compute Instances: Bolt, Converter, Transient instances, Converted Instances * Disks/Snapshots: EBS Volumes/Snapshots, Managed Disks/Snapshot * Images: AMIs, Images  ## Query existing user-defined tags on a CDM cluster  To query existing user-defined tags on a CDM cluster, send a GET request to the [&#x60;/user_defined_tag&#x60;](#operation/queryUserDefinedTag) endpoint.  **Example:** Query existing user-defined tags on a CDM cluster  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/user_defined_tag\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;json {         \&quot;resourceTags\&quot;: [{                 \&quot;id\&quot;: \&quot;38400000-8cf0-11bd-b23e-10b96e4ef00d\&quot;,                 \&quot;key\&quot;: \&quot;department\&quot;,                 \&quot;value\&quot;: \&quot;engineering\&quot;,                 \&quot;lastUpdateTime\&quot;: \&quot;2021-01-31T11:54:24 UTC\&quot;,                 \&quot;scopeRefId\&quot;: \&quot;a0ef0663-7a7c-4027-9972-061780e52fee\&quot;         }] } &#x60;&#x60;&#x60;  ## Create a new user-defined tag on a CDM cluster  To create a new user-defined tag on a CDM cluster, send a POST request to the [&#x60;/user_defined_tag&#x60;](#operation/createUserDefinedTag) endpoint.  **Example:** Create a new user-defined tags on a CDM cluster  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{           \&quot;key\&quot;: \&quot;department\&quot;,           \&quot;value\&quot;: \&quot;engineering\&quot;,           \&quot;scopeRefId\&quot;: \&quot;a0ef0663-7a7c-4027-9972-061780e52fee\&quot;     }&#39; \\   \&quot;https://$cluster_address/api/v1/user_defined_tag\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;json {         \&quot;id\&quot;: \&quot;38400000-8cf0-11bd-b23e-10b96e4ef00d\&quot;,         \&quot;key\&quot;: \&quot;department\&quot;,         \&quot;value\&quot;: \&quot;engineering\&quot;,         \&quot;lastUpdateTime\&quot;: \&quot;2021-01-31T11:54:24 UTC\&quot;,         \&quot;scopeRefId\&quot;: \&quot;a0ef0663-7a7c-4027-9972-061780e52fee\&quot; } &#x60;&#x60;&#x60;  ## Delete existing user-defined tags on a CDM cluster  To delete existing user-defined tags on a CDM cluster, send a DELETE request to the [&#x60;/user_defined_tag&#x60;](#operation/deleteUserDefinedTagBulk) endpoint.  **Example:** Delete existing user-defined tags on a CDM cluster  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/user_defined_tag?ids&#x3D;$id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;json {         \&quot;ids\&quot;: [\&quot;38400000-8cf0-11bd-b23e-10b96e4ef00d\&quot;] } &#x60;&#x60;&#x60;  ## Get information about a user-defined tag on a CDM cluster  To fetch an existing user-defined tag on a CDM cluster, send a GET request to the [&#x60;/user_defined_tag/{id}&#x60;](#operation/getUserDefinedTag) endpoint.  **Example:** To fetch an existing user-defined tag on a CDM cluster  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/user_defined_tag/$id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;json {         \&quot;id\&quot;: \&quot;38400000-8cf0-11bd-b23e-10b96e4ef00d\&quot;,         \&quot;key\&quot;: \&quot;department\&quot;,         \&quot;value\&quot;: \&quot;engineering\&quot;,         \&quot;lastUpdateTime\&quot;: \&quot;2021-01-31T11:54:24 UTC\&quot;,         \&quot;scopeRefId\&quot;: \&quot;a0ef0663-7a7c-4027-9972-061780e52fee\&quot; } &#x60;&#x60;&#x60;  ## Update information about an existing user-defined tag on a CDM cluster  To update an existing user-defined tag on a CDM cluster, send a PATCH request to the [&#x60;/user_defined_tag/{id}&#x60;](#operation/updateUserDefinedTag) endpoint.  **Example:** To update an existing user-defined tag on a CDM cluster  &#x60;&#x60;&#x60;bash curl -X PATCH \\  -d &#39;{\&quot;value\&quot;: \&quot;engineering\&quot;}&#39; \\  \&quot;https://$cluster_address/api/v1/user_defined_tag/$id\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;json {         \&quot;id\&quot;: \&quot;38400000-8cf0-11bd-b23e-10b96e4ef00d\&quot;,         \&quot;key\&quot;: \&quot;department\&quot;,         \&quot;value\&quot;: \&quot;engineering\&quot;,         \&quot;lastUpdateTime\&quot;: \&quot;2021-01-31T11:54:24 UTC\&quot;,         \&quot;scopeRefId\&quot;: \&quot;a0ef0663-7a7c-4027-9972-061780e52fee\&quot; } &#x60;&#x60;&#x60;  ## Delete a existing user-defined tag on a CDM cluster  To delete an existing user-defined tag on a CDM cluster, send a DELETE request to the [&#x60;/user_defined_tag/{id}&#x60;](#operation/deleteUserDefinedTag) endpoint.  **Example:** To delete an existing user-defined tag on a CDM cluster  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/user_defined_tag/$id\&quot; &#x60;&#x60;&#x60;    # Hosts  Rubrik clusters can protect file system data and application data through direct interaction with a host operating system. This method of protection does not require a virtual environment API. Instead, the Rubrik cluster works with the Rubrik Backup Service software that is running on supported Linux hosts and Windows hosts.  In some situations, the Rubrik cluster can directly interact with hosts without the Rubrik Backup Service, for example when providing protection of data on a network share.  ## Rubrik Backup Service  The Rubrik Backup Service software must be installed on a host to enable file system level protection and direct protection of supported applications. The Rubrik Backup Service software is signed by a specific Rubrik cluster and can only be used with that Rubrik cluster.  The following URLs provide access to the Rubrik Backup Service software on a Rubrik cluster: * Linux: https://$cluster_address/connector/rubrik-agent.x86_64.rpm * Windows: https://$cluster_address/connector/RubrikBackupService.zip  **IMPORTANT:** The Rubrik User Guide describes how to install the Rubrik Backup Service software, and lists the permissions and settings that are required to allow the Rubrik Backup Service to provide support for specific operating systems, applications, and clusters.  ## Registering a host After installing the Rubrik Backup Service on a host, register the host with the Rubrik cluster. Registering initiates secure communication between the Rubrik cluster and the Rubrik Backup Service on the host. After a host is registered, the Rubrik Backup Service on the host sends detailed information about the host to the Rubrik cluster.  The Rubrik Backup Service scans a registered host for protectable objects, such as: applications, databases, and Windows clusters. The Rubrik Backup Service sends the results of the scan to the Rubrik cluster.  To register a host, send a POST request to [&#x60;/host&#x60;](#operation/registerHost) and include &#x60;hostname: $hostname&#x60;. The &#x60;$hostname&#x60; value must be the IPv4 address of the host or the resolvable hostname of the host.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$hostname\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/host\&quot; &#x60;&#x60;&#x60;  To register the host and discover protection points of the host in the background, send a POST request to [&#x60;/host/background&#x60;](#operation/registerHostAsync) and include &#x60;hostname: $hostname&#x60;. The&#x60;$hostname&#x60; value must be the IPv4 address of the host or the resolvable hostname of the host.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$hostname\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/host/background\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details for the host, including the connection status.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$host_id\&quot;,   \&quot;name\&quot;: \&quot;$hostname\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;, (deprecated)   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,   \&quot;agentId\&quot;: \&quot;$agent_id\&quot;,   \&quot;operatingSystem\&quot;: \&quot;$os_version\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$os_type\&quot;,   \&quot;status\&quot;: \&quot;Connected\&quot;,   \&quot;compressionEnabled\&quot;: false } &#x60;&#x60;&#x60;  To register bulk hosts in the background, send a POST request to [&#x60;/host/bulk_background&#x60;](#operation/bulkRegisterHostAsync) and include &#x60;hostname: $hostname&#x60;. The&#x60;$hostname&#x60; value must be the IPv4 address of the host or the resolvable hostname of the host.  &#x60;&#x60;&#x60; curl -X POST \\   -d &#39;{     [{\&quot;hostname\&quot;: \&quot;$hostname1\&quot;}, {\&quot;hostname\&quot;: \&quot;$hostname2\&quot;}] }&#39; \\   \&quot;https://$cluster_address/api/v1/host/bulk_background\&quot; &#x60;&#x60;&#x60;  The &#x60;status&#x60; field in the response is returned as &#x60;Refreshing&#x60; until the host has finished discovering all the mssql instances, oracle DBs, etc. After this step, status is returned as &#x60;Connected&#x60; and all discovery is done for the host  For background hosts, the connection status is returned as &#x60;Refreshing&#x60; until the host is fully registered. After this step, that status is returned as &#x60;Connected&#x60; and all discovery is done for the host  ## Retrieving host information  To retrieve a current list of the hosts that are registered with a Rubrik cluster, send a GET request to [&#x60;/host&#x60;](#operation/queryHost).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/host\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a ListResponse object that contains the first page of the current list.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$host_id0\&quot;,       \&quot;name\&quot;: \&quot;$hostname0\&quot;,       \&quot;hostname\&quot;: \&quot;$hostname0\&quot;, (deprecated)       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$os_version0\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;$os_type0\&quot;,       \&quot;status\&quot;: \&quot;Connected\&quot;     },     {       \&quot;id\&quot;: \&quot;$host_id1\&quot;,       \&quot;name\&quot;: \&quot;$hostname1\&quot;,       \&quot;hostname\&quot;: \&quot;$hostname1\&quot;, (deprecated)       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$os_version1\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;$os_type1\&quot;,       \&quot;status\&quot;: \&quot;Connected\&quot;     }   ],   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60; Depending on the number of registered hosts, the complete list of registered hosts may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.   To retrieve the details for a specified host, send a GET request to [&#x60;/host/{id}&#x60;](#operation/getHost).  Adding a host will cause Rubrik to communicate with the remote Rubrik agent and get detailed information about the host.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/host/$host_id0\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details of the specified host.  &#x60;&#x60;&#x60;bash   {     \&quot;id\&quot;: \&quot;$host_id0\&quot;,     \&quot;name\&quot;: \&quot;$hostname0\&quot;,     \&quot;hostname\&quot;: \&quot;$hostname0\&quot;, (deprecated)     \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,     \&quot;agentId\&quot;: \&quot;$agent_id\&quot;,     \&quot;operatingSystem\&quot;: \&quot;$os_version0\&quot;,     \&quot;operatingSystemType\&quot;: \&quot;$os_type0\&quot;,     \&quot;status\&quot;: \&quot;Connected\&quot;,     \&quot;compressionEnabled\&quot;: false   } &#x60;&#x60;&#x60;  ## Adding a host without the Rubrik Backup Service  A host without the Rubrik Backup Service can be added by setting the &#x60;hasAgent&#x60; flag to &#x60;false&#x60;. This can be used to register a host that will be accessed through network shares.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{ \\     \&quot;hostname\&quot;: \&quot;$hostname\&quot;,     \&quot;hasAgent\&quot;: \&quot;false\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/host\&quot; &#x60;&#x60;&#x60;  ## Modifying a registered host  To change the FQDN or IPv4 address that the Rubrik cluster uses to connect with a registered host, send a PATCH request to [&#x60;/host&#x60;](#operation/updateHost). Use the value of &#x60;hostname&#x60; to specify the new FQDN or IPv4 address of the host. Optionally, also use this PATCH request to specify whether to compress the data that is transmitted to and from the host. Set the value of &#x60;compressionEnabled&#x60; to &#x60;true&#x60; to enable compression or set the value to &#x60;false&#x60; to turn compression off.   &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$hostname\&quot;,     \&quot;compressionEnabled\&quot;: true }&#39; \\   \&quot;https://$cluster_address/api/v1/host/$host_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a confirmation of the new details of the registered host.  &#x60;&#x60;&#x60;bash  {   \&quot;id\&quot;: \&quot;$host_id\&quot;,   \&quot;name\&quot;: \&quot;$hostname\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;, (deprecated)   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,   \&quot;agentId\&quot;: \&quot;$agent_id\&quot;,   \&quot;operatingSystem\&quot;: \&quot;$os_version\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$os_type\&quot;,   \&quot;status\&quot;: \&quot;Connected\&quot;,   \&quot;compressionEnabled\&quot;: true  } &#x60;&#x60;&#x60; ## Removing a host  Remove a host from the Rubrik cluster when the host no longer requires protection. The Rubrik cluster moves all of the unexpired backups for the host filesets of the host to Unmanaged Objects.  To remove a host send a DELETE request to [&#x60;/host/{id}&#x60;](#operation/deleteHost).  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/host/$host_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  ## Refreshing a Host  Refresh a host when changes made on the host do not appear in the Rubrik web UI. The refresh requests updated information from the Rubrik Backup Service that is running on the host.  To refresh a host send a POST request to [&#x60;/host/{id}/refresh&#x60;](#operation/refreshHost)  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/host/$host_id/refresh\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with HTTP response code 200 and includes the updated properties of the host object in the response body.  ## Updating a Host Certificate  When a host has a new certificate that is not registered with Rubrik the Rubrik cluster will not communicate with that host until the certificate is updated. In order to do that send a PUT request to [&#x60;/host/certificate/{id}&#x60;](#operation/updateCertificateHost)  &#x60;&#x60;&#x60;bash curl -X PUT \\   \&quot;https://$cluster_address/api/v1/host/certificate/$host_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the specified host.  ## Migrate cluster associated with Rubrik Backup Service  Hosts can register with multiple clusters but can only communicate or back up to a single cluster. Such a cluster is the primary cluster for that host. See the Multicluster Rubrik Backup Service section of the Rubrik CDM User Guide for details. To change the primary cluster to the current cluster, for Rubrik Backup Service on a host, send a POST request to [&#x60;/host/make_primary&#x60;](#operation/hostMakePrimary).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;ids\&quot;: [       \&quot;$host_id1\&quot;,       ...     ] }&#39; \\   \&quot;https://$cluster_address/api/v1/host/make_primary\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;RUNNING\&quot;,   \&quot;error\&quot;: \&quot;None\&quot;,   \&quot;progress\&quot;: \&quot;$request_progress\&quot;   \&quot;links\&quot;: [     {       href: \&quot;https://$cluster_address/api/v1/vmware/vm/request/$request_id\&quot;,       rel: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  To migrate the Rubrik Backup Service on a virtual machine, see the [corresponding virtual machine API](#section/Virtual-machines/Migrate-cluster-associated-with-Rubrik-Backup-Service).  Alternatively, in a disaster recovery scenario, when migrating the primary cluster for all hosts *and* virtual machines from an old cluster to this one, send a POST request to [&#x60;/host/make_primary&#x60;](#operation/hostMakePrimary) with oldPrimaryClusterUuid specified. Note that the hosts and virtual machines must already have been registered on this cluster.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;oldPrimaryClusterUuid\&quot;: \&quot;12345678-90ab-cdef-1234-567890abcdef\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/host/make_primary\&quot; &#x60;&#x60;&#x60;  ## Windows Server Failover Clustering nodes  To begin working with Windows Server Failover Clustering (WSFC) clusters, register each WSFC node with the Rubrik cluster as described in [&#x60;Registering a host&#x60;](#section/Hosts/Registering-a-host). The scan performed by the Rubrik Backup Service on each WSFC node detects the WSFC cluster and provides information about the WSFC cluster to the Rubrik cluster.  To view WSFC cluster information, send a GET request to [&#x60;/windows_cluster&#x60;](#operation/queryWindowsCluster).  **Note:** The variable &#x60;$cluster_address&#x60; refers to the FQDN or IPv4 address of the Rubrik cluster.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/windows_cluster\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a ListResponse object that contains the first page of the list of WSFC clusters.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$wsfc_id\&quot;,       \&quot;name\&quot;: \&quot;$wsfc_name\&quot;,       \&quot;fqdn\&quot;: \&quot;$wsfc_fqdn\&quot;,       \&quot;hostIds\&quot;: [         \&quot;$wsfc_node_id0\&quot;,         \&quot;$wsfc_node_id1\&quot;       ],       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  To retrieve detailed information about a WSFC cluster, send a GET request to: [&#x60;/windows_cluster/{id}&#x60;](#operation/getWindowsCluster), where &#x60;$cluster_id&#x60; is the &#x60;id&#x60; of the WSFC cluster.   &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/windows_cluster/$cluster_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details for the specified WSFC cluster.  &#x60;&#x60;&#x60;bash {   \&quot;name\&quot;: \&quot;$wsfc_name\&quot;,   \&quot;id\&quot;: \&quot;$wsfc_id\&quot;,   \&quot;naturalId\&quot;: \&quot;$cluster_natural_id\&quot;,   \&quot;hostIds\&quot;: [   \&quot;$wsfc_node_id0\&quot;,   \&quot;$wsfc_node_id1\&quot;   ],   \&quot;fqdn\&quot;: \&quot;$wsfc_fqdn\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot; } &#x60;&#x60;&#x60;  ## Bulk Update Host Shares  To update a list of Host shares in bulk, send a PATCH request to the [&#x60;/host/share/bulk&#x60;](#operation/bulkUpdateHostShare) endpoint with a bulk_update_properties to complete an update.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;[     {       \&quot;shareId\&quot;: \&quot;$share_id\&quot;,       \&quot;updateProperties\&quot;: {         \&quot;exportPoint\&quot;: \&quot;$export_point\&quot;,         \&quot;username\&quot;: \&quot;$username\&quot;,         \&quot;password\&quot;: \&quot;$password\&quot;,         \&quot;domain\&quot;: \&quot;$domain\&quot;,         \&quot;hostShareParameters\&quot;: {           \&quot;isNetAppSnapDiffEnabled\&quot;: true,           \&quot;isIsilonChangelistEnabled\&quot;: true         }       }     }   ]&#39; \\   \&quot;https://$cluster_address/api/v1/host/share/bulk\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the updated Host shares.  ## Discover shares on NAS host  To retrieve a current list of shares (NFS/SMB) on a specific NAS host, send a GET request to [&#x60;/host/{id}/nas_share_discover&#x60;](#operation/discoverNasShares)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/host/{id}/nas_share_discover\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a List object that contains all discovered shares on the NAS host.  &#x60;&#x60;&#x60;bash {   [     {       \&quot;shareType\&quot;: \&quot;NFS\&quot;,       \&quot;exportPoint\&quot;: \&quot;/ifs/data/dir1\&quot;,     },     {       \&quot;shareType\&quot;: \&quot;SMB\&quot;,       \&quot;exportPoint\&quot;: \&quot;ifs_data\&quot;,     }   ] } &#x60;&#x60;&#x60;  ## Bulk add NAS shares  To add NAS shares in bulk without validating their share credentials, send a POST request to [&#x60;/host/share/bulk&#x60;](#operation/bulkAddHostShares)  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{ \\     [ \\       { \\         \&quot;shareType\&quot;: \&quot;$share_type\&quot;, \\         \&quot;exportPoint\&quot;: \&quot;$export_point\&quot; \\       },       { \\         \&quot;shareType\&quot;: \&quot;$share_type\&quot;, \\         \&quot;exportPoint\&quot;: \&quot;$export_point\&quot; \\       }, \\     ] \\   }&#39; \\   \&quot;https://$cluster_address/api/v1/host/share/bulk\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with details of added shares.  ## Getting a list of volumes on a Volume Group host  To retrieve a list of all volumes on a Volume Group host, send a GET request to [&#x60;/host/{id}/volume&#x60;](#operation/queryHostVolume)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/host/{id}/volume\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with summary information for each volume on the specified Volume Group host.  &#x60;&#x60;&#x60; {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;fileSystemType\&quot;: \&quot;NTFS\&quot;,       \&quot;mountPoints\&quot;: [         \&quot;string\&quot;       ],       \&quot;size\&quot;: 0,       \&quot;naturalId\&quot;: \&quot;string\&quot;,       \&quot;volumeGroupId\&quot;: \&quot;string\&quot;,       \&quot;isCurrentlyPresentOnSystem\&quot;: true     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ## Remote RBS management The Rubrik Backup Service (RBS) management endpoints provide the capability to install/uninstall/upgrade RBS on remote hosts.  ### Retrieving the Rubrik Backup Service host information  To get the Rubrik Backup Service host information, send a GET request to [&#x60;/host/rbs&#x60;](#operation/getRbsHostInfo).  &#x60;&#x60;&#x60;bash curl -X GET \\   -d &#39;{     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;operationTimeout\&quot;: 600 }&#39; \\   \&quot;https://$cluster_address/api/v1/host/rbs\&quot; &#x60;&#x60;&#x60;   The Rubrik REST API server responds with summary information for Rubrik Backup Service host.  &#x60;&#x60;&#x60; {   \&quot;name\&quot;: \&quot;$hostname\&quot;,   \&quot;agentId\&quot;: \&quot;$rbsAgentId\&quot;,   \&quot;agentVersion\&quot;: \&quot;$rbsVersion\&quot;,   \&quot;osInfo\&quot;: \&quot;$osInfo\&quot;,   \&quot;osType\&quot;: \&quot;$osType\&quot;,   \&quot;status\&quot;: \&quot;Installed\&quot; } &#x60;&#x60;&#x60;  ### Installing Rubrik Backup Service on a host  To install Rubrik Backup Service on a host, send a POST request to [&#x60;/host/rbs/install&#x60;](#operation/rbsInstall).  Install Rubrik Backup Service on a host with operationMode as Synchronous. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;operationTimeout\&quot;: 600,     \&quot;operationMode\&quot;: Synchronous }&#39; \\   \&quot;https://$cluster_address/api/v1/host/rbs/install\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the summary of Rubrik Backup Service on the host. &#x60;&#x60;&#x60;bash {   \&quot;rbsHostSummary\&quot;: {     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;agentId\&quot;: \&quot;$rbsAgentId\&quot;,     \&quot;agentVersion\&quot;: \&quot;$rbsVersion\&quot;,     \&quot;osInfo\&quot;: \&quot;$osInfo\&quot;,     \&quot;osType\&quot;: \&quot;$osType\&quot;,     \&quot;status\&quot;: \&quot;Installed\&quot;   } } &#x60;&#x60;&#x60;  Install Rubrik Backup Service on a host with operationMode as Asynchronous. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;operationTimeout\&quot;: 600,     \&quot;operationMode\&quot;: Asynchronous }&#39; \\   \&quot;https://$cluster_address/api/v1/host/rbs/install\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;asyncRequestStatus\&quot;: {     \&quot;id\&quot;: \&quot;$id\&quot;,     \&quot;status\&quot;: \&quot;$status\&quot;,     \&quot;progress\&quot;: 0,     \&quot;startTime\&quot;: \&quot;2021-03-24T23:27:41.493Z\&quot;,     \&quot;endTime\&quot;: \&quot;2021-03-24T23:27:41.493Z\&quot;,     \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,     \&quot;error\&quot;: {       \&quot;message\&quot;: \&quot;$message\&quot;     },     \&quot;links\&quot;: [       {         \&quot;href\&quot;: \&quot;$href\&quot;,         \&quot;rel\&quot;: \&quot;$rel\&quot;       }     ]   } } &#x60;&#x60;&#x60;  ### Uninstalling Rubrik Backup Service from a host  To uninstall Rubrik Backup Service from a host, send a POST request to [&#x60;/host/rbs/uninstall&#x60;](#operation/rbsUninstall).  Uninstall Rubrik Backup Service from a host with operationMode as Synchronous. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;operationTimeout\&quot;: 600,     \&quot;operationMode\&quot;: Synchronous }&#39; \\   \&quot;https://$cluster_address/api/v1/host/rbs/uninstall\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the summary of Rubrik Backup Service on the host. &#x60;&#x60;&#x60;bash {   \&quot;rbsHostSummary\&quot;: {     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;status\&quot;: \&quot;NotInstalled\&quot;   } } &#x60;&#x60;&#x60;  Uninstall Rubrik Backup Service from a host with operationMode as Asynchronous. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;operationTimeout\&quot;: 600,     \&quot;operationMode\&quot;: Asynchronous }&#39; \\   \&quot;https://$cluster_address/api/v1/host/rbs/uninstall\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous task and responds with a task object. &#x60;&#x60;&#x60;bash {   \&quot;asyncRequestStatus\&quot;: {     \&quot;id\&quot;: \&quot;$id\&quot;,     \&quot;status\&quot;: \&quot;$status\&quot;,     \&quot;progress\&quot;: 0,     \&quot;startTime\&quot;: \&quot;2021-03-24T23:27:41.493Z\&quot;,     \&quot;endTime\&quot;: \&quot;2021-03-24T23:27:41.493Z\&quot;,     \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,     \&quot;error\&quot;: {       \&quot;message\&quot;: \&quot;$message\&quot;     },     \&quot;links\&quot;: [       {         \&quot;href\&quot;: \&quot;$href\&quot;,         \&quot;rel\&quot;: \&quot;$rel\&quot;       }     ]   } }  ### Upgrading Rubrik Backup Service on a host  To upgrade Rubrik Backup Service on a host, send a POST request to [&#x60;/host/rbs/upgrade&#x60;](#operation/rbsUpgrade).  Upgrade Rubrik Backup Service on a host with operationMode as Synchronous. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;operationTimeout\&quot;: 600,     \&quot;operationMode\&quot;: Synchronous }&#39; \\   \&quot;https://$cluster_address/api/v1/host/rbs/upgrade\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the summary of Rubrik Backup Service on the host. &#x60;&#x60;&#x60;bash {   \&quot;rbsHostSummary\&quot;: {     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;agentId\&quot;: \&quot;$rbsAgentId\&quot;,     \&quot;agentVersion\&quot;: \&quot;$rbsVersion\&quot;,     \&quot;osInfo\&quot;: \&quot;$osInfo\&quot;,     \&quot;osType\&quot;: \&quot;$osType\&quot;,     \&quot;status\&quot;: \&quot;Installed\&quot;   } } &#x60;&#x60;&#x60;  Upgrade Rubrik Backup Service on a host with operationMode as Asynchronous. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$hostname\&quot;,     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;operationTimeout\&quot;: 600,     \&quot;operationMode\&quot;: Asynchronous }&#39; \\   \&quot;https://$cluster_address/api/v1/host/rbs/upgrade\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous task and responds with a task object.  &#x60;&#x60;&#x60;bash {   \&quot;asyncRequestStatus\&quot;: {     \&quot;id\&quot;: \&quot;$id\&quot;,     \&quot;status\&quot;: \&quot;$status\&quot;,     \&quot;progress\&quot;: 0,     \&quot;startTime\&quot;: \&quot;2021-03-24T23:27:41.493Z\&quot;,     \&quot;endTime\&quot;: \&quot;2021-03-24T23:27:41.493Z\&quot;,     \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,     \&quot;error\&quot;: {       \&quot;message\&quot;: \&quot;$message\&quot;     },     \&quot;links\&quot;: [       {         \&quot;href\&quot;: \&quot;$href\&quot;,         \&quot;rel\&quot;: \&quot;$rel\&quot;       }     ]   } } &#x60;&#x60;&#x60;  # Failover cluster  This REST API is used to manage failover cluster objects of UnixLike hosts.  ### Add a new failover cluster Add a new failover cluster by making a POST call to [/failover_cluster](#operation/createFailoverCluster).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$name\&quot;,     \&quot;hostIds\&quot;: [ \&quot;$hostId\&quot; ],     \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;}&#39;\\   \&quot;https://$cluster_address/api/v1/failover_cluster\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-20T17:30:30.743Z\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;nodes\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;     }   ],   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;numNodes\&quot;: $numNodes,   \&quot;numApps\&quot;: 0 }  &#x60;&#x60;&#x60;  ### Get all failover clusters Get a listing of all failover clusters using a GET request to [/failover_cluster](#operation/queryFailoverCluster).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/failover_cluster?sort_order&#x3D;asc\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,       \&quot;nodes\&quot;: [         {           \&quot;id\&quot;: \&quot;$id\&quot;,           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,           \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;         },         {           \&quot;id\&quot;: \&quot;$id\&quot;,           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,           \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;         }       ],       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Get information about a specific failover cluster Get information about a specific failover cluster using a GET request to [/failover_cluster/{id}](#operation/getFailoverCluster).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;nodes\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;     },     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;     }   ],   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;numNodes\&quot;: $numNodes,   \&quot;numApps\&quot;: $numApps } &#x60;&#x60;&#x60;  ### Update the parameters of an existing failover cluster The parameters associated with the failover cluster can be updated by making a PATCH request to [/failover_cluster/{id}](#operation/updateFailoverCluster)  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;name\&quot;: \&quot;$name\&quot;,     \&quot;hostIds\&quot;: [ \&quot;$hostId\&quot; ],     \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;}&#39;\\   \&quot;https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-20T18:26:56.893Z\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;nodes\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;     }   ],   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;numNodes\&quot;: $numNodes,   \&quot;numApps\&quot;: $numApps } &#x60;&#x60;&#x60;  ### Delete a specific failover cluster Any failover cluster can be removed by issuing a DELETE request to [/failover_cluster/{id}](#operation/deleteFailoverCluster).  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/failover_cluster/$failover_cluster_id?preserve_snapshots&#x3D;false\&quot; &#x60;&#x60;&#x60;  ### Bulk delete a failover cluster A list of failover clusters can be removed by issuing a DELETE request to [/failover_cluster/bulk](#operation/bulkDeleteFailoverCluster).  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/failover_cluster/bulk?ids&#x3D;$failover_cluster_id1,$failover_cluster_id2&amp;preserve_snapshots&#x3D;false\&quot; &#x60;&#x60;&#x60;  # Failover cluster App  Use this REST API to manage failover cluster app objects.  ### Add a new failover cluster app Add a new failover cluster app by making a POST call to [/failover_cluster/failover_cluster_app](#operation/createFailoverClusterApp).  Use either the virtualIps or nodeOrders options in the failoverClusterAppSource request parameter to create a failover cluster app.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;$name\&quot;,     \&quot;failoverClusterType\&quot;: \&quot;Windows\&quot;,     \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,     \&quot;failoverClusterAppSource\&quot;: {       \&quot;virtualIps\&quot;: [         \&quot;$virtualIp\&quot;       ],       \&quot;nodeOrders\&quot;: [         {           \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,           \&quot;nodeName\&quot;: \&quot;$nodeName\&quot;,           \&quot;order\&quot;: 0         }       ]     },     \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;}&#39;\\   \&quot;https://$cluster_address/api/v1/failover_cluster/failover_cluster_app\&quot; &#x60;&#x60;&#x60;  Response when a failover cluster app is created using the virtualIps option in the failoverClusterAppSource request parameter.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-21T17:32:44.266Z\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;failoverClusterType\&quot;: \&quot;Windows\&quot;,   \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,   \&quot;failoverClusterAppSource\&quot;: {     \&quot;virtualIps\&quot;: [       \&quot;$virtualIp\&quot;     ]   },   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot; } &#x60;&#x60;&#x60;  Response when a failover cluster app is created using the nodeOrders option in the failoverClusterAppSource request parameter.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-21T17:32:44.266Z\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;failoverClusterType\&quot;: \&quot;Windows\&quot;,   \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,   \&quot;failoverClusterAppSource\&quot;: {     \&quot;nodeOrders\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,         \&quot;nodeName\&quot;: \&quot;$nodeName\&quot;,         \&quot;order\&quot;: 0       }     ]   },   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot; } &#x60;&#x60;&#x60;  ### Get all failover cluster apps Get a listing of all failover cluster apps using a GET request to [/failover_cluster/failover_cluster_app](#operation/queryFailoverClusterApp).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/failover_cluster/failover_cluster_app?sort_order&#x3D;asc\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,       \&quot;failoverClusterType\&quot;: \&quot;UnixLike\&quot;,       \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,       \&quot;failoverClusterAppSource\&quot;: {         \&quot;virtualIps\&quot;: [           \&quot;$virtualIp\&quot;         ]       },       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;Linux\&quot;,       \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;   ### Get information about a specific failover cluster app Get information about a specific failover cluster app using a GET request to [/failover_cluster/failover_cluster_app/{id}](#operation/getFailoverClusterApp).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;failoverClusterType\&quot;: \&quot;Windows\&quot;,   \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,   \&quot;failoverClusterAppSource\&quot;: {     \&quot;virtualIps\&quot;: [       \&quot;$virtualIp\&quot;     ],   },   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot;,   \&quot;filesets\&quot;: [     {       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;forceFull\&quot;: true,       \&quot;forceFullPartitionIds\&quot;: [         0       ],       \&quot;allowBackupNetworkMounts\&quot;: true,       \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: true,       \&quot;useWindowsVss\&quot;: true,       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,       \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,       \&quot;hostName\&quot;: \&quot;$hostName\&quot;,       \&quot;templateId\&quot;: \&quot;$templateId\&quot;,       \&quot;templateName\&quot;: \&quot;$templateName\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,       \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,       \&quot;includes\&quot;: [         \&quot;$includes\&quot;       ],       \&quot;excludes\&quot;: [         \&quot;$excludes\&quot;       ],       \&quot;exceptions\&quot;: [         \&quot;$exceptions\&quot;       ],       \&quot;isRelic\&quot;: true,       \&quot;isPassthrough\&quot;: true,       \&quot;enableSymlinkResolution\&quot;: true,       \&quot;enableHardlinkSupport\&quot;: true,       \&quot;failoverClusterAppId\&quot;: \&quot;$failoverClusterAppId\&quot;,       \&quot;failoverClusterAppName\&quot;: \&quot;$failoverClusterAppName\&quot;,       \&quot;pendingSlaDomain\&quot;: {         \&quot;objectId\&quot;: \&quot;$objectId\&quot;,         \&quot;pendingSlaDomainId\&quot;: \&quot;$pendingSlaDomainId\&quot;,         \&quot;pendingSlaDomainName\&quot;: \&quot;$pendingSlaDomainName\&quot;,         \&quot;isPendingSlaDomainRetentionLocked\&quot;: true       },       \&quot;protectionDate\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,       \&quot;snapshotCount\&quot;: 0,       \&quot;archivedSnapshotCount\&quot;: 0,       \&quot;snapshots\&quot;: [         {           \&quot;id\&quot;: \&quot;$id\&quot;,           \&quot;date\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,           \&quot;expirationDate\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,           \&quot;sourceObjectType\&quot;: \&quot;$sourceObjectType\&quot;,           \&quot;isOnDemandSnapshot\&quot;: true,           \&quot;isCustomRetentionApplied\&quot;: true,           \&quot;cloudState\&quot;: 0,           \&quot;consistencyLevel\&quot;: \&quot;$consistencyLevel\&quot;,           \&quot;indexState\&quot;: 0,           \&quot;replicationLocationIds\&quot;: [             \&quot;$replicationLocationIds\&quot;           ],           \&quot;archivalLocationIds\&quot;: [             \&quot;$archivalLocationIds\&quot;           ],           \&quot;slaId\&quot;: \&quot;$slaId\&quot;,           \&quot;slaName\&quot;: \&quot;$slaName\&quot;,           \&quot;isRetainedByRetentionLockSla\&quot;: true,           \&quot;cloudStorageTier\&quot;: \&quot;Hot\&quot;,           \&quot;isPlacedOnLegalHold\&quot;: true,           \&quot;snapshotRetentionInfo\&quot;: {             \&quot;localInfo\&quot;: {               \&quot;id\&quot;: \&quot;$id\&quot;,               \&quot;name\&quot;: \&quot;$name\&quot;,               \&quot;isSnapshotPresent\&quot;: true,               \&quot;isExpirationDateCalculated\&quot;: true,               \&quot;expirationTime\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,               \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,               \&quot;isExpirationInformationUnavailable\&quot;: true             },             \&quot;archivalInfos\&quot;: [               {                 \&quot;id\&quot;: \&quot;$id\&quot;,                 \&quot;name\&quot;: \&quot;$name\&quot;,                 \&quot;isSnapshotPresent\&quot;: true,                 \&quot;isExpirationDateCalculated\&quot;: true,                 \&quot;expirationTime\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,                 \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,                 \&quot;isExpirationInformationUnavailable\&quot;: true               }             ],             \&quot;replicationInfos\&quot;: [               {                 \&quot;id\&quot;: \&quot;$id\&quot;,                 \&quot;name\&quot;: \&quot;$name\&quot;,                 \&quot;isSnapshotPresent\&quot;: true,                 \&quot;isExpirationDateCalculated\&quot;: true,                 \&quot;expirationTime\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,                 \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,                 \&quot;isExpirationInformationUnavailable\&quot;: true               }             ],             \&quot;cloudNativeLocationInfo\&quot;: [               {                 \&quot;id\&quot;: \&quot;$id\&quot;,                 \&quot;name\&quot;: \&quot;$name\&quot;,                 \&quot;isSnapshotPresent\&quot;: true,                 \&quot;isExpirationDateCalculated\&quot;: true,                 \&quot;expirationTime\&quot;: \&quot;2020-04-21T18:00:46.694Z\&quot;,                 \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,                 \&quot;isExpirationInformationUnavailable\&quot;: true               }             ]           },           \&quot;filesetName\&quot;: \&quot;$filesetName\&quot;,           \&quot;fileCount\&quot;: 0,           \&quot;snapdiffUsed\&quot;: true         }       ],       \&quot;localStorage\&quot;: 0,       \&quot;archiveStorage\&quot;: 0,       \&quot;preBackupScript\&quot;: \&quot;$preBackupScript\&quot;,       \&quot;postBackupScript\&quot;: \&quot;$postBackupScript\&quot;,       \&quot;backupScriptTimeout\&quot;: 0,       \&quot;backupScriptErrorHandling\&quot;: \&quot;$backupScriptErrorHandling\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Update the parameters of an existing failover cluster app The parameters associated with the failover cluster app can be updated by making a PATCH request to [/failover_cluster/failover_cluster_app/{id}](#operation/updateFailoverClusterApp)  Use either the virtualIps or nodeOrders options in the failoverClusterAppSource request parameter to update a failover cluster app.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;name\&quot;: \&quot;$name\&quot;,     \&quot;failoverClusterType\&quot;: \&quot;Windows\&quot;,     \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,     \&quot;failoverClusterAppSource\&quot;: {       \&quot;virtualIps\&quot;: [         \&quot;$virtualIp\&quot;       ],       \&quot;nodeOrders\&quot;: [         {           \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,           \&quot;nodeName\&quot;: \&quot;$nodeName\&quot;,           \&quot;order\&quot;: 0         }       ]     },     \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;}&#39;\\   \&quot;https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id\&quot; &#x60;&#x60;&#x60;  Response when a failover cluster app is updated using the virtualIps option in the failoverClusterAppSource request parameter.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-21T18:24:20.126Z\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;failoverClusterType\&quot;: \&quot;Windows\&quot;,   \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,   \&quot;failoverClusterAppSource\&quot;: {     \&quot;virtualIps\&quot;: [       \&quot;$virtualIp\&quot;     ],   },   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot; } &#x60;&#x60;&#x60;  Response when a failover cluster app is updated using the nodeOrders option in the failoverClusterAppSource request parameter.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;2020-04-21T18:24:20.126Z\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;failoverClusterType\&quot;: \&quot;Windows\&quot;,   \&quot;failoverClusterId\&quot;: \&quot;$failoverClusterId\&quot;,   \&quot;failoverClusterAppSource\&quot;: {     \&quot;nodeOrders\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,         \&quot;nodeName\&quot;: \&quot;$nodeName\&quot;,         \&quot;order\&quot;: 0       }     ]   },   \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;,   \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot; } &#x60;&#x60;&#x60;  ### Delete a specific failover cluster app Remove any failover cluster app by issuing a DELETE request to [/failover_cluster/failover_cluster_app/{id}](#operation/deleteFailoverClusterApp).  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/$failover_cluster_app_id?preserve_snapshots&#x3D;false\&quot; &#x60;&#x60;&#x60;  ### Bulk delete a failover cluster apps Specify a list of failover cluster applications to remove by issuing a DELETE request to [/failover_cluster/failover_cluster_app//bulk](#operation/bulkDeleteFailoverClusterApp).  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/failover_cluster/failover_cluster_app/bulk?ids&#x3D;$failover_cluster_app_id1,$failover_cluster_app_id2&amp;preserve_snapshots&#x3D;false\&quot; &#x60;&#x60;&#x60;  # Failover cluster hierarchy  This REST API is used to get failover cluster hierarchy objects.  ### Get summary of a hierarchy object Get a summary of a hierarchy object by making a GET call to [/failover_cluster/hierarchy/{id}](#operation/getFailoverClusterHierarchyObject).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_app_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,   \&quot;objectType\&quot;: \&quot;FailoverClusterApp\&quot;,   \&quot;descendentCount\&quot;: {     \&quot;failoverCluster\&quot;: 0,     \&quot;failoverClusterApp\&quot;: 0,     \&quot;fileset\&quot;: 1   },   \&quot;isDeleted\&quot;: false,   \&quot;numNodes\&quot;: 0,   \&quot;failoverClusterType\&quot;: \&quot;UnixLike\&quot;,   \&quot;failoverClusterAppConnectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;failoverClusterAppName\&quot;: \&quot;$failoverClusterAppName\&quot;,   \&quot;failoverClusterAppSource\&quot;: {     \&quot;virtualIps\&quot;: [       \&quot;$virtualIp\&quot;     ]   },   \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,   \&quot;filesets\&quot;: [     {       \&quot;allowBackupNetworkMounts\&quot;: false,       \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: false,       \&quot;useWindowsVss\&quot;: false,       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;hostName\&quot;: \&quot;$hostName\&quot;,       \&quot;templateId\&quot;: \&quot;$templateId\&quot;,       \&quot;templateName\&quot;: \&quot;$templateName\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;UnixLike\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;includes\&quot;: [         \&quot;$includes\&quot;       ],       \&quot;excludes\&quot;: [],       \&quot;exceptions\&quot;: [],       \&quot;isRelic\&quot;: false,       \&quot;isPassthrough\&quot;: false,       \&quot;enableSymlinkResolution\&quot;: false,       \&quot;enableHardlinkSupport\&quot;: false,       \&quot;failoverClusterAppId\&quot;: \&quot;$failoverClusterAppId\&quot;,       \&quot;failoverClusterAppName\&quot;: \&quot;$failoverClusterAppName\&quot;     }   ] } &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,   \&quot;objectType\&quot;: \&quot;HostFailoverCluster\&quot;,   \&quot;descendentCount\&quot;: {     \&quot;failoverCluster\&quot;: 0,     \&quot;failoverClusterApp\&quot;: 1,     \&quot;fileset\&quot;: 1   },   \&quot;isDeleted\&quot;: false,   \&quot;numNodes\&quot;: 2,   \&quot;nodes\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;     },     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;     }   ],   \&quot;failoverClusterConnectionStatus\&quot;: \&quot;Connected\&quot;,   \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot;,   \&quot;numFailoverClusterApps\&quot;: 1,   \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot; } &#x60;&#x60;&#x60;  ### Get list of immediate descendant objects Get a list of immediate descendant objects using a GET request to [/failover_cluster/hierarchy/{id}/children](#operation/getFailoverClusterHierarchyChildren).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/failover_cluster/hierarchy/root/children\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,       \&quot;objectType\&quot;: \&quot;HostFailoverCluster\&quot;,       \&quot;descendentCount\&quot;: {         \&quot;failoverCluster\&quot;: 0,         \&quot;failoverClusterApp\&quot;: 1,         \&quot;fileset\&quot;: 1       },       \&quot;isDeleted\&quot;: false,       \&quot;numNodes\&quot;: 2,       \&quot;nodes\&quot;: [         {           \&quot;id\&quot;: \&quot;$id\&quot;,           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,           \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;         },         {           \&quot;id\&quot;: \&quot;$id\&quot;,           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;connectionStatus\&quot;: \&quot;Connected\&quot;,           \&quot;operatingSystem\&quot;: \&quot;$operatingSystem\&quot;         }       ],       \&quot;failoverClusterConnectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;failoverClusterName\&quot;: \&quot;$failoverClusterName\&quot;,       \&quot;numFailoverClusterApps\&quot;: $numFailoverClusterApps,       \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;$operatingSystemType\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id/children\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,       \&quot;objectType\&quot;: \&quot;FailoverClusterApp\&quot;,       \&quot;descendentCount\&quot;: {         \&quot;failoverCluster\&quot;: 0,         \&quot;failoverClusterApp\&quot;: 0,         \&quot;fileset\&quot;: 1       },       \&quot;isDeleted\&quot;: false,       \&quot;numNodes\&quot;: 0,       \&quot;failoverClusterType\&quot;: \&quot;UnixLike\&quot;,       \&quot;failoverClusterAppConnectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;failoverClusterAppName\&quot;: \&quot;$failoverClusterAppName\&quot;,       \&quot;failoverClusterAppSource\&quot;: {         \&quot;virtualIps\&quot;: [           \&quot;$virtualIp\&quot;         ]       },       \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,       \&quot;filesets\&quot;: [         {           \&quot;allowBackupNetworkMounts\&quot;: false,           \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: false,           \&quot;useWindowsVss\&quot;: false,           \&quot;id\&quot;: \&quot;$id\&quot;,           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,           \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,           \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,           \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,           \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,           \&quot;hostName\&quot;: \&quot;$hostName\&quot;,           \&quot;templateId\&quot;: \&quot;$templateId\&quot;,           \&quot;templateName\&quot;: \&quot;$templateName\&quot;,           \&quot;operatingSystemType\&quot;: \&quot;UnixLike\&quot;,           \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,           \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,           \&quot;includes\&quot;: [             \&quot;$includes\&quot;           ],           \&quot;excludes\&quot;: [],           \&quot;exceptions\&quot;: [],           \&quot;isRelic\&quot;: false,           \&quot;isPassthrough\&quot;: false,           \&quot;enableSymlinkResolution\&quot;: false,           \&quot;enableHardlinkSupport\&quot;: false,           \&quot;failoverClusterAppId\&quot;: \&quot;$failoverClusterAppId\&quot;,           \&quot;failoverClusterAppName\&quot;: \&quot;$failoverClusterAppName\&quot;         }       ]     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Get list of descendant objects Get a list of descendant objects using a GET request to [/failover_cluster/hierarchy/{id}/descendants](#operation/getFailoverClusterHierarchyDescendants).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/failover_cluster/hierarchy/$failover_cluster_id/descendants\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,       \&quot;objectType\&quot;: \&quot;FailoverClusterApp\&quot;,       \&quot;descendentCount\&quot;: {         \&quot;failoverCluster\&quot;: 0,         \&quot;failoverClusterApp\&quot;: 0,         \&quot;fileset\&quot;: 1       },       \&quot;isDeleted\&quot;: false,       \&quot;numNodes\&quot;: 0,       \&quot;failoverClusterType\&quot;: \&quot;UnixLike\&quot;,       \&quot;failoverClusterAppConnectionStatus\&quot;: \&quot;Connected\&quot;,       \&quot;failoverClusterAppName\&quot;: \&quot;$failoverClusterAppName\&quot;,       \&quot;failoverClusterAppSource\&quot;: {         \&quot;virtualIps\&quot;: [           \&quot;$virtualIp\&quot;         ]       },       \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;,       \&quot;filesets\&quot;: [         {           \&quot;allowBackupNetworkMounts\&quot;: false,           \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: false,           \&quot;useWindowsVss\&quot;: false,           \&quot;id\&quot;: \&quot;$id\&quot;,           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,           \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,           \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,           \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,           \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,           \&quot;hostName\&quot;: \&quot;$hostName\&quot;,           \&quot;templateId\&quot;: \&quot;$templateId\&quot;,           \&quot;templateName\&quot;: \&quot;$templateName\&quot;,           \&quot;operatingSystemType\&quot;: \&quot;UnixLike\&quot;,           \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,           \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,           \&quot;includes\&quot;: [             \&quot;$includes\&quot;           ],           \&quot;excludes\&quot;: [],           \&quot;exceptions\&quot;: [],           \&quot;isRelic\&quot;: false,           \&quot;isPassthrough\&quot;: false,           \&quot;enableSymlinkResolution\&quot;: false,           \&quot;enableHardlinkSupport\&quot;: false,           \&quot;failoverClusterAppId\&quot;: \&quot;$failoverClusterAppId\&quot;,           \&quot;failoverClusterAppName\&quot;: \&quot;$failoverClusterAppName\&quot;         }       ]     },     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$effectiveSlaDomainId\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$effectiveSlaDomainName\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,       \&quot;objectType\&quot;: \&quot;Fileset\&quot;,       \&quot;descendentCount\&quot;: {         \&quot;failoverCluster\&quot;: 0,         \&quot;failoverClusterApp\&quot;: 0,         \&quot;fileset\&quot;: 0       },       \&quot;isDeleted\&quot;: false,       \&quot;numNodes\&quot;: 0,       \&quot;slaAssignment\&quot;: \&quot;$slaAssignment\&quot;     }   ],   \&quot;total\&quot;: 2 } &#x60;&#x60;&#x60;  # Filesets  A fileset defines a set of files and folders on a Linux, Unix, or Windows host, or on NAS shares. The Rubrik cluster uses the filesets that are specified for a host or a NAS share to determine the data to protect on that host or share.  The Rubrik cluster interprets a fileset based on the values provided in the Include, Exclude, and Do Not Exclude arrays of the fileset template that the fileset is based on. The Rubrik cluster uses the values of the arrays to determine the files and folders in a fileset. The Do Not Exclude array specifies objects that should not be excluded from the fileset by the values in the Exclude array.  ## Fileset workflow To protect data through filesets perform the following tasks: 1. Obtain and install the Rubrik Backup Service software on the host. The *Rubrik CDM User Guide* describes this task. 2. Add the host to the Rubrik cluster. The [Hosts](#section/Hosts) section describes this task. 3. Create a fileset template that defines a set of file system data to protect. The [Fileset templates](#fileset-templates) section describes this task. 4. Use a fileset template to assign a fileset to a host. 5. Assign the host fileset to an SLA Domain.  ## Fileset templates A fileset template encompasses a set of file system metadata that is needed to define filesets. The metadata includes the file system paths on the host that need protection or paths that do not need protection. The metadata varies with the type of the host or the NAS share to which the template applies.  ### Retrieving fileset templates To retrieve the current list of fileset templates, send a GET request to the [&#x60;/fileset_template&#x60;](#operation/queryFilesetTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\ \&quot;https://$cluster_address/api/v1/fileset_template\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a ListResponse object containing the first page of the current list of fileset templates.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;allowBackupNetworkMounts\&quot;: false,       \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: false,       \&quot;useWindowsVss\&quot;: false,       \&quot;name\&quot;: \&quot;$fileset_name\&quot;,       \&quot;includes\&quot;: [         \&quot;/users\&quot;       ],       \&quot;excludes\&quot;: [],       \&quot;exceptions\&quot;: [],       \&quot;operatingSystemType\&quot;: \&quot;$os_type1\&quot;,       \&quot;isArrayEnabled\&quot;: true,       \&quot;id\&quot;: \&quot;$fileset_template_id0\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;isArchived\&quot;: false,       \&quot;hostCount\&quot;: 0,       \&quot;shareCount\&quot;: 0     }    ],    \&quot;total\&quot;: 1  } &#x60;&#x60;&#x60;  To retrieve the details of a specific fileset template, send a GET request to the [&#x60;fileset_template/{id}&#x60;](#operation/getFilesetTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the fileset template identified by the value of the &#x60;{id}&#x60; path parameter.  ### Creating a fileset template Create a fileset template to simplify creating identical filesets for multiple hosts.  Operations for a fileset object are described in the [Fileset](#fileset) section.  To create a fileset-template, send a POST request to [&#x60;/fileset_template&#x60;](#operation/createFilesetTemplate) with the required details: &#x60;name&#x60;, &#x60;includes&#x60;, and &#x60;operatingSystemType&#x60; or &#x60;shareType&#x60;.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;Users\&quot;,     \&quot;includes\&quot;: [\&quot;C:\\\\Users\&quot;],     \&quot;operatingSystemType\&quot;: \&quot;$os_type1\&quot;     }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset_template\&quot; &#x60;&#x60;&#x60; To create a fileset template for a specific type of NAS share, replace &#x60;operatingSystemType&#x60; with &#x60;shareType&#x60; in the above payload. For example, &#x60;\&quot;shareType\&quot;:\&quot;NFS\&quot;&#x60;.  The Rubrik REST API server responds with the new fileset template object.  &#x60;&#x60;&#x60;bash {   \&quot;allowBackupNetworkMounts\&quot;: true,   \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: true,   \&quot;useWindowsVss\&quot;: true,   \&quot;name\&quot;: \&quot;Users\&quot;,   \&quot;includes\&quot;: [     \&quot;C:\\\\users\&quot;   ],   \&quot;excludes\&quot;: [],   \&quot;exceptions\&quot;: [],   \&quot;operatingSystemType\&quot;: \&quot;$os_type1\&quot;,   \&quot;isArrayEnabled\&quot;: false,   \&quot;id\&quot;: \&quot;$fileset_template_id1\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,   \&quot;isArchived\&quot;: false,   \&quot;hostCount\&quot;: 0,   \&quot;shareCount\&quot;: 0 } &#x60;&#x60;&#x60;  ### Updating a fileset template To modify the values of a specific fileset template, send a PATCH request to the [&#x60;/fileset_template/{id}&#x60;](#operation/updateFilesetTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{         \&quot;id\&quot;: \&quot;$fileset_template_id0\&quot;,         \&quot;allowBackupNetworkMounts\&quot;: true      }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the updated fileset template.  &#x60;&#x60;&#x60;bash {       \&quot;allowBackupNetworkMounts\&quot;: true,       \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: false,       \&quot;useWindowsVss\&quot;: false,       \&quot;name\&quot;: \&quot;$fileset_name\&quot;,       \&quot;includes\&quot;: [         \&quot;/users\&quot;       ],       \&quot;excludes\&quot;: [],       \&quot;exceptions\&quot;: [],       \&quot;operatingSystemType\&quot;: \&quot;$os_type2\&quot;,       \&quot;isArrayEnabled\&quot;: true,       \&quot;id\&quot;: \&quot;$fileset_template_id0\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;isArchived\&quot;: false,       \&quot;hostCount\&quot;: 0,       \&quot;shareCount\&quot;: 0     } &#x60;&#x60;&#x60;  ### Deleting a fileset template To delete a specific fileset template and all the associated filesets, send a DELETE request to the [&#x60;/fileset_template/{id}&#x60;](#operation/deleteFilesetTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/fileset_template/$fileset_template_id0\&quot; &#x60;&#x60;&#x60;  ## Fileset A fileset is an instance of the fileset template that is assigned to a specific host.  ### Retrieving filesets To retrieve the current list of filesets, send a GET request to the [&#x60;/fileset&#x60;](#operation/queryFileset) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/fileset\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a ListResponse object containing the first page of the current list of filesets.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;allowBackupNetworkMounts\&quot;: true,       \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: true,       \&quot;useWindowsVss\&quot;: true,       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;string\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,       \&quot;slaLastUpdateTime\&quot;: \&quot;2021-03-03T18:42:24.766Z\&quot;,       \&quot;hostId\&quot;: \&quot;string\&quot;,       \&quot;shareId\&quot;: \&quot;string\&quot;,       \&quot;hostName\&quot;: \&quot;string\&quot;,       \&quot;templateId\&quot;: \&quot;string\&quot;,       \&quot;templateName\&quot;: \&quot;string\&quot;,       \&quot;operatingSystemType\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,       \&quot;effectiveSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;string\&quot;,       \&quot;includes\&quot;: [         \&quot;string\&quot;       ],       \&quot;excludes\&quot;: [         \&quot;string\&quot;       ],       \&quot;exceptions\&quot;: [         \&quot;string\&quot;       ],       \&quot;isRelic\&quot;: true,       \&quot;arraySpec\&quot;: {         \&quot;proxyHostId\&quot;: \&quot;string\&quot;       },       \&quot;isPassthrough\&quot;: true,       \&quot;enableSymlinkResolution\&quot;: true,       \&quot;enableHardlinkSupport\&quot;: true,       \&quot;failoverClusterAppId\&quot;: \&quot;string\&quot;,       \&quot;failoverClusterAppName\&quot;: \&quot;string\&quot;,       \&quot;pendingSlaDomain\&quot;: {         \&quot;objectId\&quot;: \&quot;string\&quot;,         \&quot;pendingSlaDomainId\&quot;: \&quot;string\&quot;,         \&quot;pendingSlaDomainName\&quot;: \&quot;string\&quot;,         \&quot;isPendingSlaDomainRetentionLocked\&quot;: true       },       \&quot;snapMirrorLabelForFullBackup\&quot;: \&quot;string\&quot;,       \&quot;snapMirrorLabelForIncrementalBackup\&quot;: \&quot;string\&quot;     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  To retrieve the details of a specific fileset, send a GET request to the [&#x60;/fileset/{id}&#x60;](#operation/getFileset) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/fileset/$fileset_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the fileset identified by the value of the {id} path parameter.  ### Creating a fileset To create a fileset, send a POST request to [&#x60;/fileset&#x60;](#operation/createFileset) with the required details: the &#x60;hostId&#x60; or &#x60;shareId&#x60;, and the &#x60;templateId&#x60;. See [Retrieving fileset templates](#retrieving-fileset-templates) for information on obtaining a template ID, to create a fileset.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;templateId\&quot;: \&quot;$fileset_template_id\&quot;,     \&quot;hostId\&quot;: \&quot;$host_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset\&quot; &#x60;&#x60;&#x60; To create a fileset for a NAS share, replace &#x60;hostId&#x60; with &#x60;shareId&#x60; in the above payload. For example, &#x60;\&quot;shareId\&quot;: \&quot;$share_id\&quot;&#x60;.  The Rubrik REST API server responds with the new fileset object.  &#x60;&#x60;&#x60;bash {   \&quot;configuredSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;forceFull\&quot;: false,   \&quot;forceFullPartitionIds\&quot;: [],   \&quot;allowBackupNetworkMounts\&quot;: true,   \&quot;allowBackupHiddenFoldersInNetworkMounts\&quot;: false,   \&quot;useWindowsVss\&quot;: false,   \&quot;id\&quot;: \&quot;$fileset_id\&quot;,   \&quot;name\&quot;: \&quot;$fileset_name\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;Unprotected\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,   \&quot;hostId\&quot;: \&quot;$host_id\&quot;,   \&quot;hostName\&quot;: \&quot;$hostname\&quot;,   \&quot;templateId\&quot;: \&quot;$fileset_template_id\&quot;,   \&quot;templateName\&quot;: \&quot;$fileset_template_name\&quot;,   \&quot;operatingSystemType\&quot;: \&quot;UnixLike\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,   \&quot;includes\&quot;: [     \&quot;$location_to_protect\&quot;   ],   \&quot;excludes\&quot;: [],   \&quot;exceptions\&quot;: [],   \&quot;isRelic\&quot;: false,   \&quot;isPassthrough\&quot;: false,   \&quot;enableSymlinkResolution\&quot;: false,   \&quot;enableHardlinkSupport\&quot;: false,   \&quot;snapshotCount\&quot;: 0,   \&quot;archivedSnapshotCount\&quot;: 0,   \&quot;snapshots\&quot;: [] } &#x60;&#x60;&#x60; ### Updating a fileset To update the values of a specific fileset, send a PATCH request to the [&#x60;/fileset/{id}&#x60;](#operation/updateFileset) endpoint. The request payload includes the properties to be updated.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{            \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,            \&quot;forceFull\&quot;: true,            \&quot;forceFullPartitionIds\&quot;: [                        0             ],             \&quot;snapMirrorLabelForFullBackup\&quot;: \&quot;string\&quot;,             \&quot;snapMirrorLabelForIncrementalBackup\&quot;: \&quot;string\&quot;        }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset/$fileset_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the updated fileset.  ### Deleting a fileset To delete a specific fileset, send a DELETE request to the [&#x60;/fileset/{id}&#x60;](#operation/deleteFileset) endpoint.  By default, the Rubrik cluster preserves the snapshots of the fileset to be deleted.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/fileset/$fileset_id\&quot; &#x60;&#x60;&#x60; To delete the snapshots of the fileset along with the fileset, set the &#x60;preserve_snapshots&#x60; query parameter to &#x60;false&#x60; in the DELETE request.  &#x60;&#x60;&#x60;bash curl -X DELETE \\ \&quot;https://$cluster_address/api/v1/fileset/$fileset_id?preserve_snapshots&#x3D;false\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server deletes the specified fileset and the snapshots associated with the fileset.  ## On-demand backups of host filesets ### Creating on-demand snapshot To initiate an on-demand snapshot of a fileset, send a POST request to the [&#x60;/fileset/{id}/snapshot&#x60;](#operation/createFilesetBackupJob) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/fileset/$fileset_id/snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API responds with the ID for the on-demand snapshot request along with other details about the request, like the status and the time at which the request was received.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2021-03-04T20:07:55.169Z\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/fileset/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60; ### Retrieving snapshot ID To retrieve the snapshot ID, retrieve the status of the on-demand snapshot request by sending a GET request to the [&#x60;/fileset/request/{id}&#x60;](#operation/getFilesetAsyncRequestStatus) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/fileset/request/$request_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the status of the on-demand snapshot request. If the snapshot has completed successfully, the response includes the ID for the snapshot in the reference link to the snapshot.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot;,   \&quot;startTime\&quot;: \&quot;2021-03-04T20:07:55.169Z\&quot;,   \&quot;endTime\&quot;: \&quot;2021-03-04T20:12:54.792Z\&quot;,   \&quot;nodeId\&quot;: \&quot;$node_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/fileset/$snapshot_id/snapshot\&quot;,       \&quot;rel\&quot;: \&quot;result\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/fileset/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving snapshot details To retrieve information about a specific snapshot, send a GET request to the [&#x60;/fileset/snapshot/{id}&#x60;](#operation/getFilesetSnapshot) endpoint. By default, the flag to return verbose information about the fileset is set to &#x60;false&#x60;. Change the value of the &#x60;verbose&#x60; flag to &#x60;true&#x60; to get detailed information about the fileset.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id?verbose&#x3D;false\&quot; &#x60;&#x60;&#x60; The Rubrik REST API responds with the details of the specified fileset snapshot.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$snapshot_id\&quot;,   \&quot;date\&quot;: \&quot;2021-03-04T20:08:00.000Z\&quot;,   \&quot;sourceObjectType\&quot;: \&quot;Fileset\&quot;,   \&quot;isOnDemandSnapshot\&quot;: true,   \&quot;isCustomRetentionApplied\&quot;: false,   \&quot;cloudState\&quot;: 0,   \&quot;indexState\&quot;: 1,   \&quot;replicationLocationIds\&quot;: [],   \&quot;archivalLocationIds\&quot;: [],   \&quot;slaId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;slaName\&quot;: \&quot;Unprotected\&quot;,   \&quot;isRetainedByRetentionLockSla\&quot;: false,   \&quot;isPlacedOnLegalHold\&quot;: false,   \&quot;snapshotRetentionInfo\&quot;: {     \&quot;localInfo\&quot;: {       \&quot;id\&quot;: \&quot;$cluster_id\&quot;,       \&quot;name\&quot;: \&quot;LOCAL\&quot;,       \&quot;isSnapshotPresent\&quot;: true,       \&quot;isExpirationDateCalculated\&quot;: true,       \&quot;snapshotFrequency\&quot;: \&quot;Forever\&quot;     },     \&quot;archivalInfos\&quot;: [],     \&quot;replicationInfos\&quot;: [],     \&quot;cloudNativeLocationInfo\&quot;: []   },   \&quot;filesetName\&quot;: \&quot;$fileset_name\&quot;,   \&quot;fileCount\&quot;: 10,   \&quot;lastModified\&quot;: \&quot;2021-02-24T14:13:33+0000\&quot;,   \&quot;size\&quot;: 23572 } &#x60;&#x60;&#x60;  ### Deleting fileset snapshots To delete a specific fileset snapshot, send a DELETE request to the [&#x60;/fileset/snapshot/{id}&#x60;](#operation/deleteFilesetSnapshot) endpoint, where &#x60;{id}&#x60; is the ID of the snapshot.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API deletes the specified fileset snapshot.  To delete all the snapshots of a specific fileset, send a DELETE request to the [&#x60;/fileset/{id}/snapshot&#x60;](#operation/deleteFilesetSnapshots) endpoint, where &#x60;{id}&#x60; is the ID of the fileset.  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/fileset/$fileset_id/snapshot\&quot; &#x60;&#x60;&#x60; The Rubrik REST API deletes all the snapshots of the specified fileset.  ## SLA Domain protection of host filesets  To assign an SLA to a fileset, send a PATCH request to the [&#x60;/fileset/{id}&#x60;](#operation/updateFileset) endpoint.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{      \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset/$fileset_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details of the updated fileset.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$fileset_id\&quot;,   \&quot;excludes\&quot;: [],   \&quot;operatingSystemType\&quot;: \&quot;Windows\&quot;,   \&quot;includes\&quot;: [     \&quot;C:\\\\Users\&quot;   ],   \&quot;hostId\&quot;: \&quot;$host_id\&quot;,   \&quot;templateId\&quot;: \&quot;$fileset_template_id\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot; } &#x60;&#x60;&#x60;  ### Retrieving missed snapshots To retrieve the details of snapshots that were missed for a fileset, send a GET request to the [&#x60;/fileset/{id}/missed_snapshot&#x60;](#operation/getMissedFilesetSnapshots) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/fileset/$fileset_id/missed_snapshot\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the details of snapshots that were missed, for the specified fileset.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;archivalLocationType\&quot;: [         \&quot;LOCAL\&quot;       ],       \&quot;missedSnapshotTime\&quot;: \&quot;2021-03-04T07:59:59.999Z\&quot;,       \&quot;missedSnapshotTimeUnits\&quot;: [         {           \&quot;timeUnit\&quot;: \&quot;Daily\&quot;,           \&quot;frequency\&quot;: 1,           \&quot;retention\&quot;: 2         }       ]     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ## Search &amp; Recovery ### Searching at fileset-level To search for specific file within a fileset, send a GET request to the [&#x60;/fileset/{id}/search&#x60;](#operation/searchFileset) endpoint. Specify a path prefix or a filename prefix in the &#x60;path&#x60; query parameter.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/fileset/$fileset_id/search?path&#x3D;$path\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the files that match the search query.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;path\&quot;: \&quot;$path_to_file\&quot;,       \&quot;filename\&quot;: \&quot;$filename\&quot;,       \&quot;fileVersions\&quot;: [         {           \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;,           \&quot;lastModified\&quot;: \&quot;2014-07-17T02:02:54+0000\&quot;,           \&quot;size\&quot;: 533120,           \&quot;fileMode\&quot;: \&quot;file\&quot;,           \&quot;source\&quot;: \&quot;cloud\&quot;         }       ]     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60; ### Searching at host-level To search for specific file at the host-level, send a GET request to the [&#x60;/host/{id}/search&#x60;](#operation/searchHost) endpoint. Specify a path prefix or a filename prefix in the &#x60;path&#x60; query parameter.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/host/$host_id/search?path&#x3D;$path\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the files that match the search query.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;path\&quot;: \&quot;$path_to_file\&quot;,       \&quot;filename\&quot;: \&quot;$filename\&quot;,       \&quot;fileVersions\&quot;: [         {           \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;,           \&quot;lastModified\&quot;: \&quot;2014-07-17T02:02:54+0000\&quot;,           \&quot;size\&quot;: 533120,           \&quot;fileMode\&quot;: \&quot;file\&quot;,           \&quot;source\&quot;: \&quot;cloud\&quot;         }       ]     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Browsing files in a snapshot To list all files and folders within a snapshot, send a GET request to the [&#x60;/fileset/snapshot/{id}/browse&#x60;](#operation/browseFilesetSnapshot) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/browse?path&#x3D;$absolute_file_path\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of all the files and folders available at the specified path in the snapshot.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;filename\&quot;: \&quot;$filename\&quot;,       \&quot;path\&quot;: \&quot;$path_relative_to_absolute_file_path\&quot;,       \&quot;lastModified\&quot;: \&quot;2016-12-01T23:26:59+0000\&quot;,       \&quot;size\&quot;: 529024,       \&quot;fileMode\&quot;: \&quot;file\&quot;,       \&quot;statusMessage\&quot;: \&quot;\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60; ### Download options There are two options for downloading the files of a fileset snapshot: download the entire snapshot or download specific files from the snapshot.  To download the entire snapshot from an archival location, send a POST request to the [&#x60;/fileset/snapshot/{id}/download&#x60;](#operation/createDownloadFilesetSnapshotFromCloud) endpoint.   &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download\&quot; &#x60;&#x60;&#x60;  To download files from a specific location in a snapshot, send a POST request to the [&#x60;/fileset/snapshot/{id}/download_file&#x60;](#operation/createFilesetDownloadFileJob) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST -d \\ &#39;{     \&quot;sourceDir\&quot;: \&quot;$path_to_download_from\&quot;  }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an async download job and returns a job instance ID.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$job_instance_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2021-03-05T18:19:27.584Z\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address//api/v1/fileset/request/$job_instance_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  To retrieve the download location, send a GET request to the [&#x60;fileset/request/{id}&#x60;](#operation/getFilesetAsyncRequestStatus) endpoint where, &#x60;{id}&#x60; is the &#x60;$job_instance_id&#x60;.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/fileset/request/$job_instance_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the status of the download job. The response includes a download link when the job completes successfully.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$job_instance_id\&quot;,   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot;,   \&quot;startTime\&quot;: \&quot;2021-03-05T18:01:43.755Z\&quot;,   \&quot;endTime\&quot;: \&quot;2021-03-05T18:02:48.481Z\&quot;,   \&quot;nodeId\&quot;: \&quot;$node_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;$download_url\&quot;,       \&quot;rel\&quot;: \&quot;result\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/fileset/request/$job_instance_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Recovery options To restore files from a fileset snapshot on to the source host, send a POST request to the [&#x60;/fileset/snapshot/{id}/restore_file&#x60;](#operation/createFilesetRestoreFileJob) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;sourceDir\&quot;: \&quot;$source_of_restore\&quot;,     \&quot;destinationDir\&quot;: \&quot;$destination_of_restore\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/restore_file\&quot; &#x60;&#x60;&#x60;  To restore files from a fileset snapshot on to a host other than the source host, send a POST request to the [&#x60;/fileset/snapshot/{id}/export_file&#x60;](#operation/createFilesetExportFileJob).  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;sourceDir\&quot;: \&quot;$source_of_restore\&quot;,     \&quot;destinationDir\&quot;: \&quot;$destination_of_restore\&quot;,     \&quot;hostId\&quot;: \&quot;$destination_host_id\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/export_file\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an async restore job and returns a job instance ID.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$job_instance_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2021-03-05T18:19:27.584Z\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address//api/v1/fileset/request/$job_instance_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  To check the progress of the request, send a GET request to the [&#x60;fileset/request/{id}&#x60;](#operation/getFilesetAsyncRequestStatus) endpoint where, &#x60;{id}&#x60; is the &#x60;$job_instance_id&#x60;.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/fileset/request/$job_instance_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the status of the restore job.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$job_instance_id\&quot;,   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot;,   \&quot;startTime\&quot;: \&quot;2021-03-05T18:01:43.755Z\&quot;,   \&quot;endTime\&quot;: \&quot;2021-03-05T18:02:48.481Z\&quot;,   \&quot;nodeId\&quot;: \&quot;$node_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/fileset/request/$job_instance_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  #  host hierarchy  This REST API is used to get host/share hierarchy objects.  ### Get summary of a hierarchy object Get a summary of a hierarchy object by making a GET call to [/host/hierarchy/{id}]\\ (#operation/getHostHierarchyObject).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/host/hierarchy/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns a host hierarchy object contains the ID, objectType, status, descendantCount, primaryClusterId, name, alias, operatingSystem, operatingSystemType shareType, vendorType, hostId, exportPoint, filesets and isSnapdiff.  ### Get list of immediate descendant objects Get a list of immediate descendant objects using a GET request to [/host/hierarchy/{id}/children]\\ (#operation/getHostHierarchyChildren).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/host/hierarchy/{id}/children\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns a list of host hierarchy objects.  # Directories  A HDFS directory defines a set of files and folders on a HDFS cluster.  The Rubrik cluster uses the directorys that are assigned to a HDFS cluster to determine the data to protect on that cluster.  The Rubrik cluster interprets a directory based on the values provided in the Include, Exclude, and Do Not Exclude arrays. The Rubrik cluster applies a set of rules to the values provided in these arrays and permits several types of values to be added to the arrays. The Do Not Exclude array specifies objects that should not be excluded from the directory by the values in the Exclude array.  ## Directory workflow The basic workflow to follow when using directorys to protect data in host file systems is: 1. Obtain and install the Rubrik Backup Service software on the HDFS cluster. The Rubrik user guide describes this task. 2. Add the HDFS cluster to the Rubrik cluster. The [Hosts](#section/Hosts) section describes this task. 3. Create a directory template that defines a set of file system data to protect. 4. Use a directory template to assign a directory to a host. 5. Assign the host directory to an SLA Domain.  ## Directory templates  First, create a directory template. A directory template can be used to create directory instances for various HDFS clusters. Performing a POST on [&#x60;/hdfs_template&#x60;](#operation/createHdfsTemplate)  with the necessary details will create a directory template.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;name\&quot;: \&quot;Users\&quot;,     \&quot;includes\&quot;: [\&quot;/Users\&quot;]}&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs_template\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$directory_template_id\&quot;,   \&quot;name\&quot;: \&quot;Users\&quot;,   \&quot;excludes\&quot;: [],   \&quot;includes\&quot;: [     \&quot;/Users\&quot;   ] } &#x60;&#x60;&#x60;  To get the details of a directory template, use GET on the [&#x60;/hdfs_template/{id}&#x60;](#operation/getHdfsTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   -d &#39;{     \&quot;id\&quot;: \&quot;$directory_template_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs_template\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$host_id\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;,   \&quot;status\&quot;: \&quot;Connected\&quot; } &#x60;&#x60;&#x60;  To get the current list of all directory templates matching a query, use GET on the [&#x60;/hdfs_template&#x60;](#operation/queryHdfsTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$hostname\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs_template\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$host_id\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;,   \&quot;status\&quot;: \&quot;Connected\&quot; } &#x60;&#x60;&#x60;  Modify with PATCH on the [&#x60;/hdfs_template/{id}&#x60;](#operation/updateHdfsTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;id\&quot;: \&quot;$directory_template_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs_template\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$host_id\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;,   \&quot;status\&quot;: \&quot;Connected\&quot; } &#x60;&#x60;&#x60;  Delete with the [&#x60;/hdfs_template/{id}&#x60;](#operation/deleteHdfsTemplate) endpoint.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   -d &#39;{     \&quot;id\&quot;: \&quot;$directory_template_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs_template\&quot; &#x60;&#x60;&#x60; ## Directory  Create a directory using a directory template. The directory is an instance of the template that is assigned to a specific HDFS cluster.  To get the current list of HDFS clusters, use GET on the [&#x60;/hdfs&#x60;](#operation/queryHdfs) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$hostname\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$host_id\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;,   \&quot;status\&quot;: \&quot;Connected\&quot; } &#x60;&#x60;&#x60;  To get the current further details of HDFS clusters, use GET on the [&#x60;/hdfs/{id}&#x60;](#operation/getHdfs) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;hostname\&quot;: \&quot;$hostname\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$host_id\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;,   \&quot;status\&quot;: \&quot;Connected\&quot; } &#x60;&#x60;&#x60;  A directory can be created with a POST on [&#x60;/hdfs&#x60;](#operation/createHdfs).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;templateId\&quot;: \&quot;$directory_template_id\&quot;,     \&quot;hostId\&quot;: \&quot;$host_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$directory_id\&quot;,   \&quot;excludes\&quot;: [],   \&quot;includes\&quot;: [     \&quot;/Users\&quot;   ],   \&quot;hostId\&quot;: \&quot;$host_id\&quot;,   \&quot;templateId\&quot;: \&quot;$directory_template_id\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot; } &#x60;&#x60;&#x60;  A directory can be deleted with a DELETE on [&#x60;/hdfs&#x60;](#operation/deleteHdfs).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;templateId\&quot;: \&quot;directory_template_id\&quot;,     \&quot;hostId\&quot;: \&quot;$host_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$directory_id\&quot;,   \&quot;excludes\&quot;: [],   \&quot;includes\&quot;: [     \&quot;/Users\&quot;   ],   \&quot;hostId\&quot;: \&quot;$host_id\&quot;,   \&quot;templateId\&quot;: \&quot;$directory_template_id\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot; } &#x60;&#x60;&#x60; ## On demand backups of HDFS cluster directorys  To create an on-demand snapshot, use POST on [&#x60;/hdfs/{id}/snapshot&#x60;](#operation/createHdfsBackupJob).  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/hdfs/$directory_id/snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/hdfs/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  After taking a snapshot, retrieve the &#x60;$snapshot_id&#x60; by querying [&#x60;/hdfs/request&#x60;](#operation/getHdfsAsyncRequestStatus).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/hdfs/request/$request_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\&quot;,       \&quot;rel\&quot;: \&quot;result\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/hdfs/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot; } &#x60;&#x60;&#x60;   After taking a snapshot, retrieve the &#x60;$snapshot_id&#x60; from the request.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/hdfs/request/$request_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\&quot;,       \&quot;rel\&quot;: \&quot;result\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/hdfs/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot; } &#x60;&#x60;&#x60;  For more information about a specific snapshot, send a GET request to the [&#x60;/hdfs/snapshot/{id}&#x60;](#operation/getHdfsSnapshot) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$snapshot_id\&quot;   \&quot;date\&quot;: &lt;timestamp1&gt;,   \&quot;expirationDate\&quot;: &lt;timestamp2&gt;,   \&quot;sourceObjectType\&quot;: \&quot;Hdfs\&quot;,   \&quot;isOnDemandSnapshot\&quot;: true,   \&quot;cloudState\&quot;: 2,   \&quot;consistencyLevel\&quot;: \&quot;none\&quot;,   \&quot;indexState\&quot;: 1,   \&quot;replicationLocationIds\&quot;: [     \&quot;$replication_location_id\&quot;   ],   \&quot;archivalLocationIds\&quot;: [     \&quot;$archival_location_id\&quot;   ],   \&quot;slaId\&quot;: \&quot;$sla_id\&quot;,   \&quot;slaName\&quot;: \&quot;sla\&quot;,   \&quot;directoryName\&quot;: \&quot;directory\&quot;,   \&quot;fileCount\&quot;: 10,   \&quot;lastModified\&quot;: &lt;timestamp3&gt;,   \&quot;size\&quot;: 533120 } &#x60;&#x60;&#x60;  To delete a specific snapshot, send a DELETE request to the [&#x60;/hdfs/snapshot/{id}&#x60;](#operation/deleteHdfsSnapshot) endpoint, where &#x60;{id}&#x60; is the ID of the snapshot.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash { } &#x60;&#x60;&#x60;  Delete all snapshots for a specific HDFS cluster with a DELETE on [&#x60;/hdfs/{id}/snapshot&#x60;](#operation/deleteHdfsSnapshots).  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/hdfs/$id/snapshot\&quot; &#x60;&#x60;&#x60; ## SLA Domain protection of host directorys  Assign a directory to an SLA with a PATCH [&#x60;/hdfs/{id}&#x60;](#operation/updateHdfs).  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs/$directory_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$directory_id\&quot;,   \&quot;excludes\&quot;: [],   \&quot;includes\&quot;: [     \&quot;/Users\&quot;   ],   \&quot;hostId\&quot;: \&quot;$host_id\&quot;,   \&quot;templateId\&quot;: \&quot;$directory_template_id\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot; } &#x60;&#x60;&#x60;  List missed snapshots with a GET on [&#x60;/hdfs/{id}/missed_snapshot&#x60;](#operation/getMissedHdfsSnapshots).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/hdfs/$id/missed_snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;missedSnapshotTime\&quot;: \&quot;2000-01-02T11:08:40.420Z\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ## Search &amp; Recovery  Once snapshots have been taken, they can be used to search for files and recover.  File search can be performed on a specific directory using its &#x60;$directory_id&#x60; with a GET on [&#x60;/hdfs/{id}/search&#x60;](#operation/searchHdfs) and specifying the file path with the &#x60;path&#x60; query parameter.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/hdfs/$directory_id/search?path&#x3D;home\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;path\&quot;: \&quot;/home\&quot;,       \&quot;filename\&quot;: \&quot;home\&quot;,       \&quot;fileVersions\&quot;: [         {           \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;,           \&quot;lastModified\&quot;: \&quot;2014-07-17T02:02:54+0000\&quot;,           \&quot;size\&quot;: 533120         }       ]     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Files within a snapshot can be browsed by using GET on [&#x60;/hdfs/snapshot/{id}/browse&#x60;](#operation/browseHdfsSnapshot).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/browse?path&#x3D;%2Fhome&amp;offset&#x3D;0\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;filename\&quot;: \&quot;ubuntu\&quot;,       \&quot;path\&quot;: \&quot;ubuntu\&quot;,       \&quot;lastModified\&quot;: \&quot;2016-12-01T23:26:59+0000\&quot;,       \&quot;size\&quot;: 529024,     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Files from a snapshot can also be restored to a host with POST on [&#x60;/hdfs/snapshot/{id}/restore_file&#x60;](#operation/createHdfsRestoreFileJob).  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;sourceDir\&quot;: \&quot;/foo.txt\&quot;,     \&quot;destinationDir\&quot;: \&quot;/bar.txt\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/restore_file\&quot; &#x60;&#x60;&#x60;  Files can also be restored to a different host with POST on [&#x60;/hdfs/snapshot/{id}/export_file&#x60;](#operation/createHdfsExportFileJob).  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;sourceDir\&quot;: \&quot;/foo.txt\&quot;,     \&quot;destinationDir\&quot;: \&quot;/bar.txt\&quot;,     \&quot;hostId\&quot;: \&quot;$host_id\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/hdfs/snapshot/$snapshot_id/export_file\&quot; &#x60;&#x60;&#x60;  # SQL Server databases  Version 3.0 added support for Microsoft SQL backups. First add the hosts hosting the Microsoft SQL databases as specified in the [host protection](#section/Hosts) section. Once the host has been added, instances and databases will be auto-discovered.  ## Instances  Microsoft SQL instances can be found by a GET on [&#x60;/mssql/instance&#x60;](#operation/queryMssqlInstance)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/instance\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$instance_id\&quot;,       \&quot;name\&quot;: \&quot;$instance_name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Inherit\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Further details are acquired from [&#x60;/mssql/instance/{id}&#x60;](#operation/getMssqlInstance).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/instance/$instance_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$instance_id\&quot;,       \&quot;name\&quot;: \&quot;$instance_name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  The Rubrik cluster auto-detects most fields of the Microsoft SQL instance. However, certain fields such as the &#x60;clusterInstanceAddress&#x60; can be overridden with a PATCH to [&#x60;/mssql/instance/{id}&#x60;](#operation/updateMssqlInstance).  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;clusterInstanceAddress\&quot;: \&quot;1.1.1.1\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/instance/$instance_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     &#39;{       \&quot;id\&quot;: \&quot;$instance_id\&quot;,       \&quot;name\&quot;: \&quot;$instance_name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;clusterInstanceAddress\&quot;: \&quot;1.1.1.1\&quot;   }&#39; \\     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  The total number of SQL Server Instances can be found by GET on [/mssql/instance/count](#operation/countMssqlInstanceV1).    &#x60;&#x60;&#x60;bash   curl -X GET \&quot;https://$cluster_address/api/v1/mssql/instance/count\&quot;   &#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;bash   {     \&quot;count\&quot;: $total_number_of_instances   }   &#x60;&#x60;&#x60;  ## Databases  All Microsoft SQL databases on an instance can be found with a GET on  [&#x60;/mssql/db&#x60;](#operation/queryMssqlDb).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db?instance_id&#x3D;$instance_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;name\&quot;: \&quot;$db_name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;instanceId\&quot;: \&quot;$instance_id\&quot;       \&quot;instanceName\&quot;: \&quot;$instance_name\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Further details are acquired from [&#x60;/mssql/db/{id}&#x60;](#operation/getMssqlDb).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/$db_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;name\&quot;: \&quot;$db_name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;instanceId\&quot;: \&quot;$instance_id\&quot;       \&quot;instanceName\&quot;: \&quot;$instance_name\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  The total number of SQL Server Databases can be found by GET on  [/mssql/db/count](#operation/countMssqlDbV1).    &#x60;&#x60;&#x60;bash   curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/count?root_id&#x3D;$host_id\&quot;   &#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;bash   {     \&quot;numTotal\&quot;: 15,     \&quot;numProtected\&quot;: 2,     \&quot;numNoSla\&quot;: 0,     \&quot;numDoNotProtect\&quot;: 13   }   &#x60;&#x60;&#x60;  Snappable Id of a SQL Server database can be found by GET on [/mssql/db/{id}/snappable_id](#operation/mssqlGetSnappableIdV1).    &#x60;&#x60;&#x60;bash   curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/snappable_id\&quot;   &#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;bash   {     \&quot;snappableId\&quot;: \&quot;$snappable_id\&quot;   }   &#x60;&#x60;&#x60;  The properties of SQL Server database can be updated by PATCH on [/mssql/db/bulk](#operation/bulkUpdateMssqlDbV1).  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/mssql/db/bulk\&quot; -d\\ &#39;[   {       \&quot;databaseId\&quot;: \&quot;$db_id\&quot;,       \&quot;updateProperties\&quot;: {          \&quot;logBackupFrequencyInSeconds\&quot;: 2000,          \&quot;logRetentionHours\&quot;: 180,          \&quot;copyOnly\&quot;: true,          \&quot;maxDataStreams\&quot;: 8,          \&quot;isPaused\&quot;: true,          \&quot;shouldForceFull\&quot;: true    }  } ]&#39; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash [   {     \&quot;id\&quot;: \&quot;MssqlDatabase:::5d1da757-95d0-4740-9851-53c25c3dda2d\&quot;,     \&quot;name\&quot;: \&quot;simple_rec\&quot;,     \&quot;configuredSlaDomainId\&quot;: \&quot;ea82adf1-fa12-4b33-89af-9c2a08802a5d\&quot;,     \&quot;configuredSlaDomainName\&quot;: \&quot;Gold\&quot;,     \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,     \&quot;primaryClusterId\&quot;: \&quot;977dbc71-8137-4de5-be23-67251f0b63c1\&quot;,     \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,     \&quot;effectiveSlaDomainId\&quot;: \&quot;ea82adf1-fa12-4b33-89af-9c2a08802a5d\&quot;,     \&quot;effectiveSlaDomainName\&quot;: \&quot;Gold\&quot;,     \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,     \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;MssqlDatabase:::5d1da757-95d0-4740-9851-53c25c3dda2d\&quot;,     \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;simple_rec\&quot;,     \&quot;slaAssignment\&quot;: \&quot;Direct\&quot;,     \&quot;retentionSlaDomainId\&quot;: \&quot;ea82adf1-fa12-4b33-89af-9c2a08802a5d\&quot;,     \&quot;rootProperties\&quot;: {       \&quot;rootType\&quot;: \&quot;Host\&quot;,       \&quot;rootId\&quot;: \&quot;Host:::151e41d1-5395-4940-98ec-17460eae8949\&quot;,       \&quot;rootName\&quot;: \&quot;10.0.46.37\&quot;     },     \&quot;instanceId\&quot;: \&quot;MssqlInstance:::442b9524-9e45-4b03-aa66-eec1f3d0c470\&quot;,     \&quot;instanceName\&quot;: \&quot;SQLEXPRESS\&quot;,     \&quot;isRelic\&quot;: false,     \&quot;copyOnly\&quot;: true,     \&quot;logBackupFrequencyInSeconds\&quot;: 2000,     \&quot;logBackupRetentionHours\&quot;: 180,     \&quot;isLiveMount\&quot;: false,     \&quot;isLogShippingSecondary\&quot;: false,     \&quot;recoveryModel\&quot;: \&quot;FULL\&quot;,     \&quot;state\&quot;: \&quot;ONLINE\&quot;,     \&quot;hasPermissions\&quot;: true,     \&quot;isInAvailabilityGroup\&quot;: false,     \&quot;replicas\&quot;: [       {         \&quot;instanceId\&quot;: \&quot;MssqlInstance:::442b9524-9e45-4b03-aa66-eec1f3d0c470\&quot;,         \&quot;instanceName\&quot;: \&quot;SQLEXPRESS\&quot;,         \&quot;recoveryModel\&quot;: \&quot;FULL\&quot;,         \&quot;state\&quot;: \&quot;ONLINE\&quot;,         \&quot;hasPermissions\&quot;: true,         \&quot;isStandby\&quot;: false,         \&quot;recoveryForkGuid\&quot;: \&quot;83145A93-8921-4318-8508-B9ABE1D3B0F6\&quot;,         \&quot;isArchived\&quot;: false,         \&quot;isDeleted\&quot;: false,         \&quot;rootProperties\&quot;: {           \&quot;rootType\&quot;: \&quot;Host\&quot;,           \&quot;rootId\&quot;: \&quot;Host:::151e41d1-5395-4940-98ec-17460eae8949\&quot;,           \&quot;rootName\&quot;: \&quot;10.0.46.37\&quot;         }       }     ],     \&quot;unprotectableReasons\&quot;: [],     \&quot;numMissedSnapshot\&quot;: 0,     \&quot;lastSnapshotTime\&quot;: \&quot;2020-09-07T13:36:33.000Z\&quot;,     \&quot;includeBackupTaskInfo\&quot;: false,     \&quot;isOnline\&quot;: true,     \&quot;blackoutWindowStatus\&quot;: {       \&quot;isGlobalBlackoutActive\&quot;: false,       \&quot;isSnappableBlackoutActive\&quot;: true     },     \&quot;blackoutWindows\&quot;: {       \&quot;globalBlackoutWindows\&quot;: [],       \&quot;snappableBlackoutWindows\&quot;: [         {           \&quot;startTime\&quot;: \&quot;2020-09-13T11:02:04+0000\&quot;         }       ]     },     \&quot;snapshotCount\&quot;: 2,     \&quot;isLocal\&quot;: true,     \&quot;isStandby\&quot;: false,     \&quot;latestRecoveryPoint\&quot;: \&quot;2020-09-07T14:11:54.000Z\&quot;,     \&quot;oldestRecoveryPoint\&quot;: \&quot;2020-09-07T12:47:38.000Z\&quot;,     \&quot;protectionDate\&quot;: \&quot;2020-08-26T07:43:26.429Z\&quot;,     \&quot;recoveryForkGuid\&quot;: \&quot;83145A93-8921-4318-8508-B9ABE1D3B0F6\&quot;,     \&quot;maxDataStreams\&quot;: 8,     \&quot;localStorage\&quot;: 1363475,     \&quot;archiveStorage\&quot;: 0   } ] &#x60;&#x60;&#x60;  ## Availability Groups  To get the details of a SQL Server Availability Group, GET on [&#x60;/mssql/availability_group/{id}&#x60;](#operation/getMssqlAvailabilityGroupV1).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/availability_group/$availability_group_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$availability_group_id\&quot;,   \&quot;name\&quot;: \&quot;$availability_group_name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_id\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$sla_name\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;$sla_type\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primary_cluster_id\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: $is_sla_retention_locked,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$sla_id\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$sla_name\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: $is_sla_retention_locked,   \&quot;slaAssignment\&quot;: \&quot;$sla_assignment\&quot;,   \&quot;logBackupFrequencyInSeconds\&quot;: $log_backup_frequenct,   \&quot;logRetentionHours\&quot;: $log_backup_retention,   \&quot;copyOnly\&quot;: $copy_only } &#x60;&#x60;&#x60;  To get a summary of all SQL Server Availability Groups, GET on [&#x60;/mssql/availability_group&#x60;](#operation/queryMssqlAvailabilityGroupV1).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/availability_group\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$availability_group_id\&quot;,       \&quot;name\&quot;: \&quot;$availability_group_name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_id\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$sla_name\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;$sla_type\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primary_cluster_id\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: $is_sla_retention_locked,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$sla_id\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;$sla_name\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: $is_sla_retention_locked,       \&quot;slaAssignment\&quot;: \&quot;$sla_assignment\&quot;,       \&quot;logBackupFrequencyInSeconds\&quot;: $log_backup_frequenct,       \&quot;logRetentionHours\&quot;: $log_backup_retention,       \&quot;copyOnly\&quot;: $copy_only     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  To update a SQL Server Availability Group, PATCH on [&#x60;/mssql/availability_group/{id}&#x60;](#operation/updateMssqlAvailabilityGroupV1).  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/mssql/availability_group/$availability_group_id\&quot; -d\\  &#39;{     \&quot;logBackupFrequencyInSeconds\&quot;: $log_backup_freq,     \&quot;logRetentionHours\&quot;: $log_backup_retention,     \&quot;copyOnly\&quot;: $copy_only,     \&quot;configuredSlaDomainId\\\&quot;: \&quot;$sla_id\&quot;   }&#39; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$availability_group_id\&quot;,   \&quot;name\&quot;: \&quot;$availability_group_name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_id\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$sla_name\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;$sla_type\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primary_cluster_id\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: $is_sla_retention_locked,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$sla_id\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;$sla_name\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: $is_sla_retention_locked,   \&quot;slaAssignment\&quot;: \&quot;$sla_assignment\&quot;,   \&quot;logBackupFrequencyInSeconds\&quot;: $log_backup_frequenct,   \&quot;logRetentionHours\&quot;: $log_backup_retention,   \&quot;copyOnly\&quot;: $copy_only } &#x60;&#x60;&#x60;  ## Protection  To create an on-demand snapshot, POST on [&#x60;/mssql/db/{id}/snapshot&#x60;](#operation/createOnDemandMssqlBackup).  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  Once the snapshot has been taken, the &#x60;$snapshot_id&#x60; can be retrieved from the request with [&#x60;/mssql/request/{id}&#x60;](#operation/getMssqlAsyncRequestStatus).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/mssql/request/$request_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\&quot;,       \&quot;rel\&quot;: \&quot;result\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot; } &#x60;&#x60;&#x60;  The &#x60;$snapshot_id&#x60; can be used to extract further information on the snapshot with a GET on [&#x60;/mssql/db/snapshot/{id}&#x60;](#operation/getMssqlDbSnapshot).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$snapshot_id\&quot;,   \&quot;date\&quot;: \&quot;2017-02-02T18:53:12.718Z\&quot;,   \&quot;isOnDemandSnapshot\&quot;: true } &#x60;&#x60;&#x60;  To create an on-demand log backup, POST on [&#x60;/mssql/db/{id}/log_backup&#x60;](#operation/createOnDemandMssqlLogBackup).  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/log_backup\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  To protect a specific database under an SLA, perform a PATCH on [&#x60;/mssql/db/{id}&#x60;](#operation/updateMssqlDb)  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$db_id\&quot;,   \&quot;name\&quot;: \&quot;$db_name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$sla_domain_name\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;sla_domain_name\&quot;,   \&quot;instanceId\&quot;: \&quot;$instance_id\&quot;   \&quot;instanceName\&quot;: \&quot;$instance_name\&quot; } &#x60;&#x60;&#x60;  List all snapshots for a database with a GET on [&#x60;/mssql/db/{id}/snapshot&#x60;](#operation/queryMssqlDbSnapshot).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$snapshot_id\&quot;,       \&quot;date\&quot;: \&quot;2017-02-02T18:53:12.718Z\&quot;,       \&quot;isOnDemandSnapshot\&quot;: true     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Point-in-time recovery is supported when log backups are taken. The range of recoverable times can be listed with a GET on [&#x60;/mssql/db/{id}/recoverable_range&#x60;](#operation/getMssqlDbRecoverableRanges).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;beginTime\&quot;: \&quot;2017-02-02T18:53:12.694Z\&quot;,       \&quot;endTime\&quot;: \&quot;2017-02-02T20:53:12.694Z\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ## Download The Rubrik REST API server provides endpoints to browse and download snapshots and logs for a specific SQL Server database.  ### Browsing SQL Server snapshots To view a list of snapshots and log backups of a specific SQL Server database, send a POST request to the  [&#x60;/mssql/db/{id}/browse&#x60;](#operation/browseMssqlBackupFiles) endpoint where, &#x60;{id}&#x60; is the ID of the SQL Server database.  This POST call fetches metadata based on a timestamp or the log sequence number (LSN) provided in the request payload.  To fetch a list of snapshots and log backups that are required to recover to a point in time, specify the point in time using either the &#x60;date&#x60; or the &#x60;lsnpoint&#x60; attribute of the &#x60;recoveryPoint&#x60; attribute. Both &#x60;date&#x60; and &#x60;lsnPoint&#x60; cannot be used at the same time.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{          \&quot;recoveryPoint\&quot;: {\&quot;date\&quot;: \&quot;2019-08-15T10:40\&quot;}    }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/browse &#x60;&#x60;&#x60;  To fetch a list of snapshots and log backups that fit within a range, specify the range by using a combination of the &#x60;startPoint&#x60; and &#x60;endPoint&#x60; attributes. Within the &#x60;startPoint&#x60; and &#x60;endPoint&#x60; attributes, specify values for either the &#x60;lsnPoint&#x60; or the &#x60;date&#x60; attributes, not for both.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{          \&quot;startPoint\&quot;: {\&quot;date\&quot;: \&quot;2019-08-15T10:40\&quot;},          \&quot;endPoint\&quot;: {\&quot;date\&quot;: \&quot;2019-08-15T10:45:47\&quot;}     }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/browse &#x60;&#x60;&#x60;  To recover to a point in time, use the &#x60;recoveryPoint&#x60; attribute; do not define a range using the &#x60;startPoint&#x60; and &#x60;endPoint&#x60; attributes.  To fetch a list of snapshots and log backups that fit within a range, specify the beginning of a range using the &#x60;startPoint&#x60; attribute and specify the end of the range using the &#x60;endPoint&#x60; attribute. When specifying a range, do not specify a &#x60;recoveryPoint&#x60;.  The Rubrik REST API server responds with the list of the log and database snapshots that fit within the parameters specified in the request.  &#x60;&#x60;&#x60;bash {   \&quot;items\&quot;: [     {       \&quot;backupId\&quot;: \&quot;e8f0c6ee-fafc-4740-b9c9-deadba9815df\&quot;,       \&quot;backupType\&quot;: \&quot;Log\&quot;,       \&quot;path\&quot;: \&quot;testdb/logs/2019-08-15T10-40-58Z.trn\&quot;,       \&quot;date\&quot;: \&quot;2019-08-15T10:40:58.000Z\&quot;,       \&quot;lsn\&quot;: \&quot;45000000219000001\&quot;,       \&quot;recoveryForkGuid\&quot;: \&quot;03F633D8-6B5A-48F5-97F0-401440F124FD\&quot;,       \&quot;backupSize\&quot;: 86528     },     {       \&quot;backupId\&quot;: \&quot;5e3de1ce-f5ab-4787-a057-accec64fe7af\&quot;,       \&quot;backupType\&quot;: \&quot;Snapshot\&quot;,       \&quot;path\&quot;: \&quot;testdb/snapshot-2019-08-15T10-45-31Z/\&quot;,       \&quot;date\&quot;: \&quot;2019-08-15T10:45:47.000Z\&quot;,       \&quot;lsn\&quot;: \&quot;45000000221300001\&quot;,       \&quot;recoveryForkGuid\&quot;: \&quot;03F633D8-6B5A-48F5-97F0-401440F124FD\&quot;,       \&quot;backupSize\&quot;: 16777216     },     {       \&quot;backupId\&quot;: \&quot;c57d1908-c085-43ef-9a7f-fcb482994bf7\&quot;,       \&quot;backupType\&quot;: \&quot;Log\&quot;,       \&quot;path\&quot;: \&quot;testdb/logs/2019-08-15T10-46-03Z.trn\&quot;,       \&quot;date\&quot;: \&quot;2019-08-15T10:46:03.000Z\&quot;,       \&quot;lsn\&quot;: \&quot;45000000222300001\&quot;,       \&quot;recoveryForkGuid\&quot;: \&quot;03F633D8-6B5A-48F5-97F0-401440F124FD\&quot;,       \&quot;backupSize\&quot;: 86528     }   ] }  &#x60;&#x60;&#x60;  ### Downloading all SQL Server snapshots and logs To initiate a request to build a zip file containing the snapshots and log backups that are required to recover to a specific point in time, or a range of time, send a POST request to the [&#x60;/mssql/db/{id}/download_files&#x60;](#operation/createDownloadMssqlBackupFiles) endpoint.  The usage of parameters for this POST call is identical to the usage described for the [browse API call](#browsing-sql-server-snapshots).  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{ \&quot;startPoint\&quot;: {\&quot;date\&quot;: \&quot;2019-08-15T10:40\&quot;}, \&quot;endPoint\&quot;: {\&quot;date\&quot;: \&quot;2019-08-15T10:45:47\&quot;} }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/download_files &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the asynchronous task that is initiated by the POST API call.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;$request_status\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2021-03-23T20:38:05.511Z\&quot;,   \&quot;endTime\&quot;: \&quot;2021-03-23T20:38:05.511Z\&quot;,   \&quot;nodeId\&quot;: \&quot;$node_id\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;$error_message\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  To check the status of the download request, send a GET request to the (&#x60;/mssql/request/{id}&#x60;)[#operation/getMssqlAsyncRequestStatus] endpoint where, &#x60;{id}&#x60; is the &#x60;$request_id&#x60;.  The Rubrik REST API server responds with the link to download the zip file when the zip file is ready for download.  ### Downloading specific SQL Server snapshots and logs To initiate a request to build a zip file containing specific snapshots and log backups, send a POST request to the [&#x60;/mssql/db/{id}/download_files_by_id&#x60;](#operation/createDownloadMssqlBackupFilesById) endpoint with the object IDs for the snapshots and logs to be downloaded.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{ \&quot;items\&quot;: [\&quot;e8f0c6ee-fafc-4740-b9c9-deadba9815df\&quot;, \&quot;c57d1908-c085-43ef-9a7f-fcb482994bf7\&quot;] }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/download_files_by_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the asynchronous task that is initiated by the POST API call.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;$request_status\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2021-03-23T20:38:05.511Z\&quot;,   \&quot;endTime\&quot;: \&quot;2021-03-23T20:38:05.511Z\&quot;,   \&quot;nodeId\&quot;: \&quot;$node_id\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;$error_message\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60; To check the status of the download request, send a GET request to the (&#x60;/mssql/request/{id}&#x60;)[#operation/getMssqlAsyncRequestStatus] endpoint where, &#x60;{id}&#x60; is the &#x60;$request_id&#x60;.  The Rubrik REST API server responds with the link to download the zip file when the zip file is ready for download.  The zip file uses the naming convention of &#x60;$database_name&#x60;- &#x60;$random_string&#x60;.zip.  The path to the log backup files inside the zip file is of the form &#x60;$database_name&#x60;/logs/&#x60;$database_name&#x60;-&#x60;$timestamp&#x60;.trn. For example, if the &#x60;$database_name&#x60; is &#x60;BigDatabase&#x60;, the log backup file is located at &#x60;BigDatabase/logs/BigDatabase-2021-03-23T03-15-55Z.trn&#x60; inside the downloaded zip file.  The path to the database snapshot files inside the zip file is of the form &#x60;$database_name&#x60;/snapshot-&#x60;$timestamp&#x60;/&#x60;$snapshot_files&#x60;. For example, if the &#x60;$database_name&#x60; is &#x60;BigDatabase&#x60; and a snapshot filename is &#x60;snapshot.mdf&#x60;, then the  location of the file inside the downloaded zip file is &#x60;BigDatabase/snapshot-2021-03-23T03-15-55Z/snapshot.mdf&#x60;.   Make an asynchronous POST request to the [&#x60;/mssql/db/{id}/download&#x60;](#operation/downloadFromArchive) endpoint to download snapshots and logs from archival for a given database and recovery point.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{ \&quot;recoveryPoint\&quot;: { \&quot;timestampMs\&quot;: 12345 } }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/download\&quot; &#x60;&#x60;&#x60;  A &#39;missed snapshot&#39; occurs when a snapshot that is required by SLA Domain policy cannot be created. To retrieve information about missed snapshots, send a GET request to the [&#x60;/mssql/db/{id}/missed_snapshot&#x60;](#operation/getMissedMssqlDbSnapshots) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/missed_snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;missedSnapshotTime\&quot;: \&quot;2000-01-02T11:08:40.420Z\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  To retrieve the recoverable time ranges that were missed for a specified database, send a GET request to the [&#x60;/mssql/db/{id}/missed_recoverable_range&#x60;](#operation/getMssqlDbMissedRecoverableRanges) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/missed_recoverable_range\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;beginTime\&quot;: \&quot;2017-02-02T18:53:12.694Z\&quot;,       \&quot;endTime\&quot;: \&quot;2017-02-02T20:53:12.694Z\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Delete all snapshots for a specific database with a DELETE on [&#x60;/mssql/db/{id}/snapshot&#x60;](#operation/deleteMssqlDbSnapshots).  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/snapshot\&quot; &#x60;&#x60;&#x60;  Assign SLA properties to multiple objects with a POST to [&#x60;mssql/sla_domain/assign&#x60;](#operation/assignMssqlSlaProperties).  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;ids\&quot;: [\&quot;$id1\&quot;, \&quot;$id2\&quot;],     \&quot;copyOnly\&quot;: true,     \&quot;configuredSlaDomainId\&quot;: \&quot;$slaDomainId\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/sla_domain/assign\&quot; &#x60;&#x60;&#x60;  To take on demand snapshot of multiple SQL Server databases, perform POST on  [&#x60;/mssql/db/bulk/snapshot&#x60;](#operation/createOnDemandMssqlBatchBackupV1).  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/mssql/db/bulk/snapshot\&quot; -d\\ &#39;{    \&quot;slaId\&quot;: \&quot;$sla_id\&quot;,    \&quot;databaseIds\&quot;: [      \&quot;$db_id_1\&quot;,      \&quot;$db_id_2\&quot;    ],    \&quot;instanceIds\&quot;: [      \&quot;$instance_id_3\&quot;    ],    \&quot;hostIds\&quot;: [      \&quot;$host_id_4\&quot;,      \&quot;$host_id_5\&quot;,      \&quot;$host_id_6\&quot;,    ],    \&quot;windowsClusterIds\&quot;: [      \&quot;$windows_cluster_id_7\&quot;    ],    \&quot;availabilityGroupIds\&quot;: [      \&quot;$availability_group_id_8\&quot;    ],    \&quot;forceFullSnapshot\&quot;: true  }&#39; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$mssql_multi_host_batch_backup_job_id\&quot;,   \&quot;status\&quot;: \&quot;$job_status\&quot;,   \&quot;progress\&quot;: $job_progress,   \&quot;startTime\&quot;: \&quot;$job_start_time\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;$link1\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ]  &#x60;&#x60;&#x60;  Get the details of on demand backup job of SQL Server databases by performing  GET on  [&#x60;/mssql/db/bulk/snapshot/{id}&#x60;](#operation/getOnDemandMssqlBatchBackupResultV1).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/bulk/snapshot/$mssql_multi_host_batch_backup_job_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$mssql_multi_host_batch_backup_job_id\&quot;,   \&quot;successfulSnapshots\&quot;: [     {       \&quot;databaseId\&quot;: \&quot;$db_id\&quot;,       \&quot;snapshotId\&quot;: \&quot;$snapshot_id\&quot;     }   ],   \&quot;failedSnapshots\&quot;: [     {       \&quot;databaseId\&quot;: \&quot;$db_id_2\&quot;,       \&quot;error\&quot;: \&quot;$error\&quot;     }   ],   \&quot;canceledSnapshots\&quot;: [] } &#x60;&#x60;&#x60;   To delete all the downloaded snapshots and logs for a SQL Server database,  perform DELETE on  [&#x60;mssql/db/{id}/recoverable_range/download&#x60;](#operation/deleteDownloadedMssqlDbRecoverableRangesV1).  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range_download\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;jobInstanceId\&quot;: \&quot;$expire_mssql_download_ranges_job_id\&quot; } &#x60;&#x60;&#x60;  To get the deletion status of downloaded recoverable range, perform GET on  [&#x60;/mssql/db/recoverable_range/download/{id}&#x60;](#operation/getDeleteMssqlDbRecoverableRangesStatusV1).  &#x60;&#x60;&#x60;bash curl -X GET \\ \&quot;https://$cluster_address/api/v1/mssql/db/recoverable_range/download/$expire_mssql_download_ranges_job_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$expire_mssql_download_ranges_job_id\&quot;   \&quot;status\&quot;: \&quot;SUCCEEDED\&quot;,   \&quot;startTime\&quot;: \&quot;$job_start_time\&quot;,   \&quot;endTime\&quot;: \&quot;$job_end_time\&quot;,   \&quot;jobType\&quot;: \&quot;EXPIRE_MSSQL_DOWNLOADED_RANGES\&quot;,   \&quot;nodeId\&quot;: \&quot;$node_id\&quot;,   \&quot;isDisabled\&quot;: $is_disabled,   \&quot;archived\&quot;: $archived } &#x60;&#x60;&#x60;  To get the default SQL Server database backup properties, perform GET on  [&#x60;/mssql/db/defaults&#x60;](#operation/getDefaultDbPropertiesV1).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/defaults\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;logBackupFrequencyInSeconds\&quot;: $log_backup_frequency,   \&quot;cbtStatus\&quot;: $cbt_status,   \&quot;logRetentionTimeInHours\&quot;: $log_retention_time } &#x60;&#x60;&#x60;  To update the default SQL Server database backup properties, perform PATCH on  [&#x60;/mssql/db/defaults&#x60;](#operation/updateDefaultDbPropertiesV1).  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/mssql/db/defaults\&quot; -d\\  &#39;{     \&quot;logBackupFrequencyInSeconds\&quot;: 900,     \&quot;cbtStatus\&quot;: true,     \&quot;logRetentionTimeInHours\&quot;: 168   }&#39; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;logBackupFrequencyInSeconds\&quot;: 900,   \&quot;cbtStatus\&quot;: true,   \&quot;logRetentionTimeInHours\&quot;: 168 } &#x60;&#x60;&#x60;  ## Restore  Perform a restore with a POST on [&#x60;/mssql/db/{id}/restore&#x60;](#operation/createRestoreMssqlDb) specifying the timestamp as the recovery point.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;recoveryPoint\&quot;: {       \&quot;timestampMs\&quot;: 12345     }   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/restore\&quot; &#x60;&#x60;&#x60;  A database can also be exported to another instance with a POST on [&#x60;/mssql/db/{id}/export&#x60;](#operation/createExportMssqlDb).  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;recoveryPoint\&quot;: {       \&quot;timestampMs\&quot;: 12345     },     \&quot;targetInstanceId\&quot;: \&quot;$instance_id\&quot;,     \&quot;targetDatabaseName\&quot;: \&quot;$db_name\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/export\&quot; &#x60;&#x60;&#x60;  List of all the database files which are needed to restore a SQL Server  database can be found by GET on  [/mssql/db/{id}/restore_files](#operation/mssqlGetRestoreFilesV1).    &#x60;&#x60;&#x60;bash   curl -X GET \&quot;https://$cluster_address/api/v1mssql/db/$db_id/restore_files?time&#x3D;$time_to_restore\&quot;   &#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;bash   [     {       \&quot;logicalName\&quot;: \&quot;$logical_file_name\&quot;,       \&quot;originalPath\&quot;: \&quot;$original_file_path\&quot;,       \&quot;originalName\&quot;: \&quot;$original_file_name\&quot;,       \&quot;fileType\&quot;: \&quot;Data\&quot;,       \&quot;fileId\&quot;: $file_id     },     {       \&quot;logicalName\&quot;: \&quot;$logical_file_name\&quot;,       \&quot;originalPath\&quot;: \&quot;$original_file_path\&quot;,       \&quot;originalName\&quot;: \&quot;$original_file_name\&quot;,       \&quot;fileType\&quot;: \&quot;Log\&quot;,       \&quot;fileId\&quot;: $file_id     }   ]   &#x60;&#x60;&#x60;  An estimate of resources needed for restoring a SQL Server database can be  found by GET on  [/mssql/db/{id}/restore_estimate](#operation/mssqlRestoreEstimateV1).    &#x60;&#x60;&#x60;bash   curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/restore_estimate?time&#x3D;$time_to_restore\&quot;   &#x60;&#x60;&#x60;    &#x60;&#x60;&#x60;bash   {     \&quot;bytesFromCloud\&quot;: $bytes_from_cloud   }   &#x60;&#x60;&#x60;  Get compatible instances for recovery of a SQL Server database by performing  GET on  [/mssql/db/{id}/compatible_instance](#operation/getCompatibleMssqlInstancesV1).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/compatible_instance?recovery_type&#x3D;$recovery_type\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;logBackupFrequencyInSeconds\&quot;: $log_backup_frequency,       \&quot;logRetentionHours\&quot;: $log_backup_retention,       \&quot;copyOnly\&quot;: $copy_only,       \&quot;id\&quot;: \&quot;$instance_id\&quot;,       \&quot;internalTimestamp\&quot;: $internal_timestamp,       \&quot;name\&quot;: \&quot;$instance_name\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;rootProperties\&quot;: {         \&quot;rootType\&quot;: \&quot;$root_type\&quot;,         \&quot;rootId\&quot;: \&quot;$root_id\&quot;,         \&quot;rootName\&quot;: \&quot;$root_name\&quot;       },       \&quot;version\&quot;: \&quot;$version\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;$sla_type\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$sla_name\&quot;,       \&quot;isRetentionLocked\&quot;: $is_retention_locked,       \&quot;unprotectableReasons\&quot;: []     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ## Live Mount  Perform a Live Mount with a POST on [&#x60;/mssql/db/{id}/mount&#x60;](#operation/createMssqlMount), specifying the timestamp as the recovery point.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;recoveryPoint\&quot;: {       \&quot;timestampMs\&quot;: 12345     },     \&quot;mountedDatabaseName\&quot;: \&quot;$db_name\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/$db_id/mount\&quot; &#x60;&#x60;&#x60;  All current Live Mounts can be found with a GET on [&#x60;/mssql/db/mount&#x60;](#operation/queryMssqlMount).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/mount\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$mount_id\&quot;,       \&quot;sourceDatabaseId\&quot;: \&quot;$source_db_id\&quot;,       \&quot;sourceRecoveryPoint\&quot;: {         \&quot;timestampMs\&quot;: 12345       },       \&quot;targetInstanceId\&quot;: \&quot;$target_instance_id\&quot;,       \&quot;creationDate\&quot;: \&quot;2017-02-02T18:53:12.694Z\&quot;,       \&quot;isReady\&quot;: true,       \&quot;mountedDatabaseId\&quot;: \&quot;$mounted_db_id\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Further details for a single Live Mount are acquired from [&#x60;/mssql/db/mount/{id}&#x60;](#operation/getMssqlMount).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/mount/$mount_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$mount_id\&quot;,   \&quot;sourceDatabaseId\&quot;: \&quot;$source_db_id\&quot;,   \&quot;sourceRecoveryPoint\&quot;: {     \&quot;timestampMs\&quot;: 12345   },   \&quot;targetInstanceId\&quot;: \&quot;$target_instance_id\&quot;,   \&quot;creationDate\&quot;: \&quot;2017-02-02T18:53:12.694Z\&quot;,   \&quot;isReady\&quot;: true,   \&quot;mountedDatabaseId\&quot;: \&quot;$mounted_db_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/$source_db_id\&quot;,       \&quot;rel\&quot;: \&quot;sourceDatabase\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/instance/$target_instance_id\&quot;,       \&quot;rel\&quot;: \&quot;targetInstance\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/$mounted_db_id\&quot;,       \&quot;rel\&quot;: \&quot;mountedDatabase\&quot;     }   ], } &#x60;&#x60;&#x60;  Delete a Live Mount with a DELETE on [&#x60;/mssql/db/mount/{id}&#x60;](#operation/createMssqlUnmount).  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/mssql/db/mount/$mount_id\&quot; &#x60;&#x60;&#x60;  ## Log Shipping  Create a Log Shipping Configuration with a POST on [&#x60;/mssql/db/{id}/log_shipping&#x60;](#operation/createLogShippingConfiguration).  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;config\&quot;: {       \&quot;targetInstanceId\&quot;: \&quot;$target_instance_id\&quot;,       \&quot;targetDatabaseName\&quot;: \&quot;$db_name\&quot;,       \&quot;state\&quot;: \&quot;$state\&quot;     }   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/{id}/log_shipping\&quot; &#x60;&#x60;&#x60;  All current Log Shipping Configurations can be found with a GET on [&#x60;/mssql/db/log_shipping&#x60;](#operation/queryLogShippingConfigurations).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/log_shipping\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$log_shipping_id\&quot;,       \&quot;lastAppliedPoint\&quot;: \&quot;2017-02-02T18:53:12.694Z\&quot;,       \&quot;location\&quot;: \&quot;$host_name/$instance_name\&quot;,       \&quot;primaryDatabaseId\&quot;: \&quot;$primary_db_id\&quot;,       \&quot;primaryDatabaseName\&quot;: \&quot;$primary_database_name\&quot;,       \&quot;secondaryDatabaseName\&quot;: \&quot;$secondary_database_name\&quot;,       \&quot;secondaryDatabaseId\&quot;: \&quot;$secondary_database_id\&quot;,       \&quot;state\&quot;: \&quot;$state\&quot;,       \&quot;status\&quot;: \&quot;OK\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Further details for a single Log Shipping configuration are acquired from [&#x60;/mssql/db/log_shipping/{id}&#x60;](#operation/getLogShippingConfiguration).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/db/log_shipping/{id}\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$log_shipping_id\&quot;,   \&quot;lastAppliedPoint\&quot;: \&quot;2017-02-02T18:53:12.694Z\&quot;,   \&quot;location\&quot;: \&quot;$host_name/$instance_name\&quot;,   \&quot;primaryDatabaseId\&quot;: \&quot;$primary_db_id\&quot;,   \&quot;primaryDatabaseName\&quot;: \&quot;$primary_database_name\&quot;,   \&quot;secondaryDatabaseName\&quot;: \&quot;$secondary_database_name\&quot;,   \&quot;secondaryDatabaseId\&quot;: \&quot;$secondary_database_id\&quot;,   \&quot;state\&quot;: \&quot;$state\&quot;,   \&quot;status\&quot;: \&quot;OK\&quot;   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/$primary_db_id\&quot;,       \&quot;rel\&quot;: \&quot;primaryDatabase\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/instance/$secondary_instance_id\&quot;,       \&quot;rel\&quot;: \&quot;secondaryInstance\&quot;     },     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/$secondary_db_id\&quot;,       \&quot;rel\&quot;: \&quot;secondaryDatabase\&quot;     }   ], } &#x60;&#x60;&#x60;  Update a Log Shipping Configuration with a PATCH on [&#x60;/mssql/db/log_shipping/{id}&#x60;](#operation/updateLogShippingConfiguration).  &#x60;&#x60;&#x60;bash curl -X PATCH -d \\   &#39;{     \&quot;config\&quot;: {       \&quot;state\&quot;: \&quot;$state\&quot;     }   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/log_shipping/$id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  Delete a Log Shipping Configuration with a DELETE on [&#x60;/mssql/db/log_shipping/{id}&#x60;](#operation/deleteLogShippingConfiguration).  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/mssql/db/log_shipping/$id?delete_secondary_database&#x3D;true\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  Reseed a Log Shipping Configuration with a POST on [&#x60;/mssql/db/log_shipping/{id}/reseed&#x60;](#operation/reseedSecondary)  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;config\&quot;: {       \&quot;state\&quot;: \&quot;$state\&quot;     }   }&#39; \\   \&quot;https://$cluster_address/api/v1/mssql/db/log_shipping/$id/reseed\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/mssql/db/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  # Hierarchy  This REST API is used to get SQL Server hierarchy objects.  ### Get list of immediate descendant objects Get a list of immediate descendant objects using a GET request to [/mssql/hierarchy/{id}/children]\\ (#operation/getMssqlHierarchyChildren).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/hierarchy/{id}/children\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$database_id\&quot;,       \&quot;name\&quot;: \&quot;$database_name\&quot;,       \&quot;objectType\&quot;: \&quot;MssqlDatabase\&quot;,       \&quot;descendantCount\&quot;: {},       \&quot;hasPermissions\&quot;: true,       \&quot;isInAvailabilityGroup\&quot;: false,       \&quot;isLiveMount\&quot;: false,       \&quot;isLogShippingSecondary\&quot;: false,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Inherit\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Get list of descendant objects Get a list of descendant objects using a GET request to [/mssql/hierarchy/{id}/descendants]\\ (#operation/getMssqlHierarchyDescendants).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/hierarchy/{id}/descendants\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$database_id\&quot;,       \&quot;name\&quot;: \&quot;$database_name\&quot;,       \&quot;objectType\&quot;: \&quot;MssqlDatabase\&quot;,       \&quot;descendantCount\&quot;: {},       \&quot;hasPermissions\&quot;: true,       \&quot;isInAvailabilityGroup\&quot;: false,       \&quot;isLiveMount\&quot;: false,       \&quot;isLogShippingSecondary\&quot;: false,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Inherit\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Get an object Get an object in the hierarchy using a GET request to [/mssql/hierarchy/{id}]\\ (#operation/getMssqlHierarchyObject).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mssql/hierarchy/{id}\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$database_id\&quot;,   \&quot;name\&quot;: \&quot;$database_name\&quot;,   \&quot;objectType\&quot;: \&quot;MssqlDatabase\&quot;,   \&quot;descendantCount\&quot;: {},   \&quot;hasPermissions\&quot;: true,   \&quot;isInAvailabilityGroup\&quot;: false,   \&quot;isLiveMount\&quot;: false,   \&quot;isLogShippingSecondary\&quot;: false,   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;Inherit\&quot; } &#x60;&#x60;&#x60; ## Host configurations  ### Retrieving SQL Server host configurations To retrieve all the SQL Server host configurations, send a GET request to  [&#x60;/mssql/host/configuration&#x60;](#operation/queryMssqlHostConfig).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1//mssql/host/configuration\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a list of all the SQL Server host  configurations. &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;hostId\&quot;: \&quot;hostId\&quot;,       \&quot;enableDatabaseBatchSnapshots\&quot;: \&quot;Enabled\&quot;,       \&quot;enableVdi\&quot;: \&quot;Enabled\&quot;,       \&quot;enableVdiDb\&quot;: \&quot;Enabled\&quot;,       \&quot;enableGroupFetch\&quot;: \&quot;Enabled\&quot;,       \&quot;enableCbtBackup\&quot;: \&quot;Enabled\&quot;,       \&quot;physicalHostLogBackupThrottleMaxRefCount\&quot;: 10,       \&quot;throttlePhysicalHostMaxRefCount\&quot;: 3,       \&quot;fileTransferParallelism\&quot;: 8,       \&quot;mssqlDefaultMaxDataStreamsPerDatabase\&quot;: 2,       \&quot;fileRestoreReadParallelism\&quot;: 16,       \&quot;fileRestoreWriteParallelism\&quot;: 4     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  To retrieve the configuration of a specific SQL Server host, send a GET  request to  [&#x60;/mssql/host/configuration/{host_id}&#x60;](#operation/getMssqlHostConfig).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1//mssql/host/configuration/{host_id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the configuration details of the  specified SQL Server host.  &#x60;&#x60;&#x60;bash {   \&quot;enableDatabaseBatchSnapshots\&quot;: \&quot;Enabled\&quot;,   \&quot;enableVdi\&quot;: \&quot;Enabled\&quot;,   \&quot;enableVdiDb\&quot;: \&quot;Enabled\&quot;,   \&quot;enableGroupFetch\&quot;: \&quot;Enabled\&quot;,   \&quot;enableCbtBackup\&quot;: \&quot;Enabled\&quot;,   \&quot;physicalHostLogBackupThrottleMaxRefCount\&quot;: 10,   \&quot;throttlePhysicalHostMaxRefCount\&quot;: 3,   \&quot;fileTransferParallelism\&quot;: 8,   \&quot;mssqlDefaultMaxDataStreamsPerDatabase\&quot;: 2,   \&quot;fileRestoreReadParallelism\&quot;: 16,   \&quot;fileRestoreWriteParallelism\&quot;: 4 } &#x60;&#x60;&#x60;   ### Creating a SQL Server host configuration To create a new SQL Server host configuration, send a POST request to  [&#x60;/mssql/host/configuration&#x60;](#operation/createMssqlHostConfig).  &#x60;&#x60;&#x60;bash curl -X POST -d \\  &#39;{    \&quot;hostId\&quot;: \&quot;hostId\&quot;,    \&quot;enableDatabaseBatchSnapshots\&quot;: \&quot;Enabled\&quot;,    \&quot;enableVdi\&quot;: \&quot;Enabled\&quot;,    \&quot;enableVdiDb\&quot;: \&quot;Enabled\&quot;,    \&quot;enableGroupFetch\&quot;: \&quot;Enabled\&quot;,    \&quot;enableCbtBackup\&quot;: \&quot;Enabled\&quot;,    \&quot;physicalHostLogBackupThrottleMaxRefCount\&quot;: 10,    \&quot;throttlePhysicalHostMaxRefCount\&quot;: 3,    \&quot;fileTransferParallelism\&quot;: 8,    \&quot;mssqlDefaultMaxDataStreamsPerDatabase\&quot;: 2,    \&quot;fileRestoreReadParallelism\&quot;: 16,    \&quot;fileRestoreWriteParallelism\&quot;: 4  }&#39; \\ \&quot;https://$cluster_address/api/v1/mssql/host/configuration\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the new SQL Server  host configuration. &#x60;&#x60;&#x60;bash {   \&quot;hostId\&quot;: \&quot;hostId\&quot;,   \&quot;enableDatabaseBatchSnapshots\&quot;: \&quot;Enabled\&quot;,   \&quot;enableVdi\&quot;: \&quot;Enabled\&quot;,   \&quot;enableVdiDb\&quot;: \&quot;Enabled\&quot;,   \&quot;enableGroupFetch\&quot;: \&quot;Enabled\&quot;,   \&quot;enableCbtBackup\&quot;: \&quot;Enabled\&quot;,   \&quot;physicalHostLogBackupThrottleMaxRefCount\&quot;: 10,   \&quot;throttlePhysicalHostMaxRefCount\&quot;: 3,   \&quot;fileTransferParallelism\&quot;: 8,   \&quot;mssqlDefaultMaxDataStreamsPerDatabase\&quot;: 2,   \&quot;fileRestoreReadParallelism\&quot;: 16,   \&quot;fileRestoreWriteParallelism\&quot;: 4 } &#x60;&#x60;&#x60;  ### Updating a SQL Server host configuration To update the configuration of a specific SQL Server host, send a PATCH  request to  [&#x60;/mssql/host/configuration/{host_id}&#x60;](#operation/updateMssqlHostConfig).  &#x60;&#x60;&#x60;bash curl -X PATCH -d \\  &#39;{    \&quot;enableDatabaseBatchSnapshots\&quot;: true,    \&quot;enableVdi\&quot;: true,    \&quot;enableVdiDb\&quot;: false,    \&quot;enableGroupFetch\&quot;: false,    \&quot;enableCbtBackup\&quot;: false,    \&quot;physicalHostLogBackupThrottleMaxRefCount\&quot;: 10,    \&quot;throttlePhysicalHostMaxRefCount\&quot;: 3,    \&quot;fileTransferParallelism\&quot;: 8,    \&quot;mssqlDefaultMaxDataStreamsPerDatabase\&quot;: 2,    \&quot;fileRestoreReadParallelism\&quot;: 16,    \&quot;fileRestoreWriteParallelism\&quot;: 4  }&#39; \\ \&quot;https://$cluster_address/api/v1//mssql/host/configuration/{host_id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the updated configuration details of  the specified SQL Server host.  &#x60;&#x60;&#x60;bash {   \&quot;enableDatabaseBatchSnapshots\&quot;: \&quot;Enabled\&quot;,   \&quot;enableVdi\&quot;: \&quot;Enabled\&quot;,   \&quot;enableVdiDb\&quot;: \&quot;Enabled\&quot;,   \&quot;enableGroupFetch\&quot;: \&quot;Enabled\&quot;,   \&quot;enableCbtBackup\&quot;: \&quot;Enabled\&quot;,   \&quot;physicalHostLogBackupThrottleMaxRefCount\&quot;: 10,   \&quot;throttlePhysicalHostMaxRefCount\&quot;: 3,   \&quot;fileTransferParallelism\&quot;: 8,   \&quot;mssqlDefaultMaxDataStreamsPerDatabase\&quot;: 2,   \&quot;fileRestoreReadParallelism\&quot;: 16,   \&quot;fileRestoreWriteParallelism\&quot;: 4 } &#x60;&#x60;&#x60;  ### Deleting a SQL Server host configuration To delete a specific SQL Server host configuration, send a DELETE request to  [&#x60;/mssql/host/configuration/{host_id}&#x60;](#operation/deleteMssqlHostConfig).  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/mssql/host/configuration/{host_id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server deletes the specified SQL Server host configuration.  # Oracle Databases  ## Delete Downloaded Oracle Db Snapshots and Log Snapshots  To request an asynchronous job to expire downloaded database snapshots taken during a specified time period as well as log snapshots that contain any logs with timestamps within that time period, send a DELETE request to the [&#x60;/oracle/db/{id}/downloaded_snapshots&#x60;](#operation/deleteDownloadedSnapshots) endpoint with optional query parameters before_time and after_time.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/oracle/db/{id}/downloaded_snapshots?before_time&#x3D;2016-01-01T01:23:45.678&amp;after_time&#x3D;2016-01-01T01:23:45.678\&quot;   &#x60;&#x60;&#x60; An async request is returned and can be polled to retrieve the job status.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/internal/oracle/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  ## Provide Estimate for Restore Operation Download  To request the number of bytes that must be downloaded for a restore operation for an Oracle database, send a GET request to the [&#x60;/oracle/db/{id}/restore_estimate&#x60;](#operation/oracleRestoreEstimate) endpoint with the snapshot ID or the time to be restored to.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/oracle/db/{id}/restore_estimate?recovery_time&#x3D;2016-01-01T01:23:45.678\&quot; &#x60;&#x60;&#x60; An OracleRestoreEstimateResult object is returned which stores the number of bytes which are needed to restore.  &#x60;&#x60;&#x60;bash {   \&quot;bytesToRestore\&quot;: \&quot;$bytesToRestore\&quot;, } &#x60;&#x60;&#x60;  ## Bulk Update Oracle Databases  To update a list of Oracle Databases in bulk, send a PATCH request to the [&#x60;/oracle/db/bulk&#x60;](#operation/bulkUpdateOracleDb) endpoint with a bulk_update_properties to complete a update.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;ids\&quot;: \&quot;$ids\&quot;,     \&quot;logBackupFrequencyInMinutes\&quot;: \&quot;$logBackupFrequencyInMinutes\&quot;,     \&quot;logRetentionHours\&quot;: \&quot;$logRetentionHours\&quot;,     \&quot;hostLogRetentionHours\&quot;: \&quot;$hostLogRetentionHours\&quot;,     \&quot;numChannels\&quot;: \&quot;$numChannels\&quot;,     \&quot;hostMount\&quot;: \&quot;string\&quot;,     \&quot;configuredSlaDomainIdDeprecated\&quot;: \&quot;string\&quot;,     \&quot;nodeOrder\&quot;: [       {         \&quot;nodeName\&quot;: \&quot;string\&quot;,         \&quot;order\&quot;: 0       }     ]   }&#39; \\   \&quot;https://$cluster_address/api/v1/oracle/db/bulk\&quot; &#x60;&#x60;&#x60;  A BulkOracleDbDetails object contains an array of OracleDbDetail is returned.  ## Bulk Update Oracle Hosts  To update a list of Oracle hosts in bulk, send a PATCH request to the [&#x60;/oracle/host/bulk&#x60;](#operation/bulkUpdateOracleHost) endpoint with a bulk_update_properties to complete a update.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;ids\&quot;: \&quot;$ids\&quot;,     \&quot;logBackupFrequencyInMinutes\&quot;: \&quot;$logBackupFrequencyInMinutes\&quot;,     \&quot;logRetentionHours\&quot;: \&quot;$logRetentionHours\&quot;,     \&quot;hostLogRetentionHours\&quot;: \&quot;$hostLogRetentionHours\&quot;,     \&quot;numChannels\&quot;: \&quot;$numChannels\&quot;,     \&quot;hostMount\&quot;: \&quot;string\&quot;,     \&quot;configuredSlaDomainIdDeprecated\&quot;: \&quot;string\&quot;,     \&quot;nodeOrder\&quot;: [       {         \&quot;nodeName\&quot;: \&quot;string\&quot;,         \&quot;order\&quot;: 0       }     ]   }&#39; \\   \&quot;https://$cluster_address/api/v1/oracle/host/bulk\&quot; &#x60;&#x60;&#x60;  A BulkOracleHostDetails object contains an array of OracleHostDetail is returned.  ## Bulk Update Oracle RACs  To update a list of Oracle RACs in bulk, send a PATCH request to the [&#x60;/oracle/rac/bulk&#x60;](#operation/bulkUpdateOracleRac) endpoint with a bulk_update_properties to complete a update.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;ids\&quot;: \&quot;$ids\&quot;,     \&quot;logBackupFrequencyInMinutes\&quot;: \&quot;$logBackupFrequencyInMinutes\&quot;,     \&quot;logRetentionHours\&quot;: \&quot;$logRetentionHours\&quot;,     \&quot;hostLogRetentionHours\&quot;: \&quot;$hostLogRetentionHours\&quot;,     \&quot;numChannels\&quot;: \&quot;$numChannels\&quot;,     \&quot;hostMount\&quot;: \&quot;string\&quot;,     \&quot;configuredSlaDomainIdDeprecated\&quot;: \&quot;string\&quot;,     \&quot;nodeOrder\&quot;: [       {         \&quot;nodeName\&quot;: \&quot;string\&quot;,         \&quot;order\&quot;: 0       }     ]   }&#39; \\   \&quot;https://$cluster_address/api/v1/oracle/rac/bulk\&quot; &#x60;&#x60;&#x60;  A BulkOracleRacDetails object contains an array of OracleRacDetail is returned.  ## Trigger a ORACLE_VALIDATE_BACKUP job to validate backups of selected recovery point on a choosing Oracle host  To request an asynchronous job to validate backups of selected recovery point on a choosing Oracle host or Oracle RAC, send a POST request to the [&#x60;/oracle/db/{id}/validate&#x60;](#operation/createOracleValidateBackupJob) endpoint with a OracleValidateConfig.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;config\&quot;: {       \&quot;recoveryPoint\&quot;: { \&quot;timestampMs\&quot;: 12345 },       \&quot;targetOracleHostOrRacId\&quot;: \&quot;54321\&quot;:,       \&quot;sgaMaxSize\&quot;: 4,       \&quot;targetOracleHome\&quot;: \&quot;/fullpath/for/oracleHome\&quot;,       \&quot;targetMountPath\&quot;: \&quot;/fullpath/for/mountPath\&quot;,       \&quot;numChannels\&quot;: 4     }   }&#39; \\   \&quot;https://$cluster_address/api/v1/oracle/db/{id}/validate   &#x60;&#x60;&#x60; An async request is returned and can be polled to retrieve the job status.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/internal/oracle/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ],   \&quot;status\&quot;: \&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  ## Get a download link of example Advanced Recovery Options file  To get a link to download an example Advanced Recovery Options file, send a GET request to the [&#x60;/oracle/aco_example_download_link&#x60;](#operation/getExampleAcoDownloadLink) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/oracle/aco_example_download_link\&quot; &#x60;&#x60;&#x60;  An OracleFileDownloadLink object is returned which has a link to download the sample Advanced Recovery Options file.  ## Update Oracle Data Guard Group  To update an Oracle Data Guard group, send a PATCH request to the [&#x60;/oracle/data_guard_group/{id}&#x60;](#operation/updateOracleDataGuardGroup) endpoint. Edit the update_properties field with the properties to be updated.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;logBackupFrequencyInMinutes\&quot;: \&quot;$logBackupFrequencyInMinutes\&quot;,     \&quot;logRetentionHours\&quot;: \&quot;$logRetentionHours\&quot;,     \&quot;hostLogRetentionHours\&quot;: \&quot;$hostLogRetentionHours\&quot;,     \&quot;numChannels\&quot;: \&quot;$numChannels\&quot;,     \&quot;hostMount\&quot;: \&quot;string\&quot;,     \&quot;shouldBackupFromPrimaryOnly\&quot;: false,     \&quot;preferredDGMemberUniqueNames\&quot;: [\&quot;unique_name\&quot;]     ]   }&#39; \\   \&quot;https://$cluster_address/api/v1/oracle/data_guard_group/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with an OracleDbDetail object containing information about the Data Guard group. &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\&quot;,   \&quot;name\&quot;: \&quot;rbk\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;55a8c22c-424c-41ee-91e0-94c282281e4b\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Unassigned\&quot;,   \&quot;retentionSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;infraPath\&quot;: [],   \&quot;isRelic\&quot;: false,   \&quot;numTablespaces\&quot;: 0,   \&quot;logBackupFrequencyInMinutes\&quot;: 0,   \&quot;numMissedSnapshot\&quot;: 0,   \&quot;includeBackupTaskInfo\&quot;: true,   \&quot;isDbLocalToTheCluster\&quot;: true,   \&quot;hostLogRetentionHours\&quot;: 0,   \&quot;isArchiveLogModeEnabled\&quot;: true,   \&quot;dbUniqueName\&quot;: \&quot;DG_rbk\&quot;,   \&quot;dataGuardType\&quot;: \&quot;DataGuardGroup\&quot;,   \&quot;dataGuardGroupMembers\&quot;: [     {       \&quot;dbUniqueName\&quot;: \&quot;rbk\&quot;,       \&quot;role\&quot;: \&quot;PRIMARY\&quot;,       \&quot;standaloneHostId\&quot;: \&quot;OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\&quot;,       \&quot;standaloneHostName\&quot;: \&quot;oel75-121-dg-primary-20210421023956\&quot;     }   ],   \&quot;logRetentionHours\&quot;: 720,   \&quot;numChannels\&quot;: 1,   \&quot;hostMount\&quot;: \&quot;/var/rubrik/oracle\&quot;,   \&quot;tablespaces\&quot;: [],   \&quot;snapshotCount\&quot;: 0,   \&quot;isLiveMount\&quot;: false,   \&quot;hostsInfo\&quot;: [     {       \&quot;id\&quot;: \&quot;Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\&quot;,       \&quot;hostname\&quot;: \&quot;10.0.188.224\&quot;,       \&quot;oracleSysDbaUser\&quot;: \&quot;oracle\&quot;,       \&quot;oracleQueryUser\&quot;: \&quot;oracle\&quot;     }   ],   \&quot;shouldBackupFromPrimaryDGGroupMemberOnly\&quot;: true,   \&quot;preferredDGMemberUniqueNames\&quot;: [] } &#x60;&#x60;&#x60;  ## Retrieving Oracle databases ### Retrieving a summary of all Oracle databases  To get a list of Oracle databases, send a GET request to the [&#x60;/oracle/db&#x60;](#operation/queryOracleDbV1) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/oracle/db\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a list of OracleDbSummary objects containing information about the databases.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\&quot;,       \&quot;name\&quot;: \&quot;rbk\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;55a8c22c-424c-41ee-91e0-94c282281e4b\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Unassigned\&quot;,       \&quot;retentionSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;infraPath\&quot;: [         {           \&quot;name\&quot;: \&quot;oel75-121-dg-primary-20210421023956\&quot;,           \&quot;id\&quot;: \&quot;OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\&quot;         }       ],       \&quot;isRelic\&quot;: false,       \&quot;numTablespaces\&quot;: 5,       \&quot;numMissedSnapshot\&quot;: 0,       \&quot;includeBackupTaskInfo\&quot;: false,       \&quot;isDbLocalToTheCluster\&quot;: true,       \&quot;hostLogRetentionHours\&quot;: 0,       \&quot;sid\&quot;: \&quot;rbk\&quot;,       \&quot;standaloneHostId\&quot;: \&quot;OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\&quot;,       \&quot;numInstances\&quot;: 1,       \&quot;instances\&quot;: [         {           \&quot;hostName\&quot;: \&quot;10.0.188.224\&quot;,           \&quot;instanceSid\&quot;: \&quot;rbk\&quot;         }       ],       \&quot;isArchiveLogModeEnabled\&quot;: true,       \&quot;standaloneHostName\&quot;: \&quot;oel75-121\&quot;,       \&quot;archiveLogDestinations\&quot;: [         \&quot;\&quot;       ],       \&quot;isPrimary\&quot;: true,       \&quot;dbUniqueName\&quot;: \&quot;rbk\&quot;,       \&quot;databaseRole\&quot;: \&quot;PRIMARY\&quot;,       \&quot;dataGuardType\&quot;: \&quot;DataGuardMember\&quot;,       \&quot;dataGuardGroupId\&quot;: \&quot;OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\&quot;,       \&quot;dataGuardGroupName\&quot;: \&quot;DG_rbk\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Retrieving detailed information for a specific Oracle database  To get detailed information about an Oracle Database, send a GET request to the [&#x60;/oracle/db/{id}&#x60;](#operation/getOracleDbV1) endpoint where, {id} is the ID of the Oracle database.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/oracle/db/$oracle_database_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with an OracleDbDetail object containing information about the specified  database.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\&quot;,   \&quot;name\&quot;: \&quot;rbk\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;55a8c22c-424c-41ee-91e0-94c282281e4b\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Unassigned\&quot;,   \&quot;retentionSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;infraPath\&quot;: [     {       \&quot;name\&quot;: \&quot;oel75-121-dg-primary-20210421023956\&quot;,       \&quot;id\&quot;: \&quot;OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\&quot;     }   ],   \&quot;isRelic\&quot;: false,   \&quot;numTablespaces\&quot;: 5,   \&quot;logBackupFrequencyInMinutes\&quot;: 0,   \&quot;numMissedSnapshot\&quot;: 0,   \&quot;includeBackupTaskInfo\&quot;: true,   \&quot;isDbLocalToTheCluster\&quot;: true,   \&quot;hostLogRetentionHours\&quot;: 0,   \&quot;sid\&quot;: \&quot;rbk\&quot;,   \&quot;standaloneHostId\&quot;: \&quot;OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\&quot;,   \&quot;numInstances\&quot;: 1,   \&quot;instances\&quot;: [     {       \&quot;hostName\&quot;: \&quot;10.0.188.224\&quot;,       \&quot;instanceSid\&quot;: \&quot;rbk\&quot;     }   ],   \&quot;isArchiveLogModeEnabled\&quot;: true,   \&quot;standaloneHostName\&quot;: \&quot;oel75-121-dg-primary-20210421023956\&quot;,   \&quot;archiveLogDestinations\&quot;: [     \&quot;\&quot;   ],   \&quot;isPrimary\&quot;: true,   \&quot;dbUniqueName\&quot;: \&quot;rbk\&quot;,   \&quot;databaseRole\&quot;: \&quot;PRIMARY\&quot;,   \&quot;dataGuardType\&quot;: \&quot;DataGuardMember\&quot;,   \&quot;dataGuardGroupId\&quot;: \&quot;OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\&quot;,   \&quot;dataGuardGroupName\&quot;: \&quot;DG_rbk\&quot;,   \&quot;logRetentionHours\&quot;: 720,   \&quot;numChannels\&quot;: 1,   \&quot;hostMount\&quot;: \&quot;/var/rubrik/oracle\&quot;,   \&quot;tablespaces\&quot;: [     \&quot;SYSAUX\&quot;,     \&quot;SYSTEM\&quot;,     \&quot;UNDOTBS1\&quot;,     \&quot;USERS\&quot;,     \&quot;TEMP\&quot;   ],   \&quot;snapshotCount\&quot;: 0,   \&quot;oracleHome\&quot;: \&quot;/u01/app/oracle/product/12.1.0.2/dbhome_1\&quot;,   \&quot;isLiveMount\&quot;: false,   \&quot;hostsInfo\&quot;: [     {       \&quot;id\&quot;: \&quot;Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\&quot;,       \&quot;hostname\&quot;: \&quot;10.0.188.224\&quot;,       \&quot;oracleSysDbaUser\&quot;: \&quot;oracle\&quot;,       \&quot;oracleQueryUser\&quot;: \&quot;oracle\&quot;     }   ] } &#x60;&#x60;&#x60;  ## Updating Oracle Database  To update an Oracle database, send a PATCH request to the [&#x60;/oracle/db/{id}&#x60;](#operation/updateOracleDbV1) endpoint. Edit the update_properties field with the properties to be updated.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{     \&quot;logBackupFrequencyInMinutes\&quot;: \&quot;$logBackupFrequencyInMinutes\&quot;,     \&quot;logRetentionHours\&quot;: \&quot;$logRetentionHours\&quot;,     \&quot;hostLogRetentionHours\&quot;: \&quot;$hostLogRetentionHours\&quot;,     \&quot;numChannels\&quot;: \&quot;$numChannels\&quot;,     \&quot;hostMount\&quot;: \&quot;$hostMount\&quot;     ]   }&#39; \\   \&quot;https://$cluster_address/api/v1/oracle/db/$oracle_database_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with an OracleDbDetail object containing information about the updated database. &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;OracleDatabase:::912819e7-d603-4c1a-860a-88ba9c15b930\&quot;,   \&quot;name\&quot;: \&quot;rbk\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;55a8c22c-424c-41ee-91e0-94c282281e4b\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: false,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;Global:::All\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Unassigned\&quot;,   \&quot;retentionSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;infraPath\&quot;: [     {       \&quot;name\&quot;: \&quot;oel75-121-dg-primary-20210421023956\&quot;,       \&quot;id\&quot;: \&quot;OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\&quot;     }   ],   \&quot;isRelic\&quot;: false,   \&quot;numTablespaces\&quot;: 5,   \&quot;logBackupFrequencyInMinutes\&quot;: 0,   \&quot;numMissedSnapshot\&quot;: 0,   \&quot;includeBackupTaskInfo\&quot;: true,   \&quot;isDbLocalToTheCluster\&quot;: true,   \&quot;hostLogRetentionHours\&quot;: 0,   \&quot;sid\&quot;: \&quot;rbk\&quot;,   \&quot;standaloneHostId\&quot;: \&quot;OracleHost:::d108cb3f-e4c6-4579-8aa1-f471940d6f8f\&quot;,   \&quot;numInstances\&quot;: 1,   \&quot;instances\&quot;: [     {       \&quot;hostName\&quot;: \&quot;10.0.188.224\&quot;,       \&quot;instanceSid\&quot;: \&quot;rbk\&quot;     }   ],   \&quot;isArchiveLogModeEnabled\&quot;: true,   \&quot;standaloneHostName\&quot;: \&quot;oel75-121-dg-primary-20210421023956\&quot;,   \&quot;archiveLogDestinations\&quot;: [     \&quot;\&quot;   ],   \&quot;isPrimary\&quot;: true,   \&quot;dbUniqueName\&quot;: \&quot;rbk\&quot;,   \&quot;databaseRole\&quot;: \&quot;PRIMARY\&quot;,   \&quot;dataGuardType\&quot;: \&quot;DataGuardMember\&quot;,   \&quot;dataGuardGroupId\&quot;: \&quot;OracleDatabase:::1e7d288f-deed-4d72-a3a2-ad578c093f2e\&quot;,   \&quot;dataGuardGroupName\&quot;: \&quot;DG_rbk\&quot;,   \&quot;logRetentionHours\&quot;: 720,   \&quot;numChannels\&quot;: 1,   \&quot;hostMount\&quot;: \&quot;/var/rubrik/oracle\&quot;,   \&quot;tablespaces\&quot;: [     \&quot;SYSAUX\&quot;,     \&quot;SYSTEM\&quot;,     \&quot;UNDOTBS1\&quot;,     \&quot;USERS\&quot;,     \&quot;TEMP\&quot;   ],   \&quot;snapshotCount\&quot;: 0,   \&quot;oracleHome\&quot;: \&quot;/u01/app/oracle/product/12.1.0.2/dbhome_1\&quot;,   \&quot;isLiveMount\&quot;: false,   \&quot;hostsInfo\&quot;: [     {       \&quot;id\&quot;: \&quot;Host:::0134de15-10b7-4296-a0b4-7232d2a9edaa\&quot;,       \&quot;hostname\&quot;: \&quot;10.0.188.224\&quot;,       \&quot;oracleSysDbaUser\&quot;: \&quot;oracle\&quot;,       \&quot;oracleQueryUser\&quot;: \&quot;oracle\&quot;     }   ] } &#x60;&#x60;&#x60;  ## Get Oracle Advanced Cloning Options (ACO) parameters  To get a list of supported ACO parameter names, send a GET request to the [&#x60;/oracle/aco_parameter_list&#x60;](#operation/getAcoParameterList) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/oracle/aco_parameter_list\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with an OracleAcoParameterList object which contains the list of supported ACO parameter names.  ## Validate an Oracle Advanced Cloning Options (ACO) config file  To validate an ACO file, send a POST request to the [&#x60;/oracle/validate_aco_file&#x60;](#operation/validateOracleAcoFile) endpoint. Send the base 64 encoded string of the ACO file contents in the body and a boolean determining whether the ACO file is for a Live Mount or not, as a query parameter. &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;aco_contents_base64\&quot;: \&quot;$aco_contents_base64\&quot;   }&#39; \\   \&quot;https://$cluster_address/api/v1/oracle/validate_aco_file?is_live_mount&#x3D;{is_live_mount} &#x60;&#x60;&#x60;  The Rubrik REST API server validates the given ACO file contents and returns an OracleAcoValidationResult containing the validation result of the ACO file given.  # vApps  The Rubrik cluster protects vApps running in a VMware vCloud Director environment through the vCloud Director REST APIs. The Rubrik cluster must connect to the underlying vCenter servers to protect vApps.  ## vApp Templates  The Rubrik cluster protects vApp template objects through the vCloud Director APIs.  ## vCloud Director server  A Rubrik cluster protects and manages vApps and vApp templates through the vCloud Director server that administers those vApps. After a vCloud Director server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the vApps administered under the server.  ### Retrieving details for a vApp template snapshot export  To retrieve the options available for exporting a specified vApp template snapshot to an organization vDC and available storage policies, send a GET request to [&#x60;/vcd/vapp/template/snapshot/{snapshot_id}/export/options&#x60;](#operation/getVappTemplateSnapshotExportOptions).  To filter the results of the GET request sent to the  [&#x60;/vcd/vapp/template/snapshot/{snapshot_id}/export/options&#x60;](#operation/getVappTemplateSnapshotExportOptions) endpoint, configure the following query parameters before sending the request.  | Parameter  | Required | Type   | Description | | ---------- | -------- | ------ | ----------- | |&#x60;catalog_id&#x60;| Required | string | ID of the target Catalog object.| |&#x60;name&#x60;      | Required | string | Name of template object to be created. This is used to verify the existence of a template with the given name. Templates must have unique names. |&#x60;org_vdc_id&#x60;| Optional | string | ID assigned to a target organization VDC object. This parameter is required when advanced export options are used.  A vApp template export targets a catalog and requires a valid storage policy and organization vDC. There are three options available for export of a vApp template -  * **OriginalVdcExportOptions** - This option is used to export to the original organization vDC of the vApp template   when the snapshot was taken. Only available when the catalog to export is under the same organization as the original   organization vDC and the vDC is still active.   &#x60;org_vdc_id&#x60; is not required when using this option. * **DefaultCatalogExportOptions** - This option is used to export to the vDC corresponding to the default storage policy   of the catalog. This option is unavailable for catalogs that do not have storage policies.   &#x60;org_vdc_id&#x60; is not required when using this option. * **AdvancedExportOptions** - This option is used to export to a specific organization vDC under the same organization   as the Catalog to export. The GET request returns the choices of storage policies available.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/vcd/vapp/template/snapshot/$snapshot_id/export/options?catalog_id&#x3D;$catalog_id&amp;name&#x3D;$template_name\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API responds with a &#x60;VappTemplateExportOptionsUnion&#x60; object which has fields for all the above options.  **Note:** To shorten the example, the response uses ellipses to replace some members.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;originalVdcExportOptions\&quot; :     {       \&quot;orgVdcId\&quot;: \&quot;$org_vdc_id1\&quot;,       \&quot;availableStoragePolicies\&quot;: [         ...       ]     },    \&quot;defaultCatalogExportOptions\&quot; :     {       \&quot;orgVdcId\&quot;: \&quot;$org_vdc_id1\&quot;,       \&quot;availableStoragePolicies\&quot;: [         ...       ]     },    \&quot;advancedExportOptions\&quot; :     {       \&quot;orgVdcId\&quot;: \&quot;$org_vdc_id1\&quot;,       \&quot;availableStoragePolicies\&quot;: [         ...       ]     } } &#x60;&#x60;&#x60;  ### Exporting a vApp template snapshot  To create a new vApp template in a catalog using the export feature, send a POST request to the  [&#x60;/vcd/vapp/template/snapshot/{snapshot_id}/export&#x60;](#operation/createVappTemplateSnapshotExport) endpoint. The request takes the snapshot_id as a path parameter. The request payload includes the parameters described in the  following table.  | Name            | Required | Type   | Description | | --------------- | -------- | ------ | ----------- | |&#x60;name&#x60;           | Required | string | Name of vApp template to be created.| |&#x60;catalogId&#x60;      | Required | string | ID of the Catalog where the vApp template is created.| |&#x60;orgVdcId&#x60;       | Required | string | ID of the organization vDC where the vApp template is created.| |&#x60;storagePolicyId&#x60;| Required | string | ID of the organization vDC storage policy to be used. In case a storage policy ID is not provided, the default storage policy of the organization vDC is used.  **Note:** The Catalog and organization vDC must belong to the same organization. When providing a storage policy, that storage policy must be present in the organization vDC.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;{     \&quot;name\&quot;: \&quot;$template_name\&quot;,     \&quot;catalogId\&quot;: \&quot;$catalog_id\&quot;,     \&quot;orgVdcId\&quot;: \&quot;$org_vdc_id\&quot;    }&#39; \\    \&quot;https://$cluster_address/api/v1/vcd/vapp/template/snapshot/$snapshot_id/export\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous request task and responds with the the details of the AsyncRequestStatus request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$request_id\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$timestamp\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/vapp/request/$request_id\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving summary of vApps  To retrieve the summary information for all vCD vApp objects, send a GET request to the [&#x60;/vcd/vapp&#x60;](#operation/queryVcdVappsV1) endpoint. The parameters described in the following table are available to  filter the results of the GET request.  | Name                     | Required | Type    | Description | | ------------------------ | -------- | ------- | ----------- | |&#x60;sort_by&#x60;                 | Optional | string  | Attribute to sort the vCD vApp list on.| |&#x60;sort_order&#x60;              | Optional | string  | Order for sorting the results, either ascending or descending.| |&#x60;limit&#x60;                   | Optional | int     | Limit the number of matches returned.| |&#x60;offset&#x60;                  | Optional | int     | Number of matches to ignore from the beginning of the results.| |&#x60;name&#x60;                    | Optional | string  | Search for a vCD vApp object by name.| |&#x60;is_relic&#x60;                | Optional | boolean | Filter by isRelic field of vCD vApp object. Returns both relic and non-relic vApps when this value is not specified.| |&#x60;effective_sla_domain_id&#x60; | Optional | string  | SLA Domain applied to the virtual machine, either directly or derived.| |&#x60;primary_cluster_id&#x60;      | Optional | string  | Filter by primary cluster ID, or **local**.| |&#x60;sla_assignment&#x60;          | Optional | string  | Filter by SLA assignment type.| |&#x60;include_backup_task_info&#x60;| Optional | boolean | Include backup task information in response.|   &#x60;&#x60;&#x60;bash  curl -X GET \&quot;https://$cluster_address/api/v1/vcd/vapp\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a list of vApp objects that fit the specified parameters. The response is a  List of VcdVappSummary objects.   &#x60;&#x60;&#x60;bash  {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$vappId\&quot;,       \&quot;name\&quot;: \&quot;$vappName\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,       \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,       \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,       \&quot;retentionSlaDomainId\&quot;: \&quot;$retentionSlaDomainId\&quot;,       \&quot;vcdClusterId\&quot;: \&quot;$vcdId\&quot;,       \&quot;vcdClusterName\&quot;: \&quot;$vcdClusterName\&quot;,       \&quot;infraPath\&quot;: [         ...       ],       \&quot;isRelic\&quot;: true,       \&quot;numMissedSnapshot\&quot;: 0,       \&quot;lastSnapshotTime\&quot;: \&quot;$lastSnapshotTime\&quot;,       \&quot;includeBackupTaskInfo\&quot;: true,       \&quot;currentBackupTaskInfo\&quot;: {         \&quot;taskStatus\&quot;: \&quot;Queued\&quot;,         \&quot;queueTime\&quot;: \&quot;$queueTime\&quot;,         \&quot;expectedEndTime\&quot;: \&quot;$expectedEndTime\&quot;       },       \&quot;isTemplate\&quot;: true,       \&quot;catalogId\&quot;: \&quot;$catalogId\&quot;,       \&quot;pendingSlaDomain\&quot;: {         \&quot;objectId\&quot;: \&quot;$objectId\&quot;,         \&quot;pendingSlaDomainId\&quot;: \&quot;$pendingSlaDomain\&quot;,         \&quot;pendingSlaDomainName\&quot;: \&quot;$pendingSlaDomainName\&quot;,         \&quot;isPendingSlaDomainRetentionLocked\&quot;: true       }     }   ],   \&quot;total\&quot;: 0 }  &#x60;&#x60;&#x60;  ### Retrieving details for a specific vApp  To retrieve detailed information about a specific vApp, send a GET request to [&#x60;/vcd/vapp/{id}&#x60;](#operation/getVcdVappV1), where {id} is the ID of a vApp object.   &#x60;&#x60;&#x60;bash  curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/{id}\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details (VcdVappDetail) of the specified vApp object.   &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2021-03-16T04:37:38.913Z\&quot;,   \&quot;endTime\&quot;: \&quot;2021-03-16T04:37:38.913Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] }  &#x60;&#x60;&#x60;  ### Updating vApp  To make changes to the parameters of a specified vApp object, send a PATCH request to [&#x60;/vcd/vapp/{id}&#x60;](#operation/updateVcdVappV1), where {id} is the ID of the vApp object to be updated. The request payload of the PATCH request includes the parameters to be updated.  | Name |  Description | Notes |   | ---- | ------------ | ----- | | configured_sla_domain_id | ID of the SLA Domain object that manages protection for the specified vApp object. Existing snapshots of the vApp object will be retained with the configuration of the specified SLA Domain. | optional | | is_paused | Boolean value that indicates whether protection activity is paused for the specified vApp. Set to &amp;#39;true&amp;#39; when protection activity is paused and &amp;#39;false&amp;#39; when protection activity is not paused. Protection activity includes: backup, replication, and archiving. | optional | | is_best_effort_synchronization_enabled | Boolean value that indicates whether the Rubrik cluster should attempt taking synchronized snapshots across all child Virtual Machines of the vApp object. | optional | | vcd_vm_moids_to_exclude_from_snapshot | Array containing vCloud Director Virtual Machine moids that will be excluded from the vApp snapshots. | optional |  &#x60;&#x60;&#x60;bash  curl -X PATCH -d \\   &#39;{     \&quot;configuredSlaDomainId\&quot;: \&quot;$sla_domain_id\&quot;,     \&quot;isPaused\&quot;: \&quot;true\&quot;,     \&quot;isBestEffortSynchronizationEnabled\&quot;: \&quot;true\&quot;,     \&quot;vcdVmMoidsToExcludeFromSnapshot\&quot;: \&quot;$vm_moids_to_exclude\&quot;    }&#39; \\    \&quot;https://$cluster_address/api/v1/vcd/vapp/{id}\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details (VcdVappDetail) of the updated vApp object.   &#x60;&#x60;&#x60;bash {   \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,   \&quot;isPaused\&quot;: true,   \&quot;isBestEffortSynchronizationEnabled\&quot;: true,   \&quot;vcdVmMoidsToExcludeFromSnapshot\&quot;: [     ...   ],   \&quot;id\&quot;: \&quot;$vappId\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;effectiveSlaSourceObjectName\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;retentionSlaDomainId\&quot;: \&quot;$retentionSlaDomainId\&quot;,   \&quot;vcdClusterId\&quot;: \&quot;$vcdClusterId\&quot;,   \&quot;vcdClusterName\&quot;: \&quot;$vcdClusterName\&quot;,   \&quot;infraPath\&quot;: [     ...   ],   \&quot;isRelic\&quot;: true,   \&quot;numMissedSnapshot\&quot;: 0,   \&quot;lastSnapshotTime\&quot;: \&quot;$lastSnapshotTime\&quot;,   \&quot;includeBackupTaskInfo\&quot;: true,   \&quot;currentBackupTaskInfo\&quot;: {     \&quot;taskStatus\&quot;: \&quot;Queued\&quot;,     \&quot;queueTime\&quot;: \&quot;$queueTime\&quot;,     \&quot;expectedEndTime\&quot;: \&quot;$expectedEndTime\&quot;   },   \&quot;isTemplate\&quot;: true,   \&quot;catalogId\&quot;: \&quot;$catalogId\&quot;,   \&quot;pendingSlaDomain\&quot;: {     \&quot;objectId\&quot;: \&quot;$objectId\&quot;,     \&quot;pendingSlaDomainId\&quot;: \&quot;$pendingSlaDomainId\&quot;,     \&quot;pendingSlaDomainName\&quot;: \&quot;$pendingSlaDomainName\&quot;,     \&quot;isPendingSlaDomainRetentionLocked\&quot;: true   },   \&quot;networks\&quot;: [     ...   ],   \&quot;vms\&quot;: [     ...   ] }  &#x60;&#x60;&#x60;  ### Retrieving summary information for all vApp snapshots  ## vApp snapshots  To retrieve summary information for each of the snapshot objects of a specified vApp object, send a GET request to [&#x60;/vcd/vapp/{id}/snapshot&#x60;](#operation/queryVappSnapshotV1), where {id} is the ID of the vApp object.   &#x60;&#x60;&#x60;bash  curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/{id}/snapshot\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of all the snapshots of the specified vApp.  The response is a List of VcdVappSnapshotSummary objects.   &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$vappId\&quot;,       \&quot;date\&quot;: \&quot;$date\&quot;,       \&quot;expirationDate\&quot;: \&quot;$expirationDate\&quot;,       \&quot;sourceObjectType\&quot;: \&quot;$sourceObjectType\&quot;,       \&quot;isOnDemandSnapshot\&quot;: true,       \&quot;isCustomRetentionApplied\&quot;: true,       \&quot;cloudState\&quot;: 0,       \&quot;consistencyLevel\&quot;: \&quot;#consistencyLevel\&quot;,       \&quot;indexState\&quot;: 0,       \&quot;replicationLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;archivalLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;slaId\&quot;: \&quot;$slaId\&quot;,       \&quot;slaName\&quot;: \&quot;$slaName\&quot;,       \&quot;isRetainedByRetentionLockSla\&quot;: true,       \&quot;cloudStorageTier\&quot;: \&quot;Hot\&quot;,       \&quot;isPlacedOnLegalHold\&quot;: true,       \&quot;snapshotRetentionInfo\&quot;: {         \&quot;localInfo\&quot;: {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;name\&quot;: \&quot;string\&quot;,           \&quot;isSnapshotPresent\&quot;: true,           \&quot;isExpirationDateCalculated\&quot;: true,           \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,           \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,           \&quot;isExpirationInformationUnavailable\&quot;: true         },         \&quot;archivalInfos\&quot;: [           {             \&quot;id\&quot;: \&quot;$id\&quot;,             \&quot;name\&quot;: \&quot;$name\&quot;,             \&quot;isSnapshotPresent\&quot;: true,             \&quot;isExpirationDateCalculated\&quot;: true,             \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,             \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,             \&quot;isExpirationInformationUnavailable\&quot;: true           }         ],         \&quot;replicationInfos\&quot;: [           {             \&quot;id\&quot;: \&quot;$id\&quot;,             \&quot;name\&quot;: \&quot;$name\&quot;,             \&quot;isSnapshotPresent\&quot;: true,             \&quot;isExpirationDateCalculated\&quot;: true,             \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,             \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,             \&quot;isExpirationInformationUnavailable\&quot;: true           }         ],         \&quot;cloudNativeLocationInfo\&quot;: [           {             \&quot;id\&quot;: \&quot;$id\&quot;,             \&quot;name\&quot;: \&quot;$name\&quot;,             \&quot;isSnapshotPresent\&quot;: true,             \&quot;isExpirationDateCalculated\&quot;: true,             \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,             \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,             \&quot;isExpirationInformationUnavailable\&quot;: true           }         ]       },       \&quot;parentSnapshotId\&quot;: \&quot;$parentSnapshotId\&quot;,       \&quot;vappName\&quot;: \&quot;$vappName\&quot;,       \&quot;isSynchronized\&quot;: true,       \&quot;vmSnapshots\&quot;: [         {           \&quot;vcenterVmId\&quot;: \&quot;$vcenterVmId\&quot;,           \&quot;vmSnapshotId\&quot;: \&quot;$vmSnapshotId\&quot;,           \&quot;vmName\&quot;: \&quot;$vmName\&quot;,           \&quot;vcdVmMoid\&quot;: \&quot;$vcdVmMoid\&quot;,           \&quot;indexState\&quot;: 0         }       ]     }   ],   \&quot;total\&quot;: 0 }  &#x60;&#x60;&#x60;  ## Creating an on-demand snapshot for a vApp  To create an on-demand snapshot for a specified vApp object, send a POST request to [&#x60;/vcd/vapp/{id}/snapshot&#x60;](#operation/createOnDemandSnapshotV1), where {id} is the ID of the vApp object.   &#x60;&#x60;&#x60;bash  curl -X POST -d \&quot;https://$cluster_address/api/v1/vcd/vapp/$id/snapshot\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an asynchronous job to create an on-demand snapshot and returns the details of the AsyncRequestStatus request.   &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/vapp/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] }  &#x60;&#x60;&#x60;  ### Deleting all snapshots of a vApp object  To delete all snapshots for a specified vApp object, send a DELETE request to [&#x60;/vcd/vapp/{id}/snapshot&#x60;](#operation/deleteVappSnapshotsV1), where {id} is the ID of the vApp object whose snapshot needs to be deleted.   &#x60;&#x60;&#x60;bash  curl -X DELETE -d \&quot;https://$cluster_address/api/v1/vcd/vapp/$id/snapshot\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server deletes all snapshots of the specified vApp.   &#x60;&#x60;&#x60;bash {\&quot;Snapshots deleted successfully.\&quot;}  &#x60;&#x60;&#x60;  ## Retrieving details about a specific vApp snapshot  To retrieve detailed information about a specified snapshot for a vApp object, send a GET request to [&#x60;/vcd/vapp/snapshot/{id}&#x60;](#operation/getVappSnapshotV1), where {id} is the ID of the snapshot object whose details are required.  &#x60;&#x60;&#x60;bash  curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/snapshot/{id}\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server fetches details (VcdVappSnapshotDetail) of the specified vApp snapshot.   &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;date\&quot;: \&quot;$date\&quot;,   \&quot;expirationDate\&quot;: \&quot;$expirationDate\&quot;,   \&quot;sourceObjectType\&quot;: \&quot;$sourceObjectType\&quot;,   \&quot;isOnDemandSnapshot\&quot;: true,   \&quot;isCustomRetentionApplied\&quot;: true,   \&quot;cloudState\&quot;: 0,   \&quot;consistencyLevel\&quot;: \&quot;$consistencyLevel\&quot;,   \&quot;indexState\&quot;: 0,   \&quot;replicationLocationIds\&quot;: [     \&quot;string\&quot;   ],   \&quot;archivalLocationIds\&quot;: [     \&quot;string\&quot;   ],   \&quot;slaId\&quot;: \&quot;$slaId\&quot;,   \&quot;slaName\&quot;: \&quot;$slaName\&quot;,   \&quot;isRetainedByRetentionLockSla\&quot;: true,   \&quot;cloudStorageTier\&quot;: \&quot;Hot\&quot;,   \&quot;isPlacedOnLegalHold\&quot;: true,   \&quot;snapshotRetentionInfo\&quot;: {     \&quot;localInfo\&quot;: {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;isSnapshotPresent\&quot;: true,       \&quot;isExpirationDateCalculated\&quot;: true,       \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,       \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,       \&quot;isExpirationInformationUnavailable\&quot;: true     },     \&quot;archivalInfos\&quot;: [       {         \&quot;id\&quot;: \&quot;$id\&quot;,         \&quot;name\&quot;: \&quot;$name\&quot;,         \&quot;isSnapshotPresent\&quot;: true,         \&quot;isExpirationDateCalculated\&quot;: true,         \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,         \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,         \&quot;isExpirationInformationUnavailable\&quot;: true       }     ],     \&quot;replicationInfos\&quot;: [       {         \&quot;id\&quot;: \&quot;$id\&quot;,         \&quot;name\&quot;: \&quot;$name\&quot;,         \&quot;isSnapshotPresent\&quot;: true,         \&quot;isExpirationDateCalculated\&quot;: true,         \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,         \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,         \&quot;isExpirationInformationUnavailable\&quot;: true       }     ],     \&quot;cloudNativeLocationInfo\&quot;: [       {         \&quot;id\&quot;: \&quot;$id\&quot;,         \&quot;name\&quot;: \&quot;$name\&quot;,         \&quot;isSnapshotPresent\&quot;: true,         \&quot;isExpirationDateCalculated\&quot;: true,         \&quot;expirationTime\&quot;: \&quot;$expirationTime\&quot;,         \&quot;snapshotFrequency\&quot;: \&quot;$snapshotFrequency\&quot;,         \&quot;isExpirationInformationUnavailable\&quot;: true       }     ]   },   \&quot;parentSnapshotId\&quot;: \&quot;$parentSnapshotId\&quot;,   \&quot;vappName\&quot;: \&quot;$vappName\&quot;,   \&quot;isSynchronized\&quot;: true,   \&quot;vmSnapshots\&quot;: [     {       \&quot;vcenterVmId\&quot;: \&quot;$vcenterVmId\&quot;,       \&quot;vmSnapshotId\&quot;: \&quot;$vmSnapshotId\&quot;,       \&quot;vmName\&quot;: \&quot;$vmName\&quot;,       \&quot;vcdVmMoid\&quot;: \&quot;$vcdVmMoid\&quot;,       \&quot;indexState\&quot;: 0,       \&quot;networkConnections\&quot;: [         {           \&quot;nicIndex\&quot;: 0,           \&quot;macAddress\&quot;: \&quot;$macAddress\&quot;,           \&quot;addressingMode\&quot;: \&quot;DHCP\&quot;,           \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,           \&quot;vappNetworkName\&quot;: \&quot;vappNetworkName\&quot;,           \&quot;isConnected\&quot;: true,           \&quot;networkAdapterType\&quot;: \&quot;$networkAdapterType\&quot;         }       ]     }   ],   \&quot;networks\&quot;: [     {       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;parentNetworkId\&quot;: \&quot;$parentNetworkId\&quot;,       \&quot;isDeployed\&quot;: true     }   ],   \&quot;excludedVcdVmMoids\&quot;: [     $excludedVcdVmMoids   ] }  &#x60;&#x60;&#x60;  ### Deleting a specific vApp snapshot object  To delete an on-demand snapshot or a snapshot from a vApp that is not assigned to an SLA Domain, send a DELETE request to [&#x60;/vcd/vapp/snapshot/{id}&#x60;](#operation/deleteVappSnapshotV1), where {id}  is the ID assigned to a snapshot object.  &#x60;&#x60;&#x60;bash  curl -X DELETE -d \&quot;https://$cluster_address/api/v1/vcd/vapp/snapshot/{id}?location&#x3D;$snapshot_location\&quot;  &#x60;&#x60;&#x60;  The Rubrik REST API server deletes the specified vApp snapshot at the location (\&quot;all\&quot; or \&quot;local\&quot;) specified.    &#x60;&#x60;&#x60;bash {\&quot;Snapshot successfully deleted.\&quot;}  &#x60;&#x60;&#x60;  ### Retrieving details about missed snapshots for a vApp object  To retrieve the timestamp for each missed snapshot for a specified vApp, send a GET request to [&#x60;/vcd/vapp/{id}/missed_snapshot&#x60;](#operation/vcdMissedSnapshotsV1). where {id} is the id of the vapp.   &#x60;&#x60;&#x60;bash   curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/$id/missed_snapshot\&quot;   &#x60;&#x60;&#x60;  The Rubrik REST API server fetches details about all missed snapshots (List of MissedSnapshot) of the specified vApp.    &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;archivalLocationType\&quot;: [         \&quot;string\&quot;       ],       \&quot;missedSnapshotTime\&quot;: \&quot;$missedSnapshotTime\&quot;,       \&quot;missedSnapshotTimeUnits\&quot;: [         {           \&quot;timeUnit\&quot;: \&quot;Minute\&quot;,           \&quot;frequency\&quot;: 0,           \&quot;retention\&quot;: 0,           \&quot;dayOfTime\&quot;: \&quot;Monday\&quot;         }       ]     }   ],   \&quot;total\&quot;: 0 }   &#x60;&#x60;&#x60;  ### Retrieving exportable network configurations  To retrieve the summary information for the vApp networks that are available for network connections from the virtual machines in the exported vApp snapshot, send a GET request to [&#x60;/vcd/vapp/snapshot/{snapshot_id}/export/options&#x60;](#operation/getVappSnapshotExportOptionsV1). This API requires the snapshot_id of the vApp snapshot object to export. It also requires the &#x60;export_mode&#x60;, &#x60;target_vapp_id&#x60; and the &#x60;target_org_vdc_id1&#x60;.  &#x60;&#x60;&#x60;bash   curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/export/options?export_mode&#x3D;$export_mode\&quot;   &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VappExportOptions for the specified snapshot and export mode specified.    &#x60;&#x60;&#x60;bash {   \&quot;restorableNetworks\&quot;: [     {       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;parentNetworkId\&quot;: \&quot;$parentNetworkId\&quot;,       \&quot;isDeployed\&quot;: true,       \&quot;newName\&quot;: \&quot;$newName\&quot;     }   ],   \&quot;targetVappNetworks\&quot;: [     {       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;parentNetworkId\&quot;: \&quot;$parentNetworkId\&quot;,       \&quot;isDeployed\&quot;: true     }   ],   \&quot;availableStoragePolicies\&quot;: [     {       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;id\&quot;: \&quot;$id\&quot;     }   ],   \&quot;allChildVmsWithDefaultNetworkConnections\&quot;: [     {       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;vcdMoid\&quot;: \&quot;$vcdMoid\&quot;,       \&quot;storagePolicyId\&quot;: \&quot;$storagePolicyId\&quot;,       \&quot;networkConnections\&quot;: [         {           \&quot;nicIndex\&quot;: 0,           \&quot;macAddress\&quot;: \&quot;$macAddress\&quot;,           \&quot;addressingMode\&quot;: \&quot;DHCP\&quot;,           \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,           \&quot;vappNetworkName\&quot;: \&quot;$vappNetworkName\&quot;,           \&quot;isConnected\&quot;: true,           \&quot;networkAdapterType\&quot;: \&quot;$networkAdapterType\&quot;         }       ]     }   ] }   &#x60;&#x60;&#x60;  ### Exporting vApp snapshot  To export the specified vApp snapshot into a new vApp or an existing vApp, send a POST request to [&#x60;/vcd/vapp/snapshot/{snapshot_id}/export&#x60;](#operation/createVappExportV1), where {snapshot_id} is the ID assigned to the vApp snapshot object.  &#x60;&#x60;&#x60;bash     curl -X POST -d \\     &#39;{       \&quot;exportMode\&quot;: \&quot;$exportMode\&quot;,       \&quot;newVappParams\&quot;: {         \&quot;name\&quot;: \&quot;$name\&quot;,         \&quot;orgVdcId\&quot;: \&quot;$orgVdcId\&quot;       },       \&quot;targetVappId\&quot;: \&quot;$targetVappId\&quot;,       \&quot;networksToRestore\&quot;: [         {           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;parentNetworkId\&quot;: \&quot;$parentNetworkId\&quot;,           \&quot;isDeployed\&quot;: true,           \&quot;newName\&quot;: \&quot;$newName\&quot;         }       ],       \&quot;vmsToExport\&quot;: [         {           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;vcdMoid\&quot;: \&quot;$vcdMoid\&quot;,           \&quot;storagePolicyId\&quot;: \&quot;$storagePolicyId\&quot;,           \&quot;networkConnections\&quot;: [             {               \&quot;nicIndex\&quot;: 0,               \&quot;macAddress\&quot;: \&quot;$macAddress\&quot;,               \&quot;addressingMode\&quot;: \&quot;DHCP\&quot;,               \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,               \&quot;vappNetworkName\&quot;: \&quot;$vappNetworkName\&quot;,               \&quot;isConnected\&quot;: true,               \&quot;networkAdapterType\&quot;: \&quot;$networkAdapterType\&quot;             }           ]         }       ],       \&quot;shouldPowerOnVappAfterExport\&quot;: false     }&#39; \\     \&quot;https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/export\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an asynchronous job to export vApp snapshot and returns the details of the AsyncRequestStatus request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/vapp/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Recovering vApp objects of virtual machines  To instantly recover the specified vApp, send a POST request to [&#x60;/vcd/vapp/snapshot/{snapshot_id}/instant_recover&#x60;](#operation/createVappInstantRecoveryV1), where {snapshot_id} is the ID assigned to the vApp snapshot object.  &#x60;&#x60;&#x60;bash     curl -X POST -d \\     &#39;{       \&quot;vmsToRestore\&quot;: [         {           \&quot;name\&quot;: \&quot;$name\&quot;,           \&quot;vcdMoid\&quot;: \&quot;$vcdMoid\&quot;,           \&quot;storagePolicyId\&quot;: \&quot;$storagePolicyId\&quot;,           \&quot;networkConnections\&quot;: [             {               \&quot;nicIndex\&quot;: 0,               \&quot;macAddress\&quot;: \&quot;$macAddress\&quot;,               \&quot;addressingMode\&quot;: \&quot;DHCP\&quot;,               \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,               \&quot;vappNetworkName\&quot;: \&quot;$vappNetworkName\&quot;,               \&quot;isConnected\&quot;: true,               \&quot;networkAdapterType\&quot;: \&quot;$networkAdapterType\&quot;             }           ]         }       ],       \&quot;shouldPowerOnVmsAfterRecovery\&quot;: false     }&#39; \\     \&quot;https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/instant_recover\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an asynchronous job to Instant Recover vApp snapshot and returns the details of the AsyncRequestStatus request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;$status\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/vapp/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving Instant Recovery information  To retrieve the available vApp network connections and the default vApp network connection for the virtual machines in a vApp snapshot, send a GET request to [&#x60;/vcd/vapp/snapshot/{snapshot_id}/instant_recover/options&#x60;](#operation/getVappSnapshotInstantRecoveryOptionsV1), where {snapshot_id} is the ID of the vApp snapshot object.  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/snapshot/$snapshot_id/instant_recover/options\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VappInstantRecoveryOptions for the specified snapshot.  &#x60;&#x60;&#x60;bash {   \&quot;restorableVms\&quot;: [     {       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;vcdMoid\&quot;: \&quot;$vcdMoid\&quot;,       \&quot;storagePolicyId\&quot;: \&quot;$storagePolicyId\&quot;,       \&quot;networkConnections\&quot;: [         {           \&quot;nicIndex\&quot;: 0,           \&quot;macAddress\&quot;: \&quot;$macAddress\&quot;,           \&quot;addressingMode\&quot;: \&quot;DHCP\&quot;,           \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,           \&quot;vappNetworkName\&quot;: \&quot;$vappNetworkName\&quot;,           \&quot;isConnected\&quot;: true,           \&quot;networkAdapterType\&quot;: \&quot;$networkAdapterType\&quot;         }       ]     }   ],   \&quot;availableVappNetworks\&quot;: [     {       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;parentNetworkId\&quot;: \&quot;$parentNetworkId\&quot;,       \&quot;isDeployed\&quot;: true     }   ] } &#x60;&#x60;&#x60;  ### Retrieving vApp job status  To retrieves the details of a specified asynchronous job for a vApp, send a GET request to [&#x60;/vcd/vapp/request/{id}&#x60;](#operation/getVappAsyncRequestStatusV1), where {id} is the ID assigned to an asynchronous job.  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/request/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches status of a vApp asynchronous job (AsyncRequestStatus).  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/vapp/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Searching for a file in a vApp snapshot  To search for a file through snapshots of all virtual machines that are part of the vApp, send a GET request to [&#x60;/vcd/vapp/{id}/search&#x60;](#operation/searchVappV1), where {id} is the ID of the vApp. It also requires a &#x60;path&#x60; parameter. The parameter takes either a path prefix or a filename prefix.  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/vapp/$id/search/options?path&#x3D;$path\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server searches a file through snapshots of all virtual machines and returns list of  AppSearchResponse.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;path\&quot;: \&quot;$path\&quot;,       \&quot;filename\&quot;: \&quot;$filename\&quot;,       \&quot;fileVersions\&quot;: [         {           \&quot;lastModified\&quot;: \&quot;$lastModified\&quot;,           \&quot;size\&quot;: 0,           \&quot;snapshotId\&quot;: \&quot;$snapshotId\&quot;,           \&quot;fileMode\&quot;: \&quot;$fileMode\&quot;,           \&quot;source\&quot;: \&quot;$source\&quot;         }       ],       \&quot;childObjectId\&quot;: \&quot;$childObjectId\&quot;,       \&quot;childObjectName\&quot;: \&quot;$childObjectName\&quot;     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ### Downloading snapshot from archive  To retrieve a snapshot that is not available locally, from an archival location, send a POST request to [&#x60;/vcd/vapp/snapshot/{id}/download&#x60;](#operation/createVcdVappDownloadSnapshotFromCloudV1)z where {id} is the ID of the snapshot which needs to be downloaded.  &#x60;&#x60;&#x60;bash     curl -X POST -d \&quot;https://$cluster_address/api/v1/vcd/vapp/snapshot/$id/download\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an asynchronous job to download vApp snapshot from archive and returns the  details of the AsyncRequestStatus request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/vapp/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving summary for all vCD Clusters  To retrieve the summary information for all vCD cluster objects, send a GET request to [&#x60;/vcd/cluster&#x60;](#operation/queryVcdClusterV1). The parameters described in the following table are available to filter the results of the GET request.  | Name       | Required | Type   | Description | | ---------- | -------- | ------ | ----------- | |&#x60;name&#x60;      | Optional | string | Search for a vCD Cluster object by name.| |&#x60;status&#x60;    | Optional | string | Filter the results using the status value of the vCD Cluster objects.| |&#x60;sort_by&#x60;   | Optional | string | Attribute to sort the results on.| |&#x60;sort_order&#x60;| Optional | string | Order for sorting the results, either ascending or descending.|  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/cluster\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VcdClusterSummary for all vCD instances on the Rubrik cluster.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;INHERIT\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;Inherit\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,       \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,       \&quot;hostname\&quot;: \&quot;$hostname\&quot;,       \&quot;username\&quot;: \&quot;$username\&quot;,       \&quot;caCerts\&quot;: \&quot;$caCerts\&quot;,       \&quot;connectionStatus\&quot;: {         \&quot;status\&quot;: \&quot;Disconnected\&quot;,         \&quot;message\&quot;: \&quot;string\&quot;       }     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ### Adding a vCD Cluster  To create a vCD Cluster object by providing the address of the vCD Cluster and the credentials for an account on the vCD Cluster that has administrator privileges, send a POST request to [&#x60;/vcd/cluster&#x60;](#operation/createVcdClusterV1).  &#x60;&#x60;&#x60;bash     curl -X POST -d \\     &#39;{       \&quot;hostname\&quot;: \&quot;$hostname\&quot;,       \&quot;username\&quot;: \&quot;$username\&quot;,       \&quot;caCerts\&quot;: \&quot;$caCerts\&quot;,       \&quot;password\&quot;: \&quot;$password\&quot;     }&#39; \\     \&quot;https://$cluster_address/api/v1/vcd/cluster\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server attempts to add vCD to the Rubrik cluster and returns AsyncRequestStatus of request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/cluster/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving VimServers of a vCD Cluster  To retrieve the VimServer representation of the vCenter Servers that are attached to a specified vCD Cluster object, send a GET request to [&#x60;/vcd/cluster/{id}/vimserver&#x60;](#operation/queryVcdVimServerV1), where {id} is the ID assigned to the vCD cluster. It also need two parameters &#x60;sort_by&#x60; and &#x60;sort_order&#x60; which decide the order of the results.  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/cluster/$id/vimserver\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VimserverSummary for all Vim servers belonging to a vCD.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;vcenterId\&quot;: \&quot;$vcenterId\&quot;,       \&quot;vcdClusterId\&quot;: \&quot;$vcdClusterId\&quot;,       \&quot;vcdClusterName\&quot;: \&quot;$vcdClusterName\&quot;,       \&quot;hostname\&quot;: \&quot;$hostname\&quot;,       \&quot;connectionStatus\&quot;: {         \&quot;status\&quot;: \&quot;Disconnected\&quot;,         \&quot;message\&quot;: \&quot;string\&quot;       }     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ### Refreshing a vCD Cluster  To refresh the metadata for a specified vCD Cluster object, send a POST request to [&#x60;/vcd/cluster/{id}/refresh&#x60;](#operation/refreshVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object.  &#x60;&#x60;&#x60;bash     curl -X POST -d \&quot;https://$cluster_address/api/v1/vcd/cluster/$id/refresh\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an asynchronous job to refresh a vCD and returns the details of the AsyncRequestStatus request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/cluster/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving vCD Cluster details  To retrieve detailed information for a vCD Cluster object, send a GET request to [&#x60;/vcd/cluster/{id}&#x60;](#operation/getVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object.  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/cluster/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VcdClusterDetail for the specified vCD instance.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;,   \&quot;username\&quot;: \&quot;$username\&quot;,   \&quot;caCerts\&quot;: \&quot;$caCerts\&quot;,   \&quot;connectionStatus\&quot;: {     \&quot;status\&quot;: \&quot;Disconnected\&quot;,     \&quot;message\&quot;: \&quot;string\&quot;   } } &#x60;&#x60;&#x60;  ### Changing vCD Cluster object  To modify the hostname and credentials of a specified vCD Cluster object, send a PATCH request to [&#x60;/vcd/cluster/{id}&#x60;](#operation/updateVcdClusterV1), where {id} is the ID assigned to a vCD Cluster object. It also requires a parameter named &#x60;patch_properties&#x60; which contains the updated hostname and credentials for a specified vCD Cluster object.  &#x60;&#x60;&#x60;bash     curl -X PATCH -d \\     &#39;{       \&quot;hostname\&quot;: \&quot;$hostname\&quot;,       \&quot;username\&quot;: \&quot;$username\&quot;,       \&quot;password\&quot;: \&quot;$password\&quot;,       \&quot;caCerts\&quot;: \&quot;$caCerts\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;     }&#39; \\     \&quot;https://$cluster_address/api/v1/vcd/cluster/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server updates and fetches the updated VcdClusterDetail for the specified vCD instance.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;ProtectionSla\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,   \&quot;hostname\&quot;: \&quot;$hostname\&quot;,   \&quot;username\&quot;: \&quot;$username\&quot;,   \&quot;caCerts\&quot;: \&quot;$caCerts\&quot;,   \&quot;connectionStatus\&quot;: {     \&quot;status\&quot;: \&quot;Disconnected\&quot;,     \&quot;message\&quot;: \&quot;string\&quot;   } } &#x60;&#x60;&#x60;  ### Removing a vCD Cluster  To remove a vCD Cluster object, send a DELETE request to [&#x60;/vcd/cluster/{id}&#x60;](#operation/deleteVcdClusterV1), where {id} is the ID of assigned to a vCD Cluster object.  &#x60;&#x60;&#x60;bash     curl -X DELETE -d \&quot;https://$cluster_address/api/v1/vcd/cluster/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates an asynchronous job to delete a vCD instance and returns the details of the AsyncRequestStatus request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/cluster/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving details of jobs on vCD cluster  To retrieve the details of a specified asynchronous job for a vCD Cluster, send a GET request to [&#x60;/vcd/cluster/request/{id}&#x60;](#operation/getVcdClusterAsyncRequestStatusV1), where {id} is the ID assigned to an asynchronous job.  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/cluster/request/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches details of the specifed asynchronous job and returns the AsyncRequestStatus request.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$requestId\&quot;,   \&quot;status\&quot;: \&quot;QUEUED\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;$startTime\&quot;,   \&quot;endTime\&quot;: \&quot;$endTime\&quot;,   \&quot;nodeId\&quot;: \&quot;$nodeId\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/vcd/cluster/request/$requestId\&quot;,       \&quot;rel\&quot;: \&quot;self\&quot;     }   ] } &#x60;&#x60;&#x60;  ### Retrieving summary of a vCD hierarchy object  To retrieve details of the specified object in the vCD hierarchy, send a GET request to [&#x60;/vcd/hierarchy/{id}&#x60;](#operation/getVcdHierarchyObjectV1), where {id} is the ID of the vCD hierarchy object.  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/hierarchy/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VcdHierarchyObjectSummary for the specified vCD object.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;name\&quot;: \&quot;$name\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,   \&quot;configuredSlaDomainType\&quot;: \&quot;$configuredSlaDomainType\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,   \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;retentionSlaDomainId\&quot;: \&quot;$retentionSlaDomainId\&quot;,   \&quot;infraPath\&quot;: [     ...   ],   \&quot;slaPath\&quot;: [     ...   ],   \&quot;isRelic\&quot;: true,   \&quot;isDeleted\&quot;: true,   \&quot;objectType\&quot;: \&quot;Cluster\&quot;,   \&quot;descendantCount\&quot;: {     \&quot;vcdCluster\&quot;: 0,     \&quot;connectedVimServer\&quot;: 0,     \&quot;disconnectedVimServer\&quot;: 0,     \&quot;org\&quot;: 0,     \&quot;orgVdc\&quot;: 0,     \&quot;catalog\&quot;: 0,     \&quot;vApp\&quot;: 0   },   \&quot;connectionStatus\&quot;: {     \&quot;status\&quot;: \&quot;Disconnected\&quot;,     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,   \&quot;vcenterId\&quot;: \&quot;$vcenterId\&quot;,   \&quot;extendedAttributes\&quot;: {     \&quot;vappAtributes\&quot;: {       \&quot;isVappTemplate\&quot;: true     }   },   \&quot;pendingSlaDomain\&quot;: {     \&quot;objectId\&quot;: \&quot;$objectId\&quot;,     \&quot;pendingSlaDomainId\&quot;: \&quot;$pendingSlaDomainId\&quot;,     \&quot;pendingSlaDomainName\&quot;: \&quot;$pendingSlaDomainName\&quot;,     \&quot;isPendingSlaDomainRetentionLocked\&quot;: true   } } &#x60;&#x60;&#x60;  ### Retrieving immediate descendant objects  To retrieve the list of immediate descendant objects for the specified parent, send a GET request to [&#x60;/vcd/hierarchy/{id}/children&#x60;](#operation/getVcdHierarchyChildrenV1), where {id} is the ID of the parent vCD hierarchy object. The parameters described in the following table are available to filter the results of the GET request.  | Name                    | Required | Type    | Description | | ----------------------- | -------- | ------- | ----------- | |&#x60;id&#x60;                     | Required | string  | ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.| |&#x60;sort_by&#x60;                | Optional | string  | Attribute to sort the results on.| |&#x60;sort_order&#x60;             | Optional | string  | Order for sorting the results, either ascending or descending.| |&#x60;limit&#x60;                  | Optional | int     | Limit the number of matches returned.| |&#x60;offset&#x60;                 | Optional | int     | Number of matches to ignore from the beginning of the results.| |&#x60;name&#x60;                   | Optional | string  | Search object by object name.| |&#x60;is_relic&#x60;               | Optional | boolean | Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.| |&#x60;effective_sla_domain_id&#x60;| Optional | string  | Filter by ID of effective SLA domain.| |&#x60;object_type&#x60;            | Optional | string  | Filter by node object type. | |&#x60;primary_cluster_id&#x60;     | Optional | string  | Filter by primary cluster ID, or **local**.| |&#x60;sla_assignment&#x60;         | Optional | string  | Filter by SLA assignment type.| |&#x60;snappable_status&#x60;       | Optional | string  | Filters vCD hierarchy objects based on the specified query value.|  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/hierarchy/$id/children\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VcdHierarchyObjectSummary for all children (immediate descendants)  of the specified vCD object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;$configuredSlaDomainType\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,       \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,       \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,       \&quot;retentionSlaDomainId\&quot;: \&quot;$retentionSlaDomainId\&quot;,       \&quot;infraPath\&quot;: [         ...       ],       \&quot;slaPath\&quot;: [         ...       ],       \&quot;isRelic\&quot;: true,       \&quot;isDeleted\&quot;: true,       \&quot;objectType\&quot;: \&quot;Cluster\&quot;,       \&quot;descendantCount\&quot;: {         \&quot;vcdCluster\&quot;: 0,         \&quot;connectedVimServer\&quot;: 0,         \&quot;disconnectedVimServer\&quot;: 0,         \&quot;org\&quot;: 0,         \&quot;orgVdc\&quot;: 0,         \&quot;catalog\&quot;: 0,         \&quot;vApp\&quot;: 0       },       \&quot;connectionStatus\&quot;: {         \&quot;status\&quot;: \&quot;Disconnected\&quot;,         \&quot;message\&quot;: \&quot;string\&quot;       },       \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,       \&quot;vcenterId\&quot;: \&quot;$vcenterId\&quot;,       \&quot;extendedAttributes\&quot;: {         \&quot;vappAtributes\&quot;: {           \&quot;isVappTemplate\&quot;: true         }       },       \&quot;pendingSlaDomain\&quot;: {         \&quot;objectId\&quot;: \&quot;$objectId\&quot;,         \&quot;pendingSlaDomainId\&quot;: \&quot;$pendingSlaDomainId\&quot;,         \&quot;pendingSlaDomainName\&quot;: \&quot;$pendingSlaDomainName\&quot;,         \&quot;isPendingSlaDomainRetentionLocked\&quot;: true       }     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ### Retrieving list of descendant objects  To retrieve the list of descendant objects for the specified parent, send a GET request to [&#x60;/vcd/hierarchy/{id}/descendants&#x60;](#operation/getVcdHierarchyDescendantsV1), where {id} is the ID of the parent vCD hierarchy object. The parameters described in the following table are available to filter the results of the GET request.  | Name                    | Required | Type    | Description | | ----------------------- | -------- | ------- | ----------- | |&#x60;id&#x60;                     | Required | string  | ID of the parent vCD hierarchy object. To get top-level nodes, use **root** as the ID.| |&#x60;sort_by&#x60;                | Optional | string  | Attribute to sort the results on.| |&#x60;sort_order&#x60;             | Optional | string  | Order for sorting the results, either ascending or descending.| |&#x60;limit&#x60;                  | Optional | int     | Limit the number of matches returned.| |&#x60;offset&#x60;                 | Optional | int     | Number of matches to ignore from the beginning of the results.| |&#x60;name&#x60;                   | Optional | string  | Search object by object name.| |&#x60;is_relic&#x60;               | Optional | boolean | Filter by isRelic field of vCD vApp hierarchy object. Return both relic and non-relic children when this value is not specified.| |&#x60;effective_sla_domain_id&#x60;| Optional | string  | Filter by ID of effective SLA domain.| |&#x60;object_type&#x60;            | Optional | string  | Filter by node object type. | |&#x60;primary_cluster_id&#x60;     | Optional | string  | Filter by primary cluster ID, or **local**.| |&#x60;sla_assignment&#x60;         | Optional | string  | Filter by SLA assignment type.| |&#x60;snappable_status&#x60;       | Optional | string  | Filters vCD hierarchy objects based on the specified query value.|  &#x60;&#x60;&#x60;bash     curl -X GET -d \&quot;https://$cluster_address/api/v1/vcd/hierarchy/$id/descendants\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server fetches VcdHierarchyObjectSummary for all descendants of specified vCD object.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;name\&quot;: \&quot;$name\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;$configuredSlaDomainId\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;$configuredSlaDomainName\&quot;,       \&quot;configuredSlaDomainType\&quot;: \&quot;$configuredSlaDomainType\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,       \&quot;slaLastUpdateTime\&quot;: \&quot;$slaLastUpdateTime\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;UNPROTECTED\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;Unprotected\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,       \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;$effectiveSlaDomainPolarisManagedId\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;$effectiveSlaSourceObjectId\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;$effectiveSlaSourceObjectName\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,       \&quot;retentionSlaDomainId\&quot;: \&quot;$retentionSlaDomainId\&quot;,       \&quot;infraPath\&quot;: [         ...       ],       \&quot;slaPath\&quot;: [         ...       ],       \&quot;isRelic\&quot;: true,       \&quot;isDeleted\&quot;: true,       \&quot;objectType\&quot;: \&quot;Cluster\&quot;,       \&quot;descendantCount\&quot;: {         \&quot;vcdCluster\&quot;: 0,         \&quot;connectedVimServer\&quot;: 0,         \&quot;disconnectedVimServer\&quot;: 0,         \&quot;org\&quot;: 0,         \&quot;orgVdc\&quot;: 0,         \&quot;catalog\&quot;: 0,         \&quot;vApp\&quot;: 0       },       \&quot;connectionStatus\&quot;: {         \&quot;status\&quot;: \&quot;Disconnected\&quot;,         \&quot;message\&quot;: \&quot;string\&quot;       },       \&quot;ipAddress\&quot;: \&quot;$ipAddress\&quot;,       \&quot;vcenterId\&quot;: \&quot;$vcenterId\&quot;,       \&quot;extendedAttributes\&quot;: {         \&quot;vappAtributes\&quot;: {           \&quot;isVappTemplate\&quot;: true         }       },       \&quot;pendingSlaDomain\&quot;: {         \&quot;objectId\&quot;: \&quot;$objectId\&quot;,         \&quot;pendingSlaDomainId\&quot;: \&quot;$pendingSlaDomainId\&quot;,         \&quot;pendingSlaDomainName\&quot;: \&quot;$pendingSlaDomainName\&quot;,         \&quot;isPendingSlaDomainRetentionLocked\&quot;: true       }     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  # Blackout Windows  ## Get Global Blackout Window Status Send a GET request to [&#39;/blackout_window&#x60;](#operation/getBlackoutWindowStatus)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/blackout_window\&quot; &#x60;&#x60;&#x60;  ## Start or Stop the Global Blackout Window in local Rubrik Cluster Send a PATCH request to [&#x60;/blackout_window&#x60;](#operation/toggleBlackoutWindow)  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{ \\    \&quot;isGlobalBlackoutActive\&quot;: true \\    }&#39; \\   \&quot;https://$cluster_address/api/v1/blackout_window\&quot; &#x60;&#x60;&#x60;  # Managed Volumes  ## Create Script to Unify Managed Volume Export View  To request an asynchronous job to generate a script to create a directory to view all files in all channels of a managed volume export, send a POST request to the [&#x60;/managed_volume/snapshot/export/{id}/script&#x60;](#operation/createManagedVolumeGenerateScriptJob) endpoint with the ID of the snapshot export.  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/managed_volume/snapshot/export/{id}/script\&quot; &#x60;&#x60;&#x60; An asynchronous request is returned and can be polled to retrieve the job status.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;:\&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;:\&quot;https://$cluster_address/api/v1/managed_volume/request/$request_id\&quot;,       \&quot;rel\&quot;:\&quot;result\&quot;     },   \&quot;status\&quot;:\&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  # Archival  ## Create Script to Refresh data sources in a Reader location  Send a POST request to the [&#x60;/archive/location/{location_id}/reader/refresh/data_sources&#x60;](#operation/refreshArchivalLocationDataSources) endpoint to request an asynchronous job that refreshes the metadata for a list of data sources from a specified reader location. The POST request must provide the ID of the reader location and a list of the IDs of the data sources in the archival location.  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/archive/location/{location_id}/reader/refresh/data_sources\&quot; &#x60;&#x60;&#x60; An asynchronous request is returned and can be polled to retrieve the job status.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;:\&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;:\&quot;https://$cluster_address/api/v1/archive/request/$request_id\&quot;,       \&quot;rel\&quot;:\&quot;result\&quot;     },   \&quot;status\&quot;:\&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  ## Get the ID of the customer AWS account that owns the archival location  Send a GET request to the [&#x60;/archive/aws/s3/{id}/account_id&#x60;](#operation/getAwsAccountId) endpoint to request the ID of the AWS customer account for the S3 archival location. Returns an error when the location given is not an AWS S3 archival location.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/archive/aws/s3/{id}/account_id\&quot; &#x60;&#x60;&#x60; Returns the ID of the AWS account.  ## Disable archival location for archiving and modifications.  Send a POST request to the [&#x60;/archive/location/{location_id}/owner/disable&#x60;](#operation/disableArchivalLocation) endpoint to disable the specified active archival location. The POST request must include the ID of the active location.  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/archive/location/{location_id}/owner/disable\&quot; &#x60;&#x60;&#x60; Returns empty response body  ## Enable archival location for archiving and modifications.  Send a POST request to the [&#x60;/archive/location/{location_id}/owner/enable&#x60;](#operation/enableArchivalLocation) endpoint to enable archiving and other operations that were previously disabled on the specified archival location with the disable operation. The POST request must include the ID of the specified location.  &#x60;&#x60;&#x60;bash curl -X POST \\   \&quot;https://$cluster_address/api/v1/archive/location/{location_id}/owner/enable\&quot; &#x60;&#x60;&#x60; Returns empty response body  # Replication  ## Enable Source Specific Replication Pause Send a POST request to [&#x60;/replication/location_pause/enable&#x60;] (#operation/enablePerLocationPause)  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{ \\    \&quot;sourceClusterUuids\&quot;: [\&quot;510ae3f4-d733-4545-9ea4-fe702401fdca\&quot;], \\    \&quot;shouldCancelImmediately\&quot;: true \\    }&#39; \\   \&quot;https://$cluster_address/api/v1/replication/location_pause/enable\&quot; &#x60;&#x60;&#x60;  ## Disable Source Specific Replication Pause Send a POST request to [&#x60;/replication/location_pause/disable&#x60;] (#operation/disablePerLocationPause)  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{ \\    \&quot;sourceClusterUuids\&quot;: [\&quot;510ae3f4-d733-4545-9ea4-fe702401fdca\&quot;], \\    \&quot;shouldSkipOldSnapshots\&quot;: true \\    }&#39; \\   \&quot;https://$cluster_address/api/v1/replication/location_pause/disable\&quot; &#x60;&#x60;&#x60;  # Unmanaged object  An unmanaged object is an object that is not currently assigned an active SLA.  ### Get all unmanaged reader object summaries Get a listing of all unmanaged reader object summaries using a GET request to [/unmanaged_object/reader_object](#operation/queryUnmanagedReaderObject).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/unmanaged_object/reader_object\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server returns a &#x60;ListResponse&#x60; object of unmanaged reader object summaries. &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$vm1_managed_id\&quot;,       \&quot;name\&quot;: \&quot;$vm1_name\&quot;,       \&quot;objectType\&quot;: \&quot;VirtualMachine\&quot;,       \&quot;physicalLocation\&quot;: [         {           \&quot;managedId\&quot;: \&quot;$location1_managed_id\&quot;,           \&quot;name\&quot;: \&quot;$location1_name\&quot;         }       ],       \&quot;unmanagedStatus\&quot;: \&quot;Unprotected\&quot;,       \&quot;autoSnapshotCount\&quot;: 20,       \&quot;manualSnapshotCount\&quot;: 0,       \&quot;localStorage\&quot;: 100,       \&quot;archiveStorage\&quot;: 0,       \&quot;retentionSlaDomainId\&quot;: \&quot;$gold_sla_id\&quot;,       \&quot;retentionSlaDomainName\&quot;: \&quot;Gold\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60; ### Get all unmanaged object summaries Get a list of all objects with unmanaged snapshots using a GET request to [/unmanaged_object](#operation/queryUnmanagedObjectV1).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/unmanaged_object\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server returns a &#x60;ListResponse&#x60; object of objects with  unmanaged snapshots. &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$vm1_managed_id\&quot;,       \&quot;name\&quot;: \&quot;$vm1_name\&quot;,       \&quot;objectType\&quot;: \&quot;VirtualMachine\&quot;,       \&quot;physicalLocation\&quot;: [         {           \&quot;managedId\&quot;: \&quot;$location1_managed_id\&quot;,           \&quot;name\&quot;: \&quot;$location1_name\&quot;         }       ],       \&quot;unmanagedStatus\&quot;: \&quot;Unprotected\&quot;,       \&quot;snapshotCount\&quot;: 20,       \&quot;localStorage\&quot;: 100,       \&quot;archiveStorage\&quot;: 0,       \&quot;retentionSlaDomainId\&quot;: \&quot;$gold_sla_id\&quot;,       \&quot;retentionSlaDomainName\&quot;: \&quot;Gold\&quot;     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Get summary of all snapshots for a given object Get summary of all snapshots for a given object using a GET request to [/unmanaged_object/{id}/snapshot](#operation/queryUnmanagedObjectSnapshotsV1). &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/unmanaged_object/{id}/snapshot\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server return a &#x60;ListResponse&#x60; object of snapshot summaries for the given object. &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$snapshot_id\&quot;,       \&quot;date\&quot;: \&quot;&lt;timestamp&gt;\&quot;,       \&quot;snapshotType\&quot;: \&quot;PolicyBased\&quot;,       \&quot;snapshotRetentionInfo\&quot;: {         \&quot;localInfo\&quot;: {           \&quot;id\&quot;: \&quot;location_id\&quot;,           \&quot;name\&quot;: \&quot;local_cluster\&quot;,           \&quot;isSnapshotPresent\&quot;: true,           \&quot;isExpirationDateCalculated\&quot;: true,           \&quot;expirationTime\&quot;: \&quot;&lt;timestamp2&gt;\&quot;         },         \&quot;archivalInfos\&quot;: [],         \&quot;replicationInfos\&quot;: []       }     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ### Assign a retention SLA to unmanaged object. Assign a retention SLA to an unmanaged object to expire existing snapshots in a structured manner.  Send a POST request to [/unmanaged_object/assign_retention_sla](#operation/assignToRetentionSlaAsync).  **Example:** Assigning a retention SLA Domain with ID $slaId to a list of unmanaged objects - $snap1Id, $snap2Id  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;slaDomainId\&quot;: $slaId,     \&quot;managedIds\&quot;: [$snap1Id, $snap2Id]   }&#39; \\   \&quot;https://$cluster_address/api/v1/unmanaged_object/assign_retention_sla\&quot; &#x60;&#x60;&#x60;  ### Bulk tier existing snapshots to cold storage Schedules a job to tier existing snapshots of the selected objects to cold storage.  Send a POST request to [/unmanaged_object/snapshot/bulk_archive_tier](#operation/bulkTierExistingSnapshots)  **Example:** Tier existing snapshots for the objects - $object1Id, $object2Id  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;objectIds\&quot;: [$object1Id, $object2Id]   }&#39; \\   \&quot;https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier\&quot; &#x60;&#x60;&#x60;  **Example:** Tier existing snapshots for the objects - $object1Id, $object2Id only in archival location $archivalLocationId  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;objectIds\&quot;: [$object1Id, $object2Id],     \&quot;locationId\&quot;: $archivalLocationId   }&#39; \\   \&quot;https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier\&quot;  An asynchronous request is returned and can be polled to retrieve the job status.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;:\&quot;$request_id\&quot;,   \&quot;links\&quot;: [     {       \&quot;href\&quot;:\&quot;https://$cluster_address/api/v1/unmanaged_object/snapshot/bulk_archive_tier/request/$request_id\&quot;,       \&quot;rel\&quot;:\&quot;result\&quot;     },   \&quot;status\&quot;:\&quot;QUEUED\&quot; } &#x60;&#x60;&#x60;  # Data Source  A data source is an object whose snapshots can be taken.  ### Delete given snapshots for an object Delete snapshots identified by the given snapshot IDs for the specified object using a POST request to [ &#x60;/data_source/{id}/snapshot/bulk_delete&#x60; ](#operation/bulkDeleteSnapshotsForObject).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/data_source/{id}/snapshot/bulk_delete\&quot; &#x60;&#x60;&#x60;  ### Delete all snapshots for given objects Delete all snapshots for given objects using a POST request to [&#x60;/data_source/snapshot/bulk_delete&#x60;](#operation/bulkDeleteSnapshots).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/data_source/snapshot/bulk_delete\&quot; &#x60;&#x60;&#x60;  ### Get information of expired snapshots which were explicitly assigned a SLA domain To get information on snapshots that expired according to their assigned SLA domain, send a GET request to [&#x60;/data_source/{id}/expired_custom_retention_snapshots&#x60;](#operation/expiredCustomRetentionSnapshots).  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/data_source/{id}/expired_custom_retention_snapshots\&quot; &#x60;&#x60;&#x60;  # SAP HANA databases  ## Get SAP HANA database summary  Request a list of SAP HANA discovered databases by sending a GET request to [&#x60;/sap_hana/db&#x60;](#operation/querySapHanaDatabases).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/db\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;name\&quot;: \&quot;$db_name\&quot;,       \&quot;dbStatus\&quot;: \&quot;ACTIVE\&quot;,       \&quot;dbType\&quot;: \&quot;TENANT\&quot;,       \&quot;dataPathType\&quot;: \&quot;GCP\&quot;       \&quot;logBackupJobFrequencyMins\&quot;: 30       \&quot;sapHanaSystemId\&quot;: \&quot;$sap_hana_system_id\&quot;,       \&quot;sid\&quot;: \&quot;SC1\&quot;,       \&quot;instanceNumber\&quot;: \&quot;03\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;isRelic\&quot;: False,       \&quot;isArchived\&quot;: False     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Further details are acquired from [&#x60;/sap_hana/db/{id}&#x60;](#operation/getSapHanaDatabase).  &#x60;&#x60;&#x60; curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/db/$db_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;name\&quot;: \&quot;$db_name\&quot;,       \&quot;dbStatus\&quot;: \&quot;ACTIVE\&quot;,       \&quot;dbType\&quot;: \&quot;TENANT\&quot;,       \&quot;dataPathType\&quot;: \&quot;GCP\&quot;       \&quot;logBackupJobFrequencyMins\&quot;: 30       \&quot;sapHanaSystemId\&quot;: \&quot;$sap_hana_system_id\&quot;,       \&quot;sid\&quot;: \&quot;SC1\&quot;,       \&quot;instanceNumber\&quot;: \&quot;03\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;isRelic\&quot;: False,       \&quot;isArchived\&quot;: False,       \&quot;previousFailedBackupPrefixes\&quot;: [         \&quot;abcd\&quot;, \&quot;defg\&quot;       ],       \&quot;snapShotCount\&quot;: 3 } &#x60;&#x60;&#x60;  Update SLA Domain assigned to SAP HANA database by using [&#x60;/sap_hana/db/{id}&#x60;](#operation/patchSapHanaDatabase). The API returns with the summary of the SAP HANA database.  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/sap_hana/db/$db_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;name\&quot;: \&quot;$db_name\&quot;,       \&quot;dbStatus\&quot;: \&quot;ACTIVE\&quot;,       \&quot;dbType\&quot;: \&quot;TENANT\&quot;,       \&quot;dataPathType\&quot;: \&quot;GCP\&quot;       \&quot;logBackupJobFrequencyMins\&quot;: 30       \&quot;sapHanaSystemId\&quot;: \&quot;$sap_hana_system_id\&quot;,       \&quot;sid\&quot;: \&quot;SC1\&quot;,       \&quot;instanceNumber\&quot;: \&quot;03\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;isRelic\&quot;: False,       \&quot;isArchived\&quot;: False,       \&quot;previousFailedBackupPrefixes\&quot;: [         \&quot;abcd\&quot;, \&quot;defg\&quot;       ],       \&quot;snapShotCount\&quot;: 3 } &#x60;&#x60;&#x60;  ## System copy restore  System copy restore is a type of restore that is used across different SAP HANA databases.  ### Configuring system copy restore  To initiate a task to configure a system copy restore on a SAP HANA database, send a POST request to [&#x60;/sap_hana/db/{id}/configure_restore&#x60;](#operation/configureSapHanaRestore) where, {id} is the ID of the target SAP HANA database.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;source_config\&quot;: {         \&quot;snappable_id\&quot;: \&quot;$source_db_id\&quot;       }     }&#39; \\ \&quot;https://$cluster_address/api/v1/sap_hana/db/$target_db_id/configure_restore\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the configuration task and responds with a request object.  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;QUEUED\&quot;,       \&quot;error\&quot;: \&quot;None\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,       \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/db/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ] } &#x60;&#x60;&#x60;  ### Unconfiguring system copy restore  To initiate a task to reset the configuration for a system copy restore on a SAP HANA database, send a POST request to [&#x60;/sap_hana/db/{id}/unconfigure_restore&#x60;](#operation/unconfigureSapHanaRestore) where, {id} is the ID of the target SAP HANA database.  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/sap_hana/db/$target_db_id/unconfigure_restore\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server initiates the task to reset the configuration for the system copy restore and responds with a request object.  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;QUEUED\&quot;,       \&quot;error\&quot;: \&quot;None\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,       \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/db/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ] } &#x60;&#x60;&#x60;  ## SAP HANA system apis  Request a list of SAP HANA systems on a cluster by sending a GET request to [&#x60;/sap_hana/system&#x60;](#operation/querySapHanaSystems).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/system\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$system_id\&quot;,       \&quot;sid\&quot;: \&quot;SC1\&quot;,       \&quot;numDbs\&quot;: 3,       \&quot;containerType\&quot;: \&quot;SINGLE_CONTAINER\&quot;,       \&quot;instanceNumber\&quot;: \&quot;03\&quot;,       \&quot;status\&quot;: \&quot;OK\&quot;,       \&quot;username\&quot;: \&quot;$system_username\&quot;,     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Adds an entry for SAP HANA system to database. To add a SAP HANA system entry, send a POST request to [&#x60;/sap_hana/system&#x60;](#operation/addSapHanaSystem).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;username\&quot;: \&quot;$username\&quot;,     \&quot;password\&quot;: \&quot;$password\&quot;,     \&quot;sid\&quot;: \&quot;$sid\&quot;,     \&quot;instance\&quot;: \&quot;$instance\&quot;,     \&quot;hostIdList\&quot;: [       \&quot;$host_id\&quot;     ],     \&quot;dataPathSpec\&quot;: {       \&quot;$dataPathType\&quot;: \&quot;GCP\&quot;     } }&#39; \\   \&quot;https://$cluster_address/api/v1/sap_hana/system\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the ID of the added SAP HANA system and the status of the scheduled system refresh job.  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$system_id\&quot;,       \&quot;sid\&quot;: \&quot;SC1\&quot;,       \&quot;numDbs\&quot;: 3,       \&quot;containerType\&quot;: \&quot;SINGLE_CONTAINER\&quot;,       \&quot;instanceNumber\&quot;: \&quot;03\&quot;,       \&quot;status\&quot;: \&quot;OK\&quot;,       \&quot;username\&quot;: \&quot;$system_username\&quot;, } &#x60;&#x60;&#x60;  Further details are acquired by [&#x60;/sap_hana/system/{id}&#x60;](#operation/getSapHanaSystem).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/system/$db_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$system_id\&quot;,       \&quot;sid\&quot;: \&quot;SC1\&quot;,       \&quot;numDbs\&quot;: 3,       \&quot;containerType\&quot;: \&quot;SINGLE_CONTAINER\&quot;,       \&quot;instanceNumber\&quot;: \&quot;03\&quot;,       \&quot;status\&quot;: \&quot;OK\&quot;,       \&quot;username\&quot;: \&quot;$system_username\&quot;, } &#x60;&#x60;&#x60;  Update the SlA Domain assigned to the SAP HANA system by calling the [&#x60;/sap_hana/system/{id}&#x60;](#operation/patchSapHanaSystem) endpoint. The API returns the summary of the SAP HANA system.  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/sap_hana/system/$db_id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$system_id\&quot;,       \&quot;sid\&quot;: \&quot;SC1\&quot;,       \&quot;numDbs\&quot;: 3,       \&quot;containerType\&quot;: \&quot;SINGLE_CONTAINER\&quot;,       \&quot;instanceNumber\&quot;: \&quot;03\&quot;,       \&quot;status\&quot;: \&quot;OK\&quot;,       \&quot;username\&quot;: \&quot;$system_username\&quot;, } &#x60;&#x60;&#x60;  Delete a SAP HANA system by calling the [&#x60;/sap_hana/system/{id}&#x60;](#operation/deleteSapHanaSystem) endpoint. The API initiates a delete job and responds with a request object.  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/sap_hana/system/$id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;RUNNING\&quot;,       \&quot;error\&quot;: \&quot;None\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,       \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/system/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ] } &#x60;&#x60;&#x60;  Using the information provided in the request object, send a GET request to the [&#x60;/sap_hana/system/request/{id}&#x60;](#operation/getSapHanaSystemAsyncRequestStatus) endpoint to poll the task status. When the value of &#x60;status&#x60; in the task object is &#x60;SUCCEEDED&#x60;, the task finished successfully.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/system/request/$id\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;SUCCEEDED\&quot;,       \&quot;error\&quot;: \&quot;None\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,       \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/system/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ] } &#x60;&#x60;&#x60;  Refresh the metadata of a SAP HANA system object by calling the [&#x60;/sap_hana/system/{id}/refresh&#x60;](#operation/createSapHanaSystemRefresh) endpoint. The API initiates a refresh job and responds with a request object.  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/sap_hana/system/$id/refresh\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;RUNNING\&quot;,       \&quot;error\&quot;: \&quot;None\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,       \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/system/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ] } &#x60;&#x60;&#x60;  Create a full data snapshot of a SAP HANA system object by sending a POST request to the [&#x60;/sap_hana/db/{id}/snapshot&#x60;](#operation/createOnDemandSapHanaBackup) endpoint. The API initiates a data backup job and responds with a request object.  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/sap_hana/db/{id}/snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;QUEUED\&quot;,       \&quot;error\&quot;: \&quot;None\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,       \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/db/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ] } &#x60;&#x60;&#x60;  Using the information provided in the request object, send a GET request to the [&#x60;/sap_hana/db/request/{id}&#x60;](#operation/getSapHanaDbAsyncRequestStatus)) endpoint to poll the task status. When the value of &#x60;status&#x60; in the task object is &#x60;SUCCEEDED&#x60;, the task finished successfully. The response also includes the &#x60;$snapshot_id&#x60;.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/db/request/{id}\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;id\&quot;: \&quot;$request_id\&quot;,       \&quot;status\&quot;: \&quot;SUCCEEDED\&quot;,       \&quot;error\&quot;: \&quot;None\&quot;,       \&quot;progress\&quot;: 0,       \&quot;startTime\&quot;: \&quot;$start_timestamp\&quot;,       \&quot;endTime\&quot;: \&quot;$end_timestamp\&quot;,       \&quot;links\&quot;: [         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/db/snapshot/$snapshot_id\&quot;,           \&quot;rel\&quot;: \&quot;result\&quot;         },         {           \&quot;href\&quot;: \&quot;https://$cluster_address/api/v1/sap_hana/db/request/$request_id\&quot;,           \&quot;rel\&quot;: \&quot;self\&quot;         }       ] } &#x60;&#x60;&#x60;  Request a list of summary of snapshots of a SAP HANA database by sending a GET request to the [&#x60;/sap_hana/db/{id}/snapshot&#x60;](#operation/querySapHanaDbSnapshot) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/db/{id}/snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;date\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;sourceObjectType\&quot;: \&quot;SapHanaDatabase\&quot;,       \&quot;isOnDemandSnapshot\&quot;: true,       \&quot;isCustomRetentionApplied\&quot;: false       \&quot;cloudState\&quot;: 0       \&quot;replicationLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;archivalLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;slaId\&quot;: \&quot;string\&quot;,       \&quot;slaName\&quot;: \&quot;string\&quot;,       \&quot;isRetainedByRetentionLockSla\&quot;: true,       \&quot;backupId\&quot;: 949363200000,       \&quot;backupType\&quot;: \&quot;FULL\&quot;,       \&quot;sapHanaStartTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;sapHanaEndTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;rubrikSnapshotStartTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;rubrikSnapshotEndTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;backupPrefix\&quot;: \&quot;RUBRIK_949363200000_ON_DEMAND\&quot;,       \&quot;isExternalBackup\&quot;: false,       \&quot;isRubrikTriggeredOnDemandBackup\&quot;: false     }   ],   \&quot;hasMore\&quot;: false,   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Request SAP HANA database snapshot details by sending a GET request to the [&#x60;/sap_hana/db/snapshot/{id}&#x60;](#operation/getSapHanaDbSnapshot) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/db/snapshot/{id}\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {       \&quot;isCorrupt\&quot;: false,       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;date\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;sourceObjectType\&quot;: \&quot;SapHanaDatabase\&quot;,       \&quot;isOnDemandSnapshot\&quot;: true,       \&quot;isCustomRetentionApplied\&quot;: false       \&quot;cloudState\&quot;: 0       \&quot;replicationLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;archivalLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;slaId\&quot;: \&quot;string\&quot;,       \&quot;slaName\&quot;: \&quot;string\&quot;,       \&quot;isRetainedByRetentionLockSla\&quot;: true,       \&quot;backupId\&quot;: 949363200000,       \&quot;backupType\&quot;: \&quot;FULL\&quot;,       \&quot;sapHanaStartTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;sapHanaEndTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;rubrikSnapshotStartTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;rubrikSnapshotEndTime\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;backupPrefix\&quot;: \&quot;RUBRIK_949363200000_ON_DEMAND\&quot;,       \&quot;isExternalBackup\&quot;: false,       \&quot;isRubrikTriggeredOnDemandBackup\&quot;: false } &#x60;&#x60;&#x60;  Request details of recoverable ranges of a SAP HANA database by sending a GET request to the [&#x60;/sap_hana/db/{id}/recoverable_range&#x60;](#operation/getSapHanaDbRecoverableRanges) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/db/{id}/recoverable_range\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: false,   \&quot;data\&quot;: [     {       \&quot;beginTime\&quot;: \&quot;2017-02-02T18:53:12.694Z\&quot;,       \&quot;endTime\&quot;: \&quot;2017-02-02T20:53:12.694Z\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  Delete a full snapshot with a DELETE request to the  [&#x60;/sap_hana/db/snapshot/{id}&#x60;](#operation/deleteSapHanaDbSnapshot) endpoint  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/sap_hana/db/snapshot/{id}\&quot; &#x60;&#x60;&#x60; Request details of missed snapshots of a SAP HANA database by sending a GET request to the [&#x60;/sap_hana/db/{id}/missed_snapshot&#x60;](#operation/getMissedSapHanaDbSnapshots) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/sap_hana/db/{id}/missed_snapshot\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;archivalLocationType\&quot;: [         \&quot;string\&quot;       ],       \&quot;missedSnapshotTime\&quot;: \&quot;2020-08-06T14:23:13.666Z\&quot;,       \&quot;missedSnapshotTimeUnits\&quot;: [         {           \&quot;timeUnit\&quot;: \&quot;Minute\&quot;,           \&quot;frequency\&quot;: 0,           \&quot;retention\&quot;: 0,           \&quot;dayOfTime\&quot;: \&quot;Monday\&quot;         }       ]     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  # Volume Groups  Rubrik clusters can protect Windows volumes on a host as a Volume Group.  ## Getting a list of Volume Groups  To retrieve a current list of Volume Groups, send a GET request to [&#x60;/volume_group&#x60;](#operation/queryVolumeGroup).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a list of summary objects of Volume Groups.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;configuredSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;string\&quot;,       \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,       \&quot;effectiveSlaDomainId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaDomainName\&quot;: \&quot;string\&quot;,       \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,       \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;string\&quot;,       \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;string\&quot;,       \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,       \&quot;hostname\&quot;: \&quot;string\&quot;,       \&quot;hostId\&quot;: \&quot;string\&quot;,       \&quot;isRelic\&quot;: true     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ## Getting Volume Group Details  To retrieve the details of a Volume Group, send a GET request to [&#x60;/volume_group/{id}&#x60;](#operation/getVolumeGroup)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the Volume Group.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;configuredSlaDomainId\&quot;: \&quot;string\&quot;,   \&quot;configuredSlaDomainName\&quot;: \&quot;string\&quot;,   \&quot;primaryClusterId\&quot;: \&quot;string\&quot;,   \&quot;isConfiguredSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainId\&quot;: \&quot;string\&quot;,   \&quot;effectiveSlaDomainName\&quot;: \&quot;string\&quot;,   \&quot;isEffectiveSlaDomainRetentionLocked\&quot;: true,   \&quot;effectiveSlaDomainPolarisManagedId\&quot;: \&quot;string\&quot;,   \&quot;effectiveSlaSourceObjectId\&quot;: \&quot;string\&quot;,   \&quot;effectiveSlaSourceObjectName\&quot;: \&quot;string\&quot;,   \&quot;slaAssignment\&quot;: \&quot;Derived\&quot;,   \&quot;hostname\&quot;: \&quot;string\&quot;,   \&quot;hostId\&quot;: \&quot;string\&quot;,   \&quot;isRelic\&quot;: true,   \&quot;blackoutWindowStatus\&quot;: {     \&quot;isGlobalBlackoutActive\&quot;: true,     \&quot;isSnappableBlackoutActive\&quot;: true   },   \&quot;blackoutWindows\&quot;: {     \&quot;globalBlackoutWindows\&quot;: [       {         \&quot;startTime\&quot;: \&quot;string\&quot;,         \&quot;endTime\&quot;: \&quot;string\&quot;       }     ],     \&quot;snappableBlackoutWindows\&quot;: [       {         \&quot;startTime\&quot;: \&quot;string\&quot;,         \&quot;endTime\&quot;: \&quot;string\&quot;       }     ]   },   \&quot;isPaused\&quot;: true,   \&quot;volumes\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;fileSystemType\&quot;: \&quot;NTFS\&quot;,       \&quot;mountPoints\&quot;: [         \&quot;string\&quot;       ],       \&quot;size\&quot;: 0,       \&quot;naturalId\&quot;: \&quot;string\&quot;,       \&quot;volumeGroupId\&quot;: \&quot;string\&quot;,       \&quot;isCurrentlyPresentOnSystem\&quot;: true     }   ] } &#x60;&#x60;&#x60;  ## Patching Volume Group Details  To modify the details of a Volume Group, send a PATCH request to [&#x60;/volume_group/{id}&#x60;](#operation/patchVolumeGroup)  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/volume_group/{id}\&quot; &#x60;&#x60;&#x60;  ## Getting a list of all snapshots of a Volume Group  To get a list of all snapshots of a Volume Group, send a GET request to [&#x60;/volume_group/{id}/snapshot&#x60;](#operation/queryVolumeGroupSnapshot)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group/{id}/snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responses with a list of snapshots of the Volume Group.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;date\&quot;: \&quot;2019-12-16T23:21:53.446Z\&quot;,       \&quot;expirationDate\&quot;: \&quot;2019-12-16T23:21:53.446Z\&quot;,       \&quot;sourceObjectType\&quot;: \&quot;string\&quot;,       \&quot;isOnDemandSnapshot\&quot;: true,       \&quot;cloudState\&quot;: 0,       \&quot;consistencyLevel\&quot;: \&quot;string\&quot;,       \&quot;indexState\&quot;: 0,       \&quot;replicationLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;archivalLocationIds\&quot;: [         \&quot;string\&quot;       ],       \&quot;slaId\&quot;: \&quot;string\&quot;,       \&quot;slaName\&quot;: \&quot;string\&quot;,       \&quot;isRetainedByRetentionLockSla\&quot;: true,       \&quot;cloudStorageTier\&quot;: \&quot;Hot\&quot;,       \&quot;volumeGroupId\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;includedVolumes\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;fileSystemType\&quot;: \&quot;NTFS\&quot;,           \&quot;mountPoints\&quot;: [             \&quot;string\&quot;           ],           \&quot;size\&quot;: 0         }       ]     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ## Creating on-demand snapshot of a Volume Group  To create an on-demand snapshot of a Volume Group, send a POST request to [&#x60;/volume_group/{id}/snapshot&#x60;](#operation/createOnDemandVolumeGroupBackup)  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/volume_group/{id}/snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server initiates the asynchronous snapshot task and responds with a task object.  &#x60;&#x60;&#x60; {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;status\&quot;: \&quot;string\&quot;,   \&quot;progress\&quot;: 0,   \&quot;startTime\&quot;: \&quot;2019-12-16T23:21:53.450Z\&quot;,   \&quot;endTime\&quot;: \&quot;2019-12-16T23:21:53.450Z\&quot;,   \&quot;nodeId\&quot;: \&quot;string\&quot;,   \&quot;error\&quot;: {     \&quot;message\&quot;: \&quot;string\&quot;   },   \&quot;links\&quot;: [     {       \&quot;href\&quot;: \&quot;string\&quot;,       \&quot;rel\&quot;: \&quot;string\&quot;     }   ] } &#x60;&#x60;&#x60;  ## Getting the forced full snapshot configuration of a Volume Group  To retrieve the configuration used to force a full snapshot of a Volume Group, send a GET request to [&#x60;/volume_group/{id}/request/force_full_snapshot&#x60;](#operation/getVolumeGroupForceFullSpec)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group/{id}/request/force_full_snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the Volume Group force full response object. The response object contains the latest configuration, unless it was cleared by a backup job of the Volume Group or it was never set.  &#x60;&#x60;&#x60;bash {   \&quot;volumeGroupId\&quot;: \&quot;VolumeGroup:::fe9470a4-4057-4357-ac1f-ae99ff735439\&quot;,   \&quot;volumeInfos\&quot;: [     {       \&quot;volumeId\&quot;: \&quot;872bdd28-4d5d-4831-8698-59d692a822fc\&quot;,       \&quot;shouldDedupe\&quot;: false     },     {       \&quot;volumeId\&quot;: \&quot;39f61483-9cf5-11e9-80b9-00155d094203\&quot;,       \&quot;shouldDedupe\&quot;: true     }   ] } &#x60;&#x60;&#x60;  ## Requesting a forced full snapshot for a Volume Group  To request a forced full snapshot of a Volume Group, send a POST request to [&#x60;/volume_group/{id}/request/force_full_snapshot&#x60;](#operation/requestVolumeGroupForceFullSnapshot)  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/volume_group/{id}/request/force_full_snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server persists the configuration for forcing a full snapshot until the next backup job, which takes a full snapshot and clears the configuration.  &#x60;&#x60;&#x60; {   \&quot;volumeGroupId\&quot;: \&quot;VolumeGroup:::fe9470a4-4057-4357-ac1f-ae99ff735439\&quot;,   \&quot;volumeInfos\&quot;: [     {       \&quot;volumeId\&quot;: \&quot;872bdd28-4d5d-4831-8698-59d692a822fc\&quot;,       \&quot;shouldDedupe\&quot;: false     },     {       \&quot;volumeId\&quot;: \&quot;39f61483-9cf5-11e9-80b9-00155d094203\&quot;,       \&quot;shouldDedupe\&quot;: true     }   ] } &#x60;&#x60;&#x60;  ## Getting details of a Volume Group snapshot  To get the details of a Volume Group snapshot, send a GET request to [&#x60;/volume_group/snapshot/{id}&#x60;](#operation/getVolumeGroupSnapshot)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group/snapshot/{id}\&quot; &#x60;&#x60;&#x60;  The The Rubrik REST API server responds with the details of a snapshot.  &#x60;&#x60;&#x60; {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;date\&quot;: \&quot;2019-12-16T23:21:53.395Z\&quot;,   \&quot;expirationDate\&quot;: \&quot;2019-12-16T23:21:53.395Z\&quot;,   \&quot;sourceObjectType\&quot;: \&quot;string\&quot;,   \&quot;isOnDemandSnapshot\&quot;: true,   \&quot;cloudState\&quot;: 0,   \&quot;consistencyLevel\&quot;: \&quot;string\&quot;,   \&quot;indexState\&quot;: 0,   \&quot;replicationLocationIds\&quot;: [     \&quot;string\&quot;   ],   \&quot;archivalLocationIds\&quot;: [     \&quot;string\&quot;   ],   \&quot;slaId\&quot;: \&quot;string\&quot;,   \&quot;slaName\&quot;: \&quot;string\&quot;,   \&quot;isRetainedByRetentionLockSla\&quot;: true,   \&quot;cloudStorageTier\&quot;: \&quot;Hot\&quot;,   \&quot;volumeGroupId\&quot;: \&quot;string\&quot;,   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;includedVolumes\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;fileSystemType\&quot;: \&quot;NTFS\&quot;,       \&quot;mountPoints\&quot;: [         \&quot;string\&quot;       ],       \&quot;size\&quot;: 0     }   ] } &#x60;&#x60;&#x60;  ## Getting summary information of all Volume Group mounts  To get summary information of all Volume Group mounts, send a GET request to [&#x60;/volume_group/snapshot/mount&#x60;](#operation/queryVolumeGroupSnapshotMount)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group/snapshot/mount\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns summary information for all mounts.  &#x60;&#x60;&#x60; {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;sourceVolumeGroupId\&quot;: \&quot;string\&quot;,       \&quot;sourceHostId\&quot;: \&quot;string\&quot;,       \&quot;sourceHostName\&quot;: \&quot;string\&quot;,       \&quot;snapshotDate\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;snapshotSourceVersion\&quot;: \&quot;WithLayoutInfo\&quot;,       \&quot;mountedDate\&quot;: \&quot;2019-12-16T23:21:53.377Z\&quot;,       \&quot;mountedVolumes\&quot;: [         {           \&quot;id\&quot;: \&quot;string\&quot;,           \&quot;originalMountPoints\&quot;: [             \&quot;string\&quot;           ],           \&quot;size\&quot;: 0,           \&quot;fileSystemType\&quot;: \&quot;NTFS\&quot;,           \&quot;smbPath\&quot;: \&quot;string\&quot;,           \&quot;hostMountedPath\&quot;: \&quot;string\&quot;         }       ],       \&quot;targetHostId\&quot;: \&quot;string\&quot;,       \&quot;targetHostName\&quot;: \&quot;string\&quot;,       \&quot;mountRequestId\&quot;: \&quot;string\&quot;,       \&quot;unmountRequestId\&quot;: \&quot;string\&quot;,       \&quot;isReady\&quot;: true,       \&quot;restoreScriptSmbPath\&quot;: \&quot;string\&quot;     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ## Getting summary information of one mount  To retrieve summary information of one Volume Group mount, send a GET request to [&#x60;/volume_group/snapshot/mount/{id}&#x60;](#operation/getVolumeGroupSnapshotMount)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group/snapshot/mount/{id}\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns summary information of the mount.  &#x60;&#x60;&#x60; {   \&quot;id\&quot;: \&quot;string\&quot;,   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;sourceVolumeGroupId\&quot;: \&quot;string\&quot;,   \&quot;sourceHostId\&quot;: \&quot;string\&quot;,   \&quot;sourceHostName\&quot;: \&quot;string\&quot;,   \&quot;snapshotDate\&quot;: \&quot;2019-12-16T23:21:53.387Z\&quot;,   \&quot;snapshotSourceVersion\&quot;: \&quot;WithLayoutInfo\&quot;,   \&quot;mountedDate\&quot;: \&quot;2019-12-16T23:21:53.388Z\&quot;,   \&quot;mountedVolumes\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;originalMountPoints\&quot;: [         \&quot;string\&quot;       ],       \&quot;size\&quot;: 0,       \&quot;fileSystemType\&quot;: \&quot;NTFS\&quot;,       \&quot;smbPath\&quot;: \&quot;string\&quot;,       \&quot;hostMountedPath\&quot;: \&quot;string\&quot;     }   ],   \&quot;targetHostId\&quot;: \&quot;string\&quot;,   \&quot;targetHostName\&quot;: \&quot;string\&quot;,   \&quot;mountRequestId\&quot;: \&quot;string\&quot;,   \&quot;unmountRequestId\&quot;: \&quot;string\&quot;,   \&quot;isReady\&quot;: true,   \&quot;restoreScriptSmbPath\&quot;: \&quot;string\&quot; }  &#x60;&#x60;&#x60;   ## Getting summary information of the latest snapshot of a Volume Group  Send a GET request to [&#x60;/volume_group/{id}/latest_snapshot&#x60;]\\ (#operation/queryVolumeGroupLatestSnapshot) to receive a summary of the latest snapshot of a Volume Group.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/volume_group/{id}/latest_snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server returns summary information of the snapshot. &#x60;&#x60;&#x60;bash [   {     \&quot;id\&quot;: \&quot;string\&quot;,     \&quot;date\&quot;: \&quot;2019-12-16T23:21:53.446Z\&quot;,     \&quot;expirationDate\&quot;: \&quot;2019-12-16T23:21:53.446Z\&quot;,     \&quot;sourceObjectType\&quot;: \&quot;string\&quot;,     \&quot;isOnDemandSnapshot\&quot;: true,     \&quot;cloudState\&quot;: 0,     \&quot;consistencyLevel\&quot;: \&quot;string\&quot;,     \&quot;indexState\&quot;: 0,     \&quot;replicationLocationIds\&quot;: [       \&quot;string\&quot;     ],     \&quot;archivalLocationIds\&quot;: [       \&quot;string\&quot;     ],     \&quot;slaId\&quot;: \&quot;string\&quot;,     \&quot;slaName\&quot;: \&quot;string\&quot;,     \&quot;isRetainedByRetentionLockSla\&quot;: true,     \&quot;cloudStorageTier\&quot;: \&quot;Hot\&quot;,     \&quot;volumeGroupId\&quot;: \&quot;string\&quot;,     \&quot;name\&quot;: \&quot;string\&quot;,     \&quot;includedVolumes\&quot;: [       {         \&quot;id\&quot;: \&quot;string\&quot;,         \&quot;fileSystemType\&quot;: \&quot;NTFS\&quot;,         \&quot;mountPoints\&quot;: [           \&quot;string\&quot;         ],         \&quot;size\&quot;: 0       }     ]   } ] &#x60;&#x60;&#x60;  # Snapshot Stats  ### Return storage stats of a snapshot To receive the storage statistics of a snapshot, send a GET request to  [&#x60;/snapshot/{id}/storage/stats&#x60;]\\ (#operation/getSnapshotStorageStatsV1).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/snapshot/{id}/storage/stats\&quot; &#x60;&#x60;&#x60;  # Hierarchy  ### Return the list of descendant objects with SLA conflicts in bulk To bulk get the list of descendant objects with SLA conflicts, send a POST  request to  [&#x60;/hierarchy/bulk_sla_conflicts&#x60;]\\ (#operation/bulkHierarchySlaConflictsV1).  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/hierarchy/bulk_sla_conflicts\&quot; &#x60;&#x60;&#x60;  # Backup Verification  Backup verification checks the validity of a backup based on the specified snapshot ID and object ID.  ### Verify the validity of a given snapshot Verify the validity of the snapshot identified by the specified snapshot ID and object ID. [ &#x60;/backup/verify&#x60; ](#operation/verifySnapshot).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;objectId\&quot;: \&quot;$objectId\&quot;,     \&quot;snapshotIdsOpt\&quot;: \&quot;$snapshotIdsOpt\&quot;,     \&quot;locationIdOpt\&quot;: \&quot;$locationIdOpt\&quot;,     \&quot;shouldVerifyAfterOpt\&quot;: \&quot;$shouldVerifyAfterOpt\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/backup/verify/\&quot; &#x60;&#x60;&#x60;  ### Get asynchronous request details for Backup Verification Get the details of an asynchronous request for a backup verification job. [ &#x60;/backup/verify/{id}&#x60; ](#operation/getBackupVerificationAsyncRequestStatus).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/backup/verify/$id\&quot; &#x60;&#x60;&#x60;  ### Reschedule unsuccessful backup tasks [ &#x60;/backup/retry&#x60; ](#operation/createBackupRemediationAsyncTask).  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;spec\&quot;: [       {         \&quot;objectId\&quot;: \&quot;$objectId\&quot;,         \&quot;eventSeriesId\&quot;: \&quot;$eventSeriesId\&quot;       }     ],     \&quot;config\&quot;: {       \&quot;runNow\&quot;: \&quot;$runNow\&quot;     }   }&#39; \\   \&quot;https://$cluster_address/api/v1/backup/retry/\&quot; &#x60;&#x60;&#x60;  ### Get status of reschedule operation [ &#x60;/backup/retry/{id}&#x60; ](#operation/getBackupRemediationAsyncTaskStatus).  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/backup/retry/$id\&quot; &#x60;&#x60;&#x60;  # Exclusion pattern  An exclusion pattern is a regular expression pattern that enables Rubrik clusters to exclude files and folders, with names that match the regular expression pattern, from search results. Once created, the Rubrik cluster applies the exclusion pattern to the global search results and the snapshot level search results. The exclusion patterns also exclude matching files and folders from the recovery process.  A Rubrik cluster can apply the exclusion pattern on a particular [Fileset](#section/Filesets) or on all the filesets associated with a particular [Host](#section/Hosts).  The exclusion patterns are either mutable or immutable. By default, the exclusion patterns are mutable or editable upon creation.  The Rubrik REST API exposes endpoints to:  * create a single exclusion pattern * create multiple exclusion patterns, in bulk * get details of all the existing exclusion patterns * view details of a specific exclusion pattern * update an existing exclusion pattern * delete a single exclusion pattern * delete multiple exclusion patterns, in bulk  ## Adding an exclusion pattern To create a new exclusion pattern, send a POST request to [/exclusion_pattern](#operation/createExclusionPattern). The request payload must include the following attributes required to create an exclusion pattern: * &#x60;sourceId&#x60; - The ID for a fileset or a host to which the pattern will apply. * &#x60;pattern&#x60; - The regular expression pattern.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;sourceId\&quot;: \&quot;$sourceId\&quot;,     \&quot;pattern\&quot;: \&quot;$pattern\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/exclusion_pattern\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the new exclusion pattern.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;sourceId\&quot;: \&quot;$sourceId\&quot;,   \&quot;pattern\&quot;: \&quot;$pattern\&quot;,   \&quot;isMutable\&quot;: true,   \&quot;patternStatus\&quot;: \&quot;Queued\&quot;,   \&quot;isActive\&quot;: true,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot; } &#x60;&#x60;&#x60;  ## Bulk adding exclusion patterns To create exclusion patterns in bulk, send a POST request to [/exclusion_pattern/bulk](#operation/bulkCreateExclusionPattern). The request payload must be an array. The array contains one set of required attributes for every exclusion pattern that will be created. See [Adding an exclusion pattern](#adding-an-exclusion-pattern) for a list of required attributes.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     [{ \&quot;sourceId\&quot;: \&quot;$sourceId1\&quot;, \&quot;pattern\&quot;: \&quot;$pattern1\&quot;}, { \&quot;sourceId\&quot;: \&quot;$sourceId2\&quot;, \&quot;pattern\&quot;: \&quot;$pattern2\&quot;}] }&#39; \\   \&quot;https://$cluster_address/api/v1/exclusion_pattern/bulk\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the new exclusion patterns.  &#x60;&#x60;&#x60;bash {   \&quot;exclusionPatternDetails\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;sourceId\&quot;: \&quot;$sourceId1\&quot;,       \&quot;pattern\&quot;: \&quot;$pattern1\&quot;,       \&quot;isMutable\&quot;: true,       \&quot;patternStatus\&quot;: \&quot;Queued\&quot;,       \&quot;isActive\&quot;: true,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;     },     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;sourceId\&quot;: \&quot;$sourceId2\&quot;,       \&quot;pattern\&quot;: \&quot;$pattern2\&quot;,       \&quot;isMutable\&quot;: true,       \&quot;patternStatus\&quot;: \&quot;Queued\&quot;,       \&quot;isActive\&quot;: true,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;     }   ] } &#x60;&#x60;&#x60;  ## Retrieving all exclusion patterns To retrieve a summary of all the exclusion patterns that have been added to the Rubrik cluster, send a GET request to [/exclusion_pattern](#operation/queryExclusionPattern). The GET /exclusion_pattern endpoint exposes a number of parameters to filter the list of exclusion patterns returned by the endpoint. The endpoint can be used with or without any of the available parameters.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/exclusion_pattern\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a ListResponse object that contains the current list of exclusion patterns and their details.  &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;$id\&quot;,       \&quot;sourceId\&quot;: \&quot;$sourceId\&quot;,       \&quot;pattern\&quot;: \&quot;$pattern\&quot;,       \&quot;isMutable\&quot;: true,       \&quot;patternStatus\&quot;: \&quot;Applied\&quot;,       \&quot;isActive\&quot;: true,       \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot;     }   ],   \&quot;total\&quot;: 1 } &#x60;&#x60;&#x60;  ## Retrieving a specific exclusion pattern To retrieve the details of a specific exclusion pattern, send a GET request to [/exclusion_pattern/{id}](#operation/getExclusionPattern). The {id} represents the ID for the exclusion pattern and has the form - ExclusionPattern:::{uuid}.  &#x60;&#x60;&#x60;bash curl -X GET \\   \&quot;https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the specified exclusion pattern.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$exclusion_pattern_id\&quot;,   \&quot;sourceId\&quot;: \&quot;$sourceId\&quot;,   \&quot;pattern\&quot;: \&quot;$pattern\&quot;,   \&quot;isMutable\&quot;: true,   \&quot;patternStatus\&quot;: \&quot;Applied\&quot;,   \&quot;isActive\&quot;: true,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot; } &#x60;&#x60;&#x60;  ## Updating an exclusion pattern To update a specific exclusion pattern, send a POST request to [/exclusion_pattern/{id}](#operation/updateExclusionPattern). Note that the Rubrik cluster allows updating only the exclusion patterns that have &#x60;\&quot;isMutable\&quot;: true&#x60;. The {id} represents the ID for the exclusion pattern to be updated and has the form - ExclusionPattern:::{uuid}.  The attributes that can be updated are all or a subset of the following attributes:  * pattern * isActive * isMutable  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;pattern\&quot;: \&quot;$pattern\&quot;,     \&quot;isActive\&quot;: false,     \&quot;isMutable\&quot;: true }&#39; \\   \&quot;https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the details of the updated exclusion pattern.  &#x60;&#x60;&#x60;bash {   \&quot;id\&quot;: \&quot;$exclusion_pattern_id\&quot;,   \&quot;sourceId\&quot;: \&quot;$sourceId\&quot;,   \&quot;pattern\&quot;: \&quot;$pattern\&quot;,   \&quot;isMutable\&quot;: true,   \&quot;patternStatus\&quot;: \&quot;Queued\&quot;,   \&quot;isActive\&quot;: true,   \&quot;primaryClusterId\&quot;: \&quot;$primaryClusterId\&quot; } &#x60;&#x60;&#x60;  ## Deleting an exclusion pattern To delete a specific exclusion pattern, send a DELETE request to [/exclusion_pattern/{id}](#operation/deleteExclusionPattern). Note that the Rubrik cluster only allows the deletion of the exclusion patterns that have &#x60;\&quot;isMutable\&quot;: true&#x60;. The {id} represents the ID for the exclusion pattern to be deleted and has the form - ExclusionPattern:::{uuid}.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/exclusion_pattern/$exclusion_pattern_id\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a 204 HTTP response code to indicate the successful deletion of the specified exclusion pattern.  ## Bulk deleting exclusion patterns To delete exclusion patterns in bulk, send a DELETE request to [/exclusion_pattern/bulk](#operation/bulkDeleteExclusionPattern) with the IDs for the exclusion patterns to be deleted. Note that the Rubrik cluster only allows the deletion of the exclusion patterns that have &#x60;\&quot;isMutable\&quot;: true&#x60;.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   \&quot;https://$cluster_address/api/v1/exclusion_pattern/bulk?ids&#x3D;$exclusion_pattern_id1,$exclusion_pattern_id2\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a 204 HTTP response code to indicate the successful deletion of the specified exclusion patterns.  # Hyper-V VMs   ## Getting the forced full snapshot configuration of a Hyperv VM  To retrieve the configuration used to force a full snapshot of a Hyperv virtual machine, send a GET request to: [&#x60;/hyperv/vm/{id}/request/force_full_snapshot&#x60;](#operation/getHypervVirtualMachineForceFullSpec)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/hyperv/vm/{id}/request/force_full_snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with the Hyperv virtual machine force full response object. The response object contains the latest configuration, unless it was cleared by a backup job of the Hyperv virtual machine or was never set.  &#x60;&#x60;&#x60;bash {   \&quot;vmId\&quot;: \&quot;HypervVirtualMachine:::fe9470a4-4057-4357-ac1f-ae99ff735439\&quot;,   \&quot;virtualDiskInfos\&quot;: [     {       \&quot;virtualDiskId\&quot;: \&quot;872bdd28-4d5d-4831-8698-59d692a822fc\&quot;,       \&quot;shouldDedupe\&quot;: false     },     {       \&quot;virtualDiskId\&quot;: \&quot;39f61483-9cf5-11e9-80b9-00155d094203\&quot;,       \&quot;shouldDedupe\&quot;: true     }   ] } &#x60;&#x60;&#x60;  ## Requesting a forced full snapshot for a Hyperv VM  To request a forced full snapshot of a Hyperv virtual machine, send a POST request to: [&#x60;/hyperv/vm/{id}/request/force_full_snapshot&#x60;](#operation/requestHypervVirtualMachineForceFullSnapshot)  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/hyperv/vm/{id}/request/force_full_snapshot\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server persists the configuration to force a full snapshot until the next backup job, which takes a full snapshot and clears the configuration.  &#x60;&#x60;&#x60;bash {   \&quot;vmId\&quot;: \&quot;HypervVirtualMachine:::fe9470a4-4057-4357-ac1f-ae99ff735439\&quot;,   \&quot;virtualDiskInfos\&quot;: [     {       \&quot;virtualDiskId\&quot;: \&quot;872bdd28-4d5d-4831-8698-59d692a822fc\&quot;,       \&quot;shouldDedupe\&quot;: false     },     {       \&quot;virtualDiskId\&quot;: \&quot;39f61483-9cf5-11e9-80b9-00155d094203\&quot;,       \&quot;shouldDedupe\&quot;: true     }   ] } &#x60;&#x60;&#x60;  # Health monitor The Rubrik REST API endpoints for health monitor will allow users to get insight into the health of individual nodes or the entire Rubrik cluster. Currently, the endpoints support following operations: * Retrieve a list of available health monitor policies. * Enforce health monitor policies on one or more nodes of the Rubrik cluster. * Retrieve the status of the health monitor policies.  ## Get health monitor policies To retrieve a list of health monitor policies, send GET request to GET [&#39;/health_monitor/policies&#39;](#operation/getPolicies) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/health_monitor/policies\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with a list of the available health monitor policies. Following output displays the response for Sdfs policy. &#x60;&#x60;&#x60;bash [   {     \&quot;policyId\&quot;: \&quot;Sdfs\&quot;,     \&quot;policyType\&quot;: \&quot;CHECKER\&quot;,     \&quot;policyName\&quot;: \&quot;Sdfs Check\&quot;,     \&quot;description\&quot;: \&quot;Verify /sd is accessible and the SDFS service is responding\&quot;,     \&quot;script\&quot;: \&quot;$policyScript\&quot;,     \&quot;scope\&quot;: \&quot;NODE\&quot;,     \&quot;runInState\&quot;: [       \&quot;OK\&quot;,       \&quot;BAD\&quot;     ],     \&quot;isEnabled\&quot;: true,     \&quot;isHidden\&quot;: false,     \&quot;scheduleFreqInSec\&quot;: 20,     \&quot;causes\&quot;: [],     \&quot;remedies\&quot;: [],     \&quot;configParams\&quot;: [],     \&quot;notificationConfig\&quot;: {       \&quot;name\&quot;: \&quot;Sdfs Check Failure\&quot;,       \&quot;notificationType\&quot;: \&quot;DIAGNOSTIC\&quot;,       \&quot;notificationMessage\&quot;: \&quot;Sdfs check failed\&quot;,       \&quot;criticalDetails\&quot;: {         \&quot;numFailures\&quot;: 150,         \&quot;failureWindow\&quot;: 3000,         \&quot;action\&quot;: {           \&quot;actionString\&quot;: \&quot;$criticalActionScript\&quot;,           \&quot;isEnabled\&quot;: true         }       },       \&quot;warnDetails\&quot;: {         \&quot;numFailures\&quot;: 75,         \&quot;failureWindow\&quot;: 2000,         \&quot;action\&quot;: {           \&quot;actionString\&quot;: \&quot;$warnActionScript\&quot;,           \&quot;isEnabled\&quot;: true         }       }     },     \&quot;dependencies\&quot;: []   } ]  &#x60;&#x60;&#x60;  ## Run health monitor Policies To enforce health monitor policies on selected nodes or the entire Rubrik cluster send a POST Request to [&#39;/health_monitor/$runPolicy&#39;](#operation/runPolicies) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST   -d &#39;{     \&quot;policyIds\&quot;: [\&quot;policy_id1\&quot;, \&quot;policy_id2\&quot;],     \&quot;nodeIds\&quot;: [\&quot;node_id1, node_id2\&quot;]}&#39; \\   \&quot;https://$cluster_address&gt;/api/v1/health_monitor/runPolicy\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the result of running the health monitor policies. Following output displays the Sdfs policy enforcement response. &#x60;&#x60;&#x60; [   {     \&quot;nodeId\&quot;: \&quot;$node_id1\&quot;,     \&quot;checkResults\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$node_id1\&quot;,         \&quot;policyId\&quot;: \&quot;Sdfs\&quot;,         \&quot;isCheckPassed\&quot;: true       }     ]   },   {     \&quot;nodeId\&quot;: \&quot;$node_id2\&quot;,     \&quot;checkResults\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$node_id2\&quot;,         \&quot;policyId\&quot;: \&quot;Sdfs\&quot;,         \&quot;isCheckPassed\&quot;: true       }     ]   },   {     \&quot;nodeId\&quot;: \&quot;$node_id3\&quot;,     \&quot;checkResults\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$node_id3\&quot;,         \&quot;policyId\&quot;: \&quot;Sdfs\&quot;,         \&quot;isCheckPassed\&quot;: true       }     ]   }  &#x60;&#x60;&#x60; ## Health monitor policy enforcement status To retrieve the status of the policy enforcement, send a GET request to GET [&#39;/health_monitor/policyStatus&#39;](#operation/getPolicyStatus) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/health_monitor/policyStatus? node_ids&#x3D;&lt;node_id1,node_id2&gt;&amp;policy_ids&#x3D;policy_id1,policy_id2&amp;has_detailed_status&#x3D;true\&quot; &#x60;&#x60;&#x60; The Rubrik REST API server responds with the status of running the policies on the selected nodes or the entire Rubrik cluster. &#x60;&#x60;&#x60; [   {     \&quot;nodeId\&quot;: \&quot;$node_id1\&quot;,     \&quot;checkResults\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$node_id1\&quot;,         \&quot;policyId\&quot;: \&quot;Sdfs\&quot;,         \&quot;isCheckPassed\&quot;: true,         \&quot;checkOutput\&quot;: \&quot;Passed last 12 attempts.\&quot;       }     ]   },   {     \&quot;nodeId\&quot;: \&quot;$node_id2\&quot;,     \&quot;checkResults\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$node_id2\&quot;,         \&quot;policyId\&quot;: \&quot;Sdfs\&quot;,         \&quot;isCheckPassed\&quot;: true,         \&quot;checkOutput\&quot;: \&quot;Passed last 12 attempts.\&quot;       }     ]   },   {     \&quot;nodeId\&quot;: \&quot;$node_id3\&quot;,     \&quot;checkResults\&quot;: [       {         \&quot;nodeId\&quot;: \&quot;$node_id3\&quot;,         \&quot;policyId\&quot;: \&quot;Sdfs\&quot;,         \&quot;isCheckPassed\&quot;: true,         \&quot;checkOutput\&quot;: \&quot;Passed last 12 attempts.\&quot;       }     ]   } ] &#x60;&#x60;&#x60;  # Job Monitoring  ## Get summary information for protection and recovery jobs that are currently ## running, scheduled to run, or completed in the last 24 hours. To get summary information for protection and recovery jobs that are currently running, scheduled to run, or completed in the last 24 hours, send a GET request to [&#x60;/job_monitoring&#x60;](#operation/getJobMonitoringInfo) endpoint with optional query parameters. The optional query parameters are job_event_status, job_type, is_first_full, nclude_log_related_job, object_type, object_name, node_name, effective_sla_domain_id, last_update_time, after_id, sort_by, sort_order and limit. The default sort sort_by is start time with sort_order as asc.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/job_monitoring?job_event_status&#x3D;Active,Queued&amp;limit&#x3D;1&amp;sort_by&#x3D;StartTime&amp;sort_order&#x3D;asc\&quot; &#x60;&#x60;&#x60;  The list of jobs matching the filters is returned. &#x60;&#x60;&#x60;bash {   \&quot;jobMonitoringInfoList\&quot;: [     {       \&quot;jobMonitoringState\&quot;: \&quot;Active\&quot;,       \&quot;jobStatus\&quot;: \&quot;Queued\&quot;,       \&quot;jobType\&quot;: \&quot;Replication\&quot;,       \&quot;objectId\&quot;: \&quot;ObjectId,       \&quot;objectType\&quot;: \&quot;VmwareVirtualMachine\&quot;,       \&quot;objectName\&quot;: \&quot;object name\&quot;,       \&quot;locationId\&quot;: \&quot;location id\&quot;,       \&quot;locationName\&quot;: \&quot;location name\&quot;,       \&quot;slaDomainId\&quot;: \&quot;6d29f271-d706-47a5-a706-f4411ae5555a\&quot;,       \&quot;slaDomainName\&quot;: \&quot;Sla name\&quot;,       \&quot;startTime\&quot;: \&quot;2019-10-28T22:15:14.868Z\&quot;,       \&quot;isFirstFullSnapshot\&quot;: false,       \&quot;retryCount\&quot;: 0,       \&quot;eventSeriesId\&quot;: \&quot;b3a00c13-74de-4508-80cd-822d5f2960fe\&quot;,       \&quot;duration\&quot;: 1802576,       \&quot;nodeId\&quot;: \&quot;node_id\&quot;,       \&quot;warningCount\&quot;: 0,       \&quot;lastUpdatedTime\&quot;: \&quot;2019-10-28T22:15:15.088Z\&quot;     }   ],   \&quot;jobEventStatus\&quot;: [\&quot;Active\&quot;,\&quot;Queued\&quot;],   \&quot;shouldIncludeLogRelatedJob\&quot;: false,   \&quot;afterId\&quot;: \&quot;afterId\&quot;,   \&quot;hasMore\&quot;: true } &#x60;&#x60;&#x60; ## Get job summary information for protection and recovery jobs separated by ## job type that have been scheduled, are currently running, or completed in ## the past 24 hours. To get job summary information for protection and recovery jobs separated by job type that have been scheduled, are currently running, or completed in the past 24 hours,send a GET request to [&#x60;/job_monitoring/summary_by_job_type&#x60;](#operation/getMonitoringJobCountByJobType) with the required job_monitoring_state parameter.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/job_monitoring/summary_by_job_type?job_monitoring_state&#x3D;Active\&quot; &#x60;&#x60;&#x60;  The reponse is the the number of jobs for the given state separated by job_type.  &#x60;&#x60;&#x60;bash {   \&quot;jobMonitoringState\&quot;: \&quot;Active\&quot;,   \&quot;objectCounts\&quot;: {     \&quot;total\&quot;: 37,     \&quot;archival\&quot;: 10,     \&quot;backup\&quot;: 15,     \&quot;instantiate\&quot;: 0,     \&quot;recovery\&quot;: 0,     \&quot;replication\&quot;: 12,     \&quot;logBackup\&quot;: 0,     \&quot;logArchival\&quot;: 0,     \&quot;logReplication\&quot;: 0,     \&quot;logShipping\&quot;: 0   } } &#x60;&#x60;&#x60; ## Get job summary information separated by job state for all running jobs, ## jobs that have been scheduled, and jobs that are complete, for protection ## and recovery jobs in the past 24 hours. To get job summary information separated by job state for all running jobs, jobs that have been scheduled, and jobs that are complete, for protection and recovery jobs in the past 24 hours, send a GET request to [&#x60;/job_monitoring/get_summary_by_job_state&#x60;](#operation/getMonitoringJobCountByJobState) with the optional parameter job_types to get the count only for a specific state.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/job_monitoring/get_summary_by_job_state\&quot; &#x60;&#x60;&#x60;  The response is the number of jobs in each state.  &#x60;&#x60;&#x60;bash {   \&quot;jobTypes\&quot;: [     \&quot;Instantiate\&quot;,     \&quot;LogReplication\&quot;,     \&quot;Archival\&quot;,     \&quot;Replication\&quot;,     \&quot;LogBackup\&quot;,     \&quot;LogShipping\&quot;,     \&quot;Backup\&quot;,     \&quot;Recovery\&quot;,     \&quot;LogArchival\&quot;   ],   \&quot;objectCounts\&quot;: {     \&quot;total\&quot;: 52,     \&quot;failure\&quot;: 2,     \&quot;active\&quot;: 15,     \&quot;scheduled\&quot;: 10,     \&quot;success\&quot;: 25   } } &#x60;&#x60;&#x60;  ## Get a link to to download the job summary information as a CSV file, with ## the same filters as in the &#x60;GET /job_monitoring/&#x60; API. To get a link to to download the job summary information as a CSV file, send a GET request to [&#x60;/job_monitoring/csv_download_link&#x60;](#operation/getJobMonitoringInfoCsvDownloadLink)  with require parameter job_monitoring_state.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/job_monitoring/csv_download_link?job_monitoring_state&#x3D;Active\&quot; &#x60;&#x60;&#x60;  The link to the file is returned.  &#x60;&#x60;&#x60;bash {   \&quot;downloadLink\&quot;: \&quot;https://$cluster_address/report_dir/name.csv\&quot;,   \&quot;jobMonitoringState\&quot;: \&quot;Active\&quot; } &#x60;&#x60;&#x60;  ## Create an email subscription to the monitoring page with user-specified ## job states. To create an email subscription to the monitoring page, send a POST request to [&#x60;/job_monitoring/subscription&#x60;](#operation/createMonitoringSubscription)  with required parameter subscription_request.  &#x60;&#x60;&#x60;bash curl -X POST -d &#39;{   \&quot;timeAttributes\&quot;: \&quot;$timeAttributes\&quot;,   \&quot;emailAddresses\&quot;: \&quot;$emailAddresses\&quot;,   \&quot;attachments\&quot;: \&quot;$attachments\&quot;,   \&quot;jobStates\&quot;: \&quot;$jobStates\&quot; }&#39; \&quot;https://$cluster_address/api/v1/job_monitoring/subscription\&quot; &#x60;&#x60;&#x60;  The summary of the created monitoring email subscription is returned.  &#x60;&#x60;&#x60;bash {   \&quot;timeAttributes\&quot;: {\&quot;dailyScheduleHour\&quot;: 7},   \&quot;emailAddresses\&quot;: [\&quot;abcde@rubrik.com\&quot;],   \&quot;attachments\&quot;: [\&quot;Csv\&quot;],   \&quot;jobStates\&quot;: [\&quot;Active\&quot;],   \&quot;id\&quot;: \&quot;b3a00c13-74de-4508-80cd-822d5f2960fe\&quot;,   \&quot;status\&quot;: \&quot;Active\&quot;,   \&quot;owner\&quot;: {     \&quot;userId\&quot;: \&quot;6d29f271-d706-47a5-a706-f4411ae5555a\&quot;,     \&quot;userName\&quot;: \&quot;Owner\&quot;   } } &#x60;&#x60;&#x60;  ## Get all monitoring page email subscriptions. To get all email subscriptions to the monitoring page, send a GET request to [&#x60;/job_monitoring/subscription&#x60;] (#operation/getMonitoringSubscriptions)  with no parameters.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/job_monitoring/subscription\&quot; &#x60;&#x60;&#x60;  A summary of all unarchived email subscriptions for monitoring   page in a list of summaries sorted by creation time (earliest   created first).   Each summary contains information for each subscription   -- Time attributes - when to send the email   -- Email addresses - who to send the email   -- Attachments - what attachments should the email include   -- Job states - which job states to include in the email       (Failure, Scheduled, Success, Active, Canceled).   -- Id - the tring that identifies the subscription   -- Status - the status of the subscription       (Active, Suspended, or Unknown)   -- Owner - information about the owner of the subscription     -- user id - unique id used to identify the owner     -- user name - human-readable name of user        the time schedule to send the subscription  &#x60;&#x60;&#x60;bash [   {     \&quot;timeAttributes\&quot;: {\&quot;dailyScheduleHour\&quot;: 7},     \&quot;emailAddresses\&quot;: [\&quot;abcde@rubrik.com\&quot;],     \&quot;attachments\&quot;: [\&quot;Csv\&quot;],     \&quot;jobStates\&quot;: [\&quot;Active\&quot;],     \&quot;id\&quot;: \&quot;b3a00c13-74de-4508-80cd-822d5f2960fe\&quot;,     \&quot;status\&quot;: \&quot;Suspended\&quot;,     \&quot;owner\&quot;: {       \&quot;userId\&quot;: \&quot;6d29f271-d706-47a5-a706-f4411ae5555a\&quot;,       \&quot;userName\&quot;: \&quot;Owner\&quot;     }   },   {     \&quot;timeAttributes\&quot;: {\&quot;dailyScheduleHour\&quot;: 20},     \&quot;emailAddresses\&quot;: [\&quot;dummy@rubrik.com\&quot;],     \&quot;attachments\&quot;: [\&quot;Csv\&quot;],     \&quot;jobStates\&quot;: [\&quot;Failure\&quot;, \&quot;Canceled\&quot;],     \&quot;id\&quot;: \&quot;b3a00c13-74de-4508-80cd-822d5f2960fe\&quot;,     \&quot;status\&quot;: \&quot;Active\&quot;,     \&quot;owner\&quot;: {       \&quot;userId\&quot;: \&quot;499aeb71-f114-45a5-8456-91b9f6c45ddd\&quot;,       \&quot;userName\&quot;: \&quot;Owner\&quot;     }   }, ] &#x60;&#x60;&#x60;  ## Get a monitoring page email subscription. To get an email subscription to the monitoring page, send a GET request to [&#x60;/job_monitoring/subscription/{subscription_id}&#x60;] (#operation/getMonitoringSubscription)  with required parameter subscription_id.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\&quot; &#x60;&#x60;&#x60;  The summary of the created monitoring email subscription is returned.  &#x60;&#x60;&#x60;bash {   \&quot;timeAttributes\&quot;: {\&quot;dailyScheduleHour\&quot;: 7},   \&quot;emailAddresses\&quot;: [\&quot;abcde@rubrik.com\&quot;],   \&quot;attachments\&quot;: [\&quot;Csv\&quot;],   \&quot;jobStates\&quot;: [\&quot;Active\&quot;],   \&quot;id\&quot;: \&quot;b3a00c13-74de-4508-80cd-822d5f2960fe\&quot;,   \&quot;status\&quot;: \&quot;Active\&quot;,   \&quot;owner\&quot;: {     \&quot;userId\&quot;: \&quot;6d29f271-d706-47a5-a706-f4411ae5555a\&quot;,     \&quot;userName\&quot;: \&quot;Owner\&quot;   } } &#x60;&#x60;&#x60;  ## Update an existing monitoring page email subscription. To update an email subscription to the monitoring page, send a PATCH request to [&#x60;/job_monitoring/subscription/{subscription_id}&#x60;] (#operation/updateMonitoringSubscription)  with required parameter subscription_id.  &#x60;&#x60;&#x60;bash curl -X PATCH -d &#39;{   \&quot;timeAttributes\&quot;: \&quot;$timeAttributes\&quot;,   \&quot;emailAddresses\&quot;: \&quot;$emailAddresses\&quot;,   \&quot;attachments\&quot;: \&quot;$attachments\&quot;,   \&quot;jobStates\&quot;: \&quot;$jobStates\&quot;,   \&quot;id\&quot;: \&quot;$id\&quot;,   \&quot;assumeOwnership\&quot;: \&quot;$assumeOwnership\&quot; }&#39; \&quot;https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\&quot; &#x60;&#x60;&#x60;  The summary of the updated monitoring email subscription is returned.  &#x60;&#x60;&#x60;bash {   \&quot;timeAttributes\&quot;: {\&quot;dailyScheduleHour\&quot;: 7},   \&quot;emailAddresses\&quot;: [\&quot;abcde@rubrik.com\&quot;],   \&quot;attachments\&quot;: [\&quot;Csv\&quot;],   \&quot;jobStates\&quot;: [\&quot;Active\&quot;],   \&quot;id\&quot;: \&quot;b3a00c13-74de-4508-80cd-822d5f2960fe\&quot;,   \&quot;status\&quot;: \&quot;Active\&quot;,   \&quot;owner\&quot;: {     \&quot;userId\&quot;: \&quot;6d29f271-d706-47a5-a706-f4411ae5555a\&quot;,     \&quot;userName\&quot;: \&quot;Owner\&quot;   } } &#x60;&#x60;&#x60;  ## Delete an existing monitoring page email subscription. To delete an email subscription to the monitoring page, send a DELETE request to [&#x60;/job_monitoring/subscription/{subscription_id}&#x60;] (#operation/deleteMonitoringSubscription)  with required parameter subscription_id.  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/job_monitoring/subscription/$subscription_id\&quot; &#x60;&#x60;&#x60;  # Rubrik syslog management  Rubrik CDM clusters include the capability to add export rules to forward syslog information to remote servers.  # Managing the Rubrik cluster syslog settings  To view all the currently configured syslog export rules, send a GET request to the [&#x60;/syslog/export&#x60;](#operation/getSyslogExportRules) endpoint.  **Example:** Retrieving the currently configured syslog export rules for a Rubrik cluster.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/syslog/export\&quot; &#x60;&#x60;&#x60;  To add a new syslog export rule, send a POST request to the [&#x60;/syslog/export&#x60;](#operation/addSyslogExportRule) endpoint.  **Example:** Adding a new syslog export rule for a Rubrik cluster  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/syslog/export\&quot; &#x60;&#x60;&#x60;  To retrieve a syslog export rule, send a GET request with the export rule ID to the [&#x60;/syslog/export/{id}&#x60;](#operation/getSyslogExportRule) endpoint.  To modify a syslog export rule, send a PATCH request with the export rule ID to the [&#x60;/syslog/export/{id}&#x60;](#operation/updateSyslogExportRule) endpoint.  To remove a syslog export rule, send a DELETE request with the export rule ID to the [&#x60;/syslog/export/{id}&#x60;](#operation/deleteSyslogExportRule) endpoint.  **Example:** Managing individual syslog export rules for a Rubrik cluster  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/syslog/export/{id}\&quot; curl -X PATCH \&quot;https://$cluster_address/api/v1/syslog/export/{id}\&quot; curl -X DELETE \&quot;https://$cluster_address/api/v1/syslog/export/{id}\&quot; &#x60;&#x60;&#x60;  To test a syslog export rule, send a POST request with the export rule information to the [&#x60;/syslog/export/test&#x60;](#operation/testSyslogExportRule) endpoint.  **Example:** Testing a syslog export rule for a Rubrik cluster  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/syslog/export/test\&quot; &#x60;&#x60;&#x60;  # Rubrik user management  Rubrik CDM clusters include the capability to manage access to resources using local users.  # Managing the Rubrik local user account lockout  To view the current local user account lockout configuration, send a GET request to the [&#x60;/user/lockout&#x60;](#operation/getUserAccountLockoutSettings) endpoint.  **Example:** Retrieving the current local user account lockout configuration for a Rubrik cluster  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/user/lockout\&quot; &#x60;&#x60;&#x60;  To update the lockout configuration, send a PATCH request to the [&#x60;/user/lockout&#x60;](#operation/manageUserAccountLockoutSettings) endpoint.  **Example:** Updating the local user account lockout configuration for a Rubrik cluster.  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/user/lockout\&quot; &#x60;&#x60;&#x60;  ## Unlocking a locked user To unlock a locked user, send a POST request to the [&#x60;/user/{id}/unlock&#x60;](#operation/unlockUser) endpoint  **Example:** Unlocking a locked local user on CDM cluster &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/user/{id}/unlock\&quot; &#x60;&#x60;&#x60;  # Configuring users with TOTP as 2FA  To fetch the TOTP status for an account, send a GET request to the [&#x60;/user/{id}/totp/status&#x60;](#operation/getTotpStatus) endpoint.  **Example:** Retrieving TOTP status  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/user/{id}/totp/status\&quot; &#x60;&#x60;&#x60;  To configure and enable TOTP for an account, send a PUT request to the [&#x60;/user/{id}/totp/config&#x60;](#operation/setupTotp) endpoint.  **Example:** Configure TOTP &#x60;&#x60;&#x60;bash curl -X PUT \&quot;https://$cluster_address/api/v1/user/{id}/totp/config\&quot; &#x60;&#x60;&#x60;  To reset and disable TOTP for an account, send a DELETE request to the [&#x60;/user/{id}/totp/config&#x60;](#operation/resetTotp) endpoint.  **Example:** Reset TOTP &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/user/{id}/totp/config\&quot; &#x60;&#x60;&#x60;  To generate TOTP secret for an account, send a POST request to the [&#x60;/user/{id}/totp/new_secret&#x60;](#operation/generateTotpSecret) endpoint.  **Example:** Generate TOTP secret &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/user/{id}/totp/new_secret\&quot; &#x60;&#x60;&#x60;  # MFA Servers  An MFA Server is a server that Rubrik can be configured with in order to support integrations with external multi-factor authentication services.  ## Adding a server To add an MFA Server to the cluster, send a POST request to the [&#x60;/mfa/rsa/server&#x60;](#operation/createRsaMfaServer) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST -d \\   &#39;   {   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;timeout\&quot;: 0,   \&quot;baseUrl\&quot;: \&quot;string\&quot;,   \&quot;clientId\&quot;: \&quot;string\&quot;,   \&quot;assurancePolicyName\&quot;: \&quot;string\&quot;,   \&quot;ldapUsernameAttribute\&quot;: \&quot;string\&quot;,   \&quot;certificateId\&quot;: \&quot;string\&quot;,   \&quot;restApiKey\&quot;: \&quot;string\&quot;,   \&quot;restApiAccessId\&quot;: \&quot;string\&quot;   }   &#39; \\   \&quot;https://$cluster_address/api/v1/mfa/rsa/server\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;timeout\&quot;: 0,   \&quot;baseUrl\&quot;: \&quot;string\&quot;,   \&quot;clientId\&quot;: \&quot;string\&quot;,   \&quot;assurancePolicyName\&quot;: \&quot;string\&quot;,   \&quot;ldapUsernameAttribute\&quot;: \&quot;string\&quot;,   \&quot;certificateId\&quot;: \&quot;string\&quot;,   \&quot;id\&quot;: \&quot;string\&quot; } &#x60;&#x60;&#x60; ## Getting MFA Servers To get all MFA Servers configured on the cluster, leverage a GET request on the [&#x60;/mfa/rsa/server&#x60;](#operation/queryRsaMfaServers) endpoint.  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/mfa/rsa/server\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;name\&quot;: \&quot;string\&quot;,       \&quot;timeout\&quot;: 0,       \&quot;baseUrl\&quot;: \&quot;string\&quot;,       \&quot;clientId\&quot;: \&quot;string\&quot;,       \&quot;assurancePolicyName\&quot;: \&quot;string\&quot;,       \&quot;ldapUsernameAttribute\&quot;: \&quot;string\&quot;,       \&quot;certificateId\&quot;: \&quot;string\&quot;,       \&quot;id\&quot;: \&quot;string\&quot;     }   ],   \&quot;total\&quot;: 0 } &#x60;&#x60;&#x60;  ## Deleting MFA Server Integrations In order to delete a specific MFA Server integration, make a DELETE call to the [&#x60;/mfa/rsa/server/{id}&#x60;](#operation/deleteRsaMfaServer) endpoint.  &#x60;&#x60;&#x60;bash curl -X DELETE \\   -d &#39;{     \&quot;id\&quot;: \&quot;$server_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/mfa/rsa/server/{id}\&quot; &#x60;&#x60;&#x60;  ## Getting an MFA Server In order to retrieve a specific MFA server integration, make a GET call to the [&#x60;/mfa/rsa/server/{id}&#x60;](#operation/getRsaMfaServer) endpoint.  &#x60;&#x60;&#x60;bash curl -X POST \\   -d &#39;{     \&quot;id\&quot;: \&quot;server_id\&quot; }&#39; \\   \&quot;https://$cluster_address/api/v1/mfa/rsa/server/{id}\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;timeout\&quot;: 0,   \&quot;baseUrl\&quot;: \&quot;string\&quot;,   \&quot;clientId\&quot;: \&quot;string\&quot;,   \&quot;assurancePolicyName\&quot;: \&quot;string\&quot;,   \&quot;ldapUsernameAttribute\&quot;: \&quot;string\&quot;,   \&quot;certificateId\&quot;: \&quot;string\&quot;,   \&quot;id\&quot;: \&quot;string\&quot; } &#x60;&#x60;&#x60;  ## Updating an MFA Server In order to update a specific MFA Server integration, make a PATCH call to the [&#x60;/mfa/rsa/server/{id}&#x60;](#operation/updateRsaMfaServer) endpoint.  &#x60;&#x60;&#x60;bash curl -X PATCH \\   -d &#39;{ {   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;timeout\&quot;: 0,   \&quot;baseUrl\&quot;: \&quot;string\&quot;,   \&quot;restApiKey\&quot;: \&quot;string\&quot;,   \&quot;clientId\&quot;: \&quot;string\&quot;,   \&quot;assurancePolicyName\&quot;: \&quot;string\&quot;,   \&quot;restApiAccessId\&quot;: \&quot;string\&quot;,   \&quot;ldapUsernameAttribute\&quot;: \&quot;string\&quot;,   \&quot;certificateId\&quot;: \&quot;string\&quot; }     &#39; \\   \&quot;https://$cluster_address/api/v1/mfa/rsa/server/{id}\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;name\&quot;: \&quot;string\&quot;,   \&quot;timeout\&quot;: 0,   \&quot;baseUrl\&quot;: \&quot;string\&quot;,   \&quot;clientId\&quot;: \&quot;string\&quot;,   \&quot;assurancePolicyName\&quot;: \&quot;string\&quot;,   \&quot;ldapUsernameAttribute\&quot;: \&quot;string\&quot;,   \&quot;certificateId\&quot;: \&quot;string\&quot;,   \&quot;id\&quot;: \&quot;string\&quot; } &#x60;&#x60;&#x60;  # Legal  ## Copyright  Rubrik REST API - Copyright © 2017-2021 Rubrik Inc. All rights reserved.  This documentation may be used free of charge. Selling without prior written consent is prohibited. Obtain permission before redistributing. In all cases, this copyright notice and disclaimer must remain intact.   ## Disclaimer  THE CONTENTS OF THIS DOCUMENTATION ARE PROVIDED \&quot;AS IS,\&quot; AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENTATION ARE SUITABLE FOR ANY PURPOSE; THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENTATION OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.  ## Trademarks  Rubrik, the Rubrik logo, Rubrik Envision, and Rubrik Edge are trademarks or registered trademarks of Rubrik, Inc. in the U.S. and/or other countries. All other trademarks are the property of their respective owners.  # Report Config  ## Update the config parameters related to Reports Send a PATCH request to [&#x60;/report/config&#x60;](#operation/setReportConfig) This request updates the configuration parameters related to the reporting framework. &#x60;cleanupReportJobInstanceForLogJobs&#x60; specifies an interval in days. Log jobs in report job instances are retained for the specified interval.  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/report/config\&quot; &#x60;&#x60;&#x60;  ## Get summary information for backup compliance based on each 24 hour time period Send a GET request to [&#x60;/report/compliance_summary&#x60;](#operation/getComplianceSummaryV1)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/report/compliance_summary\&quot; &#x60;&#x60;&#x60;  ## Get summary information for backup compliance based on snapshot range Send a GET request to  [&#x60;/report/compliance_summary_sla&#x60;](#operation/getComplianceSummarySLAV1)  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/report/compliance_summary_sla\&quot; &#x60;&#x60;&#x60;  #Database log backup report  #Get the database log report summary  To get the database log report summary, send a GET request to the [&#x60;/database/log_report&#x60;](#operation/queryLogReport) end point  **Example:** Retrieving the database log report summary  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/database/log_report\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;total\&quot;: 1,   \&quot;data\&quot;: [     {       \&quot;effectiveSlaDomainName\&quot;: \&quot;sla_name\&quot;,       \&quot;id\&quot;: \&quot;$db_id\&quot;,       \&quot;name\&quot;: \&quot;$db_name\&quot;,       \&quot;location\&quot;: \&quot;$location_name\&quot;,       \&quot;databaseType\&quot;: \&quot;$db_type\&quot;,       \&quot;primaryClusterId\&quot;: \&quot;$cluster_id\&quot;,       \&quot;logBackupFrequency\&quot;: 3600,       \&quot;lastSnapshotTime\&quot;: \&quot;2020-11-10T22:21:43.000Z\&quot;,       \&quot;effectiveSlaDomainId\&quot;: \&quot;$sla_id\&quot;     }   ],   \&quot;hasMore\&quot;: false } &#x60;&#x60;&#x60;  #Get the database log report properties  To get the database log report properties, send a GET request to the [&#x60;/database/log_report/defaults&#x60;](#operation/queryReportProperties) end point   **Example:** Retrieving the database log report properties  &#x60;&#x60;&#x60;bash curl -X GET \&quot;https://$cluster_address/api/v1/database/log_report/defaults\&quot; &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;bash {   \&quot;logDelayNotificationFrequencyInMin\&quot;: 720,   \&quot;logDelayThresholdInMin\&quot;: 720,   \&quot;enableDelayNotification\&quot;: false } &#x60;&#x60;&#x60;  #Update the database log report properties  To update the database log report properties, send a PATCH request to the [&#x60;/database/log_report/defaults&#x60;](#operation/updateReportProperties) end point   **Example:** Update the database log report properties  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/database/log_report/defaults\&quot; -d\\ &#39;{     \&quot;logDelayNotificationFrequencyInMin\&quot;: 360,     \&quot;logDelayThresholdInMin\&quot;: 120,     \&quot;enableDelayNotification\&quot;: true  }&#39; &#x60;&#x60;&#x60;  # Organization  ## Create a list of Rubrik Envoy objects To create a list of Rubrik Envoy objects, send a POST request to the [&#x60;/organization/{id}/envoy/bulk&#x60;](#operation/bulkCreateEnvoys) endpoint. The request takes an ID for the Organization and the information about the Rubrik Envoy objects.  &#x60;&#x60;&#x60;bash curl -X POST \&quot;https://$cluster_address/api/v1/organization/{id}/envoy/bulk\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object. &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;ipAddress\&quot;: \&quot;string\&quot;,       \&quot;port\&quot;: 1234,       \&quot;organizationId\&quot;: \&quot;string\&quot;,       \&quot;status\&quot;: \&quot;Connected\&quot;,     },   ] } &#x60;&#x60;&#x60;  ## Remove a list of Rubrik Envoy objects To remove a list of Rubrik Envoy objects, send a DELETE request to the [&#x60;/organization/{id}/envoy/bulk&#x60;](#operation/bulkDeleteEnvoys) endpoint. The request takes an ID for the Organization and a list of IDs for Rubrik Envoy objects.  &#x60;&#x60;&#x60;bash curl -X DELETE \&quot;https://$cluster_address/api/v1/organization/{id}/envoy/bulk\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.  ## Update a list of Rubrik Envoy objects To update a list of Rubrik Envoy objects, send a PATCH request to the [&#x60;/organization/{id}/envoy/bulk&#x60;](#operation/bulkUpdateEnvoys) endpoint. The request takes an ID for the Organization and the information about the Rubrik Envoy objects.  &#x60;&#x60;&#x60;bash curl -X PATCH \&quot;https://$cluster_address/api/v1/organization/{id}/envoy/bulk\&quot; &#x60;&#x60;&#x60;  The Rubrik REST API server responds with a &#x60;ListResponse&#x60; object. &#x60;&#x60;&#x60;bash {   \&quot;hasMore\&quot;: true,   \&quot;data\&quot;: [     {       \&quot;id\&quot;: \&quot;string\&quot;,       \&quot;ipAddress\&quot;: \&quot;string\&quot;,       \&quot;port\&quot;: 1234,       \&quot;organizationId\&quot;: \&quot;string\&quot;,       \&quot;status\&quot;: \&quot;Connected\&quot;,     },   ] } &#x60;&#x60;&#x60; .<br>
* The <code>index</code> module provides access to constructors for all the classes which comprise the public API.
* <p>
* An AMD (recommended!) or CommonJS application will generally do something equivalent to the following:
* <pre>
* var RubrikRestApi = require('index'); // See note below*.
* var xxxSvc = new RubrikRestApi.XxxApi(); // Allocate the API class we're going to use.
* var yyyModel = new RubrikRestApi.Yyy(); // Construct a model instance.
* yyyModel.someProperty = 'someValue';
* ...
* var zzz = xxxSvc.doSomething(yyyModel); // Invoke the service.
* ...
* </pre>
* <em>*NOTE: For a top-level AMD script, use require(['index'], function(){...})
* and put the application logic within the callback function.</em>
* </p>
* <p>
* A non-AMD browser application (discouraged) might do something like this:
* <pre>
* var xxxSvc = new RubrikRestApi.XxxApi(); // Allocate the API class we're going to use.
* var yyy = new RubrikRestApi.Yyy(); // Construct a model instance.
* yyyModel.someProperty = 'someValue';
* ...
* var zzz = xxxSvc.doSomething(yyyModel); // Invoke the service.
* ...
* </pre>
* </p>
* @module index
* @version v1
*/
export {
    /**
     * The ApiClient constructor.
     * @property {module:ApiClient}
     */
    ApiClient,

    /**
     * The ActionDetails model constructor.
     * @property {module:model/ActionDetails}
     */
    ActionDetails,

    /**
     * The ActivityLogSummaryV1 model constructor.
     * @property {module:model/ActivityLogSummaryV1}
     */
    ActivityLogSummaryV1,

    /**
     * The ActivityLogSummaryV1ListResponse model constructor.
     * @property {module:model/ActivityLogSummaryV1ListResponse}
     */
    ActivityLogSummaryV1ListResponse,

    /**
     * The AdaptiveThrottlingSettingsVmwareFields model constructor.
     * @property {module:model/AdaptiveThrottlingSettingsVmwareFields}
     */
    AdaptiveThrottlingSettingsVmwareFields,

    /**
     * The AdvancedLdapConfiguration model constructor.
     * @property {module:model/AdvancedLdapConfiguration}
     */
    AdvancedLdapConfiguration,

    /**
     * The AdvancedUiConfigAttributes model constructor.
     * @property {module:model/AdvancedUiConfigAttributes}
     */
    AdvancedUiConfigAttributes,

    /**
     * The AgentSecondaryCertificateInfo model constructor.
     * @property {module:model/AgentSecondaryCertificateInfo}
     */
    AgentSecondaryCertificateInfo,

    /**
     * The AgentSecondaryCertificateInfoListResponse model constructor.
     * @property {module:model/AgentSecondaryCertificateInfoListResponse}
     */
    AgentSecondaryCertificateInfoListResponse,

    /**
     * The AgentStatus model constructor.
     * @property {module:model/AgentStatus}
     */
    AgentStatus,

    /**
     * The AppSearchResponse model constructor.
     * @property {module:model/AppSearchResponse}
     */
    AppSearchResponse,

    /**
     * The AppSearchResponseListResponse model constructor.
     * @property {module:model/AppSearchResponseListResponse}
     */
    AppSearchResponseListResponse,

    /**
     * The ApplyLegalHoldDefinition model constructor.
     * @property {module:model/ApplyLegalHoldDefinition}
     */
    ApplyLegalHoldDefinition,

    /**
     * The ArchivalSpec model constructor.
     * @property {module:model/ArchivalSpec}
     */
    ArchivalSpec,

    /**
     * The ArchivalSpecV2 model constructor.
     * @property {module:model/ArchivalSpecV2}
     */
    ArchivalSpecV2,

    /**
     * The ArchivalTieringSpec model constructor.
     * @property {module:model/ArchivalTieringSpec}
     */
    ArchivalTieringSpec,

    /**
     * The AsyncRequestStatus model constructor.
     * @property {module:model/AsyncRequestStatus}
     */
    AsyncRequestStatus,

    /**
     * The AuthDomainType model constructor.
     * @property {module:model/AuthDomainType}
     */
    AuthDomainType,

    /**
     * The AvailableVersionInfo model constructor.
     * @property {module:model/AvailableVersionInfo}
     */
    AvailableVersionInfo,

    /**
     * The AwsEc2InstanceSlaObjectCount model constructor.
     * @property {module:model/AwsEc2InstanceSlaObjectCount}
     */
    AwsEc2InstanceSlaObjectCount,

    /**
     * The BackupTaskDiagnosticInfo model constructor.
     * @property {module:model/BackupTaskDiagnosticInfo}
     */
    BackupTaskDiagnosticInfo,

    /**
     * The BackupWindow model constructor.
     * @property {module:model/BackupWindow}
     */
    BackupWindow,

    /**
     * The BaseGuestCredential model constructor.
     * @property {module:model/BaseGuestCredential}
     */
    BaseGuestCredential,

    /**
     * The BaseGuestCredentialDetail model constructor.
     * @property {module:model/BaseGuestCredentialDetail}
     */
    BaseGuestCredentialDetail,

    /**
     * The BaseOnDemandSnapshotConfig model constructor.
     * @property {module:model/BaseOnDemandSnapshotConfig}
     */
    BaseOnDemandSnapshotConfig,

    /**
     * The BaseSnapshotDetail model constructor.
     * @property {module:model/BaseSnapshotDetail}
     */
    BaseSnapshotDetail,

    /**
     * The BaseSnapshotSummary model constructor.
     * @property {module:model/BaseSnapshotSummary}
     */
    BaseSnapshotSummary,

    /**
     * The BatchAsyncRequest model constructor.
     * @property {module:model/BatchAsyncRequest}
     */
    BatchAsyncRequest,

    /**
     * The BatchAsyncRequestStatus model constructor.
     * @property {module:model/BatchAsyncRequestStatus}
     */
    BatchAsyncRequestStatus,

    /**
     * The BatchMountSnapshotJobConfig model constructor.
     * @property {module:model/BatchMountSnapshotJobConfig}
     */
    BatchMountSnapshotJobConfig,

    /**
     * The BatchVmSnapshotSummaries model constructor.
     * @property {module:model/BatchVmSnapshotSummaries}
     */
    BatchVmSnapshotSummaries,

    /**
     * The BatchVmwareCdpLiveInfo model constructor.
     * @property {module:model/BatchVmwareCdpLiveInfo}
     */
    BatchVmwareCdpLiveInfo,

    /**
     * The BatchVmwareCdpStateInfo model constructor.
     * @property {module:model/BatchVmwareCdpStateInfo}
     */
    BatchVmwareCdpStateInfo,

    /**
     * The BatchVmwareVmMissedRecoverableRanges model constructor.
     * @property {module:model/BatchVmwareVmMissedRecoverableRanges}
     */
    BatchVmwareVmMissedRecoverableRanges,

    /**
     * The BatchVmwareVmMissedRecoverableRangesRequest model constructor.
     * @property {module:model/BatchVmwareVmMissedRecoverableRangesRequest}
     */
    BatchVmwareVmMissedRecoverableRangesRequest,

    /**
     * The BatchVmwareVmRecoverableRanges model constructor.
     * @property {module:model/BatchVmwareVmRecoverableRanges}
     */
    BatchVmwareVmRecoverableRanges,

    /**
     * The BatchVmwareVmRecoverableRangesRequest model constructor.
     * @property {module:model/BatchVmwareVmRecoverableRangesRequest}
     */
    BatchVmwareVmRecoverableRangesRequest,

    /**
     * The BlackoutWindow model constructor.
     * @property {module:model/BlackoutWindow}
     */
    BlackoutWindow,

    /**
     * The BlackoutWindowResponseInfo model constructor.
     * @property {module:model/BlackoutWindowResponseInfo}
     */
    BlackoutWindowResponseInfo,

    /**
     * The BlackoutWindowStatus model constructor.
     * @property {module:model/BlackoutWindowStatus}
     */
    BlackoutWindowStatus,

    /**
     * The BlackoutWindows model constructor.
     * @property {module:model/BlackoutWindows}
     */
    BlackoutWindows,

    /**
     * The BooleanResponse model constructor.
     * @property {module:model/BooleanResponse}
     */
    BooleanResponse,

    /**
     * The BootstrappableNodeInfoV1 model constructor.
     * @property {module:model/BootstrappableNodeInfoV1}
     */
    BootstrappableNodeInfoV1,

    /**
     * The BootstrappableNodeIpv4Info model constructor.
     * @property {module:model/BootstrappableNodeIpv4Info}
     */
    BootstrappableNodeIpv4Info,

    /**
     * The BrowseResponse model constructor.
     * @property {module:model/BrowseResponse}
     */
    BrowseResponse,

    /**
     * The BrowseResponseListResponse model constructor.
     * @property {module:model/BrowseResponseListResponse}
     */
    BrowseResponseListResponse,

    /**
     * The BulkDeleteObjectSnapshotsConfig model constructor.
     * @property {module:model/BulkDeleteObjectSnapshotsConfig}
     */
    BulkDeleteObjectSnapshotsConfig,

    /**
     * The BulkDeleteSnapshotsConfig model constructor.
     * @property {module:model/BulkDeleteSnapshotsConfig}
     */
    BulkDeleteSnapshotsConfig,

    /**
     * The BulkOnDemandSnapshotJobConfig model constructor.
     * @property {module:model/BulkOnDemandSnapshotJobConfig}
     */
    BulkOnDemandSnapshotJobConfig,

    /**
     * The BulkOracleDbDetails model constructor.
     * @property {module:model/BulkOracleDbDetails}
     */
    BulkOracleDbDetails,

    /**
     * The BulkOracleHostDetails model constructor.
     * @property {module:model/BulkOracleHostDetails}
     */
    BulkOracleHostDetails,

    /**
     * The BulkOracleRacDetails model constructor.
     * @property {module:model/BulkOracleRacDetails}
     */
    BulkOracleRacDetails,

    /**
     * The BulkShareAddResponse model constructor.
     * @property {module:model/BulkShareAddResponse}
     */
    BulkShareAddResponse,

    /**
     * The BulkSlaConflictsSummary model constructor.
     * @property {module:model/BulkSlaConflictsSummary}
     */
    BulkSlaConflictsSummary,

    /**
     * The BulkTierSnapshotsConfig model constructor.
     * @property {module:model/BulkTierSnapshotsConfig}
     */
    BulkTierSnapshotsConfig,

    /**
     * The CdpLocalStatus model constructor.
     * @property {module:model/CdpLocalStatus}
     */
    CdpLocalStatus,

    /**
     * The CdpReplicationStatus model constructor.
     * @property {module:model/CdpReplicationStatus}
     */
    CdpReplicationStatus,

    /**
     * The CdpState model constructor.
     * @property {module:model/CdpState}
     */
    CdpState,

    /**
     * The CertificateImportRequest model constructor.
     * @property {module:model/CertificateImportRequest}
     */
    CertificateImportRequest,

    /**
     * The CertificateListSortAttributes model constructor.
     * @property {module:model/CertificateListSortAttributes}
     */
    CertificateListSortAttributes,

    /**
     * The CertificatePatchRequest model constructor.
     * @property {module:model/CertificatePatchRequest}
     */
    CertificatePatchRequest,

    /**
     * The CertificateSummary model constructor.
     * @property {module:model/CertificateSummary}
     */
    CertificateSummary,

    /**
     * The CertificateSummaryListResponse model constructor.
     * @property {module:model/CertificateSummaryListResponse}
     */
    CertificateSummaryListResponse,

    /**
     * The CloudInstantiationSpec model constructor.
     * @property {module:model/CloudInstantiationSpec}
     */
    CloudInstantiationSpec,

    /**
     * The CloudOutComputeForecastSummaries model constructor.
     * @property {module:model/CloudOutComputeForecastSummaries}
     */
    CloudOutComputeForecastSummaries,

    /**
     * The CloudOutComputeForecastSummary model constructor.
     * @property {module:model/CloudOutComputeForecastSummary}
     */
    CloudOutComputeForecastSummary,

    /**
     * The CloudOutForecastRequest model constructor.
     * @property {module:model/CloudOutForecastRequest}
     */
    CloudOutForecastRequest,

    /**
     * The CloudOutForecastSlaParameters model constructor.
     * @property {module:model/CloudOutForecastSlaParameters}
     */
    CloudOutForecastSlaParameters,

    /**
     * The CloudOutForecastSummary model constructor.
     * @property {module:model/CloudOutForecastSummary}
     */
    CloudOutForecastSummary,

    /**
     * The CloudOutStorageForecastSummaries model constructor.
     * @property {module:model/CloudOutStorageForecastSummaries}
     */
    CloudOutStorageForecastSummaries,

    /**
     * The CloudOutStorageForecastSummary model constructor.
     * @property {module:model/CloudOutStorageForecastSummary}
     */
    CloudOutStorageForecastSummary,

    /**
     * The CloudStorageColdTier model constructor.
     * @property {module:model/CloudStorageColdTier}
     */
    CloudStorageColdTier,

    /**
     * The CloudStorageRehydrationSpeed model constructor.
     * @property {module:model/CloudStorageRehydrationSpeed}
     */
    CloudStorageRehydrationSpeed,

    /**
     * The ClusterApiVersion model constructor.
     * @property {module:model/ClusterApiVersion}
     */
    ClusterApiVersion,

    /**
     * The ClusterCertificate model constructor.
     * @property {module:model/ClusterCertificate}
     */
    ClusterCertificate,

    /**
     * The ClusterGeolocation model constructor.
     * @property {module:model/ClusterGeolocation}
     */
    ClusterGeolocation,

    /**
     * The ClusterHostGroupInfo model constructor.
     * @property {module:model/ClusterHostGroupInfo}
     */
    ClusterHostGroupInfo,

    /**
     * The ClusterInfo model constructor.
     * @property {module:model/ClusterInfo}
     */
    ClusterInfo,

    /**
     * The ClusterTimezone model constructor.
     * @property {module:model/ClusterTimezone}
     */
    ClusterTimezone,

    /**
     * The ClusterUpdate model constructor.
     * @property {module:model/ClusterUpdate}
     */
    ClusterUpdate,

    /**
     * The ClusterVersion model constructor.
     * @property {module:model/ClusterVersion}
     */
    ClusterVersion,

    /**
     * The ClusterVisibilityConfig model constructor.
     * @property {module:model/ClusterVisibilityConfig}
     */
    ClusterVisibilityConfig,

    /**
     * The ClusterVisibilityInfo model constructor.
     * @property {module:model/ClusterVisibilityInfo}
     */
    ClusterVisibilityInfo,

    /**
     * The CommunityUserCredentials model constructor.
     * @property {module:model/CommunityUserCredentials}
     */
    CommunityUserCredentials,

    /**
     * The ComplianceRangeFilter model constructor.
     * @property {module:model/ComplianceRangeFilter}
     */
    ComplianceRangeFilter,

    /**
     * The ComplianceSummarySLAV1 model constructor.
     * @property {module:model/ComplianceSummarySLAV1}
     */
    ComplianceSummarySLAV1,

    /**
     * The ComplianceSummaryStatus model constructor.
     * @property {module:model/ComplianceSummaryStatus}
     */
    ComplianceSummaryStatus,

    /**
     * The ComplianceSummaryV1 model constructor.
     * @property {module:model/ComplianceSummaryV1}
     */
    ComplianceSummaryV1,

    /**
     * The ComputeClusterDetail model constructor.
     * @property {module:model/ComputeClusterDetail}
     */
    ComputeClusterDetail,

    /**
     * The ComputeClusterSummary model constructor.
     * @property {module:model/ComputeClusterSummary}
     */
    ComputeClusterSummary,

    /**
     * The ComputeClusterSummaryListResponse model constructor.
     * @property {module:model/ComputeClusterSummaryListResponse}
     */
    ComputeClusterSummaryListResponse,

    /**
     * The ComputeClusterUpdate model constructor.
     * @property {module:model/ComputeClusterUpdate}
     */
    ComputeClusterUpdate,

    /**
     * The ConfigChangeSource model constructor.
     * @property {module:model/ConfigChangeSource}
     */
    ConfigChangeSource,

    /**
     * The ConfigParam model constructor.
     * @property {module:model/ConfigParam}
     */
    ConfigParam,

    /**
     * The ConfigurationSummary model constructor.
     * @property {module:model/ConfigurationSummary}
     */
    ConfigurationSummary,

    /**
     * The ConfigurationSummaryListResponse model constructor.
     * @property {module:model/ConfigurationSummaryListResponse}
     */
    ConfigurationSummaryListResponse,

    /**
     * The ConfigurationUpdateSummary model constructor.
     * @property {module:model/ConfigurationUpdateSummary}
     */
    ConfigurationUpdateSummary,

    /**
     * The ConfigurationUpdateSummaryListResponse model constructor.
     * @property {module:model/ConfigurationUpdateSummaryListResponse}
     */
    ConfigurationUpdateSummaryListResponse,

    /**
     * The ConfiguredSlaType model constructor.
     * @property {module:model/ConfiguredSlaType}
     */
    ConfiguredSlaType,

    /**
     * The CorsConfiguration model constructor.
     * @property {module:model/CorsConfiguration}
     */
    CorsConfiguration,

    /**
     * The CorsConfigurationPatch model constructor.
     * @property {module:model/CorsConfigurationPatch}
     */
    CorsConfigurationPatch,

    /**
     * The CountResponse model constructor.
     * @property {module:model/CountResponse}
     */
    CountResponse,

    /**
     * The CreateNewVappParams model constructor.
     * @property {module:model/CreateNewVappParams}
     */
    CreateNewVappParams,

    /**
     * The CreateVappNetworkParams model constructor.
     * @property {module:model/CreateVappNetworkParams}
     */
    CreateVappNetworkParams,

    /**
     * The CsrRequest model constructor.
     * @property {module:model/CsrRequest}
     */
    CsrRequest,

    /**
     * The CsrSummary model constructor.
     * @property {module:model/CsrSummary}
     */
    CsrSummary,

    /**
     * The CsrSummaryListResponse model constructor.
     * @property {module:model/CsrSummaryListResponse}
     */
    CsrSummaryListResponse,

    /**
     * The DataCenterSummary model constructor.
     * @property {module:model/DataCenterSummary}
     */
    DataCenterSummary,

    /**
     * The DataGuardGroupMember model constructor.
     * @property {module:model/DataGuardGroupMember}
     */
    DataGuardGroupMember,

    /**
     * The DataGuardType model constructor.
     * @property {module:model/DataGuardType}
     */
    DataGuardType,

    /**
     * The DataStoreSummary model constructor.
     * @property {module:model/DataStoreSummary}
     */
    DataStoreSummary,

    /**
     * The DatabaseType model constructor.
     * @property {module:model/DatabaseType}
     */
    DatabaseType,

    /**
     * The DbLogReportProperties model constructor.
     * @property {module:model/DbLogReportProperties}
     */
    DbLogReportProperties,

    /**
     * The DbLogReportPropertiesUpdate model constructor.
     * @property {module:model/DbLogReportPropertiesUpdate}
     */
    DbLogReportPropertiesUpdate,

    /**
     * The DbLogReportSummary model constructor.
     * @property {module:model/DbLogReportSummary}
     */
    DbLogReportSummary,

    /**
     * The DbLogReportSummaryListResponse model constructor.
     * @property {module:model/DbLogReportSummaryListResponse}
     */
    DbLogReportSummaryListResponse,

    /**
     * The DbLogReportSummaryListSortAttribute model constructor.
     * @property {module:model/DbLogReportSummaryListSortAttribute}
     */
    DbLogReportSummaryListSortAttribute,

    /**
     * The DiagnosticTaskStatus model constructor.
     * @property {module:model/DiagnosticTaskStatus}
     */
    DiagnosticTaskStatus,

    /**
     * The DisablePerLocationPause model constructor.
     * @property {module:model/DisablePerLocationPause}
     */
    DisablePerLocationPause,

    /**
     * The DiscoveredNasShare model constructor.
     * @property {module:model/DiscoveredNasShare}
     */
    DiscoveredNasShare,

    /**
     * The DissolveLegalHoldDefinition model constructor.
     * @property {module:model/DissolveLegalHoldDefinition}
     */
    DissolveLegalHoldDefinition,

    /**
     * The DissolveLegalHoldResponse model constructor.
     * @property {module:model/DissolveLegalHoldResponse}
     */
    DissolveLegalHoldResponse,

    /**
     * The DownloadFileJobConfig model constructor.
     * @property {module:model/DownloadFileJobConfig}
     */
    DownloadFileJobConfig,

    /**
     * The DownloadJobInfo model constructor.
     * @property {module:model/DownloadJobInfo}
     */
    DownloadJobInfo,

    /**
     * The DownloadMssqlBackupFilesByIdJobConfig model constructor.
     * @property {module:model/DownloadMssqlBackupFilesByIdJobConfig}
     */
    DownloadMssqlBackupFilesByIdJobConfig,

    /**
     * The DownloadedSnapshotSlaAssignmentInfo model constructor.
     * @property {module:model/DownloadedSnapshotSlaAssignmentInfo}
     */
    DownloadedSnapshotSlaAssignmentInfo,

    /**
     * The EffectiveSlaHolder model constructor.
     * @property {module:model/EffectiveSlaHolder}
     */
    EffectiveSlaHolder,

    /**
     * The EnablePerLocationPause model constructor.
     * @property {module:model/EnablePerLocationPause}
     */
    EnablePerLocationPause,

    /**
     * The EncryptionStatus model constructor.
     * @property {module:model/EncryptionStatus}
     */
    EncryptionStatus,

    /**
     * The EnvoyBulkUpdate model constructor.
     * @property {module:model/EnvoyBulkUpdate}
     */
    EnvoyBulkUpdate,

    /**
     * The EnvoyCreate model constructor.
     * @property {module:model/EnvoyCreate}
     */
    EnvoyCreate,

    /**
     * The EnvoyDetail model constructor.
     * @property {module:model/EnvoyDetail}
     */
    EnvoyDetail,

    /**
     * The EnvoyDetailList model constructor.
     * @property {module:model/EnvoyDetailList}
     */
    EnvoyDetailList,

    /**
     * The EnvoyIdList model constructor.
     * @property {module:model/EnvoyIdList}
     */
    EnvoyIdList,

    /**
     * The EnvoySummary model constructor.
     * @property {module:model/EnvoySummary}
     */
    EnvoySummary,

    /**
     * The EnvoyUpdate model constructor.
     * @property {module:model/EnvoyUpdate}
     */
    EnvoyUpdate,

    /**
     * The EnvoyUserInfo model constructor.
     * @property {module:model/EnvoyUserInfo}
     */
    EnvoyUserInfo,

    /**
     * The EventCsvDownloadResponse model constructor.
     * @property {module:model/EventCsvDownloadResponse}
     */
    EventCsvDownloadResponse,

    /**
     * The EventNotification model constructor.
     * @property {module:model/EventNotification}
     */
    EventNotification,

    /**
     * The EventSeriesStatusV1 model constructor.
     * @property {module:model/EventSeriesStatusV1}
     */
    EventSeriesStatusV1,

    /**
     * The EventSeriesSummaryV1 model constructor.
     * @property {module:model/EventSeriesSummaryV1}
     */
    EventSeriesSummaryV1,

    /**
     * The EventSeverityV1 model constructor.
     * @property {module:model/EventSeverityV1}
     */
    EventSeverityV1,

    /**
     * The EventStatusV1 model constructor.
     * @property {module:model/EventStatusV1}
     */
    EventStatusV1,

    /**
     * The EventSummaryV1 model constructor.
     * @property {module:model/EventSummaryV1}
     */
    EventSummaryV1,

    /**
     * The EventTypeV1 model constructor.
     * @property {module:model/EventTypeV1}
     */
    EventTypeV1,

    /**
     * The EventsAndSeriesSummariesResponse model constructor.
     * @property {module:model/EventsAndSeriesSummariesResponse}
     */
    EventsAndSeriesSummariesResponse,

    /**
     * The EventsAndSeriesSummariesV1 model constructor.
     * @property {module:model/EventsAndSeriesSummariesV1}
     */
    EventsAndSeriesSummariesV1,

    /**
     * The ExampleEnum model constructor.
     * @property {module:model/ExampleEnum}
     */
    ExampleEnum,

    /**
     * The ExclusionPatternCreateConfig model constructor.
     * @property {module:model/ExclusionPatternCreateConfig}
     */
    ExclusionPatternCreateConfig,

    /**
     * The ExclusionPatternDetail model constructor.
     * @property {module:model/ExclusionPatternDetail}
     */
    ExclusionPatternDetail,

    /**
     * The ExclusionPatternDetailList model constructor.
     * @property {module:model/ExclusionPatternDetailList}
     */
    ExclusionPatternDetailList,

    /**
     * The ExclusionPatternDetailListResponse model constructor.
     * @property {module:model/ExclusionPatternDetailListResponse}
     */
    ExclusionPatternDetailListResponse,

    /**
     * The ExclusionPatternUpdateConfig model constructor.
     * @property {module:model/ExclusionPatternUpdateConfig}
     */
    ExclusionPatternUpdateConfig,

    /**
     * The ExistingSnapshotRetention model constructor.
     * @property {module:model/ExistingSnapshotRetention}
     */
    ExistingSnapshotRetention,

    /**
     * The ExpiredCustomRetentionSnapshotInfo model constructor.
     * @property {module:model/ExpiredCustomRetentionSnapshotInfo}
     */
    ExpiredCustomRetentionSnapshotInfo,

    /**
     * The ExpiredCustomRetentionSnapshots model constructor.
     * @property {module:model/ExpiredCustomRetentionSnapshots}
     */
    ExpiredCustomRetentionSnapshots,

    /**
     * The ExportMssqlDbJobConfig model constructor.
     * @property {module:model/ExportMssqlDbJobConfig}
     */
    ExportMssqlDbJobConfig,

    /**
     * The ExportSnapshotJobConfigV1 model constructor.
     * @property {module:model/ExportSnapshotJobConfigV1}
     */
    ExportSnapshotJobConfigV1,

    /**
     * The FailoverClusterAppConfig model constructor.
     * @property {module:model/FailoverClusterAppConfig}
     */
    FailoverClusterAppConfig,

    /**
     * The FailoverClusterAppConnectionStatus model constructor.
     * @property {module:model/FailoverClusterAppConnectionStatus}
     */
    FailoverClusterAppConnectionStatus,

    /**
     * The FailoverClusterAppDetail model constructor.
     * @property {module:model/FailoverClusterAppDetail}
     */
    FailoverClusterAppDetail,

    /**
     * The FailoverClusterAppSource model constructor.
     * @property {module:model/FailoverClusterAppSource}
     */
    FailoverClusterAppSource,

    /**
     * The FailoverClusterAppSummary model constructor.
     * @property {module:model/FailoverClusterAppSummary}
     */
    FailoverClusterAppSummary,

    /**
     * The FailoverClusterAppSummaryListResponse model constructor.
     * @property {module:model/FailoverClusterAppSummaryListResponse}
     */
    FailoverClusterAppSummaryListResponse,

    /**
     * The FailoverClusterConfig model constructor.
     * @property {module:model/FailoverClusterConfig}
     */
    FailoverClusterConfig,

    /**
     * The FailoverClusterConnectionStatus model constructor.
     * @property {module:model/FailoverClusterConnectionStatus}
     */
    FailoverClusterConnectionStatus,

    /**
     * The FailoverClusterDetail model constructor.
     * @property {module:model/FailoverClusterDetail}
     */
    FailoverClusterDetail,

    /**
     * The FailoverClusterHierarchyObjectDescendentCount model constructor.
     * @property {module:model/FailoverClusterHierarchyObjectDescendentCount}
     */
    FailoverClusterHierarchyObjectDescendentCount,

    /**
     * The FailoverClusterHierarchyObjectSortAttribute model constructor.
     * @property {module:model/FailoverClusterHierarchyObjectSortAttribute}
     */
    FailoverClusterHierarchyObjectSortAttribute,

    /**
     * The FailoverClusterHierarchyObjectSummary model constructor.
     * @property {module:model/FailoverClusterHierarchyObjectSummary}
     */
    FailoverClusterHierarchyObjectSummary,

    /**
     * The FailoverClusterHierarchyObjectSummaryListResponse model constructor.
     * @property {module:model/FailoverClusterHierarchyObjectSummaryListResponse}
     */
    FailoverClusterHierarchyObjectSummaryListResponse,

    /**
     * The FailoverClusterNode model constructor.
     * @property {module:model/FailoverClusterNode}
     */
    FailoverClusterNode,

    /**
     * The FailoverClusterNodeConnectionStatus model constructor.
     * @property {module:model/FailoverClusterNodeConnectionStatus}
     */
    FailoverClusterNodeConnectionStatus,

    /**
     * The FailoverClusterNodeOrder model constructor.
     * @property {module:model/FailoverClusterNodeOrder}
     */
    FailoverClusterNodeOrder,

    /**
     * The FailoverClusterNodeOsType model constructor.
     * @property {module:model/FailoverClusterNodeOsType}
     */
    FailoverClusterNodeOsType,

    /**
     * The FailoverClusterObjectType model constructor.
     * @property {module:model/FailoverClusterObjectType}
     */
    FailoverClusterObjectType,

    /**
     * The FailoverClusterOsType model constructor.
     * @property {module:model/FailoverClusterOsType}
     */
    FailoverClusterOsType,

    /**
     * The FailoverClusterSummary model constructor.
     * @property {module:model/FailoverClusterSummary}
     */
    FailoverClusterSummary,

    /**
     * The FailoverClusterSummaryListResponse model constructor.
     * @property {module:model/FailoverClusterSummaryListResponse}
     */
    FailoverClusterSummaryListResponse,

    /**
     * The FailoverClusterType model constructor.
     * @property {module:model/FailoverClusterType}
     */
    FailoverClusterType,

    /**
     * The FileSystemType model constructor.
     * @property {module:model/FileSystemType}
     */
    FileSystemType,

    /**
     * The FileVersion model constructor.
     * @property {module:model/FileVersion}
     */
    FileVersion,

    /**
     * The FilesetArraySpec model constructor.
     * @property {module:model/FilesetArraySpec}
     */
    FilesetArraySpec,

    /**
     * The FilesetCreate model constructor.
     * @property {module:model/FilesetCreate}
     */
    FilesetCreate,

    /**
     * The FilesetDetail model constructor.
     * @property {module:model/FilesetDetail}
     */
    FilesetDetail,

    /**
     * The FilesetDownloadFileJobConfig model constructor.
     * @property {module:model/FilesetDownloadFileJobConfig}
     */
    FilesetDownloadFileJobConfig,

    /**
     * The FilesetExportFileJobConfig model constructor.
     * @property {module:model/FilesetExportFileJobConfig}
     */
    FilesetExportFileJobConfig,

    /**
     * The FilesetOptions model constructor.
     * @property {module:model/FilesetOptions}
     */
    FilesetOptions,

    /**
     * The FilesetRestoreFileJobConfig model constructor.
     * @property {module:model/FilesetRestoreFileJobConfig}
     */
    FilesetRestoreFileJobConfig,

    /**
     * The FilesetSnapshotDetail model constructor.
     * @property {module:model/FilesetSnapshotDetail}
     */
    FilesetSnapshotDetail,

    /**
     * The FilesetSnapshotSummary model constructor.
     * @property {module:model/FilesetSnapshotSummary}
     */
    FilesetSnapshotSummary,

    /**
     * The FilesetSnapshotVerbose model constructor.
     * @property {module:model/FilesetSnapshotVerbose}
     */
    FilesetSnapshotVerbose,

    /**
     * The FilesetSummary model constructor.
     * @property {module:model/FilesetSummary}
     */
    FilesetSummary,

    /**
     * The FilesetSummaryListResponse model constructor.
     * @property {module:model/FilesetSummaryListResponse}
     */
    FilesetSummaryListResponse,

    /**
     * The FilesetTemplateCreate model constructor.
     * @property {module:model/FilesetTemplateCreate}
     */
    FilesetTemplateCreate,

    /**
     * The FilesetTemplateDetail model constructor.
     * @property {module:model/FilesetTemplateDetail}
     */
    FilesetTemplateDetail,

    /**
     * The FilesetTemplateDetailListResponse model constructor.
     * @property {module:model/FilesetTemplateDetailListResponse}
     */
    FilesetTemplateDetailListResponse,

    /**
     * The FilesetTemplatePatch model constructor.
     * @property {module:model/FilesetTemplatePatch}
     */
    FilesetTemplatePatch,

    /**
     * The FilesetUpdate model constructor.
     * @property {module:model/FilesetUpdate}
     */
    FilesetUpdate,

    /**
     * The FipsStatus model constructor.
     * @property {module:model/FipsStatus}
     */
    FipsStatus,

    /**
     * The FipsStatusPatch model constructor.
     * @property {module:model/FipsStatusPatch}
     */
    FipsStatusPatch,

    /**
     * The ForceFullVolumeInfo model constructor.
     * @property {module:model/ForceFullVolumeInfo}
     */
    ForceFullVolumeInfo,

    /**
     * The ForecastAssumptions model constructor.
     * @property {module:model/ForecastAssumptions}
     */
    ForecastAssumptions,

    /**
     * The ForecastConsolidationFilter model constructor.
     * @property {module:model/ForecastConsolidationFilter}
     */
    ForecastConsolidationFilter,

    /**
     * The ForecastGranularity model constructor.
     * @property {module:model/ForecastGranularity}
     */
    ForecastGranularity,

    /**
     * The FrequencyChangeRates model constructor.
     * @property {module:model/FrequencyChangeRates}
     */
    FrequencyChangeRates,

    /**
     * The FrequencyConfig model constructor.
     * @property {module:model/FrequencyConfig}
     */
    FrequencyConfig,

    /**
     * The FullyQualifiedDomainNameInfo model constructor.
     * @property {module:model/FullyQualifiedDomainNameInfo}
     */
    FullyQualifiedDomainNameInfo,

    /**
     * The GenericCsrRequest model constructor.
     * @property {module:model/GenericCsrRequest}
     */
    GenericCsrRequest,

    /**
     * The GlobalBlackoutWindowStatus model constructor.
     * @property {module:model/GlobalBlackoutWindowStatus}
     */
    GlobalBlackoutWindowStatus,

    /**
     * The HdfsBaseConfig model constructor.
     * @property {module:model/HdfsBaseConfig}
     */
    HdfsBaseConfig,

    /**
     * The HdfsConfig model constructor.
     * @property {module:model/HdfsConfig}
     */
    HdfsConfig,

    /**
     * The HdfsCreate model constructor.
     * @property {module:model/HdfsCreate}
     */
    HdfsCreate,

    /**
     * The HdfsDetail model constructor.
     * @property {module:model/HdfsDetail}
     */
    HdfsDetail,

    /**
     * The HdfsExportFileJobConfig model constructor.
     * @property {module:model/HdfsExportFileJobConfig}
     */
    HdfsExportFileJobConfig,

    /**
     * The HdfsHost model constructor.
     * @property {module:model/HdfsHost}
     */
    HdfsHost,

    /**
     * The HdfsRestoreFileJobConfig model constructor.
     * @property {module:model/HdfsRestoreFileJobConfig}
     */
    HdfsRestoreFileJobConfig,

    /**
     * The HdfsSnapshotDetail model constructor.
     * @property {module:model/HdfsSnapshotDetail}
     */
    HdfsSnapshotDetail,

    /**
     * The HdfsSnapshotSummary model constructor.
     * @property {module:model/HdfsSnapshotSummary}
     */
    HdfsSnapshotSummary,

    /**
     * The HdfsSummary model constructor.
     * @property {module:model/HdfsSummary}
     */
    HdfsSummary,

    /**
     * The HdfsSummaryListResponse model constructor.
     * @property {module:model/HdfsSummaryListResponse}
     */
    HdfsSummaryListResponse,

    /**
     * The HdfsTemplateCreate model constructor.
     * @property {module:model/HdfsTemplateCreate}
     */
    HdfsTemplateCreate,

    /**
     * The HdfsTemplateDetail model constructor.
     * @property {module:model/HdfsTemplateDetail}
     */
    HdfsTemplateDetail,

    /**
     * The HdfsTemplateDetailListResponse model constructor.
     * @property {module:model/HdfsTemplateDetailListResponse}
     */
    HdfsTemplateDetailListResponse,

    /**
     * The HdfsTemplatePatch model constructor.
     * @property {module:model/HdfsTemplatePatch}
     */
    HdfsTemplatePatch,

    /**
     * The HdfsUpdate model constructor.
     * @property {module:model/HdfsUpdate}
     */
    HdfsUpdate,

    /**
     * The HealthMonitorPolicy model constructor.
     * @property {module:model/HealthMonitorPolicy}
     */
    HealthMonitorPolicy,

    /**
     * The HierarchyObjectIds model constructor.
     * @property {module:model/HierarchyObjectIds}
     */
    HierarchyObjectIds,

    /**
     * The HoldConfig model constructor.
     * @property {module:model/HoldConfig}
     */
    HoldConfig,

    /**
     * The HostConfigurationPropertyEnabled model constructor.
     * @property {module:model/HostConfigurationPropertyEnabled}
     */
    HostConfigurationPropertyEnabled,

    /**
     * The HostDetail model constructor.
     * @property {module:model/HostDetail}
     */
    HostDetail,

    /**
     * The HostFilterStatus model constructor.
     * @property {module:model/HostFilterStatus}
     */
    HostFilterStatus,

    /**
     * The HostGroupInfo model constructor.
     * @property {module:model/HostGroupInfo}
     */
    HostGroupInfo,

    /**
     * The HostHierarchyObjectDescendantCount model constructor.
     * @property {module:model/HostHierarchyObjectDescendantCount}
     */
    HostHierarchyObjectDescendantCount,

    /**
     * The HostHierarchyObjectSortAttribute model constructor.
     * @property {module:model/HostHierarchyObjectSortAttribute}
     */
    HostHierarchyObjectSortAttribute,

    /**
     * The HostHierarchyObjectSummary model constructor.
     * @property {module:model/HostHierarchyObjectSummary}
     */
    HostHierarchyObjectSummary,

    /**
     * The HostHierarchyObjectSummaryListResponse model constructor.
     * @property {module:model/HostHierarchyObjectSummaryListResponse}
     */
    HostHierarchyObjectSummaryListResponse,

    /**
     * The HostInfo model constructor.
     * @property {module:model/HostInfo}
     */
    HostInfo,

    /**
     * The HostMakePrimaryRequest model constructor.
     * @property {module:model/HostMakePrimaryRequest}
     */
    HostMakePrimaryRequest,

    /**
     * The HostObjectType model constructor.
     * @property {module:model/HostObjectType}
     */
    HostObjectType,

    /**
     * The HostOperatingSystemType model constructor.
     * @property {module:model/HostOperatingSystemType}
     */
    HostOperatingSystemType,

    /**
     * The HostRbsStatus model constructor.
     * @property {module:model/HostRbsStatus}
     */
    HostRbsStatus,

    /**
     * The HostRegister model constructor.
     * @property {module:model/HostRegister}
     */
    HostRegister,

    /**
     * The HostShareDetail model constructor.
     * @property {module:model/HostShareDetail}
     */
    HostShareDetail,

    /**
     * The HostShareParameters model constructor.
     * @property {module:model/HostShareParameters}
     */
    HostShareParameters,

    /**
     * The HostSharePatch model constructor.
     * @property {module:model/HostSharePatch}
     */
    HostSharePatch,

    /**
     * The HostShareUpdate model constructor.
     * @property {module:model/HostShareUpdate}
     */
    HostShareUpdate,

    /**
     * The HostShareVendorType model constructor.
     * @property {module:model/HostShareVendorType}
     */
    HostShareVendorType,

    /**
     * The HostSummary model constructor.
     * @property {module:model/HostSummary}
     */
    HostSummary,

    /**
     * The HostSummaryListResponse model constructor.
     * @property {module:model/HostSummaryListResponse}
     */
    HostSummaryListResponse,

    /**
     * The HostUiFilterStatus model constructor.
     * @property {module:model/HostUiFilterStatus}
     */
    HostUiFilterStatus,

    /**
     * The HostUpdate model constructor.
     * @property {module:model/HostUpdate}
     */
    HostUpdate,

    /**
     * The HostVfdInstallConfig model constructor.
     * @property {module:model/HostVfdInstallConfig}
     */
    HostVfdInstallConfig,

    /**
     * The HostVfdState model constructor.
     * @property {module:model/HostVfdState}
     */
    HostVfdState,

    /**
     * The HostVolumeSummary model constructor.
     * @property {module:model/HostVolumeSummary}
     */
    HostVolumeSummary,

    /**
     * The HostVolumeSummaryListResponse model constructor.
     * @property {module:model/HostVolumeSummaryListResponse}
     */
    HostVolumeSummaryListResponse,

    /**
     * The HotAddBandwidthInfo model constructor.
     * @property {module:model/HotAddBandwidthInfo}
     */
    HotAddBandwidthInfo,

    /**
     * The HotAddNetworkConfigWithId model constructor.
     * @property {module:model/HotAddNetworkConfigWithId}
     */
    HotAddNetworkConfigWithId,

    /**
     * The HotAddNetworkConfigWithName model constructor.
     * @property {module:model/HotAddNetworkConfigWithName}
     */
    HotAddNetworkConfigWithName,

    /**
     * The HotAddProxiesNeededInfo model constructor.
     * @property {module:model/HotAddProxiesNeededInfo}
     */
    HotAddProxiesNeededInfo,

    /**
     * The HotAddProxyVmInfo model constructor.
     * @property {module:model/HotAddProxyVmInfo}
     */
    HotAddProxyVmInfo,

    /**
     * The HotAddProxyVmInfoListResponse model constructor.
     * @property {module:model/HotAddProxyVmInfoListResponse}
     */
    HotAddProxyVmInfoListResponse,

    /**
     * The HotAddProxyVmStatusType model constructor.
     * @property {module:model/HotAddProxyVmStatusType}
     */
    HotAddProxyVmStatusType,

    /**
     * The HypervVirtualDiskForceFullInfo model constructor.
     * @property {module:model/HypervVirtualDiskForceFullInfo}
     */
    HypervVirtualDiskForceFullInfo,

    /**
     * The HypervVirtualMachineForceFullRequest model constructor.
     * @property {module:model/HypervVirtualMachineForceFullRequest}
     */
    HypervVirtualMachineForceFullRequest,

    /**
     * The HypervVirtualMachineForceFullResponse model constructor.
     * @property {module:model/HypervVirtualMachineForceFullResponse}
     */
    HypervVirtualMachineForceFullResponse,

    /**
     * The HypervVmSlaObjectCount model constructor.
     * @property {module:model/HypervVmSlaObjectCount}
     */
    HypervVmSlaObjectCount,

    /**
     * The IdNamePair model constructor.
     * @property {module:model/IdNamePair}
     */
    IdNamePair,

    /**
     * The IdProviderAuthDomainInfo model constructor.
     * @property {module:model/IdProviderAuthDomainInfo}
     */
    IdProviderAuthDomainInfo,

    /**
     * The IdProviderAuthDomainInfoUpdate model constructor.
     * @property {module:model/IdProviderAuthDomainInfoUpdate}
     */
    IdProviderAuthDomainInfoUpdate,

    /**
     * The IdProviderAuthDomainSummary model constructor.
     * @property {module:model/IdProviderAuthDomainSummary}
     */
    IdProviderAuthDomainSummary,

    /**
     * The IdProviderAuthDomainSummaryListResponse model constructor.
     * @property {module:model/IdProviderAuthDomainSummaryListResponse}
     */
    IdProviderAuthDomainSummaryListResponse,

    /**
     * The IdProviderSamlInfo model constructor.
     * @property {module:model/IdProviderSamlInfo}
     */
    IdProviderSamlInfo,

    /**
     * The IdProviderSamlInfoUpdate model constructor.
     * @property {module:model/IdProviderSamlInfoUpdate}
     */
    IdProviderSamlInfoUpdate,

    /**
     * The InstantRecoveryJobConfig model constructor.
     * @property {module:model/InstantRecoveryJobConfig}
     */
    InstantRecoveryJobConfig,

    /**
     * The InternalJobInstanceDetail model constructor.
     * @property {module:model/InternalJobInstanceDetail}
     */
    InternalJobInstanceDetail,

    /**
     * The IoFilterStatus model constructor.
     * @property {module:model/IoFilterStatus}
     */
    IoFilterStatus,

    /**
     * The IoFilterSummary model constructor.
     * @property {module:model/IoFilterSummary}
     */
    IoFilterSummary,

    /**
     * The IoFilterSummaryListResponse model constructor.
     * @property {module:model/IoFilterSummaryListResponse}
     */
    IoFilterSummaryListResponse,

    /**
     * The JobMonitoringCsvDownloadResponse model constructor.
     * @property {module:model/JobMonitoringCsvDownloadResponse}
     */
    JobMonitoringCsvDownloadResponse,

    /**
     * The JobMonitoringInfo model constructor.
     * @property {module:model/JobMonitoringInfo}
     */
    JobMonitoringInfo,

    /**
     * The JobMonitoringJobProgressInfo model constructor.
     * @property {module:model/JobMonitoringJobProgressInfo}
     */
    JobMonitoringJobProgressInfo,

    /**
     * The JobMonitoringObjectsCountByState model constructor.
     * @property {module:model/JobMonitoringObjectsCountByState}
     */
    JobMonitoringObjectsCountByState,

    /**
     * The JobMonitoringObjectsCountByType model constructor.
     * @property {module:model/JobMonitoringObjectsCountByType}
     */
    JobMonitoringObjectsCountByType,

    /**
     * The JobMonitoringResponse model constructor.
     * @property {module:model/JobMonitoringResponse}
     */
    JobMonitoringResponse,

    /**
     * The JobMonitoringRetryStatus model constructor.
     * @property {module:model/JobMonitoringRetryStatus}
     */
    JobMonitoringRetryStatus,

    /**
     * The JobMonitoringState model constructor.
     * @property {module:model/JobMonitoringState}
     */
    JobMonitoringState,

    /**
     * The JobMonitoringStatus model constructor.
     * @property {module:model/JobMonitoringStatus}
     */
    JobMonitoringStatus,

    /**
     * The JobMonitoringStream model constructor.
     * @property {module:model/JobMonitoringStream}
     */
    JobMonitoringStream,

    /**
     * The JobMonitoringStreamingResponse model constructor.
     * @property {module:model/JobMonitoringStreamingResponse}
     */
    JobMonitoringStreamingResponse,

    /**
     * The JobMonitoringSummaryByState model constructor.
     * @property {module:model/JobMonitoringSummaryByState}
     */
    JobMonitoringSummaryByState,

    /**
     * The JobMonitoringSummaryByType model constructor.
     * @property {module:model/JobMonitoringSummaryByType}
     */
    JobMonitoringSummaryByType,

    /**
     * The JobMonitoringTaskType model constructor.
     * @property {module:model/JobMonitoringTaskType}
     */
    JobMonitoringTaskType,

    /**
     * The JobScheduledResponse model constructor.
     * @property {module:model/JobScheduledResponse}
     */
    JobScheduledResponse,

    /**
     * The KmipClientConfiguration model constructor.
     * @property {module:model/KmipClientConfiguration}
     */
    KmipClientConfiguration,

    /**
     * The KmipClientDetail model constructor.
     * @property {module:model/KmipClientDetail}
     */
    KmipClientDetail,

    /**
     * The KmipServerConfiguration model constructor.
     * @property {module:model/KmipServerConfiguration}
     */
    KmipServerConfiguration,

    /**
     * The KmipServerDetail model constructor.
     * @property {module:model/KmipServerDetail}
     */
    KmipServerDetail,

    /**
     * The KuprHostRegister model constructor.
     * @property {module:model/KuprHostRegister}
     */
    KuprHostRegister,

    /**
     * The KuprHostUpdate model constructor.
     * @property {module:model/KuprHostUpdate}
     */
    KuprHostUpdate,

    /**
     * The LdapDomainName model constructor.
     * @property {module:model/LdapDomainName}
     */
    LdapDomainName,

    /**
     * The LdapDomainNameListResponse model constructor.
     * @property {module:model/LdapDomainNameListResponse}
     */
    LdapDomainNameListResponse,

    /**
     * The LdapServiceInfo model constructor.
     * @property {module:model/LdapServiceInfo}
     */
    LdapServiceInfo,

    /**
     * The LdapServiceInfoUpdate model constructor.
     * @property {module:model/LdapServiceInfoUpdate}
     */
    LdapServiceInfoUpdate,

    /**
     * The LdapServiceSummary model constructor.
     * @property {module:model/LdapServiceSummary}
     */
    LdapServiceSummary,

    /**
     * The LdapServiceSummaryListResponse model constructor.
     * @property {module:model/LdapServiceSummaryListResponse}
     */
    LdapServiceSummaryListResponse,

    /**
     * The LegalHoldDownloadConfig model constructor.
     * @property {module:model/LegalHoldDownloadConfig}
     */
    LegalHoldDownloadConfig,

    /**
     * The LegalHoldObjectSortAttribute model constructor.
     * @property {module:model/LegalHoldObjectSortAttribute}
     */
    LegalHoldObjectSortAttribute,

    /**
     * The LegalHoldSnapshotSortAttribute model constructor.
     * @property {module:model/LegalHoldSnapshotSortAttribute}
     */
    LegalHoldSnapshotSortAttribute,

    /**
     * The LegalHoldSummary model constructor.
     * @property {module:model/LegalHoldSummary}
     */
    LegalHoldSummary,

    /**
     * The LegalHoldSummaryListResponse model constructor.
     * @property {module:model/LegalHoldSummaryListResponse}
     */
    LegalHoldSummaryListResponse,

    /**
     * The Link model constructor.
     * @property {module:model/Link}
     */
    Link,

    /**
     * The LocalUserAccountLockoutConfig model constructor.
     * @property {module:model/LocalUserAccountLockoutConfig}
     */
    LocalUserAccountLockoutConfig,

    /**
     * The LocalUserAccountLockoutStatus model constructor.
     * @property {module:model/LocalUserAccountLockoutStatus}
     */
    LocalUserAccountLockoutStatus,

    /**
     * The LocationPathPoint model constructor.
     * @property {module:model/LocationPathPoint}
     */
    LocationPathPoint,

    /**
     * The LsnRecoveryPoint model constructor.
     * @property {module:model/LsnRecoveryPoint}
     */
    LsnRecoveryPoint,

    /**
     * The ManagedHierarchyObjectAncestor model constructor.
     * @property {module:model/ManagedHierarchyObjectAncestor}
     */
    ManagedHierarchyObjectAncestor,

    /**
     * The ManagedHierarchyObjectSummary model constructor.
     * @property {module:model/ManagedHierarchyObjectSummary}
     */
    ManagedHierarchyObjectSummary,

    /**
     * The ManagedObjectDescendantCountVcdVappFields model constructor.
     * @property {module:model/ManagedObjectDescendantCountVcdVappFields}
     */
    ManagedObjectDescendantCountVcdVappFields,

    /**
     * The ManagedObjectPendingSlaInfo model constructor.
     * @property {module:model/ManagedObjectPendingSlaInfo}
     */
    ManagedObjectPendingSlaInfo,

    /**
     * The ManagedVolumeSlaObjectCount model constructor.
     * @property {module:model/ManagedVolumeSlaObjectCount}
     */
    ManagedVolumeSlaObjectCount,

    /**
     * The ManualDiscoveryNodeInfo model constructor.
     * @property {module:model/ManualDiscoveryNodeInfo}
     */
    ManualDiscoveryNodeInfo,

    /**
     * The ManualDiscoveryNodeIpv4Info model constructor.
     * @property {module:model/ManualDiscoveryNodeIpv4Info}
     */
    ManualDiscoveryNodeIpv4Info,

    /**
     * The MfaServerConfig model constructor.
     * @property {module:model/MfaServerConfig}
     */
    MfaServerConfig,

    /**
     * The MissedSnapshot model constructor.
     * @property {module:model/MissedSnapshot}
     */
    MissedSnapshot,

    /**
     * The MissedSnapshotDayOfTimeUnit model constructor.
     * @property {module:model/MissedSnapshotDayOfTimeUnit}
     */
    MissedSnapshotDayOfTimeUnit,

    /**
     * The MissedSnapshotListResponse model constructor.
     * @property {module:model/MissedSnapshotListResponse}
     */
    MissedSnapshotListResponse,

    /**
     * The MissedSnapshotTimeUnitConfig model constructor.
     * @property {module:model/MissedSnapshotTimeUnitConfig}
     */
    MissedSnapshotTimeUnitConfig,

    /**
     * The MonitoringEmailSubscriptionRequest model constructor.
     * @property {module:model/MonitoringEmailSubscriptionRequest}
     */
    MonitoringEmailSubscriptionRequest,

    /**
     * The MonitoringEmailSubscriptionUpdate model constructor.
     * @property {module:model/MonitoringEmailSubscriptionUpdate}
     */
    MonitoringEmailSubscriptionUpdate,

    /**
     * The MonitoringRowType model constructor.
     * @property {module:model/MonitoringRowType}
     */
    MonitoringRowType,

    /**
     * The MonitoringSubscriptionSummary model constructor.
     * @property {module:model/MonitoringSubscriptionSummary}
     */
    MonitoringSubscriptionSummary,

    /**
     * The MonthlyConfig model constructor.
     * @property {module:model/MonthlyConfig}
     */
    MonthlyConfig,

    /**
     * The MountExportSnapshotJobCommonOptions model constructor.
     * @property {module:model/MountExportSnapshotJobCommonOptions}
     */
    MountExportSnapshotJobCommonOptions,

    /**
     * The MountMssqlDbConfig model constructor.
     * @property {module:model/MountMssqlDbConfig}
     */
    MountMssqlDbConfig,

    /**
     * The MountSnapshotJobConfigForBatchV1 model constructor.
     * @property {module:model/MountSnapshotJobConfigForBatchV1}
     */
    MountSnapshotJobConfigForBatchV1,

    /**
     * The MountSnapshotJobConfigV1 model constructor.
     * @property {module:model/MountSnapshotJobConfigV1}
     */
    MountSnapshotJobConfigV1,

    /**
     * The MssqlAvailabilityGroupDetail model constructor.
     * @property {module:model/MssqlAvailabilityGroupDetail}
     */
    MssqlAvailabilityGroupDetail,

    /**
     * The MssqlAvailabilityGroupSummary model constructor.
     * @property {module:model/MssqlAvailabilityGroupSummary}
     */
    MssqlAvailabilityGroupSummary,

    /**
     * The MssqlAvailabilityGroupSummaryListResponse model constructor.
     * @property {module:model/MssqlAvailabilityGroupSummaryListResponse}
     */
    MssqlAvailabilityGroupSummaryListResponse,

    /**
     * The MssqlAvailabilityGroupUpdate model constructor.
     * @property {module:model/MssqlAvailabilityGroupUpdate}
     */
    MssqlAvailabilityGroupUpdate,

    /**
     * The MssqlBackup model constructor.
     * @property {module:model/MssqlBackup}
     */
    MssqlBackup,

    /**
     * The MssqlBackupJobConfig model constructor.
     * @property {module:model/MssqlBackupJobConfig}
     */
    MssqlBackupJobConfig,

    /**
     * The MssqlBackupSelection model constructor.
     * @property {module:model/MssqlBackupSelection}
     */
    MssqlBackupSelection,

    /**
     * The MssqlBackupType model constructor.
     * @property {module:model/MssqlBackupType}
     */
    MssqlBackupType,

    /**
     * The MssqlBackups model constructor.
     * @property {module:model/MssqlBackups}
     */
    MssqlBackups,

    /**
     * The MssqlBatchBackupCanceledSummary model constructor.
     * @property {module:model/MssqlBatchBackupCanceledSummary}
     */
    MssqlBatchBackupCanceledSummary,

    /**
     * The MssqlBatchBackupFailureSummary model constructor.
     * @property {module:model/MssqlBatchBackupFailureSummary}
     */
    MssqlBatchBackupFailureSummary,

    /**
     * The MssqlBatchBackupJobConfig model constructor.
     * @property {module:model/MssqlBatchBackupJobConfig}
     */
    MssqlBatchBackupJobConfig,

    /**
     * The MssqlBatchBackupSuccessSummary model constructor.
     * @property {module:model/MssqlBatchBackupSuccessSummary}
     */
    MssqlBatchBackupSuccessSummary,

    /**
     * The MssqlBatchBackupSummary model constructor.
     * @property {module:model/MssqlBatchBackupSummary}
     */
    MssqlBatchBackupSummary,

    /**
     * The MssqlCbtEffectiveStatusType model constructor.
     * @property {module:model/MssqlCbtEffectiveStatusType}
     */
    MssqlCbtEffectiveStatusType,

    /**
     * The MssqlCbtStatusType model constructor.
     * @property {module:model/MssqlCbtStatusType}
     */
    MssqlCbtStatusType,

    /**
     * The MssqlDatabaseFileType model constructor.
     * @property {module:model/MssqlDatabaseFileType}
     */
    MssqlDatabaseFileType,

    /**
     * The MssqlDatabaseListSortAttribute model constructor.
     * @property {module:model/MssqlDatabaseListSortAttribute}
     */
    MssqlDatabaseListSortAttribute,

    /**
     * The MssqlDatabaseRecoveryModel model constructor.
     * @property {module:model/MssqlDatabaseRecoveryModel}
     */
    MssqlDatabaseRecoveryModel,

    /**
     * The MssqlDbDefaults model constructor.
     * @property {module:model/MssqlDbDefaults}
     */
    MssqlDbDefaults,

    /**
     * The MssqlDbDefaultsUpdate model constructor.
     * @property {module:model/MssqlDbDefaultsUpdate}
     */
    MssqlDbDefaultsUpdate,

    /**
     * The MssqlDbDetail model constructor.
     * @property {module:model/MssqlDbDetail}
     */
    MssqlDbDetail,

    /**
     * The MssqlDbFileExportPath model constructor.
     * @property {module:model/MssqlDbFileExportPath}
     */
    MssqlDbFileExportPath,

    /**
     * The MssqlDbReplica model constructor.
     * @property {module:model/MssqlDbReplica}
     */
    MssqlDbReplica,

    /**
     * The MssqlDbReplicaAvailabilityInfo model constructor.
     * @property {module:model/MssqlDbReplicaAvailabilityInfo}
     */
    MssqlDbReplicaAvailabilityInfo,

    /**
     * The MssqlDbSlaObjectCount model constructor.
     * @property {module:model/MssqlDbSlaObjectCount}
     */
    MssqlDbSlaObjectCount,

    /**
     * The MssqlDbSnapshotDetail model constructor.
     * @property {module:model/MssqlDbSnapshotDetail}
     */
    MssqlDbSnapshotDetail,

    /**
     * The MssqlDbSnapshotSummary model constructor.
     * @property {module:model/MssqlDbSnapshotSummary}
     */
    MssqlDbSnapshotSummary,

    /**
     * The MssqlDbSnapshotSummaryListResponse model constructor.
     * @property {module:model/MssqlDbSnapshotSummaryListResponse}
     */
    MssqlDbSnapshotSummaryListResponse,

    /**
     * The MssqlDbSummary model constructor.
     * @property {module:model/MssqlDbSummary}
     */
    MssqlDbSummary,

    /**
     * The MssqlDbSummaryListResponse model constructor.
     * @property {module:model/MssqlDbSummaryListResponse}
     */
    MssqlDbSummaryListResponse,

    /**
     * The MssqlDbUpdate model constructor.
     * @property {module:model/MssqlDbUpdate}
     */
    MssqlDbUpdate,

    /**
     * The MssqlDbUpdateId model constructor.
     * @property {module:model/MssqlDbUpdateId}
     */
    MssqlDbUpdateId,

    /**
     * The MssqlDownloadFromArchiveConfig model constructor.
     * @property {module:model/MssqlDownloadFromArchiveConfig}
     */
    MssqlDownloadFromArchiveConfig,

    /**
     * The MssqlHierarchyObjectDescendantCount model constructor.
     * @property {module:model/MssqlHierarchyObjectDescendantCount}
     */
    MssqlHierarchyObjectDescendantCount,

    /**
     * The MssqlHierarchyObjectSummary model constructor.
     * @property {module:model/MssqlHierarchyObjectSummary}
     */
    MssqlHierarchyObjectSummary,

    /**
     * The MssqlHierarchyObjectSummaryListResponse model constructor.
     * @property {module:model/MssqlHierarchyObjectSummaryListResponse}
     */
    MssqlHierarchyObjectSummaryListResponse,

    /**
     * The MssqlHierarchyObjectType model constructor.
     * @property {module:model/MssqlHierarchyObjectType}
     */
    MssqlHierarchyObjectType,

    /**
     * The MssqlHostCbtEffectiveStatusType model constructor.
     * @property {module:model/MssqlHostCbtEffectiveStatusType}
     */
    MssqlHostCbtEffectiveStatusType,

    /**
     * The MssqlHostCbtStatusType model constructor.
     * @property {module:model/MssqlHostCbtStatusType}
     */
    MssqlHostCbtStatusType,

    /**
     * The MssqlHostConfiguration model constructor.
     * @property {module:model/MssqlHostConfiguration}
     */
    MssqlHostConfiguration,

    /**
     * The MssqlHostConfigurationWithHostId model constructor.
     * @property {module:model/MssqlHostConfigurationWithHostId}
     */
    MssqlHostConfigurationWithHostId,

    /**
     * The MssqlHostConfigurationWithHostIdListResponse model constructor.
     * @property {module:model/MssqlHostConfigurationWithHostIdListResponse}
     */
    MssqlHostConfigurationWithHostIdListResponse,

    /**
     * The MssqlInstanceDetail model constructor.
     * @property {module:model/MssqlInstanceDetail}
     */
    MssqlInstanceDetail,

    /**
     * The MssqlInstanceShortSummary model constructor.
     * @property {module:model/MssqlInstanceShortSummary}
     */
    MssqlInstanceShortSummary,

    /**
     * The MssqlInstanceSummary model constructor.
     * @property {module:model/MssqlInstanceSummary}
     */
    MssqlInstanceSummary,

    /**
     * The MssqlInstanceSummaryListResponse model constructor.
     * @property {module:model/MssqlInstanceSummaryListResponse}
     */
    MssqlInstanceSummaryListResponse,

    /**
     * The MssqlInstanceUpdate model constructor.
     * @property {module:model/MssqlInstanceUpdate}
     */
    MssqlInstanceUpdate,

    /**
     * The MssqlLogShippingCreateConfig model constructor.
     * @property {module:model/MssqlLogShippingCreateConfig}
     */
    MssqlLogShippingCreateConfig,

    /**
     * The MssqlLogShippingDetail model constructor.
     * @property {module:model/MssqlLogShippingDetail}
     */
    MssqlLogShippingDetail,

    /**
     * The MssqlLogShippingLinks model constructor.
     * @property {module:model/MssqlLogShippingLinks}
     */
    MssqlLogShippingLinks,

    /**
     * The MssqlLogShippingListSortAttribute model constructor.
     * @property {module:model/MssqlLogShippingListSortAttribute}
     */
    MssqlLogShippingListSortAttribute,

    /**
     * The MssqlLogShippingOkState model constructor.
     * @property {module:model/MssqlLogShippingOkState}
     */
    MssqlLogShippingOkState,

    /**
     * The MssqlLogShippingReseedConfig model constructor.
     * @property {module:model/MssqlLogShippingReseedConfig}
     */
    MssqlLogShippingReseedConfig,

    /**
     * The MssqlLogShippingStatus model constructor.
     * @property {module:model/MssqlLogShippingStatus}
     */
    MssqlLogShippingStatus,

    /**
     * The MssqlLogShippingStatusInfo model constructor.
     * @property {module:model/MssqlLogShippingStatusInfo}
     */
    MssqlLogShippingStatusInfo,

    /**
     * The MssqlLogShippingSummary model constructor.
     * @property {module:model/MssqlLogShippingSummary}
     */
    MssqlLogShippingSummary,

    /**
     * The MssqlLogShippingSummaryListResponse model constructor.
     * @property {module:model/MssqlLogShippingSummaryListResponse}
     */
    MssqlLogShippingSummaryListResponse,

    /**
     * The MssqlLogShippingTargetStateOptions model constructor.
     * @property {module:model/MssqlLogShippingTargetStateOptions}
     */
    MssqlLogShippingTargetStateOptions,

    /**
     * The MssqlLogShippingUpdate model constructor.
     * @property {module:model/MssqlLogShippingUpdate}
     */
    MssqlLogShippingUpdate,

    /**
     * The MssqlMissedRecoverableRange model constructor.
     * @property {module:model/MssqlMissedRecoverableRange}
     */
    MssqlMissedRecoverableRange,

    /**
     * The MssqlMissedRecoverableRangeError model constructor.
     * @property {module:model/MssqlMissedRecoverableRangeError}
     */
    MssqlMissedRecoverableRangeError,

    /**
     * The MssqlMissedRecoverableRangeListResponse model constructor.
     * @property {module:model/MssqlMissedRecoverableRangeListResponse}
     */
    MssqlMissedRecoverableRangeListResponse,

    /**
     * The MssqlMountDetail model constructor.
     * @property {module:model/MssqlMountDetail}
     */
    MssqlMountDetail,

    /**
     * The MssqlMountLinks model constructor.
     * @property {module:model/MssqlMountLinks}
     */
    MssqlMountLinks,

    /**
     * The MssqlMountSummary model constructor.
     * @property {module:model/MssqlMountSummary}
     */
    MssqlMountSummary,

    /**
     * The MssqlMountSummaryListResponse model constructor.
     * @property {module:model/MssqlMountSummaryListResponse}
     */
    MssqlMountSummaryListResponse,

    /**
     * The MssqlRecoverableRange model constructor.
     * @property {module:model/MssqlRecoverableRange}
     */
    MssqlRecoverableRange,

    /**
     * The MssqlRecoverableRangeListResponse model constructor.
     * @property {module:model/MssqlRecoverableRangeListResponse}
     */
    MssqlRecoverableRangeListResponse,

    /**
     * The MssqlRecoveryPoint model constructor.
     * @property {module:model/MssqlRecoveryPoint}
     */
    MssqlRecoveryPoint,

    /**
     * The MssqlRestoreEstimateResult model constructor.
     * @property {module:model/MssqlRestoreEstimateResult}
     */
    MssqlRestoreEstimateResult,

    /**
     * The MssqlRestoreFile model constructor.
     * @property {module:model/MssqlRestoreFile}
     */
    MssqlRestoreFile,

    /**
     * The MssqlRootProperties model constructor.
     * @property {module:model/MssqlRootProperties}
     */
    MssqlRootProperties,

    /**
     * The MssqlScriptDetail model constructor.
     * @property {module:model/MssqlScriptDetail}
     */
    MssqlScriptDetail,

    /**
     * The MssqlSlaDomainAssignInfo model constructor.
     * @property {module:model/MssqlSlaDomainAssignInfo}
     */
    MssqlSlaDomainAssignInfo,

    /**
     * The MssqlSlaDomainInfo model constructor.
     * @property {module:model/MssqlSlaDomainInfo}
     */
    MssqlSlaDomainInfo,

    /**
     * The MssqlSlaPatchProperties model constructor.
     * @property {module:model/MssqlSlaPatchProperties}
     */
    MssqlSlaPatchProperties,

    /**
     * The MssqlSlaRelatedProperties model constructor.
     * @property {module:model/MssqlSlaRelatedProperties}
     */
    MssqlSlaRelatedProperties,

    /**
     * The MssqlSnappableId model constructor.
     * @property {module:model/MssqlSnappableId}
     */
    MssqlSnappableId,

    /**
     * The NasBaseConfig model constructor.
     * @property {module:model/NasBaseConfig}
     */
    NasBaseConfig,

    /**
     * The NasConfig model constructor.
     * @property {module:model/NasConfig}
     */
    NasConfig,

    /**
     * The NasSharesToAdd model constructor.
     * @property {module:model/NasSharesToAdd}
     */
    NasSharesToAdd,

    /**
     * The NasVendorType model constructor.
     * @property {module:model/NasVendorType}
     */
    NasVendorType,

    /**
     * The NetworkInfo model constructor.
     * @property {module:model/NetworkInfo}
     */
    NetworkInfo,

    /**
     * The NetworkInfoListResponse model constructor.
     * @property {module:model/NetworkInfoListResponse}
     */
    NetworkInfoListResponse,

    /**
     * The NodeHostnameInfo model constructor.
     * @property {module:model/NodeHostnameInfo}
     */
    NodeHostnameInfo,

    /**
     * The NodeHostnameInfoListResponse model constructor.
     * @property {module:model/NodeHostnameInfoListResponse}
     */
    NodeHostnameInfoListResponse,

    /**
     * The NodeId model constructor.
     * @property {module:model/NodeId}
     */
    NodeId,

    /**
     * The NodePolicyCheckResult model constructor.
     * @property {module:model/NodePolicyCheckResult}
     */
    NodePolicyCheckResult,

    /**
     * The NodeStatusEnum model constructor.
     * @property {module:model/NodeStatusEnum}
     */
    NodeStatusEnum,

    /**
     * The NotificationConfig model constructor.
     * @property {module:model/NotificationConfig}
     */
    NotificationConfig,

    /**
     * The NotificationDetails model constructor.
     * @property {module:model/NotificationDetails}
     */
    NotificationDetails,

    /**
     * The NotificationTypeEnum model constructor.
     * @property {module:model/NotificationTypeEnum}
     */
    NotificationTypeEnum,

    /**
     * The NutanixVmSlaObjectCount model constructor.
     * @property {module:model/NutanixVmSlaObjectCount}
     */
    NutanixVmSlaObjectCount,

    /**
     * The ObjectHoldSummary model constructor.
     * @property {module:model/ObjectHoldSummary}
     */
    ObjectHoldSummary,

    /**
     * The ObjectHoldSummaryListResponse model constructor.
     * @property {module:model/ObjectHoldSummaryListResponse}
     */
    ObjectHoldSummaryListResponse,

    /**
     * The ObjectHolder model constructor.
     * @property {module:model/ObjectHolder}
     */
    ObjectHolder,

    /**
     * The ObjectTypeV1 model constructor.
     * @property {module:model/ObjectTypeV1}
     */
    ObjectTypeV1,

    /**
     * The OperatingSystemFamily model constructor.
     * @property {module:model/OperatingSystemFamily}
     */
    OperatingSystemFamily,

    /**
     * The OperationMode model constructor.
     * @property {module:model/OperationMode}
     */
    OperationMode,

    /**
     * The OracleAcoParameterDetail model constructor.
     * @property {module:model/OracleAcoParameterDetail}
     */
    OracleAcoParameterDetail,

    /**
     * The OracleAcoParameterList model constructor.
     * @property {module:model/OracleAcoParameterList}
     */
    OracleAcoParameterList,

    /**
     * The OracleAcoValidationResult model constructor.
     * @property {module:model/OracleAcoValidationResult}
     */
    OracleAcoValidationResult,

    /**
     * The OracleAcoValueErrorDetail model constructor.
     * @property {module:model/OracleAcoValueErrorDetail}
     */
    OracleAcoValueErrorDetail,

    /**
     * The OracleBulkUpdate model constructor.
     * @property {module:model/OracleBulkUpdate}
     */
    OracleBulkUpdate,

    /**
     * The OracleDataGuardGroupUpdate model constructor.
     * @property {module:model/OracleDataGuardGroupUpdate}
     */
    OracleDataGuardGroupUpdate,

    /**
     * The OracleDbDetail model constructor.
     * @property {module:model/OracleDbDetail}
     */
    OracleDbDetail,

    /**
     * The OracleDbSummary model constructor.
     * @property {module:model/OracleDbSummary}
     */
    OracleDbSummary,

    /**
     * The OracleDbSummaryListResponse model constructor.
     * @property {module:model/OracleDbSummaryListResponse}
     */
    OracleDbSummaryListResponse,

    /**
     * The OracleFileDownloadLink model constructor.
     * @property {module:model/OracleFileDownloadLink}
     */
    OracleFileDownloadLink,

    /**
     * The OracleHostDetail model constructor.
     * @property {module:model/OracleHostDetail}
     */
    OracleHostDetail,

    /**
     * The OracleHostSummary model constructor.
     * @property {module:model/OracleHostSummary}
     */
    OracleHostSummary,

    /**
     * The OracleInstanceProperties model constructor.
     * @property {module:model/OracleInstanceProperties}
     */
    OracleInstanceProperties,

    /**
     * The OracleLastValidationResult model constructor.
     * @property {module:model/OracleLastValidationResult}
     */
    OracleLastValidationResult,

    /**
     * The OracleNodeOrder model constructor.
     * @property {module:model/OracleNodeOrder}
     */
    OracleNodeOrder,

    /**
     * The OracleNodeProperties model constructor.
     * @property {module:model/OracleNodeProperties}
     */
    OracleNodeProperties,

    /**
     * The OracleNonSlaProperties model constructor.
     * @property {module:model/OracleNonSlaProperties}
     */
    OracleNonSlaProperties,

    /**
     * The OracleRacDetail model constructor.
     * @property {module:model/OracleRacDetail}
     */
    OracleRacDetail,

    /**
     * The OracleRacSummary model constructor.
     * @property {module:model/OracleRacSummary}
     */
    OracleRacSummary,

    /**
     * The OracleRecoveryApiValidationErrors model constructor.
     * @property {module:model/OracleRecoveryApiValidationErrors}
     */
    OracleRecoveryApiValidationErrors,

    /**
     * The OracleRecoveryPoint model constructor.
     * @property {module:model/OracleRecoveryPoint}
     */
    OracleRecoveryPoint,

    /**
     * The OracleRestoreEstimateResult model constructor.
     * @property {module:model/OracleRestoreEstimateResult}
     */
    OracleRestoreEstimateResult,

    /**
     * The OracleUpdate model constructor.
     * @property {module:model/OracleUpdate}
     */
    OracleUpdate,

    /**
     * The OracleUpdateCommon model constructor.
     * @property {module:model/OracleUpdateCommon}
     */
    OracleUpdateCommon,

    /**
     * The OracleValidateConfig model constructor.
     * @property {module:model/OracleValidateConfig}
     */
    OracleValidateConfig,

    /**
     * The ParentAppInfo model constructor.
     * @property {module:model/ParentAppInfo}
     */
    ParentAppInfo,

    /**
     * The PasswordRequirementsPatchRequest model constructor.
     * @property {module:model/PasswordRequirementsPatchRequest}
     */
    PasswordRequirementsPatchRequest,

    /**
     * The PasswordRequirementsSummary model constructor.
     * @property {module:model/PasswordRequirementsSummary}
     */
    PasswordRequirementsSummary,

    /**
     * The PatternStatus model constructor.
     * @property {module:model/PatternStatus}
     */
    PatternStatus,

    /**
     * The PerLocationCloudOutForecastSummary model constructor.
     * @property {module:model/PerLocationCloudOutForecastSummary}
     */
    PerLocationCloudOutForecastSummary,

    /**
     * The PerStorageClassCloudOutStorageForecastSummary model constructor.
     * @property {module:model/PerStorageClassCloudOutStorageForecastSummary}
     */
    PerStorageClassCloudOutStorageForecastSummary,

    /**
     * The PolicyCheckResult model constructor.
     * @property {module:model/PolicyCheckResult}
     */
    PolicyCheckResult,

    /**
     * The PolicyScopeEnum model constructor.
     * @property {module:model/PolicyScopeEnum}
     */
    PolicyScopeEnum,

    /**
     * The PolicyTypeEnum model constructor.
     * @property {module:model/PolicyTypeEnum}
     */
    PolicyTypeEnum,

    /**
     * The PrecheckFailureResult model constructor.
     * @property {module:model/PrecheckFailureResult}
     */
    PrecheckFailureResult,

    /**
     * The PrecheckStatusNextRunInfo model constructor.
     * @property {module:model/PrecheckStatusNextRunInfo}
     */
    PrecheckStatusNextRunInfo,

    /**
     * The PrecheckStatusResponse model constructor.
     * @property {module:model/PrecheckStatusResponse}
     */
    PrecheckStatusResponse,

    /**
     * The PreferredCdpNetworkProtocol model constructor.
     * @property {module:model/PreferredCdpNetworkProtocol}
     */
    PreferredCdpNetworkProtocol,

    /**
     * The PreferredCdpNetworkProtocolObject model constructor.
     * @property {module:model/PreferredCdpNetworkProtocolObject}
     */
    PreferredCdpNetworkProtocolObject,

    /**
     * The PrincipalSearchSortAttribute model constructor.
     * @property {module:model/PrincipalSearchSortAttribute}
     */
    PrincipalSearchSortAttribute,

    /**
     * The PrincipalSummaryV1 model constructor.
     * @property {module:model/PrincipalSummaryV1}
     */
    PrincipalSummaryV1,

    /**
     * The PrincipalSummaryV1ListResponse model constructor.
     * @property {module:model/PrincipalSummaryV1ListResponse}
     */
    PrincipalSummaryV1ListResponse,

    /**
     * The PrincipalType model constructor.
     * @property {module:model/PrincipalType}
     */
    PrincipalType,

    /**
     * The PrincipalWithRoleInfo model constructor.
     * @property {module:model/PrincipalWithRoleInfo}
     */
    PrincipalWithRoleInfo,

    /**
     * The ProtectedObjectsCount model constructor.
     * @property {module:model/ProtectedObjectsCount}
     */
    ProtectedObjectsCount,

    /**
     * The QuarterlyConfig model constructor.
     * @property {module:model/QuarterlyConfig}
     */
    QuarterlyConfig,

    /**
     * The RbsHostOperationRequest model constructor.
     * @property {module:model/RbsHostOperationRequest}
     */
    RbsHostOperationRequest,

    /**
     * The RbsHostOperationResponse model constructor.
     * @property {module:model/RbsHostOperationResponse}
     */
    RbsHostOperationResponse,

    /**
     * The RbsHostSummary model constructor.
     * @property {module:model/RbsHostSummary}
     */
    RbsHostSummary,

    /**
     * The RbsHostUserConfig model constructor.
     * @property {module:model/RbsHostUserConfig}
     */
    RbsHostUserConfig,

    /**
     * The ReaderRefreshDataSourcesRequest model constructor.
     * @property {module:model/ReaderRefreshDataSourcesRequest}
     */
    ReaderRefreshDataSourcesRequest,

    /**
     * The RefreshableObjectConnectionStatus model constructor.
     * @property {module:model/RefreshableObjectConnectionStatus}
     */
    RefreshableObjectConnectionStatus,

    /**
     * The RefreshableObjectConnectionStatusType model constructor.
     * @property {module:model/RefreshableObjectConnectionStatusType}
     */
    RefreshableObjectConnectionStatusType,

    /**
     * The RelocateMountConfig model constructor.
     * @property {module:model/RelocateMountConfig}
     */
    RelocateMountConfig,

    /**
     * The RemediationRequest model constructor.
     * @property {module:model/RemediationRequest}
     */
    RemediationRequest,

    /**
     * The RemediationRequestRunConfig model constructor.
     * @property {module:model/RemediationRequestRunConfig}
     */
    RemediationRequestRunConfig,

    /**
     * The RemediationRequestSpec model constructor.
     * @property {module:model/RemediationRequestSpec}
     */
    RemediationRequestSpec,

    /**
     * The RemediationResponse model constructor.
     * @property {module:model/RemediationResponse}
     */
    RemediationResponse,

    /**
     * The ReplicationSpec model constructor.
     * @property {module:model/ReplicationSpec}
     */
    ReplicationSpec,

    /**
     * The ReplicationType model constructor.
     * @property {module:model/ReplicationType}
     */
    ReplicationType,

    /**
     * The ReportConfigPatch model constructor.
     * @property {module:model/ReportConfigPatch}
     */
    ReportConfigPatch,

    /**
     * The ReportConfigResponse model constructor.
     * @property {module:model/ReportConfigResponse}
     */
    ReportConfigResponse,

    /**
     * The ReportableObjectType model constructor.
     * @property {module:model/ReportableObjectType}
     */
    ReportableObjectType,

    /**
     * The RequestErrorInfo model constructor.
     * @property {module:model/RequestErrorInfo}
     */
    RequestErrorInfo,

    /**
     * The RequestFailedException model constructor.
     * @property {module:model/RequestFailedException}
     */
    RequestFailedException,

    /**
     * The ResourceTagDefinition model constructor.
     * @property {module:model/ResourceTagDefinition}
     */
    ResourceTagDefinition,

    /**
     * The ResourceTagDeleteResponse model constructor.
     * @property {module:model/ResourceTagDeleteResponse}
     */
    ResourceTagDeleteResponse,

    /**
     * The ResourceTagDetail model constructor.
     * @property {module:model/ResourceTagDetail}
     */
    ResourceTagDetail,

    /**
     * The ResourceTagGetResponse model constructor.
     * @property {module:model/ResourceTagGetResponse}
     */
    ResourceTagGetResponse,

    /**
     * The ResourceTagUpdate model constructor.
     * @property {module:model/ResourceTagUpdate}
     */
    ResourceTagUpdate,

    /**
     * The RestoreFileJobConfig model constructor.
     * @property {module:model/RestoreFileJobConfig}
     */
    RestoreFileJobConfig,

    /**
     * The RestoreMssqlDbJobConfig model constructor.
     * @property {module:model/RestoreMssqlDbJobConfig}
     */
    RestoreMssqlDbJobConfig,

    /**
     * The RoleAssignmentRequest model constructor.
     * @property {module:model/RoleAssignmentRequest}
     */
    RoleAssignmentRequest,

    /**
     * The RoleInfo model constructor.
     * @property {module:model/RoleInfo}
     */
    RoleInfo,

    /**
     * The RoleInfoCreate model constructor.
     * @property {module:model/RoleInfoCreate}
     */
    RoleInfoCreate,

    /**
     * The RoleInfoListResponse model constructor.
     * @property {module:model/RoleInfoListResponse}
     */
    RoleInfoListResponse,

    /**
     * The RoleInfoUpdate model constructor.
     * @property {module:model/RoleInfoUpdate}
     */
    RoleInfoUpdate,

    /**
     * The RoleInfoWithPrincipals model constructor.
     * @property {module:model/RoleInfoWithPrincipals}
     */
    RoleInfoWithPrincipals,

    /**
     * The RoleListSortAttributes model constructor.
     * @property {module:model/RoleListSortAttributes}
     */
    RoleListSortAttributes,

    /**
     * The RsaMfaServerConfig model constructor.
     * @property {module:model/RsaMfaServerConfig}
     */
    RsaMfaServerConfig,

    /**
     * The RsaMfaServerConfigUpdate model constructor.
     * @property {module:model/RsaMfaServerConfigUpdate}
     */
    RsaMfaServerConfigUpdate,

    /**
     * The RsaMfaServerConfigWithoutSecrets model constructor.
     * @property {module:model/RsaMfaServerConfigWithoutSecrets}
     */
    RsaMfaServerConfigWithoutSecrets,

    /**
     * The RsaMfaServerDetail model constructor.
     * @property {module:model/RsaMfaServerDetail}
     */
    RsaMfaServerDetail,

    /**
     * The RsaMfaServerDetailListResponse model constructor.
     * @property {module:model/RsaMfaServerDetailListResponse}
     */
    RsaMfaServerDetailListResponse,

    /**
     * The RubrikMibFileDownloadLink model constructor.
     * @property {module:model/RubrikMibFileDownloadLink}
     */
    RubrikMibFileDownloadLink,

    /**
     * The RubrikSamlMetadataDetail model constructor.
     * @property {module:model/RubrikSamlMetadataDetail}
     */
    RubrikSamlMetadataDetail,

    /**
     * The RubrikSamlMetadataInfo model constructor.
     * @property {module:model/RubrikSamlMetadataInfo}
     */
    RubrikSamlMetadataInfo,

    /**
     * The RubrikSamlMetadataSummary model constructor.
     * @property {module:model/RubrikSamlMetadataSummary}
     */
    RubrikSamlMetadataSummary,

    /**
     * The RunPolicyArg model constructor.
     * @property {module:model/RunPolicyArg}
     */
    RunPolicyArg,

    /**
     * The SamlSsoAuthnRequestDetail model constructor.
     * @property {module:model/SamlSsoAuthnRequestDetail}
     */
    SamlSsoAuthnRequestDetail,

    /**
     * The SamlSsoAuthnRequestInfo model constructor.
     * @property {module:model/SamlSsoAuthnRequestInfo}
     */
    SamlSsoAuthnRequestInfo,

    /**
     * The SamlSsoStatus model constructor.
     * @property {module:model/SamlSsoStatus}
     */
    SamlSsoStatus,

    /**
     * The SapHanaAddSystemResponse model constructor.
     * @property {module:model/SapHanaAddSystemResponse}
     */
    SapHanaAddSystemResponse,

    /**
     * The SapHanaDataPathSpec model constructor.
     * @property {module:model/SapHanaDataPathSpec}
     */
    SapHanaDataPathSpec,

    /**
     * The SapHanaDataPathType model constructor.
     * @property {module:model/SapHanaDataPathType}
     */
    SapHanaDataPathType,

    /**
     * The SapHanaDatabaseDetail model constructor.
     * @property {module:model/SapHanaDatabaseDetail}
     */
    SapHanaDatabaseDetail,

    /**
     * The SapHanaDatabaseListSortAttribute model constructor.
     * @property {module:model/SapHanaDatabaseListSortAttribute}
     */
    SapHanaDatabaseListSortAttribute,

    /**
     * The SapHanaDatabasePatch model constructor.
     * @property {module:model/SapHanaDatabasePatch}
     */
    SapHanaDatabasePatch,

    /**
     * The SapHanaDatabaseSnapshotDetail model constructor.
     * @property {module:model/SapHanaDatabaseSnapshotDetail}
     */
    SapHanaDatabaseSnapshotDetail,

    /**
     * The SapHanaDatabaseSnapshotSummary model constructor.
     * @property {module:model/SapHanaDatabaseSnapshotSummary}
     */
    SapHanaDatabaseSnapshotSummary,

    /**
     * The SapHanaDatabaseSnapshotSummaryListResponse model constructor.
     * @property {module:model/SapHanaDatabaseSnapshotSummaryListResponse}
     */
    SapHanaDatabaseSnapshotSummaryListResponse,

    /**
     * The SapHanaDatabaseSummary model constructor.
     * @property {module:model/SapHanaDatabaseSummary}
     */
    SapHanaDatabaseSummary,

    /**
     * The SapHanaDatabaseSummaryListResponse model constructor.
     * @property {module:model/SapHanaDatabaseSummaryListResponse}
     */
    SapHanaDatabaseSummaryListResponse,

    /**
     * The SapHanaHost model constructor.
     * @property {module:model/SapHanaHost}
     */
    SapHanaHost,

    /**
     * The SapHanaPatchSystemResponse model constructor.
     * @property {module:model/SapHanaPatchSystemResponse}
     */
    SapHanaPatchSystemResponse,

    /**
     * The SapHanaRecoverableRange model constructor.
     * @property {module:model/SapHanaRecoverableRange}
     */
    SapHanaRecoverableRange,

    /**
     * The SapHanaRecoverableRangeListResponse model constructor.
     * @property {module:model/SapHanaRecoverableRangeListResponse}
     */
    SapHanaRecoverableRangeListResponse,

    /**
     * The SapHanaRestoreSourceConfig model constructor.
     * @property {module:model/SapHanaRestoreSourceConfig}
     */
    SapHanaRestoreSourceConfig,

    /**
     * The SapHanaSslInfo model constructor.
     * @property {module:model/SapHanaSslInfo}
     */
    SapHanaSslInfo,

    /**
     * The SapHanaSystemConfig model constructor.
     * @property {module:model/SapHanaSystemConfig}
     */
    SapHanaSystemConfig,

    /**
     * The SapHanaSystemDataPathSpec model constructor.
     * @property {module:model/SapHanaSystemDataPathSpec}
     */
    SapHanaSystemDataPathSpec,

    /**
     * The SapHanaSystemInfo model constructor.
     * @property {module:model/SapHanaSystemInfo}
     */
    SapHanaSystemInfo,

    /**
     * The SapHanaSystemListSortAttribute model constructor.
     * @property {module:model/SapHanaSystemListSortAttribute}
     */
    SapHanaSystemListSortAttribute,

    /**
     * The SapHanaSystemPatch model constructor.
     * @property {module:model/SapHanaSystemPatch}
     */
    SapHanaSystemPatch,

    /**
     * The SapHanaSystemSummary model constructor.
     * @property {module:model/SapHanaSystemSummary}
     */
    SapHanaSystemSummary,

    /**
     * The SapHanaSystemSummaryListResponse model constructor.
     * @property {module:model/SapHanaSystemSummaryListResponse}
     */
    SapHanaSystemSummaryListResponse,

    /**
     * The ScriptErrorAction model constructor.
     * @property {module:model/ScriptErrorAction}
     */
    ScriptErrorAction,

    /**
     * The SearchResponse model constructor.
     * @property {module:model/SearchResponse}
     */
    SearchResponse,

    /**
     * The SearchResponseListResponse model constructor.
     * @property {module:model/SearchResponseListResponse}
     */
    SearchResponseListResponse,

    /**
     * The SessionSummary model constructor.
     * @property {module:model/SessionSummary}
     */
    SessionSummary,

    /**
     * The SlaAssignable model constructor.
     * @property {module:model/SlaAssignable}
     */
    SlaAssignable,

    /**
     * The SlaAssignment model constructor.
     * @property {module:model/SlaAssignment}
     */
    SlaAssignment,

    /**
     * The SlaConflictsSummary model constructor.
     * @property {module:model/SlaConflictsSummary}
     */
    SlaConflictsSummary,

    /**
     * The SlaDayOfMonth model constructor.
     * @property {module:model/SlaDayOfMonth}
     */
    SlaDayOfMonth,

    /**
     * The SlaDayOfQuarter model constructor.
     * @property {module:model/SlaDayOfQuarter}
     */
    SlaDayOfQuarter,

    /**
     * The SlaDayOfWeek model constructor.
     * @property {module:model/SlaDayOfWeek}
     */
    SlaDayOfWeek,

    /**
     * The SlaDayOfYear model constructor.
     * @property {module:model/SlaDayOfYear}
     */
    SlaDayOfYear,

    /**
     * The SlaDomainDefinition model constructor.
     * @property {module:model/SlaDomainDefinition}
     */
    SlaDomainDefinition,

    /**
     * The SlaDomainPatchDefinition model constructor.
     * @property {module:model/SlaDomainPatchDefinition}
     */
    SlaDomainPatchDefinition,

    /**
     * The SlaDomainSummary model constructor.
     * @property {module:model/SlaDomainSummary}
     */
    SlaDomainSummary,

    /**
     * The SlaDomainSummaryListResponse model constructor.
     * @property {module:model/SlaDomainSummaryListResponse}
     */
    SlaDomainSummaryListResponse,

    /**
     * The SlaFrequency model constructor.
     * @property {module:model/SlaFrequency}
     */
    SlaFrequency,

    /**
     * The SlaFrequencyV2 model constructor.
     * @property {module:model/SlaFrequencyV2}
     */
    SlaFrequencyV2,

    /**
     * The SlaMonth model constructor.
     * @property {module:model/SlaMonth}
     */
    SlaMonth,

    /**
     * The SlaObjectCounts model constructor.
     * @property {module:model/SlaObjectCounts}
     */
    SlaObjectCounts,

    /**
     * The SlaStartTimeAttributes model constructor.
     * @property {module:model/SlaStartTimeAttributes}
     */
    SlaStartTimeAttributes,

    /**
     * The SlaTimeUnit model constructor.
     * @property {module:model/SlaTimeUnit}
     */
    SlaTimeUnit,

    /**
     * The Snappable model constructor.
     * @property {module:model/Snappable}
     */
    Snappable,

    /**
     * The SnappablePrivilegeStatus model constructor.
     * @property {module:model/SnappablePrivilegeStatus}
     */
    SnappablePrivilegeStatus,

    /**
     * The SnappableRecoveryInfo model constructor.
     * @property {module:model/SnappableRecoveryInfo}
     */
    SnappableRecoveryInfo,

    /**
     * The SnapshotCloudStorageTier model constructor.
     * @property {module:model/SnapshotCloudStorageTier}
     */
    SnapshotCloudStorageTier,

    /**
     * The SnapshotEventSeries model constructor.
     * @property {module:model/SnapshotEventSeries}
     */
    SnapshotEventSeries,

    /**
     * The SnapshotLocationRetentionInfo model constructor.
     * @property {module:model/SnapshotLocationRetentionInfo}
     */
    SnapshotLocationRetentionInfo,

    /**
     * The SnapshotRetentionInfo model constructor.
     * @property {module:model/SnapshotRetentionInfo}
     */
    SnapshotRetentionInfo,

    /**
     * The SnapshotSortAttribute model constructor.
     * @property {module:model/SnapshotSortAttribute}
     */
    SnapshotSortAttribute,

    /**
     * The SnapshotStorageStats model constructor.
     * @property {module:model/SnapshotStorageStats}
     */
    SnapshotStorageStats,

    /**
     * The SnapshotSummary model constructor.
     * @property {module:model/SnapshotSummary}
     */
    SnapshotSummary,

    /**
     * The SnapshotSummaryListResponse model constructor.
     * @property {module:model/SnapshotSummaryListResponse}
     */
    SnapshotSummaryListResponse,

    /**
     * The SnapshotType model constructor.
     * @property {module:model/SnapshotType}
     */
    SnapshotType,

    /**
     * The SoftwareAvailability model constructor.
     * @property {module:model/SoftwareAvailability}
     */
    SoftwareAvailability,

    /**
     * The SortColumn model constructor.
     * @property {module:model/SortColumn}
     */
    SortColumn,

    /**
     * The SortOrder model constructor.
     * @property {module:model/SortOrder}
     */
    SortOrder,

    /**
     * The StageCdmSoftwareInfo model constructor.
     * @property {module:model/StageCdmSoftwareInfo}
     */
    StageCdmSoftwareInfo,

    /**
     * The StaticIpInfo model constructor.
     * @property {module:model/StaticIpInfo}
     */
    StaticIpInfo,

    /**
     * The Status model constructor.
     * @property {module:model/Status}
     */
    Status,

    /**
     * The StringResponse model constructor.
     * @property {module:model/StringResponse}
     */
    StringResponse,

    /**
     * The SubscriptionAttachmentType model constructor.
     * @property {module:model/SubscriptionAttachmentType}
     */
    SubscriptionAttachmentType,

    /**
     * The SubscriptionOwner model constructor.
     * @property {module:model/SubscriptionOwner}
     */
    SubscriptionOwner,

    /**
     * The SubscriptionScheduleTimeAttributes model constructor.
     * @property {module:model/SubscriptionScheduleTimeAttributes}
     */
    SubscriptionScheduleTimeAttributes,

    /**
     * The SubscriptionStatus model constructor.
     * @property {module:model/SubscriptionStatus}
     */
    SubscriptionStatus,

    /**
     * The SupportDataConfig model constructor.
     * @property {module:model/SupportDataConfig}
     */
    SupportDataConfig,

    /**
     * The SupportDataType model constructor.
     * @property {module:model/SupportDataType}
     */
    SupportDataType,

    /**
     * The SupportDataTypeConfig model constructor.
     * @property {module:model/SupportDataTypeConfig}
     */
    SupportDataTypeConfig,

    /**
     * The SupportDataTypeStatus model constructor.
     * @property {module:model/SupportDataTypeStatus}
     */
    SupportDataTypeStatus,

    /**
     * The SyslogExportRuleFull model constructor.
     * @property {module:model/SyslogExportRuleFull}
     */
    SyslogExportRuleFull,

    /**
     * The SyslogExportRulePartial model constructor.
     * @property {module:model/SyslogExportRulePartial}
     */
    SyslogExportRulePartial,

    /**
     * The SyslogExportRuleSummary model constructor.
     * @property {module:model/SyslogExportRuleSummary}
     */
    SyslogExportRuleSummary,

    /**
     * The SyslogExportRuleSummaryListResponse model constructor.
     * @property {module:model/SyslogExportRuleSummaryListResponse}
     */
    SyslogExportRuleSummaryListResponse,

    /**
     * The SyslogFacility model constructor.
     * @property {module:model/SyslogFacility}
     */
    SyslogFacility,

    /**
     * The SyslogMsgMibFileDownloadLink model constructor.
     * @property {module:model/SyslogMsgMibFileDownloadLink}
     */
    SyslogMsgMibFileDownloadLink,

    /**
     * The SyslogServerTestResult model constructor.
     * @property {module:model/SyslogServerTestResult}
     */
    SyslogServerTestResult,

    /**
     * The SyslogSeverity model constructor.
     * @property {module:model/SyslogSeverity}
     */
    SyslogSeverity,

    /**
     * The SyslogTcMibFileDownloadLink model constructor.
     * @property {module:model/SyslogTcMibFileDownloadLink}
     */
    SyslogTcMibFileDownloadLink,

    /**
     * The TelemetryConfig model constructor.
     * @property {module:model/TelemetryConfig}
     */
    TelemetryConfig,

    /**
     * The TelemetryLevel model constructor.
     * @property {module:model/TelemetryLevel}
     */
    TelemetryLevel,

    /**
     * The TotpConfigUpdateRequest model constructor.
     * @property {module:model/TotpConfigUpdateRequest}
     */
    TotpConfigUpdateRequest,

    /**
     * The TotpGlobalSetting model constructor.
     * @property {module:model/TotpGlobalSetting}
     */
    TotpGlobalSetting,

    /**
     * The TotpGlobalSettingUpdate model constructor.
     * @property {module:model/TotpGlobalSettingUpdate}
     */
    TotpGlobalSettingUpdate,

    /**
     * The TotpSecret model constructor.
     * @property {module:model/TotpSecret}
     */
    TotpSecret,

    /**
     * The TotpStatus model constructor.
     * @property {module:model/TotpStatus}
     */
    TotpStatus,

    /**
     * The TransportLayerProtocol model constructor.
     * @property {module:model/TransportLayerProtocol}
     */
    TransportLayerProtocol,

    /**
     * The TruststorePayload model constructor.
     * @property {module:model/TruststorePayload}
     */
    TruststorePayload,

    /**
     * The TruststoreSummary model constructor.
     * @property {module:model/TruststoreSummary}
     */
    TruststoreSummary,

    /**
     * The TruststoreSummaryListResponse model constructor.
     * @property {module:model/TruststoreSummaryListResponse}
     */
    TruststoreSummaryListResponse,

    /**
     * The TruststoreType model constructor.
     * @property {module:model/TruststoreType}
     */
    TruststoreType,

    /**
     * The UnmanagedObjectDetails model constructor.
     * @property {module:model/UnmanagedObjectDetails}
     */
    UnmanagedObjectDetails,

    /**
     * The UnmanagedObjectDetailsListResponse model constructor.
     * @property {module:model/UnmanagedObjectDetailsListResponse}
     */
    UnmanagedObjectDetailsListResponse,

    /**
     * The UnmanagedObjectSlaAssignmentInfo model constructor.
     * @property {module:model/UnmanagedObjectSlaAssignmentInfo}
     */
    UnmanagedObjectSlaAssignmentInfo,

    /**
     * The UnmanagedObjectSortAttribute model constructor.
     * @property {module:model/UnmanagedObjectSortAttribute}
     */
    UnmanagedObjectSortAttribute,

    /**
     * The UnmanagedObjectStatus model constructor.
     * @property {module:model/UnmanagedObjectStatus}
     */
    UnmanagedObjectStatus,

    /**
     * The UnmanagedObjectSummary model constructor.
     * @property {module:model/UnmanagedObjectSummary}
     */
    UnmanagedObjectSummary,

    /**
     * The UnmanagedObjectSummaryListResponse model constructor.
     * @property {module:model/UnmanagedObjectSummaryListResponse}
     */
    UnmanagedObjectSummaryListResponse,

    /**
     * The UnmanagedObjectType model constructor.
     * @property {module:model/UnmanagedObjectType}
     */
    UnmanagedObjectType,

    /**
     * The UnmanagedSnapshotType model constructor.
     * @property {module:model/UnmanagedSnapshotType}
     */
    UnmanagedSnapshotType,

    /**
     * The UpdateMountConfig model constructor.
     * @property {module:model/UpdateMountConfig}
     */
    UpdateMountConfig,

    /**
     * The UserActionV1 model constructor.
     * @property {module:model/UserActionV1}
     */
    UserActionV1,

    /**
     * The VappAttributes model constructor.
     * @property {module:model/VappAttributes}
     */
    VappAttributes,

    /**
     * The VappExportMode model constructor.
     * @property {module:model/VappExportMode}
     */
    VappExportMode,

    /**
     * The VappExportOptions model constructor.
     * @property {module:model/VappExportOptions}
     */
    VappExportOptions,

    /**
     * The VappExportSnapshotJobConfig model constructor.
     * @property {module:model/VappExportSnapshotJobConfig}
     */
    VappExportSnapshotJobConfig,

    /**
     * The VappInstantRecoveryJobConfig model constructor.
     * @property {module:model/VappInstantRecoveryJobConfig}
     */
    VappInstantRecoveryJobConfig,

    /**
     * The VappInstantRecoveryOptions model constructor.
     * @property {module:model/VappInstantRecoveryOptions}
     */
    VappInstantRecoveryOptions,

    /**
     * The VappNetworkMode model constructor.
     * @property {module:model/VappNetworkMode}
     */
    VappNetworkMode,

    /**
     * The VappNetworkSummary model constructor.
     * @property {module:model/VappNetworkSummary}
     */
    VappNetworkSummary,

    /**
     * The VappTemplateExportJobConfig model constructor.
     * @property {module:model/VappTemplateExportJobConfig}
     */
    VappTemplateExportJobConfig,

    /**
     * The VappTemplateExportOptions model constructor.
     * @property {module:model/VappTemplateExportOptions}
     */
    VappTemplateExportOptions,

    /**
     * The VappTemplateExportOptionsUnion model constructor.
     * @property {module:model/VappTemplateExportOptionsUnion}
     */
    VappTemplateExportOptionsUnion,

    /**
     * The VappVmDetail model constructor.
     * @property {module:model/VappVmDetail}
     */
    VappVmDetail,

    /**
     * The VappVmIpAddressingMode model constructor.
     * @property {module:model/VappVmIpAddressingMode}
     */
    VappVmIpAddressingMode,

    /**
     * The VappVmNetworkConnection model constructor.
     * @property {module:model/VappVmNetworkConnection}
     */
    VappVmNetworkConnection,

    /**
     * The VappVmRestoreSpec model constructor.
     * @property {module:model/VappVmRestoreSpec}
     */
    VappVmRestoreSpec,

    /**
     * The VappVmSummary model constructor.
     * @property {module:model/VappVmSummary}
     */
    VappVmSummary,

    /**
     * The VcdClusterBaseConfig model constructor.
     * @property {module:model/VcdClusterBaseConfig}
     */
    VcdClusterBaseConfig,

    /**
     * The VcdClusterConfig model constructor.
     * @property {module:model/VcdClusterConfig}
     */
    VcdClusterConfig,

    /**
     * The VcdClusterDetail model constructor.
     * @property {module:model/VcdClusterDetail}
     */
    VcdClusterDetail,

    /**
     * The VcdClusterListSortAttribute model constructor.
     * @property {module:model/VcdClusterListSortAttribute}
     */
    VcdClusterListSortAttribute,

    /**
     * The VcdClusterPatch model constructor.
     * @property {module:model/VcdClusterPatch}
     */
    VcdClusterPatch,

    /**
     * The VcdClusterSummary model constructor.
     * @property {module:model/VcdClusterSummary}
     */
    VcdClusterSummary,

    /**
     * The VcdClusterSummaryListResponse model constructor.
     * @property {module:model/VcdClusterSummaryListResponse}
     */
    VcdClusterSummaryListResponse,

    /**
     * The VcdConnectionStatus model constructor.
     * @property {module:model/VcdConnectionStatus}
     */
    VcdConnectionStatus,

    /**
     * The VcdHierarchyObjectAttributes model constructor.
     * @property {module:model/VcdHierarchyObjectAttributes}
     */
    VcdHierarchyObjectAttributes,

    /**
     * The VcdHierarchyObjectDescendantCount model constructor.
     * @property {module:model/VcdHierarchyObjectDescendantCount}
     */
    VcdHierarchyObjectDescendantCount,

    /**
     * The VcdHierarchyObjectSortAttribute model constructor.
     * @property {module:model/VcdHierarchyObjectSortAttribute}
     */
    VcdHierarchyObjectSortAttribute,

    /**
     * The VcdHierarchyObjectSummary model constructor.
     * @property {module:model/VcdHierarchyObjectSummary}
     */
    VcdHierarchyObjectSummary,

    /**
     * The VcdHierarchyObjectSummaryListResponse model constructor.
     * @property {module:model/VcdHierarchyObjectSummaryListResponse}
     */
    VcdHierarchyObjectSummaryListResponse,

    /**
     * The VcdObjectType model constructor.
     * @property {module:model/VcdObjectType}
     */
    VcdObjectType,

    /**
     * The VcdOrgVdcStorageProfile model constructor.
     * @property {module:model/VcdOrgVdcStorageProfile}
     */
    VcdOrgVdcStorageProfile,

    /**
     * The VcdVappDetail model constructor.
     * @property {module:model/VcdVappDetail}
     */
    VcdVappDetail,

    /**
     * The VcdVappObjectSortAttribute model constructor.
     * @property {module:model/VcdVappObjectSortAttribute}
     */
    VcdVappObjectSortAttribute,

    /**
     * The VcdVappPatch model constructor.
     * @property {module:model/VcdVappPatch}
     */
    VcdVappPatch,

    /**
     * The VcdVappSlaObjectCount model constructor.
     * @property {module:model/VcdVappSlaObjectCount}
     */
    VcdVappSlaObjectCount,

    /**
     * The VcdVappSnapshotDetail model constructor.
     * @property {module:model/VcdVappSnapshotDetail}
     */
    VcdVappSnapshotDetail,

    /**
     * The VcdVappSnapshotSummary model constructor.
     * @property {module:model/VcdVappSnapshotSummary}
     */
    VcdVappSnapshotSummary,

    /**
     * The VcdVappSnapshotSummaryDetailSharedFields model constructor.
     * @property {module:model/VcdVappSnapshotSummaryDetailSharedFields}
     */
    VcdVappSnapshotSummaryDetailSharedFields,

    /**
     * The VcdVappSnapshotSummaryListResponse model constructor.
     * @property {module:model/VcdVappSnapshotSummaryListResponse}
     */
    VcdVappSnapshotSummaryListResponse,

    /**
     * The VcdVappSummary model constructor.
     * @property {module:model/VcdVappSummary}
     */
    VcdVappSummary,

    /**
     * The VcdVappSummaryListResponse model constructor.
     * @property {module:model/VcdVappSummaryListResponse}
     */
    VcdVappSummaryListResponse,

    /**
     * The VcdVmSnapshotDetail model constructor.
     * @property {module:model/VcdVmSnapshotDetail}
     */
    VcdVmSnapshotDetail,

    /**
     * The VcdVmSnapshotSummary model constructor.
     * @property {module:model/VcdVmSnapshotSummary}
     */
    VcdVmSnapshotSummary,

    /**
     * The VcenterConfig model constructor.
     * @property {module:model/VcenterConfig}
     */
    VcenterConfig,

    /**
     * The VcenterConnectionConfig model constructor.
     * @property {module:model/VcenterConnectionConfig}
     */
    VcenterConnectionConfig,

    /**
     * The VcenterDetail model constructor.
     * @property {module:model/VcenterDetail}
     */
    VcenterDetail,

    /**
     * The VcenterPatch model constructor.
     * @property {module:model/VcenterPatch}
     */
    VcenterPatch,

    /**
     * The VcenterPreAddConfig model constructor.
     * @property {module:model/VcenterPreAddConfig}
     */
    VcenterPreAddConfig,

    /**
     * The VcenterPreAddInfo model constructor.
     * @property {module:model/VcenterPreAddInfo}
     */
    VcenterPreAddInfo,

    /**
     * The VcenterSummary model constructor.
     * @property {module:model/VcenterSummary}
     */
    VcenterSummary,

    /**
     * The VcenterSummaryListResponse model constructor.
     * @property {module:model/VcenterSummaryListResponse}
     */
    VcenterSummaryListResponse,

    /**
     * The VerificationParameters model constructor.
     * @property {module:model/VerificationParameters}
     */
    VerificationParameters,

    /**
     * The VerificationResponse model constructor.
     * @property {module:model/VerificationResponse}
     */
    VerificationResponse,

    /**
     * The VimserverSummary model constructor.
     * @property {module:model/VimserverSummary}
     */
    VimserverSummary,

    /**
     * The VimserverSummaryListResponse model constructor.
     * @property {module:model/VimserverSummaryListResponse}
     */
    VimserverSummaryListResponse,

    /**
     * The VirtualDiskDetail model constructor.
     * @property {module:model/VirtualDiskDetail}
     */
    VirtualDiskDetail,

    /**
     * The VirtualDiskUpdate model constructor.
     * @property {module:model/VirtualDiskUpdate}
     */
    VirtualDiskUpdate,

    /**
     * The VirtualMachineDetail model constructor.
     * @property {module:model/VirtualMachineDetail}
     */
    VirtualMachineDetail,

    /**
     * The VirtualMachineScriptDetail model constructor.
     * @property {module:model/VirtualMachineScriptDetail}
     */
    VirtualMachineScriptDetail,

    /**
     * The VirtualMachineSummary model constructor.
     * @property {module:model/VirtualMachineSummary}
     */
    VirtualMachineSummary,

    /**
     * The VirtualMachineSummaryListResponse model constructor.
     * @property {module:model/VirtualMachineSummaryListResponse}
     */
    VirtualMachineSummaryListResponse,

    /**
     * The VirtualMachineUpdate model constructor.
     * @property {module:model/VirtualMachineUpdate}
     */
    VirtualMachineUpdate,

    /**
     * The VirtualMachineUpdateWithSecret model constructor.
     * @property {module:model/VirtualMachineUpdateWithSecret}
     */
    VirtualMachineUpdateWithSecret,

    /**
     * The VmForceFullRequest model constructor.
     * @property {module:model/VmForceFullRequest}
     */
    VmForceFullRequest,

    /**
     * The VmForceFullResponse model constructor.
     * @property {module:model/VmForceFullResponse}
     */
    VmForceFullResponse,

    /**
     * The VmGuestScriptRunConfig model constructor.
     * @property {module:model/VmGuestScriptRunConfig}
     */
    VmGuestScriptRunConfig,

    /**
     * The VmPathPoint model constructor.
     * @property {module:model/VmPathPoint}
     */
    VmPathPoint,

    /**
     * The VmSnapshotDetail model constructor.
     * @property {module:model/VmSnapshotDetail}
     */
    VmSnapshotDetail,

    /**
     * The VmSnapshotDiskDetail model constructor.
     * @property {module:model/VmSnapshotDiskDetail}
     */
    VmSnapshotDiskDetail,

    /**
     * The VmSnapshotSummaries model constructor.
     * @property {module:model/VmSnapshotSummaries}
     */
    VmSnapshotSummaries,

    /**
     * The VmSnapshotSummary model constructor.
     * @property {module:model/VmSnapshotSummary}
     */
    VmSnapshotSummary,

    /**
     * The VmSnapshotSummaryListResponse model constructor.
     * @property {module:model/VmSnapshotSummaryListResponse}
     */
    VmSnapshotSummaryListResponse,

    /**
     * The VmwareAdaptiveThrottlingSettings model constructor.
     * @property {module:model/VmwareAdaptiveThrottlingSettings}
     */
    VmwareAdaptiveThrottlingSettings,

    /**
     * The VmwareCdpLiveInfo model constructor.
     * @property {module:model/VmwareCdpLiveInfo}
     */
    VmwareCdpLiveInfo,

    /**
     * The VmwareCdpStateInfo model constructor.
     * @property {module:model/VmwareCdpStateInfo}
     */
    VmwareCdpStateInfo,

    /**
     * The VmwareHierarchyInfo model constructor.
     * @property {module:model/VmwareHierarchyInfo}
     */
    VmwareHierarchyInfo,

    /**
     * The VmwareHierarchyInfoListResponse model constructor.
     * @property {module:model/VmwareHierarchyInfoListResponse}
     */
    VmwareHierarchyInfoListResponse,

    /**
     * The VmwareHierarchyObjectType model constructor.
     * @property {module:model/VmwareHierarchyObjectType}
     */
    VmwareHierarchyObjectType,

    /**
     * The VmwareHostDatastoreDetail model constructor.
     * @property {module:model/VmwareHostDatastoreDetail}
     */
    VmwareHostDatastoreDetail,

    /**
     * The VmwareHostDetail model constructor.
     * @property {module:model/VmwareHostDetail}
     */
    VmwareHostDetail,

    /**
     * The VmwareHostSummary model constructor.
     * @property {module:model/VmwareHostSummary}
     */
    VmwareHostSummary,

    /**
     * The VmwareHostSummaryListResponse model constructor.
     * @property {module:model/VmwareHostSummaryListResponse}
     */
    VmwareHostSummaryListResponse,

    /**
     * The VmwareHostUpdate model constructor.
     * @property {module:model/VmwareHostUpdate}
     */
    VmwareHostUpdate,

    /**
     * The VmwareNetworkCollection model constructor.
     * @property {module:model/VmwareNetworkCollection}
     */
    VmwareNetworkCollection,

    /**
     * The VmwareNetworkDeviceInfo model constructor.
     * @property {module:model/VmwareNetworkDeviceInfo}
     */
    VmwareNetworkDeviceInfo,

    /**
     * The VmwareNetworkInfo model constructor.
     * @property {module:model/VmwareNetworkInfo}
     */
    VmwareNetworkInfo,

    /**
     * The VmwareNetworkType model constructor.
     * @property {module:model/VmwareNetworkType}
     */
    VmwareNetworkType,

    /**
     * The VmwareRecoverableRange model constructor.
     * @property {module:model/VmwareRecoverableRange}
     */
    VmwareRecoverableRange,

    /**
     * The VmwareRecoverableRangeListResponse model constructor.
     * @property {module:model/VmwareRecoverableRangeListResponse}
     */
    VmwareRecoverableRangeListResponse,

    /**
     * The VmwareVNicBindingInfo model constructor.
     * @property {module:model/VmwareVNicBindingInfo}
     */
    VmwareVNicBindingInfo,

    /**
     * The VmwareVdiskForceFullInfo model constructor.
     * @property {module:model/VmwareVdiskForceFullInfo}
     */
    VmwareVdiskForceFullInfo,

    /**
     * The VmwareVmMissedRecoverableRanges model constructor.
     * @property {module:model/VmwareVmMissedRecoverableRanges}
     */
    VmwareVmMissedRecoverableRanges,

    /**
     * The VmwareVmMountDetailV1 model constructor.
     * @property {module:model/VmwareVmMountDetailV1}
     */
    VmwareVmMountDetailV1,

    /**
     * The VmwareVmMountSummaryV1 model constructor.
     * @property {module:model/VmwareVmMountSummaryV1}
     */
    VmwareVmMountSummaryV1,

    /**
     * The VmwareVmMountSummaryV1ListResponse model constructor.
     * @property {module:model/VmwareVmMountSummaryV1ListResponse}
     */
    VmwareVmMountSummaryV1ListResponse,

    /**
     * The VmwareVmRecoverableRanges model constructor.
     * @property {module:model/VmwareVmRecoverableRanges}
     */
    VmwareVmRecoverableRanges,

    /**
     * The VolumeGroupDetail model constructor.
     * @property {module:model/VolumeGroupDetail}
     */
    VolumeGroupDetail,

    /**
     * The VolumeGroupForceFullRequest model constructor.
     * @property {module:model/VolumeGroupForceFullRequest}
     */
    VolumeGroupForceFullRequest,

    /**
     * The VolumeGroupForceFullResponse model constructor.
     * @property {module:model/VolumeGroupForceFullResponse}
     */
    VolumeGroupForceFullResponse,

    /**
     * The VolumeGroupListSortAttribute model constructor.
     * @property {module:model/VolumeGroupListSortAttribute}
     */
    VolumeGroupListSortAttribute,

    /**
     * The VolumeGroupMountListSortAttribute model constructor.
     * @property {module:model/VolumeGroupMountListSortAttribute}
     */
    VolumeGroupMountListSortAttribute,

    /**
     * The VolumeGroupMountSummary model constructor.
     * @property {module:model/VolumeGroupMountSummary}
     */
    VolumeGroupMountSummary,

    /**
     * The VolumeGroupMountSummaryListResponse model constructor.
     * @property {module:model/VolumeGroupMountSummaryListResponse}
     */
    VolumeGroupMountSummaryListResponse,

    /**
     * The VolumeGroupOnDemandSnapshotConfig model constructor.
     * @property {module:model/VolumeGroupOnDemandSnapshotConfig}
     */
    VolumeGroupOnDemandSnapshotConfig,

    /**
     * The VolumeGroupPatch model constructor.
     * @property {module:model/VolumeGroupPatch}
     */
    VolumeGroupPatch,

    /**
     * The VolumeGroupReleaseVersion model constructor.
     * @property {module:model/VolumeGroupReleaseVersion}
     */
    VolumeGroupReleaseVersion,

    /**
     * The VolumeGroupRestoreVolumeSpec model constructor.
     * @property {module:model/VolumeGroupRestoreVolumeSpec}
     */
    VolumeGroupRestoreVolumeSpec,

    /**
     * The VolumeGroupRestoreVolumesConfig model constructor.
     * @property {module:model/VolumeGroupRestoreVolumesConfig}
     */
    VolumeGroupRestoreVolumesConfig,

    /**
     * The VolumeGroupSnapshotDetail model constructor.
     * @property {module:model/VolumeGroupSnapshotDetail}
     */
    VolumeGroupSnapshotDetail,

    /**
     * The VolumeGroupSnapshotSummary model constructor.
     * @property {module:model/VolumeGroupSnapshotSummary}
     */
    VolumeGroupSnapshotSummary,

    /**
     * The VolumeGroupSnapshotSummaryListResponse model constructor.
     * @property {module:model/VolumeGroupSnapshotSummaryListResponse}
     */
    VolumeGroupSnapshotSummaryListResponse,

    /**
     * The VolumeGroupSnapshotVolumeSummary model constructor.
     * @property {module:model/VolumeGroupSnapshotVolumeSummary}
     */
    VolumeGroupSnapshotVolumeSummary,

    /**
     * The VolumeGroupSummary model constructor.
     * @property {module:model/VolumeGroupSummary}
     */
    VolumeGroupSummary,

    /**
     * The VolumeGroupSummaryListResponse model constructor.
     * @property {module:model/VolumeGroupSummaryListResponse}
     */
    VolumeGroupSummaryListResponse,

    /**
     * The VolumeMountInfo model constructor.
     * @property {module:model/VolumeMountInfo}
     */
    VolumeMountInfo,

    /**
     * The WebServerCertificatePayload model constructor.
     * @property {module:model/WebServerCertificatePayload}
     */
    WebServerCertificatePayload,

    /**
     * The WebServerCertificateSummary model constructor.
     * @property {module:model/WebServerCertificateSummary}
     */
    WebServerCertificateSummary,

    /**
     * The WeeklyConfig model constructor.
     * @property {module:model/WeeklyConfig}
     */
    WeeklyConfig,

    /**
     * The WindowsClusterDetail model constructor.
     * @property {module:model/WindowsClusterDetail}
     */
    WindowsClusterDetail,

    /**
     * The WindowsClusterSummary model constructor.
     * @property {module:model/WindowsClusterSummary}
     */
    WindowsClusterSummary,

    /**
     * The WindowsClusterSummaryListResponse model constructor.
     * @property {module:model/WindowsClusterSummaryListResponse}
     */
    WindowsClusterSummaryListResponse,

    /**
     * The YearlyConfig model constructor.
     * @property {module:model/YearlyConfig}
     */
    YearlyConfig,

    /**
    * The ArchiveApi service constructor.
    * @property {module:api/ArchiveApi}
    */
    ArchiveApi,

    /**
    * The AuthorizationApi service constructor.
    * @property {module:api/AuthorizationApi}
    */
    AuthorizationApi,

    /**
    * The BackupApi service constructor.
    * @property {module:api/BackupApi}
    */
    BackupApi,

    /**
    * The BlackoutWindowApi service constructor.
    * @property {module:api/BlackoutWindowApi}
    */
    BlackoutWindowApi,

    /**
    * The CertificateApi service constructor.
    * @property {module:api/CertificateApi}
    */
    CertificateApi,

    /**
    * The CertificateAgentApi service constructor.
    * @property {module:api/CertificateAgentApi}
    */
    CertificateAgentApi,

    /**
    * The CloudUtilizationApi service constructor.
    * @property {module:api/CloudUtilizationApi}
    */
    CloudUtilizationApi,

    /**
    * The ClusterApi service constructor.
    * @property {module:api/ClusterApi}
    */
    ClusterApi,

    /**
    * The ConfigHistoryApi service constructor.
    * @property {module:api/ConfigHistoryApi}
    */
    ConfigHistoryApi,

    /**
    * The CsrApi service constructor.
    * @property {module:api/CsrApi}
    */
    CsrApi,

    /**
    * The DataSourceApi service constructor.
    * @property {module:api/DataSourceApi}
    */
    DataSourceApi,

    /**
    * The DatabaseLogReportApi service constructor.
    * @property {module:api/DatabaseLogReportApi}
    */
    DatabaseLogReportApi,

    /**
    * The EventApi service constructor.
    * @property {module:api/EventApi}
    */
    EventApi,

    /**
    * The EventSeriesApi service constructor.
    * @property {module:api/EventSeriesApi}
    */
    EventSeriesApi,

    /**
    * The ExclusionPatternApi service constructor.
    * @property {module:api/ExclusionPatternApi}
    */
    ExclusionPatternApi,

    /**
    * The FailoverClusterApi service constructor.
    * @property {module:api/FailoverClusterApi}
    */
    FailoverClusterApi,

    /**
    * The FailoverClusterFailoverClusterAppApi service constructor.
    * @property {module:api/FailoverClusterFailoverClusterAppApi}
    */
    FailoverClusterFailoverClusterAppApi,

    /**
    * The FailoverClusterHierarchyApi service constructor.
    * @property {module:api/FailoverClusterHierarchyApi}
    */
    FailoverClusterHierarchyApi,

    /**
    * The FilesetApi service constructor.
    * @property {module:api/FilesetApi}
    */
    FilesetApi,

    /**
    * The FilesetTemplateApi service constructor.
    * @property {module:api/FilesetTemplateApi}
    */
    FilesetTemplateApi,

    /**
    * The HdfsApi service constructor.
    * @property {module:api/HdfsApi}
    */
    HdfsApi,

    /**
    * The HdfsTemplateApi service constructor.
    * @property {module:api/HdfsTemplateApi}
    */
    HdfsTemplateApi,

    /**
    * The HealthMonitorApi service constructor.
    * @property {module:api/HealthMonitorApi}
    */
    HealthMonitorApi,

    /**
    * The HierarchyApi service constructor.
    * @property {module:api/HierarchyApi}
    */
    HierarchyApi,

    /**
    * The HostApi service constructor.
    * @property {module:api/HostApi}
    */
    HostApi,

    /**
    * The HostHierarchyApi service constructor.
    * @property {module:api/HostHierarchyApi}
    */
    HostHierarchyApi,

    /**
    * The HostShareApi service constructor.
    * @property {module:api/HostShareApi}
    */
    HostShareApi,

    /**
    * The HypervVmApi service constructor.
    * @property {module:api/HypervVmApi}
    */
    HypervVmApi,

    /**
    * The IdpAuthDomainApi service constructor.
    * @property {module:api/IdpAuthDomainApi}
    */
    IdpAuthDomainApi,

    /**
    * The JobMonitoringApi service constructor.
    * @property {module:api/JobMonitoringApi}
    */
    JobMonitoringApi,

    /**
    * The LdapServiceApi service constructor.
    * @property {module:api/LdapServiceApi}
    */
    LdapServiceApi,

    /**
    * The LegalHoldApi service constructor.
    * @property {module:api/LegalHoldApi}
    */
    LegalHoldApi,

    /**
    * The ManagedVolumeApi service constructor.
    * @property {module:api/ManagedVolumeApi}
    */
    ManagedVolumeApi,

    /**
    * The MfaRsaApi service constructor.
    * @property {module:api/MfaRsaApi}
    */
    MfaRsaApi,

    /**
    * The MssqlApi service constructor.
    * @property {module:api/MssqlApi}
    */
    MssqlApi,

    /**
    * The OracleApi service constructor.
    * @property {module:api/OracleApi}
    */
    OracleApi,

    /**
    * The OrganizationApi service constructor.
    * @property {module:api/OrganizationApi}
    */
    OrganizationApi,

    /**
    * The PrincipalApi service constructor.
    * @property {module:api/PrincipalApi}
    */
    PrincipalApi,

    /**
    * The ReplicationApi service constructor.
    * @property {module:api/ReplicationApi}
    */
    ReplicationApi,

    /**
    * The ReportsApi service constructor.
    * @property {module:api/ReportsApi}
    */
    ReportsApi,

    /**
    * The RoleApi service constructor.
    * @property {module:api/RoleApi}
    */
    RoleApi,

    /**
    * The SamlApi service constructor.
    * @property {module:api/SamlApi}
    */
    SamlApi,

    /**
    * The SapHanaApi service constructor.
    * @property {module:api/SapHanaApi}
    */
    SapHanaApi,

    /**
    * The SessionApi service constructor.
    * @property {module:api/SessionApi}
    */
    SessionApi,

    /**
    * The SlaDomainApi service constructor.
    * @property {module:api/SlaDomainApi}
    */
    SlaDomainApi,

    /**
    * The SnapshotApi service constructor.
    * @property {module:api/SnapshotApi}
    */
    SnapshotApi,

    /**
    * The UnmanagedObjectApi service constructor.
    * @property {module:api/UnmanagedObjectApi}
    */
    UnmanagedObjectApi,

    /**
    * The UserApi service constructor.
    * @property {module:api/UserApi}
    */
    UserApi,

    /**
    * The UserDefinedTagApi service constructor.
    * @property {module:api/UserDefinedTagApi}
    */
    UserDefinedTagApi,

    /**
    * The VcdClusterApi service constructor.
    * @property {module:api/VcdClusterApi}
    */
    VcdClusterApi,

    /**
    * The VcdHierarchyApi service constructor.
    * @property {module:api/VcdHierarchyApi}
    */
    VcdHierarchyApi,

    /**
    * The VcdVappApi service constructor.
    * @property {module:api/VcdVappApi}
    */
    VcdVappApi,

    /**
    * The VmwareComputeClusterApi service constructor.
    * @property {module:api/VmwareComputeClusterApi}
    */
    VmwareComputeClusterApi,

    /**
    * The VmwareConfigApi service constructor.
    * @property {module:api/VmwareConfigApi}
    */
    VmwareConfigApi,

    /**
    * The VmwareHierarchyApi service constructor.
    * @property {module:api/VmwareHierarchyApi}
    */
    VmwareHierarchyApi,

    /**
    * The VmwareHostApi service constructor.
    * @property {module:api/VmwareHostApi}
    */
    VmwareHostApi,

    /**
    * The VmwareVcenterApi service constructor.
    * @property {module:api/VmwareVcenterApi}
    */
    VmwareVcenterApi,

    /**
    * The VmwareVmApi service constructor.
    * @property {module:api/VmwareVmApi}
    */
    VmwareVmApi,

    /**
    * The VolumeGroupApi service constructor.
    * @property {module:api/VolumeGroupApi}
    */
    VolumeGroupApi,

    /**
    * The WindowsClusterApi service constructor.
    * @property {module:api/WindowsClusterApi}
    */
    WindowsClusterApi
};
