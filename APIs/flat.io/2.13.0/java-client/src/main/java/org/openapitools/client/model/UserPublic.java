/*
 * Flat API
 * The Flat API allows you to easily extend the abilities of the [Flat Platform](https://flat.io), with a wide range of use cases including the following:  * Creating and importing new music scores using MusicXML, MIDI, Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar and MuseScore files * Browsing, updating, copying, exporting the user's scores (for example in MP3, WAV or MIDI) * Managing educational resources with Flat for Education: creating & updating the organization accounts, the classes, rosters and assignments.  The Flat API is built on HTTP. Our API is RESTful It has predictable resource URLs. It returns HTTP response codes to indicate errors. It also accepts and returns JSON in the HTTP body. The [schema](/swagger.yaml) of this API follows the [OpenAPI Initiative (OAI) specification](https://www.openapis.org/), you can use and work with [compatible Swagger tools](http://swagger.io/open-source-integrations/). This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/).  You can use your favorite HTTP/REST library for your programming language to use Flat's API. This specification and reference is [available on Github](https://github.com/FlatIO/api-reference).  Getting Started and learn more:  * [API Overview and introduction](https://flat.io/developers/docs/api/) * [Authentication (Personal Access Tokens or OAuth2)](https://flat.io/developers/docs/api/authentication.html) * [SDKs](https://flat.io/developers/docs/api/sdks.html) * [Rate Limits](https://flat.io/developers/docs/api/rate-limits.html) * [Changelog](https://flat.io/developers/docs/api/changelog.html) 
 *
 * The version of the OpenAPI document: 2.13.0
 * Contact: developers@flat.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ClassRoles;
import org.openapitools.client.model.OrganizationRoles;
import org.openapitools.client.model.UserPublicSummary;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Public User details
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:29:21.367769-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UserPublic extends UserPublicSummary {
  public static final String SERIALIZED_NAME_BIO = "bio";
  @SerializedName(SERIALIZED_NAME_BIO)
  private String bio;

  public static final String SERIALIZED_NAME_COVER_PICTURE = "coverPicture";
  @SerializedName(SERIALIZED_NAME_COVER_PICTURE)
  private String coverPicture;

  public static final String SERIALIZED_NAME_FOLLOWERS_COUNT = "followersCount";
  @SerializedName(SERIALIZED_NAME_FOLLOWERS_COUNT)
  private Integer followersCount;

  public static final String SERIALIZED_NAME_FOLLOWING_COUNT = "followingCount";
  @SerializedName(SERIALIZED_NAME_FOLLOWING_COUNT)
  private Integer followingCount;

  public static final String SERIALIZED_NAME_INSTRUMENTS = "instruments";
  @SerializedName(SERIALIZED_NAME_INSTRUMENTS)
  private List<String> instruments = new ArrayList<>();

  public static final String SERIALIZED_NAME_LIKED_SCORES_COUNT = "likedScoresCount";
  @SerializedName(SERIALIZED_NAME_LIKED_SCORES_COUNT)
  private Integer likedScoresCount;

  public static final String SERIALIZED_NAME_OWNED_PUBLIC_SCORES_COUNT = "ownedPublicScoresCount";
  @SerializedName(SERIALIZED_NAME_OWNED_PUBLIC_SCORES_COUNT)
  private Integer ownedPublicScoresCount;

  public static final String SERIALIZED_NAME_PROFILE_THEME = "profileTheme";
  @SerializedName(SERIALIZED_NAME_PROFILE_THEME)
  private String profileTheme;

  public static final String SERIALIZED_NAME_REGISTRATION_DATE = "registrationDate";
  @SerializedName(SERIALIZED_NAME_REGISTRATION_DATE)
  private OffsetDateTime registrationDate;

  public UserPublic() {
    this.type = this.getClass().getSimpleName();
  }

  public UserPublic bio(String bio) {
    this.bio = bio;
    return this;
  }

  /**
   * User&#39;s biography
   * @return bio
   */
  @javax.annotation.Nullable
  public String getBio() {
    return bio;
  }

  public void setBio(String bio) {
    this.bio = bio;
  }


  public UserPublic coverPicture(String coverPicture) {
    this.coverPicture = coverPicture;
    return this;
  }

  /**
   * Cover picture (backgroud) for the profile
   * @return coverPicture
   */
  @javax.annotation.Nullable
  public String getCoverPicture() {
    return coverPicture;
  }

  public void setCoverPicture(String coverPicture) {
    this.coverPicture = coverPicture;
  }


  public UserPublic followersCount(Integer followersCount) {
    this.followersCount = followersCount;
    return this;
  }

  /**
   * Number of followers the user have
   * @return followersCount
   */
  @javax.annotation.Nullable
  public Integer getFollowersCount() {
    return followersCount;
  }

  public void setFollowersCount(Integer followersCount) {
    this.followersCount = followersCount;
  }


  public UserPublic followingCount(Integer followingCount) {
    this.followingCount = followingCount;
    return this;
  }

  /**
   * Number of people the user follow
   * @return followingCount
   */
  @javax.annotation.Nullable
  public Integer getFollowingCount() {
    return followingCount;
  }

  public void setFollowingCount(Integer followingCount) {
    this.followingCount = followingCount;
  }


  public UserPublic instruments(List<String> instruments) {
    this.instruments = instruments;
    return this;
  }

  public UserPublic addInstrumentsItem(String instrumentsItem) {
    if (this.instruments == null) {
      this.instruments = new ArrayList<>();
    }
    this.instruments.add(instrumentsItem);
    return this;
  }

  /**
   * An array of the instrument identifiers. The format of the strings is &#x60;{instrument-group}.{instrument-id}&#x60;. 
   * @return instruments
   */
  @javax.annotation.Nullable
  public List<String> getInstruments() {
    return instruments;
  }

  public void setInstruments(List<String> instruments) {
    this.instruments = instruments;
  }


  public UserPublic likedScoresCount(Integer likedScoresCount) {
    this.likedScoresCount = likedScoresCount;
    return this;
  }

  /**
   * Number of the scores liked by the user
   * @return likedScoresCount
   */
  @javax.annotation.Nullable
  public Integer getLikedScoresCount() {
    return likedScoresCount;
  }

  public void setLikedScoresCount(Integer likedScoresCount) {
    this.likedScoresCount = likedScoresCount;
  }


  public UserPublic ownedPublicScoresCount(Integer ownedPublicScoresCount) {
    this.ownedPublicScoresCount = ownedPublicScoresCount;
    return this;
  }

  /**
   * Number of public scores the user have
   * @return ownedPublicScoresCount
   */
  @javax.annotation.Nullable
  public Integer getOwnedPublicScoresCount() {
    return ownedPublicScoresCount;
  }

  public void setOwnedPublicScoresCount(Integer ownedPublicScoresCount) {
    this.ownedPublicScoresCount = ownedPublicScoresCount;
  }


  public UserPublic profileTheme(String profileTheme) {
    this.profileTheme = profileTheme;
    return this;
  }

  /**
   * Theme (background) for the profile
   * @return profileTheme
   */
  @javax.annotation.Nullable
  public String getProfileTheme() {
    return profileTheme;
  }

  public void setProfileTheme(String profileTheme) {
    this.profileTheme = profileTheme;
  }


  public UserPublic registrationDate(OffsetDateTime registrationDate) {
    this.registrationDate = registrationDate;
    return this;
  }

  /**
   * Date the user signed up
   * @return registrationDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRegistrationDate() {
    return registrationDate;
  }

  public void setRegistrationDate(OffsetDateTime registrationDate) {
    this.registrationDate = registrationDate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UserPublic userPublic = (UserPublic) o;
    return Objects.equals(this.bio, userPublic.bio) &&
        Objects.equals(this.coverPicture, userPublic.coverPicture) &&
        Objects.equals(this.followersCount, userPublic.followersCount) &&
        Objects.equals(this.followingCount, userPublic.followingCount) &&
        Objects.equals(this.instruments, userPublic.instruments) &&
        Objects.equals(this.likedScoresCount, userPublic.likedScoresCount) &&
        Objects.equals(this.ownedPublicScoresCount, userPublic.ownedPublicScoresCount) &&
        Objects.equals(this.profileTheme, userPublic.profileTheme) &&
        Objects.equals(this.registrationDate, userPublic.registrationDate) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(bio, coverPicture, followersCount, followingCount, instruments, likedScoresCount, ownedPublicScoresCount, profileTheme, registrationDate, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UserPublic {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    bio: ").append(toIndentedString(bio)).append("\n");
    sb.append("    coverPicture: ").append(toIndentedString(coverPicture)).append("\n");
    sb.append("    followersCount: ").append(toIndentedString(followersCount)).append("\n");
    sb.append("    followingCount: ").append(toIndentedString(followingCount)).append("\n");
    sb.append("    instruments: ").append(toIndentedString(instruments)).append("\n");
    sb.append("    likedScoresCount: ").append(toIndentedString(likedScoresCount)).append("\n");
    sb.append("    ownedPublicScoresCount: ").append(toIndentedString(ownedPublicScoresCount)).append("\n");
    sb.append("    profileTheme: ").append(toIndentedString(profileTheme)).append("\n");
    sb.append("    registrationDate: ").append(toIndentedString(registrationDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("firstname");
    openapiFields.add("id");
    openapiFields.add("isFlatTeam");
    openapiFields.add("isPowerUser");
    openapiFields.add("lastname");
    openapiFields.add("name");
    openapiFields.add("picture");
    openapiFields.add("printableName");
    openapiFields.add("type");
    openapiFields.add("username");
    openapiFields.add("classRole");
    openapiFields.add("htmlUrl");
    openapiFields.add("organization");
    openapiFields.add("organizationRole");
    openapiFields.add("bio");
    openapiFields.add("coverPicture");
    openapiFields.add("followersCount");
    openapiFields.add("followingCount");
    openapiFields.add("instruments");
    openapiFields.add("likedScoresCount");
    openapiFields.add("ownedPublicScoresCount");
    openapiFields.add("profileTheme");
    openapiFields.add("registrationDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UserPublic
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UserPublic.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UserPublic is not found in the empty JSON string", UserPublic.openapiRequiredFields.toString()));
        }
      }

      String discriminatorValue = jsonElement.getAsJsonObject().get("type").getAsString();
      switch (discriminatorValue) {
        case "UserDetails":
          UserDetails.validateJsonElement(jsonElement);
          break;
        default:
          throw new IllegalArgumentException(String.format("The value of the `type` field `%s` does not match any key defined in the discriminator's mapping.", discriminatorValue));
      }
  }


  /**
   * Create an instance of UserPublic given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UserPublic
   * @throws IOException if the JSON string is invalid with respect to UserPublic
   */
  public static UserPublic fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UserPublic.class);
  }

  /**
   * Convert an instance of UserPublic to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

