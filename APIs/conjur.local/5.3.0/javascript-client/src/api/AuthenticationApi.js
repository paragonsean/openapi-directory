/**
 * Conjur
 * This is an API definition for CyberArk Conjur Open Source. You can find out more at [Conjur.org](https://www.conjur.org/).
 *
 * The version of the OpenAPI document: 5.3.0
 * Contact: conj_maintainers@cyberark.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";

/**
* Authentication service.
* @module api/AuthenticationApi
* @version 5.3.0
*/
export default class AuthenticationApi {

    /**
    * Constructs a new AuthenticationApi. 
    * @alias module:api/AuthenticationApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the changePassword operation.
     * @callback module:api/AuthenticationApi~changePasswordCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Changes a user’s password.
     * You must provide the login name and current password or API key of the user whose password is to be updated in an HTTP Basic Authentication header. Also replaces the user’s API key with a new securely generated random value. You can fetch the new API key using the Login method.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords. They authenticate using their API keys, while passwords are only used by human users. 
     * @param {String} account Organization account name
     * @param {String} body New password
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:api/AuthenticationApi~changePasswordCallback} callback The callback function, accepting three arguments: error, data, response
     */
    changePassword(account, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling changePassword");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling changePassword");
      }

      let pathParams = {
        'account': account
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
      };

      let authNames = ['basicAuth'];
      let contentTypes = ['text/plain'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn/{account}/password', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the enableAuthenticator operation.
     * @callback module:api/AuthenticationApi~enableAuthenticatorCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Enables or disables authenticator defined without service_id.
     * Allows you to either enable or disable a given authenticator that does not have service_id (For example: authn-gcp).  When you enable or disable an authenticator via this endpoint, the status of the authenticator is stored in the Conjur database. The enablement status of the authenticator service may be overridden by setting the `CONJUR_AUTHENTICATORS` environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.** 
     * @param {module:model/String} authenticator The authenticator to update
     * @param {String} account Organization account name
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {Boolean} [enabled] 
     * @param {module:api/AuthenticationApi~enableAuthenticatorCallback} callback The callback function, accepting three arguments: error, data, response
     */
    enableAuthenticator(authenticator, account, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'authenticator' is set
      if (authenticator === undefined || authenticator === null) {
        throw new Error("Missing the required parameter 'authenticator' when calling enableAuthenticator");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling enableAuthenticator");
      }

      let pathParams = {
        'authenticator': authenticator,
        'account': account
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
        'enabled': opts['enabled']
      };

      let authNames = ['basicAuth', 'conjurKubernetesMutualTls', 'conjurAuth'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/{authenticator}/{account}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the enableAuthenticatorInstance operation.
     * @callback module:api/AuthenticationApi~enableAuthenticatorInstanceCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Enables or disables authenticator service instances.
     * Allows you to either enable or disable a given authenticator service instance.  When you enable or disable an authenticator service instance via this endpoint, the status of the authenticator service instance is stored in the Conjur database. The enablement status of the authenticator service instance may be overridden by setting the `CONJUR_AUTHENTICATORS` environment variable on the Conjur server; in the case where this environment variable is set, the database record of whether the authenticator service instance is enabled will be ignored.  **This endpoint is part of an early implementation of support for enabling Conjur authenticators via the API, and is currently available at the Community (or early alpha) level. This endpoint is still subject to breaking changes in the future.** 
     * @param {module:model/ERRORUNKNOWN} authenticator The authenticator to update
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} account Organization account name
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:api/AuthenticationApi~enableAuthenticatorInstanceCallback} callback The callback function, accepting three arguments: error, data, response
     */
    enableAuthenticatorInstance(authenticator, serviceId, account, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'authenticator' is set
      if (authenticator === undefined || authenticator === null) {
        throw new Error("Missing the required parameter 'authenticator' when calling enableAuthenticatorInstance");
      }
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling enableAuthenticatorInstance");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling enableAuthenticatorInstance");
      }

      let pathParams = {
        'authenticator': authenticator,
        'service_id': serviceId,
        'account': account
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
      };

      let authNames = ['conjurAuth'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/{authenticator}/{service_id}/{account}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAPIKey operation.
     * @callback module:api/AuthenticationApi~getAPIKeyCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets the API key of a user given the username and password via HTTP Basic Authentication. 
     * Passwords are stored in the Conjur database using `bcrypt` with a work factor of 12. Therefore, login is a fairly expensive operation. However, once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  Note that machine roles (Hosts) do not have passwords and do not need to use this endpoint. 
     * @param {String} account Organization account name
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:api/AuthenticationApi~getAPIKeyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    getAPIKey(account, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAPIKey");
      }

      let pathParams = {
        'account': account
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
      };

      let authNames = ['basicAuth'];
      let contentTypes = [];
      let accepts = ['text/plain'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/authn/{account}/login', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAPIKeyViaLDAP operation.
     * @callback module:api/AuthenticationApi~getAPIKeyViaLDAPCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets the Conjur API key of a user given the LDAP username and password via HTTP Basic Authentication. 
     * Exchange your LDAP credentials for a Conjur API key. Once the API key is obtained, it may be used to inexpensively obtain access tokens by calling the Authenticate method. An access token is required to use most other parts of the Conjur API.  The Basic authentication-compliant header is formed by: 1. Concatenating the LDAP username, a literal colon character ':',    and the password to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. 
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} account Organization account name
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:api/AuthenticationApi~getAPIKeyViaLDAPCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAPIKeyViaLDAP(serviceId, account, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAPIKeyViaLDAP");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAPIKeyViaLDAP");
      }

      let pathParams = {
        'service_id': serviceId,
        'account': account
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
      };

      let authNames = ['basicAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-ldap/{service_id}/{account}/login', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessToken operation.
     * @callback module:api/AuthenticationApi~getAccessTokenCallback
     * @param {String} error Error message, if any.
     * @param {String} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token, which is required in the header of most subsequent API requests. 
     * A client can obtain an access token by presenting a valid login name and API key.  The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  The `login` must be URL encoded. For example, `alice@devops` must be encoded as `alice%40devops`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For host authentication, the `login` is the host ID with the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  This is the default authentication endpoint only. See other endpoints for details on authenticating to Conjur using another method, e.g. for applications running in Azure or Kubernetes. 
     * @param {String} account Organization account name
     * @param {String} login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>`
     * @param {Object} body API Key
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:model/String} [acceptEncoding = 'application/json')] Setting the Accept-Encoding header to base64 will return a pre-encoded access token
     * @param {module:api/AuthenticationApi~getAccessTokenCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link String}
     */
    getAccessToken(account, login, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessToken");
      }
      // verify the required parameter 'login' is set
      if (login === undefined || login === null) {
        throw new Error("Missing the required parameter 'login' when calling getAccessToken");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getAccessToken");
      }

      let pathParams = {
        'account': account,
        'login': login
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId'],
        'Accept-Encoding': opts['acceptEncoding']
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['text/plain'];
      let accepts = ['text/plain'];
      let returnType = 'String';
      return this.apiClient.callApi(
        '/authn/{account}/{login}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaAWS operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaAWSCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a short-lived access token for applications running in AWS.
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For detailed instructions on authenticating to Conjur using this endpoint, reference the documentation: [AWS IAM Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/AWS_IAM_Authenticator.htm) (`authn-iam`). 
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} account Organization account name
     * @param {module:model/ERRORUNKNOWN} login URL-encoded login name. For hosts, the login name is `host/<host-id>`
     * @param {String} body AWS Signature header
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:model/String} [acceptEncoding = 'application/json')] Setting the Accept-Encoding header to base64 will return a pre-encoded access token
     * @param {module:api/AuthenticationApi~getAccessTokenViaAWSCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaAWS(serviceId, account, login, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAccessTokenViaAWS");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaAWS");
      }
      // verify the required parameter 'login' is set
      if (login === undefined || login === null) {
        throw new Error("Missing the required parameter 'login' when calling getAccessTokenViaAWS");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getAccessTokenViaAWS");
      }

      let pathParams = {
        'service_id': serviceId,
        'account': account,
        'login': login
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId'],
        'Accept-Encoding': opts['acceptEncoding']
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['text/plain'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-iam/{service_id}/{account}/{login}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaAzure operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaAzureCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token for applications running in Azure.
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Azure Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/azure_authn.htm) (`authn-azure`). 
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} account Organization account name
     * @param {module:model/ERRORUNKNOWN} login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>`
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:model/String} [acceptEncoding = 'application/json')] Setting the Accept-Encoding header to base64 will return a pre-encoded access token
     * @param {String} [jwt] 
     * @param {module:api/AuthenticationApi~getAccessTokenViaAzureCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaAzure(serviceId, account, login, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAccessTokenViaAzure");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaAzure");
      }
      // verify the required parameter 'login' is set
      if (login === undefined || login === null) {
        throw new Error("Missing the required parameter 'login' when calling getAccessTokenViaAzure");
      }

      let pathParams = {
        'service_id': serviceId,
        'account': account,
        'login': login
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId'],
        'Accept-Encoding': opts['acceptEncoding']
      };
      let formParams = {
        'jwt': opts['jwt']
      };

      let authNames = [];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-azure/{service_id}/{account}/{login}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaGCP operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaGCPCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token for applications running in Google Cloud Platform. 
     * Use the GCP Authenticator API to send an authentication request from a Google Cloud service to Conjur.  For more information, see [the documentation](https://docs.conjur.org/Latest/en/Content/Operations/Services/cjr-gcp-authn.htm). 
     * @param {String} account Organization account name
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:model/String} [acceptEncoding] Setting the Accept-Encoding header to base64 will return a pre-encoded access token
     * @param {String} [jwt] 
     * @param {module:api/AuthenticationApi~getAccessTokenViaGCPCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaGCP(account, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaGCP");
      }

      let pathParams = {
        'account': account
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId'],
        'Accept-Encoding': opts['acceptEncoding']
      };
      let formParams = {
        'jwt': opts['jwt']
      };

      let authNames = [];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-gcp/{account}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaJWT operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaJWTCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API. 
     * Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur. 
     * @param {String} account Organization account name
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {String} [jwt] 
     * @param {module:api/AuthenticationApi~getAccessTokenViaJWTCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaJWT(account, serviceId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaJWT");
      }
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAccessTokenViaJWT");
      }

      let pathParams = {
        'account': account,
        'service_id': serviceId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
        'jwt': opts['jwt']
      };

      let authNames = [];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-jwt/{service_id}/{account}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaJWTWithId operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaJWTWithIdCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token for applications using JSON Web Token (JWT) to access the Conjur API. Covers the case of use of optional URL parameter \"ID\" 
     * Use the JWT Authenticator to leverage the identity layer provided by JWT to authenticate with Conjur. 
     * @param {String} account Organization account name
     * @param {String} id Organization user id
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:api/AuthenticationApi~getAccessTokenViaJWTWithIdCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaJWTWithId(account, id, serviceId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaJWTWithId");
      }
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getAccessTokenViaJWTWithId");
      }
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAccessTokenViaJWTWithId");
      }

      let pathParams = {
        'account': account,
        'id': id,
        'service_id': serviceId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-jwt/{service_id}/{account}/{id}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaKubernetes operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaKubernetesCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token for applications running in Kubernetes.
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded and the host ID must have the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  To authenticate to Conjur using this endpoint, reference the detailed documentation: [Kubernetes Authenticator](https://docs.conjur.org/Latest/en/Content/Operations/Services/k8s_auth.htm) (`authn-k8s`). 
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} account Organization account name
     * @param {module:model/ERRORUNKNOWN} login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>`
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:model/String} [acceptEncoding = 'application/json')] Setting the Accept-Encoding header to base64 will return a pre-encoded access token
     * @param {module:api/AuthenticationApi~getAccessTokenViaKubernetesCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaKubernetes(serviceId, account, login, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAccessTokenViaKubernetes");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaKubernetes");
      }
      // verify the required parameter 'login' is set
      if (login === undefined || login === null) {
        throw new Error("Missing the required parameter 'login' when calling getAccessTokenViaKubernetes");
      }

      let pathParams = {
        'service_id': serviceId,
        'account': account,
        'login': login
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId'],
        'Accept-Encoding': opts['acceptEncoding']
      };
      let formParams = {
      };

      let authNames = ['conjurKubernetesMutualTls'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-k8s/{service_id}/{account}/{login}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaLDAP operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaLDAPCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token for users and hosts using their LDAP identity to access the Conjur API. 
     * The access token is used to communicate to the REST API that the bearer of the token has been authorized to access the API and perform specific actions specified by the scope that was granted during authorization.  For API usage, the base64-encoded access token is ordinarily passed as an HTTP Authorization header as `Authorization: Token token=<base64-encoded token>`.  The `login` must be URL encoded. For example, `alice@devops` must be encoded as `alice%40devops`.  The `service_id`, if given, must be URL encoded. For example, `prod/gke` must be encoded as `prod%2Fgke`.  For host authentication, the `login` is the host ID with the prefix `host/`. For example, the host webserver would login as `host/webserver`, and would be encoded as `host%2Fwebserver`.  To authenticate to Conjur using a LDAP, reference the detailed documentation: [LDAP Authenticator](https://docs.conjur.org/Latest/en/Content/Integrations/ldap/ldap_authenticator.html) (`authn-ldap`). 
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} account Organization account name
     * @param {module:model/ERRORUNKNOWN} login URL-encoded login name. For users, it’s the user ID. For hosts, the login name is `host/<host-id>`
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {module:model/String} [acceptEncoding = 'application/json')] Setting the Accept-Encoding header to base64 will return a pre-encoded access token
     * @param {Object} [body] API key
     * @param {module:api/AuthenticationApi~getAccessTokenViaLDAPCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaLDAP(serviceId, account, login, opts, callback) {
      opts = opts || {};
      let postBody = opts['body'];
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAccessTokenViaLDAP");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaLDAP");
      }
      // verify the required parameter 'login' is set
      if (login === undefined || login === null) {
        throw new Error("Missing the required parameter 'login' when calling getAccessTokenViaLDAP");
      }

      let pathParams = {
        'service_id': serviceId,
        'account': account,
        'login': login
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId'],
        'Accept-Encoding': opts['acceptEncoding']
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['text/plain'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-ldap/{service_id}/{account}/{login}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getAccessTokenViaOIDC operation.
     * @callback module:api/AuthenticationApi~getAccessTokenViaOIDCCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Gets a short-lived access token for applications using OpenID Connect (OIDC) to access the Conjur API. 
     * Use the OIDC Authenticator to leverage the identity layer provided by OIDC to authenticate with Conjur.  For more information see [the documentation](https://docs.conjur.org/Latest/en/Content/OIDC/OIDC.htm). 
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} account Organization account name
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {String} [idToken] 
     * @param {module:api/AuthenticationApi~getAccessTokenViaOIDCCallback} callback The callback function, accepting three arguments: error, data, response
     */
    getAccessTokenViaOIDC(serviceId, account, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling getAccessTokenViaOIDC");
      }
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling getAccessTokenViaOIDC");
      }

      let pathParams = {
        'service_id': serviceId,
        'account': account
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
        'id_token': opts['idToken']
      };

      let authNames = [];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-oidc/{service_id}/{account}/authenticate', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the k8sInjectClientCert operation.
     * @callback module:api/AuthenticationApi~k8sInjectClientCertCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * For applications running in Kubernetes; sends Conjur a certificate signing request (CSR) and requests a client certificate injected into the application's Kubernetes pod. 
     * This request sends a Certificate Signing Request to Conjur, which uses the Kubernetes API to inject a client certificate into the application pod.  This endpoint requires a properly configured Conjur Certificate Authority service alongside a properly configured and enabled Kubernetes authenticator. For detailed instructions, see [the documentation](https://docs.conjur.org/Latest/en/Content/Integrations/kubernetes.htm). 
     * @param {String} serviceId URL-Encoded authenticator service ID
     * @param {String} body Valid certificate signing request that includes the host identity suffix as the CSR common name 
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {String} [hostIdPrefix] Dot-separated policy tree, prefixed by `host.`, where the application identity is defined
     * @param {module:api/AuthenticationApi~k8sInjectClientCertCallback} callback The callback function, accepting three arguments: error, data, response
     */
    k8sInjectClientCert(serviceId, body, opts, callback) {
      opts = opts || {};
      let postBody = body;
      // verify the required parameter 'serviceId' is set
      if (serviceId === undefined || serviceId === null) {
        throw new Error("Missing the required parameter 'serviceId' when calling k8sInjectClientCert");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling k8sInjectClientCert");
      }

      let pathParams = {
        'service_id': serviceId
      };
      let queryParams = {
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId'],
        'Host-Id-Prefix': opts['hostIdPrefix']
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'conjurKubernetesMutualTls', 'conjurAuth'];
      let contentTypes = ['text/plain'];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn-k8s/{service_id}/inject_client_cert', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the rotateApiKey operation.
     * @callback module:api/AuthenticationApi~rotateApiKeyCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Rotates a role's API key.
     * Any role can rotate its own API key. The name and password (for users) or current API key (for hosts and users) of the role must be provided via HTTP Basic Authorization.  To rotate another role's API key, you may provide your name and password (for users) or current API key (for hosts and users) via HTTP Basic Authorization with the request. Alternatively, you may provide your Conjur access token via the standard Conjur `Authorization` header.  The Basic authentication-compliant header is formed by: 1. Concatenating the role's name, a literal colon character ':',    and the password or API key to create the authentication string. 2. Base64-encoding the authentication string. 3. Prefixing the authentication string with the scheme: `Basic `    (note the required space). 4. Providing the result as the value of the `Authorization` HTTP header:    `Authorization: Basic <authentication string>`.  Your HTTP/REST client probably provides HTTP basic authentication support. For example, `curl` and all of the Conjur client libraries provide this.  If using the Conjur `Authorization` header, its value should be set to `Token token=<base64-encoded access token>`.  Note that the body of the request must be the empty string. 
     * @param {String} account Organization account name
     * @param {Object} opts Optional parameters
     * @param {String} [xRequestId] Add an ID to the request being made so it can be tracked in Conjur. If not provided the server will automatically generate one. 
     * @param {String} [role] (**Optional**) role specifier in `{kind}:{identifier}` format  ##### Permissions required  `update` privilege on the role whose API key is being rotated. 
     * @param {module:api/AuthenticationApi~rotateApiKeyCallback} callback The callback function, accepting three arguments: error, data, response
     */
    rotateApiKey(account, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'account' is set
      if (account === undefined || account === null) {
        throw new Error("Missing the required parameter 'account' when calling rotateApiKey");
      }

      let pathParams = {
        'account': account
      };
      let queryParams = {
        'role': opts['role']
      };
      let headerParams = {
        'X-Request-Id': opts['xRequestId']
      };
      let formParams = {
      };

      let authNames = ['basicAuth', 'conjurAuth'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/authn/{account}/api_key', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
