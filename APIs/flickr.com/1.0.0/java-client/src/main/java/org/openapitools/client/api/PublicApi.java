/*
 * Flickr API Schema
 * A subset of Flickr's API defined in Swagger format.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.openapitools.client.model.Echo200Response;
import java.io.File;
import org.openapitools.client.model.GetAlbumByID200Response;
import org.openapitools.client.model.GetAlbumsByPersonID200Response;
import org.openapitools.client.model.GetFavoritesByPersonID200Response;
import org.openapitools.client.model.GetFavoritesContextByID200Response;
import org.openapitools.client.model.GetGalleryPhotosByID200Response;
import org.openapitools.client.model.GetGroupByID200Response;
import org.openapitools.client.model.GetGroupDiscussionsByID200Response;
import org.openapitools.client.model.GetGroupTopicByID200Response;
import org.openapitools.client.model.GetGroupTopicRepliesByID200Response;
import org.openapitools.client.model.GetLicenseByID200Response;
import org.openapitools.client.model.GetPersonByID200Response;
import org.openapitools.client.model.GetPhotoByID200Response;
import org.openapitools.client.model.GetPhotoExifByID200Response;
import org.openapitools.client.model.GetPhotoSizesByID200Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PublicApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PublicApi() {
        this(Configuration.getDefaultApiClient());
    }

    public PublicApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for echo
     * @param apiKey  (required)
     * @param echo  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call echoCall(String apiKey, String echo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.test.echo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (echo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("echo", echo));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call echoValidateBeforeCall(String apiKey, String echo, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling echo(Async)");
        }

        return echoCall(apiKey, echo, _callback);

    }

    /**
     * 
     * Echos the input parameters back in the response
     * @param apiKey  (required)
     * @param echo  (optional)
     * @return Echo200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Echo200Response echo(String apiKey, String echo) throws ApiException {
        ApiResponse<Echo200Response> localVarResp = echoWithHttpInfo(apiKey, echo);
        return localVarResp.getData();
    }

    /**
     * 
     * Echos the input parameters back in the response
     * @param apiKey  (required)
     * @param echo  (optional)
     * @return ApiResponse&lt;Echo200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Echo200Response> echoWithHttpInfo(String apiKey, String echo) throws ApiException {
        okhttp3.Call localVarCall = echoValidateBeforeCall(apiKey, echo, null);
        Type localVarReturnType = new TypeToken<Echo200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Echos the input parameters back in the response
     * @param apiKey  (required)
     * @param echo  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call echoAsync(String apiKey, String echo, final ApiCallback<Echo200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = echoValidateBeforeCall(apiKey, echo, _callback);
        Type localVarReturnType = new TypeToken<Echo200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAccessToken
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthVerifier  (required)
     * @param oauthToken  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAccessTokenCall(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthVerifier, String oauthToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/oauth/access_token";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (oauthConsumerKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_consumer_key", oauthConsumerKey));
        }

        if (oauthNonce != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_nonce", oauthNonce));
        }

        if (oauthTimestamp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_timestamp", oauthTimestamp));
        }

        if (oauthSignatureMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_signature_method", oauthSignatureMethod));
        }

        if (oauthVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_version", oauthVersion));
        }

        if (oauthSignature != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_signature", oauthSignature));
        }

        if (oauthVerifier != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_verifier", oauthVerifier));
        }

        if (oauthToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_token", oauthToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAccessTokenValidateBeforeCall(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthVerifier, String oauthToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'oauthConsumerKey' is set
        if (oauthConsumerKey == null) {
            throw new ApiException("Missing the required parameter 'oauthConsumerKey' when calling getAccessToken(Async)");
        }

        // verify the required parameter 'oauthNonce' is set
        if (oauthNonce == null) {
            throw new ApiException("Missing the required parameter 'oauthNonce' when calling getAccessToken(Async)");
        }

        // verify the required parameter 'oauthTimestamp' is set
        if (oauthTimestamp == null) {
            throw new ApiException("Missing the required parameter 'oauthTimestamp' when calling getAccessToken(Async)");
        }

        // verify the required parameter 'oauthSignatureMethod' is set
        if (oauthSignatureMethod == null) {
            throw new ApiException("Missing the required parameter 'oauthSignatureMethod' when calling getAccessToken(Async)");
        }

        // verify the required parameter 'oauthVersion' is set
        if (oauthVersion == null) {
            throw new ApiException("Missing the required parameter 'oauthVersion' when calling getAccessToken(Async)");
        }

        // verify the required parameter 'oauthSignature' is set
        if (oauthSignature == null) {
            throw new ApiException("Missing the required parameter 'oauthSignature' when calling getAccessToken(Async)");
        }

        // verify the required parameter 'oauthVerifier' is set
        if (oauthVerifier == null) {
            throw new ApiException("Missing the required parameter 'oauthVerifier' when calling getAccessToken(Async)");
        }

        // verify the required parameter 'oauthToken' is set
        if (oauthToken == null) {
            throw new ApiException("Missing the required parameter 'oauthToken' when calling getAccessToken(Async)");
        }

        return getAccessTokenCall(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthVerifier, oauthToken, _callback);

    }

    /**
     * 
     * Returns an access token
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthVerifier  (required)
     * @param oauthToken  (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public String getAccessToken(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthVerifier, String oauthToken) throws ApiException {
        ApiResponse<String> localVarResp = getAccessTokenWithHttpInfo(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthVerifier, oauthToken);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns an access token
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthVerifier  (required)
     * @param oauthToken  (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getAccessTokenWithHttpInfo(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthVerifier, String oauthToken) throws ApiException {
        okhttp3.Call localVarCall = getAccessTokenValidateBeforeCall(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthVerifier, oauthToken, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns an access token
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthVerifier  (required)
     * @param oauthToken  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAccessTokenAsync(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthVerifier, String oauthToken, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAccessTokenValidateBeforeCall(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthVerifier, oauthToken, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAlbumByID
     * @param apiKey  (required)
     * @param photosetId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlbumByIDCall(String apiKey, String photosetId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photosets.getPhotos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photosetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photoset_id", photosetId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAlbumByIDValidateBeforeCall(String apiKey, String photosetId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getAlbumByID(Async)");
        }

        // verify the required parameter 'photosetId' is set
        if (photosetId == null) {
            throw new ApiException("Missing the required parameter 'photosetId' when calling getAlbumByID(Async)");
        }

        return getAlbumByIDCall(apiKey, photosetId, _callback);

    }

    /**
     * 
     * Returns a list of photos in an album.
     * @param apiKey  (required)
     * @param photosetId  (required)
     * @return GetAlbumByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetAlbumByID200Response getAlbumByID(String apiKey, String photosetId) throws ApiException {
        ApiResponse<GetAlbumByID200Response> localVarResp = getAlbumByIDWithHttpInfo(apiKey, photosetId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of photos in an album.
     * @param apiKey  (required)
     * @param photosetId  (required)
     * @return ApiResponse&lt;GetAlbumByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetAlbumByID200Response> getAlbumByIDWithHttpInfo(String apiKey, String photosetId) throws ApiException {
        okhttp3.Call localVarCall = getAlbumByIDValidateBeforeCall(apiKey, photosetId, null);
        Type localVarReturnType = new TypeToken<GetAlbumByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of photos in an album.
     * @param apiKey  (required)
     * @param photosetId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlbumByIDAsync(String apiKey, String photosetId, final ApiCallback<GetAlbumByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAlbumByIDValidateBeforeCall(apiKey, photosetId, _callback);
        Type localVarReturnType = new TypeToken<GetAlbumByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAlbumContextByID
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photosetId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlbumContextByIDCall(String apiKey, String photoId, String photosetId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photosets.getContext";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        if (photosetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photoset_id", photosetId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAlbumContextByIDValidateBeforeCall(String apiKey, String photoId, String photosetId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getAlbumContextByID(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling getAlbumContextByID(Async)");
        }

        return getAlbumContextByIDCall(apiKey, photoId, photosetId, _callback);

    }

    /**
     * 
     * Returns next and previous photos for a photo in a set
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photosetId  (optional)
     * @return GetFavoritesContextByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesContextByID200Response getAlbumContextByID(String apiKey, String photoId, String photosetId) throws ApiException {
        ApiResponse<GetFavoritesContextByID200Response> localVarResp = getAlbumContextByIDWithHttpInfo(apiKey, photoId, photosetId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns next and previous photos for a photo in a set
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photosetId  (optional)
     * @return ApiResponse&lt;GetFavoritesContextByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesContextByID200Response> getAlbumContextByIDWithHttpInfo(String apiKey, String photoId, String photosetId) throws ApiException {
        okhttp3.Call localVarCall = getAlbumContextByIDValidateBeforeCall(apiKey, photoId, photosetId, null);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns next and previous photos for a photo in a set
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photosetId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlbumContextByIDAsync(String apiKey, String photoId, String photosetId, final ApiCallback<GetFavoritesContextByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAlbumContextByIDValidateBeforeCall(apiKey, photoId, photosetId, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAlbumsByPersonID
     * @param apiKey  (required)
     * @param userId  (required)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlbumsByPersonIDCall(String apiKey, String userId, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photosets.getList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAlbumsByPersonIDValidateBeforeCall(String apiKey, String userId, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getAlbumsByPersonID(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getAlbumsByPersonID(Async)");
        }

        return getAlbumsByPersonIDCall(apiKey, userId, page, perPage, _callback);

    }

    /**
     * 
     * Returns the albums belonging to the specified user
     * @param apiKey  (required)
     * @param userId  (required)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return GetAlbumsByPersonID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetAlbumsByPersonID200Response getAlbumsByPersonID(String apiKey, String userId, BigDecimal page, BigDecimal perPage) throws ApiException {
        ApiResponse<GetAlbumsByPersonID200Response> localVarResp = getAlbumsByPersonIDWithHttpInfo(apiKey, userId, page, perPage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns the albums belonging to the specified user
     * @param apiKey  (required)
     * @param userId  (required)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return ApiResponse&lt;GetAlbumsByPersonID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetAlbumsByPersonID200Response> getAlbumsByPersonIDWithHttpInfo(String apiKey, String userId, BigDecimal page, BigDecimal perPage) throws ApiException {
        okhttp3.Call localVarCall = getAlbumsByPersonIDValidateBeforeCall(apiKey, userId, page, perPage, null);
        Type localVarReturnType = new TypeToken<GetAlbumsByPersonID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns the albums belonging to the specified user
     * @param apiKey  (required)
     * @param userId  (required)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAlbumsByPersonIDAsync(String apiKey, String userId, BigDecimal page, BigDecimal perPage, final ApiCallback<GetAlbumsByPersonID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAlbumsByPersonIDValidateBeforeCall(apiKey, userId, page, perPage, _callback);
        Type localVarReturnType = new TypeToken<GetAlbumsByPersonID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFavoritesByPersonID
     * @param apiKey  (required)
     * @param userId  (required)
     * @param minFaveDate  (optional)
     * @param maxFaveDate  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFavoritesByPersonIDCall(String apiKey, String userId, BigDecimal minFaveDate, BigDecimal maxFaveDate, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.favorites.getList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (minFaveDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min_fave_date", minFaveDate));
        }

        if (maxFaveDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_fave_date", maxFaveDate));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFavoritesByPersonIDValidateBeforeCall(String apiKey, String userId, BigDecimal minFaveDate, BigDecimal maxFaveDate, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getFavoritesByPersonID(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getFavoritesByPersonID(Async)");
        }

        return getFavoritesByPersonIDCall(apiKey, userId, minFaveDate, maxFaveDate, page, perPage, _callback);

    }

    /**
     * 
     * Returns a list of the user&#39;s favorite photos. Only photos which the calling user has permission to see are returned.
     * @param apiKey  (required)
     * @param userId  (required)
     * @param minFaveDate  (optional)
     * @param maxFaveDate  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return GetFavoritesByPersonID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesByPersonID200Response getFavoritesByPersonID(String apiKey, String userId, BigDecimal minFaveDate, BigDecimal maxFaveDate, BigDecimal page, BigDecimal perPage) throws ApiException {
        ApiResponse<GetFavoritesByPersonID200Response> localVarResp = getFavoritesByPersonIDWithHttpInfo(apiKey, userId, minFaveDate, maxFaveDate, page, perPage);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of the user&#39;s favorite photos. Only photos which the calling user has permission to see are returned.
     * @param apiKey  (required)
     * @param userId  (required)
     * @param minFaveDate  (optional)
     * @param maxFaveDate  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return ApiResponse&lt;GetFavoritesByPersonID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesByPersonID200Response> getFavoritesByPersonIDWithHttpInfo(String apiKey, String userId, BigDecimal minFaveDate, BigDecimal maxFaveDate, BigDecimal page, BigDecimal perPage) throws ApiException {
        okhttp3.Call localVarCall = getFavoritesByPersonIDValidateBeforeCall(apiKey, userId, minFaveDate, maxFaveDate, page, perPage, null);
        Type localVarReturnType = new TypeToken<GetFavoritesByPersonID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of the user&#39;s favorite photos. Only photos which the calling user has permission to see are returned.
     * @param apiKey  (required)
     * @param userId  (required)
     * @param minFaveDate  (optional)
     * @param maxFaveDate  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFavoritesByPersonIDAsync(String apiKey, String userId, BigDecimal minFaveDate, BigDecimal maxFaveDate, BigDecimal page, BigDecimal perPage, final ApiCallback<GetFavoritesByPersonID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFavoritesByPersonIDValidateBeforeCall(apiKey, userId, minFaveDate, maxFaveDate, page, perPage, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesByPersonID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFavoritesContextByID
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param userId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFavoritesContextByIDCall(String apiKey, String photoId, String userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.favorites.getContext";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFavoritesContextByIDValidateBeforeCall(String apiKey, String photoId, String userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getFavoritesContextByID(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling getFavoritesContextByID(Async)");
        }

        return getFavoritesContextByIDCall(apiKey, photoId, userId, _callback);

    }

    /**
     * 
     * Returns next and previous favorites for a photo in a user&#39;s favorites
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param userId  (optional)
     * @return GetFavoritesContextByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesContextByID200Response getFavoritesContextByID(String apiKey, String photoId, String userId) throws ApiException {
        ApiResponse<GetFavoritesContextByID200Response> localVarResp = getFavoritesContextByIDWithHttpInfo(apiKey, photoId, userId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns next and previous favorites for a photo in a user&#39;s favorites
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param userId  (optional)
     * @return ApiResponse&lt;GetFavoritesContextByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesContextByID200Response> getFavoritesContextByIDWithHttpInfo(String apiKey, String photoId, String userId) throws ApiException {
        okhttp3.Call localVarCall = getFavoritesContextByIDValidateBeforeCall(apiKey, photoId, userId, null);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns next and previous favorites for a photo in a user&#39;s favorites
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param userId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFavoritesContextByIDAsync(String apiKey, String photoId, String userId, final ApiCallback<GetFavoritesContextByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFavoritesContextByIDValidateBeforeCall(apiKey, photoId, userId, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGalleryPhotosByID
     * @param apiKey  (required)
     * @param galleryId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGalleryPhotosByIDCall(String apiKey, String galleryId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.galleries.getPhotos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (galleryId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("gallery_id", galleryId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGalleryPhotosByIDValidateBeforeCall(String apiKey, String galleryId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getGalleryPhotosByID(Async)");
        }

        // verify the required parameter 'galleryId' is set
        if (galleryId == null) {
            throw new ApiException("Missing the required parameter 'galleryId' when calling getGalleryPhotosByID(Async)");
        }

        return getGalleryPhotosByIDCall(apiKey, galleryId, _callback);

    }

    /**
     * 
     * Returns a list of photos in a gallery.
     * @param apiKey  (required)
     * @param galleryId  (required)
     * @return GetGalleryPhotosByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetGalleryPhotosByID200Response getGalleryPhotosByID(String apiKey, String galleryId) throws ApiException {
        ApiResponse<GetGalleryPhotosByID200Response> localVarResp = getGalleryPhotosByIDWithHttpInfo(apiKey, galleryId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of photos in a gallery.
     * @param apiKey  (required)
     * @param galleryId  (required)
     * @return ApiResponse&lt;GetGalleryPhotosByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetGalleryPhotosByID200Response> getGalleryPhotosByIDWithHttpInfo(String apiKey, String galleryId) throws ApiException {
        okhttp3.Call localVarCall = getGalleryPhotosByIDValidateBeforeCall(apiKey, galleryId, null);
        Type localVarReturnType = new TypeToken<GetGalleryPhotosByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of photos in a gallery.
     * @param apiKey  (required)
     * @param galleryId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGalleryPhotosByIDAsync(String apiKey, String galleryId, final ApiCallback<GetGalleryPhotosByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGalleryPhotosByIDValidateBeforeCall(apiKey, galleryId, _callback);
        Type localVarReturnType = new TypeToken<GetGalleryPhotosByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupByID
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param groupPathAlias  (optional)
     * @param lang  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupByIDCall(String apiKey, String groupId, String groupPathAlias, String lang, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.groups.getInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        if (groupPathAlias != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_path_alias", groupPathAlias));
        }

        if (lang != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lang", lang));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupByIDValidateBeforeCall(String apiKey, String groupId, String groupPathAlias, String lang, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getGroupByID(Async)");
        }

        return getGroupByIDCall(apiKey, groupId, groupPathAlias, lang, _callback);

    }

    /**
     * 
     * Get information about a group
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param groupPathAlias  (optional)
     * @param lang  (optional)
     * @return GetGroupByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetGroupByID200Response getGroupByID(String apiKey, String groupId, String groupPathAlias, String lang) throws ApiException {
        ApiResponse<GetGroupByID200Response> localVarResp = getGroupByIDWithHttpInfo(apiKey, groupId, groupPathAlias, lang);
        return localVarResp.getData();
    }

    /**
     * 
     * Get information about a group
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param groupPathAlias  (optional)
     * @param lang  (optional)
     * @return ApiResponse&lt;GetGroupByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetGroupByID200Response> getGroupByIDWithHttpInfo(String apiKey, String groupId, String groupPathAlias, String lang) throws ApiException {
        okhttp3.Call localVarCall = getGroupByIDValidateBeforeCall(apiKey, groupId, groupPathAlias, lang, null);
        Type localVarReturnType = new TypeToken<GetGroupByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Get information about a group
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param groupPathAlias  (optional)
     * @param lang  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupByIDAsync(String apiKey, String groupId, String groupPathAlias, String lang, final ApiCallback<GetGroupByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupByIDValidateBeforeCall(apiKey, groupId, groupPathAlias, lang, _callback);
        Type localVarReturnType = new TypeToken<GetGroupByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupDiscussionsByID
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupDiscussionsByIDCall(String apiKey, String groupId, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.groups.discuss.topics.getList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupDiscussionsByIDValidateBeforeCall(String apiKey, String groupId, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getGroupDiscussionsByID(Async)");
        }

        return getGroupDiscussionsByIDCall(apiKey, groupId, page, perPage, _callback);

    }

    /**
     * 
     * Get a list of discussion topics in a group.
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return GetGroupDiscussionsByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetGroupDiscussionsByID200Response getGroupDiscussionsByID(String apiKey, String groupId, BigDecimal page, BigDecimal perPage) throws ApiException {
        ApiResponse<GetGroupDiscussionsByID200Response> localVarResp = getGroupDiscussionsByIDWithHttpInfo(apiKey, groupId, page, perPage);
        return localVarResp.getData();
    }

    /**
     * 
     * Get a list of discussion topics in a group.
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return ApiResponse&lt;GetGroupDiscussionsByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetGroupDiscussionsByID200Response> getGroupDiscussionsByIDWithHttpInfo(String apiKey, String groupId, BigDecimal page, BigDecimal perPage) throws ApiException {
        okhttp3.Call localVarCall = getGroupDiscussionsByIDValidateBeforeCall(apiKey, groupId, page, perPage, null);
        Type localVarReturnType = new TypeToken<GetGroupDiscussionsByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Get a list of discussion topics in a group.
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupDiscussionsByIDAsync(String apiKey, String groupId, BigDecimal page, BigDecimal perPage, final ApiCallback<GetGroupDiscussionsByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupDiscussionsByIDValidateBeforeCall(apiKey, groupId, page, perPage, _callback);
        Type localVarReturnType = new TypeToken<GetGroupDiscussionsByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupPhotosByID
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupPhotosByIDCall(String apiKey, String groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.groups.pools.getPhotos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupPhotosByIDValidateBeforeCall(String apiKey, String groupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getGroupPhotosByID(Async)");
        }

        return getGroupPhotosByIDCall(apiKey, groupId, _callback);

    }

    /**
     * 
     * Returns a list of pool photos for a given group
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @return GetGalleryPhotosByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetGalleryPhotosByID200Response getGroupPhotosByID(String apiKey, String groupId) throws ApiException {
        ApiResponse<GetGalleryPhotosByID200Response> localVarResp = getGroupPhotosByIDWithHttpInfo(apiKey, groupId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a list of pool photos for a given group
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @return ApiResponse&lt;GetGalleryPhotosByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetGalleryPhotosByID200Response> getGroupPhotosByIDWithHttpInfo(String apiKey, String groupId) throws ApiException {
        okhttp3.Call localVarCall = getGroupPhotosByIDValidateBeforeCall(apiKey, groupId, null);
        Type localVarReturnType = new TypeToken<GetGalleryPhotosByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a list of pool photos for a given group
     * @param apiKey  (required)
     * @param groupId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupPhotosByIDAsync(String apiKey, String groupId, final ApiCallback<GetGalleryPhotosByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupPhotosByIDValidateBeforeCall(apiKey, groupId, _callback);
        Type localVarReturnType = new TypeToken<GetGalleryPhotosByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupTopicByID
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param groupId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupTopicByIDCall(String apiKey, String topicId, String groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.groups.discuss.topics.getInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        if (topicId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("topic_id", topicId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupTopicByIDValidateBeforeCall(String apiKey, String topicId, String groupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getGroupTopicByID(Async)");
        }

        // verify the required parameter 'topicId' is set
        if (topicId == null) {
            throw new ApiException("Missing the required parameter 'topicId' when calling getGroupTopicByID(Async)");
        }

        return getGroupTopicByIDCall(apiKey, topicId, groupId, _callback);

    }

    /**
     * 
     * Get information about a group discussion topic
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param groupId  (optional)
     * @return GetGroupTopicByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetGroupTopicByID200Response getGroupTopicByID(String apiKey, String topicId, String groupId) throws ApiException {
        ApiResponse<GetGroupTopicByID200Response> localVarResp = getGroupTopicByIDWithHttpInfo(apiKey, topicId, groupId);
        return localVarResp.getData();
    }

    /**
     * 
     * Get information about a group discussion topic
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param groupId  (optional)
     * @return ApiResponse&lt;GetGroupTopicByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetGroupTopicByID200Response> getGroupTopicByIDWithHttpInfo(String apiKey, String topicId, String groupId) throws ApiException {
        okhttp3.Call localVarCall = getGroupTopicByIDValidateBeforeCall(apiKey, topicId, groupId, null);
        Type localVarReturnType = new TypeToken<GetGroupTopicByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Get information about a group discussion topic
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param groupId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupTopicByIDAsync(String apiKey, String topicId, String groupId, final ApiCallback<GetGroupTopicByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupTopicByIDValidateBeforeCall(apiKey, topicId, groupId, _callback);
        Type localVarReturnType = new TypeToken<GetGroupTopicByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupTopicRepliesByID
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param replyId  (required)
     * @param groupId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupTopicRepliesByIDCall(String apiKey, String topicId, String replyId, String groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.groups.discuss.replies.getInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        if (topicId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("topic_id", topicId));
        }

        if (replyId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reply_id", replyId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupTopicRepliesByIDValidateBeforeCall(String apiKey, String topicId, String replyId, String groupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getGroupTopicRepliesByID(Async)");
        }

        // verify the required parameter 'topicId' is set
        if (topicId == null) {
            throw new ApiException("Missing the required parameter 'topicId' when calling getGroupTopicRepliesByID(Async)");
        }

        // verify the required parameter 'replyId' is set
        if (replyId == null) {
            throw new ApiException("Missing the required parameter 'replyId' when calling getGroupTopicRepliesByID(Async)");
        }

        return getGroupTopicRepliesByIDCall(apiKey, topicId, replyId, groupId, _callback);

    }

    /**
     * 
     * Get information on a group topic reply
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param replyId  (required)
     * @param groupId  (optional)
     * @return GetGroupTopicRepliesByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetGroupTopicRepliesByID200Response getGroupTopicRepliesByID(String apiKey, String topicId, String replyId, String groupId) throws ApiException {
        ApiResponse<GetGroupTopicRepliesByID200Response> localVarResp = getGroupTopicRepliesByIDWithHttpInfo(apiKey, topicId, replyId, groupId);
        return localVarResp.getData();
    }

    /**
     * 
     * Get information on a group topic reply
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param replyId  (required)
     * @param groupId  (optional)
     * @return ApiResponse&lt;GetGroupTopicRepliesByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetGroupTopicRepliesByID200Response> getGroupTopicRepliesByIDWithHttpInfo(String apiKey, String topicId, String replyId, String groupId) throws ApiException {
        okhttp3.Call localVarCall = getGroupTopicRepliesByIDValidateBeforeCall(apiKey, topicId, replyId, groupId, null);
        Type localVarReturnType = new TypeToken<GetGroupTopicRepliesByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Get information on a group topic reply
     * @param apiKey  (required)
     * @param topicId  (required)
     * @param replyId  (required)
     * @param groupId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupTopicRepliesByIDAsync(String apiKey, String topicId, String replyId, String groupId, final ApiCallback<GetGroupTopicRepliesByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupTopicRepliesByIDValidateBeforeCall(apiKey, topicId, replyId, groupId, _callback);
        Type localVarReturnType = new TypeToken<GetGroupTopicRepliesByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getLicenseByID
     * @param apiKey  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLicenseByIDCall(String apiKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photos.licenses.getInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLicenseByIDValidateBeforeCall(String apiKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getLicenseByID(Async)");
        }

        return getLicenseByIDCall(apiKey, _callback);

    }

    /**
     * 
     * Fetches a list of available photo licenses for Flickr
     * @param apiKey  (required)
     * @return GetLicenseByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetLicenseByID200Response getLicenseByID(String apiKey) throws ApiException {
        ApiResponse<GetLicenseByID200Response> localVarResp = getLicenseByIDWithHttpInfo(apiKey);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetches a list of available photo licenses for Flickr
     * @param apiKey  (required)
     * @return ApiResponse&lt;GetLicenseByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetLicenseByID200Response> getLicenseByIDWithHttpInfo(String apiKey) throws ApiException {
        okhttp3.Call localVarCall = getLicenseByIDValidateBeforeCall(apiKey, null);
        Type localVarReturnType = new TypeToken<GetLicenseByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetches a list of available photo licenses for Flickr
     * @param apiKey  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLicenseByIDAsync(String apiKey, final ApiCallback<GetLicenseByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getLicenseByIDValidateBeforeCall(apiKey, _callback);
        Type localVarReturnType = new TypeToken<GetLicenseByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMediaByPersonID
     * @param apiKey  (required)
     * @param userId  (required)
     * @param safeSearch  (optional)
     * @param minUploadDate  (optional)
     * @param maxUploadDate  (optional)
     * @param minTakenDate  (optional)
     * @param maxTakenDate  (optional)
     * @param contentType  (optional)
     * @param privacyFilter  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMediaByPersonIDCall(String apiKey, String userId, BigDecimal safeSearch, BigDecimal minUploadDate, BigDecimal maxUploadDate, BigDecimal minTakenDate, BigDecimal maxTakenDate, BigDecimal contentType, BigDecimal privacyFilter, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.people.getPhotos";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (safeSearch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("safe_search", safeSearch));
        }

        if (minUploadDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min_upload_date", minUploadDate));
        }

        if (maxUploadDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_upload_date", maxUploadDate));
        }

        if (minTakenDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min_taken_date", minTakenDate));
        }

        if (maxTakenDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_taken_date", maxTakenDate));
        }

        if (contentType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("content_type", contentType));
        }

        if (privacyFilter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("privacy_filter", privacyFilter));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMediaByPersonIDValidateBeforeCall(String apiKey, String userId, BigDecimal safeSearch, BigDecimal minUploadDate, BigDecimal maxUploadDate, BigDecimal minTakenDate, BigDecimal maxTakenDate, BigDecimal contentType, BigDecimal privacyFilter, BigDecimal page, BigDecimal perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getMediaByPersonID(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getMediaByPersonID(Async)");
        }

        return getMediaByPersonIDCall(apiKey, userId, safeSearch, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, contentType, privacyFilter, page, perPage, _callback);

    }

    /**
     * 
     * Return photos from the given user&#39;s photostream
     * @param apiKey  (required)
     * @param userId  (required)
     * @param safeSearch  (optional)
     * @param minUploadDate  (optional)
     * @param maxUploadDate  (optional)
     * @param minTakenDate  (optional)
     * @param maxTakenDate  (optional)
     * @param contentType  (optional)
     * @param privacyFilter  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return GetFavoritesByPersonID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesByPersonID200Response getMediaByPersonID(String apiKey, String userId, BigDecimal safeSearch, BigDecimal minUploadDate, BigDecimal maxUploadDate, BigDecimal minTakenDate, BigDecimal maxTakenDate, BigDecimal contentType, BigDecimal privacyFilter, BigDecimal page, BigDecimal perPage) throws ApiException {
        ApiResponse<GetFavoritesByPersonID200Response> localVarResp = getMediaByPersonIDWithHttpInfo(apiKey, userId, safeSearch, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, contentType, privacyFilter, page, perPage);
        return localVarResp.getData();
    }

    /**
     * 
     * Return photos from the given user&#39;s photostream
     * @param apiKey  (required)
     * @param userId  (required)
     * @param safeSearch  (optional)
     * @param minUploadDate  (optional)
     * @param maxUploadDate  (optional)
     * @param minTakenDate  (optional)
     * @param maxTakenDate  (optional)
     * @param contentType  (optional)
     * @param privacyFilter  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @return ApiResponse&lt;GetFavoritesByPersonID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesByPersonID200Response> getMediaByPersonIDWithHttpInfo(String apiKey, String userId, BigDecimal safeSearch, BigDecimal minUploadDate, BigDecimal maxUploadDate, BigDecimal minTakenDate, BigDecimal maxTakenDate, BigDecimal contentType, BigDecimal privacyFilter, BigDecimal page, BigDecimal perPage) throws ApiException {
        okhttp3.Call localVarCall = getMediaByPersonIDValidateBeforeCall(apiKey, userId, safeSearch, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, contentType, privacyFilter, page, perPage, null);
        Type localVarReturnType = new TypeToken<GetFavoritesByPersonID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Return photos from the given user&#39;s photostream
     * @param apiKey  (required)
     * @param userId  (required)
     * @param safeSearch  (optional)
     * @param minUploadDate  (optional)
     * @param maxUploadDate  (optional)
     * @param minTakenDate  (optional)
     * @param maxTakenDate  (optional)
     * @param contentType  (optional)
     * @param privacyFilter  (optional)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMediaByPersonIDAsync(String apiKey, String userId, BigDecimal safeSearch, BigDecimal minUploadDate, BigDecimal maxUploadDate, BigDecimal minTakenDate, BigDecimal maxTakenDate, BigDecimal contentType, BigDecimal privacyFilter, BigDecimal page, BigDecimal perPage, final ApiCallback<GetFavoritesByPersonID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMediaByPersonIDValidateBeforeCall(apiKey, userId, safeSearch, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, contentType, privacyFilter, page, perPage, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesByPersonID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMediaBySearch
     * @param apiKey  (required)
     * @param text A free text search. Photos who&#39;s title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param tags A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param userId The NSID of the user who&#39;s photo to search. If this parameter isn&#39;t passed then everybody&#39;s public photos will be searched. A value of \&quot;me\&quot; will search against the calling user&#39;s photos for authenticated calls. (optional)
     * @param minUploadDate Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param maxUploadDate Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param minTakenDate Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param maxTakenDate Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param license The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated. (optional)
     * @param sort The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:   date-posted-asc,   date-posted-desc,   date-taken-asc,   date-taken-desc,   interestingness-desc,   interestingness-asc, and   relevance.  (optional)
     * @param privacyFilter Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,   1: public photos,   2: private photos visible to friends,   3: private photos visible to family,   4: private photos visible to friends &amp; family,   5: completely private photos  (optional)
     * @param bbox A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched. (optional)
     * @param accuracy Recorded accuracy level of the location information. Current range is 1-16:   World level is 1   Country is ~3   Region is ~6   City is ~11   Street is ~16  (optional)
     * @param safeSearch Safe search setting:   1: for safe,   2: for moderate,   3: for restricted  (optional)
     * @param contentType Content Type setting:   1: photos only.   2: screenshots only.   3: &#39;other&#39; only.   4: photos and screenshots.   5: screenshots and &#39;other&#39;.   6: photos and &#39;other&#39;.   7: photos, screenshots, and &#39;other&#39; (all).  (optional)
     * @param machineTags Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:\&quot; Find photos with a title in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\&quot; Find photos titled \&quot;mr. camera\&quot; in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\\\&quot;mr. camera\\\&quot; Find photos whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos that have a title, in any namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\&quot; Find photos that have a title, in any namespace, whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos, in the &#39;dc&#39; namespace whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \&quot;AND\&quot; queries are limited to (16) machine tags. \&quot;OR\&quot; queries are limited to (8).  (optional)
     * @param machineTagMode Either &#39;any&#39; for an OR combination of tags, or &#39;all&#39; for an AND combination. Defaults to &#39;any&#39; if not specified. (optional)
     * @param groupId The id of a group who&#39;s pool to search. If specified, only matching photos posted to the group&#39;s pool will be returned. (optional)
     * @param contacts Search your contacts. Either &#39;all&#39; or &#39;ff&#39; for just friends and family. (Experimental) (optional)
     * @param woeId A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present). (optional)
     * @param placeId A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param media Filter results by media type. Possible values are all (default), photos or videos (optional)
     * @param hasGeo Any photo that has been geotagged, or if the value is \&quot;0\&quot; any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param geoContext Geo context is a numeric value representing the photo&#39;s geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \&quot;indoors\&quot; or \&quot;outdoors\&quot;. The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lat A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lon A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param radius A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km). (optional)
     * @param radiusUnits The unit of measure when doing radial geo queries. Valid options are \&quot;mi\&quot; (miles) and \&quot;km\&quot; (kilometers). The default is \&quot;km\&quot;. (optional)
     * @param isCommons Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false. (optional)
     * @param inGallery Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos. (optional)
     * @param isGetty Limit the scope of the search to only photos that are for sale on Getty. Default is false. (optional)
     * @param perPage Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500. (optional)
     * @param page The page of results to return. If this argument is omitted, it defaults to 1. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMediaBySearchCall(String apiKey, String text, String tags, String userId, String minUploadDate, String maxUploadDate, String minTakenDate, String maxTakenDate, String license, String sort, BigDecimal privacyFilter, String bbox, String accuracy, BigDecimal safeSearch, BigDecimal contentType, String machineTags, String machineTagMode, String groupId, String contacts, String woeId, String placeId, String media, String hasGeo, String geoContext, String lat, String lon, BigDecimal radius, String radiusUnits, Boolean isCommons, Boolean inGallery, Boolean isGetty, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photos.search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (text != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("text", text));
        }

        if (tags != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tags", tags));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (minUploadDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min_upload_date", minUploadDate));
        }

        if (maxUploadDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_upload_date", maxUploadDate));
        }

        if (minTakenDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min_taken_date", minTakenDate));
        }

        if (maxTakenDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_taken_date", maxTakenDate));
        }

        if (license != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("license", license));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (privacyFilter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("privacy_filter", privacyFilter));
        }

        if (bbox != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bbox", bbox));
        }

        if (accuracy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accuracy", accuracy));
        }

        if (safeSearch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("safe_search", safeSearch));
        }

        if (contentType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("content_type", contentType));
        }

        if (machineTags != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("machine_tags", machineTags));
        }

        if (machineTagMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("machine_tag_mode", machineTagMode));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        if (contacts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contacts", contacts));
        }

        if (woeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("woe_id", woeId));
        }

        if (placeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("place_id", placeId));
        }

        if (media != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("media", media));
        }

        if (hasGeo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("has_geo", hasGeo));
        }

        if (geoContext != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("geo_context", geoContext));
        }

        if (lat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lat", lat));
        }

        if (lon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lon", lon));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (radiusUnits != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius_units", radiusUnits));
        }

        if (isCommons != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_commons", isCommons));
        }

        if (inGallery != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("in_gallery", inGallery));
        }

        if (isGetty != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_getty", isGetty));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMediaBySearchValidateBeforeCall(String apiKey, String text, String tags, String userId, String minUploadDate, String maxUploadDate, String minTakenDate, String maxTakenDate, String license, String sort, BigDecimal privacyFilter, String bbox, String accuracy, BigDecimal safeSearch, BigDecimal contentType, String machineTags, String machineTagMode, String groupId, String contacts, String woeId, String placeId, String media, String hasGeo, String geoContext, String lat, String lon, BigDecimal radius, String radiusUnits, Boolean isCommons, Boolean inGallery, Boolean isGetty, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getMediaBySearch(Async)");
        }

        return getMediaBySearchCall(apiKey, text, tags, userId, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, license, sort, privacyFilter, bbox, accuracy, safeSearch, contentType, machineTags, machineTagMode, groupId, contacts, woeId, placeId, media, hasGeo, geoContext, lat, lon, radius, radiusUnits, isCommons, inGallery, isGetty, perPage, page, _callback);

    }

    /**
     * 
     * Return a list of photos matching some criteria.
     * @param apiKey  (required)
     * @param text A free text search. Photos who&#39;s title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param tags A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param userId The NSID of the user who&#39;s photo to search. If this parameter isn&#39;t passed then everybody&#39;s public photos will be searched. A value of \&quot;me\&quot; will search against the calling user&#39;s photos for authenticated calls. (optional)
     * @param minUploadDate Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param maxUploadDate Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param minTakenDate Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param maxTakenDate Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param license The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated. (optional)
     * @param sort The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:   date-posted-asc,   date-posted-desc,   date-taken-asc,   date-taken-desc,   interestingness-desc,   interestingness-asc, and   relevance.  (optional)
     * @param privacyFilter Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,   1: public photos,   2: private photos visible to friends,   3: private photos visible to family,   4: private photos visible to friends &amp; family,   5: completely private photos  (optional)
     * @param bbox A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched. (optional)
     * @param accuracy Recorded accuracy level of the location information. Current range is 1-16:   World level is 1   Country is ~3   Region is ~6   City is ~11   Street is ~16  (optional)
     * @param safeSearch Safe search setting:   1: for safe,   2: for moderate,   3: for restricted  (optional)
     * @param contentType Content Type setting:   1: photos only.   2: screenshots only.   3: &#39;other&#39; only.   4: photos and screenshots.   5: screenshots and &#39;other&#39;.   6: photos and &#39;other&#39;.   7: photos, screenshots, and &#39;other&#39; (all).  (optional)
     * @param machineTags Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:\&quot; Find photos with a title in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\&quot; Find photos titled \&quot;mr. camera\&quot; in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\\\&quot;mr. camera\\\&quot; Find photos whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos that have a title, in any namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\&quot; Find photos that have a title, in any namespace, whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos, in the &#39;dc&#39; namespace whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \&quot;AND\&quot; queries are limited to (16) machine tags. \&quot;OR\&quot; queries are limited to (8).  (optional)
     * @param machineTagMode Either &#39;any&#39; for an OR combination of tags, or &#39;all&#39; for an AND combination. Defaults to &#39;any&#39; if not specified. (optional)
     * @param groupId The id of a group who&#39;s pool to search. If specified, only matching photos posted to the group&#39;s pool will be returned. (optional)
     * @param contacts Search your contacts. Either &#39;all&#39; or &#39;ff&#39; for just friends and family. (Experimental) (optional)
     * @param woeId A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present). (optional)
     * @param placeId A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param media Filter results by media type. Possible values are all (default), photos or videos (optional)
     * @param hasGeo Any photo that has been geotagged, or if the value is \&quot;0\&quot; any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param geoContext Geo context is a numeric value representing the photo&#39;s geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \&quot;indoors\&quot; or \&quot;outdoors\&quot;. The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lat A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lon A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param radius A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km). (optional)
     * @param radiusUnits The unit of measure when doing radial geo queries. Valid options are \&quot;mi\&quot; (miles) and \&quot;km\&quot; (kilometers). The default is \&quot;km\&quot;. (optional)
     * @param isCommons Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false. (optional)
     * @param inGallery Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos. (optional)
     * @param isGetty Limit the scope of the search to only photos that are for sale on Getty. Default is false. (optional)
     * @param perPage Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500. (optional)
     * @param page The page of results to return. If this argument is omitted, it defaults to 1. (optional)
     * @return GetFavoritesByPersonID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesByPersonID200Response getMediaBySearch(String apiKey, String text, String tags, String userId, String minUploadDate, String maxUploadDate, String minTakenDate, String maxTakenDate, String license, String sort, BigDecimal privacyFilter, String bbox, String accuracy, BigDecimal safeSearch, BigDecimal contentType, String machineTags, String machineTagMode, String groupId, String contacts, String woeId, String placeId, String media, String hasGeo, String geoContext, String lat, String lon, BigDecimal radius, String radiusUnits, Boolean isCommons, Boolean inGallery, Boolean isGetty, BigDecimal perPage, BigDecimal page) throws ApiException {
        ApiResponse<GetFavoritesByPersonID200Response> localVarResp = getMediaBySearchWithHttpInfo(apiKey, text, tags, userId, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, license, sort, privacyFilter, bbox, accuracy, safeSearch, contentType, machineTags, machineTagMode, groupId, contacts, woeId, placeId, media, hasGeo, geoContext, lat, lon, radius, radiusUnits, isCommons, inGallery, isGetty, perPage, page);
        return localVarResp.getData();
    }

    /**
     * 
     * Return a list of photos matching some criteria.
     * @param apiKey  (required)
     * @param text A free text search. Photos who&#39;s title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param tags A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param userId The NSID of the user who&#39;s photo to search. If this parameter isn&#39;t passed then everybody&#39;s public photos will be searched. A value of \&quot;me\&quot; will search against the calling user&#39;s photos for authenticated calls. (optional)
     * @param minUploadDate Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param maxUploadDate Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param minTakenDate Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param maxTakenDate Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param license The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated. (optional)
     * @param sort The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:   date-posted-asc,   date-posted-desc,   date-taken-asc,   date-taken-desc,   interestingness-desc,   interestingness-asc, and   relevance.  (optional)
     * @param privacyFilter Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,   1: public photos,   2: private photos visible to friends,   3: private photos visible to family,   4: private photos visible to friends &amp; family,   5: completely private photos  (optional)
     * @param bbox A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched. (optional)
     * @param accuracy Recorded accuracy level of the location information. Current range is 1-16:   World level is 1   Country is ~3   Region is ~6   City is ~11   Street is ~16  (optional)
     * @param safeSearch Safe search setting:   1: for safe,   2: for moderate,   3: for restricted  (optional)
     * @param contentType Content Type setting:   1: photos only.   2: screenshots only.   3: &#39;other&#39; only.   4: photos and screenshots.   5: screenshots and &#39;other&#39;.   6: photos and &#39;other&#39;.   7: photos, screenshots, and &#39;other&#39; (all).  (optional)
     * @param machineTags Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:\&quot; Find photos with a title in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\&quot; Find photos titled \&quot;mr. camera\&quot; in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\\\&quot;mr. camera\\\&quot; Find photos whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos that have a title, in any namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\&quot; Find photos that have a title, in any namespace, whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos, in the &#39;dc&#39; namespace whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \&quot;AND\&quot; queries are limited to (16) machine tags. \&quot;OR\&quot; queries are limited to (8).  (optional)
     * @param machineTagMode Either &#39;any&#39; for an OR combination of tags, or &#39;all&#39; for an AND combination. Defaults to &#39;any&#39; if not specified. (optional)
     * @param groupId The id of a group who&#39;s pool to search. If specified, only matching photos posted to the group&#39;s pool will be returned. (optional)
     * @param contacts Search your contacts. Either &#39;all&#39; or &#39;ff&#39; for just friends and family. (Experimental) (optional)
     * @param woeId A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present). (optional)
     * @param placeId A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param media Filter results by media type. Possible values are all (default), photos or videos (optional)
     * @param hasGeo Any photo that has been geotagged, or if the value is \&quot;0\&quot; any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param geoContext Geo context is a numeric value representing the photo&#39;s geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \&quot;indoors\&quot; or \&quot;outdoors\&quot;. The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lat A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lon A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param radius A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km). (optional)
     * @param radiusUnits The unit of measure when doing radial geo queries. Valid options are \&quot;mi\&quot; (miles) and \&quot;km\&quot; (kilometers). The default is \&quot;km\&quot;. (optional)
     * @param isCommons Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false. (optional)
     * @param inGallery Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos. (optional)
     * @param isGetty Limit the scope of the search to only photos that are for sale on Getty. Default is false. (optional)
     * @param perPage Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500. (optional)
     * @param page The page of results to return. If this argument is omitted, it defaults to 1. (optional)
     * @return ApiResponse&lt;GetFavoritesByPersonID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesByPersonID200Response> getMediaBySearchWithHttpInfo(String apiKey, String text, String tags, String userId, String minUploadDate, String maxUploadDate, String minTakenDate, String maxTakenDate, String license, String sort, BigDecimal privacyFilter, String bbox, String accuracy, BigDecimal safeSearch, BigDecimal contentType, String machineTags, String machineTagMode, String groupId, String contacts, String woeId, String placeId, String media, String hasGeo, String geoContext, String lat, String lon, BigDecimal radius, String radiusUnits, Boolean isCommons, Boolean inGallery, Boolean isGetty, BigDecimal perPage, BigDecimal page) throws ApiException {
        okhttp3.Call localVarCall = getMediaBySearchValidateBeforeCall(apiKey, text, tags, userId, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, license, sort, privacyFilter, bbox, accuracy, safeSearch, contentType, machineTags, machineTagMode, groupId, contacts, woeId, placeId, media, hasGeo, geoContext, lat, lon, radius, radiusUnits, isCommons, inGallery, isGetty, perPage, page, null);
        Type localVarReturnType = new TypeToken<GetFavoritesByPersonID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Return a list of photos matching some criteria.
     * @param apiKey  (required)
     * @param text A free text search. Photos who&#39;s title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param tags A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
     * @param userId The NSID of the user who&#39;s photo to search. If this parameter isn&#39;t passed then everybody&#39;s public photos will be searched. A value of \&quot;me\&quot; will search against the calling user&#39;s photos for authenticated calls. (optional)
     * @param minUploadDate Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param maxUploadDate Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
     * @param minTakenDate Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param maxTakenDate Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
     * @param license The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated. (optional)
     * @param sort The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:   date-posted-asc,   date-posted-desc,   date-taken-asc,   date-taken-desc,   interestingness-desc,   interestingness-asc, and   relevance.  (optional)
     * @param privacyFilter Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,   1: public photos,   2: private photos visible to friends,   3: private photos visible to family,   4: private photos visible to friends &amp; family,   5: completely private photos  (optional)
     * @param bbox A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched. (optional)
     * @param accuracy Recorded accuracy level of the location information. Current range is 1-16:   World level is 1   Country is ~3   Region is ~6   City is ~11   Street is ~16  (optional)
     * @param safeSearch Safe search setting:   1: for safe,   2: for moderate,   3: for restricted  (optional)
     * @param contentType Content Type setting:   1: photos only.   2: screenshots only.   3: &#39;other&#39; only.   4: photos and screenshots.   5: screenshots and &#39;other&#39;.   6: photos and &#39;other&#39;.   7: photos, screenshots, and &#39;other&#39; (all).  (optional)
     * @param machineTags Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:\&quot; Find photos with a title in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\&quot; Find photos titled \&quot;mr. camera\&quot; in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\\\&quot;mr. camera\\\&quot; Find photos whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos that have a title, in any namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\&quot; Find photos that have a title, in any namespace, whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos, in the &#39;dc&#39; namespace whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \&quot;AND\&quot; queries are limited to (16) machine tags. \&quot;OR\&quot; queries are limited to (8).  (optional)
     * @param machineTagMode Either &#39;any&#39; for an OR combination of tags, or &#39;all&#39; for an AND combination. Defaults to &#39;any&#39; if not specified. (optional)
     * @param groupId The id of a group who&#39;s pool to search. If specified, only matching photos posted to the group&#39;s pool will be returned. (optional)
     * @param contacts Search your contacts. Either &#39;all&#39; or &#39;ff&#39; for just friends and family. (Experimental) (optional)
     * @param woeId A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present). (optional)
     * @param placeId A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param media Filter results by media type. Possible values are all (default), photos or videos (optional)
     * @param hasGeo Any photo that has been geotagged, or if the value is \&quot;0\&quot; any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param geoContext Geo context is a numeric value representing the photo&#39;s geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \&quot;indoors\&quot; or \&quot;outdoors\&quot;. The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lat A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param lon A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters  If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
     * @param radius A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km). (optional)
     * @param radiusUnits The unit of measure when doing radial geo queries. Valid options are \&quot;mi\&quot; (miles) and \&quot;km\&quot; (kilometers). The default is \&quot;km\&quot;. (optional)
     * @param isCommons Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false. (optional)
     * @param inGallery Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos. (optional)
     * @param isGetty Limit the scope of the search to only photos that are for sale on Getty. Default is false. (optional)
     * @param perPage Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500. (optional)
     * @param page The page of results to return. If this argument is omitted, it defaults to 1. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMediaBySearchAsync(String apiKey, String text, String tags, String userId, String minUploadDate, String maxUploadDate, String minTakenDate, String maxTakenDate, String license, String sort, BigDecimal privacyFilter, String bbox, String accuracy, BigDecimal safeSearch, BigDecimal contentType, String machineTags, String machineTagMode, String groupId, String contacts, String woeId, String placeId, String media, String hasGeo, String geoContext, String lat, String lon, BigDecimal radius, String radiusUnits, Boolean isCommons, Boolean inGallery, Boolean isGetty, BigDecimal perPage, BigDecimal page, final ApiCallback<GetFavoritesByPersonID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMediaBySearchValidateBeforeCall(apiKey, text, tags, userId, minUploadDate, maxUploadDate, minTakenDate, maxTakenDate, license, sort, privacyFilter, bbox, accuracy, safeSearch, contentType, machineTags, machineTagMode, groupId, contacts, woeId, placeId, media, hasGeo, geoContext, lat, lon, radius, radiusUnits, isCommons, inGallery, isGetty, perPage, page, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesByPersonID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPersonByID
     * @param apiKey  (required)
     * @param userId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPersonByIDCall(String apiKey, String userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.people.getInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPersonByIDValidateBeforeCall(String apiKey, String userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getPersonByID(Async)");
        }

        return getPersonByIDCall(apiKey, userId, _callback);

    }

    /**
     * 
     * Returns a person
     * @param apiKey  (required)
     * @param userId  (optional)
     * @return GetPersonByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetPersonByID200Response getPersonByID(String apiKey, String userId) throws ApiException {
        ApiResponse<GetPersonByID200Response> localVarResp = getPersonByIDWithHttpInfo(apiKey, userId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a person
     * @param apiKey  (required)
     * @param userId  (optional)
     * @return ApiResponse&lt;GetPersonByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetPersonByID200Response> getPersonByIDWithHttpInfo(String apiKey, String userId) throws ApiException {
        okhttp3.Call localVarCall = getPersonByIDValidateBeforeCall(apiKey, userId, null);
        Type localVarReturnType = new TypeToken<GetPersonByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a person
     * @param apiKey  (required)
     * @param userId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPersonByIDAsync(String apiKey, String userId, final ApiCallback<GetPersonByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPersonByIDValidateBeforeCall(apiKey, userId, _callback);
        Type localVarReturnType = new TypeToken<GetPersonByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPhotoByID
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a photo </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotoByIDCall(String apiKey, String photoId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photos.getInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPhotoByIDValidateBeforeCall(String apiKey, String photoId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getPhotoByID(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling getPhotoByID(Async)");
        }

        return getPhotoByIDCall(apiKey, photoId, _callback);

    }

    /**
     * 
     * Returns a photo
     * @param apiKey  (required)
     * @param photoId  (required)
     * @return GetPhotoByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a photo </td><td>  -  </td></tr>
     </table>
     */
    public GetPhotoByID200Response getPhotoByID(String apiKey, String photoId) throws ApiException {
        ApiResponse<GetPhotoByID200Response> localVarResp = getPhotoByIDWithHttpInfo(apiKey, photoId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns a photo
     * @param apiKey  (required)
     * @param photoId  (required)
     * @return ApiResponse&lt;GetPhotoByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a photo </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetPhotoByID200Response> getPhotoByIDWithHttpInfo(String apiKey, String photoId) throws ApiException {
        okhttp3.Call localVarCall = getPhotoByIDValidateBeforeCall(apiKey, photoId, null);
        Type localVarReturnType = new TypeToken<GetPhotoByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns a photo
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> a photo </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotoByIDAsync(String apiKey, String photoId, final ApiCallback<GetPhotoByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPhotoByIDValidateBeforeCall(apiKey, photoId, _callback);
        Type localVarReturnType = new TypeToken<GetPhotoByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPhotoExifByID
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param secret  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotoExifByIDCall(String apiKey, String photoId, String secret, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photos.getExif";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        if (secret != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secret", secret));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPhotoExifByIDValidateBeforeCall(String apiKey, String photoId, String secret, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getPhotoExifByID(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling getPhotoExifByID(Async)");
        }

        return getPhotoExifByIDCall(apiKey, photoId, secret, _callback);

    }

    /**
     * 
     * Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param secret  (optional)
     * @return GetPhotoExifByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetPhotoExifByID200Response getPhotoExifByID(String apiKey, String photoId, String secret) throws ApiException {
        ApiResponse<GetPhotoExifByID200Response> localVarResp = getPhotoExifByIDWithHttpInfo(apiKey, photoId, secret);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param secret  (optional)
     * @return ApiResponse&lt;GetPhotoExifByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetPhotoExifByID200Response> getPhotoExifByIDWithHttpInfo(String apiKey, String photoId, String secret) throws ApiException {
        okhttp3.Call localVarCall = getPhotoExifByIDValidateBeforeCall(apiKey, photoId, secret, null);
        Type localVarReturnType = new TypeToken<GetPhotoExifByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param secret  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotoExifByIDAsync(String apiKey, String photoId, String secret, final ApiCallback<GetPhotoExifByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPhotoExifByIDValidateBeforeCall(apiKey, photoId, secret, _callback);
        Type localVarReturnType = new TypeToken<GetPhotoExifByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPhotoSizesByID
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Photo sizes </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotoSizesByIDCall(String apiKey, String photoId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photos.getSizes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPhotoSizesByIDValidateBeforeCall(String apiKey, String photoId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getPhotoSizesByID(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling getPhotoSizesByID(Async)");
        }

        return getPhotoSizesByIDCall(apiKey, photoId, _callback);

    }

    /**
     * 
     * Returns photo sizes
     * @param apiKey  (required)
     * @param photoId  (required)
     * @return GetPhotoSizesByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Photo sizes </td><td>  -  </td></tr>
     </table>
     */
    public GetPhotoSizesByID200Response getPhotoSizesByID(String apiKey, String photoId) throws ApiException {
        ApiResponse<GetPhotoSizesByID200Response> localVarResp = getPhotoSizesByIDWithHttpInfo(apiKey, photoId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns photo sizes
     * @param apiKey  (required)
     * @param photoId  (required)
     * @return ApiResponse&lt;GetPhotoSizesByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Photo sizes </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetPhotoSizesByID200Response> getPhotoSizesByIDWithHttpInfo(String apiKey, String photoId) throws ApiException {
        okhttp3.Call localVarCall = getPhotoSizesByIDValidateBeforeCall(apiKey, photoId, null);
        Type localVarReturnType = new TypeToken<GetPhotoSizesByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns photo sizes
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Photo sizes </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotoSizesByIDAsync(String apiKey, String photoId, final ApiCallback<GetPhotoSizesByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPhotoSizesByIDValidateBeforeCall(apiKey, photoId, _callback);
        Type localVarReturnType = new TypeToken<GetPhotoSizesByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPhotolistContextByID
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photolistId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotolistContextByIDCall(String apiKey, String photoId, String photolistId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photolist.getContext";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        if (photolistId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photolist_id", photolistId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPhotolistContextByIDValidateBeforeCall(String apiKey, String photoId, String photolistId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getPhotolistContextByID(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling getPhotolistContextByID(Async)");
        }

        // verify the required parameter 'photolistId' is set
        if (photolistId == null) {
            throw new ApiException("Missing the required parameter 'photolistId' when calling getPhotolistContextByID(Async)");
        }

        return getPhotolistContextByIDCall(apiKey, photoId, photolistId, _callback);

    }

    /**
     * 
     * Returns next and previous photos in a photo list
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photolistId  (required)
     * @return GetFavoritesContextByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesContextByID200Response getPhotolistContextByID(String apiKey, String photoId, String photolistId) throws ApiException {
        ApiResponse<GetFavoritesContextByID200Response> localVarResp = getPhotolistContextByIDWithHttpInfo(apiKey, photoId, photolistId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns next and previous photos in a photo list
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photolistId  (required)
     * @return ApiResponse&lt;GetFavoritesContextByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesContextByID200Response> getPhotolistContextByIDWithHttpInfo(String apiKey, String photoId, String photolistId) throws ApiException {
        okhttp3.Call localVarCall = getPhotolistContextByIDValidateBeforeCall(apiKey, photoId, photolistId, null);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns next and previous photos in a photo list
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param photolistId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotolistContextByIDAsync(String apiKey, String photoId, String photolistId, final ApiCallback<GetFavoritesContextByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPhotolistContextByIDValidateBeforeCall(apiKey, photoId, photolistId, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPhotostreamContextByID
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotostreamContextByIDCall(String apiKey, String photoId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.photos.getContext";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPhotostreamContextByIDValidateBeforeCall(String apiKey, String photoId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling getPhotostreamContextByID(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling getPhotostreamContextByID(Async)");
        }

        return getPhotostreamContextByIDCall(apiKey, photoId, _callback);

    }

    /**
     * 
     * Returns next and previous photos for a photo in a photostream
     * @param apiKey  (required)
     * @param photoId  (required)
     * @return GetFavoritesContextByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesContextByID200Response getPhotostreamContextByID(String apiKey, String photoId) throws ApiException {
        ApiResponse<GetFavoritesContextByID200Response> localVarResp = getPhotostreamContextByIDWithHttpInfo(apiKey, photoId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns next and previous photos for a photo in a photostream
     * @param apiKey  (required)
     * @param photoId  (required)
     * @return ApiResponse&lt;GetFavoritesContextByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesContextByID200Response> getPhotostreamContextByIDWithHttpInfo(String apiKey, String photoId) throws ApiException {
        okhttp3.Call localVarCall = getPhotostreamContextByIDValidateBeforeCall(apiKey, photoId, null);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns next and previous photos for a photo in a photostream
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPhotostreamContextByIDAsync(String apiKey, String photoId, final ApiCallback<GetFavoritesContextByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPhotostreamContextByIDValidateBeforeCall(apiKey, photoId, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRequestToken
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthCallback  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRequestTokenCall(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/oauth/request_token";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (oauthConsumerKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_consumer_key", oauthConsumerKey));
        }

        if (oauthNonce != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_nonce", oauthNonce));
        }

        if (oauthTimestamp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_timestamp", oauthTimestamp));
        }

        if (oauthSignatureMethod != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_signature_method", oauthSignatureMethod));
        }

        if (oauthVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_version", oauthVersion));
        }

        if (oauthSignature != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_signature", oauthSignature));
        }

        if (oauthCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oauth_callback", oauthCallback));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRequestTokenValidateBeforeCall(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'oauthConsumerKey' is set
        if (oauthConsumerKey == null) {
            throw new ApiException("Missing the required parameter 'oauthConsumerKey' when calling getRequestToken(Async)");
        }

        // verify the required parameter 'oauthNonce' is set
        if (oauthNonce == null) {
            throw new ApiException("Missing the required parameter 'oauthNonce' when calling getRequestToken(Async)");
        }

        // verify the required parameter 'oauthTimestamp' is set
        if (oauthTimestamp == null) {
            throw new ApiException("Missing the required parameter 'oauthTimestamp' when calling getRequestToken(Async)");
        }

        // verify the required parameter 'oauthSignatureMethod' is set
        if (oauthSignatureMethod == null) {
            throw new ApiException("Missing the required parameter 'oauthSignatureMethod' when calling getRequestToken(Async)");
        }

        // verify the required parameter 'oauthVersion' is set
        if (oauthVersion == null) {
            throw new ApiException("Missing the required parameter 'oauthVersion' when calling getRequestToken(Async)");
        }

        // verify the required parameter 'oauthSignature' is set
        if (oauthSignature == null) {
            throw new ApiException("Missing the required parameter 'oauthSignature' when calling getRequestToken(Async)");
        }

        // verify the required parameter 'oauthCallback' is set
        if (oauthCallback == null) {
            throw new ApiException("Missing the required parameter 'oauthCallback' when calling getRequestToken(Async)");
        }

        return getRequestTokenCall(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthCallback, _callback);

    }

    /**
     * 
     * Returns an oauth token and oauth token secret
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthCallback  (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public String getRequestToken(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthCallback) throws ApiException {
        ApiResponse<String> localVarResp = getRequestTokenWithHttpInfo(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthCallback);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns an oauth token and oauth token secret
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthCallback  (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> getRequestTokenWithHttpInfo(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthCallback) throws ApiException {
        okhttp3.Call localVarCall = getRequestTokenValidateBeforeCall(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthCallback, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns an oauth token and oauth token secret
     * @param oauthConsumerKey  (required)
     * @param oauthNonce  (required)
     * @param oauthTimestamp  (required)
     * @param oauthSignatureMethod  (required)
     * @param oauthVersion  (required)
     * @param oauthSignature  (required)
     * @param oauthCallback  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRequestTokenAsync(String oauthConsumerKey, String oauthNonce, String oauthTimestamp, String oauthSignatureMethod, String oauthVersion, String oauthSignature, String oauthCallback, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRequestTokenValidateBeforeCall(oauthConsumerKey, oauthNonce, oauthTimestamp, oauthSignatureMethod, oauthVersion, oauthSignature, oauthCallback, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for restmethodflickrGroupsPoolsGetContextGet
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param groupId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call restmethodflickrGroupsPoolsGetContextGetCall(String apiKey, String photoId, String groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest?method=flickr.groups.pools.getContext";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_key", apiKey));
        }

        if (photoId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("photo_id", photoId));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call restmethodflickrGroupsPoolsGetContextGetValidateBeforeCall(String apiKey, String photoId, String groupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling restmethodflickrGroupsPoolsGetContextGet(Async)");
        }

        // verify the required parameter 'photoId' is set
        if (photoId == null) {
            throw new ApiException("Missing the required parameter 'photoId' when calling restmethodflickrGroupsPoolsGetContextGet(Async)");
        }

        return restmethodflickrGroupsPoolsGetContextGetCall(apiKey, photoId, groupId, _callback);

    }

    /**
     * 
     * Returns next and previous photos for a photo in a group pool
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param groupId  (optional)
     * @return GetFavoritesContextByID200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesContextByID200Response restmethodflickrGroupsPoolsGetContextGet(String apiKey, String photoId, String groupId) throws ApiException {
        ApiResponse<GetFavoritesContextByID200Response> localVarResp = restmethodflickrGroupsPoolsGetContextGetWithHttpInfo(apiKey, photoId, groupId);
        return localVarResp.getData();
    }

    /**
     * 
     * Returns next and previous photos for a photo in a group pool
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param groupId  (optional)
     * @return ApiResponse&lt;GetFavoritesContextByID200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFavoritesContextByID200Response> restmethodflickrGroupsPoolsGetContextGetWithHttpInfo(String apiKey, String photoId, String groupId) throws ApiException {
        okhttp3.Call localVarCall = restmethodflickrGroupsPoolsGetContextGetValidateBeforeCall(apiKey, photoId, groupId, null);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Returns next and previous photos for a photo in a group pool
     * @param apiKey  (required)
     * @param photoId  (required)
     * @param groupId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call restmethodflickrGroupsPoolsGetContextGetAsync(String apiKey, String photoId, String groupId, final ApiCallback<GetFavoritesContextByID200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = restmethodflickrGroupsPoolsGetContextGetValidateBeforeCall(apiKey, photoId, groupId, _callback);
        Type localVarReturnType = new TypeToken<GetFavoritesContextByID200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for uploadPhoto
     * @param apiKey  (required)
     * @param photo  (required)
     * @param contentType  (optional)
     * @param description  (optional)
     * @param hidden  (optional)
     * @param isFamily  (optional)
     * @param isFriend  (optional)
     * @param isPublic  (optional)
     * @param safetyLevel  (optional)
     * @param tags  (optional)
     * @param title  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uploadPhotoCall(String apiKey, File photo, String contentType, String description, String hidden, String isFamily, String isFriend, String isPublic, String safetyLevel, String tags, String title, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/upload";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiKey != null) {
            localVarFormParams.put("api_key", apiKey);
        }

        if (contentType != null) {
            localVarFormParams.put("content_type", contentType);
        }

        if (description != null) {
            localVarFormParams.put("description", description);
        }

        if (hidden != null) {
            localVarFormParams.put("hidden", hidden);
        }

        if (isFamily != null) {
            localVarFormParams.put("is_family", isFamily);
        }

        if (isFriend != null) {
            localVarFormParams.put("is_friend", isFriend);
        }

        if (isPublic != null) {
            localVarFormParams.put("is_public", isPublic);
        }

        if (photo != null) {
            localVarFormParams.put("photo", photo);
        }

        if (safetyLevel != null) {
            localVarFormParams.put("safety_level", safetyLevel);
        }

        if (tags != null) {
            localVarFormParams.put("tags", tags);
        }

        if (title != null) {
            localVarFormParams.put("title", title);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadPhotoValidateBeforeCall(String apiKey, File photo, String contentType, String description, String hidden, String isFamily, String isFriend, String isPublic, String safetyLevel, String tags, String title, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling uploadPhoto(Async)");
        }

        // verify the required parameter 'photo' is set
        if (photo == null) {
            throw new ApiException("Missing the required parameter 'photo' when calling uploadPhoto(Async)");
        }

        return uploadPhotoCall(apiKey, photo, contentType, description, hidden, isFamily, isFriend, isPublic, safetyLevel, tags, title, _callback);

    }

    /**
     * 
     * Uploads a new photo to Flickr
     * @param apiKey  (required)
     * @param photo  (required)
     * @param contentType  (optional)
     * @param description  (optional)
     * @param hidden  (optional)
     * @param isFamily  (optional)
     * @param isFriend  (optional)
     * @param isPublic  (optional)
     * @param safetyLevel  (optional)
     * @param tags  (optional)
     * @param title  (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Object uploadPhoto(String apiKey, File photo, String contentType, String description, String hidden, String isFamily, String isFriend, String isPublic, String safetyLevel, String tags, String title) throws ApiException {
        ApiResponse<Object> localVarResp = uploadPhotoWithHttpInfo(apiKey, photo, contentType, description, hidden, isFamily, isFriend, isPublic, safetyLevel, tags, title);
        return localVarResp.getData();
    }

    /**
     * 
     * Uploads a new photo to Flickr
     * @param apiKey  (required)
     * @param photo  (required)
     * @param contentType  (optional)
     * @param description  (optional)
     * @param hidden  (optional)
     * @param isFamily  (optional)
     * @param isFriend  (optional)
     * @param isPublic  (optional)
     * @param safetyLevel  (optional)
     * @param tags  (optional)
     * @param title  (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> uploadPhotoWithHttpInfo(String apiKey, File photo, String contentType, String description, String hidden, String isFamily, String isFriend, String isPublic, String safetyLevel, String tags, String title) throws ApiException {
        okhttp3.Call localVarCall = uploadPhotoValidateBeforeCall(apiKey, photo, contentType, description, hidden, isFamily, isFriend, isPublic, safetyLevel, tags, title, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Uploads a new photo to Flickr
     * @param apiKey  (required)
     * @param photo  (required)
     * @param contentType  (optional)
     * @param description  (optional)
     * @param hidden  (optional)
     * @param isFamily  (optional)
     * @param isFriend  (optional)
     * @param isPublic  (optional)
     * @param safetyLevel  (optional)
     * @param tags  (optional)
     * @param title  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uploadPhotoAsync(String apiKey, File photo, String contentType, String description, String hidden, String isFamily, String isFriend, String isPublic, String safetyLevel, String tags, String title, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadPhotoValidateBeforeCall(apiKey, photo, contentType, description, hidden, isFamily, isFriend, isPublic, safetyLevel, tags, title, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
