/**
 * Wowza Streaming Cloud REST API Reference Documentation
 *  # About the REST API  The Wowza Streaming Cloud<sup>TM</sup> REST API (application programming interface) offers complete programmatic control over live streams, transcoders, stream sources, and stream targets. Anything you can do in the Wowza Streaming Cloud UI can also be achieved by making HTTP-based requests to cloud-based servers through the REST API.  The Wowza Streaming Cloud REST API features *cross-origin resource sharing*, or CORS. CORS is a [W3C specification](https://www.w3.org/TR/cors/) that provides headers in HTTP requests to enable a web server to safely make a network request to another domain.  In order to protect shared resources, the Wowza Streaming Cloud REST API is subject to limits. For details, see [Wowza Streaming Cloud REST API limits](https://www.wowza.com/docs/wowza-streaming-cloud-rest-api-limits). # About this documentation This reference documentation is based on the open-source [Swagger framework](http://swagger.io/specification/). It allows you to view the operations, parameters, and request and reponse schemas for every resource. Request samples are presented in cURL (Shell) and JavaScript; some samples also include just the JSON object. Response samples are all JSON.  For more information and examples on using the Wowza Streaming Cloud REST API, see our [library of Wowza Streaming Cloud REST API technical articles](https://www.wowza.com/docs/wowza-streaming-cloud-rest-api).  # Query requirements The Wowza Streaming Cloud REST API uses HTTP requests to retrieve data from cloud-based servers. Requests must contain proper JSON, two authentication keys, and the correct version number in the base path.  ## JSON The Wowza Streaming Cloud REST API uses the [JSON API specification](http://jsonapi.org/format/) to request and return data. This means requests must include the header `Content-Type: application/json` and must include a single resource object in JSON format as primary data.  Responses include HTTP status codes that indicate whether the query was successful. If there was an error, a description explains the problem so that you can fix it and try again.  ## Authentication Requests to the Wowza Streaming Cloud REST API must be authenticated with two keys: an API key and an access key. Each key is a 64-character alphanumeric string that you can find on the **API Access** page in Wowza Streaming Cloud.  Use the `wsc-api-key` and `wsc-access-key` headers to authenticate requests, like this (in cURL):  ```bash curl -H 'wsc-api-key: [64-character-api-key-goes-here]' -H 'wsc-access-key: [64-character-access-key-goes-here]' ```  <!-- ReDoc-Inject: <security-definitions> -->  ## Version The Wowza Streaming Cloud API is currently at version 1.0.0. Use `v1` in your base path in every request, like this path to the live_streams endpoint: ``` https://api.cloud.wowza.com/api/v1/live_streams ``` ## Example query Here is a complete example POST request, in cURL, with proper JSON syntax, headers, authentication, and version information: ```bash curl -H 'wsc-api-key: [64-character-api-key-goes-here]' -H 'wsc-access-key: [64-character-access-key-goes-here]'   -H 'Content-Type: application/json' -X POST -d '{     \"live_stream\": {       \"name\": \"My live Stream\",       \"...\": \"...\"     }   }' https://api.cloud.wowza.com/api/v1/live_streams ``` 
 *
 * The version of the OpenAPI document: 1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITranscodersApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAITranscodersApi::OAITranscodersApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAITranscodersApi::~OAITranscodersApi() {
}

void OAITranscodersApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api-sandbox.cloud.wowza.com/api/v1"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("addStreamTargetToTranscoderOutput", defaultConf);
    _serverIndices.insert("addStreamTargetToTranscoderOutput", 0);
    _serverConfigs.insert("createTranscoder", defaultConf);
    _serverIndices.insert("createTranscoder", 0);
    _serverConfigs.insert("createTranscoderOutput", defaultConf);
    _serverIndices.insert("createTranscoderOutput", 0);
    _serverConfigs.insert("createTranscoderOutputOutputStreamTarget", defaultConf);
    _serverIndices.insert("createTranscoderOutputOutputStreamTarget", 0);
    _serverConfigs.insert("createTranscoderProperty", defaultConf);
    _serverIndices.insert("createTranscoderProperty", 0);
    _serverConfigs.insert("deleteTranscoder", defaultConf);
    _serverIndices.insert("deleteTranscoder", 0);
    _serverConfigs.insert("deleteTranscoderOutput", defaultConf);
    _serverIndices.insert("deleteTranscoderOutput", 0);
    _serverConfigs.insert("deleteTranscoderOutputOutputStreamTarget", defaultConf);
    _serverIndices.insert("deleteTranscoderOutputOutputStreamTarget", 0);
    _serverConfigs.insert("deleteTranscoderProperty", defaultConf);
    _serverIndices.insert("deleteTranscoderProperty", 0);
    _serverConfigs.insert("disableAllStreamTargetsTranscoder", defaultConf);
    _serverIndices.insert("disableAllStreamTargetsTranscoder", 0);
    _serverConfigs.insert("disableTranscoderOutputOutputStreamTarget", defaultConf);
    _serverIndices.insert("disableTranscoderOutputOutputStreamTarget", 0);
    _serverConfigs.insert("enableAllStreamTargetsTranscoder", defaultConf);
    _serverIndices.insert("enableAllStreamTargetsTranscoder", 0);
    _serverConfigs.insert("enableTranscoderOutputOutputStreamTarget", defaultConf);
    _serverIndices.insert("enableTranscoderOutputOutputStreamTarget", 0);
    _serverConfigs.insert("indexUptimes", defaultConf);
    _serverIndices.insert("indexUptimes", 0);
    _serverConfigs.insert("listTranscoderOutputOutputStreamTargets", defaultConf);
    _serverIndices.insert("listTranscoderOutputOutputStreamTargets", 0);
    _serverConfigs.insert("listTranscoderOutputs", defaultConf);
    _serverIndices.insert("listTranscoderOutputs", 0);
    _serverConfigs.insert("listTranscoderProperties", defaultConf);
    _serverIndices.insert("listTranscoderProperties", 0);
    _serverConfigs.insert("listTranscoderRecordings", defaultConf);
    _serverIndices.insert("listTranscoderRecordings", 0);
    _serverConfigs.insert("listTranscoderSchedules", defaultConf);
    _serverIndices.insert("listTranscoderSchedules", 0);
    _serverConfigs.insert("listTranscoders", defaultConf);
    _serverIndices.insert("listTranscoders", 0);
    _serverConfigs.insert("removeStreamTargetToTranscoderOutput", defaultConf);
    _serverIndices.insert("removeStreamTargetToTranscoderOutput", 0);
    _serverConfigs.insert("resetTranscoder", defaultConf);
    _serverIndices.insert("resetTranscoder", 0);
    _serverConfigs.insert("restartTranscoderOutputOutputStreamTarget", defaultConf);
    _serverIndices.insert("restartTranscoderOutputOutputStreamTarget", 0);
    _serverConfigs.insert("showTranscoder", defaultConf);
    _serverIndices.insert("showTranscoder", 0);
    _serverConfigs.insert("showTranscoderOutput", defaultConf);
    _serverIndices.insert("showTranscoderOutput", 0);
    _serverConfigs.insert("showTranscoderOutputOutputStreamTarget", defaultConf);
    _serverIndices.insert("showTranscoderOutputOutputStreamTarget", 0);
    _serverConfigs.insert("showTranscoderProperty", defaultConf);
    _serverIndices.insert("showTranscoderProperty", 0);
    _serverConfigs.insert("showTranscoderState", defaultConf);
    _serverIndices.insert("showTranscoderState", 0);
    _serverConfigs.insert("showTranscoderStats", defaultConf);
    _serverIndices.insert("showTranscoderStats", 0);
    _serverConfigs.insert("showTranscoderThumbnailUrl", defaultConf);
    _serverIndices.insert("showTranscoderThumbnailUrl", 0);
    _serverConfigs.insert("showUptime", defaultConf);
    _serverIndices.insert("showUptime", 0);
    _serverConfigs.insert("showUptimeMetricsCurrent", defaultConf);
    _serverIndices.insert("showUptimeMetricsCurrent", 0);
    _serverConfigs.insert("showUptimeMetricsHistoric", defaultConf);
    _serverIndices.insert("showUptimeMetricsHistoric", 0);
    _serverConfigs.insert("startTranscoder", defaultConf);
    _serverIndices.insert("startTranscoder", 0);
    _serverConfigs.insert("stopTranscoder", defaultConf);
    _serverIndices.insert("stopTranscoder", 0);
    _serverConfigs.insert("updateTranscoder", defaultConf);
    _serverIndices.insert("updateTranscoder", 0);
    _serverConfigs.insert("updateTranscoderOutput", defaultConf);
    _serverIndices.insert("updateTranscoderOutput", 0);
    _serverConfigs.insert("updateTranscoderOutputOutputStreamTarget", defaultConf);
    _serverIndices.insert("updateTranscoderOutputOutputStreamTarget", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAITranscodersApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAITranscodersApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAITranscodersApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAITranscodersApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAITranscodersApi::setUsername(const QString &username) {
    _username = username;
}

void OAITranscodersApi::setPassword(const QString &password) {
    _password = password;
}


void OAITranscodersApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAITranscodersApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAITranscodersApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAITranscodersApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITranscodersApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITranscodersApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAITranscodersApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAITranscodersApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAITranscodersApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAITranscodersApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAITranscodersApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAITranscodersApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAITranscodersApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAITranscodersApi::addStreamTargetToTranscoderOutput(const QString &transcoder_id, const QString &id, const OAIOutput_add_stream_target_input &output_stream_target) {
    QString fullPath = QString(_serverConfigs["addStreamTargetToTranscoderOutput"][_serverIndices.value("addStreamTargetToTranscoderOutput")].URL()+"/transcoders/{transcoder_id}/outputs/{id}/add_stream_target");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = output_stream_target.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::addStreamTargetToTranscoderOutputCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::addStreamTargetToTranscoderOutputCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAddStreamTargetToTranscoderOutput_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addStreamTargetToTranscoderOutputSignal(output);
        Q_EMIT addStreamTargetToTranscoderOutputSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addStreamTargetToTranscoderOutputSignalE(output, error_type, error_str);
        Q_EMIT addStreamTargetToTranscoderOutputSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addStreamTargetToTranscoderOutputSignalError(output, error_type, error_str);
        Q_EMIT addStreamTargetToTranscoderOutputSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::createTranscoder(const OAITranscoder_create_input &transcoder) {
    QString fullPath = QString(_serverConfigs["createTranscoder"][_serverIndices.value("createTranscoder")].URL()+"/transcoders");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = transcoder.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::createTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::createTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createTranscoderSignal(output);
        Q_EMIT createTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createTranscoderSignalE(output, error_type, error_str);
        Q_EMIT createTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createTranscoderSignalError(output, error_type, error_str);
        Q_EMIT createTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::createTranscoderOutput(const QString &transcoder_id, const OAIOutput_create_input &output) {
    QString fullPath = QString(_serverConfigs["createTranscoderOutput"][_serverIndices.value("createTranscoderOutput")].URL()+"/transcoders/{transcoder_id}/outputs");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = output.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::createTranscoderOutputCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::createTranscoderOutputCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoderOutput_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createTranscoderOutputSignal(output);
        Q_EMIT createTranscoderOutputSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createTranscoderOutputSignalE(output, error_type, error_str);
        Q_EMIT createTranscoderOutputSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createTranscoderOutputSignalError(output, error_type, error_str);
        Q_EMIT createTranscoderOutputSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::createTranscoderOutputOutputStreamTarget(const QString &transcoder_id, const QString &output_id, const OAIOutput_stream_target_create_input &output_stream_target) {
    QString fullPath = QString(_serverConfigs["createTranscoderOutputOutputStreamTarget"][_serverIndices.value("createTranscoderOutputOutputStreamTarget")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = output_stream_target.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::createTranscoderOutputOutputStreamTargetCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::createTranscoderOutputOutputStreamTargetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAddStreamTargetToTranscoderOutput_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createTranscoderOutputOutputStreamTargetSignal(output);
        Q_EMIT createTranscoderOutputOutputStreamTargetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createTranscoderOutputOutputStreamTargetSignalE(output, error_type, error_str);
        Q_EMIT createTranscoderOutputOutputStreamTargetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createTranscoderOutputOutputStreamTargetSignalError(output, error_type, error_str);
        Q_EMIT createTranscoderOutputOutputStreamTargetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::createTranscoderProperty(const QString &transcoder_id, const OAITranscoder_property_create_input &property) {
    QString fullPath = QString(_serverConfigs["createTranscoderProperty"][_serverIndices.value("createTranscoderProperty")].URL()+"/transcoders/{transcoder_id}/properties");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = property.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::createTranscoderPropertyCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::createTranscoderPropertyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoderProperty_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createTranscoderPropertySignal(output);
        Q_EMIT createTranscoderPropertySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createTranscoderPropertySignalE(output, error_type, error_str);
        Q_EMIT createTranscoderPropertySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createTranscoderPropertySignalError(output, error_type, error_str);
        Q_EMIT createTranscoderPropertySignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::deleteTranscoder(const QString &id) {
    QString fullPath = QString(_serverConfigs["deleteTranscoder"][_serverIndices.value("deleteTranscoder")].URL()+"/transcoders/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::deleteTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::deleteTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTranscoderSignal();
        Q_EMIT deleteTranscoderSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTranscoderSignalE(error_type, error_str);
        Q_EMIT deleteTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTranscoderSignalError(error_type, error_str);
        Q_EMIT deleteTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::deleteTranscoderOutput(const QString &transcoder_id, const QString &id) {
    QString fullPath = QString(_serverConfigs["deleteTranscoderOutput"][_serverIndices.value("deleteTranscoderOutput")].URL()+"/transcoders/{transcoder_id}/outputs/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::deleteTranscoderOutputCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::deleteTranscoderOutputCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTranscoderOutputSignal();
        Q_EMIT deleteTranscoderOutputSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTranscoderOutputSignalE(error_type, error_str);
        Q_EMIT deleteTranscoderOutputSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTranscoderOutputSignalError(error_type, error_str);
        Q_EMIT deleteTranscoderOutputSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::deleteTranscoderOutputOutputStreamTarget(const QString &transcoder_id, const QString &output_id, const QString &stream_target_id) {
    QString fullPath = QString(_serverConfigs["deleteTranscoderOutputOutputStreamTarget"][_serverIndices.value("deleteTranscoderOutputOutputStreamTarget")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    
    {
        QString stream_target_idPathParam("{");
        stream_target_idPathParam.append("stream_target_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "stream_target_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"stream_target_id"+pathSuffix : pathPrefix;
        fullPath.replace(stream_target_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(stream_target_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::deleteTranscoderOutputOutputStreamTargetCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::deleteTranscoderOutputOutputStreamTargetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTranscoderOutputOutputStreamTargetSignal();
        Q_EMIT deleteTranscoderOutputOutputStreamTargetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTranscoderOutputOutputStreamTargetSignalE(error_type, error_str);
        Q_EMIT deleteTranscoderOutputOutputStreamTargetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTranscoderOutputOutputStreamTargetSignalError(error_type, error_str);
        Q_EMIT deleteTranscoderOutputOutputStreamTargetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::deleteTranscoderProperty(const QString &transcoder_id, const QString &id) {
    QString fullPath = QString(_serverConfigs["deleteTranscoderProperty"][_serverIndices.value("deleteTranscoderProperty")].URL()+"/transcoders/{transcoder_id}/properties/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::deleteTranscoderPropertyCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::deleteTranscoderPropertyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTranscoderPropertySignal();
        Q_EMIT deleteTranscoderPropertySignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTranscoderPropertySignalE(error_type, error_str);
        Q_EMIT deleteTranscoderPropertySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTranscoderPropertySignalError(error_type, error_str);
        Q_EMIT deleteTranscoderPropertySignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::disableAllStreamTargetsTranscoder(const QString &id) {
    QString fullPath = QString(_serverConfigs["disableAllStreamTargetsTranscoder"][_serverIndices.value("disableAllStreamTargetsTranscoder")].URL()+"/transcoders/{id}/disable_all_stream_targets");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::disableAllStreamTargetsTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::disableAllStreamTargetsTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDisableAllStreamTargetsTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT disableAllStreamTargetsTranscoderSignal(output);
        Q_EMIT disableAllStreamTargetsTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT disableAllStreamTargetsTranscoderSignalE(output, error_type, error_str);
        Q_EMIT disableAllStreamTargetsTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT disableAllStreamTargetsTranscoderSignalError(output, error_type, error_str);
        Q_EMIT disableAllStreamTargetsTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::disableTranscoderOutputOutputStreamTarget(const QString &transcoder_id, const QString &output_id, const QString &stream_target_id) {
    QString fullPath = QString(_serverConfigs["disableTranscoderOutputOutputStreamTarget"][_serverIndices.value("disableTranscoderOutputOutputStreamTarget")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}/disable");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    
    {
        QString stream_target_idPathParam("{");
        stream_target_idPathParam.append("stream_target_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "stream_target_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"stream_target_id"+pathSuffix : pathPrefix;
        fullPath.replace(stream_target_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(stream_target_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::disableTranscoderOutputOutputStreamTargetCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::disableTranscoderOutputOutputStreamTargetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDisableTranscoderOutputOutputStreamTarget_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT disableTranscoderOutputOutputStreamTargetSignal(output);
        Q_EMIT disableTranscoderOutputOutputStreamTargetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT disableTranscoderOutputOutputStreamTargetSignalE(output, error_type, error_str);
        Q_EMIT disableTranscoderOutputOutputStreamTargetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT disableTranscoderOutputOutputStreamTargetSignalError(output, error_type, error_str);
        Q_EMIT disableTranscoderOutputOutputStreamTargetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::enableAllStreamTargetsTranscoder(const QString &id) {
    QString fullPath = QString(_serverConfigs["enableAllStreamTargetsTranscoder"][_serverIndices.value("enableAllStreamTargetsTranscoder")].URL()+"/transcoders/{id}/enable_all_stream_targets");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::enableAllStreamTargetsTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::enableAllStreamTargetsTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDisableAllStreamTargetsTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT enableAllStreamTargetsTranscoderSignal(output);
        Q_EMIT enableAllStreamTargetsTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT enableAllStreamTargetsTranscoderSignalE(output, error_type, error_str);
        Q_EMIT enableAllStreamTargetsTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT enableAllStreamTargetsTranscoderSignalError(output, error_type, error_str);
        Q_EMIT enableAllStreamTargetsTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::enableTranscoderOutputOutputStreamTarget(const QString &transcoder_id, const QString &output_id, const QString &stream_target_id) {
    QString fullPath = QString(_serverConfigs["enableTranscoderOutputOutputStreamTarget"][_serverIndices.value("enableTranscoderOutputOutputStreamTarget")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}/enable");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    
    {
        QString stream_target_idPathParam("{");
        stream_target_idPathParam.append("stream_target_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "stream_target_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"stream_target_id"+pathSuffix : pathPrefix;
        fullPath.replace(stream_target_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(stream_target_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::enableTranscoderOutputOutputStreamTargetCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::enableTranscoderOutputOutputStreamTargetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEnableTranscoderOutputOutputStreamTarget_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT enableTranscoderOutputOutputStreamTargetSignal(output);
        Q_EMIT enableTranscoderOutputOutputStreamTargetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT enableTranscoderOutputOutputStreamTargetSignalE(output, error_type, error_str);
        Q_EMIT enableTranscoderOutputOutputStreamTargetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT enableTranscoderOutputOutputStreamTargetSignalError(output, error_type, error_str);
        Q_EMIT enableTranscoderOutputOutputStreamTargetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::indexUptimes(const QString &transcoder_id, const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &per_page) {
    QString fullPath = QString(_serverConfigs["indexUptimes"][_serverIndices.value("indexUptimes")].URL()+"/transcoders/{transcoder_id}/uptimes");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::indexUptimesCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::indexUptimesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUptimes output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT indexUptimesSignal(output);
        Q_EMIT indexUptimesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT indexUptimesSignalE(output, error_type, error_str);
        Q_EMIT indexUptimesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT indexUptimesSignalError(output, error_type, error_str);
        Q_EMIT indexUptimesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::listTranscoderOutputOutputStreamTargets(const QString &transcoder_id, const QString &output_id) {
    QString fullPath = QString(_serverConfigs["listTranscoderOutputOutputStreamTargets"][_serverIndices.value("listTranscoderOutputOutputStreamTargets")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::listTranscoderOutputOutputStreamTargetsCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::listTranscoderOutputOutputStreamTargetsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOutput_stream_target output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listTranscoderOutputOutputStreamTargetsSignal(output);
        Q_EMIT listTranscoderOutputOutputStreamTargetsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listTranscoderOutputOutputStreamTargetsSignalE(output, error_type, error_str);
        Q_EMIT listTranscoderOutputOutputStreamTargetsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listTranscoderOutputOutputStreamTargetsSignalError(output, error_type, error_str);
        Q_EMIT listTranscoderOutputOutputStreamTargetsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::listTranscoderOutputs(const QString &transcoder_id) {
    QString fullPath = QString(_serverConfigs["listTranscoderOutputs"][_serverIndices.value("listTranscoderOutputs")].URL()+"/transcoders/{transcoder_id}/outputs");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::listTranscoderOutputsCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::listTranscoderOutputsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOutputs output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listTranscoderOutputsSignal(output);
        Q_EMIT listTranscoderOutputsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listTranscoderOutputsSignalE(output, error_type, error_str);
        Q_EMIT listTranscoderOutputsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listTranscoderOutputsSignalError(output, error_type, error_str);
        Q_EMIT listTranscoderOutputsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::listTranscoderProperties(const QString &transcoder_id) {
    QString fullPath = QString(_serverConfigs["listTranscoderProperties"][_serverIndices.value("listTranscoderProperties")].URL()+"/transcoders/{transcoder_id}/properties");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::listTranscoderPropertiesCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::listTranscoderPropertiesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITranscoder_properties output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listTranscoderPropertiesSignal(output);
        Q_EMIT listTranscoderPropertiesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listTranscoderPropertiesSignalE(output, error_type, error_str);
        Q_EMIT listTranscoderPropertiesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listTranscoderPropertiesSignalError(output, error_type, error_str);
        Q_EMIT listTranscoderPropertiesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::listTranscoderRecordings(const QString &id) {
    QString fullPath = QString(_serverConfigs["listTranscoderRecordings"][_serverIndices.value("listTranscoderRecordings")].URL()+"/transcoders/{id}/recordings");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::listTranscoderRecordingsCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::listTranscoderRecordingsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIListTranscoderRecordings_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listTranscoderRecordingsSignal(output);
        Q_EMIT listTranscoderRecordingsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listTranscoderRecordingsSignalE(output, error_type, error_str);
        Q_EMIT listTranscoderRecordingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listTranscoderRecordingsSignalError(output, error_type, error_str);
        Q_EMIT listTranscoderRecordingsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::listTranscoderSchedules(const QString &id) {
    QString fullPath = QString(_serverConfigs["listTranscoderSchedules"][_serverIndices.value("listTranscoderSchedules")].URL()+"/transcoders/{id}/schedules");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::listTranscoderSchedulesCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::listTranscoderSchedulesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIListTranscoderSchedules_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listTranscoderSchedulesSignal(output);
        Q_EMIT listTranscoderSchedulesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listTranscoderSchedulesSignalE(output, error_type, error_str);
        Q_EMIT listTranscoderSchedulesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listTranscoderSchedulesSignalError(output, error_type, error_str);
        Q_EMIT listTranscoderSchedulesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::listTranscoders(const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &per_page) {
    QString fullPath = QString(_serverConfigs["listTranscoders"][_serverIndices.value("listTranscoders")].URL()+"/transcoders");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::listTranscodersCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::listTranscodersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITranscoders output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listTranscodersSignal(output);
        Q_EMIT listTranscodersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listTranscodersSignalE(output, error_type, error_str);
        Q_EMIT listTranscodersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listTranscodersSignalError(output, error_type, error_str);
        Q_EMIT listTranscodersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::removeStreamTargetToTranscoderOutput(const QString &transcoder_id, const QString &id, const OAIOutput_remove_stream_target_input &output_stream_target) {
    QString fullPath = QString(_serverConfigs["removeStreamTargetToTranscoderOutput"][_serverIndices.value("removeStreamTargetToTranscoderOutput")].URL()+"/transcoders/{transcoder_id}/outputs/{id}/remove_stream_target");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");

    {

        
        QByteArray output = output_stream_target.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::removeStreamTargetToTranscoderOutputCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::removeStreamTargetToTranscoderOutputCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT removeStreamTargetToTranscoderOutputSignal();
        Q_EMIT removeStreamTargetToTranscoderOutputSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT removeStreamTargetToTranscoderOutputSignalE(error_type, error_str);
        Q_EMIT removeStreamTargetToTranscoderOutputSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT removeStreamTargetToTranscoderOutputSignalError(error_type, error_str);
        Q_EMIT removeStreamTargetToTranscoderOutputSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::resetTranscoder(const QString &id) {
    QString fullPath = QString(_serverConfigs["resetTranscoder"][_serverIndices.value("resetTranscoder")].URL()+"/transcoders/{id}/reset");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::resetTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::resetTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIResetTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT resetTranscoderSignal(output);
        Q_EMIT resetTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT resetTranscoderSignalE(output, error_type, error_str);
        Q_EMIT resetTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT resetTranscoderSignalError(output, error_type, error_str);
        Q_EMIT resetTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::restartTranscoderOutputOutputStreamTarget(const QString &transcoder_id, const QString &output_id, const QString &stream_target_id) {
    QString fullPath = QString(_serverConfigs["restartTranscoderOutputOutputStreamTarget"][_serverIndices.value("restartTranscoderOutputOutputStreamTarget")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}/restart");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    
    {
        QString stream_target_idPathParam("{");
        stream_target_idPathParam.append("stream_target_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "stream_target_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"stream_target_id"+pathSuffix : pathPrefix;
        fullPath.replace(stream_target_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(stream_target_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::restartTranscoderOutputOutputStreamTargetCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::restartTranscoderOutputOutputStreamTargetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRestartTranscoderOutputOutputStreamTarget_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT restartTranscoderOutputOutputStreamTargetSignal(output);
        Q_EMIT restartTranscoderOutputOutputStreamTargetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT restartTranscoderOutputOutputStreamTargetSignalE(output, error_type, error_str);
        Q_EMIT restartTranscoderOutputOutputStreamTargetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT restartTranscoderOutputOutputStreamTargetSignalError(output, error_type, error_str);
        Q_EMIT restartTranscoderOutputOutputStreamTargetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showTranscoder(const QString &id) {
    QString fullPath = QString(_serverConfigs["showTranscoder"][_serverIndices.value("showTranscoder")].URL()+"/transcoders/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showTranscoderSignal(output);
        Q_EMIT showTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showTranscoderSignalE(output, error_type, error_str);
        Q_EMIT showTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showTranscoderSignalError(output, error_type, error_str);
        Q_EMIT showTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showTranscoderOutput(const QString &transcoder_id, const QString &id) {
    QString fullPath = QString(_serverConfigs["showTranscoderOutput"][_serverIndices.value("showTranscoderOutput")].URL()+"/transcoders/{transcoder_id}/outputs/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showTranscoderOutputCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showTranscoderOutputCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoderOutput_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showTranscoderOutputSignal(output);
        Q_EMIT showTranscoderOutputSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showTranscoderOutputSignalE(output, error_type, error_str);
        Q_EMIT showTranscoderOutputSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showTranscoderOutputSignalError(output, error_type, error_str);
        Q_EMIT showTranscoderOutputSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showTranscoderOutputOutputStreamTarget(const QString &transcoder_id, const QString &output_id, const QString &stream_target_id) {
    QString fullPath = QString(_serverConfigs["showTranscoderOutputOutputStreamTarget"][_serverIndices.value("showTranscoderOutputOutputStreamTarget")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    
    {
        QString stream_target_idPathParam("{");
        stream_target_idPathParam.append("stream_target_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "stream_target_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"stream_target_id"+pathSuffix : pathPrefix;
        fullPath.replace(stream_target_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(stream_target_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showTranscoderOutputOutputStreamTargetCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showTranscoderOutputOutputStreamTargetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAddStreamTargetToTranscoderOutput_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showTranscoderOutputOutputStreamTargetSignal(output);
        Q_EMIT showTranscoderOutputOutputStreamTargetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showTranscoderOutputOutputStreamTargetSignalE(output, error_type, error_str);
        Q_EMIT showTranscoderOutputOutputStreamTargetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showTranscoderOutputOutputStreamTargetSignalError(output, error_type, error_str);
        Q_EMIT showTranscoderOutputOutputStreamTargetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showTranscoderProperty(const QString &transcoder_id, const QString &id) {
    QString fullPath = QString(_serverConfigs["showTranscoderProperty"][_serverIndices.value("showTranscoderProperty")].URL()+"/transcoders/{transcoder_id}/properties/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showTranscoderPropertyCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showTranscoderPropertyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoderProperty_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showTranscoderPropertySignal(output);
        Q_EMIT showTranscoderPropertySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showTranscoderPropertySignalE(output, error_type, error_str);
        Q_EMIT showTranscoderPropertySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showTranscoderPropertySignalError(output, error_type, error_str);
        Q_EMIT showTranscoderPropertySignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showTranscoderState(const QString &id) {
    QString fullPath = QString(_serverConfigs["showTranscoderState"][_serverIndices.value("showTranscoderState")].URL()+"/transcoders/{id}/state");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showTranscoderStateCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showTranscoderStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIShowTranscoderState_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showTranscoderStateSignal(output);
        Q_EMIT showTranscoderStateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showTranscoderStateSignalE(output, error_type, error_str);
        Q_EMIT showTranscoderStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showTranscoderStateSignalError(output, error_type, error_str);
        Q_EMIT showTranscoderStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showTranscoderStats(const QString &id) {
    QString fullPath = QString(_serverConfigs["showTranscoderStats"][_serverIndices.value("showTranscoderStats")].URL()+"/transcoders/{id}/stats");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showTranscoderStatsCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showTranscoderStatsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIShowTranscoderStats_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showTranscoderStatsSignal(output);
        Q_EMIT showTranscoderStatsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showTranscoderStatsSignalE(output, error_type, error_str);
        Q_EMIT showTranscoderStatsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showTranscoderStatsSignalError(output, error_type, error_str);
        Q_EMIT showTranscoderStatsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showTranscoderThumbnailUrl(const QString &id) {
    QString fullPath = QString(_serverConfigs["showTranscoderThumbnailUrl"][_serverIndices.value("showTranscoderThumbnailUrl")].URL()+"/transcoders/{id}/thumbnail_url");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showTranscoderThumbnailUrlCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showTranscoderThumbnailUrlCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIShowTranscoderThumbnailUrl_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showTranscoderThumbnailUrlSignal(output);
        Q_EMIT showTranscoderThumbnailUrlSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showTranscoderThumbnailUrlSignalE(output, error_type, error_str);
        Q_EMIT showTranscoderThumbnailUrlSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showTranscoderThumbnailUrlSignalError(output, error_type, error_str);
        Q_EMIT showTranscoderThumbnailUrlSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showUptime(const QString &transcoder_id, const QString &id) {
    QString fullPath = QString(_serverConfigs["showUptime"][_serverIndices.value("showUptime")].URL()+"/transcoders/{transcoder_id}/uptimes/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showUptimeCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showUptimeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUptime output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showUptimeSignal(output);
        Q_EMIT showUptimeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showUptimeSignalE(output, error_type, error_str);
        Q_EMIT showUptimeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showUptimeSignalError(output, error_type, error_str);
        Q_EMIT showUptimeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showUptimeMetricsCurrent(const QString &transcoder_id, const QString &id, const ::OpenAPI::OptionalParam<QString> &fields) {
    QString fullPath = QString(_serverConfigs["showUptimeMetricsCurrent"][_serverIndices.value("showUptimeMetricsCurrent")].URL()+"/transcoders/{transcoder_id}/uptimes/{id}/metrics/current");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (fields.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "fields", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("fields")).append(querySuffix).append(QUrl::toPercentEncoding(fields.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showUptimeMetricsCurrentCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showUptimeMetricsCurrentCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIShowUptimeMetricsCurrent_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showUptimeMetricsCurrentSignal(output);
        Q_EMIT showUptimeMetricsCurrentSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showUptimeMetricsCurrentSignalE(output, error_type, error_str);
        Q_EMIT showUptimeMetricsCurrentSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showUptimeMetricsCurrentSignalError(output, error_type, error_str);
        Q_EMIT showUptimeMetricsCurrentSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::showUptimeMetricsHistoric(const QString &transcoder_id, const QString &id, const ::OpenAPI::OptionalParam<QString> &fields, const ::OpenAPI::OptionalParam<QString> &from, const ::OpenAPI::OptionalParam<QString> &to) {
    QString fullPath = QString(_serverConfigs["showUptimeMetricsHistoric"][_serverIndices.value("showUptimeMetricsHistoric")].URL()+"/transcoders/{transcoder_id}/uptimes/{id}/metrics/historic");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (fields.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "fields", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("fields")).append(querySuffix).append(QUrl::toPercentEncoding(fields.stringValue()));
    }
    if (from.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "from", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("from")).append(querySuffix).append(QUrl::toPercentEncoding(from.stringValue()));
    }
    if (to.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "to", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("to")).append(querySuffix).append(QUrl::toPercentEncoding(to.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::showUptimeMetricsHistoricCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::showUptimeMetricsHistoricCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIShowUptimeMetricsHistoric_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT showUptimeMetricsHistoricSignal(output);
        Q_EMIT showUptimeMetricsHistoricSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT showUptimeMetricsHistoricSignalE(output, error_type, error_str);
        Q_EMIT showUptimeMetricsHistoricSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT showUptimeMetricsHistoricSignalError(output, error_type, error_str);
        Q_EMIT showUptimeMetricsHistoricSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::startTranscoder(const QString &id) {
    QString fullPath = QString(_serverConfigs["startTranscoder"][_serverIndices.value("startTranscoder")].URL()+"/transcoders/{id}/start");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::startTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::startTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStartTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT startTranscoderSignal(output);
        Q_EMIT startTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT startTranscoderSignalE(output, error_type, error_str);
        Q_EMIT startTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT startTranscoderSignalError(output, error_type, error_str);
        Q_EMIT startTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::stopTranscoder(const QString &id) {
    QString fullPath = QString(_serverConfigs["stopTranscoder"][_serverIndices.value("stopTranscoder")].URL()+"/transcoders/{id}/stop");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::stopTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::stopTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStartTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT stopTranscoderSignal(output);
        Q_EMIT stopTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT stopTranscoderSignalE(output, error_type, error_str);
        Q_EMIT stopTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT stopTranscoderSignalError(output, error_type, error_str);
        Q_EMIT stopTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::updateTranscoder(const QString &id, const OAITranscoder_update_input &transcoder) {
    QString fullPath = QString(_serverConfigs["updateTranscoder"][_serverIndices.value("updateTranscoder")].URL()+"/transcoders/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = transcoder.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::updateTranscoderCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::updateTranscoderCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoder_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateTranscoderSignal(output);
        Q_EMIT updateTranscoderSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateTranscoderSignalE(output, error_type, error_str);
        Q_EMIT updateTranscoderSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateTranscoderSignalError(output, error_type, error_str);
        Q_EMIT updateTranscoderSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::updateTranscoderOutput(const QString &transcoder_id, const QString &id, const OAIOutput_update_input &output) {
    QString fullPath = QString(_serverConfigs["updateTranscoderOutput"][_serverIndices.value("updateTranscoderOutput")].URL()+"/transcoders/{transcoder_id}/outputs/{id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = output.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::updateTranscoderOutputCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::updateTranscoderOutputCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateTranscoderOutput_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateTranscoderOutputSignal(output);
        Q_EMIT updateTranscoderOutputSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateTranscoderOutputSignalE(output, error_type, error_str);
        Q_EMIT updateTranscoderOutputSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateTranscoderOutputSignalError(output, error_type, error_str);
        Q_EMIT updateTranscoderOutputSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::updateTranscoderOutputOutputStreamTarget(const QString &transcoder_id, const QString &output_id, const QString &stream_target_id, const OAIOutput_stream_target_update_input &output_stream_target) {
    QString fullPath = QString(_serverConfigs["updateTranscoderOutputOutputStreamTarget"][_serverIndices.value("updateTranscoderOutputOutputStreamTarget")].URL()+"/transcoders/{transcoder_id}/outputs/{output_id}/output_stream_targets/{stream_target_id}");
    
    if (_apiKeys.contains("wsc-api-key")) {
        addHeaders("wsc-api-key",_apiKeys.find("wsc-api-key").value());
    }
    
    if (_apiKeys.contains("wsc-access-key")) {
        addHeaders("wsc-access-key",_apiKeys.find("wsc-access-key").value());
    }
    
    
    {
        QString transcoder_idPathParam("{");
        transcoder_idPathParam.append("transcoder_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transcoder_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transcoder_id"+pathSuffix : pathPrefix;
        fullPath.replace(transcoder_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transcoder_id)));
    }
    
    {
        QString output_idPathParam("{");
        output_idPathParam.append("output_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "output_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"output_id"+pathSuffix : pathPrefix;
        fullPath.replace(output_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(output_id)));
    }
    
    {
        QString stream_target_idPathParam("{");
        stream_target_idPathParam.append("stream_target_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "stream_target_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"stream_target_id"+pathSuffix : pathPrefix;
        fullPath.replace(stream_target_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(stream_target_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = output_stream_target.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITranscodersApi::updateTranscoderOutputOutputStreamTargetCallback);
    connect(this, &OAITranscodersApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITranscodersApi::updateTranscoderOutputOutputStreamTargetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAddStreamTargetToTranscoderOutput_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateTranscoderOutputOutputStreamTargetSignal(output);
        Q_EMIT updateTranscoderOutputOutputStreamTargetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateTranscoderOutputOutputStreamTargetSignalE(output, error_type, error_str);
        Q_EMIT updateTranscoderOutputOutputStreamTargetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateTranscoderOutputOutputStreamTargetSignalError(output, error_type, error_str);
        Q_EMIT updateTranscoderOutputOutputStreamTargetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITranscodersApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
