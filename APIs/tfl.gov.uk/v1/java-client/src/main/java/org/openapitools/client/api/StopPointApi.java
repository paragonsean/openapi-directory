/*
 * Transport for London Unified API
 * Our unified API brings together data across all modes of transport into a single RESTful API. This API provides access to the most highly requested realtime and status infomation across all the modes of transport, in a single and consistent way. Access to the developer documentation is available at https://api.tfl.gov.uk
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.TflApiPresentationEntitiesArrivalDeparture;
import org.openapitools.client.model.TflApiPresentationEntitiesDisruptedPoint;
import org.openapitools.client.model.TflApiPresentationEntitiesLineServiceType;
import org.openapitools.client.model.TflApiPresentationEntitiesMode;
import org.openapitools.client.model.TflApiPresentationEntitiesPlace;
import org.openapitools.client.model.TflApiPresentationEntitiesPrediction;
import org.openapitools.client.model.TflApiPresentationEntitiesSearchResponse;
import org.openapitools.client.model.TflApiPresentationEntitiesStopPoint;
import org.openapitools.client.model.TflApiPresentationEntitiesStopPointCategory;
import org.openapitools.client.model.TflApiPresentationEntitiesStopPointRouteSection;
import org.openapitools.client.model.TflApiPresentationEntitiesStopPointsResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class StopPointApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public StopPointApi() {
        this(Configuration.getDefaultApiClient());
    }

    public StopPointApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for stopPointArrivalDepartures
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineIds A comma-separated list of line ids e.g. elizabeth, london-overground, thameslink (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointArrivalDeparturesCall(String id, List<String> lineIds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{id}/ArrivalDepartures"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (lineIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "lineIds", lineIds));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointArrivalDeparturesValidateBeforeCall(String id, List<String> lineIds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointArrivalDepartures(Async)");
        }

        // verify the required parameter 'lineIds' is set
        if (lineIds == null) {
            throw new ApiException("Missing the required parameter 'lineIds' when calling stopPointArrivalDepartures(Async)");
        }

        return stopPointArrivalDeparturesCall(id, lineIds, _callback);

    }

    /**
     * Gets the list of arrival and departure predictions for the given stop point id (overground, Elizabeth line and thameslink only)
     * 
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineIds A comma-separated list of line ids e.g. elizabeth, london-overground, thameslink (required)
     * @return List&lt;TflApiPresentationEntitiesArrivalDeparture&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesArrivalDeparture> stopPointArrivalDepartures(String id, List<String> lineIds) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesArrivalDeparture>> localVarResp = stopPointArrivalDeparturesWithHttpInfo(id, lineIds);
        return localVarResp.getData();
    }

    /**
     * Gets the list of arrival and departure predictions for the given stop point id (overground, Elizabeth line and thameslink only)
     * 
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineIds A comma-separated list of line ids e.g. elizabeth, london-overground, thameslink (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesArrivalDeparture&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesArrivalDeparture>> stopPointArrivalDeparturesWithHttpInfo(String id, List<String> lineIds) throws ApiException {
        okhttp3.Call localVarCall = stopPointArrivalDeparturesValidateBeforeCall(id, lineIds, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesArrivalDeparture>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the list of arrival and departure predictions for the given stop point id (overground, Elizabeth line and thameslink only) (asynchronously)
     * 
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineIds A comma-separated list of line ids e.g. elizabeth, london-overground, thameslink (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointArrivalDeparturesAsync(String id, List<String> lineIds, final ApiCallback<List<TflApiPresentationEntitiesArrivalDeparture>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointArrivalDeparturesValidateBeforeCall(id, lineIds, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesArrivalDeparture>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointArrivals
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointArrivalsCall(String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{id}/Arrivals"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointArrivalsValidateBeforeCall(String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointArrivals(Async)");
        }

        return stopPointArrivalsCall(id, _callback);

    }

    /**
     * Gets the list of arrival predictions for the given stop point id
     * 
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @return List&lt;TflApiPresentationEntitiesPrediction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesPrediction> stopPointArrivals(String id) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesPrediction>> localVarResp = stopPointArrivalsWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Gets the list of arrival predictions for the given stop point id
     * 
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesPrediction&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesPrediction>> stopPointArrivalsWithHttpInfo(String id) throws ApiException {
        okhttp3.Call localVarCall = stopPointArrivalsValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPrediction>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the list of arrival predictions for the given stop point id (asynchronously)
     * 
     * @param id A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointArrivalsAsync(String id, final ApiCallback<List<TflApiPresentationEntitiesPrediction>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointArrivalsValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPrediction>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointCrowding
     * @param id The Naptan id of the stop (required)
     * @param line A particular line e.g. victoria, circle, northern etc. (required)
     * @param direction The direction of travel. Can be inbound or outbound. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointCrowdingCall(String id, String line, String direction, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{id}/Crowding/{line}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()))
            .replace("{" + "line" + "}", localVarApiClient.escapeString(line.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointCrowdingValidateBeforeCall(String id, String line, String direction, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointCrowding(Async)");
        }

        // verify the required parameter 'line' is set
        if (line == null) {
            throw new ApiException("Missing the required parameter 'line' when calling stopPointCrowding(Async)");
        }

        // verify the required parameter 'direction' is set
        if (direction == null) {
            throw new ApiException("Missing the required parameter 'direction' when calling stopPointCrowding(Async)");
        }

        return stopPointCrowdingCall(id, line, direction, _callback);

    }

    /**
     * Gets all the Crowding data (static) for the StopPointId, plus crowding data for a given line and optionally a particular direction.
     * 
     * @param id The Naptan id of the stop (required)
     * @param line A particular line e.g. victoria, circle, northern etc. (required)
     * @param direction The direction of travel. Can be inbound or outbound. (required)
     * @return List&lt;TflApiPresentationEntitiesStopPoint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesStopPoint> stopPointCrowding(String id, String line, String direction) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesStopPoint>> localVarResp = stopPointCrowdingWithHttpInfo(id, line, direction);
        return localVarResp.getData();
    }

    /**
     * Gets all the Crowding data (static) for the StopPointId, plus crowding data for a given line and optionally a particular direction.
     * 
     * @param id The Naptan id of the stop (required)
     * @param line A particular line e.g. victoria, circle, northern etc. (required)
     * @param direction The direction of travel. Can be inbound or outbound. (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesStopPoint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesStopPoint>> stopPointCrowdingWithHttpInfo(String id, String line, String direction) throws ApiException {
        okhttp3.Call localVarCall = stopPointCrowdingValidateBeforeCall(id, line, direction, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets all the Crowding data (static) for the StopPointId, plus crowding data for a given line and optionally a particular direction. (asynchronously)
     * 
     * @param id The Naptan id of the stop (required)
     * @param line A particular line e.g. victoria, circle, northern etc. (required)
     * @param direction The direction of travel. Can be inbound or outbound. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointCrowdingAsync(String id, String line, String direction, final ApiCallback<List<TflApiPresentationEntitiesStopPoint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointCrowdingValidateBeforeCall(id, line, direction, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointDirection
     * @param id Originating stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param toStopPointId Destination stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineId Optional line id filter e.g. victoria (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointDirectionCall(String id, String toStopPointId, String lineId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{id}/DirectionTo/{toStopPointId}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()))
            .replace("{" + "toStopPointId" + "}", localVarApiClient.escapeString(toStopPointId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (lineId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lineId", lineId));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointDirectionValidateBeforeCall(String id, String toStopPointId, String lineId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointDirection(Async)");
        }

        // verify the required parameter 'toStopPointId' is set
        if (toStopPointId == null) {
            throw new ApiException("Missing the required parameter 'toStopPointId' when calling stopPointDirection(Async)");
        }

        return stopPointDirectionCall(id, toStopPointId, lineId, _callback);

    }

    /**
     * Returns the canonical direction, \&quot;inbound\&quot; or \&quot;outbound\&quot;, for a given pair of stop point Ids in the direction from -&amp;gt; to.
     * 
     * @param id Originating stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param toStopPointId Destination stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineId Optional line id filter e.g. victoria (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public String stopPointDirection(String id, String toStopPointId, String lineId) throws ApiException {
        ApiResponse<String> localVarResp = stopPointDirectionWithHttpInfo(id, toStopPointId, lineId);
        return localVarResp.getData();
    }

    /**
     * Returns the canonical direction, \&quot;inbound\&quot; or \&quot;outbound\&quot;, for a given pair of stop point Ids in the direction from -&amp;gt; to.
     * 
     * @param id Originating stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param toStopPointId Destination stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineId Optional line id filter e.g. victoria (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<String> stopPointDirectionWithHttpInfo(String id, String toStopPointId, String lineId) throws ApiException {
        okhttp3.Call localVarCall = stopPointDirectionValidateBeforeCall(id, toStopPointId, lineId, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns the canonical direction, \&quot;inbound\&quot; or \&quot;outbound\&quot;, for a given pair of stop point Ids in the direction from -&amp;gt; to. (asynchronously)
     * 
     * @param id Originating stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param toStopPointId Destination stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param lineId Optional line id filter e.g. victoria (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointDirectionAsync(String id, String toStopPointId, String lineId, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointDirectionValidateBeforeCall(id, toStopPointId, lineId, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointDisruption
     * @param ids A comma-seperated list of stop point ids. Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param getFamily Specify true to return disruptions for entire family, or false to return disruptions for just this stop point. Defaults to false. (optional)
     * @param includeRouteBlockedStops  (optional)
     * @param flattenResponse Specify true to associate all disruptions with parent stop point. (Only applicable when getFamily is true). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointDisruptionCall(List<String> ids, Boolean getFamily, Boolean includeRouteBlockedStops, Boolean flattenResponse, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{ids}/Disruption"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ids)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (getFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("getFamily", getFamily));
        }

        if (includeRouteBlockedStops != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeRouteBlockedStops", includeRouteBlockedStops));
        }

        if (flattenResponse != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("flattenResponse", flattenResponse));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointDisruptionValidateBeforeCall(List<String> ids, Boolean getFamily, Boolean includeRouteBlockedStops, Boolean flattenResponse, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling stopPointDisruption(Async)");
        }

        return stopPointDisruptionCall(ids, getFamily, includeRouteBlockedStops, flattenResponse, _callback);

    }

    /**
     * Gets all disruptions for the specified StopPointId, plus disruptions for any child Naptan records it may have.
     * 
     * @param ids A comma-seperated list of stop point ids. Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param getFamily Specify true to return disruptions for entire family, or false to return disruptions for just this stop point. Defaults to false. (optional)
     * @param includeRouteBlockedStops  (optional)
     * @param flattenResponse Specify true to associate all disruptions with parent stop point. (Only applicable when getFamily is true). (optional)
     * @return List&lt;TflApiPresentationEntitiesDisruptedPoint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesDisruptedPoint> stopPointDisruption(List<String> ids, Boolean getFamily, Boolean includeRouteBlockedStops, Boolean flattenResponse) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesDisruptedPoint>> localVarResp = stopPointDisruptionWithHttpInfo(ids, getFamily, includeRouteBlockedStops, flattenResponse);
        return localVarResp.getData();
    }

    /**
     * Gets all disruptions for the specified StopPointId, plus disruptions for any child Naptan records it may have.
     * 
     * @param ids A comma-seperated list of stop point ids. Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param getFamily Specify true to return disruptions for entire family, or false to return disruptions for just this stop point. Defaults to false. (optional)
     * @param includeRouteBlockedStops  (optional)
     * @param flattenResponse Specify true to associate all disruptions with parent stop point. (Only applicable when getFamily is true). (optional)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesDisruptedPoint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesDisruptedPoint>> stopPointDisruptionWithHttpInfo(List<String> ids, Boolean getFamily, Boolean includeRouteBlockedStops, Boolean flattenResponse) throws ApiException {
        okhttp3.Call localVarCall = stopPointDisruptionValidateBeforeCall(ids, getFamily, includeRouteBlockedStops, flattenResponse, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesDisruptedPoint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets all disruptions for the specified StopPointId, plus disruptions for any child Naptan records it may have. (asynchronously)
     * 
     * @param ids A comma-seperated list of stop point ids. Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param getFamily Specify true to return disruptions for entire family, or false to return disruptions for just this stop point. Defaults to false. (optional)
     * @param includeRouteBlockedStops  (optional)
     * @param flattenResponse Specify true to associate all disruptions with parent stop point. (Only applicable when getFamily is true). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointDisruptionAsync(List<String> ids, Boolean getFamily, Boolean includeRouteBlockedStops, Boolean flattenResponse, final ApiCallback<List<TflApiPresentationEntitiesDisruptedPoint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointDisruptionValidateBeforeCall(ids, getFamily, includeRouteBlockedStops, flattenResponse, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesDisruptedPoint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointDisruptionByMode
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param includeRouteBlockedStops  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointDisruptionByModeCall(List<String> modes, Boolean includeRouteBlockedStops, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Mode/{modes}/Disruption"
            .replace("{" + "modes" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", modes)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (includeRouteBlockedStops != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeRouteBlockedStops", includeRouteBlockedStops));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointDisruptionByModeValidateBeforeCall(List<String> modes, Boolean includeRouteBlockedStops, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'modes' is set
        if (modes == null) {
            throw new ApiException("Missing the required parameter 'modes' when calling stopPointDisruptionByMode(Async)");
        }

        return stopPointDisruptionByModeCall(modes, includeRouteBlockedStops, _callback);

    }

    /**
     * Gets a distinct list of disrupted stop points for the given modes
     * 
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param includeRouteBlockedStops  (optional)
     * @return List&lt;TflApiPresentationEntitiesDisruptedPoint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesDisruptedPoint> stopPointDisruptionByMode(List<String> modes, Boolean includeRouteBlockedStops) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesDisruptedPoint>> localVarResp = stopPointDisruptionByModeWithHttpInfo(modes, includeRouteBlockedStops);
        return localVarResp.getData();
    }

    /**
     * Gets a distinct list of disrupted stop points for the given modes
     * 
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param includeRouteBlockedStops  (optional)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesDisruptedPoint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesDisruptedPoint>> stopPointDisruptionByModeWithHttpInfo(List<String> modes, Boolean includeRouteBlockedStops) throws ApiException {
        okhttp3.Call localVarCall = stopPointDisruptionByModeValidateBeforeCall(modes, includeRouteBlockedStops, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesDisruptedPoint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a distinct list of disrupted stop points for the given modes (asynchronously)
     * 
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param includeRouteBlockedStops  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointDisruptionByModeAsync(List<String> modes, Boolean includeRouteBlockedStops, final ApiCallback<List<TflApiPresentationEntitiesDisruptedPoint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointDisruptionByModeValidateBeforeCall(modes, includeRouteBlockedStops, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesDisruptedPoint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGet
     * @param ids A comma-separated list of stop point ids (station naptan code e.g. 940GZZLUASL). Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param includeCrowdingData Include the crowding data (static). To Filter further use: /StopPoint/{ids}/Crowding/{line} (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetCall(List<String> ids, Boolean includeCrowdingData, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{ids}"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ids)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (includeCrowdingData != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeCrowdingData", includeCrowdingData));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetValidateBeforeCall(List<String> ids, Boolean includeCrowdingData, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling stopPointGet(Async)");
        }

        return stopPointGetCall(ids, includeCrowdingData, _callback);

    }

    /**
     * Gets a list of StopPoints corresponding to the given list of stop ids.
     * 
     * @param ids A comma-separated list of stop point ids (station naptan code e.g. 940GZZLUASL). Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param includeCrowdingData Include the crowding data (static). To Filter further use: /StopPoint/{ids}/Crowding/{line} (optional)
     * @return List&lt;TflApiPresentationEntitiesStopPoint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesStopPoint> stopPointGet(List<String> ids, Boolean includeCrowdingData) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesStopPoint>> localVarResp = stopPointGetWithHttpInfo(ids, includeCrowdingData);
        return localVarResp.getData();
    }

    /**
     * Gets a list of StopPoints corresponding to the given list of stop ids.
     * 
     * @param ids A comma-separated list of stop point ids (station naptan code e.g. 940GZZLUASL). Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param includeCrowdingData Include the crowding data (static). To Filter further use: /StopPoint/{ids}/Crowding/{line} (optional)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesStopPoint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesStopPoint>> stopPointGetWithHttpInfo(List<String> ids, Boolean includeCrowdingData) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetValidateBeforeCall(ids, includeCrowdingData, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a list of StopPoints corresponding to the given list of stop ids. (asynchronously)
     * 
     * @param ids A comma-separated list of stop point ids (station naptan code e.g. 940GZZLUASL). Max. approx. 20 ids.              You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name. (required)
     * @param includeCrowdingData Include the crowding data (static). To Filter further use: /StopPoint/{ids}/Crowding/{line} (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetAsync(List<String> ids, Boolean includeCrowdingData, final ApiCallback<List<TflApiPresentationEntitiesStopPoint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetValidateBeforeCall(ids, includeCrowdingData, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetByGeoPoint
     * @param stopTypes a list of stopTypes that should be returned (a list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint) (required)
     * @param locationLat  (required)
     * @param locationLon  (required)
     * @param radius the radius of the bounding circle in metres (default : 200) (optional)
     * @param useStopPointHierarchy Re-arrange the output into a parent/child hierarchy (optional)
     * @param modes the list of modes to search (comma separated mode names e.g. tube,dlr) (optional)
     * @param categories an optional list of comma separated property categories to return in the StopPoint&#39;s property bag. If null or empty, all categories of property are returned. Pass the keyword \&quot;none\&quot; to return no properties (a valid list of categories can be obtained from the /StopPoint/Meta/categories endpoint) (optional)
     * @param returnLines true to return the lines that each stop point serves as a nested resource (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByGeoPointCall(List<String> stopTypes, Double locationLat, Double locationLon, Integer radius, Boolean useStopPointHierarchy, List<String> modes, List<String> categories, Boolean returnLines, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (stopTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "stopTypes", stopTypes));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (useStopPointHierarchy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("useStopPointHierarchy", useStopPointHierarchy));
        }

        if (modes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "modes", modes));
        }

        if (categories != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "categories", categories));
        }

        if (returnLines != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnLines", returnLines));
        }

        if (locationLat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("location.lat", locationLat));
        }

        if (locationLon != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("location.lon", locationLon));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetByGeoPointValidateBeforeCall(List<String> stopTypes, Double locationLat, Double locationLon, Integer radius, Boolean useStopPointHierarchy, List<String> modes, List<String> categories, Boolean returnLines, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'stopTypes' is set
        if (stopTypes == null) {
            throw new ApiException("Missing the required parameter 'stopTypes' when calling stopPointGetByGeoPoint(Async)");
        }

        // verify the required parameter 'locationLat' is set
        if (locationLat == null) {
            throw new ApiException("Missing the required parameter 'locationLat' when calling stopPointGetByGeoPoint(Async)");
        }

        // verify the required parameter 'locationLon' is set
        if (locationLon == null) {
            throw new ApiException("Missing the required parameter 'locationLon' when calling stopPointGetByGeoPoint(Async)");
        }

        return stopPointGetByGeoPointCall(stopTypes, locationLat, locationLon, radius, useStopPointHierarchy, modes, categories, returnLines, _callback);

    }

    /**
     * Gets a list of StopPoints within {radius} by the specified criteria
     * 
     * @param stopTypes a list of stopTypes that should be returned (a list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint) (required)
     * @param locationLat  (required)
     * @param locationLon  (required)
     * @param radius the radius of the bounding circle in metres (default : 200) (optional)
     * @param useStopPointHierarchy Re-arrange the output into a parent/child hierarchy (optional)
     * @param modes the list of modes to search (comma separated mode names e.g. tube,dlr) (optional)
     * @param categories an optional list of comma separated property categories to return in the StopPoint&#39;s property bag. If null or empty, all categories of property are returned. Pass the keyword \&quot;none\&quot; to return no properties (a valid list of categories can be obtained from the /StopPoint/Meta/categories endpoint) (optional)
     * @param returnLines true to return the lines that each stop point serves as a nested resource (optional)
     * @return TflApiPresentationEntitiesStopPointsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public TflApiPresentationEntitiesStopPointsResponse stopPointGetByGeoPoint(List<String> stopTypes, Double locationLat, Double locationLon, Integer radius, Boolean useStopPointHierarchy, List<String> modes, List<String> categories, Boolean returnLines) throws ApiException {
        ApiResponse<TflApiPresentationEntitiesStopPointsResponse> localVarResp = stopPointGetByGeoPointWithHttpInfo(stopTypes, locationLat, locationLon, radius, useStopPointHierarchy, modes, categories, returnLines);
        return localVarResp.getData();
    }

    /**
     * Gets a list of StopPoints within {radius} by the specified criteria
     * 
     * @param stopTypes a list of stopTypes that should be returned (a list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint) (required)
     * @param locationLat  (required)
     * @param locationLon  (required)
     * @param radius the radius of the bounding circle in metres (default : 200) (optional)
     * @param useStopPointHierarchy Re-arrange the output into a parent/child hierarchy (optional)
     * @param modes the list of modes to search (comma separated mode names e.g. tube,dlr) (optional)
     * @param categories an optional list of comma separated property categories to return in the StopPoint&#39;s property bag. If null or empty, all categories of property are returned. Pass the keyword \&quot;none\&quot; to return no properties (a valid list of categories can be obtained from the /StopPoint/Meta/categories endpoint) (optional)
     * @param returnLines true to return the lines that each stop point serves as a nested resource (optional)
     * @return ApiResponse&lt;TflApiPresentationEntitiesStopPointsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TflApiPresentationEntitiesStopPointsResponse> stopPointGetByGeoPointWithHttpInfo(List<String> stopTypes, Double locationLat, Double locationLon, Integer radius, Boolean useStopPointHierarchy, List<String> modes, List<String> categories, Boolean returnLines) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetByGeoPointValidateBeforeCall(stopTypes, locationLat, locationLon, radius, useStopPointHierarchy, modes, categories, returnLines, null);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesStopPointsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a list of StopPoints within {radius} by the specified criteria (asynchronously)
     * 
     * @param stopTypes a list of stopTypes that should be returned (a list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint) (required)
     * @param locationLat  (required)
     * @param locationLon  (required)
     * @param radius the radius of the bounding circle in metres (default : 200) (optional)
     * @param useStopPointHierarchy Re-arrange the output into a parent/child hierarchy (optional)
     * @param modes the list of modes to search (comma separated mode names e.g. tube,dlr) (optional)
     * @param categories an optional list of comma separated property categories to return in the StopPoint&#39;s property bag. If null or empty, all categories of property are returned. Pass the keyword \&quot;none\&quot; to return no properties (a valid list of categories can be obtained from the /StopPoint/Meta/categories endpoint) (optional)
     * @param returnLines true to return the lines that each stop point serves as a nested resource (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByGeoPointAsync(List<String> stopTypes, Double locationLat, Double locationLon, Integer radius, Boolean useStopPointHierarchy, List<String> modes, List<String> categories, Boolean returnLines, final ApiCallback<TflApiPresentationEntitiesStopPointsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetByGeoPointValidateBeforeCall(stopTypes, locationLat, locationLon, radius, useStopPointHierarchy, modes, categories, returnLines, _callback);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesStopPointsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetByMode
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param page The data set page to return. Page 1 equates to the first 1000 stop points, page 2 equates to 1001-2000 etc. Must be entered for bus mode as data set is too large. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByModeCall(List<String> modes, Integer page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Mode/{modes}"
            .replace("{" + "modes" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", modes)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetByModeValidateBeforeCall(List<String> modes, Integer page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'modes' is set
        if (modes == null) {
            throw new ApiException("Missing the required parameter 'modes' when calling stopPointGetByMode(Async)");
        }

        return stopPointGetByModeCall(modes, page, _callback);

    }

    /**
     * Gets a list of StopPoints filtered by the modes available at that StopPoint.
     * 
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param page The data set page to return. Page 1 equates to the first 1000 stop points, page 2 equates to 1001-2000 etc. Must be entered for bus mode as data set is too large. (optional)
     * @return TflApiPresentationEntitiesStopPointsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public TflApiPresentationEntitiesStopPointsResponse stopPointGetByMode(List<String> modes, Integer page) throws ApiException {
        ApiResponse<TflApiPresentationEntitiesStopPointsResponse> localVarResp = stopPointGetByModeWithHttpInfo(modes, page);
        return localVarResp.getData();
    }

    /**
     * Gets a list of StopPoints filtered by the modes available at that StopPoint.
     * 
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param page The data set page to return. Page 1 equates to the first 1000 stop points, page 2 equates to 1001-2000 etc. Must be entered for bus mode as data set is too large. (optional)
     * @return ApiResponse&lt;TflApiPresentationEntitiesStopPointsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TflApiPresentationEntitiesStopPointsResponse> stopPointGetByModeWithHttpInfo(List<String> modes, Integer page) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetByModeValidateBeforeCall(modes, page, null);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesStopPointsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a list of StopPoints filtered by the modes available at that StopPoint. (asynchronously)
     * 
     * @param modes A comma-seperated list of modes e.g. tube,dlr (required)
     * @param page The data set page to return. Page 1 equates to the first 1000 stop points, page 2 equates to 1001-2000 etc. Must be entered for bus mode as data set is too large. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByModeAsync(List<String> modes, Integer page, final ApiCallback<TflApiPresentationEntitiesStopPointsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetByModeValidateBeforeCall(modes, page, _callback);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesStopPointsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetBySms
     * @param id A 5-digit Countdown Bus Stop Code e.g. 73241, 50435, 56334. (required)
     * @param output If set to \&quot;web\&quot;, a 302 redirect to relevant website bus stop page is returned. Valid values are : web. All other values are ignored. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetBySmsCall(String id, String output, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Sms/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (output != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("output", output));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetBySmsValidateBeforeCall(String id, String output, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointGetBySms(Async)");
        }

        return stopPointGetBySmsCall(id, output, _callback);

    }

    /**
     * Gets a StopPoint for a given sms code.
     * 
     * @param id A 5-digit Countdown Bus Stop Code e.g. 73241, 50435, 56334. (required)
     * @param output If set to \&quot;web\&quot;, a 302 redirect to relevant website bus stop page is returned. Valid values are : web. All other values are ignored. (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Object stopPointGetBySms(String id, String output) throws ApiException {
        ApiResponse<Object> localVarResp = stopPointGetBySmsWithHttpInfo(id, output);
        return localVarResp.getData();
    }

    /**
     * Gets a StopPoint for a given sms code.
     * 
     * @param id A 5-digit Countdown Bus Stop Code e.g. 73241, 50435, 56334. (required)
     * @param output If set to \&quot;web\&quot;, a 302 redirect to relevant website bus stop page is returned. Valid values are : web. All other values are ignored. (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> stopPointGetBySmsWithHttpInfo(String id, String output) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetBySmsValidateBeforeCall(id, output, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a StopPoint for a given sms code. (asynchronously)
     * 
     * @param id A 5-digit Countdown Bus Stop Code e.g. 73241, 50435, 56334. (required)
     * @param output If set to \&quot;web\&quot;, a 302 redirect to relevant website bus stop page is returned. Valid values are : web. All other values are ignored. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetBySmsAsync(String id, String output, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetBySmsValidateBeforeCall(id, output, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetByType
     * @param types A comma-separated list of the types to return. Max. approx. 12 types.               A list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByTypeCall(List<String> types, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Type/{types}"
            .replace("{" + "types" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", types)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetByTypeValidateBeforeCall(List<String> types, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'types' is set
        if (types == null) {
            throw new ApiException("Missing the required parameter 'types' when calling stopPointGetByType(Async)");
        }

        return stopPointGetByTypeCall(types, _callback);

    }

    /**
     * Gets all stop points of a given type
     * 
     * @param types A comma-separated list of the types to return. Max. approx. 12 types.               A list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint. (required)
     * @return List&lt;TflApiPresentationEntitiesStopPoint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesStopPoint> stopPointGetByType(List<String> types) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesStopPoint>> localVarResp = stopPointGetByTypeWithHttpInfo(types);
        return localVarResp.getData();
    }

    /**
     * Gets all stop points of a given type
     * 
     * @param types A comma-separated list of the types to return. Max. approx. 12 types.               A list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint. (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesStopPoint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesStopPoint>> stopPointGetByTypeWithHttpInfo(List<String> types) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetByTypeValidateBeforeCall(types, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets all stop points of a given type (asynchronously)
     * 
     * @param types A comma-separated list of the types to return. Max. approx. 12 types.               A list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByTypeAsync(List<String> types, final ApiCallback<List<TflApiPresentationEntitiesStopPoint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetByTypeValidateBeforeCall(types, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetByTypeWithPagination
     * @param types  (required)
     * @param page  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByTypeWithPaginationCall(List<String> types, Integer page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Type/{types}/page/{page}"
            .replace("{" + "types" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", types)))
            .replace("{" + "page" + "}", localVarApiClient.escapeString(page.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetByTypeWithPaginationValidateBeforeCall(List<String> types, Integer page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'types' is set
        if (types == null) {
            throw new ApiException("Missing the required parameter 'types' when calling stopPointGetByTypeWithPagination(Async)");
        }

        // verify the required parameter 'page' is set
        if (page == null) {
            throw new ApiException("Missing the required parameter 'page' when calling stopPointGetByTypeWithPagination(Async)");
        }

        return stopPointGetByTypeWithPaginationCall(types, page, _callback);

    }

    /**
     * Gets all the stop points of given type(s) with a page number
     * 
     * @param types  (required)
     * @param page  (required)
     * @return List&lt;TflApiPresentationEntitiesStopPoint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesStopPoint> stopPointGetByTypeWithPagination(List<String> types, Integer page) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesStopPoint>> localVarResp = stopPointGetByTypeWithPaginationWithHttpInfo(types, page);
        return localVarResp.getData();
    }

    /**
     * Gets all the stop points of given type(s) with a page number
     * 
     * @param types  (required)
     * @param page  (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesStopPoint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesStopPoint>> stopPointGetByTypeWithPaginationWithHttpInfo(List<String> types, Integer page) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetByTypeWithPaginationValidateBeforeCall(types, page, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets all the stop points of given type(s) with a page number (asynchronously)
     * 
     * @param types  (required)
     * @param page  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetByTypeWithPaginationAsync(List<String> types, Integer page, final ApiCallback<List<TflApiPresentationEntitiesStopPoint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetByTypeWithPaginationValidateBeforeCall(types, page, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetCarParksById
     * @param stopPointId stopPointId is required to get the car parks. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetCarParksByIdCall(String stopPointId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{stopPointId}/CarParks"
            .replace("{" + "stopPointId" + "}", localVarApiClient.escapeString(stopPointId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetCarParksByIdValidateBeforeCall(String stopPointId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'stopPointId' is set
        if (stopPointId == null) {
            throw new ApiException("Missing the required parameter 'stopPointId' when calling stopPointGetCarParksById(Async)");
        }

        return stopPointGetCarParksByIdCall(stopPointId, _callback);

    }

    /**
     * Get car parks corresponding to the given stop point id.
     * 
     * @param stopPointId stopPointId is required to get the car parks. (required)
     * @return List&lt;TflApiPresentationEntitiesPlace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesPlace> stopPointGetCarParksById(String stopPointId) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesPlace>> localVarResp = stopPointGetCarParksByIdWithHttpInfo(stopPointId);
        return localVarResp.getData();
    }

    /**
     * Get car parks corresponding to the given stop point id.
     * 
     * @param stopPointId stopPointId is required to get the car parks. (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesPlace&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesPlace>> stopPointGetCarParksByIdWithHttpInfo(String stopPointId) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetCarParksByIdValidateBeforeCall(stopPointId, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPlace>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get car parks corresponding to the given stop point id. (asynchronously)
     * 
     * @param stopPointId stopPointId is required to get the car parks. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetCarParksByIdAsync(String stopPointId, final ApiCallback<List<TflApiPresentationEntitiesPlace>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetCarParksByIdValidateBeforeCall(stopPointId, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPlace>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetServiceTypes
     * @param id The Naptan id of the stop (required)
     * @param lineIds The lines which contain the given Naptan id (all lines relevant to the given stoppoint if empty) (optional)
     * @param modes The modes which the lines are relevant to (all if empty) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetServiceTypesCall(String id, List<String> lineIds, List<String> modes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/ServiceTypes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("id", id));
        }

        if (lineIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "lineIds", lineIds));
        }

        if (modes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "modes", modes));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetServiceTypesValidateBeforeCall(String id, List<String> lineIds, List<String> modes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointGetServiceTypes(Async)");
        }

        return stopPointGetServiceTypesCall(id, lineIds, modes, _callback);

    }

    /**
     * Gets the service types for a given stoppoint
     * 
     * @param id The Naptan id of the stop (required)
     * @param lineIds The lines which contain the given Naptan id (all lines relevant to the given stoppoint if empty) (optional)
     * @param modes The modes which the lines are relevant to (all if empty) (optional)
     * @return List&lt;TflApiPresentationEntitiesLineServiceType&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesLineServiceType> stopPointGetServiceTypes(String id, List<String> lineIds, List<String> modes) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesLineServiceType>> localVarResp = stopPointGetServiceTypesWithHttpInfo(id, lineIds, modes);
        return localVarResp.getData();
    }

    /**
     * Gets the service types for a given stoppoint
     * 
     * @param id The Naptan id of the stop (required)
     * @param lineIds The lines which contain the given Naptan id (all lines relevant to the given stoppoint if empty) (optional)
     * @param modes The modes which the lines are relevant to (all if empty) (optional)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesLineServiceType&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesLineServiceType>> stopPointGetServiceTypesWithHttpInfo(String id, List<String> lineIds, List<String> modes) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetServiceTypesValidateBeforeCall(id, lineIds, modes, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesLineServiceType>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the service types for a given stoppoint (asynchronously)
     * 
     * @param id The Naptan id of the stop (required)
     * @param lineIds The lines which contain the given Naptan id (all lines relevant to the given stoppoint if empty) (optional)
     * @param modes The modes which the lines are relevant to (all if empty) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetServiceTypesAsync(String id, List<String> lineIds, List<String> modes, final ApiCallback<List<TflApiPresentationEntitiesLineServiceType>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetServiceTypesValidateBeforeCall(id, lineIds, modes, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesLineServiceType>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointGetTaxiRanksByIds
     * @param stopPointId stopPointId is required to get the taxi ranks. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetTaxiRanksByIdsCall(String stopPointId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{stopPointId}/TaxiRanks"
            .replace("{" + "stopPointId" + "}", localVarApiClient.escapeString(stopPointId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointGetTaxiRanksByIdsValidateBeforeCall(String stopPointId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'stopPointId' is set
        if (stopPointId == null) {
            throw new ApiException("Missing the required parameter 'stopPointId' when calling stopPointGetTaxiRanksByIds(Async)");
        }

        return stopPointGetTaxiRanksByIdsCall(stopPointId, _callback);

    }

    /**
     * Gets a list of taxi ranks corresponding to the given stop point id.
     * 
     * @param stopPointId stopPointId is required to get the taxi ranks. (required)
     * @return List&lt;TflApiPresentationEntitiesPlace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesPlace> stopPointGetTaxiRanksByIds(String stopPointId) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesPlace>> localVarResp = stopPointGetTaxiRanksByIdsWithHttpInfo(stopPointId);
        return localVarResp.getData();
    }

    /**
     * Gets a list of taxi ranks corresponding to the given stop point id.
     * 
     * @param stopPointId stopPointId is required to get the taxi ranks. (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesPlace&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesPlace>> stopPointGetTaxiRanksByIdsWithHttpInfo(String stopPointId) throws ApiException {
        okhttp3.Call localVarCall = stopPointGetTaxiRanksByIdsValidateBeforeCall(stopPointId, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPlace>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets a list of taxi ranks corresponding to the given stop point id. (asynchronously)
     * 
     * @param stopPointId stopPointId is required to get the taxi ranks. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointGetTaxiRanksByIdsAsync(String stopPointId, final ApiCallback<List<TflApiPresentationEntitiesPlace>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointGetTaxiRanksByIdsValidateBeforeCall(stopPointId, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPlace>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointIdPlaceTypesGet
     * @param id A naptan id for a stop point (station naptan code e.g. 940GZZLUASL). (required)
     * @param placeTypes A comcomma-separated value representing the place types. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointIdPlaceTypesGetCall(String id, List<String> placeTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{id}/placeTypes"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (placeTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "placeTypes", placeTypes));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointIdPlaceTypesGetValidateBeforeCall(String id, List<String> placeTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointIdPlaceTypesGet(Async)");
        }

        // verify the required parameter 'placeTypes' is set
        if (placeTypes == null) {
            throw new ApiException("Missing the required parameter 'placeTypes' when calling stopPointIdPlaceTypesGet(Async)");
        }

        return stopPointIdPlaceTypesGetCall(id, placeTypes, _callback);

    }

    /**
     * Get a list of places corresponding to a given id and place types.
     * 
     * @param id A naptan id for a stop point (station naptan code e.g. 940GZZLUASL). (required)
     * @param placeTypes A comcomma-separated value representing the place types. (required)
     * @return List&lt;TflApiPresentationEntitiesPlace&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesPlace> stopPointIdPlaceTypesGet(String id, List<String> placeTypes) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesPlace>> localVarResp = stopPointIdPlaceTypesGetWithHttpInfo(id, placeTypes);
        return localVarResp.getData();
    }

    /**
     * Get a list of places corresponding to a given id and place types.
     * 
     * @param id A naptan id for a stop point (station naptan code e.g. 940GZZLUASL). (required)
     * @param placeTypes A comcomma-separated value representing the place types. (required)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesPlace&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesPlace>> stopPointIdPlaceTypesGetWithHttpInfo(String id, List<String> placeTypes) throws ApiException {
        okhttp3.Call localVarCall = stopPointIdPlaceTypesGetValidateBeforeCall(id, placeTypes, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPlace>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a list of places corresponding to a given id and place types. (asynchronously)
     * 
     * @param id A naptan id for a stop point (station naptan code e.g. 940GZZLUASL). (required)
     * @param placeTypes A comcomma-separated value representing the place types. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointIdPlaceTypesGetAsync(String id, List<String> placeTypes, final ApiCallback<List<TflApiPresentationEntitiesPlace>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointIdPlaceTypesGetValidateBeforeCall(id, placeTypes, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesPlace>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointMetaCategories
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointMetaCategoriesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Meta/Categories";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointMetaCategoriesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return stopPointMetaCategoriesCall(_callback);

    }

    /**
     * Gets the list of available StopPoint additional information categories
     * 
     * @return List&lt;TflApiPresentationEntitiesStopPointCategory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesStopPointCategory> stopPointMetaCategories() throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesStopPointCategory>> localVarResp = stopPointMetaCategoriesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Gets the list of available StopPoint additional information categories
     * 
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesStopPointCategory&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesStopPointCategory>> stopPointMetaCategoriesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = stopPointMetaCategoriesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPointCategory>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the list of available StopPoint additional information categories (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointMetaCategoriesAsync(final ApiCallback<List<TflApiPresentationEntitiesStopPointCategory>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointMetaCategoriesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPointCategory>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointMetaModes
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointMetaModesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Meta/Modes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointMetaModesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return stopPointMetaModesCall(_callback);

    }

    /**
     * Gets the list of available StopPoint modes
     * 
     * @return List&lt;TflApiPresentationEntitiesMode&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesMode> stopPointMetaModes() throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesMode>> localVarResp = stopPointMetaModesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Gets the list of available StopPoint modes
     * 
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesMode&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesMode>> stopPointMetaModesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = stopPointMetaModesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesMode>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the list of available StopPoint modes (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointMetaModesAsync(final ApiCallback<List<TflApiPresentationEntitiesMode>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointMetaModesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesMode>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointMetaStopTypes
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointMetaStopTypesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Meta/StopTypes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointMetaStopTypesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return stopPointMetaStopTypesCall(_callback);

    }

    /**
     * Gets the list of available StopPoint types
     * 
     * @return List&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<String> stopPointMetaStopTypes() throws ApiException {
        ApiResponse<List<String>> localVarResp = stopPointMetaStopTypesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Gets the list of available StopPoint types
     * 
     * @return ApiResponse&lt;List&lt;String&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<String>> stopPointMetaStopTypesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = stopPointMetaStopTypesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<String>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the list of available StopPoint types (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointMetaStopTypesAsync(final ApiCallback<List<String>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointMetaStopTypesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<String>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointReachableFrom
     * @param id The id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) of the stop point to filter by (required)
     * @param lineId Line id of the line to filter by (e.g. victoria) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointReachableFromCall(String id, String lineId, List<String> serviceTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{id}/CanReachOnLine/{lineId}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()))
            .replace("{" + "lineId" + "}", localVarApiClient.escapeString(lineId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (serviceTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "serviceTypes", serviceTypes));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointReachableFromValidateBeforeCall(String id, String lineId, List<String> serviceTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointReachableFrom(Async)");
        }

        // verify the required parameter 'lineId' is set
        if (lineId == null) {
            throw new ApiException("Missing the required parameter 'lineId' when calling stopPointReachableFrom(Async)");
        }

        return stopPointReachableFromCall(id, lineId, serviceTypes, _callback);

    }

    /**
     * Gets Stopoints that are reachable from a station/line combination.
     * 
     * @param id The id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) of the stop point to filter by (required)
     * @param lineId Line id of the line to filter by (e.g. victoria) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @return List&lt;TflApiPresentationEntitiesStopPoint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesStopPoint> stopPointReachableFrom(String id, String lineId, List<String> serviceTypes) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesStopPoint>> localVarResp = stopPointReachableFromWithHttpInfo(id, lineId, serviceTypes);
        return localVarResp.getData();
    }

    /**
     * Gets Stopoints that are reachable from a station/line combination.
     * 
     * @param id The id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) of the stop point to filter by (required)
     * @param lineId Line id of the line to filter by (e.g. victoria) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesStopPoint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesStopPoint>> stopPointReachableFromWithHttpInfo(String id, String lineId, List<String> serviceTypes) throws ApiException {
        okhttp3.Call localVarCall = stopPointReachableFromValidateBeforeCall(id, lineId, serviceTypes, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets Stopoints that are reachable from a station/line combination. (asynchronously)
     * 
     * @param id The id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) of the stop point to filter by (required)
     * @param lineId Line id of the line to filter by (e.g. victoria) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointReachableFromAsync(String id, String lineId, List<String> serviceTypes, final ApiCallback<List<TflApiPresentationEntitiesStopPoint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointReachableFromValidateBeforeCall(id, lineId, serviceTypes, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPoint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointRoute
     * @param id A stop point id (station naptan codes e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointRouteCall(String id, List<String> serviceTypes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/{id}/Route"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (serviceTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "serviceTypes", serviceTypes));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointRouteValidateBeforeCall(String id, List<String> serviceTypes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling stopPointRoute(Async)");
        }

        return stopPointRouteCall(id, serviceTypes, _callback);

    }

    /**
     * Returns the route sections for all the lines that service the given stop point ids
     * 
     * @param id A stop point id (station naptan codes e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @return List&lt;TflApiPresentationEntitiesStopPointRouteSection&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<TflApiPresentationEntitiesStopPointRouteSection> stopPointRoute(String id, List<String> serviceTypes) throws ApiException {
        ApiResponse<List<TflApiPresentationEntitiesStopPointRouteSection>> localVarResp = stopPointRouteWithHttpInfo(id, serviceTypes);
        return localVarResp.getData();
    }

    /**
     * Returns the route sections for all the lines that service the given stop point ids
     * 
     * @param id A stop point id (station naptan codes e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @return ApiResponse&lt;List&lt;TflApiPresentationEntitiesStopPointRouteSection&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<TflApiPresentationEntitiesStopPointRouteSection>> stopPointRouteWithHttpInfo(String id, List<String> serviceTypes) throws ApiException {
        okhttp3.Call localVarCall = stopPointRouteValidateBeforeCall(id, serviceTypes, null);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPointRouteSection>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns the route sections for all the lines that service the given stop point ids (asynchronously)
     * 
     * @param id A stop point id (station naptan codes e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) (required)
     * @param serviceTypes A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to &#39;Regular&#39; if not specified (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointRouteAsync(String id, List<String> serviceTypes, final ApiCallback<List<TflApiPresentationEntitiesStopPointRouteSection>> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointRouteValidateBeforeCall(id, serviceTypes, _callback);
        Type localVarReturnType = new TypeToken<List<TflApiPresentationEntitiesStopPointRouteSection>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointSearch
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointSearchCall(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Search/{query}"
            .replace("{" + "query" + "}", localVarApiClient.escapeString(query.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (modes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "modes", modes));
        }

        if (faresOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("faresOnly", faresOnly));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        if (lines != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "lines", lines));
        }

        if (includeHubs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeHubs", includeHubs));
        }

        if (tflOperatedNationalRailStationsOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tflOperatedNationalRailStationsOnly", tflOperatedNationalRailStationsOnly));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointSearchValidateBeforeCall(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling stopPointSearch(Async)");
        }

        return stopPointSearchCall(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly, _callback);

    }

    /**
     * Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code.
     * 
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @return TflApiPresentationEntitiesSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public TflApiPresentationEntitiesSearchResponse stopPointSearch(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly) throws ApiException {
        ApiResponse<TflApiPresentationEntitiesSearchResponse> localVarResp = stopPointSearchWithHttpInfo(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly);
        return localVarResp.getData();
    }

    /**
     * Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code.
     * 
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @return ApiResponse&lt;TflApiPresentationEntitiesSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TflApiPresentationEntitiesSearchResponse> stopPointSearchWithHttpInfo(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly) throws ApiException {
        okhttp3.Call localVarCall = stopPointSearchValidateBeforeCall(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly, null);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code. (asynchronously)
     * 
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointSearchAsync(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly, final ApiCallback<TflApiPresentationEntitiesSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointSearchValidateBeforeCall(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly, _callback);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopPointSearchGet
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointSearchGetCall(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/StopPoint/Search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (modes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "modes", modes));
        }

        if (faresOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("faresOnly", faresOnly));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        if (lines != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "lines", lines));
        }

        if (includeHubs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeHubs", includeHubs));
        }

        if (tflOperatedNationalRailStationsOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tflOperatedNationalRailStationsOnly", tflOperatedNationalRailStationsOnly));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/json",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopPointSearchGetValidateBeforeCall(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling stopPointSearchGet(Async)");
        }

        return stopPointSearchGetCall(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly, _callback);

    }

    /**
     * Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code.
     * 
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @return TflApiPresentationEntitiesSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public TflApiPresentationEntitiesSearchResponse stopPointSearchGet(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly) throws ApiException {
        ApiResponse<TflApiPresentationEntitiesSearchResponse> localVarResp = stopPointSearchGetWithHttpInfo(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly);
        return localVarResp.getData();
    }

    /**
     * Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code.
     * 
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @return ApiResponse&lt;TflApiPresentationEntitiesSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TflApiPresentationEntitiesSearchResponse> stopPointSearchGetWithHttpInfo(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly) throws ApiException {
        okhttp3.Call localVarCall = stopPointSearchGetValidateBeforeCall(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly, null);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code. (asynchronously)
     * 
     * @param query The query string, case-insensitive. Leading and trailing wildcards are applied automatically. (required)
     * @param modes An optional, parameter separated list of the modes to filter by (optional)
     * @param faresOnly True to only return stations in that have Fares data available for single fares to another station. (optional)
     * @param maxResults An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,              it is possible that the flattened result set will contain more than 50 items. (optional)
     * @param lines An optional, parameter separated list of the lines to filter by (optional)
     * @param includeHubs If true, returns results including HUBs. (optional)
     * @param tflOperatedNationalRailStationsOnly If the national-rail mode is included, this flag will filter the national rail stations so that only those operated by TfL are returned (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopPointSearchGetAsync(String query, List<String> modes, Boolean faresOnly, Integer maxResults, List<String> lines, Boolean includeHubs, Boolean tflOperatedNationalRailStationsOnly, final ApiCallback<TflApiPresentationEntitiesSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopPointSearchGetValidateBeforeCall(query, modes, faresOnly, maxResults, lines, includeHubs, tflOperatedNationalRailStationsOnly, _callback);
        Type localVarReturnType = new TypeToken<TflApiPresentationEntitiesSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
