/**
 * Slack Web API
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.7.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIObjs_channel.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIObjs_channel::OAIObjs_channel(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIObjs_channel::OAIObjs_channel() {
    this->initializeModel();
}

OAIObjs_channel::~OAIObjs_channel() {}

void OAIObjs_channel::initializeModel() {

    m_accepted_user_isSet = false;
    m_accepted_user_isValid = false;

    m_created_isSet = false;
    m_created_isValid = false;

    m_creator_isSet = false;
    m_creator_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_is_archived_isSet = false;
    m_is_archived_isValid = false;

    m_is_channel_isSet = false;
    m_is_channel_isValid = false;

    m_is_frozen_isSet = false;
    m_is_frozen_isValid = false;

    m_is_general_isSet = false;
    m_is_general_isValid = false;

    m_is_member_isSet = false;
    m_is_member_isValid = false;

    m_is_moved_isSet = false;
    m_is_moved_isValid = false;

    m_is_mpim_isSet = false;
    m_is_mpim_isValid = false;

    m_is_non_threadable_isSet = false;
    m_is_non_threadable_isValid = false;

    m_is_org_shared_isSet = false;
    m_is_org_shared_isValid = false;

    m_is_pending_ext_shared_isSet = false;
    m_is_pending_ext_shared_isValid = false;

    m_is_private_isSet = false;
    m_is_private_isValid = false;

    m_is_read_only_isSet = false;
    m_is_read_only_isValid = false;

    m_is_shared_isSet = false;
    m_is_shared_isValid = false;

    m_is_thread_only_isSet = false;
    m_is_thread_only_isValid = false;

    m_last_read_isSet = false;
    m_last_read_isValid = false;

    m_latest_isSet = false;
    m_latest_isValid = false;

    m_members_isSet = false;
    m_members_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_name_normalized_isSet = false;
    m_name_normalized_isValid = false;

    m_num_members_isSet = false;
    m_num_members_isValid = false;

    m_pending_shared_isSet = false;
    m_pending_shared_isValid = false;

    m_previous_names_isSet = false;
    m_previous_names_isValid = false;

    m_priority_isSet = false;
    m_priority_isValid = false;

    m_purpose_isSet = false;
    m_purpose_isValid = false;

    m_topic_isSet = false;
    m_topic_isValid = false;

    m_unlinked_isSet = false;
    m_unlinked_isValid = false;

    m_unread_count_isSet = false;
    m_unread_count_isValid = false;

    m_unread_count_display_isSet = false;
    m_unread_count_display_isValid = false;
}

void OAIObjs_channel::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIObjs_channel::fromJsonObject(QJsonObject json) {

    m_accepted_user_isValid = ::OpenAPI::fromJsonValue(m_accepted_user, json[QString("accepted_user")]);
    m_accepted_user_isSet = !json[QString("accepted_user")].isNull() && m_accepted_user_isValid;

    m_created_isValid = ::OpenAPI::fromJsonValue(m_created, json[QString("created")]);
    m_created_isSet = !json[QString("created")].isNull() && m_created_isValid;

    m_creator_isValid = ::OpenAPI::fromJsonValue(m_creator, json[QString("creator")]);
    m_creator_isSet = !json[QString("creator")].isNull() && m_creator_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_is_archived_isValid = ::OpenAPI::fromJsonValue(m_is_archived, json[QString("is_archived")]);
    m_is_archived_isSet = !json[QString("is_archived")].isNull() && m_is_archived_isValid;

    m_is_channel_isValid = ::OpenAPI::fromJsonValue(m_is_channel, json[QString("is_channel")]);
    m_is_channel_isSet = !json[QString("is_channel")].isNull() && m_is_channel_isValid;

    m_is_frozen_isValid = ::OpenAPI::fromJsonValue(m_is_frozen, json[QString("is_frozen")]);
    m_is_frozen_isSet = !json[QString("is_frozen")].isNull() && m_is_frozen_isValid;

    m_is_general_isValid = ::OpenAPI::fromJsonValue(m_is_general, json[QString("is_general")]);
    m_is_general_isSet = !json[QString("is_general")].isNull() && m_is_general_isValid;

    m_is_member_isValid = ::OpenAPI::fromJsonValue(m_is_member, json[QString("is_member")]);
    m_is_member_isSet = !json[QString("is_member")].isNull() && m_is_member_isValid;

    m_is_moved_isValid = ::OpenAPI::fromJsonValue(m_is_moved, json[QString("is_moved")]);
    m_is_moved_isSet = !json[QString("is_moved")].isNull() && m_is_moved_isValid;

    m_is_mpim_isValid = ::OpenAPI::fromJsonValue(m_is_mpim, json[QString("is_mpim")]);
    m_is_mpim_isSet = !json[QString("is_mpim")].isNull() && m_is_mpim_isValid;

    m_is_non_threadable_isValid = ::OpenAPI::fromJsonValue(m_is_non_threadable, json[QString("is_non_threadable")]);
    m_is_non_threadable_isSet = !json[QString("is_non_threadable")].isNull() && m_is_non_threadable_isValid;

    m_is_org_shared_isValid = ::OpenAPI::fromJsonValue(m_is_org_shared, json[QString("is_org_shared")]);
    m_is_org_shared_isSet = !json[QString("is_org_shared")].isNull() && m_is_org_shared_isValid;

    m_is_pending_ext_shared_isValid = ::OpenAPI::fromJsonValue(m_is_pending_ext_shared, json[QString("is_pending_ext_shared")]);
    m_is_pending_ext_shared_isSet = !json[QString("is_pending_ext_shared")].isNull() && m_is_pending_ext_shared_isValid;

    m_is_private_isValid = ::OpenAPI::fromJsonValue(m_is_private, json[QString("is_private")]);
    m_is_private_isSet = !json[QString("is_private")].isNull() && m_is_private_isValid;

    m_is_read_only_isValid = ::OpenAPI::fromJsonValue(m_is_read_only, json[QString("is_read_only")]);
    m_is_read_only_isSet = !json[QString("is_read_only")].isNull() && m_is_read_only_isValid;

    m_is_shared_isValid = ::OpenAPI::fromJsonValue(m_is_shared, json[QString("is_shared")]);
    m_is_shared_isSet = !json[QString("is_shared")].isNull() && m_is_shared_isValid;

    m_is_thread_only_isValid = ::OpenAPI::fromJsonValue(m_is_thread_only, json[QString("is_thread_only")]);
    m_is_thread_only_isSet = !json[QString("is_thread_only")].isNull() && m_is_thread_only_isValid;

    m_last_read_isValid = ::OpenAPI::fromJsonValue(m_last_read, json[QString("last_read")]);
    m_last_read_isSet = !json[QString("last_read")].isNull() && m_last_read_isValid;

    m_latest_isValid = ::OpenAPI::fromJsonValue(m_latest, json[QString("latest")]);
    m_latest_isSet = !json[QString("latest")].isNull() && m_latest_isValid;

    m_members_isValid = ::OpenAPI::fromJsonValue(m_members, json[QString("members")]);
    m_members_isSet = !json[QString("members")].isNull() && m_members_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_name_normalized_isValid = ::OpenAPI::fromJsonValue(m_name_normalized, json[QString("name_normalized")]);
    m_name_normalized_isSet = !json[QString("name_normalized")].isNull() && m_name_normalized_isValid;

    m_num_members_isValid = ::OpenAPI::fromJsonValue(m_num_members, json[QString("num_members")]);
    m_num_members_isSet = !json[QString("num_members")].isNull() && m_num_members_isValid;

    m_pending_shared_isValid = ::OpenAPI::fromJsonValue(m_pending_shared, json[QString("pending_shared")]);
    m_pending_shared_isSet = !json[QString("pending_shared")].isNull() && m_pending_shared_isValid;

    m_previous_names_isValid = ::OpenAPI::fromJsonValue(m_previous_names, json[QString("previous_names")]);
    m_previous_names_isSet = !json[QString("previous_names")].isNull() && m_previous_names_isValid;

    m_priority_isValid = ::OpenAPI::fromJsonValue(m_priority, json[QString("priority")]);
    m_priority_isSet = !json[QString("priority")].isNull() && m_priority_isValid;

    m_purpose_isValid = ::OpenAPI::fromJsonValue(m_purpose, json[QString("purpose")]);
    m_purpose_isSet = !json[QString("purpose")].isNull() && m_purpose_isValid;

    m_topic_isValid = ::OpenAPI::fromJsonValue(m_topic, json[QString("topic")]);
    m_topic_isSet = !json[QString("topic")].isNull() && m_topic_isValid;

    m_unlinked_isValid = ::OpenAPI::fromJsonValue(m_unlinked, json[QString("unlinked")]);
    m_unlinked_isSet = !json[QString("unlinked")].isNull() && m_unlinked_isValid;

    m_unread_count_isValid = ::OpenAPI::fromJsonValue(m_unread_count, json[QString("unread_count")]);
    m_unread_count_isSet = !json[QString("unread_count")].isNull() && m_unread_count_isValid;

    m_unread_count_display_isValid = ::OpenAPI::fromJsonValue(m_unread_count_display, json[QString("unread_count_display")]);
    m_unread_count_display_isSet = !json[QString("unread_count_display")].isNull() && m_unread_count_display_isValid;
}

QString OAIObjs_channel::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIObjs_channel::asJsonObject() const {
    QJsonObject obj;
    if (m_accepted_user_isSet) {
        obj.insert(QString("accepted_user"), ::OpenAPI::toJsonValue(m_accepted_user));
    }
    if (m_created_isSet) {
        obj.insert(QString("created"), ::OpenAPI::toJsonValue(m_created));
    }
    if (m_creator_isSet) {
        obj.insert(QString("creator"), ::OpenAPI::toJsonValue(m_creator));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_is_archived_isSet) {
        obj.insert(QString("is_archived"), ::OpenAPI::toJsonValue(m_is_archived));
    }
    if (m_is_channel_isSet) {
        obj.insert(QString("is_channel"), ::OpenAPI::toJsonValue(m_is_channel));
    }
    if (m_is_frozen_isSet) {
        obj.insert(QString("is_frozen"), ::OpenAPI::toJsonValue(m_is_frozen));
    }
    if (m_is_general_isSet) {
        obj.insert(QString("is_general"), ::OpenAPI::toJsonValue(m_is_general));
    }
    if (m_is_member_isSet) {
        obj.insert(QString("is_member"), ::OpenAPI::toJsonValue(m_is_member));
    }
    if (m_is_moved_isSet) {
        obj.insert(QString("is_moved"), ::OpenAPI::toJsonValue(m_is_moved));
    }
    if (m_is_mpim_isSet) {
        obj.insert(QString("is_mpim"), ::OpenAPI::toJsonValue(m_is_mpim));
    }
    if (m_is_non_threadable_isSet) {
        obj.insert(QString("is_non_threadable"), ::OpenAPI::toJsonValue(m_is_non_threadable));
    }
    if (m_is_org_shared_isSet) {
        obj.insert(QString("is_org_shared"), ::OpenAPI::toJsonValue(m_is_org_shared));
    }
    if (m_is_pending_ext_shared_isSet) {
        obj.insert(QString("is_pending_ext_shared"), ::OpenAPI::toJsonValue(m_is_pending_ext_shared));
    }
    if (m_is_private_isSet) {
        obj.insert(QString("is_private"), ::OpenAPI::toJsonValue(m_is_private));
    }
    if (m_is_read_only_isSet) {
        obj.insert(QString("is_read_only"), ::OpenAPI::toJsonValue(m_is_read_only));
    }
    if (m_is_shared_isSet) {
        obj.insert(QString("is_shared"), ::OpenAPI::toJsonValue(m_is_shared));
    }
    if (m_is_thread_only_isSet) {
        obj.insert(QString("is_thread_only"), ::OpenAPI::toJsonValue(m_is_thread_only));
    }
    if (m_last_read_isSet) {
        obj.insert(QString("last_read"), ::OpenAPI::toJsonValue(m_last_read));
    }
    if (m_latest.size() > 0) {
        obj.insert(QString("latest"), ::OpenAPI::toJsonValue(m_latest));
    }
    if (m_members.size() > 0) {
        obj.insert(QString("members"), ::OpenAPI::toJsonValue(m_members));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_name_normalized_isSet) {
        obj.insert(QString("name_normalized"), ::OpenAPI::toJsonValue(m_name_normalized));
    }
    if (m_num_members_isSet) {
        obj.insert(QString("num_members"), ::OpenAPI::toJsonValue(m_num_members));
    }
    if (m_pending_shared.size() > 0) {
        obj.insert(QString("pending_shared"), ::OpenAPI::toJsonValue(m_pending_shared));
    }
    if (m_previous_names.size() > 0) {
        obj.insert(QString("previous_names"), ::OpenAPI::toJsonValue(m_previous_names));
    }
    if (m_priority_isSet) {
        obj.insert(QString("priority"), ::OpenAPI::toJsonValue(m_priority));
    }
    if (m_purpose.isSet()) {
        obj.insert(QString("purpose"), ::OpenAPI::toJsonValue(m_purpose));
    }
    if (m_topic.isSet()) {
        obj.insert(QString("topic"), ::OpenAPI::toJsonValue(m_topic));
    }
    if (m_unlinked_isSet) {
        obj.insert(QString("unlinked"), ::OpenAPI::toJsonValue(m_unlinked));
    }
    if (m_unread_count_isSet) {
        obj.insert(QString("unread_count"), ::OpenAPI::toJsonValue(m_unread_count));
    }
    if (m_unread_count_display_isSet) {
        obj.insert(QString("unread_count_display"), ::OpenAPI::toJsonValue(m_unread_count_display));
    }
    return obj;
}

QString OAIObjs_channel::getAcceptedUser() const {
    return m_accepted_user;
}
void OAIObjs_channel::setAcceptedUser(const QString &accepted_user) {
    m_accepted_user = accepted_user;
    m_accepted_user_isSet = true;
}

bool OAIObjs_channel::is_accepted_user_Set() const{
    return m_accepted_user_isSet;
}

bool OAIObjs_channel::is_accepted_user_Valid() const{
    return m_accepted_user_isValid;
}

qint32 OAIObjs_channel::getCreated() const {
    return m_created;
}
void OAIObjs_channel::setCreated(const qint32 &created) {
    m_created = created;
    m_created_isSet = true;
}

bool OAIObjs_channel::is_created_Set() const{
    return m_created_isSet;
}

bool OAIObjs_channel::is_created_Valid() const{
    return m_created_isValid;
}

QString OAIObjs_channel::getCreator() const {
    return m_creator;
}
void OAIObjs_channel::setCreator(const QString &creator) {
    m_creator = creator;
    m_creator_isSet = true;
}

bool OAIObjs_channel::is_creator_Set() const{
    return m_creator_isSet;
}

bool OAIObjs_channel::is_creator_Valid() const{
    return m_creator_isValid;
}

QString OAIObjs_channel::getId() const {
    return m_id;
}
void OAIObjs_channel::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIObjs_channel::is_id_Set() const{
    return m_id_isSet;
}

bool OAIObjs_channel::is_id_Valid() const{
    return m_id_isValid;
}

bool OAIObjs_channel::isIsArchived() const {
    return m_is_archived;
}
void OAIObjs_channel::setIsArchived(const bool &is_archived) {
    m_is_archived = is_archived;
    m_is_archived_isSet = true;
}

bool OAIObjs_channel::is_is_archived_Set() const{
    return m_is_archived_isSet;
}

bool OAIObjs_channel::is_is_archived_Valid() const{
    return m_is_archived_isValid;
}

bool OAIObjs_channel::isIsChannel() const {
    return m_is_channel;
}
void OAIObjs_channel::setIsChannel(const bool &is_channel) {
    m_is_channel = is_channel;
    m_is_channel_isSet = true;
}

bool OAIObjs_channel::is_is_channel_Set() const{
    return m_is_channel_isSet;
}

bool OAIObjs_channel::is_is_channel_Valid() const{
    return m_is_channel_isValid;
}

bool OAIObjs_channel::isIsFrozen() const {
    return m_is_frozen;
}
void OAIObjs_channel::setIsFrozen(const bool &is_frozen) {
    m_is_frozen = is_frozen;
    m_is_frozen_isSet = true;
}

bool OAIObjs_channel::is_is_frozen_Set() const{
    return m_is_frozen_isSet;
}

bool OAIObjs_channel::is_is_frozen_Valid() const{
    return m_is_frozen_isValid;
}

bool OAIObjs_channel::isIsGeneral() const {
    return m_is_general;
}
void OAIObjs_channel::setIsGeneral(const bool &is_general) {
    m_is_general = is_general;
    m_is_general_isSet = true;
}

bool OAIObjs_channel::is_is_general_Set() const{
    return m_is_general_isSet;
}

bool OAIObjs_channel::is_is_general_Valid() const{
    return m_is_general_isValid;
}

bool OAIObjs_channel::isIsMember() const {
    return m_is_member;
}
void OAIObjs_channel::setIsMember(const bool &is_member) {
    m_is_member = is_member;
    m_is_member_isSet = true;
}

bool OAIObjs_channel::is_is_member_Set() const{
    return m_is_member_isSet;
}

bool OAIObjs_channel::is_is_member_Valid() const{
    return m_is_member_isValid;
}

qint32 OAIObjs_channel::getIsMoved() const {
    return m_is_moved;
}
void OAIObjs_channel::setIsMoved(const qint32 &is_moved) {
    m_is_moved = is_moved;
    m_is_moved_isSet = true;
}

bool OAIObjs_channel::is_is_moved_Set() const{
    return m_is_moved_isSet;
}

bool OAIObjs_channel::is_is_moved_Valid() const{
    return m_is_moved_isValid;
}

bool OAIObjs_channel::isIsMpim() const {
    return m_is_mpim;
}
void OAIObjs_channel::setIsMpim(const bool &is_mpim) {
    m_is_mpim = is_mpim;
    m_is_mpim_isSet = true;
}

bool OAIObjs_channel::is_is_mpim_Set() const{
    return m_is_mpim_isSet;
}

bool OAIObjs_channel::is_is_mpim_Valid() const{
    return m_is_mpim_isValid;
}

bool OAIObjs_channel::isIsNonThreadable() const {
    return m_is_non_threadable;
}
void OAIObjs_channel::setIsNonThreadable(const bool &is_non_threadable) {
    m_is_non_threadable = is_non_threadable;
    m_is_non_threadable_isSet = true;
}

bool OAIObjs_channel::is_is_non_threadable_Set() const{
    return m_is_non_threadable_isSet;
}

bool OAIObjs_channel::is_is_non_threadable_Valid() const{
    return m_is_non_threadable_isValid;
}

bool OAIObjs_channel::isIsOrgShared() const {
    return m_is_org_shared;
}
void OAIObjs_channel::setIsOrgShared(const bool &is_org_shared) {
    m_is_org_shared = is_org_shared;
    m_is_org_shared_isSet = true;
}

bool OAIObjs_channel::is_is_org_shared_Set() const{
    return m_is_org_shared_isSet;
}

bool OAIObjs_channel::is_is_org_shared_Valid() const{
    return m_is_org_shared_isValid;
}

bool OAIObjs_channel::isIsPendingExtShared() const {
    return m_is_pending_ext_shared;
}
void OAIObjs_channel::setIsPendingExtShared(const bool &is_pending_ext_shared) {
    m_is_pending_ext_shared = is_pending_ext_shared;
    m_is_pending_ext_shared_isSet = true;
}

bool OAIObjs_channel::is_is_pending_ext_shared_Set() const{
    return m_is_pending_ext_shared_isSet;
}

bool OAIObjs_channel::is_is_pending_ext_shared_Valid() const{
    return m_is_pending_ext_shared_isValid;
}

bool OAIObjs_channel::isIsPrivate() const {
    return m_is_private;
}
void OAIObjs_channel::setIsPrivate(const bool &is_private) {
    m_is_private = is_private;
    m_is_private_isSet = true;
}

bool OAIObjs_channel::is_is_private_Set() const{
    return m_is_private_isSet;
}

bool OAIObjs_channel::is_is_private_Valid() const{
    return m_is_private_isValid;
}

bool OAIObjs_channel::isIsReadOnly() const {
    return m_is_read_only;
}
void OAIObjs_channel::setIsReadOnly(const bool &is_read_only) {
    m_is_read_only = is_read_only;
    m_is_read_only_isSet = true;
}

bool OAIObjs_channel::is_is_read_only_Set() const{
    return m_is_read_only_isSet;
}

bool OAIObjs_channel::is_is_read_only_Valid() const{
    return m_is_read_only_isValid;
}

bool OAIObjs_channel::isIsShared() const {
    return m_is_shared;
}
void OAIObjs_channel::setIsShared(const bool &is_shared) {
    m_is_shared = is_shared;
    m_is_shared_isSet = true;
}

bool OAIObjs_channel::is_is_shared_Set() const{
    return m_is_shared_isSet;
}

bool OAIObjs_channel::is_is_shared_Valid() const{
    return m_is_shared_isValid;
}

bool OAIObjs_channel::isIsThreadOnly() const {
    return m_is_thread_only;
}
void OAIObjs_channel::setIsThreadOnly(const bool &is_thread_only) {
    m_is_thread_only = is_thread_only;
    m_is_thread_only_isSet = true;
}

bool OAIObjs_channel::is_is_thread_only_Set() const{
    return m_is_thread_only_isSet;
}

bool OAIObjs_channel::is_is_thread_only_Valid() const{
    return m_is_thread_only_isValid;
}

QString OAIObjs_channel::getLastRead() const {
    return m_last_read;
}
void OAIObjs_channel::setLastRead(const QString &last_read) {
    m_last_read = last_read;
    m_last_read_isSet = true;
}

bool OAIObjs_channel::is_last_read_Set() const{
    return m_last_read_isSet;
}

bool OAIObjs_channel::is_last_read_Valid() const{
    return m_last_read_isValid;
}

QList<OAIObjs_channel_latest_inner> OAIObjs_channel::getLatest() const {
    return m_latest;
}
void OAIObjs_channel::setLatest(const QList<OAIObjs_channel_latest_inner> &latest) {
    m_latest = latest;
    m_latest_isSet = true;
}

bool OAIObjs_channel::is_latest_Set() const{
    return m_latest_isSet;
}

bool OAIObjs_channel::is_latest_Valid() const{
    return m_latest_isValid;
}

QSet<QString> OAIObjs_channel::getMembers() const {
    return m_members;
}
void OAIObjs_channel::setMembers(const QSet<QString> &members) {
    m_members = members;
    m_members_isSet = true;
}

bool OAIObjs_channel::is_members_Set() const{
    return m_members_isSet;
}

bool OAIObjs_channel::is_members_Valid() const{
    return m_members_isValid;
}

QString OAIObjs_channel::getName() const {
    return m_name;
}
void OAIObjs_channel::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIObjs_channel::is_name_Set() const{
    return m_name_isSet;
}

bool OAIObjs_channel::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIObjs_channel::getNameNormalized() const {
    return m_name_normalized;
}
void OAIObjs_channel::setNameNormalized(const QString &name_normalized) {
    m_name_normalized = name_normalized;
    m_name_normalized_isSet = true;
}

bool OAIObjs_channel::is_name_normalized_Set() const{
    return m_name_normalized_isSet;
}

bool OAIObjs_channel::is_name_normalized_Valid() const{
    return m_name_normalized_isValid;
}

qint32 OAIObjs_channel::getNumMembers() const {
    return m_num_members;
}
void OAIObjs_channel::setNumMembers(const qint32 &num_members) {
    m_num_members = num_members;
    m_num_members_isSet = true;
}

bool OAIObjs_channel::is_num_members_Set() const{
    return m_num_members_isSet;
}

bool OAIObjs_channel::is_num_members_Valid() const{
    return m_num_members_isValid;
}

QSet<QString> OAIObjs_channel::getPendingShared() const {
    return m_pending_shared;
}
void OAIObjs_channel::setPendingShared(const QSet<QString> &pending_shared) {
    m_pending_shared = pending_shared;
    m_pending_shared_isSet = true;
}

bool OAIObjs_channel::is_pending_shared_Set() const{
    return m_pending_shared_isSet;
}

bool OAIObjs_channel::is_pending_shared_Valid() const{
    return m_pending_shared_isValid;
}

QSet<QString> OAIObjs_channel::getPreviousNames() const {
    return m_previous_names;
}
void OAIObjs_channel::setPreviousNames(const QSet<QString> &previous_names) {
    m_previous_names = previous_names;
    m_previous_names_isSet = true;
}

bool OAIObjs_channel::is_previous_names_Set() const{
    return m_previous_names_isSet;
}

bool OAIObjs_channel::is_previous_names_Valid() const{
    return m_previous_names_isValid;
}

double OAIObjs_channel::getPriority() const {
    return m_priority;
}
void OAIObjs_channel::setPriority(const double &priority) {
    m_priority = priority;
    m_priority_isSet = true;
}

bool OAIObjs_channel::is_priority_Set() const{
    return m_priority_isSet;
}

bool OAIObjs_channel::is_priority_Valid() const{
    return m_priority_isValid;
}

OAIObjs_channel_purpose OAIObjs_channel::getPurpose() const {
    return m_purpose;
}
void OAIObjs_channel::setPurpose(const OAIObjs_channel_purpose &purpose) {
    m_purpose = purpose;
    m_purpose_isSet = true;
}

bool OAIObjs_channel::is_purpose_Set() const{
    return m_purpose_isSet;
}

bool OAIObjs_channel::is_purpose_Valid() const{
    return m_purpose_isValid;
}

OAIObjs_channel_purpose OAIObjs_channel::getTopic() const {
    return m_topic;
}
void OAIObjs_channel::setTopic(const OAIObjs_channel_purpose &topic) {
    m_topic = topic;
    m_topic_isSet = true;
}

bool OAIObjs_channel::is_topic_Set() const{
    return m_topic_isSet;
}

bool OAIObjs_channel::is_topic_Valid() const{
    return m_topic_isValid;
}

qint32 OAIObjs_channel::getUnlinked() const {
    return m_unlinked;
}
void OAIObjs_channel::setUnlinked(const qint32 &unlinked) {
    m_unlinked = unlinked;
    m_unlinked_isSet = true;
}

bool OAIObjs_channel::is_unlinked_Set() const{
    return m_unlinked_isSet;
}

bool OAIObjs_channel::is_unlinked_Valid() const{
    return m_unlinked_isValid;
}

qint32 OAIObjs_channel::getUnreadCount() const {
    return m_unread_count;
}
void OAIObjs_channel::setUnreadCount(const qint32 &unread_count) {
    m_unread_count = unread_count;
    m_unread_count_isSet = true;
}

bool OAIObjs_channel::is_unread_count_Set() const{
    return m_unread_count_isSet;
}

bool OAIObjs_channel::is_unread_count_Valid() const{
    return m_unread_count_isValid;
}

qint32 OAIObjs_channel::getUnreadCountDisplay() const {
    return m_unread_count_display;
}
void OAIObjs_channel::setUnreadCountDisplay(const qint32 &unread_count_display) {
    m_unread_count_display = unread_count_display;
    m_unread_count_display_isSet = true;
}

bool OAIObjs_channel::is_unread_count_display_Set() const{
    return m_unread_count_display_isSet;
}

bool OAIObjs_channel::is_unread_count_display_Valid() const{
    return m_unread_count_display_isValid;
}

bool OAIObjs_channel::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accepted_user_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_creator_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_archived_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_channel_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_frozen_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_general_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_member_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_moved_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_mpim_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_non_threadable_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_org_shared_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_pending_ext_shared_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_private_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_read_only_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_shared_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_thread_only_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_read_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_latest.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_members.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_normalized_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_members_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pending_shared.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_previous_names.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_priority_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_purpose.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_topic.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_unlinked_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unread_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unread_count_display_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIObjs_channel::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_created_isValid && m_creator_isValid && m_id_isValid && m_is_channel_isValid && m_is_mpim_isValid && m_is_org_shared_isValid && m_is_private_isValid && m_is_shared_isValid && m_members_isValid && m_name_isValid && m_name_normalized_isValid && m_purpose_isValid && m_topic_isValid && true;
}

} // namespace OpenAPI
