/*
 * Slack Web API
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import org.openapitools.client.model.ObjsChannelLatestInner;
import org.openapitools.client.model.ObjsChannelPurpose;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ObjsChannel
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:22:39.442809-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ObjsChannel {
  public static final String SERIALIZED_NAME_ACCEPTED_USER = "accepted_user";
  @SerializedName(SERIALIZED_NAME_ACCEPTED_USER)
  private String acceptedUser;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private Integer created;

  public static final String SERIALIZED_NAME_CREATOR = "creator";
  @SerializedName(SERIALIZED_NAME_CREATOR)
  private String creator;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IS_ARCHIVED = "is_archived";
  @SerializedName(SERIALIZED_NAME_IS_ARCHIVED)
  private Boolean isArchived;

  public static final String SERIALIZED_NAME_IS_CHANNEL = "is_channel";
  @SerializedName(SERIALIZED_NAME_IS_CHANNEL)
  private Boolean isChannel;

  public static final String SERIALIZED_NAME_IS_FROZEN = "is_frozen";
  @SerializedName(SERIALIZED_NAME_IS_FROZEN)
  private Boolean isFrozen;

  public static final String SERIALIZED_NAME_IS_GENERAL = "is_general";
  @SerializedName(SERIALIZED_NAME_IS_GENERAL)
  private Boolean isGeneral;

  public static final String SERIALIZED_NAME_IS_MEMBER = "is_member";
  @SerializedName(SERIALIZED_NAME_IS_MEMBER)
  private Boolean isMember;

  public static final String SERIALIZED_NAME_IS_MOVED = "is_moved";
  @SerializedName(SERIALIZED_NAME_IS_MOVED)
  private Integer isMoved;

  public static final String SERIALIZED_NAME_IS_MPIM = "is_mpim";
  @SerializedName(SERIALIZED_NAME_IS_MPIM)
  private Boolean isMpim;

  public static final String SERIALIZED_NAME_IS_NON_THREADABLE = "is_non_threadable";
  @SerializedName(SERIALIZED_NAME_IS_NON_THREADABLE)
  private Boolean isNonThreadable;

  public static final String SERIALIZED_NAME_IS_ORG_SHARED = "is_org_shared";
  @SerializedName(SERIALIZED_NAME_IS_ORG_SHARED)
  private Boolean isOrgShared;

  public static final String SERIALIZED_NAME_IS_PENDING_EXT_SHARED = "is_pending_ext_shared";
  @SerializedName(SERIALIZED_NAME_IS_PENDING_EXT_SHARED)
  private Boolean isPendingExtShared;

  public static final String SERIALIZED_NAME_IS_PRIVATE = "is_private";
  @SerializedName(SERIALIZED_NAME_IS_PRIVATE)
  private Boolean isPrivate;

  public static final String SERIALIZED_NAME_IS_READ_ONLY = "is_read_only";
  @SerializedName(SERIALIZED_NAME_IS_READ_ONLY)
  private Boolean isReadOnly;

  public static final String SERIALIZED_NAME_IS_SHARED = "is_shared";
  @SerializedName(SERIALIZED_NAME_IS_SHARED)
  private Boolean isShared;

  public static final String SERIALIZED_NAME_IS_THREAD_ONLY = "is_thread_only";
  @SerializedName(SERIALIZED_NAME_IS_THREAD_ONLY)
  private Boolean isThreadOnly;

  public static final String SERIALIZED_NAME_LAST_READ = "last_read";
  @SerializedName(SERIALIZED_NAME_LAST_READ)
  private String lastRead;

  public static final String SERIALIZED_NAME_LATEST = "latest";
  @SerializedName(SERIALIZED_NAME_LATEST)
  private List<ObjsChannelLatestInner> latest = new ArrayList<>();

  public static final String SERIALIZED_NAME_MEMBERS = "members";
  @SerializedName(SERIALIZED_NAME_MEMBERS)
  private Set<String> members = new LinkedHashSet<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAME_NORMALIZED = "name_normalized";
  @SerializedName(SERIALIZED_NAME_NAME_NORMALIZED)
  private String nameNormalized;

  public static final String SERIALIZED_NAME_NUM_MEMBERS = "num_members";
  @SerializedName(SERIALIZED_NAME_NUM_MEMBERS)
  private Integer numMembers;

  public static final String SERIALIZED_NAME_PENDING_SHARED = "pending_shared";
  @SerializedName(SERIALIZED_NAME_PENDING_SHARED)
  private Set<String> pendingShared = new LinkedHashSet<>();

  public static final String SERIALIZED_NAME_PREVIOUS_NAMES = "previous_names";
  @SerializedName(SERIALIZED_NAME_PREVIOUS_NAMES)
  private Set<String> previousNames = new LinkedHashSet<>();

  public static final String SERIALIZED_NAME_PRIORITY = "priority";
  @SerializedName(SERIALIZED_NAME_PRIORITY)
  private BigDecimal priority;

  public static final String SERIALIZED_NAME_PURPOSE = "purpose";
  @SerializedName(SERIALIZED_NAME_PURPOSE)
  private ObjsChannelPurpose purpose;

  public static final String SERIALIZED_NAME_TOPIC = "topic";
  @SerializedName(SERIALIZED_NAME_TOPIC)
  private ObjsChannelPurpose topic;

  public static final String SERIALIZED_NAME_UNLINKED = "unlinked";
  @SerializedName(SERIALIZED_NAME_UNLINKED)
  private Integer unlinked;

  public static final String SERIALIZED_NAME_UNREAD_COUNT = "unread_count";
  @SerializedName(SERIALIZED_NAME_UNREAD_COUNT)
  private Integer unreadCount;

  public static final String SERIALIZED_NAME_UNREAD_COUNT_DISPLAY = "unread_count_display";
  @SerializedName(SERIALIZED_NAME_UNREAD_COUNT_DISPLAY)
  private Integer unreadCountDisplay;

  public ObjsChannel() {
  }

  public ObjsChannel acceptedUser(String acceptedUser) {
    this.acceptedUser = acceptedUser;
    return this;
  }

  /**
   * Get acceptedUser
   * @return acceptedUser
   */
  @javax.annotation.Nullable
  public String getAcceptedUser() {
    return acceptedUser;
  }

  public void setAcceptedUser(String acceptedUser) {
    this.acceptedUser = acceptedUser;
  }


  public ObjsChannel created(Integer created) {
    this.created = created;
    return this;
  }

  /**
   * Get created
   * @return created
   */
  @javax.annotation.Nonnull
  public Integer getCreated() {
    return created;
  }

  public void setCreated(Integer created) {
    this.created = created;
  }


  public ObjsChannel creator(String creator) {
    this.creator = creator;
    return this;
  }

  /**
   * Get creator
   * @return creator
   */
  @javax.annotation.Nonnull
  public String getCreator() {
    return creator;
  }

  public void setCreator(String creator) {
    this.creator = creator;
  }


  public ObjsChannel id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public ObjsChannel isArchived(Boolean isArchived) {
    this.isArchived = isArchived;
    return this;
  }

  /**
   * Get isArchived
   * @return isArchived
   */
  @javax.annotation.Nullable
  public Boolean getIsArchived() {
    return isArchived;
  }

  public void setIsArchived(Boolean isArchived) {
    this.isArchived = isArchived;
  }


  public ObjsChannel isChannel(Boolean isChannel) {
    this.isChannel = isChannel;
    return this;
  }

  /**
   * Get isChannel
   * @return isChannel
   */
  @javax.annotation.Nonnull
  public Boolean getIsChannel() {
    return isChannel;
  }

  public void setIsChannel(Boolean isChannel) {
    this.isChannel = isChannel;
  }


  public ObjsChannel isFrozen(Boolean isFrozen) {
    this.isFrozen = isFrozen;
    return this;
  }

  /**
   * Get isFrozen
   * @return isFrozen
   */
  @javax.annotation.Nullable
  public Boolean getIsFrozen() {
    return isFrozen;
  }

  public void setIsFrozen(Boolean isFrozen) {
    this.isFrozen = isFrozen;
  }


  public ObjsChannel isGeneral(Boolean isGeneral) {
    this.isGeneral = isGeneral;
    return this;
  }

  /**
   * Get isGeneral
   * @return isGeneral
   */
  @javax.annotation.Nullable
  public Boolean getIsGeneral() {
    return isGeneral;
  }

  public void setIsGeneral(Boolean isGeneral) {
    this.isGeneral = isGeneral;
  }


  public ObjsChannel isMember(Boolean isMember) {
    this.isMember = isMember;
    return this;
  }

  /**
   * Get isMember
   * @return isMember
   */
  @javax.annotation.Nullable
  public Boolean getIsMember() {
    return isMember;
  }

  public void setIsMember(Boolean isMember) {
    this.isMember = isMember;
  }


  public ObjsChannel isMoved(Integer isMoved) {
    this.isMoved = isMoved;
    return this;
  }

  /**
   * Get isMoved
   * @return isMoved
   */
  @javax.annotation.Nullable
  public Integer getIsMoved() {
    return isMoved;
  }

  public void setIsMoved(Integer isMoved) {
    this.isMoved = isMoved;
  }


  public ObjsChannel isMpim(Boolean isMpim) {
    this.isMpim = isMpim;
    return this;
  }

  /**
   * Get isMpim
   * @return isMpim
   */
  @javax.annotation.Nonnull
  public Boolean getIsMpim() {
    return isMpim;
  }

  public void setIsMpim(Boolean isMpim) {
    this.isMpim = isMpim;
  }


  public ObjsChannel isNonThreadable(Boolean isNonThreadable) {
    this.isNonThreadable = isNonThreadable;
    return this;
  }

  /**
   * Get isNonThreadable
   * @return isNonThreadable
   */
  @javax.annotation.Nullable
  public Boolean getIsNonThreadable() {
    return isNonThreadable;
  }

  public void setIsNonThreadable(Boolean isNonThreadable) {
    this.isNonThreadable = isNonThreadable;
  }


  public ObjsChannel isOrgShared(Boolean isOrgShared) {
    this.isOrgShared = isOrgShared;
    return this;
  }

  /**
   * Get isOrgShared
   * @return isOrgShared
   */
  @javax.annotation.Nonnull
  public Boolean getIsOrgShared() {
    return isOrgShared;
  }

  public void setIsOrgShared(Boolean isOrgShared) {
    this.isOrgShared = isOrgShared;
  }


  public ObjsChannel isPendingExtShared(Boolean isPendingExtShared) {
    this.isPendingExtShared = isPendingExtShared;
    return this;
  }

  /**
   * Get isPendingExtShared
   * @return isPendingExtShared
   */
  @javax.annotation.Nullable
  public Boolean getIsPendingExtShared() {
    return isPendingExtShared;
  }

  public void setIsPendingExtShared(Boolean isPendingExtShared) {
    this.isPendingExtShared = isPendingExtShared;
  }


  public ObjsChannel isPrivate(Boolean isPrivate) {
    this.isPrivate = isPrivate;
    return this;
  }

  /**
   * Get isPrivate
   * @return isPrivate
   */
  @javax.annotation.Nonnull
  public Boolean getIsPrivate() {
    return isPrivate;
  }

  public void setIsPrivate(Boolean isPrivate) {
    this.isPrivate = isPrivate;
  }


  public ObjsChannel isReadOnly(Boolean isReadOnly) {
    this.isReadOnly = isReadOnly;
    return this;
  }

  /**
   * Get isReadOnly
   * @return isReadOnly
   */
  @javax.annotation.Nullable
  public Boolean getIsReadOnly() {
    return isReadOnly;
  }

  public void setIsReadOnly(Boolean isReadOnly) {
    this.isReadOnly = isReadOnly;
  }


  public ObjsChannel isShared(Boolean isShared) {
    this.isShared = isShared;
    return this;
  }

  /**
   * Get isShared
   * @return isShared
   */
  @javax.annotation.Nonnull
  public Boolean getIsShared() {
    return isShared;
  }

  public void setIsShared(Boolean isShared) {
    this.isShared = isShared;
  }


  public ObjsChannel isThreadOnly(Boolean isThreadOnly) {
    this.isThreadOnly = isThreadOnly;
    return this;
  }

  /**
   * Get isThreadOnly
   * @return isThreadOnly
   */
  @javax.annotation.Nullable
  public Boolean getIsThreadOnly() {
    return isThreadOnly;
  }

  public void setIsThreadOnly(Boolean isThreadOnly) {
    this.isThreadOnly = isThreadOnly;
  }


  public ObjsChannel lastRead(String lastRead) {
    this.lastRead = lastRead;
    return this;
  }

  /**
   * Get lastRead
   * @return lastRead
   */
  @javax.annotation.Nullable
  public String getLastRead() {
    return lastRead;
  }

  public void setLastRead(String lastRead) {
    this.lastRead = lastRead;
  }


  public ObjsChannel latest(List<ObjsChannelLatestInner> latest) {
    this.latest = latest;
    return this;
  }

  public ObjsChannel addLatestItem(ObjsChannelLatestInner latestItem) {
    if (this.latest == null) {
      this.latest = new ArrayList<>();
    }
    this.latest.add(latestItem);
    return this;
  }

  /**
   * Get latest
   * @return latest
   */
  @javax.annotation.Nullable
  public List<ObjsChannelLatestInner> getLatest() {
    return latest;
  }

  public void setLatest(List<ObjsChannelLatestInner> latest) {
    this.latest = latest;
  }


  public ObjsChannel members(Set<String> members) {
    this.members = members;
    return this;
  }

  public ObjsChannel addMembersItem(String membersItem) {
    if (this.members == null) {
      this.members = new LinkedHashSet<>();
    }
    this.members.add(membersItem);
    return this;
  }

  /**
   * Get members
   * @return members
   */
  @javax.annotation.Nonnull
  public Set<String> getMembers() {
    return members;
  }

  public void setMembers(Set<String> members) {
    this.members = members;
  }


  public ObjsChannel name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ObjsChannel nameNormalized(String nameNormalized) {
    this.nameNormalized = nameNormalized;
    return this;
  }

  /**
   * Get nameNormalized
   * @return nameNormalized
   */
  @javax.annotation.Nonnull
  public String getNameNormalized() {
    return nameNormalized;
  }

  public void setNameNormalized(String nameNormalized) {
    this.nameNormalized = nameNormalized;
  }


  public ObjsChannel numMembers(Integer numMembers) {
    this.numMembers = numMembers;
    return this;
  }

  /**
   * Get numMembers
   * @return numMembers
   */
  @javax.annotation.Nullable
  public Integer getNumMembers() {
    return numMembers;
  }

  public void setNumMembers(Integer numMembers) {
    this.numMembers = numMembers;
  }


  public ObjsChannel pendingShared(Set<String> pendingShared) {
    this.pendingShared = pendingShared;
    return this;
  }

  public ObjsChannel addPendingSharedItem(String pendingSharedItem) {
    if (this.pendingShared == null) {
      this.pendingShared = new LinkedHashSet<>();
    }
    this.pendingShared.add(pendingSharedItem);
    return this;
  }

  /**
   * Get pendingShared
   * @return pendingShared
   */
  @javax.annotation.Nullable
  public Set<String> getPendingShared() {
    return pendingShared;
  }

  public void setPendingShared(Set<String> pendingShared) {
    this.pendingShared = pendingShared;
  }


  public ObjsChannel previousNames(Set<String> previousNames) {
    this.previousNames = previousNames;
    return this;
  }

  public ObjsChannel addPreviousNamesItem(String previousNamesItem) {
    if (this.previousNames == null) {
      this.previousNames = new LinkedHashSet<>();
    }
    this.previousNames.add(previousNamesItem);
    return this;
  }

  /**
   * Get previousNames
   * @return previousNames
   */
  @javax.annotation.Nullable
  public Set<String> getPreviousNames() {
    return previousNames;
  }

  public void setPreviousNames(Set<String> previousNames) {
    this.previousNames = previousNames;
  }


  public ObjsChannel priority(BigDecimal priority) {
    this.priority = priority;
    return this;
  }

  /**
   * Get priority
   * @return priority
   */
  @javax.annotation.Nullable
  public BigDecimal getPriority() {
    return priority;
  }

  public void setPriority(BigDecimal priority) {
    this.priority = priority;
  }


  public ObjsChannel purpose(ObjsChannelPurpose purpose) {
    this.purpose = purpose;
    return this;
  }

  /**
   * Get purpose
   * @return purpose
   */
  @javax.annotation.Nonnull
  public ObjsChannelPurpose getPurpose() {
    return purpose;
  }

  public void setPurpose(ObjsChannelPurpose purpose) {
    this.purpose = purpose;
  }


  public ObjsChannel topic(ObjsChannelPurpose topic) {
    this.topic = topic;
    return this;
  }

  /**
   * Get topic
   * @return topic
   */
  @javax.annotation.Nonnull
  public ObjsChannelPurpose getTopic() {
    return topic;
  }

  public void setTopic(ObjsChannelPurpose topic) {
    this.topic = topic;
  }


  public ObjsChannel unlinked(Integer unlinked) {
    this.unlinked = unlinked;
    return this;
  }

  /**
   * Get unlinked
   * @return unlinked
   */
  @javax.annotation.Nullable
  public Integer getUnlinked() {
    return unlinked;
  }

  public void setUnlinked(Integer unlinked) {
    this.unlinked = unlinked;
  }


  public ObjsChannel unreadCount(Integer unreadCount) {
    this.unreadCount = unreadCount;
    return this;
  }

  /**
   * Get unreadCount
   * @return unreadCount
   */
  @javax.annotation.Nullable
  public Integer getUnreadCount() {
    return unreadCount;
  }

  public void setUnreadCount(Integer unreadCount) {
    this.unreadCount = unreadCount;
  }


  public ObjsChannel unreadCountDisplay(Integer unreadCountDisplay) {
    this.unreadCountDisplay = unreadCountDisplay;
    return this;
  }

  /**
   * Get unreadCountDisplay
   * @return unreadCountDisplay
   */
  @javax.annotation.Nullable
  public Integer getUnreadCountDisplay() {
    return unreadCountDisplay;
  }

  public void setUnreadCountDisplay(Integer unreadCountDisplay) {
    this.unreadCountDisplay = unreadCountDisplay;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ObjsChannel objsChannel = (ObjsChannel) o;
    return Objects.equals(this.acceptedUser, objsChannel.acceptedUser) &&
        Objects.equals(this.created, objsChannel.created) &&
        Objects.equals(this.creator, objsChannel.creator) &&
        Objects.equals(this.id, objsChannel.id) &&
        Objects.equals(this.isArchived, objsChannel.isArchived) &&
        Objects.equals(this.isChannel, objsChannel.isChannel) &&
        Objects.equals(this.isFrozen, objsChannel.isFrozen) &&
        Objects.equals(this.isGeneral, objsChannel.isGeneral) &&
        Objects.equals(this.isMember, objsChannel.isMember) &&
        Objects.equals(this.isMoved, objsChannel.isMoved) &&
        Objects.equals(this.isMpim, objsChannel.isMpim) &&
        Objects.equals(this.isNonThreadable, objsChannel.isNonThreadable) &&
        Objects.equals(this.isOrgShared, objsChannel.isOrgShared) &&
        Objects.equals(this.isPendingExtShared, objsChannel.isPendingExtShared) &&
        Objects.equals(this.isPrivate, objsChannel.isPrivate) &&
        Objects.equals(this.isReadOnly, objsChannel.isReadOnly) &&
        Objects.equals(this.isShared, objsChannel.isShared) &&
        Objects.equals(this.isThreadOnly, objsChannel.isThreadOnly) &&
        Objects.equals(this.lastRead, objsChannel.lastRead) &&
        Objects.equals(this.latest, objsChannel.latest) &&
        Objects.equals(this.members, objsChannel.members) &&
        Objects.equals(this.name, objsChannel.name) &&
        Objects.equals(this.nameNormalized, objsChannel.nameNormalized) &&
        Objects.equals(this.numMembers, objsChannel.numMembers) &&
        Objects.equals(this.pendingShared, objsChannel.pendingShared) &&
        Objects.equals(this.previousNames, objsChannel.previousNames) &&
        Objects.equals(this.priority, objsChannel.priority) &&
        Objects.equals(this.purpose, objsChannel.purpose) &&
        Objects.equals(this.topic, objsChannel.topic) &&
        Objects.equals(this.unlinked, objsChannel.unlinked) &&
        Objects.equals(this.unreadCount, objsChannel.unreadCount) &&
        Objects.equals(this.unreadCountDisplay, objsChannel.unreadCountDisplay);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptedUser, created, creator, id, isArchived, isChannel, isFrozen, isGeneral, isMember, isMoved, isMpim, isNonThreadable, isOrgShared, isPendingExtShared, isPrivate, isReadOnly, isShared, isThreadOnly, lastRead, latest, members, name, nameNormalized, numMembers, pendingShared, previousNames, priority, purpose, topic, unlinked, unreadCount, unreadCountDisplay);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ObjsChannel {\n");
    sb.append("    acceptedUser: ").append(toIndentedString(acceptedUser)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    creator: ").append(toIndentedString(creator)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    isArchived: ").append(toIndentedString(isArchived)).append("\n");
    sb.append("    isChannel: ").append(toIndentedString(isChannel)).append("\n");
    sb.append("    isFrozen: ").append(toIndentedString(isFrozen)).append("\n");
    sb.append("    isGeneral: ").append(toIndentedString(isGeneral)).append("\n");
    sb.append("    isMember: ").append(toIndentedString(isMember)).append("\n");
    sb.append("    isMoved: ").append(toIndentedString(isMoved)).append("\n");
    sb.append("    isMpim: ").append(toIndentedString(isMpim)).append("\n");
    sb.append("    isNonThreadable: ").append(toIndentedString(isNonThreadable)).append("\n");
    sb.append("    isOrgShared: ").append(toIndentedString(isOrgShared)).append("\n");
    sb.append("    isPendingExtShared: ").append(toIndentedString(isPendingExtShared)).append("\n");
    sb.append("    isPrivate: ").append(toIndentedString(isPrivate)).append("\n");
    sb.append("    isReadOnly: ").append(toIndentedString(isReadOnly)).append("\n");
    sb.append("    isShared: ").append(toIndentedString(isShared)).append("\n");
    sb.append("    isThreadOnly: ").append(toIndentedString(isThreadOnly)).append("\n");
    sb.append("    lastRead: ").append(toIndentedString(lastRead)).append("\n");
    sb.append("    latest: ").append(toIndentedString(latest)).append("\n");
    sb.append("    members: ").append(toIndentedString(members)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nameNormalized: ").append(toIndentedString(nameNormalized)).append("\n");
    sb.append("    numMembers: ").append(toIndentedString(numMembers)).append("\n");
    sb.append("    pendingShared: ").append(toIndentedString(pendingShared)).append("\n");
    sb.append("    previousNames: ").append(toIndentedString(previousNames)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    purpose: ").append(toIndentedString(purpose)).append("\n");
    sb.append("    topic: ").append(toIndentedString(topic)).append("\n");
    sb.append("    unlinked: ").append(toIndentedString(unlinked)).append("\n");
    sb.append("    unreadCount: ").append(toIndentedString(unreadCount)).append("\n");
    sb.append("    unreadCountDisplay: ").append(toIndentedString(unreadCountDisplay)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accepted_user");
    openapiFields.add("created");
    openapiFields.add("creator");
    openapiFields.add("id");
    openapiFields.add("is_archived");
    openapiFields.add("is_channel");
    openapiFields.add("is_frozen");
    openapiFields.add("is_general");
    openapiFields.add("is_member");
    openapiFields.add("is_moved");
    openapiFields.add("is_mpim");
    openapiFields.add("is_non_threadable");
    openapiFields.add("is_org_shared");
    openapiFields.add("is_pending_ext_shared");
    openapiFields.add("is_private");
    openapiFields.add("is_read_only");
    openapiFields.add("is_shared");
    openapiFields.add("is_thread_only");
    openapiFields.add("last_read");
    openapiFields.add("latest");
    openapiFields.add("members");
    openapiFields.add("name");
    openapiFields.add("name_normalized");
    openapiFields.add("num_members");
    openapiFields.add("pending_shared");
    openapiFields.add("previous_names");
    openapiFields.add("priority");
    openapiFields.add("purpose");
    openapiFields.add("topic");
    openapiFields.add("unlinked");
    openapiFields.add("unread_count");
    openapiFields.add("unread_count_display");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("created");
    openapiRequiredFields.add("creator");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("is_channel");
    openapiRequiredFields.add("is_mpim");
    openapiRequiredFields.add("is_org_shared");
    openapiRequiredFields.add("is_private");
    openapiRequiredFields.add("is_shared");
    openapiRequiredFields.add("members");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("name_normalized");
    openapiRequiredFields.add("purpose");
    openapiRequiredFields.add("topic");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ObjsChannel
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ObjsChannel.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ObjsChannel is not found in the empty JSON string", ObjsChannel.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ObjsChannel.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ObjsChannel` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ObjsChannel.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accepted_user") != null && !jsonObj.get("accepted_user").isJsonNull()) && !jsonObj.get("accepted_user").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accepted_user` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accepted_user").toString()));
      }
      if (!jsonObj.get("creator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creator").toString()));
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("last_read") != null && !jsonObj.get("last_read").isJsonNull()) && !jsonObj.get("last_read").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `last_read` to be a primitive type in the JSON string but got `%s`", jsonObj.get("last_read").toString()));
      }
      if (jsonObj.get("latest") != null && !jsonObj.get("latest").isJsonNull()) {
        JsonArray jsonArraylatest = jsonObj.getAsJsonArray("latest");
        if (jsonArraylatest != null) {
          // ensure the json data is an array
          if (!jsonObj.get("latest").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `latest` to be an array in the JSON string but got `%s`", jsonObj.get("latest").toString()));
          }

          // validate the optional field `latest` (array)
          for (int i = 0; i < jsonArraylatest.size(); i++) {
            ObjsChannelLatestInner.validateJsonElement(jsonArraylatest.get(i));
          };
        }
      }
      // ensure the required json array is present
      if (jsonObj.get("members") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("members").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `members` to be an array in the JSON string but got `%s`", jsonObj.get("members").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (!jsonObj.get("name_normalized").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name_normalized` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name_normalized").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("pending_shared") != null && !jsonObj.get("pending_shared").isJsonNull() && !jsonObj.get("pending_shared").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `pending_shared` to be an array in the JSON string but got `%s`", jsonObj.get("pending_shared").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("previous_names") != null && !jsonObj.get("previous_names").isJsonNull() && !jsonObj.get("previous_names").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `previous_names` to be an array in the JSON string but got `%s`", jsonObj.get("previous_names").toString()));
      }
      // validate the required field `purpose`
      ObjsChannelPurpose.validateJsonElement(jsonObj.get("purpose"));
      // validate the required field `topic`
      ObjsChannelPurpose.validateJsonElement(jsonObj.get("topic"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ObjsChannel.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ObjsChannel' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ObjsChannel> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ObjsChannel.class));

       return (TypeAdapter<T>) new TypeAdapter<ObjsChannel>() {
           @Override
           public void write(JsonWriter out, ObjsChannel value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ObjsChannel read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ObjsChannel given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ObjsChannel
   * @throws IOException if the JSON string is invalid with respect to ObjsChannel
   */
  public static ObjsChannel fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ObjsChannel.class);
  }

  /**
   * Convert an instance of ObjsChannel to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

