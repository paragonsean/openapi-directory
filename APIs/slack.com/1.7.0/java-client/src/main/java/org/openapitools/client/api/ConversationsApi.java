/*
 * Slack Web API
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.openapitools.client.model.ConversationsArchiveErrorSchema;
import org.openapitools.client.model.ConversationsArchiveSuccessSchema;
import org.openapitools.client.model.ConversationsCloseErrorSchema;
import org.openapitools.client.model.ConversationsCloseSuccessSchema;
import org.openapitools.client.model.ConversationsCreateErrorSchema;
import org.openapitools.client.model.ConversationsCreateSuccessSchema;
import org.openapitools.client.model.ConversationsHistoryErrorSchema;
import org.openapitools.client.model.ConversationsHistorySuccessSchema;
import org.openapitools.client.model.ConversationsInfoErrorSchema;
import org.openapitools.client.model.ConversationsInfoSuccessSchema;
import org.openapitools.client.model.ConversationsInviteErrorSchema;
import org.openapitools.client.model.ConversationsInviteErrorSchema1;
import org.openapitools.client.model.ConversationsJoinErrorSchema;
import org.openapitools.client.model.ConversationsJoinSuccessSchema;
import org.openapitools.client.model.ConversationsKickErrorSchema;
import org.openapitools.client.model.ConversationsKickSuccessSchema;
import org.openapitools.client.model.ConversationsLeaveErrorSchema;
import org.openapitools.client.model.ConversationsLeaveSuccessSchema;
import org.openapitools.client.model.ConversationsListErrorSchema;
import org.openapitools.client.model.ConversationsListSuccessSchema;
import org.openapitools.client.model.ConversationsMarkErrorSchema;
import org.openapitools.client.model.ConversationsMarkSuccessSchema;
import org.openapitools.client.model.ConversationsMembersErrorSchema;
import org.openapitools.client.model.ConversationsMembersSuccessSchema;
import org.openapitools.client.model.ConversationsOpenErrorSchema;
import org.openapitools.client.model.ConversationsOpenSuccessSchema;
import org.openapitools.client.model.ConversationsRenameErrorSchema;
import org.openapitools.client.model.ConversationsRenameSuccessSchema;
import org.openapitools.client.model.ConversationsRepliesErrorSchema;
import org.openapitools.client.model.ConversationsRepliesSuccessSchema;
import org.openapitools.client.model.ConversationsSetPurposeErrorSchema;
import org.openapitools.client.model.ConversationsSetPurposeSuccessSchema;
import org.openapitools.client.model.ConversationsSetTopicErrorSchema;
import org.openapitools.client.model.ConversationsSetTopicSuccessSchema;
import org.openapitools.client.model.ConversationsUnarchiveErrorSchema;
import org.openapitools.client.model.ConversationsUnarchiveSuccessSchema;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ConversationsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ConversationsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ConversationsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for conversationsArchive
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to archive (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.archive"> Documentation</a>
     */
    public okhttp3.Call conversationsArchiveCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.archive";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsArchiveValidateBeforeCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        return conversationsArchiveCall(token, channel, _callback);

    }

    /**
     * 
     * Archives a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to archive (optional)
     * @return ConversationsArchiveSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.archive"> Documentation</a>
     */
    public ConversationsArchiveSuccessSchema conversationsArchive(String token, String channel) throws ApiException {
        ApiResponse<ConversationsArchiveSuccessSchema> localVarResp = conversationsArchiveWithHttpInfo(token, channel);
        return localVarResp.getData();
    }

    /**
     * 
     * Archives a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to archive (optional)
     * @return ApiResponse&lt;ConversationsArchiveSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.archive"> Documentation</a>
     */
    public ApiResponse<ConversationsArchiveSuccessSchema> conversationsArchiveWithHttpInfo(String token, String channel) throws ApiException {
        okhttp3.Call localVarCall = conversationsArchiveValidateBeforeCall(token, channel, null);
        Type localVarReturnType = new TypeToken<ConversationsArchiveSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Archives a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to archive (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.archive"> Documentation</a>
     */
    public okhttp3.Call conversationsArchiveAsync(String token, String channel, final ApiCallback<ConversationsArchiveSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsArchiveValidateBeforeCall(token, channel, _callback);
        Type localVarReturnType = new TypeToken<ConversationsArchiveSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsClose
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to close. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.close"> Documentation</a>
     */
    public okhttp3.Call conversationsCloseCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.close";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsCloseValidateBeforeCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        return conversationsCloseCall(token, channel, _callback);

    }

    /**
     * 
     * Closes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to close. (optional)
     * @return ConversationsCloseSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.close"> Documentation</a>
     */
    public ConversationsCloseSuccessSchema conversationsClose(String token, String channel) throws ApiException {
        ApiResponse<ConversationsCloseSuccessSchema> localVarResp = conversationsCloseWithHttpInfo(token, channel);
        return localVarResp.getData();
    }

    /**
     * 
     * Closes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to close. (optional)
     * @return ApiResponse&lt;ConversationsCloseSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.close"> Documentation</a>
     */
    public ApiResponse<ConversationsCloseSuccessSchema> conversationsCloseWithHttpInfo(String token, String channel) throws ApiException {
        okhttp3.Call localVarCall = conversationsCloseValidateBeforeCall(token, channel, null);
        Type localVarReturnType = new TypeToken<ConversationsCloseSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Closes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to close. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.close"> Documentation</a>
     */
    public okhttp3.Call conversationsCloseAsync(String token, String channel, final ApiCallback<ConversationsCloseSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsCloseValidateBeforeCall(token, channel, _callback);
        Type localVarReturnType = new TypeToken<ConversationsCloseSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsCreate
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param isPrivate Create a private channel instead of a public one (optional)
     * @param name Name of the public or private channel to create (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](/types/conversation) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.create"> Documentation</a>
     */
    public okhttp3.Call conversationsCreateCall(String token, Boolean isPrivate, String name, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (isPrivate != null) {
            localVarFormParams.put("is_private", isPrivate);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsCreateValidateBeforeCall(String token, Boolean isPrivate, String name, final ApiCallback _callback) throws ApiException {
        return conversationsCreateCall(token, isPrivate, name, _callback);

    }

    /**
     * 
     * Initiates a public or private channel-based conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param isPrivate Create a private channel instead of a public one (optional)
     * @param name Name of the public or private channel to create (optional)
     * @return ConversationsCreateSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](/types/conversation) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.create"> Documentation</a>
     */
    public ConversationsCreateSuccessSchema conversationsCreate(String token, Boolean isPrivate, String name) throws ApiException {
        ApiResponse<ConversationsCreateSuccessSchema> localVarResp = conversationsCreateWithHttpInfo(token, isPrivate, name);
        return localVarResp.getData();
    }

    /**
     * 
     * Initiates a public or private channel-based conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param isPrivate Create a private channel instead of a public one (optional)
     * @param name Name of the public or private channel to create (optional)
     * @return ApiResponse&lt;ConversationsCreateSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](/types/conversation) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.create"> Documentation</a>
     */
    public ApiResponse<ConversationsCreateSuccessSchema> conversationsCreateWithHttpInfo(String token, Boolean isPrivate, String name) throws ApiException {
        okhttp3.Call localVarCall = conversationsCreateValidateBeforeCall(token, isPrivate, name, null);
        Type localVarReturnType = new TypeToken<ConversationsCreateSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Initiates a public or private channel-based conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param isPrivate Create a private channel instead of a public one (optional)
     * @param name Name of the public or private channel to create (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](/types/conversation) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.create"> Documentation</a>
     */
    public okhttp3.Call conversationsCreateAsync(String token, Boolean isPrivate, String name, final ApiCallback<ConversationsCreateSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsCreateValidateBeforeCall(token, isPrivate, name, _callback);
        Type localVarReturnType = new TypeToken<ConversationsCreateSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsHistory
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch history for. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.history"> Documentation</a>
     */
    public okhttp3.Call conversationsHistoryCall(String token, String channel, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (latest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latest", latest));
        }

        if (oldest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oldest", oldest));
        }

        if (inclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inclusive", inclusive));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsHistoryValidateBeforeCall(String token, String channel, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return conversationsHistoryCall(token, channel, latest, oldest, inclusive, limit, cursor, _callback);

    }

    /**
     * 
     * Fetches a conversation&#39;s history of messages and events.
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch history for. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsHistorySuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.history"> Documentation</a>
     */
    public ConversationsHistorySuccessSchema conversationsHistory(String token, String channel, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor) throws ApiException {
        ApiResponse<ConversationsHistorySuccessSchema> localVarResp = conversationsHistoryWithHttpInfo(token, channel, latest, oldest, inclusive, limit, cursor);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetches a conversation&#39;s history of messages and events.
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch history for. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse&lt;ConversationsHistorySuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.history"> Documentation</a>
     */
    public ApiResponse<ConversationsHistorySuccessSchema> conversationsHistoryWithHttpInfo(String token, String channel, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = conversationsHistoryValidateBeforeCall(token, channel, latest, oldest, inclusive, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsHistorySuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetches a conversation&#39;s history of messages and events.
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch history for. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.history"> Documentation</a>
     */
    public okhttp3.Call conversationsHistoryAsync(String token, String channel, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback<ConversationsHistorySuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsHistoryValidateBeforeCall(token, channel, latest, oldest, inclusive, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsHistorySuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsInfo
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel Conversation ID to learn more about (optional)
     * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
     * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.info"> Documentation</a>
     */
    public okhttp3.Call conversationsInfoCall(String token, String channel, Boolean includeLocale, Boolean includeNumMembers, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (includeLocale != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_locale", includeLocale));
        }

        if (includeNumMembers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_num_members", includeNumMembers));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsInfoValidateBeforeCall(String token, String channel, Boolean includeLocale, Boolean includeNumMembers, final ApiCallback _callback) throws ApiException {
        return conversationsInfoCall(token, channel, includeLocale, includeNumMembers, _callback);

    }

    /**
     * 
     * Retrieve information about a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel Conversation ID to learn more about (optional)
     * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
     * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
     * @return ConversationsInfoSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.info"> Documentation</a>
     */
    public ConversationsInfoSuccessSchema conversationsInfo(String token, String channel, Boolean includeLocale, Boolean includeNumMembers) throws ApiException {
        ApiResponse<ConversationsInfoSuccessSchema> localVarResp = conversationsInfoWithHttpInfo(token, channel, includeLocale, includeNumMembers);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve information about a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel Conversation ID to learn more about (optional)
     * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
     * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
     * @return ApiResponse&lt;ConversationsInfoSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.info"> Documentation</a>
     */
    public ApiResponse<ConversationsInfoSuccessSchema> conversationsInfoWithHttpInfo(String token, String channel, Boolean includeLocale, Boolean includeNumMembers) throws ApiException {
        okhttp3.Call localVarCall = conversationsInfoValidateBeforeCall(token, channel, includeLocale, includeNumMembers, null);
        Type localVarReturnType = new TypeToken<ConversationsInfoSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve information about a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel Conversation ID to learn more about (optional)
     * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
     * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.info"> Documentation</a>
     */
    public okhttp3.Call conversationsInfoAsync(String token, String channel, Boolean includeLocale, Boolean includeNumMembers, final ApiCallback<ConversationsInfoSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsInfoValidateBeforeCall(token, channel, includeLocale, includeNumMembers, _callback);
        Type localVarReturnType = new TypeToken<ConversationsInfoSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsInvite
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel The ID of the public or private channel to invite user(s) to. (optional)
     * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.invite"> Documentation</a>
     */
    public okhttp3.Call conversationsInviteCall(String token, String channel, String users, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.invite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (users != null) {
            localVarFormParams.put("users", users);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsInviteValidateBeforeCall(String token, String channel, String users, final ApiCallback _callback) throws ApiException {
        return conversationsInviteCall(token, channel, users, _callback);

    }

    /**
     * 
     * Invites users to a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel The ID of the public or private channel to invite user(s) to. (optional)
     * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
     * @return ConversationsInviteErrorSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.invite"> Documentation</a>
     */
    public ConversationsInviteErrorSchema conversationsInvite(String token, String channel, String users) throws ApiException {
        ApiResponse<ConversationsInviteErrorSchema> localVarResp = conversationsInviteWithHttpInfo(token, channel, users);
        return localVarResp.getData();
    }

    /**
     * 
     * Invites users to a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel The ID of the public or private channel to invite user(s) to. (optional)
     * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
     * @return ApiResponse&lt;ConversationsInviteErrorSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.invite"> Documentation</a>
     */
    public ApiResponse<ConversationsInviteErrorSchema> conversationsInviteWithHttpInfo(String token, String channel, String users) throws ApiException {
        okhttp3.Call localVarCall = conversationsInviteValidateBeforeCall(token, channel, users, null);
        Type localVarReturnType = new TypeToken<ConversationsInviteErrorSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Invites users to a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel The ID of the public or private channel to invite user(s) to. (optional)
     * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.invite"> Documentation</a>
     */
    public okhttp3.Call conversationsInviteAsync(String token, String channel, String users, final ApiCallback<ConversationsInviteErrorSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsInviteValidateBeforeCall(token, channel, users, _callback);
        Type localVarReturnType = new TypeToken<ConversationsInviteErrorSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsJoin
     * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
     * @param channel ID of conversation to join (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.join"> Documentation</a>
     */
    public okhttp3.Call conversationsJoinCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.join";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsJoinValidateBeforeCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        return conversationsJoinCall(token, channel, _callback);

    }

    /**
     * 
     * Joins an existing conversation.
     * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
     * @param channel ID of conversation to join (optional)
     * @return ConversationsJoinSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.join"> Documentation</a>
     */
    public ConversationsJoinSuccessSchema conversationsJoin(String token, String channel) throws ApiException {
        ApiResponse<ConversationsJoinSuccessSchema> localVarResp = conversationsJoinWithHttpInfo(token, channel);
        return localVarResp.getData();
    }

    /**
     * 
     * Joins an existing conversation.
     * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
     * @param channel ID of conversation to join (optional)
     * @return ApiResponse&lt;ConversationsJoinSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.join"> Documentation</a>
     */
    public ApiResponse<ConversationsJoinSuccessSchema> conversationsJoinWithHttpInfo(String token, String channel) throws ApiException {
        okhttp3.Call localVarCall = conversationsJoinValidateBeforeCall(token, channel, null);
        Type localVarReturnType = new TypeToken<ConversationsJoinSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Joins an existing conversation.
     * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
     * @param channel ID of conversation to join (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.join"> Documentation</a>
     */
    public okhttp3.Call conversationsJoinAsync(String token, String channel, final ApiCallback<ConversationsJoinSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsJoinValidateBeforeCall(token, channel, _callback);
        Type localVarReturnType = new TypeToken<ConversationsJoinSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsKick
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to remove user from. (optional)
     * @param user User ID to be removed. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.kick"> Documentation</a>
     */
    public okhttp3.Call conversationsKickCall(String token, String channel, String user, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.kick";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (user != null) {
            localVarFormParams.put("user", user);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsKickValidateBeforeCall(String token, String channel, String user, final ApiCallback _callback) throws ApiException {
        return conversationsKickCall(token, channel, user, _callback);

    }

    /**
     * 
     * Removes a user from a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to remove user from. (optional)
     * @param user User ID to be removed. (optional)
     * @return ConversationsKickSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.kick"> Documentation</a>
     */
    public ConversationsKickSuccessSchema conversationsKick(String token, String channel, String user) throws ApiException {
        ApiResponse<ConversationsKickSuccessSchema> localVarResp = conversationsKickWithHttpInfo(token, channel, user);
        return localVarResp.getData();
    }

    /**
     * 
     * Removes a user from a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to remove user from. (optional)
     * @param user User ID to be removed. (optional)
     * @return ApiResponse&lt;ConversationsKickSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.kick"> Documentation</a>
     */
    public ApiResponse<ConversationsKickSuccessSchema> conversationsKickWithHttpInfo(String token, String channel, String user) throws ApiException {
        okhttp3.Call localVarCall = conversationsKickValidateBeforeCall(token, channel, user, null);
        Type localVarReturnType = new TypeToken<ConversationsKickSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Removes a user from a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to remove user from. (optional)
     * @param user User ID to be removed. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.kick"> Documentation</a>
     */
    public okhttp3.Call conversationsKickAsync(String token, String channel, String user, final ApiCallback<ConversationsKickSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsKickValidateBeforeCall(token, channel, user, _callback);
        Type localVarReturnType = new TypeToken<ConversationsKickSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsLeave
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to leave (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.leave"> Documentation</a>
     */
    public okhttp3.Call conversationsLeaveCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.leave";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsLeaveValidateBeforeCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        return conversationsLeaveCall(token, channel, _callback);

    }

    /**
     * 
     * Leaves a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to leave (optional)
     * @return ConversationsLeaveSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.leave"> Documentation</a>
     */
    public ConversationsLeaveSuccessSchema conversationsLeave(String token, String channel) throws ApiException {
        ApiResponse<ConversationsLeaveSuccessSchema> localVarResp = conversationsLeaveWithHttpInfo(token, channel);
        return localVarResp.getData();
    }

    /**
     * 
     * Leaves a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to leave (optional)
     * @return ApiResponse&lt;ConversationsLeaveSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.leave"> Documentation</a>
     */
    public ApiResponse<ConversationsLeaveSuccessSchema> conversationsLeaveWithHttpInfo(String token, String channel) throws ApiException {
        okhttp3.Call localVarCall = conversationsLeaveValidateBeforeCall(token, channel, null);
        Type localVarReturnType = new TypeToken<ConversationsLeaveSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Leaves a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to leave (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.leave"> Documentation</a>
     */
    public okhttp3.Call conversationsLeaveAsync(String token, String channel, final ApiCallback<ConversationsLeaveSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsLeaveValidateBeforeCall(token, channel, _callback);
        Type localVarReturnType = new TypeToken<ConversationsLeaveSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsList
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
     * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.list"> Documentation</a>
     */
    public okhttp3.Call conversationsListCall(String token, Boolean excludeArchived, String types, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (excludeArchived != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_archived", excludeArchived));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsListValidateBeforeCall(String token, Boolean excludeArchived, String types, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return conversationsListCall(token, excludeArchived, types, limit, cursor, _callback);

    }

    /**
     * 
     * Lists all channels in a Slack team.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
     * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsListSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.list"> Documentation</a>
     */
    public ConversationsListSuccessSchema conversationsList(String token, Boolean excludeArchived, String types, Integer limit, String cursor) throws ApiException {
        ApiResponse<ConversationsListSuccessSchema> localVarResp = conversationsListWithHttpInfo(token, excludeArchived, types, limit, cursor);
        return localVarResp.getData();
    }

    /**
     * 
     * Lists all channels in a Slack team.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
     * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse&lt;ConversationsListSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.list"> Documentation</a>
     */
    public ApiResponse<ConversationsListSuccessSchema> conversationsListWithHttpInfo(String token, Boolean excludeArchived, String types, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = conversationsListValidateBeforeCall(token, excludeArchived, types, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsListSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Lists all channels in a Slack team.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
     * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.list"> Documentation</a>
     */
    public okhttp3.Call conversationsListAsync(String token, Boolean excludeArchived, String types, Integer limit, String cursor, final ApiCallback<ConversationsListSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsListValidateBeforeCall(token, excludeArchived, types, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsListSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsMark
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Channel or conversation to set the read cursor for. (optional)
     * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.mark"> Documentation</a>
     */
    public okhttp3.Call conversationsMarkCall(String token, String channel, BigDecimal ts, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.mark";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (ts != null) {
            localVarFormParams.put("ts", ts);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsMarkValidateBeforeCall(String token, String channel, BigDecimal ts, final ApiCallback _callback) throws ApiException {
        return conversationsMarkCall(token, channel, ts, _callback);

    }

    /**
     * 
     * Sets the read cursor in a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Channel or conversation to set the read cursor for. (optional)
     * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
     * @return ConversationsMarkSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.mark"> Documentation</a>
     */
    public ConversationsMarkSuccessSchema conversationsMark(String token, String channel, BigDecimal ts) throws ApiException {
        ApiResponse<ConversationsMarkSuccessSchema> localVarResp = conversationsMarkWithHttpInfo(token, channel, ts);
        return localVarResp.getData();
    }

    /**
     * 
     * Sets the read cursor in a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Channel or conversation to set the read cursor for. (optional)
     * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
     * @return ApiResponse&lt;ConversationsMarkSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.mark"> Documentation</a>
     */
    public ApiResponse<ConversationsMarkSuccessSchema> conversationsMarkWithHttpInfo(String token, String channel, BigDecimal ts) throws ApiException {
        okhttp3.Call localVarCall = conversationsMarkValidateBeforeCall(token, channel, ts, null);
        Type localVarReturnType = new TypeToken<ConversationsMarkSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Sets the read cursor in a channel.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Channel or conversation to set the read cursor for. (optional)
     * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.mark"> Documentation</a>
     */
    public okhttp3.Call conversationsMarkAsync(String token, String channel, BigDecimal ts, final ApiCallback<ConversationsMarkSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsMarkValidateBeforeCall(token, channel, ts, _callback);
        Type localVarReturnType = new TypeToken<ConversationsMarkSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsMembers
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel ID of the conversation to retrieve members for (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.members"> Documentation</a>
     */
    public okhttp3.Call conversationsMembersCall(String token, String channel, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.members";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsMembersValidateBeforeCall(String token, String channel, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return conversationsMembersCall(token, channel, limit, cursor, _callback);

    }

    /**
     * 
     * Retrieve members of a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel ID of the conversation to retrieve members for (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsMembersSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.members"> Documentation</a>
     */
    public ConversationsMembersSuccessSchema conversationsMembers(String token, String channel, Integer limit, String cursor) throws ApiException {
        ApiResponse<ConversationsMembersSuccessSchema> localVarResp = conversationsMembersWithHttpInfo(token, channel, limit, cursor);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve members of a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel ID of the conversation to retrieve members for (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse&lt;ConversationsMembersSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.members"> Documentation</a>
     */
    public ApiResponse<ConversationsMembersSuccessSchema> conversationsMembersWithHttpInfo(String token, String channel, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = conversationsMembersValidateBeforeCall(token, channel, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsMembersSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve members of a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
     * @param channel ID of the conversation to retrieve members for (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.members"> Documentation</a>
     */
    public okhttp3.Call conversationsMembersAsync(String token, String channel, Integer limit, String cursor, final ApiCallback<ConversationsMembersSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsMembersValidateBeforeCall(token, channel, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsMembersSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsOpen
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
     * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
     * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.open"> Documentation</a>
     */
    public okhttp3.Call conversationsOpenCall(String token, String channel, Boolean returnIm, String users, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.open";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (returnIm != null) {
            localVarFormParams.put("return_im", returnIm);
        }

        if (users != null) {
            localVarFormParams.put("users", users);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsOpenValidateBeforeCall(String token, String channel, Boolean returnIm, String users, final ApiCallback _callback) throws ApiException {
        return conversationsOpenCall(token, channel, returnIm, users, _callback);

    }

    /**
     * 
     * Opens or resumes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
     * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
     * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
     * @return ConversationsOpenSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.open"> Documentation</a>
     */
    public ConversationsOpenSuccessSchema conversationsOpen(String token, String channel, Boolean returnIm, String users) throws ApiException {
        ApiResponse<ConversationsOpenSuccessSchema> localVarResp = conversationsOpenWithHttpInfo(token, channel, returnIm, users);
        return localVarResp.getData();
    }

    /**
     * 
     * Opens or resumes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
     * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
     * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
     * @return ApiResponse&lt;ConversationsOpenSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.open"> Documentation</a>
     */
    public ApiResponse<ConversationsOpenSuccessSchema> conversationsOpenWithHttpInfo(String token, String channel, Boolean returnIm, String users) throws ApiException {
        okhttp3.Call localVarCall = conversationsOpenValidateBeforeCall(token, channel, returnIm, users, null);
        Type localVarReturnType = new TypeToken<ConversationsOpenSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Opens or resumes a direct message or multi-person direct message.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
     * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
     * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.open"> Documentation</a>
     */
    public okhttp3.Call conversationsOpenAsync(String token, String channel, Boolean returnIm, String users, final ApiCallback<ConversationsOpenSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsOpenValidateBeforeCall(token, channel, returnIm, users, _callback);
        Type localVarReturnType = new TypeToken<ConversationsOpenSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsRename
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to rename (optional)
     * @param name New name for conversation. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.rename"> Documentation</a>
     */
    public okhttp3.Call conversationsRenameCall(String token, String channel, String name, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.rename";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsRenameValidateBeforeCall(String token, String channel, String name, final ApiCallback _callback) throws ApiException {
        return conversationsRenameCall(token, channel, name, _callback);

    }

    /**
     * 
     * Renames a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to rename (optional)
     * @param name New name for conversation. (optional)
     * @return ConversationsRenameSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.rename"> Documentation</a>
     */
    public ConversationsRenameSuccessSchema conversationsRename(String token, String channel, String name) throws ApiException {
        ApiResponse<ConversationsRenameSuccessSchema> localVarResp = conversationsRenameWithHttpInfo(token, channel, name);
        return localVarResp.getData();
    }

    /**
     * 
     * Renames a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to rename (optional)
     * @param name New name for conversation. (optional)
     * @return ApiResponse&lt;ConversationsRenameSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.rename"> Documentation</a>
     */
    public ApiResponse<ConversationsRenameSuccessSchema> conversationsRenameWithHttpInfo(String token, String channel, String name) throws ApiException {
        okhttp3.Call localVarCall = conversationsRenameValidateBeforeCall(token, channel, name, null);
        Type localVarReturnType = new TypeToken<ConversationsRenameSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Renames a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to rename (optional)
     * @param name New name for conversation. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.rename"> Documentation</a>
     */
    public okhttp3.Call conversationsRenameAsync(String token, String channel, String name, final ApiCallback<ConversationsRenameSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsRenameValidateBeforeCall(token, channel, name, _callback);
        Type localVarReturnType = new TypeToken<ConversationsRenameSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsReplies
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch thread from. (optional)
     * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.replies"> Documentation</a>
     */
    public okhttp3.Call conversationsRepliesCall(String token, String channel, BigDecimal ts, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.replies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (ts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ts", ts));
        }

        if (latest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latest", latest));
        }

        if (oldest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oldest", oldest));
        }

        if (inclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inclusive", inclusive));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsRepliesValidateBeforeCall(String token, String channel, BigDecimal ts, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return conversationsRepliesCall(token, channel, ts, latest, oldest, inclusive, limit, cursor, _callback);

    }

    /**
     * 
     * Retrieve a thread of messages posted to a conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch thread from. (optional)
     * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ConversationsRepliesSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.replies"> Documentation</a>
     */
    public ConversationsRepliesSuccessSchema conversationsReplies(String token, String channel, BigDecimal ts, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor) throws ApiException {
        ApiResponse<ConversationsRepliesSuccessSchema> localVarResp = conversationsRepliesWithHttpInfo(token, channel, ts, latest, oldest, inclusive, limit, cursor);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve a thread of messages posted to a conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch thread from. (optional)
     * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @return ApiResponse&lt;ConversationsRepliesSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.replies"> Documentation</a>
     */
    public ApiResponse<ConversationsRepliesSuccessSchema> conversationsRepliesWithHttpInfo(String token, String channel, BigDecimal ts, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = conversationsRepliesValidateBeforeCall(token, channel, ts, latest, oldest, inclusive, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsRepliesSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve a thread of messages posted to a conversation
     * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
     * @param channel Conversation ID to fetch thread from. (optional)
     * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
     * @param latest End of time range of messages to include in results. (optional)
     * @param oldest Start of time range of messages to include in results. (optional)
     * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
     * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
     * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.replies"> Documentation</a>
     */
    public okhttp3.Call conversationsRepliesAsync(String token, String channel, BigDecimal ts, BigDecimal latest, BigDecimal oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback<ConversationsRepliesSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsRepliesValidateBeforeCall(token, channel, ts, latest, oldest, inclusive, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsRepliesSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsSetPurpose
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the purpose of (optional)
     * @param purpose A new, specialer purpose (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setPurpose"> Documentation</a>
     */
    public okhttp3.Call conversationsSetPurposeCall(String token, String channel, String purpose, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.setPurpose";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (purpose != null) {
            localVarFormParams.put("purpose", purpose);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsSetPurposeValidateBeforeCall(String token, String channel, String purpose, final ApiCallback _callback) throws ApiException {
        return conversationsSetPurposeCall(token, channel, purpose, _callback);

    }

    /**
     * 
     * Sets the purpose for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the purpose of (optional)
     * @param purpose A new, specialer purpose (optional)
     * @return ConversationsSetPurposeSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setPurpose"> Documentation</a>
     */
    public ConversationsSetPurposeSuccessSchema conversationsSetPurpose(String token, String channel, String purpose) throws ApiException {
        ApiResponse<ConversationsSetPurposeSuccessSchema> localVarResp = conversationsSetPurposeWithHttpInfo(token, channel, purpose);
        return localVarResp.getData();
    }

    /**
     * 
     * Sets the purpose for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the purpose of (optional)
     * @param purpose A new, specialer purpose (optional)
     * @return ApiResponse&lt;ConversationsSetPurposeSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setPurpose"> Documentation</a>
     */
    public ApiResponse<ConversationsSetPurposeSuccessSchema> conversationsSetPurposeWithHttpInfo(String token, String channel, String purpose) throws ApiException {
        okhttp3.Call localVarCall = conversationsSetPurposeValidateBeforeCall(token, channel, purpose, null);
        Type localVarReturnType = new TypeToken<ConversationsSetPurposeSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Sets the purpose for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the purpose of (optional)
     * @param purpose A new, specialer purpose (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setPurpose"> Documentation</a>
     */
    public okhttp3.Call conversationsSetPurposeAsync(String token, String channel, String purpose, final ApiCallback<ConversationsSetPurposeSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsSetPurposeValidateBeforeCall(token, channel, purpose, _callback);
        Type localVarReturnType = new TypeToken<ConversationsSetPurposeSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsSetTopic
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the topic of (optional)
     * @param topic The new topic string. Does not support formatting or linkification. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setTopic"> Documentation</a>
     */
    public okhttp3.Call conversationsSetTopicCall(String token, String channel, String topic, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.setTopic";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (topic != null) {
            localVarFormParams.put("topic", topic);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsSetTopicValidateBeforeCall(String token, String channel, String topic, final ApiCallback _callback) throws ApiException {
        return conversationsSetTopicCall(token, channel, topic, _callback);

    }

    /**
     * 
     * Sets the topic for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the topic of (optional)
     * @param topic The new topic string. Does not support formatting or linkification. (optional)
     * @return ConversationsSetTopicSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setTopic"> Documentation</a>
     */
    public ConversationsSetTopicSuccessSchema conversationsSetTopic(String token, String channel, String topic) throws ApiException {
        ApiResponse<ConversationsSetTopicSuccessSchema> localVarResp = conversationsSetTopicWithHttpInfo(token, channel, topic);
        return localVarResp.getData();
    }

    /**
     * 
     * Sets the topic for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the topic of (optional)
     * @param topic The new topic string. Does not support formatting or linkification. (optional)
     * @return ApiResponse&lt;ConversationsSetTopicSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setTopic"> Documentation</a>
     */
    public ApiResponse<ConversationsSetTopicSuccessSchema> conversationsSetTopicWithHttpInfo(String token, String channel, String topic) throws ApiException {
        okhttp3.Call localVarCall = conversationsSetTopicValidateBeforeCall(token, channel, topic, null);
        Type localVarReturnType = new TypeToken<ConversationsSetTopicSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Sets the topic for a conversation.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel Conversation to set the topic of (optional)
     * @param topic The new topic string. Does not support formatting or linkification. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setTopic"> Documentation</a>
     */
    public okhttp3.Call conversationsSetTopicAsync(String token, String channel, String topic, final ApiCallback<ConversationsSetTopicSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsSetTopicValidateBeforeCall(token, channel, topic, _callback);
        Type localVarReturnType = new TypeToken<ConversationsSetTopicSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsUnarchive
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to unarchive (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.unarchive"> Documentation</a>
     */
    public okhttp3.Call conversationsUnarchiveCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.unarchive";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsUnarchiveValidateBeforeCall(String token, String channel, final ApiCallback _callback) throws ApiException {
        return conversationsUnarchiveCall(token, channel, _callback);

    }

    /**
     * 
     * Reverses conversation archival.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to unarchive (optional)
     * @return ConversationsUnarchiveSuccessSchema
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.unarchive"> Documentation</a>
     */
    public ConversationsUnarchiveSuccessSchema conversationsUnarchive(String token, String channel) throws ApiException {
        ApiResponse<ConversationsUnarchiveSuccessSchema> localVarResp = conversationsUnarchiveWithHttpInfo(token, channel);
        return localVarResp.getData();
    }

    /**
     * 
     * Reverses conversation archival.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to unarchive (optional)
     * @return ApiResponse&lt;ConversationsUnarchiveSuccessSchema&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.unarchive"> Documentation</a>
     */
    public ApiResponse<ConversationsUnarchiveSuccessSchema> conversationsUnarchiveWithHttpInfo(String token, String channel) throws ApiException {
        okhttp3.Call localVarCall = conversationsUnarchiveValidateBeforeCall(token, channel, null);
        Type localVarReturnType = new TypeToken<ConversationsUnarchiveSuccessSchema>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Reverses conversation archival.
     * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
     * @param channel ID of conversation to unarchive (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.unarchive"> Documentation</a>
     */
    public okhttp3.Call conversationsUnarchiveAsync(String token, String channel, final ApiCallback<ConversationsUnarchiveSuccessSchema> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsUnarchiveValidateBeforeCall(token, channel, _callback);
        Type localVarReturnType = new TypeToken<ConversationsUnarchiveSuccessSchema>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
