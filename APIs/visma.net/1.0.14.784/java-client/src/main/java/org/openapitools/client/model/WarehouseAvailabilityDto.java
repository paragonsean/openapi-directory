/*
 * Visma.net.ERP.SalesOrders.Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.14.784
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.LocationAvailabilityDto;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Warehouse information for a specific inventory item
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:18:31.300103-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class WarehouseAvailabilityDto {
  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ESTIMATED_TOTAL_COST = "estimatedTotalCost";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_TOTAL_COST)
  private Double estimatedTotalCost;

  public static final String SERIALIZED_NAME_ESTIMATED_UNIT_COST = "estimatedUnitCost";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_UNIT_COST)
  private Double estimatedUnitCost;

  public static final String SERIALIZED_NAME_INTERNAL_WAREHOUSE_ID = "internalWarehouseId";
  @SerializedName(SERIALIZED_NAME_INTERNAL_WAREHOUSE_ID)
  private Integer internalWarehouseId;

  public static final String SERIALIZED_NAME_LAST_MODIFIED = "lastModified";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED)
  private OffsetDateTime lastModified;

  public static final String SERIALIZED_NAME_LOCATIONS = "locations";
  @SerializedName(SERIALIZED_NAME_LOCATIONS)
  private List<LocationAvailabilityDto> locations;

  public static final String SERIALIZED_NAME_QUANTITY_AVAILABLE = "quantityAvailable";
  @SerializedName(SERIALIZED_NAME_QUANTITY_AVAILABLE)
  private Double quantityAvailable;

  public static final String SERIALIZED_NAME_QUANTITY_AVAILABLE_FOR_SHIPMENT = "quantityAvailableForShipment";
  @SerializedName(SERIALIZED_NAME_QUANTITY_AVAILABLE_FOR_SHIPMENT)
  private Double quantityAvailableForShipment;

  public static final String SERIALIZED_NAME_QUANTITY_NOT_AVAILABLE = "quantityNotAvailable";
  @SerializedName(SERIALIZED_NAME_QUANTITY_NOT_AVAILABLE)
  private Double quantityNotAvailable;

  public static final String SERIALIZED_NAME_QUANTITY_ON_HAND = "quantityOnHand";
  @SerializedName(SERIALIZED_NAME_QUANTITY_ON_HAND)
  private Double quantityOnHand;

  public static final String SERIALIZED_NAME_QUANTITY_PURCHASE_ORDERS = "quantityPurchaseOrders";
  @SerializedName(SERIALIZED_NAME_QUANTITY_PURCHASE_ORDERS)
  private Double quantityPurchaseOrders;

  public static final String SERIALIZED_NAME_WAREHOUSE_ID = "warehouseId";
  @SerializedName(SERIALIZED_NAME_WAREHOUSE_ID)
  private String warehouseId;

  public WarehouseAvailabilityDto() {
  }

  public WarehouseAvailabilityDto description(String description) {
    this.description = description;
    return this;
  }

  /**
   * The description of the warehouse
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public WarehouseAvailabilityDto estimatedTotalCost(Double estimatedTotalCost) {
    this.estimatedTotalCost = estimatedTotalCost;
    return this;
  }

  /**
   * The total cost for the QuantityOnHand
   * @return estimatedTotalCost
   */
  @javax.annotation.Nullable
  public Double getEstimatedTotalCost() {
    return estimatedTotalCost;
  }

  public void setEstimatedTotalCost(Double estimatedTotalCost) {
    this.estimatedTotalCost = estimatedTotalCost;
  }


  public WarehouseAvailabilityDto estimatedUnitCost(Double estimatedUnitCost) {
    this.estimatedUnitCost = estimatedUnitCost;
    return this;
  }

  /**
   * The estimated cost per unit, calculated as EstimatedTotalCost/QuantityOnHand
   * @return estimatedUnitCost
   */
  @javax.annotation.Nullable
  public Double getEstimatedUnitCost() {
    return estimatedUnitCost;
  }

  public void setEstimatedUnitCost(Double estimatedUnitCost) {
    this.estimatedUnitCost = estimatedUnitCost;
  }


  public WarehouseAvailabilityDto internalWarehouseId(Integer internalWarehouseId) {
    this.internalWarehouseId = internalWarehouseId;
    return this;
  }

  /**
   * The internal id used by the system for the warehouse
   * @return internalWarehouseId
   */
  @javax.annotation.Nullable
  public Integer getInternalWarehouseId() {
    return internalWarehouseId;
  }

  public void setInternalWarehouseId(Integer internalWarehouseId) {
    this.internalWarehouseId = internalWarehouseId;
  }


  public WarehouseAvailabilityDto lastModified(OffsetDateTime lastModified) {
    this.lastModified = lastModified;
    return this;
  }

  /**
   * The date and time the entry for this warehouse was modified  Unless a specific time zone offset is included (e.g. &#39;2012-12-24T12:15:14+02:00&#39;), the date is considered to be in the UTC time zone.
   * @return lastModified
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastModified() {
    return lastModified;
  }

  public void setLastModified(OffsetDateTime lastModified) {
    this.lastModified = lastModified;
  }


  public WarehouseAvailabilityDto locations(List<LocationAvailabilityDto> locations) {
    this.locations = locations;
    return this;
  }

  public WarehouseAvailabilityDto addLocationsItem(LocationAvailabilityDto locationsItem) {
    if (this.locations == null) {
      this.locations = new ArrayList<>();
    }
    this.locations.add(locationsItem);
    return this;
  }

  /**
   * List of locations in the warehouse for the specific inventory item.  Note that this is not returned as part of the response unless expand&#x3D;Location is specified with the request.
   * @return locations
   */
  @javax.annotation.Nullable
  public List<LocationAvailabilityDto> getLocations() {
    return locations;
  }

  public void setLocations(List<LocationAvailabilityDto> locations) {
    this.locations = locations;
  }


  public WarehouseAvailabilityDto quantityAvailable(Double quantityAvailable) {
    this.quantityAvailable = quantityAvailable;
    return this;
  }

  /**
   * You can configure the way this estimated quantity is calculated by using availability  calculation rules. The available quantity may include anticipated transactions and therefore  may be less than or greater than the QuantityOnHand. Anticipated transactions correspond  to the documents and transactions that have been entered in the system but not yet  processed to the end.  In the availability calculation settings of an item class, you specify which anticipated  transactions affect the available quantity. Thus, the available quantity may include  goods on purchase orders and exclude the goods allocated for sales orders. You can use  the available quantity as an indicator of demand
   * @return quantityAvailable
   */
  @javax.annotation.Nullable
  public Double getQuantityAvailable() {
    return quantityAvailable;
  }

  public void setQuantityAvailable(Double quantityAvailable) {
    this.quantityAvailable = quantityAvailable;
  }


  public WarehouseAvailabilityDto quantityAvailableForShipment(Double quantityAvailableForShipment) {
    this.quantityAvailableForShipment = quantityAvailableForShipment;
    return this;
  }

  /**
   * Estimated quantity calculated by using the following formula: the QuantityOnHand minus the quantity on unreleased inventory  issues, minus the quantity allocated for shipping. Thus, the QuantityAvailableForShipment can be less than the QuantityOnHand
   * @return quantityAvailableForShipment
   */
  @javax.annotation.Nullable
  public Double getQuantityAvailableForShipment() {
    return quantityAvailableForShipment;
  }

  public void setQuantityAvailableForShipment(Double quantityAvailableForShipment) {
    this.quantityAvailableForShipment = quantityAvailableForShipment;
  }


  public WarehouseAvailabilityDto quantityNotAvailable(Double quantityNotAvailable) {
    this.quantityNotAvailable = quantityNotAvailable;
    return this;
  }

  /**
   * The quantity stored at locations not included in the availability calculation.  For each warehouse location, the &#39;Include in Qty. Available&#39; check box on the  Warehouses(IN204000) screen defines whether the quantity of items stored at this  location is included in the quantity of available items.
   * @return quantityNotAvailable
   */
  @javax.annotation.Nullable
  public Double getQuantityNotAvailable() {
    return quantityNotAvailable;
  }

  public void setQuantityNotAvailable(Double quantityNotAvailable) {
    this.quantityNotAvailable = quantityNotAvailable;
  }


  public WarehouseAvailabilityDto quantityOnHand(Double quantityOnHand) {
    this.quantityOnHand = quantityOnHand;
    return this;
  }

  /**
   * Physical quantity on-hand of items in the specific warehouse
   * @return quantityOnHand
   */
  @javax.annotation.Nullable
  public Double getQuantityOnHand() {
    return quantityOnHand;
  }

  public void setQuantityOnHand(Double quantityOnHand) {
    this.quantityOnHand = quantityOnHand;
  }


  public WarehouseAvailabilityDto quantityPurchaseOrders(Double quantityPurchaseOrders) {
    this.quantityPurchaseOrders = quantityPurchaseOrders;
    return this;
  }

  /**
   * The quantity of the inventory item included in open purchase orders.
   * @return quantityPurchaseOrders
   */
  @javax.annotation.Nullable
  public Double getQuantityPurchaseOrders() {
    return quantityPurchaseOrders;
  }

  public void setQuantityPurchaseOrders(Double quantityPurchaseOrders) {
    this.quantityPurchaseOrders = quantityPurchaseOrders;
  }


  public WarehouseAvailabilityDto warehouseId(String warehouseId) {
    this.warehouseId = warehouseId;
    return this;
  }

  /**
   * The id (SiteCd) of the warehouse
   * @return warehouseId
   */
  @javax.annotation.Nullable
  public String getWarehouseId() {
    return warehouseId;
  }

  public void setWarehouseId(String warehouseId) {
    this.warehouseId = warehouseId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WarehouseAvailabilityDto warehouseAvailabilityDto = (WarehouseAvailabilityDto) o;
    return Objects.equals(this.description, warehouseAvailabilityDto.description) &&
        Objects.equals(this.estimatedTotalCost, warehouseAvailabilityDto.estimatedTotalCost) &&
        Objects.equals(this.estimatedUnitCost, warehouseAvailabilityDto.estimatedUnitCost) &&
        Objects.equals(this.internalWarehouseId, warehouseAvailabilityDto.internalWarehouseId) &&
        Objects.equals(this.lastModified, warehouseAvailabilityDto.lastModified) &&
        Objects.equals(this.locations, warehouseAvailabilityDto.locations) &&
        Objects.equals(this.quantityAvailable, warehouseAvailabilityDto.quantityAvailable) &&
        Objects.equals(this.quantityAvailableForShipment, warehouseAvailabilityDto.quantityAvailableForShipment) &&
        Objects.equals(this.quantityNotAvailable, warehouseAvailabilityDto.quantityNotAvailable) &&
        Objects.equals(this.quantityOnHand, warehouseAvailabilityDto.quantityOnHand) &&
        Objects.equals(this.quantityPurchaseOrders, warehouseAvailabilityDto.quantityPurchaseOrders) &&
        Objects.equals(this.warehouseId, warehouseAvailabilityDto.warehouseId);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, estimatedTotalCost, estimatedUnitCost, internalWarehouseId, lastModified, locations, quantityAvailable, quantityAvailableForShipment, quantityNotAvailable, quantityOnHand, quantityPurchaseOrders, warehouseId);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WarehouseAvailabilityDto {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    estimatedTotalCost: ").append(toIndentedString(estimatedTotalCost)).append("\n");
    sb.append("    estimatedUnitCost: ").append(toIndentedString(estimatedUnitCost)).append("\n");
    sb.append("    internalWarehouseId: ").append(toIndentedString(internalWarehouseId)).append("\n");
    sb.append("    lastModified: ").append(toIndentedString(lastModified)).append("\n");
    sb.append("    locations: ").append(toIndentedString(locations)).append("\n");
    sb.append("    quantityAvailable: ").append(toIndentedString(quantityAvailable)).append("\n");
    sb.append("    quantityAvailableForShipment: ").append(toIndentedString(quantityAvailableForShipment)).append("\n");
    sb.append("    quantityNotAvailable: ").append(toIndentedString(quantityNotAvailable)).append("\n");
    sb.append("    quantityOnHand: ").append(toIndentedString(quantityOnHand)).append("\n");
    sb.append("    quantityPurchaseOrders: ").append(toIndentedString(quantityPurchaseOrders)).append("\n");
    sb.append("    warehouseId: ").append(toIndentedString(warehouseId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("description");
    openapiFields.add("estimatedTotalCost");
    openapiFields.add("estimatedUnitCost");
    openapiFields.add("internalWarehouseId");
    openapiFields.add("lastModified");
    openapiFields.add("locations");
    openapiFields.add("quantityAvailable");
    openapiFields.add("quantityAvailableForShipment");
    openapiFields.add("quantityNotAvailable");
    openapiFields.add("quantityOnHand");
    openapiFields.add("quantityPurchaseOrders");
    openapiFields.add("warehouseId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to WarehouseAvailabilityDto
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WarehouseAvailabilityDto.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WarehouseAvailabilityDto is not found in the empty JSON string", WarehouseAvailabilityDto.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WarehouseAvailabilityDto.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WarehouseAvailabilityDto` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if (jsonObj.get("locations") != null && !jsonObj.get("locations").isJsonNull()) {
        JsonArray jsonArraylocations = jsonObj.getAsJsonArray("locations");
        if (jsonArraylocations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("locations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `locations` to be an array in the JSON string but got `%s`", jsonObj.get("locations").toString()));
          }

          // validate the optional field `locations` (array)
          for (int i = 0; i < jsonArraylocations.size(); i++) {
            LocationAvailabilityDto.validateJsonElement(jsonArraylocations.get(i));
          };
        }
      }
      if ((jsonObj.get("warehouseId") != null && !jsonObj.get("warehouseId").isJsonNull()) && !jsonObj.get("warehouseId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `warehouseId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("warehouseId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WarehouseAvailabilityDto.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WarehouseAvailabilityDto' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WarehouseAvailabilityDto> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WarehouseAvailabilityDto.class));

       return (TypeAdapter<T>) new TypeAdapter<WarehouseAvailabilityDto>() {
           @Override
           public void write(JsonWriter out, WarehouseAvailabilityDto value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WarehouseAvailabilityDto read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of WarehouseAvailabilityDto given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of WarehouseAvailabilityDto
   * @throws IOException if the JSON string is invalid with respect to WarehouseAvailabilityDto
   */
  public static WarehouseAvailabilityDto fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WarehouseAvailabilityDto.class);
  }

  /**
   * Convert an instance of WarehouseAvailabilityDto to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

