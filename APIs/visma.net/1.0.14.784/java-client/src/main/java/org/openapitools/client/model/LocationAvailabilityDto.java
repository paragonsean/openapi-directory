/*
 * Visma.net.ERP.SalesOrders.Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.14.784
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * LocationAvailabilityDto
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:18:31.300103-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LocationAvailabilityDto {
  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_INTERNAL_LOCATION_ID = "internalLocationId";
  @SerializedName(SERIALIZED_NAME_INTERNAL_LOCATION_ID)
  private Integer internalLocationId;

  public static final String SERIALIZED_NAME_LAST_MODIFIED = "lastModified";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED)
  private OffsetDateTime lastModified;

  public static final String SERIALIZED_NAME_LOCATION_ID = "locationId";
  @SerializedName(SERIALIZED_NAME_LOCATION_ID)
  private String locationId;

  public static final String SERIALIZED_NAME_QUANTITY_AVAILABLE = "quantityAvailable";
  @SerializedName(SERIALIZED_NAME_QUANTITY_AVAILABLE)
  private Double quantityAvailable;

  public static final String SERIALIZED_NAME_QUANTITY_AVAILABLE_FOR_SHIPMENT = "quantityAvailableForShipment";
  @SerializedName(SERIALIZED_NAME_QUANTITY_AVAILABLE_FOR_SHIPMENT)
  private Double quantityAvailableForShipment;

  public static final String SERIALIZED_NAME_QUANTITY_NOT_AVAILABLE = "quantityNotAvailable";
  @SerializedName(SERIALIZED_NAME_QUANTITY_NOT_AVAILABLE)
  private Double quantityNotAvailable;

  public static final String SERIALIZED_NAME_QUANTITY_ON_HAND = "quantityOnHand";
  @SerializedName(SERIALIZED_NAME_QUANTITY_ON_HAND)
  private Double quantityOnHand;

  public static final String SERIALIZED_NAME_QUANTITY_PURCHASE_ORDERS = "quantityPurchaseOrders";
  @SerializedName(SERIALIZED_NAME_QUANTITY_PURCHASE_ORDERS)
  private Double quantityPurchaseOrders;

  public LocationAvailabilityDto() {
  }

  public LocationAvailabilityDto description(String description) {
    this.description = description;
    return this;
  }

  /**
   * The description of the location
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public LocationAvailabilityDto internalLocationId(Integer internalLocationId) {
    this.internalLocationId = internalLocationId;
    return this;
  }

  /**
   * The internal id used by the sytem for this location
   * @return internalLocationId
   */
  @javax.annotation.Nullable
  public Integer getInternalLocationId() {
    return internalLocationId;
  }

  public void setInternalLocationId(Integer internalLocationId) {
    this.internalLocationId = internalLocationId;
  }


  public LocationAvailabilityDto lastModified(OffsetDateTime lastModified) {
    this.lastModified = lastModified;
    return this;
  }

  /**
   * Date and time this entry for this location was modified  Unless a specific time zone offset is included (e.g. &#39;2012-12-24T12:15:14+02:00&#39;), the date is considered to be in the UTC time zone.
   * @return lastModified
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastModified() {
    return lastModified;
  }

  public void setLastModified(OffsetDateTime lastModified) {
    this.lastModified = lastModified;
  }


  public LocationAvailabilityDto locationId(String locationId) {
    this.locationId = locationId;
    return this;
  }

  /**
   * The location id (LocationCd) for this location
   * @return locationId
   */
  @javax.annotation.Nullable
  public String getLocationId() {
    return locationId;
  }

  public void setLocationId(String locationId) {
    this.locationId = locationId;
  }


  public LocationAvailabilityDto quantityAvailable(Double quantityAvailable) {
    this.quantityAvailable = quantityAvailable;
    return this;
  }

  /**
   * You can configure the way this estimated quantity is calculated by using availability  calculation rules. The available quantity may include anticipated transactions and therefore  may be less than or greater than the QuantityOnHand. Anticipated transactions correspond  to the documents and transactions that have been entered in the system but not yet  processed to the end.  In the availability calculation settings of an item class, you specify which anticipated  transactions affect the available quantity. Thus, the available quantity may include  goods on purchase orders and exclude the goods allocated for sales orders. You can use  the available quantity as an indicator of demand.  Note: For quantities on warehouse location level, only quantities added specifically for the location are taken into consideration in quantityAvailable
   * @return quantityAvailable
   */
  @javax.annotation.Nullable
  public Double getQuantityAvailable() {
    return quantityAvailable;
  }

  public void setQuantityAvailable(Double quantityAvailable) {
    this.quantityAvailable = quantityAvailable;
  }


  public LocationAvailabilityDto quantityAvailableForShipment(Double quantityAvailableForShipment) {
    this.quantityAvailableForShipment = quantityAvailableForShipment;
    return this;
  }

  /**
   * Estimated quantity calculated by using the following formula: the QuantityOnHand minus the quantity on unreleased inventory  issues, minus the quantity allocated for shipping. Thus, the QuantityAvailableForShipment can be less than the QuantityOnHand.  Note: For quantities on warehouse location level, only quantities added specifically for the location are taken into consideration in quantityAvailableForShipment
   * @return quantityAvailableForShipment
   */
  @javax.annotation.Nullable
  public Double getQuantityAvailableForShipment() {
    return quantityAvailableForShipment;
  }

  public void setQuantityAvailableForShipment(Double quantityAvailableForShipment) {
    this.quantityAvailableForShipment = quantityAvailableForShipment;
  }


  public LocationAvailabilityDto quantityNotAvailable(Double quantityNotAvailable) {
    this.quantityNotAvailable = quantityNotAvailable;
    return this;
  }

  /**
   * The quantity stored at locations not included in the availability calculation.  For each warehouse location, the &#39;Include in Qty. Available&#39; check box on the  Warehouses(IN204000) screen defines whether the quantity of items stored at this  location is included in the quantity of available items.
   * @return quantityNotAvailable
   */
  @javax.annotation.Nullable
  public Double getQuantityNotAvailable() {
    return quantityNotAvailable;
  }

  public void setQuantityNotAvailable(Double quantityNotAvailable) {
    this.quantityNotAvailable = quantityNotAvailable;
  }


  public LocationAvailabilityDto quantityOnHand(Double quantityOnHand) {
    this.quantityOnHand = quantityOnHand;
    return this;
  }

  /**
   * Physical quantity on-hand of items in the specific location
   * @return quantityOnHand
   */
  @javax.annotation.Nullable
  public Double getQuantityOnHand() {
    return quantityOnHand;
  }

  public void setQuantityOnHand(Double quantityOnHand) {
    this.quantityOnHand = quantityOnHand;
  }


  public LocationAvailabilityDto quantityPurchaseOrders(Double quantityPurchaseOrders) {
    this.quantityPurchaseOrders = quantityPurchaseOrders;
    return this;
  }

  /**
   * The quantity of the inventory item included in open purchase orders.  Note: For quantities on warehouse location level, only quantities added specifically for the location are taken into consideration
   * @return quantityPurchaseOrders
   */
  @javax.annotation.Nullable
  public Double getQuantityPurchaseOrders() {
    return quantityPurchaseOrders;
  }

  public void setQuantityPurchaseOrders(Double quantityPurchaseOrders) {
    this.quantityPurchaseOrders = quantityPurchaseOrders;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LocationAvailabilityDto locationAvailabilityDto = (LocationAvailabilityDto) o;
    return Objects.equals(this.description, locationAvailabilityDto.description) &&
        Objects.equals(this.internalLocationId, locationAvailabilityDto.internalLocationId) &&
        Objects.equals(this.lastModified, locationAvailabilityDto.lastModified) &&
        Objects.equals(this.locationId, locationAvailabilityDto.locationId) &&
        Objects.equals(this.quantityAvailable, locationAvailabilityDto.quantityAvailable) &&
        Objects.equals(this.quantityAvailableForShipment, locationAvailabilityDto.quantityAvailableForShipment) &&
        Objects.equals(this.quantityNotAvailable, locationAvailabilityDto.quantityNotAvailable) &&
        Objects.equals(this.quantityOnHand, locationAvailabilityDto.quantityOnHand) &&
        Objects.equals(this.quantityPurchaseOrders, locationAvailabilityDto.quantityPurchaseOrders);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, internalLocationId, lastModified, locationId, quantityAvailable, quantityAvailableForShipment, quantityNotAvailable, quantityOnHand, quantityPurchaseOrders);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LocationAvailabilityDto {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    internalLocationId: ").append(toIndentedString(internalLocationId)).append("\n");
    sb.append("    lastModified: ").append(toIndentedString(lastModified)).append("\n");
    sb.append("    locationId: ").append(toIndentedString(locationId)).append("\n");
    sb.append("    quantityAvailable: ").append(toIndentedString(quantityAvailable)).append("\n");
    sb.append("    quantityAvailableForShipment: ").append(toIndentedString(quantityAvailableForShipment)).append("\n");
    sb.append("    quantityNotAvailable: ").append(toIndentedString(quantityNotAvailable)).append("\n");
    sb.append("    quantityOnHand: ").append(toIndentedString(quantityOnHand)).append("\n");
    sb.append("    quantityPurchaseOrders: ").append(toIndentedString(quantityPurchaseOrders)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("description");
    openapiFields.add("internalLocationId");
    openapiFields.add("lastModified");
    openapiFields.add("locationId");
    openapiFields.add("quantityAvailable");
    openapiFields.add("quantityAvailableForShipment");
    openapiFields.add("quantityNotAvailable");
    openapiFields.add("quantityOnHand");
    openapiFields.add("quantityPurchaseOrders");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LocationAvailabilityDto
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LocationAvailabilityDto.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LocationAvailabilityDto is not found in the empty JSON string", LocationAvailabilityDto.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LocationAvailabilityDto.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LocationAvailabilityDto` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("locationId") != null && !jsonObj.get("locationId").isJsonNull()) && !jsonObj.get("locationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `locationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("locationId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LocationAvailabilityDto.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LocationAvailabilityDto' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LocationAvailabilityDto> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LocationAvailabilityDto.class));

       return (TypeAdapter<T>) new TypeAdapter<LocationAvailabilityDto>() {
           @Override
           public void write(JsonWriter out, LocationAvailabilityDto value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LocationAvailabilityDto read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LocationAvailabilityDto given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LocationAvailabilityDto
   * @throws IOException if the JSON string is invalid with respect to LocationAvailabilityDto
   */
  public static LocationAvailabilityDto fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LocationAvailabilityDto.class);
  }

  /**
   * Convert an instance of LocationAvailabilityDto to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

