/*
 * DaniWeb Connect API
 * User Recommendation Engine and Chat Network
 *
 * The version of the OpenAPI document: 4
 * Contact: dani@daniwebmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.EndpointGetUsers;
import org.openapitools.client.model.EndpointGetUsersID;
import org.openapitools.client.model.EndpointGetUsersIDGroups;
import org.openapitools.client.model.EndpointGetUsersIDGroupsMessages;
import org.openapitools.client.model.EndpointGetUsersIDMetadata;
import org.openapitools.client.model.EndpointGetUsersIDMetadataCollections;
import org.openapitools.client.model.EndpointGetUsersIDPositions;
import org.openapitools.client.model.EndpointGetUsersIDSynergies;
import org.openapitools.client.model.EndpointGetUsersNearby;
import org.openapitools.client.model.EndpointPatchUsers;
import org.openapitools.client.model.EndpointPatchUsersIDSynergies;
import org.openapitools.client.model.EndpointPostUsersIDMessages;
import org.openapitools.client.model.EndpointPostUsersIDMetadata;
import org.openapitools.client.model.EndpointPostUsersInvites;
import org.openapitools.client.model.EndpointPostUsersMetadataFilters;
import org.openapitools.client.model.EndpointPostUsersSearches;
import java.io.File;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UsersApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public UsersApi() {
        this(Configuration.getDefaultApiClient());
    }

    public UsersApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for usersGet
     * @param filter  (optional, default to connections)
     * @param orderBy  (optional, default to id)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersGetCall(String filter, String orderBy, Boolean bubbled, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (orderBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order_by", orderBy));
        }

        if (bubbled != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bubbled", bubbled));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersGetValidateBeforeCall(String filter, String orderBy, Boolean bubbled, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        return usersGetCall(filter, orderBy, bubbled, offset, limit, _callback);

    }

    /**
     * 
     * Fetch an array of users that you&#39;ve been matched with, connected with, skipped, or muted. You can only retrieve users existing within the current access token&#39;s bubble. This report may be limited to the last ~500-1000 users you&#39;ve communicated with within the access token&#39;s bubble. Matches are always ordered by synergy, and the order_by parameter is ignored. You can only retrieve bubbled users when retrieving matches, and the bubbled parameter is ignored otherwise. Your 100 best algorithmic matches are based on: Complementary data submitted to Profiles, CVs, and Metadata; Complementary data acquired from third-parties; Location information; Many behavioral data points, such as how responsive users are to connections; Degrees of separation (mutual connections); etc. You may connect with 3 of these algorithmic matches per day for free. However, new members are allowed a grace period of additional daily matches. Each time you choose to meet or mute one of your algorithmic matches, a new match is introduced.
     * @param filter  (optional, default to connections)
     * @param orderBy  (optional, default to id)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return EndpointGetUsers
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsers usersGet(String filter, String orderBy, Boolean bubbled, Integer offset, Integer limit) throws ApiException {
        ApiResponse<EndpointGetUsers> localVarResp = usersGetWithHttpInfo(filter, orderBy, bubbled, offset, limit);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetch an array of users that you&#39;ve been matched with, connected with, skipped, or muted. You can only retrieve users existing within the current access token&#39;s bubble. This report may be limited to the last ~500-1000 users you&#39;ve communicated with within the access token&#39;s bubble. Matches are always ordered by synergy, and the order_by parameter is ignored. You can only retrieve bubbled users when retrieving matches, and the bubbled parameter is ignored otherwise. Your 100 best algorithmic matches are based on: Complementary data submitted to Profiles, CVs, and Metadata; Complementary data acquired from third-parties; Location information; Many behavioral data points, such as how responsive users are to connections; Degrees of separation (mutual connections); etc. You may connect with 3 of these algorithmic matches per day for free. However, new members are allowed a grace period of additional daily matches. Each time you choose to meet or mute one of your algorithmic matches, a new match is introduced.
     * @param filter  (optional, default to connections)
     * @param orderBy  (optional, default to id)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return ApiResponse&lt;EndpointGetUsers&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsers> usersGetWithHttpInfo(String filter, String orderBy, Boolean bubbled, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = usersGetValidateBeforeCall(filter, orderBy, bubbled, offset, limit, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsers>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetch an array of users that you&#39;ve been matched with, connected with, skipped, or muted. You can only retrieve users existing within the current access token&#39;s bubble. This report may be limited to the last ~500-1000 users you&#39;ve communicated with within the access token&#39;s bubble. Matches are always ordered by synergy, and the order_by parameter is ignored. You can only retrieve bubbled users when retrieving matches, and the bubbled parameter is ignored otherwise. Your 100 best algorithmic matches are based on: Complementary data submitted to Profiles, CVs, and Metadata; Complementary data acquired from third-parties; Location information; Many behavioral data points, such as how responsive users are to connections; Degrees of separation (mutual connections); etc. You may connect with 3 of these algorithmic matches per day for free. However, new members are allowed a grace period of additional daily matches. Each time you choose to meet or mute one of your algorithmic matches, a new match is introduced.
     * @param filter  (optional, default to connections)
     * @param orderBy  (optional, default to id)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersGetAsync(String filter, String orderBy, Boolean bubbled, Integer offset, Integer limit, final ApiCallback<EndpointGetUsers> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersGetValidateBeforeCall(filter, orderBy, bubbled, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsers>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersGet_0
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersGet_0Call(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/~";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersGet_0ValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return usersGet_0Call(_callback);

    }

    /**
     * 
     * Retrieve the currently OAuth&#39;ed end-user, based on the access token being used, including private information and settings such as their email address.
     * @return EndpointGetUsers
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsers usersGet_0() throws ApiException {
        ApiResponse<EndpointGetUsers> localVarResp = usersGet_0WithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the currently OAuth&#39;ed end-user, based on the access token being used, including private information and settings such as their email address.
     * @return ApiResponse&lt;EndpointGetUsers&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsers> usersGet_0WithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = usersGet_0ValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<EndpointGetUsers>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the currently OAuth&#39;ed end-user, based on the access token being used, including private information and settings such as their email address.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersGet_0Async(final ApiCallback<EndpointGetUsers> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersGet_0ValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsers>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDGetCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ID)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDGetValidateBeforeCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDGet(Async)");
        }

        return usersIDGetCall(ID, _callback);

    }

    /**
     * 
     * Fetch an array of users. You can only retrieve users existing within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return EndpointGetUsersID
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersID usersIDGet(List<Integer> ID) throws ApiException {
        ApiResponse<EndpointGetUsersID> localVarResp = usersIDGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetch an array of users. You can only retrieve users existing within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetUsersID&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersID> usersIDGetWithHttpInfo(List<Integer> ID) throws ApiException {
        okhttp3.Call localVarCall = usersIDGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersID>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetch an array of users. You can only retrieve users existing within the current access token&#39;s bubble.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDGetAsync(List<Integer> ID, final ApiCallback<EndpointGetUsersID> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersID>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDGroupsGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDGroupsGetCall(Integer ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/groups"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDGroupsGetValidateBeforeCall(Integer ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDGroupsGet(Async)");
        }

        return usersIDGroupsGetCall(ID, _callback);

    }

    /**
     * 
     * You can only retrieve groups that were created by users existing within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return EndpointGetUsersIDGroups
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersIDGroups usersIDGroupsGet(Integer ID) throws ApiException {
        ApiResponse<EndpointGetUsersIDGroups> localVarResp = usersIDGroupsGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * You can only retrieve groups that were created by users existing within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetUsersIDGroups&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersIDGroups> usersIDGroupsGetWithHttpInfo(Integer ID) throws ApiException {
        okhttp3.Call localVarCall = usersIDGroupsGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDGroups>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * You can only retrieve groups that were created by users existing within the current access token&#39;s bubble.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDGroupsGetAsync(Integer ID, final ApiCallback<EndpointGetUsersIDGroups> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDGroupsGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDGroups>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDGroupsMessagesGet
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDGroupsMessagesGetCall(Integer ID, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/groups/messages"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDGroupsMessagesGetValidateBeforeCall(Integer ID, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDGroupsMessagesGet(Async)");
        }

        return usersIDGroupsMessagesGetCall(ID, offset, limit, _callback);

    }

    /**
     * 
     * Paginated transcript of group messages authored by an individual user who exists within the current access token&#39;s bubble. Messages are sorted oldest to newest.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return EndpointGetUsersIDGroupsMessages
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersIDGroupsMessages usersIDGroupsMessagesGet(Integer ID, Integer offset, Integer limit) throws ApiException {
        ApiResponse<EndpointGetUsersIDGroupsMessages> localVarResp = usersIDGroupsMessagesGetWithHttpInfo(ID, offset, limit);
        return localVarResp.getData();
    }

    /**
     * 
     * Paginated transcript of group messages authored by an individual user who exists within the current access token&#39;s bubble. Messages are sorted oldest to newest.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return ApiResponse&lt;EndpointGetUsersIDGroupsMessages&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersIDGroupsMessages> usersIDGroupsMessagesGetWithHttpInfo(Integer ID, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = usersIDGroupsMessagesGetValidateBeforeCall(ID, offset, limit, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDGroupsMessages>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Paginated transcript of group messages authored by an individual user who exists within the current access token&#39;s bubble. Messages are sorted oldest to newest.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDGroupsMessagesGetAsync(Integer ID, Integer offset, Integer limit, final ApiCallback<EndpointGetUsersIDGroupsMessages> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDGroupsMessagesGetValidateBeforeCall(ID, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDGroupsMessages>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDMessagesPost
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @param textRaw  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMessagesPostCall(Integer ID, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, String textRaw, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/messages"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (bubbled != null) {
            localVarFormParams.put("bubbled", bubbled);
        }

        if (metadata0Key != null) {
            localVarFormParams.put("metadata_0_key", metadata0Key);
        }

        if (metadata0Privacy != null) {
            localVarFormParams.put("metadata_0_privacy", metadata0Privacy);
        }

        if (metadata0Values != null) {
            localVarFormParams.put("metadata_0_values[]", metadata0Values);
        }

        if (metadata1Key != null) {
            localVarFormParams.put("metadata_1_key", metadata1Key);
        }

        if (metadata1Privacy != null) {
            localVarFormParams.put("metadata_1_privacy", metadata1Privacy);
        }

        if (metadata1Values != null) {
            localVarFormParams.put("metadata_1_values[]", metadata1Values);
        }

        if (metadata2Key != null) {
            localVarFormParams.put("metadata_2_key", metadata2Key);
        }

        if (metadata2Privacy != null) {
            localVarFormParams.put("metadata_2_privacy", metadata2Privacy);
        }

        if (metadata2Values != null) {
            localVarFormParams.put("metadata_2_values[]", metadata2Values);
        }

        if (textEmoticons != null) {
            localVarFormParams.put("text_emoticons", textEmoticons);
        }

        if (textRaw != null) {
            localVarFormParams.put("text_raw", textRaw);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDMessagesPostValidateBeforeCall(Integer ID, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, String textRaw, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDMessagesPost(Async)");
        }

        return usersIDMessagesPostCall(ID, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons, textRaw, _callback);

    }

    /**
     * 
     * Initiate a conversation with a user who exists within the current access token&#39;s bubble by sending them an introductory message. If you aren&#39;t already in a conversation with them, this endpoint meets them first, and then sends the message. Note that if you aren&#39;t in an existing conversation, you still must meet the criteria to meet them, meaning the user must currently be free for you to meet. You will receive an error message unless it is currently free for you to meet the user. You can use the users/{:IDS}/synergies endpoint to first determine if the user isn&#39;t already in a conversation with you and is free for you to meet and, if they aren&#39;t, how to pay to meet them. If you don&#39;t specify a message, it defaults to your custom introductory message defined in your settings.
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @param textRaw  (optional)
     * @return EndpointPostUsersIDMessages
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostUsersIDMessages usersIDMessagesPost(Integer ID, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, String textRaw) throws ApiException {
        ApiResponse<EndpointPostUsersIDMessages> localVarResp = usersIDMessagesPostWithHttpInfo(ID, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons, textRaw);
        return localVarResp.getData();
    }

    /**
     * 
     * Initiate a conversation with a user who exists within the current access token&#39;s bubble by sending them an introductory message. If you aren&#39;t already in a conversation with them, this endpoint meets them first, and then sends the message. Note that if you aren&#39;t in an existing conversation, you still must meet the criteria to meet them, meaning the user must currently be free for you to meet. You will receive an error message unless it is currently free for you to meet the user. You can use the users/{:IDS}/synergies endpoint to first determine if the user isn&#39;t already in a conversation with you and is free for you to meet and, if they aren&#39;t, how to pay to meet them. If you don&#39;t specify a message, it defaults to your custom introductory message defined in your settings.
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @param textRaw  (optional)
     * @return ApiResponse&lt;EndpointPostUsersIDMessages&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostUsersIDMessages> usersIDMessagesPostWithHttpInfo(Integer ID, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, String textRaw) throws ApiException {
        okhttp3.Call localVarCall = usersIDMessagesPostValidateBeforeCall(ID, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons, textRaw, null);
        Type localVarReturnType = new TypeToken<EndpointPostUsersIDMessages>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Initiate a conversation with a user who exists within the current access token&#39;s bubble by sending them an introductory message. If you aren&#39;t already in a conversation with them, this endpoint meets them first, and then sends the message. Note that if you aren&#39;t in an existing conversation, you still must meet the criteria to meet them, meaning the user must currently be free for you to meet. You will receive an error message unless it is currently free for you to meet the user. You can use the users/{:IDS}/synergies endpoint to first determine if the user isn&#39;t already in a conversation with you and is free for you to meet and, if they aren&#39;t, how to pay to meet them. If you don&#39;t specify a message, it defaults to your custom introductory message defined in your settings.
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @param textRaw  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMessagesPostAsync(Integer ID, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, String textRaw, final ApiCallback<EndpointPostUsersIDMessages> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDMessagesPostValidateBeforeCall(ID, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons, textRaw, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostUsersIDMessages>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDMetadataCollectionsGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMetadataCollectionsGetCall(Integer ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/metadata/collections"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDMetadataCollectionsGetValidateBeforeCall(Integer ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDMetadataCollectionsGet(Async)");
        }

        return usersIDMetadataCollectionsGetCall(ID, _callback);

    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token&#39;s bubble based on preknown metadata key/value pairs. Metadata will be grouped by key.
     * @param ID  (required)
     * @return EndpointGetUsersIDMetadataCollections
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersIDMetadataCollections usersIDMetadataCollectionsGet(Integer ID) throws ApiException {
        ApiResponse<EndpointGetUsersIDMetadataCollections> localVarResp = usersIDMetadataCollectionsGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token&#39;s bubble based on preknown metadata key/value pairs. Metadata will be grouped by key.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetUsersIDMetadataCollections&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersIDMetadataCollections> usersIDMetadataCollectionsGetWithHttpInfo(Integer ID) throws ApiException {
        okhttp3.Call localVarCall = usersIDMetadataCollectionsGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDMetadataCollections>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token&#39;s bubble based on preknown metadata key/value pairs. Metadata will be grouped by key.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMetadataCollectionsGetAsync(Integer ID, final ApiCallback<EndpointGetUsersIDMetadataCollections> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDMetadataCollectionsGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDMetadataCollections>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDMetadataGet
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMetadataGetCall(Integer ID, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/metadata"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDMetadataGetValidateBeforeCall(Integer ID, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDMetadataGet(Async)");
        }

        return usersIDMetadataGetCall(ID, offset, limit, _callback);

    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token&#39;s bubble based on preknown metadata key/value pairs.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return EndpointGetUsersIDMetadata
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersIDMetadata usersIDMetadataGet(Integer ID, Integer offset, Integer limit) throws ApiException {
        ApiResponse<EndpointGetUsersIDMetadata> localVarResp = usersIDMetadataGetWithHttpInfo(ID, offset, limit);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token&#39;s bubble based on preknown metadata key/value pairs.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return ApiResponse&lt;EndpointGetUsersIDMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersIDMetadata> usersIDMetadataGetWithHttpInfo(Integer ID, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = usersIDMetadataGetValidateBeforeCall(ID, offset, limit, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve all key/value pairs attached to the current user that you have access to, so long as the user exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. However, you can always use the /users/metadata/filters endpoint to filter across all users, including those that are unmatched, existing within the current access token&#39;s bubble based on preknown metadata key/value pairs.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMetadataGetAsync(Integer ID, Integer offset, Integer limit, final ApiCallback<EndpointGetUsersIDMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDMetadataGetValidateBeforeCall(ID, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDMetadataPost
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMetadataPostCall(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/metadata"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (metadata0Key != null) {
            localVarFormParams.put("metadata_0_key", metadata0Key);
        }

        if (metadata0Privacy != null) {
            localVarFormParams.put("metadata_0_privacy", metadata0Privacy);
        }

        if (metadata0Values != null) {
            localVarFormParams.put("metadata_0_values[]", metadata0Values);
        }

        if (metadata1Key != null) {
            localVarFormParams.put("metadata_1_key", metadata1Key);
        }

        if (metadata1Privacy != null) {
            localVarFormParams.put("metadata_1_privacy", metadata1Privacy);
        }

        if (metadata1Values != null) {
            localVarFormParams.put("metadata_1_values[]", metadata1Values);
        }

        if (metadata2Key != null) {
            localVarFormParams.put("metadata_2_key", metadata2Key);
        }

        if (metadata2Privacy != null) {
            localVarFormParams.put("metadata_2_privacy", metadata2Privacy);
        }

        if (metadata2Values != null) {
            localVarFormParams.put("metadata_2_values[]", metadata2Values);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDMetadataPostValidateBeforeCall(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDMetadataPost(Async)");
        }

        return usersIDMetadataPostCall(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, _callback);

    }

    /**
     * 
     * Attach one-to-many key/value pairs of metadata to a user, so long as the user exists within the current access token&#39;s bubble. You can set one key at a time, with one or many values. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by anyone using an access token which grants them access to the user; Bubbled metadata by anyone using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user; Private metadata by you, so long as you are using an access token existing within the current bubble.
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @return EndpointPostUsersIDMetadata
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostUsersIDMetadata usersIDMetadataPost(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values) throws ApiException {
        ApiResponse<EndpointPostUsersIDMetadata> localVarResp = usersIDMetadataPostWithHttpInfo(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values);
        return localVarResp.getData();
    }

    /**
     * 
     * Attach one-to-many key/value pairs of metadata to a user, so long as the user exists within the current access token&#39;s bubble. You can set one key at a time, with one or many values. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by anyone using an access token which grants them access to the user; Bubbled metadata by anyone using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user; Private metadata by you, so long as you are using an access token existing within the current bubble.
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @return ApiResponse&lt;EndpointPostUsersIDMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostUsersIDMetadata> usersIDMetadataPostWithHttpInfo(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values) throws ApiException {
        okhttp3.Call localVarCall = usersIDMetadataPostValidateBeforeCall(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, null);
        Type localVarReturnType = new TypeToken<EndpointPostUsersIDMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Attach one-to-many key/value pairs of metadata to a user, so long as the user exists within the current access token&#39;s bubble. You can set one key at a time, with one or many values. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by anyone using an access token which grants them access to the user; Bubbled metadata by anyone using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user; Private metadata by you, so long as you are using an access token existing within the current bubble.
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDMetadataPostAsync(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, final ApiCallback<EndpointPostUsersIDMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDMetadataPostValidateBeforeCall(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostUsersIDMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDPositionsGet
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDPositionsGetCall(Integer ID, Boolean bubbled, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/positions"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (bubbled != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bubbled", bubbled));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDPositionsGetValidateBeforeCall(Integer ID, Boolean bubbled, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDPositionsGet(Async)");
        }

        return usersIDPositionsGetCall(ID, bubbled, _callback);

    }

    /**
     * 
     * Retrieve the CV of a user who exists within the current access token&#39;s bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. You can only record CV data to your own account. However, any app that you have OAuth&#39;ed against can do so. By default, you will receive CV data that all apps have recorded for the user. Optionally, you can choose to only receive data that the current access token&#39;s bubble has recorded.
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @return EndpointGetUsersIDPositions
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersIDPositions usersIDPositionsGet(Integer ID, Boolean bubbled) throws ApiException {
        ApiResponse<EndpointGetUsersIDPositions> localVarResp = usersIDPositionsGetWithHttpInfo(ID, bubbled);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the CV of a user who exists within the current access token&#39;s bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. You can only record CV data to your own account. However, any app that you have OAuth&#39;ed against can do so. By default, you will receive CV data that all apps have recorded for the user. Optionally, you can choose to only receive data that the current access token&#39;s bubble has recorded.
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @return ApiResponse&lt;EndpointGetUsersIDPositions&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersIDPositions> usersIDPositionsGetWithHttpInfo(Integer ID, Boolean bubbled) throws ApiException {
        okhttp3.Call localVarCall = usersIDPositionsGetValidateBeforeCall(ID, bubbled, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDPositions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the CV of a user who exists within the current access token&#39;s bubble. You will receive an error message unless either the current access token is bubbled, the user is an algorithmic match for you and you have not reached your quota of new introductions for the day, or you have paid to meet them. You can only record CV data to your own account. However, any app that you have OAuth&#39;ed against can do so. By default, you will receive CV data that all apps have recorded for the user. Optionally, you can choose to only receive data that the current access token&#39;s bubble has recorded.
     * @param ID  (required)
     * @param bubbled  (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDPositionsGetAsync(Integer ID, Boolean bubbled, final ApiCallback<EndpointGetUsersIDPositions> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDPositionsGetValidateBeforeCall(ID, bubbled, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDPositions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDSynergiesGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDSynergiesGetCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/synergies"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ID)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDSynergiesGetValidateBeforeCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDSynergiesGet(Async)");
        }

        return usersIDSynergiesGetCall(ID, _callback);

    }

    /**
     * 
     * Determine your match relationship with one or more users who exist within the current access token&#39;s bubble. Under some conditions, the price to meet the user will be $0. However, if this is not the case, the PayPal URL payment method will be provided along with the price to meet the user. The PayPal API can be leveraged to send payments programatically, provided the parameters passed in remain the same to ensure that the payment is correctly recorded. Once the payment has been recorded via PayPal IPN, the price to meet the user changes to $0. You can then call the users/{:ID}/meet endpoint to meet the user.
     * @param ID  (required)
     * @return EndpointGetUsersIDSynergies
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersIDSynergies usersIDSynergiesGet(List<Integer> ID) throws ApiException {
        ApiResponse<EndpointGetUsersIDSynergies> localVarResp = usersIDSynergiesGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * Determine your match relationship with one or more users who exist within the current access token&#39;s bubble. Under some conditions, the price to meet the user will be $0. However, if this is not the case, the PayPal URL payment method will be provided along with the price to meet the user. The PayPal API can be leveraged to send payments programatically, provided the parameters passed in remain the same to ensure that the payment is correctly recorded. Once the payment has been recorded via PayPal IPN, the price to meet the user changes to $0. You can then call the users/{:ID}/meet endpoint to meet the user.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetUsersIDSynergies&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersIDSynergies> usersIDSynergiesGetWithHttpInfo(List<Integer> ID) throws ApiException {
        okhttp3.Call localVarCall = usersIDSynergiesGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDSynergies>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Determine your match relationship with one or more users who exist within the current access token&#39;s bubble. Under some conditions, the price to meet the user will be $0. However, if this is not the case, the PayPal URL payment method will be provided along with the price to meet the user. The PayPal API can be leveraged to send payments programatically, provided the parameters passed in remain the same to ensure that the payment is correctly recorded. Once the payment has been recorded via PayPal IPN, the price to meet the user changes to $0. You can then call the users/{:ID}/meet endpoint to meet the user.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDSynergiesGetAsync(List<Integer> ID, final ApiCallback<EndpointGetUsersIDSynergies> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDSynergiesGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersIDSynergies>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIDSynergiesPatch
     * @param ID  (required)
     * @param relationshipMuted  (optional)
     * @param relationshipSkipped  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDSynergiesPatchCall(Integer ID, Boolean relationshipMuted, Boolean relationshipSkipped, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ID}/synergies"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (relationshipMuted != null) {
            localVarFormParams.put("relationship_muted", relationshipMuted);
        }

        if (relationshipSkipped != null) {
            localVarFormParams.put("relationship_skipped", relationshipSkipped);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIDSynergiesPatchValidateBeforeCall(Integer ID, Boolean relationshipMuted, Boolean relationshipSkipped, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling usersIDSynergiesPatch(Async)");
        }

        return usersIDSynergiesPatchCall(ID, relationshipMuted, relationshipSkipped, _callback);

    }

    /**
     * 
     * Skip, mute or unmute a user you&#39;ve been matched with. Skipped matches are only presented as algorithmic matches after all other candidates have been exhausted. You cannot be matched with or meet muted users. You can only skip, mute or unmute users existing within the same bubble.
     * @param ID  (required)
     * @param relationshipMuted  (optional)
     * @param relationshipSkipped  (optional)
     * @return EndpointPatchUsersIDSynergies
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPatchUsersIDSynergies usersIDSynergiesPatch(Integer ID, Boolean relationshipMuted, Boolean relationshipSkipped) throws ApiException {
        ApiResponse<EndpointPatchUsersIDSynergies> localVarResp = usersIDSynergiesPatchWithHttpInfo(ID, relationshipMuted, relationshipSkipped);
        return localVarResp.getData();
    }

    /**
     * 
     * Skip, mute or unmute a user you&#39;ve been matched with. Skipped matches are only presented as algorithmic matches after all other candidates have been exhausted. You cannot be matched with or meet muted users. You can only skip, mute or unmute users existing within the same bubble.
     * @param ID  (required)
     * @param relationshipMuted  (optional)
     * @param relationshipSkipped  (optional)
     * @return ApiResponse&lt;EndpointPatchUsersIDSynergies&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPatchUsersIDSynergies> usersIDSynergiesPatchWithHttpInfo(Integer ID, Boolean relationshipMuted, Boolean relationshipSkipped) throws ApiException {
        okhttp3.Call localVarCall = usersIDSynergiesPatchValidateBeforeCall(ID, relationshipMuted, relationshipSkipped, null);
        Type localVarReturnType = new TypeToken<EndpointPatchUsersIDSynergies>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Skip, mute or unmute a user you&#39;ve been matched with. Skipped matches are only presented as algorithmic matches after all other candidates have been exhausted. You cannot be matched with or meet muted users. You can only skip, mute or unmute users existing within the same bubble.
     * @param ID  (required)
     * @param relationshipMuted  (optional)
     * @param relationshipSkipped  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIDSynergiesPatchAsync(Integer ID, Boolean relationshipMuted, Boolean relationshipSkipped, final ApiCallback<EndpointPatchUsersIDSynergies> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIDSynergiesPatchValidateBeforeCall(ID, relationshipMuted, relationshipSkipped, _callback);
        Type localVarReturnType = new TypeToken<EndpointPatchUsersIDSynergies>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersInvitesPost
     * @param csv  (optional)
     * @param emails  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersInvitesPostCall(File csv, List<String> emails, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/invites";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (csv != null) {
            localVarFormParams.put("csv", csv);
        }

        if (emails != null) {
            localVarFormParams.put("emails[]", emails);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersInvitesPostValidateBeforeCall(File csv, List<String> emails, final ApiCallback _callback) throws ApiException {
        return usersInvitesPostCall(csv, emails, _callback);

    }

    /**
     * 
     * Invite users to into your current access token&#39;s bubble by having Dazah send out email invitations on your behalf. The invitation sends users to begin the OAuth flow for the current application (based on the settings specified in the application&#39;s profile), and therefore they will be redirected to the application upon signing up / logging in. Upon doing so, if they aren&#39;t already, they will automatically be connected with you as well. If your current access token does not escape the bubble, the invitation will specify you wish to connect within the application&#39;s name. If your current access token escapes the bubble, the invitation will specify you wish to connect within Dazah. Submit either a list of emails, or a LinkedIn or Outlook CSV file. You can retrieve your LinkedIn CSV file by exporting your LinkedIn Connections at https://www.linkedin.com/people/export-settings. You can retrieve your Outlook CSV file by using the Outlook Import and Export Wizard. This endpoint buckets the invitations into four categories: Existing invites are existing users who are already connected with you within the current bubble, and are therefore not emailed; Discovered invites are existing Dazah users who are available to be connected with within the current bubble, and are therefore not emailed. Now that they have been discovered, the users/{:ID}/meet API endpoint may be used to connect with them; Invalid invites are existing Dazah users who are unavailable to be connected with, because they have deactivated accounts, are muting you, etc., and are therefore not emailed; Emailed invites are queued to receive an invitation within approximately 1 hour. Note that if you are attempting to invite an existing Dazah user who does not currently exist within your current access token&#39;s bubble, they will fall within the Discovered bucket if your current access token escapes the bubble, but will be emailed an invitation to join the application if your current access token does not escape the bubble.
     * @param csv  (optional)
     * @param emails  (optional)
     * @return EndpointPostUsersInvites
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostUsersInvites usersInvitesPost(File csv, List<String> emails) throws ApiException {
        ApiResponse<EndpointPostUsersInvites> localVarResp = usersInvitesPostWithHttpInfo(csv, emails);
        return localVarResp.getData();
    }

    /**
     * 
     * Invite users to into your current access token&#39;s bubble by having Dazah send out email invitations on your behalf. The invitation sends users to begin the OAuth flow for the current application (based on the settings specified in the application&#39;s profile), and therefore they will be redirected to the application upon signing up / logging in. Upon doing so, if they aren&#39;t already, they will automatically be connected with you as well. If your current access token does not escape the bubble, the invitation will specify you wish to connect within the application&#39;s name. If your current access token escapes the bubble, the invitation will specify you wish to connect within Dazah. Submit either a list of emails, or a LinkedIn or Outlook CSV file. You can retrieve your LinkedIn CSV file by exporting your LinkedIn Connections at https://www.linkedin.com/people/export-settings. You can retrieve your Outlook CSV file by using the Outlook Import and Export Wizard. This endpoint buckets the invitations into four categories: Existing invites are existing users who are already connected with you within the current bubble, and are therefore not emailed; Discovered invites are existing Dazah users who are available to be connected with within the current bubble, and are therefore not emailed. Now that they have been discovered, the users/{:ID}/meet API endpoint may be used to connect with them; Invalid invites are existing Dazah users who are unavailable to be connected with, because they have deactivated accounts, are muting you, etc., and are therefore not emailed; Emailed invites are queued to receive an invitation within approximately 1 hour. Note that if you are attempting to invite an existing Dazah user who does not currently exist within your current access token&#39;s bubble, they will fall within the Discovered bucket if your current access token escapes the bubble, but will be emailed an invitation to join the application if your current access token does not escape the bubble.
     * @param csv  (optional)
     * @param emails  (optional)
     * @return ApiResponse&lt;EndpointPostUsersInvites&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostUsersInvites> usersInvitesPostWithHttpInfo(File csv, List<String> emails) throws ApiException {
        okhttp3.Call localVarCall = usersInvitesPostValidateBeforeCall(csv, emails, null);
        Type localVarReturnType = new TypeToken<EndpointPostUsersInvites>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Invite users to into your current access token&#39;s bubble by having Dazah send out email invitations on your behalf. The invitation sends users to begin the OAuth flow for the current application (based on the settings specified in the application&#39;s profile), and therefore they will be redirected to the application upon signing up / logging in. Upon doing so, if they aren&#39;t already, they will automatically be connected with you as well. If your current access token does not escape the bubble, the invitation will specify you wish to connect within the application&#39;s name. If your current access token escapes the bubble, the invitation will specify you wish to connect within Dazah. Submit either a list of emails, or a LinkedIn or Outlook CSV file. You can retrieve your LinkedIn CSV file by exporting your LinkedIn Connections at https://www.linkedin.com/people/export-settings. You can retrieve your Outlook CSV file by using the Outlook Import and Export Wizard. This endpoint buckets the invitations into four categories: Existing invites are existing users who are already connected with you within the current bubble, and are therefore not emailed; Discovered invites are existing Dazah users who are available to be connected with within the current bubble, and are therefore not emailed. Now that they have been discovered, the users/{:ID}/meet API endpoint may be used to connect with them; Invalid invites are existing Dazah users who are unavailable to be connected with, because they have deactivated accounts, are muting you, etc., and are therefore not emailed; Emailed invites are queued to receive an invitation within approximately 1 hour. Note that if you are attempting to invite an existing Dazah user who does not currently exist within your current access token&#39;s bubble, they will fall within the Discovered bucket if your current access token escapes the bubble, but will be emailed an invitation to join the application if your current access token does not escape the bubble.
     * @param csv  (optional)
     * @param emails  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersInvitesPostAsync(File csv, List<String> emails, final ApiCallback<EndpointPostUsersInvites> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersInvitesPostValidateBeforeCall(csv, emails, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostUsersInvites>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersMetadataFiltersPost
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersMetadataFiltersPostCall(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/metadata/filters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarFormParams.put("limit", limit);
        }

        if (metadata0Key != null) {
            localVarFormParams.put("metadata_0_key", metadata0Key);
        }

        if (metadata0Values != null) {
            localVarFormParams.put("metadata_0_values[]", metadata0Values);
        }

        if (metadata1Key != null) {
            localVarFormParams.put("metadata_1_key", metadata1Key);
        }

        if (metadata1Values != null) {
            localVarFormParams.put("metadata_1_values[]", metadata1Values);
        }

        if (metadata2Key != null) {
            localVarFormParams.put("metadata_2_key", metadata2Key);
        }

        if (metadata2Values != null) {
            localVarFormParams.put("metadata_2_values[]", metadata2Values);
        }

        if (offset != null) {
            localVarFormParams.put("offset", offset);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersMetadataFiltersPostValidateBeforeCall(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset, final ApiCallback _callback) throws ApiException {
        return usersMetadataFiltersPostCall(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset, _callback);

    }

    /**
     * 
     * Paginated listing of users filtered by arbitrary metadata criteria. Users must match on all key/value pairs passed in. Users may only match on one value of an array passed in. However, users are sorted based on how many distinct values they match on (most matches first).
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @return EndpointPostUsersMetadataFilters
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostUsersMetadataFilters usersMetadataFiltersPost(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset) throws ApiException {
        ApiResponse<EndpointPostUsersMetadataFilters> localVarResp = usersMetadataFiltersPostWithHttpInfo(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset);
        return localVarResp.getData();
    }

    /**
     * 
     * Paginated listing of users filtered by arbitrary metadata criteria. Users must match on all key/value pairs passed in. Users may only match on one value of an array passed in. However, users are sorted based on how many distinct values they match on (most matches first).
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @return ApiResponse&lt;EndpointPostUsersMetadataFilters&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostUsersMetadataFilters> usersMetadataFiltersPostWithHttpInfo(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = usersMetadataFiltersPostValidateBeforeCall(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset, null);
        Type localVarReturnType = new TypeToken<EndpointPostUsersMetadataFilters>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Paginated listing of users filtered by arbitrary metadata criteria. Users must match on all key/value pairs passed in. Users may only match on one value of an array passed in. However, users are sorted based on how many distinct values they match on (most matches first).
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersMetadataFiltersPostAsync(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset, final ApiCallback<EndpointPostUsersMetadataFilters> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersMetadataFiltersPostValidateBeforeCall(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostUsersMetadataFilters>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersNearbyGet
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersNearbyGetCall(Float latitude, Float longitude, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/nearby";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersNearbyGetValidateBeforeCall(Float latitude, Float longitude, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        return usersNearbyGetCall(latitude, longitude, offset, limit, _callback);

    }

    /**
     * 
     * Fetch an array of users that are geographically close to a set of coordinates. You can only retrieve users existing within the current access token&#39;s bubble.
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return EndpointGetUsersNearby
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetUsersNearby usersNearbyGet(Float latitude, Float longitude, Integer offset, Integer limit) throws ApiException {
        ApiResponse<EndpointGetUsersNearby> localVarResp = usersNearbyGetWithHttpInfo(latitude, longitude, offset, limit);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetch an array of users that are geographically close to a set of coordinates. You can only retrieve users existing within the current access token&#39;s bubble.
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return ApiResponse&lt;EndpointGetUsersNearby&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetUsersNearby> usersNearbyGetWithHttpInfo(Float latitude, Float longitude, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = usersNearbyGetValidateBeforeCall(latitude, longitude, offset, limit, null);
        Type localVarReturnType = new TypeToken<EndpointGetUsersNearby>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetch an array of users that are geographically close to a set of coordinates. You can only retrieve users existing within the current access token&#39;s bubble.
     * @param latitude  (optional)
     * @param longitude  (optional)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersNearbyGetAsync(Float latitude, Float longitude, Integer offset, Integer limit, final ApiCallback<EndpointGetUsersNearby> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersNearbyGetValidateBeforeCall(latitude, longitude, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetUsersNearby>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersPatch
     * @param company  (optional)
     * @param companySize  (optional)
     * @param firstName  (optional)
     * @param goals  (optional)
     * @param headline  (optional)
     * @param industry  (optional)
     * @param introduction  (optional)
     * @param jobPosition  (optional)
     * @param lastName  (optional)
     * @param locationImportance  (optional)
     * @param matchTags  (optional)
     * @param pitch  (optional)
     * @param tags  (optional)
     * @param targetedIndustry  (optional)
     * @param url  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersPatchCall(String company, String companySize, String firstName, List<String> goals, String headline, String industry, String introduction, String jobPosition, String lastName, String locationImportance, List<String> matchTags, String pitch, List<String> tags, String targetedIndustry, String url, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/~";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (company != null) {
            localVarFormParams.put("company", company);
        }

        if (companySize != null) {
            localVarFormParams.put("company_size", companySize);
        }

        if (firstName != null) {
            localVarFormParams.put("first_name", firstName);
        }

        if (goals != null) {
            localVarFormParams.put("goals[]", goals);
        }

        if (headline != null) {
            localVarFormParams.put("headline", headline);
        }

        if (industry != null) {
            localVarFormParams.put("industry", industry);
        }

        if (introduction != null) {
            localVarFormParams.put("introduction", introduction);
        }

        if (jobPosition != null) {
            localVarFormParams.put("job_position", jobPosition);
        }

        if (lastName != null) {
            localVarFormParams.put("last_name", lastName);
        }

        if (locationImportance != null) {
            localVarFormParams.put("location_importance", locationImportance);
        }

        if (matchTags != null) {
            localVarFormParams.put("match_tags[]", matchTags);
        }

        if (pitch != null) {
            localVarFormParams.put("pitch", pitch);
        }

        if (tags != null) {
            localVarFormParams.put("tags[]", tags);
        }

        if (targetedIndustry != null) {
            localVarFormParams.put("targeted_industry", targetedIndustry);
        }

        if (url != null) {
            localVarFormParams.put("url", url);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersPatchValidateBeforeCall(String company, String companySize, String firstName, List<String> goals, String headline, String industry, String introduction, String jobPosition, String lastName, String locationImportance, List<String> matchTags, String pitch, List<String> tags, String targetedIndustry, String url, final ApiCallback _callback) throws ApiException {
        return usersPatchCall(company, companySize, firstName, goals, headline, industry, introduction, jobPosition, lastName, locationImportance, matchTags, pitch, tags, targetedIndustry, url, _callback);

    }

    /**
     * 
     * Update the OAuth&#39;ed end user&#39;s account profile. At this time, for anti-spam reasons, restrictions preclude the ability to update email address and some other settings via the API.
     * @param company  (optional)
     * @param companySize  (optional)
     * @param firstName  (optional)
     * @param goals  (optional)
     * @param headline  (optional)
     * @param industry  (optional)
     * @param introduction  (optional)
     * @param jobPosition  (optional)
     * @param lastName  (optional)
     * @param locationImportance  (optional)
     * @param matchTags  (optional)
     * @param pitch  (optional)
     * @param tags  (optional)
     * @param targetedIndustry  (optional)
     * @param url  (optional)
     * @return EndpointPatchUsers
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPatchUsers usersPatch(String company, String companySize, String firstName, List<String> goals, String headline, String industry, String introduction, String jobPosition, String lastName, String locationImportance, List<String> matchTags, String pitch, List<String> tags, String targetedIndustry, String url) throws ApiException {
        ApiResponse<EndpointPatchUsers> localVarResp = usersPatchWithHttpInfo(company, companySize, firstName, goals, headline, industry, introduction, jobPosition, lastName, locationImportance, matchTags, pitch, tags, targetedIndustry, url);
        return localVarResp.getData();
    }

    /**
     * 
     * Update the OAuth&#39;ed end user&#39;s account profile. At this time, for anti-spam reasons, restrictions preclude the ability to update email address and some other settings via the API.
     * @param company  (optional)
     * @param companySize  (optional)
     * @param firstName  (optional)
     * @param goals  (optional)
     * @param headline  (optional)
     * @param industry  (optional)
     * @param introduction  (optional)
     * @param jobPosition  (optional)
     * @param lastName  (optional)
     * @param locationImportance  (optional)
     * @param matchTags  (optional)
     * @param pitch  (optional)
     * @param tags  (optional)
     * @param targetedIndustry  (optional)
     * @param url  (optional)
     * @return ApiResponse&lt;EndpointPatchUsers&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPatchUsers> usersPatchWithHttpInfo(String company, String companySize, String firstName, List<String> goals, String headline, String industry, String introduction, String jobPosition, String lastName, String locationImportance, List<String> matchTags, String pitch, List<String> tags, String targetedIndustry, String url) throws ApiException {
        okhttp3.Call localVarCall = usersPatchValidateBeforeCall(company, companySize, firstName, goals, headline, industry, introduction, jobPosition, lastName, locationImportance, matchTags, pitch, tags, targetedIndustry, url, null);
        Type localVarReturnType = new TypeToken<EndpointPatchUsers>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Update the OAuth&#39;ed end user&#39;s account profile. At this time, for anti-spam reasons, restrictions preclude the ability to update email address and some other settings via the API.
     * @param company  (optional)
     * @param companySize  (optional)
     * @param firstName  (optional)
     * @param goals  (optional)
     * @param headline  (optional)
     * @param industry  (optional)
     * @param introduction  (optional)
     * @param jobPosition  (optional)
     * @param lastName  (optional)
     * @param locationImportance  (optional)
     * @param matchTags  (optional)
     * @param pitch  (optional)
     * @param tags  (optional)
     * @param targetedIndustry  (optional)
     * @param url  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersPatchAsync(String company, String companySize, String firstName, List<String> goals, String headline, String industry, String introduction, String jobPosition, String lastName, String locationImportance, List<String> matchTags, String pitch, List<String> tags, String targetedIndustry, String url, final ApiCallback<EndpointPatchUsers> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersPatchValidateBeforeCall(company, companySize, firstName, goals, headline, industry, introduction, jobPosition, lastName, locationImportance, matchTags, pitch, tags, targetedIndustry, url, _callback);
        Type localVarReturnType = new TypeToken<EndpointPatchUsers>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersSearchesPost
     * @param activeWithinXDays  (optional)
     * @param audienceIds  (optional)
     * @param bubbled  (optional, default to false)
     * @param excludeConnections  (optional, default to false)
     * @param excludeMatches  (optional, default to false)
     * @param excludeMuted  (optional, default to false)
     * @param excludeSkipped  (optional, default to false)
     * @param geoLatitude  (optional)
     * @param geoLongitude  (optional)
     * @param geoMilesAway  (optional)
     * @param groupId  (optional)
     * @param limit  (optional, default to 50)
     * @param locationCityQuery  (optional)
     * @param locationCityWeight  (optional)
     * @param locationCountryQuery  (optional)
     * @param locationCountryWeight  (optional)
     * @param locationRegionQuery  (optional)
     * @param locationRegionWeight  (optional)
     * @param metadata0Key  (optional)
     * @param metadata0Query  (optional)
     * @param metadata0Weight  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Query  (optional)
     * @param metadata1Weight  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Query  (optional)
     * @param metadata2Weight  (optional)
     * @param offset  (optional, default to 0)
     * @param positionOrganizationQuery  (optional)
     * @param positionOrganizationWeight  (optional)
     * @param positionRoleQuery  (optional)
     * @param positionRoleWeight  (optional)
     * @param positionSummaryQuery  (optional)
     * @param positionSummaryWeight  (optional)
     * @param profileFirstNameQuery  (optional)
     * @param profileFirstNameWeight  (optional)
     * @param profileGoalsQuery  (optional)
     * @param profileGoalsWeight  (optional)
     * @param profileHeadlineQuery  (optional)
     * @param profileHeadlineWeight  (optional)
     * @param profileIndustryQuery  (optional)
     * @param profileIndustryWeight  (optional)
     * @param profileLastNameQuery  (optional)
     * @param profileLastNameWeight  (optional)
     * @param profilePitchQuery  (optional)
     * @param profilePitchWeight  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersSearchesPostCall(Integer activeWithinXDays, List<Integer> audienceIds, Boolean bubbled, Boolean excludeConnections, Boolean excludeMatches, Boolean excludeMuted, Boolean excludeSkipped, Float geoLatitude, Float geoLongitude, Float geoMilesAway, Integer groupId, Integer limit, String locationCityQuery, Integer locationCityWeight, String locationCountryQuery, Integer locationCountryWeight, String locationRegionQuery, Integer locationRegionWeight, String metadata0Key, String metadata0Query, Integer metadata0Weight, String metadata1Key, String metadata1Query, Integer metadata1Weight, String metadata2Key, String metadata2Query, Integer metadata2Weight, Integer offset, String positionOrganizationQuery, Integer positionOrganizationWeight, String positionRoleQuery, Integer positionRoleWeight, String positionSummaryQuery, Integer positionSummaryWeight, String profileFirstNameQuery, Integer profileFirstNameWeight, String profileGoalsQuery, String profileGoalsWeight, String profileHeadlineQuery, Integer profileHeadlineWeight, String profileIndustryQuery, Integer profileIndustryWeight, String profileLastNameQuery, Integer profileLastNameWeight, String profilePitchQuery, Integer profilePitchWeight, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/searches";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (activeWithinXDays != null) {
            localVarFormParams.put("active_within_x_days", activeWithinXDays);
        }

        if (audienceIds != null) {
            localVarFormParams.put("audience_ids[]", audienceIds);
        }

        if (bubbled != null) {
            localVarFormParams.put("bubbled", bubbled);
        }

        if (excludeConnections != null) {
            localVarFormParams.put("exclude_connections", excludeConnections);
        }

        if (excludeMatches != null) {
            localVarFormParams.put("exclude_matches", excludeMatches);
        }

        if (excludeMuted != null) {
            localVarFormParams.put("exclude_muted", excludeMuted);
        }

        if (excludeSkipped != null) {
            localVarFormParams.put("exclude_skipped", excludeSkipped);
        }

        if (geoLatitude != null) {
            localVarFormParams.put("geo_latitude", geoLatitude);
        }

        if (geoLongitude != null) {
            localVarFormParams.put("geo_longitude", geoLongitude);
        }

        if (geoMilesAway != null) {
            localVarFormParams.put("geo_miles_away", geoMilesAway);
        }

        if (groupId != null) {
            localVarFormParams.put("group_id", groupId);
        }

        if (limit != null) {
            localVarFormParams.put("limit", limit);
        }

        if (locationCityQuery != null) {
            localVarFormParams.put("location_city_query", locationCityQuery);
        }

        if (locationCityWeight != null) {
            localVarFormParams.put("location_city_weight", locationCityWeight);
        }

        if (locationCountryQuery != null) {
            localVarFormParams.put("location_country_query", locationCountryQuery);
        }

        if (locationCountryWeight != null) {
            localVarFormParams.put("location_country_weight", locationCountryWeight);
        }

        if (locationRegionQuery != null) {
            localVarFormParams.put("location_region_query", locationRegionQuery);
        }

        if (locationRegionWeight != null) {
            localVarFormParams.put("location_region_weight", locationRegionWeight);
        }

        if (metadata0Key != null) {
            localVarFormParams.put("metadata_0_key", metadata0Key);
        }

        if (metadata0Query != null) {
            localVarFormParams.put("metadata_0_query", metadata0Query);
        }

        if (metadata0Weight != null) {
            localVarFormParams.put("metadata_0_weight", metadata0Weight);
        }

        if (metadata1Key != null) {
            localVarFormParams.put("metadata_1_key", metadata1Key);
        }

        if (metadata1Query != null) {
            localVarFormParams.put("metadata_1_query", metadata1Query);
        }

        if (metadata1Weight != null) {
            localVarFormParams.put("metadata_1_weight", metadata1Weight);
        }

        if (metadata2Key != null) {
            localVarFormParams.put("metadata_2_key", metadata2Key);
        }

        if (metadata2Query != null) {
            localVarFormParams.put("metadata_2_query", metadata2Query);
        }

        if (metadata2Weight != null) {
            localVarFormParams.put("metadata_2_weight", metadata2Weight);
        }

        if (offset != null) {
            localVarFormParams.put("offset", offset);
        }

        if (positionOrganizationQuery != null) {
            localVarFormParams.put("position_organization_query", positionOrganizationQuery);
        }

        if (positionOrganizationWeight != null) {
            localVarFormParams.put("position_organization_weight", positionOrganizationWeight);
        }

        if (positionRoleQuery != null) {
            localVarFormParams.put("position_role_query", positionRoleQuery);
        }

        if (positionRoleWeight != null) {
            localVarFormParams.put("position_role_weight", positionRoleWeight);
        }

        if (positionSummaryQuery != null) {
            localVarFormParams.put("position_summary_query", positionSummaryQuery);
        }

        if (positionSummaryWeight != null) {
            localVarFormParams.put("position_summary_weight", positionSummaryWeight);
        }

        if (profileFirstNameQuery != null) {
            localVarFormParams.put("profile_first_name_query", profileFirstNameQuery);
        }

        if (profileFirstNameWeight != null) {
            localVarFormParams.put("profile_first_name_weight", profileFirstNameWeight);
        }

        if (profileGoalsQuery != null) {
            localVarFormParams.put("profile_goals_query", profileGoalsQuery);
        }

        if (profileGoalsWeight != null) {
            localVarFormParams.put("profile_goals_weight", profileGoalsWeight);
        }

        if (profileHeadlineQuery != null) {
            localVarFormParams.put("profile_headline_query", profileHeadlineQuery);
        }

        if (profileHeadlineWeight != null) {
            localVarFormParams.put("profile_headline_weight", profileHeadlineWeight);
        }

        if (profileIndustryQuery != null) {
            localVarFormParams.put("profile_industry_query", profileIndustryQuery);
        }

        if (profileIndustryWeight != null) {
            localVarFormParams.put("profile_industry_weight", profileIndustryWeight);
        }

        if (profileLastNameQuery != null) {
            localVarFormParams.put("profile_last_name_query", profileLastNameQuery);
        }

        if (profileLastNameWeight != null) {
            localVarFormParams.put("profile_last_name_weight", profileLastNameWeight);
        }

        if (profilePitchQuery != null) {
            localVarFormParams.put("profile_pitch_query", profilePitchQuery);
        }

        if (profilePitchWeight != null) {
            localVarFormParams.put("profile_pitch_weight", profilePitchWeight);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersSearchesPostValidateBeforeCall(Integer activeWithinXDays, List<Integer> audienceIds, Boolean bubbled, Boolean excludeConnections, Boolean excludeMatches, Boolean excludeMuted, Boolean excludeSkipped, Float geoLatitude, Float geoLongitude, Float geoMilesAway, Integer groupId, Integer limit, String locationCityQuery, Integer locationCityWeight, String locationCountryQuery, Integer locationCountryWeight, String locationRegionQuery, Integer locationRegionWeight, String metadata0Key, String metadata0Query, Integer metadata0Weight, String metadata1Key, String metadata1Query, Integer metadata1Weight, String metadata2Key, String metadata2Query, Integer metadata2Weight, Integer offset, String positionOrganizationQuery, Integer positionOrganizationWeight, String positionRoleQuery, Integer positionRoleWeight, String positionSummaryQuery, Integer positionSummaryWeight, String profileFirstNameQuery, Integer profileFirstNameWeight, String profileGoalsQuery, String profileGoalsWeight, String profileHeadlineQuery, Integer profileHeadlineWeight, String profileIndustryQuery, Integer profileIndustryWeight, String profileLastNameQuery, Integer profileLastNameWeight, String profilePitchQuery, Integer profilePitchWeight, final ApiCallback _callback) throws ApiException {
        return usersSearchesPostCall(activeWithinXDays, audienceIds, bubbled, excludeConnections, excludeMatches, excludeMuted, excludeSkipped, geoLatitude, geoLongitude, geoMilesAway, groupId, limit, locationCityQuery, locationCityWeight, locationCountryQuery, locationCountryWeight, locationRegionQuery, locationRegionWeight, metadata0Key, metadata0Query, metadata0Weight, metadata1Key, metadata1Query, metadata1Weight, metadata2Key, metadata2Query, metadata2Weight, offset, positionOrganizationQuery, positionOrganizationWeight, positionRoleQuery, positionRoleWeight, positionSummaryQuery, positionSummaryWeight, profileFirstNameQuery, profileFirstNameWeight, profileGoalsQuery, profileGoalsWeight, profileHeadlineQuery, profileHeadlineWeight, profileIndustryQuery, profileIndustryWeight, profileLastNameQuery, profileLastNameWeight, profilePitchQuery, profilePitchWeight, _callback);

    }

    /**
     * 
     * Filter and perform a weighted search against user profile fields, CV fields, and metadata by specifying a string to search on for each individual field. By default, results are filtered such that all words in the string must exist, unless you seprate the words with OR. To perform a weighted search (as opposed to filtering), specify the weight (from 0-100) the search algorithm should assign to the field. You can optionally exclude users who you are already in or not in conversations with, exclude users who you previously skipped, or exclude users who you are muting. By doing so, you can effectively customize your own matching algorithm. You can specify geo coordinates to only find users a certain distance away from a specific location, or only find users within a certain distance from the OAuth&#39;ed end-user&#39;s last known location. If your app utilizes multiple audience segments, you can specify which audiences you would like to search. You can also limit users to just those who have been recently active. You can also choose to only receive users originating from the current access token&#39;s bubble. Only users existing within the current access token&#39;s bubble will be matched, and you can only search within a group created by a bubbled user.
     * @param activeWithinXDays  (optional)
     * @param audienceIds  (optional)
     * @param bubbled  (optional, default to false)
     * @param excludeConnections  (optional, default to false)
     * @param excludeMatches  (optional, default to false)
     * @param excludeMuted  (optional, default to false)
     * @param excludeSkipped  (optional, default to false)
     * @param geoLatitude  (optional)
     * @param geoLongitude  (optional)
     * @param geoMilesAway  (optional)
     * @param groupId  (optional)
     * @param limit  (optional, default to 50)
     * @param locationCityQuery  (optional)
     * @param locationCityWeight  (optional)
     * @param locationCountryQuery  (optional)
     * @param locationCountryWeight  (optional)
     * @param locationRegionQuery  (optional)
     * @param locationRegionWeight  (optional)
     * @param metadata0Key  (optional)
     * @param metadata0Query  (optional)
     * @param metadata0Weight  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Query  (optional)
     * @param metadata1Weight  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Query  (optional)
     * @param metadata2Weight  (optional)
     * @param offset  (optional, default to 0)
     * @param positionOrganizationQuery  (optional)
     * @param positionOrganizationWeight  (optional)
     * @param positionRoleQuery  (optional)
     * @param positionRoleWeight  (optional)
     * @param positionSummaryQuery  (optional)
     * @param positionSummaryWeight  (optional)
     * @param profileFirstNameQuery  (optional)
     * @param profileFirstNameWeight  (optional)
     * @param profileGoalsQuery  (optional)
     * @param profileGoalsWeight  (optional)
     * @param profileHeadlineQuery  (optional)
     * @param profileHeadlineWeight  (optional)
     * @param profileIndustryQuery  (optional)
     * @param profileIndustryWeight  (optional)
     * @param profileLastNameQuery  (optional)
     * @param profileLastNameWeight  (optional)
     * @param profilePitchQuery  (optional)
     * @param profilePitchWeight  (optional)
     * @return EndpointPostUsersSearches
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostUsersSearches usersSearchesPost(Integer activeWithinXDays, List<Integer> audienceIds, Boolean bubbled, Boolean excludeConnections, Boolean excludeMatches, Boolean excludeMuted, Boolean excludeSkipped, Float geoLatitude, Float geoLongitude, Float geoMilesAway, Integer groupId, Integer limit, String locationCityQuery, Integer locationCityWeight, String locationCountryQuery, Integer locationCountryWeight, String locationRegionQuery, Integer locationRegionWeight, String metadata0Key, String metadata0Query, Integer metadata0Weight, String metadata1Key, String metadata1Query, Integer metadata1Weight, String metadata2Key, String metadata2Query, Integer metadata2Weight, Integer offset, String positionOrganizationQuery, Integer positionOrganizationWeight, String positionRoleQuery, Integer positionRoleWeight, String positionSummaryQuery, Integer positionSummaryWeight, String profileFirstNameQuery, Integer profileFirstNameWeight, String profileGoalsQuery, String profileGoalsWeight, String profileHeadlineQuery, Integer profileHeadlineWeight, String profileIndustryQuery, Integer profileIndustryWeight, String profileLastNameQuery, Integer profileLastNameWeight, String profilePitchQuery, Integer profilePitchWeight) throws ApiException {
        ApiResponse<EndpointPostUsersSearches> localVarResp = usersSearchesPostWithHttpInfo(activeWithinXDays, audienceIds, bubbled, excludeConnections, excludeMatches, excludeMuted, excludeSkipped, geoLatitude, geoLongitude, geoMilesAway, groupId, limit, locationCityQuery, locationCityWeight, locationCountryQuery, locationCountryWeight, locationRegionQuery, locationRegionWeight, metadata0Key, metadata0Query, metadata0Weight, metadata1Key, metadata1Query, metadata1Weight, metadata2Key, metadata2Query, metadata2Weight, offset, positionOrganizationQuery, positionOrganizationWeight, positionRoleQuery, positionRoleWeight, positionSummaryQuery, positionSummaryWeight, profileFirstNameQuery, profileFirstNameWeight, profileGoalsQuery, profileGoalsWeight, profileHeadlineQuery, profileHeadlineWeight, profileIndustryQuery, profileIndustryWeight, profileLastNameQuery, profileLastNameWeight, profilePitchQuery, profilePitchWeight);
        return localVarResp.getData();
    }

    /**
     * 
     * Filter and perform a weighted search against user profile fields, CV fields, and metadata by specifying a string to search on for each individual field. By default, results are filtered such that all words in the string must exist, unless you seprate the words with OR. To perform a weighted search (as opposed to filtering), specify the weight (from 0-100) the search algorithm should assign to the field. You can optionally exclude users who you are already in or not in conversations with, exclude users who you previously skipped, or exclude users who you are muting. By doing so, you can effectively customize your own matching algorithm. You can specify geo coordinates to only find users a certain distance away from a specific location, or only find users within a certain distance from the OAuth&#39;ed end-user&#39;s last known location. If your app utilizes multiple audience segments, you can specify which audiences you would like to search. You can also limit users to just those who have been recently active. You can also choose to only receive users originating from the current access token&#39;s bubble. Only users existing within the current access token&#39;s bubble will be matched, and you can only search within a group created by a bubbled user.
     * @param activeWithinXDays  (optional)
     * @param audienceIds  (optional)
     * @param bubbled  (optional, default to false)
     * @param excludeConnections  (optional, default to false)
     * @param excludeMatches  (optional, default to false)
     * @param excludeMuted  (optional, default to false)
     * @param excludeSkipped  (optional, default to false)
     * @param geoLatitude  (optional)
     * @param geoLongitude  (optional)
     * @param geoMilesAway  (optional)
     * @param groupId  (optional)
     * @param limit  (optional, default to 50)
     * @param locationCityQuery  (optional)
     * @param locationCityWeight  (optional)
     * @param locationCountryQuery  (optional)
     * @param locationCountryWeight  (optional)
     * @param locationRegionQuery  (optional)
     * @param locationRegionWeight  (optional)
     * @param metadata0Key  (optional)
     * @param metadata0Query  (optional)
     * @param metadata0Weight  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Query  (optional)
     * @param metadata1Weight  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Query  (optional)
     * @param metadata2Weight  (optional)
     * @param offset  (optional, default to 0)
     * @param positionOrganizationQuery  (optional)
     * @param positionOrganizationWeight  (optional)
     * @param positionRoleQuery  (optional)
     * @param positionRoleWeight  (optional)
     * @param positionSummaryQuery  (optional)
     * @param positionSummaryWeight  (optional)
     * @param profileFirstNameQuery  (optional)
     * @param profileFirstNameWeight  (optional)
     * @param profileGoalsQuery  (optional)
     * @param profileGoalsWeight  (optional)
     * @param profileHeadlineQuery  (optional)
     * @param profileHeadlineWeight  (optional)
     * @param profileIndustryQuery  (optional)
     * @param profileIndustryWeight  (optional)
     * @param profileLastNameQuery  (optional)
     * @param profileLastNameWeight  (optional)
     * @param profilePitchQuery  (optional)
     * @param profilePitchWeight  (optional)
     * @return ApiResponse&lt;EndpointPostUsersSearches&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostUsersSearches> usersSearchesPostWithHttpInfo(Integer activeWithinXDays, List<Integer> audienceIds, Boolean bubbled, Boolean excludeConnections, Boolean excludeMatches, Boolean excludeMuted, Boolean excludeSkipped, Float geoLatitude, Float geoLongitude, Float geoMilesAway, Integer groupId, Integer limit, String locationCityQuery, Integer locationCityWeight, String locationCountryQuery, Integer locationCountryWeight, String locationRegionQuery, Integer locationRegionWeight, String metadata0Key, String metadata0Query, Integer metadata0Weight, String metadata1Key, String metadata1Query, Integer metadata1Weight, String metadata2Key, String metadata2Query, Integer metadata2Weight, Integer offset, String positionOrganizationQuery, Integer positionOrganizationWeight, String positionRoleQuery, Integer positionRoleWeight, String positionSummaryQuery, Integer positionSummaryWeight, String profileFirstNameQuery, Integer profileFirstNameWeight, String profileGoalsQuery, String profileGoalsWeight, String profileHeadlineQuery, Integer profileHeadlineWeight, String profileIndustryQuery, Integer profileIndustryWeight, String profileLastNameQuery, Integer profileLastNameWeight, String profilePitchQuery, Integer profilePitchWeight) throws ApiException {
        okhttp3.Call localVarCall = usersSearchesPostValidateBeforeCall(activeWithinXDays, audienceIds, bubbled, excludeConnections, excludeMatches, excludeMuted, excludeSkipped, geoLatitude, geoLongitude, geoMilesAway, groupId, limit, locationCityQuery, locationCityWeight, locationCountryQuery, locationCountryWeight, locationRegionQuery, locationRegionWeight, metadata0Key, metadata0Query, metadata0Weight, metadata1Key, metadata1Query, metadata1Weight, metadata2Key, metadata2Query, metadata2Weight, offset, positionOrganizationQuery, positionOrganizationWeight, positionRoleQuery, positionRoleWeight, positionSummaryQuery, positionSummaryWeight, profileFirstNameQuery, profileFirstNameWeight, profileGoalsQuery, profileGoalsWeight, profileHeadlineQuery, profileHeadlineWeight, profileIndustryQuery, profileIndustryWeight, profileLastNameQuery, profileLastNameWeight, profilePitchQuery, profilePitchWeight, null);
        Type localVarReturnType = new TypeToken<EndpointPostUsersSearches>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Filter and perform a weighted search against user profile fields, CV fields, and metadata by specifying a string to search on for each individual field. By default, results are filtered such that all words in the string must exist, unless you seprate the words with OR. To perform a weighted search (as opposed to filtering), specify the weight (from 0-100) the search algorithm should assign to the field. You can optionally exclude users who you are already in or not in conversations with, exclude users who you previously skipped, or exclude users who you are muting. By doing so, you can effectively customize your own matching algorithm. You can specify geo coordinates to only find users a certain distance away from a specific location, or only find users within a certain distance from the OAuth&#39;ed end-user&#39;s last known location. If your app utilizes multiple audience segments, you can specify which audiences you would like to search. You can also limit users to just those who have been recently active. You can also choose to only receive users originating from the current access token&#39;s bubble. Only users existing within the current access token&#39;s bubble will be matched, and you can only search within a group created by a bubbled user.
     * @param activeWithinXDays  (optional)
     * @param audienceIds  (optional)
     * @param bubbled  (optional, default to false)
     * @param excludeConnections  (optional, default to false)
     * @param excludeMatches  (optional, default to false)
     * @param excludeMuted  (optional, default to false)
     * @param excludeSkipped  (optional, default to false)
     * @param geoLatitude  (optional)
     * @param geoLongitude  (optional)
     * @param geoMilesAway  (optional)
     * @param groupId  (optional)
     * @param limit  (optional, default to 50)
     * @param locationCityQuery  (optional)
     * @param locationCityWeight  (optional)
     * @param locationCountryQuery  (optional)
     * @param locationCountryWeight  (optional)
     * @param locationRegionQuery  (optional)
     * @param locationRegionWeight  (optional)
     * @param metadata0Key  (optional)
     * @param metadata0Query  (optional)
     * @param metadata0Weight  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Query  (optional)
     * @param metadata1Weight  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Query  (optional)
     * @param metadata2Weight  (optional)
     * @param offset  (optional, default to 0)
     * @param positionOrganizationQuery  (optional)
     * @param positionOrganizationWeight  (optional)
     * @param positionRoleQuery  (optional)
     * @param positionRoleWeight  (optional)
     * @param positionSummaryQuery  (optional)
     * @param positionSummaryWeight  (optional)
     * @param profileFirstNameQuery  (optional)
     * @param profileFirstNameWeight  (optional)
     * @param profileGoalsQuery  (optional)
     * @param profileGoalsWeight  (optional)
     * @param profileHeadlineQuery  (optional)
     * @param profileHeadlineWeight  (optional)
     * @param profileIndustryQuery  (optional)
     * @param profileIndustryWeight  (optional)
     * @param profileLastNameQuery  (optional)
     * @param profileLastNameWeight  (optional)
     * @param profilePitchQuery  (optional)
     * @param profilePitchWeight  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersSearchesPostAsync(Integer activeWithinXDays, List<Integer> audienceIds, Boolean bubbled, Boolean excludeConnections, Boolean excludeMatches, Boolean excludeMuted, Boolean excludeSkipped, Float geoLatitude, Float geoLongitude, Float geoMilesAway, Integer groupId, Integer limit, String locationCityQuery, Integer locationCityWeight, String locationCountryQuery, Integer locationCountryWeight, String locationRegionQuery, Integer locationRegionWeight, String metadata0Key, String metadata0Query, Integer metadata0Weight, String metadata1Key, String metadata1Query, Integer metadata1Weight, String metadata2Key, String metadata2Query, Integer metadata2Weight, Integer offset, String positionOrganizationQuery, Integer positionOrganizationWeight, String positionRoleQuery, Integer positionRoleWeight, String positionSummaryQuery, Integer positionSummaryWeight, String profileFirstNameQuery, Integer profileFirstNameWeight, String profileGoalsQuery, String profileGoalsWeight, String profileHeadlineQuery, Integer profileHeadlineWeight, String profileIndustryQuery, Integer profileIndustryWeight, String profileLastNameQuery, Integer profileLastNameWeight, String profilePitchQuery, Integer profilePitchWeight, final ApiCallback<EndpointPostUsersSearches> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersSearchesPostValidateBeforeCall(activeWithinXDays, audienceIds, bubbled, excludeConnections, excludeMatches, excludeMuted, excludeSkipped, geoLatitude, geoLongitude, geoMilesAway, groupId, limit, locationCityQuery, locationCityWeight, locationCountryQuery, locationCountryWeight, locationRegionQuery, locationRegionWeight, metadata0Key, metadata0Query, metadata0Weight, metadata1Key, metadata1Query, metadata1Weight, metadata2Key, metadata2Query, metadata2Weight, offset, positionOrganizationQuery, positionOrganizationWeight, positionRoleQuery, positionRoleWeight, positionSummaryQuery, positionSummaryWeight, profileFirstNameQuery, profileFirstNameWeight, profileGoalsQuery, profileGoalsWeight, profileHeadlineQuery, profileHeadlineWeight, profileIndustryQuery, profileIndustryWeight, profileLastNameQuery, profileLastNameWeight, profilePitchQuery, profilePitchWeight, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostUsersSearches>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
