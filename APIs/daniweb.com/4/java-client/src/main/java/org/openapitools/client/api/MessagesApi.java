/*
 * DaniWeb Connect API
 * User Recommendation Engine and Chat Network
 *
 * The version of the OpenAPI document: 4
 * Contact: dani@daniwebmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.EndpointGetMessagesID;
import org.openapitools.client.model.EndpointGetMessagesIDMetadata;
import org.openapitools.client.model.EndpointGetMessagesIDMetadataCollections;
import org.openapitools.client.model.EndpointPostMessagesIDMetadata;
import org.openapitools.client.model.EndpointPostMessagesMetadataFilters;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MessagesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessagesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MessagesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for messagesIDGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDGetCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{ID}"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ID)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesIDGetValidateBeforeCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling messagesIDGet(Async)");
        }

        return messagesIDGetCall(ID, _callback);

    }

    /**
     * 
     * Fetch an array of messages. You can only retrieve messages authored by you or by users who exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return EndpointGetMessagesID
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetMessagesID messagesIDGet(List<Integer> ID) throws ApiException {
        ApiResponse<EndpointGetMessagesID> localVarResp = messagesIDGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetch an array of messages. You can only retrieve messages authored by you or by users who exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetMessagesID&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetMessagesID> messagesIDGetWithHttpInfo(List<Integer> ID) throws ApiException {
        okhttp3.Call localVarCall = messagesIDGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetMessagesID>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetch an array of messages. You can only retrieve messages authored by you or by users who exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDGetAsync(List<Integer> ID, final ApiCallback<EndpointGetMessagesID> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesIDGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetMessagesID>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesIDMetadataCollectionsGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDMetadataCollectionsGetCall(Integer ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{ID}/metadata/collections"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesIDMetadataCollectionsGetValidateBeforeCall(Integer ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling messagesIDMetadataCollectionsGet(Async)");
        }

        return messagesIDMetadataCollectionsGetCall(ID, _callback);

    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current message that you have access to, so long as the user who authored the message exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. Metadata will be grouped by key.
     * @param ID  (required)
     * @return EndpointGetMessagesIDMetadataCollections
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetMessagesIDMetadataCollections messagesIDMetadataCollectionsGet(Integer ID) throws ApiException {
        ApiResponse<EndpointGetMessagesIDMetadataCollections> localVarResp = messagesIDMetadataCollectionsGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current message that you have access to, so long as the user who authored the message exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. Metadata will be grouped by key.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetMessagesIDMetadataCollections&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetMessagesIDMetadataCollections> messagesIDMetadataCollectionsGetWithHttpInfo(Integer ID) throws ApiException {
        okhttp3.Call localVarCall = messagesIDMetadataCollectionsGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetMessagesIDMetadataCollections>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve all key/value pairs attached to the current message that you have access to, so long as the user who authored the message exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble. Metadata will be grouped by key.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDMetadataCollectionsGetAsync(Integer ID, final ApiCallback<EndpointGetMessagesIDMetadataCollections> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesIDMetadataCollectionsGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetMessagesIDMetadataCollections>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesIDMetadataGet
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDMetadataGetCall(Integer ID, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{ID}/metadata"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesIDMetadataGetValidateBeforeCall(Integer ID, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling messagesIDMetadataGet(Async)");
        }

        return messagesIDMetadataGetCall(ID, offset, limit, _callback);

    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current message that you have access to, so long as the user who authored the message exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return EndpointGetMessagesIDMetadata
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetMessagesIDMetadata messagesIDMetadataGet(Integer ID, Integer offset, Integer limit) throws ApiException {
        ApiResponse<EndpointGetMessagesIDMetadata> localVarResp = messagesIDMetadataGetWithHttpInfo(ID, offset, limit);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve all key/value pairs attached to the current message that you have access to, so long as the user who authored the message exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return ApiResponse&lt;EndpointGetMessagesIDMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetMessagesIDMetadata> messagesIDMetadataGetWithHttpInfo(Integer ID, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = messagesIDMetadataGetValidateBeforeCall(ID, offset, limit, null);
        Type localVarReturnType = new TypeToken<EndpointGetMessagesIDMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve all key/value pairs attached to the current message that you have access to, so long as the user who authored the message exists within the current access token&#39;s bubble. This includes all public metadata, bubbled metadata that was created by an access token existing within the current bubble, user metadata that was created by you, or private metadata created by you from an access token existing within the current bubble.
     * @param ID  (required)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDMetadataGetAsync(Integer ID, Integer offset, Integer limit, final ApiCallback<EndpointGetMessagesIDMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesIDMetadataGetValidateBeforeCall(ID, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetMessagesIDMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesIDMetadataPost
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDMetadataPostCall(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{ID}/metadata"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (metadata0Key != null) {
            localVarFormParams.put("metadata_0_key", metadata0Key);
        }

        if (metadata0Privacy != null) {
            localVarFormParams.put("metadata_0_privacy", metadata0Privacy);
        }

        if (metadata0Values != null) {
            localVarFormParams.put("metadata_0_values[]", metadata0Values);
        }

        if (metadata1Key != null) {
            localVarFormParams.put("metadata_1_key", metadata1Key);
        }

        if (metadata1Privacy != null) {
            localVarFormParams.put("metadata_1_privacy", metadata1Privacy);
        }

        if (metadata1Values != null) {
            localVarFormParams.put("metadata_1_values[]", metadata1Values);
        }

        if (metadata2Key != null) {
            localVarFormParams.put("metadata_2_key", metadata2Key);
        }

        if (metadata2Privacy != null) {
            localVarFormParams.put("metadata_2_privacy", metadata2Privacy);
        }

        if (metadata2Values != null) {
            localVarFormParams.put("metadata_2_values[]", metadata2Values);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesIDMetadataPostValidateBeforeCall(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling messagesIDMetadataPost(Async)");
        }

        return messagesIDMetadataPostCall(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, _callback);

    }

    /**
     * 
     * Attach one-to-many key/value pairs of metadata to a message, so long as the user who authored the message exists within the current access token&#39;s bubble. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by you or the other user in the message&#39;s conversation, using an access token which grants you access to the user who authored the message, if it wasn&#39;t you; Bubbled metadata by you or the other user in the message&#39;s conversation, using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user who authored the message, if it wasn&#39;t you; Private metadata by you, so long as you are using an access token existing within the current bubble.
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @return EndpointPostMessagesIDMetadata
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostMessagesIDMetadata messagesIDMetadataPost(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values) throws ApiException {
        ApiResponse<EndpointPostMessagesIDMetadata> localVarResp = messagesIDMetadataPostWithHttpInfo(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values);
        return localVarResp.getData();
    }

    /**
     * 
     * Attach one-to-many key/value pairs of metadata to a message, so long as the user who authored the message exists within the current access token&#39;s bubble. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by you or the other user in the message&#39;s conversation, using an access token which grants you access to the user who authored the message, if it wasn&#39;t you; Bubbled metadata by you or the other user in the message&#39;s conversation, using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user who authored the message, if it wasn&#39;t you; Private metadata by you, so long as you are using an access token existing within the current bubble.
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @return ApiResponse&lt;EndpointPostMessagesIDMetadata&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostMessagesIDMetadata> messagesIDMetadataPostWithHttpInfo(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values) throws ApiException {
        okhttp3.Call localVarCall = messagesIDMetadataPostValidateBeforeCall(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, null);
        Type localVarReturnType = new TypeToken<EndpointPostMessagesIDMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Attach one-to-many key/value pairs of metadata to a message, so long as the user who authored the message exists within the current access token&#39;s bubble. A key is unique for each author/bubble combination. Attaching metadata with an existing key that was previously created by you, from within the same bubble, overwrites the key with the new value or set of values. The privacy setting allows you to specify who will have access to the metadata: Public metadata by you or the other user in the message&#39;s conversation, using an access token which grants you access to the user who authored the message, if it wasn&#39;t you; Bubbled metadata by you or the other user in the message&#39;s conversation, using an access token existing within the current bubble; User metadata by you, so long as you are using an access token which grants you access to the user who authored the message, if it wasn&#39;t you; Private metadata by you, so long as you are using an access token existing within the current bubble.
     * @param ID  (required)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIDMetadataPostAsync(Integer ID, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, final ApiCallback<EndpointPostMessagesIDMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesIDMetadataPostValidateBeforeCall(ID, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostMessagesIDMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesMetadataFiltersPost
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesMetadataFiltersPostCall(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/metadata/filters";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarFormParams.put("limit", limit);
        }

        if (metadata0Key != null) {
            localVarFormParams.put("metadata_0_key", metadata0Key);
        }

        if (metadata0Values != null) {
            localVarFormParams.put("metadata_0_values[]", metadata0Values);
        }

        if (metadata1Key != null) {
            localVarFormParams.put("metadata_1_key", metadata1Key);
        }

        if (metadata1Values != null) {
            localVarFormParams.put("metadata_1_values[]", metadata1Values);
        }

        if (metadata2Key != null) {
            localVarFormParams.put("metadata_2_key", metadata2Key);
        }

        if (metadata2Values != null) {
            localVarFormParams.put("metadata_2_values[]", metadata2Values);
        }

        if (offset != null) {
            localVarFormParams.put("offset", offset);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesMetadataFiltersPostValidateBeforeCall(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset, final ApiCallback _callback) throws ApiException {
        return messagesMetadataFiltersPostCall(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset, _callback);

    }

    /**
     * 
     * Paginated listing of messages filtered by arbitrary metadata criteria. Messages must match on all key/value pairs passed in. Messages may only match on one value of an array passed in. However, messages are sorted based on how many distinct values they match on (most matches first).
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @return EndpointPostMessagesMetadataFilters
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostMessagesMetadataFilters messagesMetadataFiltersPost(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset) throws ApiException {
        ApiResponse<EndpointPostMessagesMetadataFilters> localVarResp = messagesMetadataFiltersPostWithHttpInfo(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset);
        return localVarResp.getData();
    }

    /**
     * 
     * Paginated listing of messages filtered by arbitrary metadata criteria. Messages must match on all key/value pairs passed in. Messages may only match on one value of an array passed in. However, messages are sorted based on how many distinct values they match on (most matches first).
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @return ApiResponse&lt;EndpointPostMessagesMetadataFilters&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostMessagesMetadataFilters> messagesMetadataFiltersPostWithHttpInfo(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = messagesMetadataFiltersPostValidateBeforeCall(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset, null);
        Type localVarReturnType = new TypeToken<EndpointPostMessagesMetadataFilters>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Paginated listing of messages filtered by arbitrary metadata criteria. Messages must match on all key/value pairs passed in. Messages may only match on one value of an array passed in. However, messages are sorted based on how many distinct values they match on (most matches first).
     * @param limit  (optional, default to 50)
     * @param metadata0Key  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Values  (optional)
     * @param offset  (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesMetadataFiltersPostAsync(Integer limit, String metadata0Key, List<String> metadata0Values, String metadata1Key, List<String> metadata1Values, String metadata2Key, List<String> metadata2Values, Integer offset, final ApiCallback<EndpointPostMessagesMetadataFilters> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesMetadataFiltersPostValidateBeforeCall(limit, metadata0Key, metadata0Values, metadata1Key, metadata1Values, metadata2Key, metadata2Values, offset, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostMessagesMetadataFilters>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
