/*
 * DaniWeb Connect API
 * User Recommendation Engine and Chat Network
 *
 * The version of the OpenAPI document: 4
 * Contact: dani@daniwebmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.EndpointGetConversationsID;
import org.openapitools.client.model.EndpointGetConversationsIDMessages;
import org.openapitools.client.model.EndpointGetConversationsIDStatuses;
import org.openapitools.client.model.EndpointGetConversationsStatuses;
import org.openapitools.client.model.EndpointPatchConversationsIDStatuses;
import org.openapitools.client.model.EndpointPostConversationsIDMessages;
import org.openapitools.client.model.EndpointPostConversationsIDSchedules;
import org.openapitools.client.model.EndpointPostConversationsIDSearches;
import org.openapitools.client.model.EndpointPostConversationsSchedules;
import org.openapitools.client.model.EndpointPostConversationsSearches;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ConversationsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ConversationsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ConversationsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for conversationsIDGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDGetCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/{ID}"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ID)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsIDGetValidateBeforeCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling conversationsIDGet(Async)");
        }

        return conversationsIDGetCall(ID, _callback);

    }

    /**
     * 
     * Fetch an array of conversations. You can only retrieve conversations with users who exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return EndpointGetConversationsID
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetConversationsID conversationsIDGet(List<Integer> ID) throws ApiException {
        ApiResponse<EndpointGetConversationsID> localVarResp = conversationsIDGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetch an array of conversations. You can only retrieve conversations with users who exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetConversationsID&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetConversationsID> conversationsIDGetWithHttpInfo(List<Integer> ID) throws ApiException {
        okhttp3.Call localVarCall = conversationsIDGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsID>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetch an array of conversations. You can only retrieve conversations with users who exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDGetAsync(List<Integer> ID, final ApiCallback<EndpointGetConversationsID> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsIDGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsID>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsIDMessagesGet
     * @param ID  (required)
     * @param gtMessageId  (optional)
     * @param excludeSelf  (optional, default to false)
     * @param date  (optional)
     * @param bubbled  (optional, default to false)
     * @param recordSeen  (optional, default to false)
     * @param timeout  (optional, default to 0)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDMessagesGetCall(Integer ID, Integer gtMessageId, Boolean excludeSelf, String date, Boolean bubbled, Boolean recordSeen, Integer timeout, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/{ID}/messages"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (gtMessageId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("gt_message_id", gtMessageId));
        }

        if (excludeSelf != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_self", excludeSelf));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        if (bubbled != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bubbled", bubbled));
        }

        if (recordSeen != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("record_seen", recordSeen));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsIDMessagesGetValidateBeforeCall(Integer ID, Integer gtMessageId, Boolean excludeSelf, String date, Boolean bubbled, Boolean recordSeen, Integer timeout, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling conversationsIDMessagesGet(Async)");
        }

        return conversationsIDMessagesGetCall(ID, gtMessageId, excludeSelf, date, bubbled, recordSeen, timeout, offset, limit, _callback);

    }

    /**
     * 
     * Retrieve the last {limit} messages in the conversation, provided the conversations exist within the current access token&#39;s bubble. If a timeout is 0 or greater, the batch is sorted oldest first. Otherwise, if timeout is a negative number, the transcript is paginated and sorted newest first. Specify a timeout for long polling (which delays the server sending back results for up to n seconds or until results are available, whichever comes first), or default to 0 for immediate results. Optionally record your status as online along with sharing the latest message you&#39;ve seen with the other conversation participant. Optionally specify a gt_message_id to retrieve only messages with an ID greater than that specified (such as greater than the latest message ID received in the last poll). Optionally only poll for messages authored by the other person in the conversation, and echo messages authored by you when sending, for a perceived increase in performance. Optionally only retrieve messages that were posted from within the current access token&#39;s bubble. Optionally specify a date formatted as YYYY-MM-DD to retrieve a transcript of messages from a single day. When record_seen is set to true, the new message count for the conversation is reset to zero.
     * @param ID  (required)
     * @param gtMessageId  (optional)
     * @param excludeSelf  (optional, default to false)
     * @param date  (optional)
     * @param bubbled  (optional, default to false)
     * @param recordSeen  (optional, default to false)
     * @param timeout  (optional, default to 0)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return EndpointGetConversationsIDMessages
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetConversationsIDMessages conversationsIDMessagesGet(Integer ID, Integer gtMessageId, Boolean excludeSelf, String date, Boolean bubbled, Boolean recordSeen, Integer timeout, Integer offset, Integer limit) throws ApiException {
        ApiResponse<EndpointGetConversationsIDMessages> localVarResp = conversationsIDMessagesGetWithHttpInfo(ID, gtMessageId, excludeSelf, date, bubbled, recordSeen, timeout, offset, limit);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve the last {limit} messages in the conversation, provided the conversations exist within the current access token&#39;s bubble. If a timeout is 0 or greater, the batch is sorted oldest first. Otherwise, if timeout is a negative number, the transcript is paginated and sorted newest first. Specify a timeout for long polling (which delays the server sending back results for up to n seconds or until results are available, whichever comes first), or default to 0 for immediate results. Optionally record your status as online along with sharing the latest message you&#39;ve seen with the other conversation participant. Optionally specify a gt_message_id to retrieve only messages with an ID greater than that specified (such as greater than the latest message ID received in the last poll). Optionally only poll for messages authored by the other person in the conversation, and echo messages authored by you when sending, for a perceived increase in performance. Optionally only retrieve messages that were posted from within the current access token&#39;s bubble. Optionally specify a date formatted as YYYY-MM-DD to retrieve a transcript of messages from a single day. When record_seen is set to true, the new message count for the conversation is reset to zero.
     * @param ID  (required)
     * @param gtMessageId  (optional)
     * @param excludeSelf  (optional, default to false)
     * @param date  (optional)
     * @param bubbled  (optional, default to false)
     * @param recordSeen  (optional, default to false)
     * @param timeout  (optional, default to 0)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return ApiResponse&lt;EndpointGetConversationsIDMessages&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetConversationsIDMessages> conversationsIDMessagesGetWithHttpInfo(Integer ID, Integer gtMessageId, Boolean excludeSelf, String date, Boolean bubbled, Boolean recordSeen, Integer timeout, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = conversationsIDMessagesGetValidateBeforeCall(ID, gtMessageId, excludeSelf, date, bubbled, recordSeen, timeout, offset, limit, null);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsIDMessages>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve the last {limit} messages in the conversation, provided the conversations exist within the current access token&#39;s bubble. If a timeout is 0 or greater, the batch is sorted oldest first. Otherwise, if timeout is a negative number, the transcript is paginated and sorted newest first. Specify a timeout for long polling (which delays the server sending back results for up to n seconds or until results are available, whichever comes first), or default to 0 for immediate results. Optionally record your status as online along with sharing the latest message you&#39;ve seen with the other conversation participant. Optionally specify a gt_message_id to retrieve only messages with an ID greater than that specified (such as greater than the latest message ID received in the last poll). Optionally only poll for messages authored by the other person in the conversation, and echo messages authored by you when sending, for a perceived increase in performance. Optionally only retrieve messages that were posted from within the current access token&#39;s bubble. Optionally specify a date formatted as YYYY-MM-DD to retrieve a transcript of messages from a single day. When record_seen is set to true, the new message count for the conversation is reset to zero.
     * @param ID  (required)
     * @param gtMessageId  (optional)
     * @param excludeSelf  (optional, default to false)
     * @param date  (optional)
     * @param bubbled  (optional, default to false)
     * @param recordSeen  (optional, default to false)
     * @param timeout  (optional, default to 0)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDMessagesGetAsync(Integer ID, Integer gtMessageId, Boolean excludeSelf, String date, Boolean bubbled, Boolean recordSeen, Integer timeout, Integer offset, Integer limit, final ApiCallback<EndpointGetConversationsIDMessages> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsIDMessagesGetValidateBeforeCall(ID, gtMessageId, excludeSelf, date, bubbled, recordSeen, timeout, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsIDMessages>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsIDMessagesPost
     * @param ID  (required)
     * @param textRaw  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDMessagesPostCall(Integer ID, String textRaw, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/{ID}/messages"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (bubbled != null) {
            localVarFormParams.put("bubbled", bubbled);
        }

        if (metadata0Key != null) {
            localVarFormParams.put("metadata_0_key", metadata0Key);
        }

        if (metadata0Privacy != null) {
            localVarFormParams.put("metadata_0_privacy", metadata0Privacy);
        }

        if (metadata0Values != null) {
            localVarFormParams.put("metadata_0_values[]", metadata0Values);
        }

        if (metadata1Key != null) {
            localVarFormParams.put("metadata_1_key", metadata1Key);
        }

        if (metadata1Privacy != null) {
            localVarFormParams.put("metadata_1_privacy", metadata1Privacy);
        }

        if (metadata1Values != null) {
            localVarFormParams.put("metadata_1_values[]", metadata1Values);
        }

        if (metadata2Key != null) {
            localVarFormParams.put("metadata_2_key", metadata2Key);
        }

        if (metadata2Privacy != null) {
            localVarFormParams.put("metadata_2_privacy", metadata2Privacy);
        }

        if (metadata2Values != null) {
            localVarFormParams.put("metadata_2_values[]", metadata2Values);
        }

        if (textEmoticons != null) {
            localVarFormParams.put("text_emoticons", textEmoticons);
        }

        if (textRaw != null) {
            localVarFormParams.put("text_raw", textRaw);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsIDMessagesPostValidateBeforeCall(Integer ID, String textRaw, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling conversationsIDMessagesPost(Async)");
        }

        // verify the required parameter 'textRaw' is set
        if (textRaw == null) {
            throw new ApiException("Missing the required parameter 'textRaw' when calling conversationsIDMessagesPost(Async)");
        }

        return conversationsIDMessagesPostCall(ID, textRaw, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons, _callback);

    }

    /**
     * 
     * Post a message to a conversation that is with a user who exists within the current access token&#39;s bubble. Optionally specify whether emoticons should be parsed into smiley images. Optionally specify whether the message should be bubbled within the app. Additionally, optionally attach a single metadata key/value pair to the message upon submission.
     * @param ID  (required)
     * @param textRaw  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @return EndpointPostConversationsIDMessages
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostConversationsIDMessages conversationsIDMessagesPost(Integer ID, String textRaw, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons) throws ApiException {
        ApiResponse<EndpointPostConversationsIDMessages> localVarResp = conversationsIDMessagesPostWithHttpInfo(ID, textRaw, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons);
        return localVarResp.getData();
    }

    /**
     * 
     * Post a message to a conversation that is with a user who exists within the current access token&#39;s bubble. Optionally specify whether emoticons should be parsed into smiley images. Optionally specify whether the message should be bubbled within the app. Additionally, optionally attach a single metadata key/value pair to the message upon submission.
     * @param ID  (required)
     * @param textRaw  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @return ApiResponse&lt;EndpointPostConversationsIDMessages&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostConversationsIDMessages> conversationsIDMessagesPostWithHttpInfo(Integer ID, String textRaw, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons) throws ApiException {
        okhttp3.Call localVarCall = conversationsIDMessagesPostValidateBeforeCall(ID, textRaw, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons, null);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsIDMessages>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Post a message to a conversation that is with a user who exists within the current access token&#39;s bubble. Optionally specify whether emoticons should be parsed into smiley images. Optionally specify whether the message should be bubbled within the app. Additionally, optionally attach a single metadata key/value pair to the message upon submission.
     * @param ID  (required)
     * @param textRaw  (required)
     * @param bubbled  (optional, default to false)
     * @param metadata0Key  (optional)
     * @param metadata0Privacy  (optional)
     * @param metadata0Values  (optional)
     * @param metadata1Key  (optional)
     * @param metadata1Privacy  (optional)
     * @param metadata1Values  (optional)
     * @param metadata2Key  (optional)
     * @param metadata2Privacy  (optional)
     * @param metadata2Values  (optional)
     * @param textEmoticons  (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDMessagesPostAsync(Integer ID, String textRaw, Boolean bubbled, String metadata0Key, String metadata0Privacy, List<String> metadata0Values, String metadata1Key, String metadata1Privacy, List<String> metadata1Values, String metadata2Key, String metadata2Privacy, List<String> metadata2Values, Boolean textEmoticons, final ApiCallback<EndpointPostConversationsIDMessages> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsIDMessagesPostValidateBeforeCall(ID, textRaw, bubbled, metadata0Key, metadata0Privacy, metadata0Values, metadata1Key, metadata1Privacy, metadata1Values, metadata2Key, metadata2Privacy, metadata2Values, textEmoticons, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsIDMessages>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsIDSchedulesPost
     * @param ID  (required)
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDSchedulesPostCall(List<Integer> ID, String date, Integer limit, Integer offset, Boolean rollUp, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/{ID}/schedules"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ID)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (date != null) {
            localVarFormParams.put("date", date);
        }

        if (limit != null) {
            localVarFormParams.put("limit", limit);
        }

        if (offset != null) {
            localVarFormParams.put("offset", offset);
        }

        if (rollUp != null) {
            localVarFormParams.put("roll_up", rollUp);
        }

        if (sort != null) {
            localVarFormParams.put("sort", sort);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsIDSchedulesPostValidateBeforeCall(List<Integer> ID, String date, Integer limit, Integer offset, Boolean rollUp, String sort, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling conversationsIDSchedulesPost(Async)");
        }

        return conversationsIDSchedulesPostCall(ID, date, limit, offset, rollUp, sort, _callback);

    }

    /**
     * 
     * Paginated report of information about messages contributed by conversation and date. Only conversations that exist within the current access token&#39;s bubble are considered in the calculations. Optionally roll up all conversations to retrieve one record per date. Optionally specify a date formatted as YYYY-MM-DD to retrieve information just from the single date, along with additional navigational information, which is useful when generating a transcript for a single day and wanting to reference the previous and next days there were messages within the conversation(s).
     * @param ID  (required)
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @return EndpointPostConversationsIDSchedules
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostConversationsIDSchedules conversationsIDSchedulesPost(List<Integer> ID, String date, Integer limit, Integer offset, Boolean rollUp, String sort) throws ApiException {
        ApiResponse<EndpointPostConversationsIDSchedules> localVarResp = conversationsIDSchedulesPostWithHttpInfo(ID, date, limit, offset, rollUp, sort);
        return localVarResp.getData();
    }

    /**
     * 
     * Paginated report of information about messages contributed by conversation and date. Only conversations that exist within the current access token&#39;s bubble are considered in the calculations. Optionally roll up all conversations to retrieve one record per date. Optionally specify a date formatted as YYYY-MM-DD to retrieve information just from the single date, along with additional navigational information, which is useful when generating a transcript for a single day and wanting to reference the previous and next days there were messages within the conversation(s).
     * @param ID  (required)
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @return ApiResponse&lt;EndpointPostConversationsIDSchedules&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostConversationsIDSchedules> conversationsIDSchedulesPostWithHttpInfo(List<Integer> ID, String date, Integer limit, Integer offset, Boolean rollUp, String sort) throws ApiException {
        okhttp3.Call localVarCall = conversationsIDSchedulesPostValidateBeforeCall(ID, date, limit, offset, rollUp, sort, null);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsIDSchedules>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Paginated report of information about messages contributed by conversation and date. Only conversations that exist within the current access token&#39;s bubble are considered in the calculations. Optionally roll up all conversations to retrieve one record per date. Optionally specify a date formatted as YYYY-MM-DD to retrieve information just from the single date, along with additional navigational information, which is useful when generating a transcript for a single day and wanting to reference the previous and next days there were messages within the conversation(s).
     * @param ID  (required)
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDSchedulesPostAsync(List<Integer> ID, String date, Integer limit, Integer offset, Boolean rollUp, String sort, final ApiCallback<EndpointPostConversationsIDSchedules> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsIDSchedulesPostValidateBeforeCall(ID, date, limit, offset, rollUp, sort, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsIDSchedules>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsIDSearchesPost
     * @param ID  (required)
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDSearchesPostCall(List<Integer> ID, String query, String date, Integer gtMessageId, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/{ID}/searches"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ID)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (date != null) {
            localVarFormParams.put("date", date);
        }

        if (gtMessageId != null) {
            localVarFormParams.put("gt_message_id", gtMessageId);
        }

        if (limit != null) {
            localVarFormParams.put("limit", limit);
        }

        if (offset != null) {
            localVarFormParams.put("offset", offset);
        }

        if (query != null) {
            localVarFormParams.put("query", query);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsIDSearchesPostValidateBeforeCall(List<Integer> ID, String query, String date, Integer gtMessageId, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling conversationsIDSearchesPost(Async)");
        }

        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling conversationsIDSearchesPost(Async)");
        }

        return conversationsIDSearchesPostCall(ID, query, date, gtMessageId, limit, offset, _callback);

    }

    /**
     * 
     * Fetch messages authored from within specified conversations that match a query string passed in as a search parameter along with their relevancy score.
     * @param ID  (required)
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @return EndpointPostConversationsIDSearches
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostConversationsIDSearches conversationsIDSearchesPost(List<Integer> ID, String query, String date, Integer gtMessageId, Integer limit, Integer offset) throws ApiException {
        ApiResponse<EndpointPostConversationsIDSearches> localVarResp = conversationsIDSearchesPostWithHttpInfo(ID, query, date, gtMessageId, limit, offset);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetch messages authored from within specified conversations that match a query string passed in as a search parameter along with their relevancy score.
     * @param ID  (required)
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @return ApiResponse&lt;EndpointPostConversationsIDSearches&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostConversationsIDSearches> conversationsIDSearchesPostWithHttpInfo(List<Integer> ID, String query, String date, Integer gtMessageId, Integer limit, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = conversationsIDSearchesPostValidateBeforeCall(ID, query, date, gtMessageId, limit, offset, null);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsIDSearches>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetch messages authored from within specified conversations that match a query string passed in as a search parameter along with their relevancy score.
     * @param ID  (required)
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDSearchesPostAsync(List<Integer> ID, String query, String date, Integer gtMessageId, Integer limit, Integer offset, final ApiCallback<EndpointPostConversationsIDSearches> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsIDSearchesPostValidateBeforeCall(ID, query, date, gtMessageId, limit, offset, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsIDSearches>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsIDStatusesGet
     * @param ID  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDStatusesGetCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/{ID}/statuses"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(localVarApiClient.collectionPathParameterToString("csv", ID)));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsIDStatusesGetValidateBeforeCall(List<Integer> ID, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling conversationsIDStatusesGet(Async)");
        }

        return conversationsIDStatusesGetCall(ID, _callback);

    }

    /**
     * 
     * Status information about your current relationship with one or more conversations you participating in, provided the conversations exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return EndpointGetConversationsIDStatuses
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetConversationsIDStatuses conversationsIDStatusesGet(List<Integer> ID) throws ApiException {
        ApiResponse<EndpointGetConversationsIDStatuses> localVarResp = conversationsIDStatusesGetWithHttpInfo(ID);
        return localVarResp.getData();
    }

    /**
     * 
     * Status information about your current relationship with one or more conversations you participating in, provided the conversations exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @return ApiResponse&lt;EndpointGetConversationsIDStatuses&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetConversationsIDStatuses> conversationsIDStatusesGetWithHttpInfo(List<Integer> ID) throws ApiException {
        okhttp3.Call localVarCall = conversationsIDStatusesGetValidateBeforeCall(ID, null);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsIDStatuses>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Status information about your current relationship with one or more conversations you participating in, provided the conversations exist within the current access token&#39;s bubble.
     * @param ID  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDStatusesGetAsync(List<Integer> ID, final ApiCallback<EndpointGetConversationsIDStatuses> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsIDStatusesGetValidateBeforeCall(ID, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsIDStatuses>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsIDStatusesPatch
     * @param ID  (required)
     * @param archivedStatus  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDStatusesPatchCall(Integer ID, Boolean archivedStatus, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/{ID}/statuses"
            .replace("{" + "ID" + "}", localVarApiClient.escapeString(ID.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (archivedStatus != null) {
            localVarFormParams.put("archived_status", archivedStatus);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsIDStatusesPatchValidateBeforeCall(Integer ID, Boolean archivedStatus, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling conversationsIDStatusesPatch(Async)");
        }

        // verify the required parameter 'archivedStatus' is set
        if (archivedStatus == null) {
            throw new ApiException("Missing the required parameter 'archivedStatus' when calling conversationsIDStatusesPatch(Async)");
        }

        return conversationsIDStatusesPatchCall(ID, archivedStatus, _callback);

    }

    /**
     * 
     * Archive or unarchive a conversation that is with a user who exists within the same bubble.
     * @param ID  (required)
     * @param archivedStatus  (required)
     * @return EndpointPatchConversationsIDStatuses
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPatchConversationsIDStatuses conversationsIDStatusesPatch(Integer ID, Boolean archivedStatus) throws ApiException {
        ApiResponse<EndpointPatchConversationsIDStatuses> localVarResp = conversationsIDStatusesPatchWithHttpInfo(ID, archivedStatus);
        return localVarResp.getData();
    }

    /**
     * 
     * Archive or unarchive a conversation that is with a user who exists within the same bubble.
     * @param ID  (required)
     * @param archivedStatus  (required)
     * @return ApiResponse&lt;EndpointPatchConversationsIDStatuses&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPatchConversationsIDStatuses> conversationsIDStatusesPatchWithHttpInfo(Integer ID, Boolean archivedStatus) throws ApiException {
        okhttp3.Call localVarCall = conversationsIDStatusesPatchValidateBeforeCall(ID, archivedStatus, null);
        Type localVarReturnType = new TypeToken<EndpointPatchConversationsIDStatuses>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Archive or unarchive a conversation that is with a user who exists within the same bubble.
     * @param ID  (required)
     * @param archivedStatus  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsIDStatusesPatchAsync(Integer ID, Boolean archivedStatus, final ApiCallback<EndpointPatchConversationsIDStatuses> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsIDStatusesPatchValidateBeforeCall(ID, archivedStatus, _callback);
        Type localVarReturnType = new TypeToken<EndpointPatchConversationsIDStatuses>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsSchedulesPost
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsSchedulesPostCall(String date, Integer limit, Integer offset, Boolean rollUp, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/schedules";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (date != null) {
            localVarFormParams.put("date", date);
        }

        if (limit != null) {
            localVarFormParams.put("limit", limit);
        }

        if (offset != null) {
            localVarFormParams.put("offset", offset);
        }

        if (rollUp != null) {
            localVarFormParams.put("roll_up", rollUp);
        }

        if (sort != null) {
            localVarFormParams.put("sort", sort);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsSchedulesPostValidateBeforeCall(String date, Integer limit, Integer offset, Boolean rollUp, String sort, final ApiCallback _callback) throws ApiException {
        return conversationsSchedulesPostCall(date, limit, offset, rollUp, sort, _callback);

    }

    /**
     * 
     * Paginated report of information about messages contributed by conversation and date. Only conversations that exist within the current access token&#39;s bubble are considered in the calculations. Optionally roll up all conversations to retrieve one record per date. Optionally specify a date formatted as YYYY-MM-DD to retrieve information just from the single date, along with additional navigational information, which is useful when generating a transcript for a single day and wanting to reference the previous and next days there were messages.
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @return EndpointPostConversationsSchedules
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostConversationsSchedules conversationsSchedulesPost(String date, Integer limit, Integer offset, Boolean rollUp, String sort) throws ApiException {
        ApiResponse<EndpointPostConversationsSchedules> localVarResp = conversationsSchedulesPostWithHttpInfo(date, limit, offset, rollUp, sort);
        return localVarResp.getData();
    }

    /**
     * 
     * Paginated report of information about messages contributed by conversation and date. Only conversations that exist within the current access token&#39;s bubble are considered in the calculations. Optionally roll up all conversations to retrieve one record per date. Optionally specify a date formatted as YYYY-MM-DD to retrieve information just from the single date, along with additional navigational information, which is useful when generating a transcript for a single day and wanting to reference the previous and next days there were messages.
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @return ApiResponse&lt;EndpointPostConversationsSchedules&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostConversationsSchedules> conversationsSchedulesPostWithHttpInfo(String date, Integer limit, Integer offset, Boolean rollUp, String sort) throws ApiException {
        okhttp3.Call localVarCall = conversationsSchedulesPostValidateBeforeCall(date, limit, offset, rollUp, sort, null);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsSchedules>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Paginated report of information about messages contributed by conversation and date. Only conversations that exist within the current access token&#39;s bubble are considered in the calculations. Optionally roll up all conversations to retrieve one record per date. Optionally specify a date formatted as YYYY-MM-DD to retrieve information just from the single date, along with additional navigational information, which is useful when generating a transcript for a single day and wanting to reference the previous and next days there were messages.
     * @param date  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param rollUp  (optional, default to false)
     * @param sort  (optional, default to desc)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsSchedulesPostAsync(String date, Integer limit, Integer offset, Boolean rollUp, String sort, final ApiCallback<EndpointPostConversationsSchedules> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsSchedulesPostValidateBeforeCall(date, limit, offset, rollUp, sort, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsSchedules>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsSearchesPost
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsSearchesPostCall(String query, String date, Integer gtMessageId, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/searches";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (date != null) {
            localVarFormParams.put("date", date);
        }

        if (gtMessageId != null) {
            localVarFormParams.put("gt_message_id", gtMessageId);
        }

        if (limit != null) {
            localVarFormParams.put("limit", limit);
        }

        if (offset != null) {
            localVarFormParams.put("offset", offset);
        }

        if (query != null) {
            localVarFormParams.put("query", query);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsSearchesPostValidateBeforeCall(String query, String date, Integer gtMessageId, Integer limit, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling conversationsSearchesPost(Async)");
        }

        return conversationsSearchesPostCall(query, date, gtMessageId, limit, offset, _callback);

    }

    /**
     * 
     * Fetch messages authored from within the current bubble that match a query string passed in as a search parameter along with their relevancy score.
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @return EndpointPostConversationsSearches
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointPostConversationsSearches conversationsSearchesPost(String query, String date, Integer gtMessageId, Integer limit, Integer offset) throws ApiException {
        ApiResponse<EndpointPostConversationsSearches> localVarResp = conversationsSearchesPostWithHttpInfo(query, date, gtMessageId, limit, offset);
        return localVarResp.getData();
    }

    /**
     * 
     * Fetch messages authored from within the current bubble that match a query string passed in as a search parameter along with their relevancy score.
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @return ApiResponse&lt;EndpointPostConversationsSearches&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointPostConversationsSearches> conversationsSearchesPostWithHttpInfo(String query, String date, Integer gtMessageId, Integer limit, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = conversationsSearchesPostValidateBeforeCall(query, date, gtMessageId, limit, offset, null);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsSearches>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Fetch messages authored from within the current bubble that match a query string passed in as a search parameter along with their relevancy score.
     * @param query  (required)
     * @param date  (optional)
     * @param gtMessageId  (optional)
     * @param limit  (optional, default to 50)
     * @param offset  (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsSearchesPostAsync(String query, String date, Integer gtMessageId, Integer limit, Integer offset, final ApiCallback<EndpointPostConversationsSearches> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsSearchesPostValidateBeforeCall(query, date, gtMessageId, limit, offset, _callback);
        Type localVarReturnType = new TypeToken<EndpointPostConversationsSearches>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for conversationsStatusesGet
     * @param filter  (optional)
     * @param includeArchived  (optional, default to false)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsStatusesGetCall(String filter, Boolean includeArchived, Boolean bubbled, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations/statuses";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (includeArchived != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_archived", includeArchived));
        }

        if (bubbled != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bubbled", bubbled));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "implicit_flow", "explicit_flow" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call conversationsStatusesGetValidateBeforeCall(String filter, Boolean includeArchived, Boolean bubbled, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        return conversationsStatusesGetCall(filter, includeArchived, bubbled, offset, limit, _callback);

    }

    /**
     * 
     * Retrieve conversations that you are participating in with users who exists within the same bubble, along with your current relationship with the conversations. The user_a / user_b properties of the conversation are populated with as much data as is available if the user is not you. If the user is you, only the id field is populated. There is a separate status endpoint to retrieve relationship information for individual conversations. Optionally filter: &#39;new&#39; to only show conversations with messages you haven&#39;t yet seen; &#39;introductions&#39; to only show conversations where users have introduced themselves to you but nothing more; &#39;unreplied&#39; to only show conversations where you have introduced yourself to other users but nothing more; &#39;notifications&#39; to show all conversations where the other user was the last person to message. Optionally only show conversations engaging within the existing access token&#39;s bubble. This report is limited to your ~500-1000 most recently active conversations you&#39;ve engaged in within current the access token&#39;s bubble.
     * @param filter  (optional)
     * @param includeArchived  (optional, default to false)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return EndpointGetConversationsStatuses
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public EndpointGetConversationsStatuses conversationsStatusesGet(String filter, Boolean includeArchived, Boolean bubbled, Integer offset, Integer limit) throws ApiException {
        ApiResponse<EndpointGetConversationsStatuses> localVarResp = conversationsStatusesGetWithHttpInfo(filter, includeArchived, bubbled, offset, limit);
        return localVarResp.getData();
    }

    /**
     * 
     * Retrieve conversations that you are participating in with users who exists within the same bubble, along with your current relationship with the conversations. The user_a / user_b properties of the conversation are populated with as much data as is available if the user is not you. If the user is you, only the id field is populated. There is a separate status endpoint to retrieve relationship information for individual conversations. Optionally filter: &#39;new&#39; to only show conversations with messages you haven&#39;t yet seen; &#39;introductions&#39; to only show conversations where users have introduced themselves to you but nothing more; &#39;unreplied&#39; to only show conversations where you have introduced yourself to other users but nothing more; &#39;notifications&#39; to show all conversations where the other user was the last person to message. Optionally only show conversations engaging within the existing access token&#39;s bubble. This report is limited to your ~500-1000 most recently active conversations you&#39;ve engaged in within current the access token&#39;s bubble.
     * @param filter  (optional)
     * @param includeArchived  (optional, default to false)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @return ApiResponse&lt;EndpointGetConversationsStatuses&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EndpointGetConversationsStatuses> conversationsStatusesGetWithHttpInfo(String filter, Boolean includeArchived, Boolean bubbled, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = conversationsStatusesGetValidateBeforeCall(filter, includeArchived, bubbled, offset, limit, null);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsStatuses>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Retrieve conversations that you are participating in with users who exists within the same bubble, along with your current relationship with the conversations. The user_a / user_b properties of the conversation are populated with as much data as is available if the user is not you. If the user is you, only the id field is populated. There is a separate status endpoint to retrieve relationship information for individual conversations. Optionally filter: &#39;new&#39; to only show conversations with messages you haven&#39;t yet seen; &#39;introductions&#39; to only show conversations where users have introduced themselves to you but nothing more; &#39;unreplied&#39; to only show conversations where you have introduced yourself to other users but nothing more; &#39;notifications&#39; to show all conversations where the other user was the last person to message. Optionally only show conversations engaging within the existing access token&#39;s bubble. This report is limited to your ~500-1000 most recently active conversations you&#39;ve engaged in within current the access token&#39;s bubble.
     * @param filter  (optional)
     * @param includeArchived  (optional, default to false)
     * @param bubbled  (optional, default to false)
     * @param offset  (optional, default to 0)
     * @param limit  (optional, default to 50)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Valid Response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call conversationsStatusesGetAsync(String filter, Boolean includeArchived, Boolean bubbled, Integer offset, Integer limit, final ApiCallback<EndpointGetConversationsStatuses> _callback) throws ApiException {

        okhttp3.Call localVarCall = conversationsStatusesGetValidateBeforeCall(filter, includeArchived, bubbled, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<EndpointGetConversationsStatuses>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
