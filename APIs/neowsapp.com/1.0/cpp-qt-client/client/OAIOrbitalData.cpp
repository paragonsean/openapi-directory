/**
 * NeoWs - (Near Earth Object Web Service)
 * A web service for near earth objects. All the data is from the <a href=\"http://neo.jpl.nasa.gov/\" target=\"_blank\">NASA JPL Asteroid team</a>.      NeoWs is proud to power AsteroidTracker on <a href=\"https://itunes.apple.com/us/app/asteroid-tracker/id689684901?mt=8\" target=\"_blank\">iOS</a> and <a href=\"https://play.google.com/store/apps/details?id=com.vitruviussoftware.bunifish.asteroidtracker&feature\" target=\"_blank\">Android</a> as well as related apps.    Follow us on <a href=\"https://twitter.com/AsteroidTracker\" target=\"_blank\">Twitter</a>
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIOrbitalData.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIOrbitalData::OAIOrbitalData(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIOrbitalData::OAIOrbitalData() {
    this->initializeModel();
}

OAIOrbitalData::~OAIOrbitalData() {}

void OAIOrbitalData::initializeModel() {

    m_aphelion_distance_isSet = false;
    m_aphelion_distance_isValid = false;

    m_ascending_node_longitude_isSet = false;
    m_ascending_node_longitude_isValid = false;

    m_data_arc_in_days_isSet = false;
    m_data_arc_in_days_isValid = false;

    m_eccentricity_isSet = false;
    m_eccentricity_isValid = false;

    m_epoch_osculation_isSet = false;
    m_epoch_osculation_isValid = false;

    m_equinox_isSet = false;
    m_equinox_isValid = false;

    m_first_observation_date_isSet = false;
    m_first_observation_date_isValid = false;

    m_inclination_isSet = false;
    m_inclination_isValid = false;

    m_jupiter_tisserand_invariant_isSet = false;
    m_jupiter_tisserand_invariant_isValid = false;

    m_last_observation_date_isSet = false;
    m_last_observation_date_isValid = false;

    m_mean_anomaly_isSet = false;
    m_mean_anomaly_isValid = false;

    m_mean_motion_isSet = false;
    m_mean_motion_isValid = false;

    m_minimum_orbit_intersection_isSet = false;
    m_minimum_orbit_intersection_isValid = false;

    m_observations_used_isSet = false;
    m_observations_used_isValid = false;

    m_orbit_class_isSet = false;
    m_orbit_class_isValid = false;

    m_orbit_determination_date_isSet = false;
    m_orbit_determination_date_isValid = false;

    m_orbit_id_isSet = false;
    m_orbit_id_isValid = false;

    m_orbit_uncertainty_isSet = false;
    m_orbit_uncertainty_isValid = false;

    m_orbital_period_isSet = false;
    m_orbital_period_isValid = false;

    m_perihelion_argument_isSet = false;
    m_perihelion_argument_isValid = false;

    m_perihelion_distance_isSet = false;
    m_perihelion_distance_isValid = false;

    m_perihelion_time_isSet = false;
    m_perihelion_time_isValid = false;

    m_semi_major_axis_isSet = false;
    m_semi_major_axis_isValid = false;
}

void OAIOrbitalData::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIOrbitalData::fromJsonObject(QJsonObject json) {

    m_aphelion_distance_isValid = ::OpenAPI::fromJsonValue(m_aphelion_distance, json[QString("aphelion_distance")]);
    m_aphelion_distance_isSet = !json[QString("aphelion_distance")].isNull() && m_aphelion_distance_isValid;

    m_ascending_node_longitude_isValid = ::OpenAPI::fromJsonValue(m_ascending_node_longitude, json[QString("ascending_node_longitude")]);
    m_ascending_node_longitude_isSet = !json[QString("ascending_node_longitude")].isNull() && m_ascending_node_longitude_isValid;

    m_data_arc_in_days_isValid = ::OpenAPI::fromJsonValue(m_data_arc_in_days, json[QString("data_arc_in_days")]);
    m_data_arc_in_days_isSet = !json[QString("data_arc_in_days")].isNull() && m_data_arc_in_days_isValid;

    m_eccentricity_isValid = ::OpenAPI::fromJsonValue(m_eccentricity, json[QString("eccentricity")]);
    m_eccentricity_isSet = !json[QString("eccentricity")].isNull() && m_eccentricity_isValid;

    m_epoch_osculation_isValid = ::OpenAPI::fromJsonValue(m_epoch_osculation, json[QString("epoch_osculation")]);
    m_epoch_osculation_isSet = !json[QString("epoch_osculation")].isNull() && m_epoch_osculation_isValid;

    m_equinox_isValid = ::OpenAPI::fromJsonValue(m_equinox, json[QString("equinox")]);
    m_equinox_isSet = !json[QString("equinox")].isNull() && m_equinox_isValid;

    m_first_observation_date_isValid = ::OpenAPI::fromJsonValue(m_first_observation_date, json[QString("first_observation_date")]);
    m_first_observation_date_isSet = !json[QString("first_observation_date")].isNull() && m_first_observation_date_isValid;

    m_inclination_isValid = ::OpenAPI::fromJsonValue(m_inclination, json[QString("inclination")]);
    m_inclination_isSet = !json[QString("inclination")].isNull() && m_inclination_isValid;

    m_jupiter_tisserand_invariant_isValid = ::OpenAPI::fromJsonValue(m_jupiter_tisserand_invariant, json[QString("jupiter_tisserand_invariant")]);
    m_jupiter_tisserand_invariant_isSet = !json[QString("jupiter_tisserand_invariant")].isNull() && m_jupiter_tisserand_invariant_isValid;

    m_last_observation_date_isValid = ::OpenAPI::fromJsonValue(m_last_observation_date, json[QString("last_observation_date")]);
    m_last_observation_date_isSet = !json[QString("last_observation_date")].isNull() && m_last_observation_date_isValid;

    m_mean_anomaly_isValid = ::OpenAPI::fromJsonValue(m_mean_anomaly, json[QString("mean_anomaly")]);
    m_mean_anomaly_isSet = !json[QString("mean_anomaly")].isNull() && m_mean_anomaly_isValid;

    m_mean_motion_isValid = ::OpenAPI::fromJsonValue(m_mean_motion, json[QString("mean_motion")]);
    m_mean_motion_isSet = !json[QString("mean_motion")].isNull() && m_mean_motion_isValid;

    m_minimum_orbit_intersection_isValid = ::OpenAPI::fromJsonValue(m_minimum_orbit_intersection, json[QString("minimum_orbit_intersection")]);
    m_minimum_orbit_intersection_isSet = !json[QString("minimum_orbit_intersection")].isNull() && m_minimum_orbit_intersection_isValid;

    m_observations_used_isValid = ::OpenAPI::fromJsonValue(m_observations_used, json[QString("observations_used")]);
    m_observations_used_isSet = !json[QString("observations_used")].isNull() && m_observations_used_isValid;

    m_orbit_class_isValid = ::OpenAPI::fromJsonValue(m_orbit_class, json[QString("orbit_class")]);
    m_orbit_class_isSet = !json[QString("orbit_class")].isNull() && m_orbit_class_isValid;

    m_orbit_determination_date_isValid = ::OpenAPI::fromJsonValue(m_orbit_determination_date, json[QString("orbit_determination_date")]);
    m_orbit_determination_date_isSet = !json[QString("orbit_determination_date")].isNull() && m_orbit_determination_date_isValid;

    m_orbit_id_isValid = ::OpenAPI::fromJsonValue(m_orbit_id, json[QString("orbit_id")]);
    m_orbit_id_isSet = !json[QString("orbit_id")].isNull() && m_orbit_id_isValid;

    m_orbit_uncertainty_isValid = ::OpenAPI::fromJsonValue(m_orbit_uncertainty, json[QString("orbit_uncertainty")]);
    m_orbit_uncertainty_isSet = !json[QString("orbit_uncertainty")].isNull() && m_orbit_uncertainty_isValid;

    m_orbital_period_isValid = ::OpenAPI::fromJsonValue(m_orbital_period, json[QString("orbital_period")]);
    m_orbital_period_isSet = !json[QString("orbital_period")].isNull() && m_orbital_period_isValid;

    m_perihelion_argument_isValid = ::OpenAPI::fromJsonValue(m_perihelion_argument, json[QString("perihelion_argument")]);
    m_perihelion_argument_isSet = !json[QString("perihelion_argument")].isNull() && m_perihelion_argument_isValid;

    m_perihelion_distance_isValid = ::OpenAPI::fromJsonValue(m_perihelion_distance, json[QString("perihelion_distance")]);
    m_perihelion_distance_isSet = !json[QString("perihelion_distance")].isNull() && m_perihelion_distance_isValid;

    m_perihelion_time_isValid = ::OpenAPI::fromJsonValue(m_perihelion_time, json[QString("perihelion_time")]);
    m_perihelion_time_isSet = !json[QString("perihelion_time")].isNull() && m_perihelion_time_isValid;

    m_semi_major_axis_isValid = ::OpenAPI::fromJsonValue(m_semi_major_axis, json[QString("semi_major_axis")]);
    m_semi_major_axis_isSet = !json[QString("semi_major_axis")].isNull() && m_semi_major_axis_isValid;
}

QString OAIOrbitalData::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIOrbitalData::asJsonObject() const {
    QJsonObject obj;
    if (m_aphelion_distance_isSet) {
        obj.insert(QString("aphelion_distance"), ::OpenAPI::toJsonValue(m_aphelion_distance));
    }
    if (m_ascending_node_longitude_isSet) {
        obj.insert(QString("ascending_node_longitude"), ::OpenAPI::toJsonValue(m_ascending_node_longitude));
    }
    if (m_data_arc_in_days_isSet) {
        obj.insert(QString("data_arc_in_days"), ::OpenAPI::toJsonValue(m_data_arc_in_days));
    }
    if (m_eccentricity_isSet) {
        obj.insert(QString("eccentricity"), ::OpenAPI::toJsonValue(m_eccentricity));
    }
    if (m_epoch_osculation_isSet) {
        obj.insert(QString("epoch_osculation"), ::OpenAPI::toJsonValue(m_epoch_osculation));
    }
    if (m_equinox_isSet) {
        obj.insert(QString("equinox"), ::OpenAPI::toJsonValue(m_equinox));
    }
    if (m_first_observation_date_isSet) {
        obj.insert(QString("first_observation_date"), ::OpenAPI::toJsonValue(m_first_observation_date));
    }
    if (m_inclination_isSet) {
        obj.insert(QString("inclination"), ::OpenAPI::toJsonValue(m_inclination));
    }
    if (m_jupiter_tisserand_invariant_isSet) {
        obj.insert(QString("jupiter_tisserand_invariant"), ::OpenAPI::toJsonValue(m_jupiter_tisserand_invariant));
    }
    if (m_last_observation_date_isSet) {
        obj.insert(QString("last_observation_date"), ::OpenAPI::toJsonValue(m_last_observation_date));
    }
    if (m_mean_anomaly_isSet) {
        obj.insert(QString("mean_anomaly"), ::OpenAPI::toJsonValue(m_mean_anomaly));
    }
    if (m_mean_motion_isSet) {
        obj.insert(QString("mean_motion"), ::OpenAPI::toJsonValue(m_mean_motion));
    }
    if (m_minimum_orbit_intersection_isSet) {
        obj.insert(QString("minimum_orbit_intersection"), ::OpenAPI::toJsonValue(m_minimum_orbit_intersection));
    }
    if (m_observations_used_isSet) {
        obj.insert(QString("observations_used"), ::OpenAPI::toJsonValue(m_observations_used));
    }
    if (m_orbit_class.isSet()) {
        obj.insert(QString("orbit_class"), ::OpenAPI::toJsonValue(m_orbit_class));
    }
    if (m_orbit_determination_date_isSet) {
        obj.insert(QString("orbit_determination_date"), ::OpenAPI::toJsonValue(m_orbit_determination_date));
    }
    if (m_orbit_id_isSet) {
        obj.insert(QString("orbit_id"), ::OpenAPI::toJsonValue(m_orbit_id));
    }
    if (m_orbit_uncertainty_isSet) {
        obj.insert(QString("orbit_uncertainty"), ::OpenAPI::toJsonValue(m_orbit_uncertainty));
    }
    if (m_orbital_period_isSet) {
        obj.insert(QString("orbital_period"), ::OpenAPI::toJsonValue(m_orbital_period));
    }
    if (m_perihelion_argument_isSet) {
        obj.insert(QString("perihelion_argument"), ::OpenAPI::toJsonValue(m_perihelion_argument));
    }
    if (m_perihelion_distance_isSet) {
        obj.insert(QString("perihelion_distance"), ::OpenAPI::toJsonValue(m_perihelion_distance));
    }
    if (m_perihelion_time_isSet) {
        obj.insert(QString("perihelion_time"), ::OpenAPI::toJsonValue(m_perihelion_time));
    }
    if (m_semi_major_axis_isSet) {
        obj.insert(QString("semi_major_axis"), ::OpenAPI::toJsonValue(m_semi_major_axis));
    }
    return obj;
}

QString OAIOrbitalData::getAphelionDistance() const {
    return m_aphelion_distance;
}
void OAIOrbitalData::setAphelionDistance(const QString &aphelion_distance) {
    m_aphelion_distance = aphelion_distance;
    m_aphelion_distance_isSet = true;
}

bool OAIOrbitalData::is_aphelion_distance_Set() const{
    return m_aphelion_distance_isSet;
}

bool OAIOrbitalData::is_aphelion_distance_Valid() const{
    return m_aphelion_distance_isValid;
}

QString OAIOrbitalData::getAscendingNodeLongitude() const {
    return m_ascending_node_longitude;
}
void OAIOrbitalData::setAscendingNodeLongitude(const QString &ascending_node_longitude) {
    m_ascending_node_longitude = ascending_node_longitude;
    m_ascending_node_longitude_isSet = true;
}

bool OAIOrbitalData::is_ascending_node_longitude_Set() const{
    return m_ascending_node_longitude_isSet;
}

bool OAIOrbitalData::is_ascending_node_longitude_Valid() const{
    return m_ascending_node_longitude_isValid;
}

qint64 OAIOrbitalData::getDataArcInDays() const {
    return m_data_arc_in_days;
}
void OAIOrbitalData::setDataArcInDays(const qint64 &data_arc_in_days) {
    m_data_arc_in_days = data_arc_in_days;
    m_data_arc_in_days_isSet = true;
}

bool OAIOrbitalData::is_data_arc_in_days_Set() const{
    return m_data_arc_in_days_isSet;
}

bool OAIOrbitalData::is_data_arc_in_days_Valid() const{
    return m_data_arc_in_days_isValid;
}

QString OAIOrbitalData::getEccentricity() const {
    return m_eccentricity;
}
void OAIOrbitalData::setEccentricity(const QString &eccentricity) {
    m_eccentricity = eccentricity;
    m_eccentricity_isSet = true;
}

bool OAIOrbitalData::is_eccentricity_Set() const{
    return m_eccentricity_isSet;
}

bool OAIOrbitalData::is_eccentricity_Valid() const{
    return m_eccentricity_isValid;
}

QString OAIOrbitalData::getEpochOsculation() const {
    return m_epoch_osculation;
}
void OAIOrbitalData::setEpochOsculation(const QString &epoch_osculation) {
    m_epoch_osculation = epoch_osculation;
    m_epoch_osculation_isSet = true;
}

bool OAIOrbitalData::is_epoch_osculation_Set() const{
    return m_epoch_osculation_isSet;
}

bool OAIOrbitalData::is_epoch_osculation_Valid() const{
    return m_epoch_osculation_isValid;
}

QString OAIOrbitalData::getEquinox() const {
    return m_equinox;
}
void OAIOrbitalData::setEquinox(const QString &equinox) {
    m_equinox = equinox;
    m_equinox_isSet = true;
}

bool OAIOrbitalData::is_equinox_Set() const{
    return m_equinox_isSet;
}

bool OAIOrbitalData::is_equinox_Valid() const{
    return m_equinox_isValid;
}

QString OAIOrbitalData::getFirstObservationDate() const {
    return m_first_observation_date;
}
void OAIOrbitalData::setFirstObservationDate(const QString &first_observation_date) {
    m_first_observation_date = first_observation_date;
    m_first_observation_date_isSet = true;
}

bool OAIOrbitalData::is_first_observation_date_Set() const{
    return m_first_observation_date_isSet;
}

bool OAIOrbitalData::is_first_observation_date_Valid() const{
    return m_first_observation_date_isValid;
}

QString OAIOrbitalData::getInclination() const {
    return m_inclination;
}
void OAIOrbitalData::setInclination(const QString &inclination) {
    m_inclination = inclination;
    m_inclination_isSet = true;
}

bool OAIOrbitalData::is_inclination_Set() const{
    return m_inclination_isSet;
}

bool OAIOrbitalData::is_inclination_Valid() const{
    return m_inclination_isValid;
}

QString OAIOrbitalData::getJupiterTisserandInvariant() const {
    return m_jupiter_tisserand_invariant;
}
void OAIOrbitalData::setJupiterTisserandInvariant(const QString &jupiter_tisserand_invariant) {
    m_jupiter_tisserand_invariant = jupiter_tisserand_invariant;
    m_jupiter_tisserand_invariant_isSet = true;
}

bool OAIOrbitalData::is_jupiter_tisserand_invariant_Set() const{
    return m_jupiter_tisserand_invariant_isSet;
}

bool OAIOrbitalData::is_jupiter_tisserand_invariant_Valid() const{
    return m_jupiter_tisserand_invariant_isValid;
}

QString OAIOrbitalData::getLastObservationDate() const {
    return m_last_observation_date;
}
void OAIOrbitalData::setLastObservationDate(const QString &last_observation_date) {
    m_last_observation_date = last_observation_date;
    m_last_observation_date_isSet = true;
}

bool OAIOrbitalData::is_last_observation_date_Set() const{
    return m_last_observation_date_isSet;
}

bool OAIOrbitalData::is_last_observation_date_Valid() const{
    return m_last_observation_date_isValid;
}

QString OAIOrbitalData::getMeanAnomaly() const {
    return m_mean_anomaly;
}
void OAIOrbitalData::setMeanAnomaly(const QString &mean_anomaly) {
    m_mean_anomaly = mean_anomaly;
    m_mean_anomaly_isSet = true;
}

bool OAIOrbitalData::is_mean_anomaly_Set() const{
    return m_mean_anomaly_isSet;
}

bool OAIOrbitalData::is_mean_anomaly_Valid() const{
    return m_mean_anomaly_isValid;
}

QString OAIOrbitalData::getMeanMotion() const {
    return m_mean_motion;
}
void OAIOrbitalData::setMeanMotion(const QString &mean_motion) {
    m_mean_motion = mean_motion;
    m_mean_motion_isSet = true;
}

bool OAIOrbitalData::is_mean_motion_Set() const{
    return m_mean_motion_isSet;
}

bool OAIOrbitalData::is_mean_motion_Valid() const{
    return m_mean_motion_isValid;
}

QString OAIOrbitalData::getMinimumOrbitIntersection() const {
    return m_minimum_orbit_intersection;
}
void OAIOrbitalData::setMinimumOrbitIntersection(const QString &minimum_orbit_intersection) {
    m_minimum_orbit_intersection = minimum_orbit_intersection;
    m_minimum_orbit_intersection_isSet = true;
}

bool OAIOrbitalData::is_minimum_orbit_intersection_Set() const{
    return m_minimum_orbit_intersection_isSet;
}

bool OAIOrbitalData::is_minimum_orbit_intersection_Valid() const{
    return m_minimum_orbit_intersection_isValid;
}

qint64 OAIOrbitalData::getObservationsUsed() const {
    return m_observations_used;
}
void OAIOrbitalData::setObservationsUsed(const qint64 &observations_used) {
    m_observations_used = observations_used;
    m_observations_used_isSet = true;
}

bool OAIOrbitalData::is_observations_used_Set() const{
    return m_observations_used_isSet;
}

bool OAIOrbitalData::is_observations_used_Valid() const{
    return m_observations_used_isValid;
}

OAIOrbitClass OAIOrbitalData::getOrbitClass() const {
    return m_orbit_class;
}
void OAIOrbitalData::setOrbitClass(const OAIOrbitClass &orbit_class) {
    m_orbit_class = orbit_class;
    m_orbit_class_isSet = true;
}

bool OAIOrbitalData::is_orbit_class_Set() const{
    return m_orbit_class_isSet;
}

bool OAIOrbitalData::is_orbit_class_Valid() const{
    return m_orbit_class_isValid;
}

QString OAIOrbitalData::getOrbitDeterminationDate() const {
    return m_orbit_determination_date;
}
void OAIOrbitalData::setOrbitDeterminationDate(const QString &orbit_determination_date) {
    m_orbit_determination_date = orbit_determination_date;
    m_orbit_determination_date_isSet = true;
}

bool OAIOrbitalData::is_orbit_determination_date_Set() const{
    return m_orbit_determination_date_isSet;
}

bool OAIOrbitalData::is_orbit_determination_date_Valid() const{
    return m_orbit_determination_date_isValid;
}

QString OAIOrbitalData::getOrbitId() const {
    return m_orbit_id;
}
void OAIOrbitalData::setOrbitId(const QString &orbit_id) {
    m_orbit_id = orbit_id;
    m_orbit_id_isSet = true;
}

bool OAIOrbitalData::is_orbit_id_Set() const{
    return m_orbit_id_isSet;
}

bool OAIOrbitalData::is_orbit_id_Valid() const{
    return m_orbit_id_isValid;
}

QString OAIOrbitalData::getOrbitUncertainty() const {
    return m_orbit_uncertainty;
}
void OAIOrbitalData::setOrbitUncertainty(const QString &orbit_uncertainty) {
    m_orbit_uncertainty = orbit_uncertainty;
    m_orbit_uncertainty_isSet = true;
}

bool OAIOrbitalData::is_orbit_uncertainty_Set() const{
    return m_orbit_uncertainty_isSet;
}

bool OAIOrbitalData::is_orbit_uncertainty_Valid() const{
    return m_orbit_uncertainty_isValid;
}

QString OAIOrbitalData::getOrbitalPeriod() const {
    return m_orbital_period;
}
void OAIOrbitalData::setOrbitalPeriod(const QString &orbital_period) {
    m_orbital_period = orbital_period;
    m_orbital_period_isSet = true;
}

bool OAIOrbitalData::is_orbital_period_Set() const{
    return m_orbital_period_isSet;
}

bool OAIOrbitalData::is_orbital_period_Valid() const{
    return m_orbital_period_isValid;
}

QString OAIOrbitalData::getPerihelionArgument() const {
    return m_perihelion_argument;
}
void OAIOrbitalData::setPerihelionArgument(const QString &perihelion_argument) {
    m_perihelion_argument = perihelion_argument;
    m_perihelion_argument_isSet = true;
}

bool OAIOrbitalData::is_perihelion_argument_Set() const{
    return m_perihelion_argument_isSet;
}

bool OAIOrbitalData::is_perihelion_argument_Valid() const{
    return m_perihelion_argument_isValid;
}

QString OAIOrbitalData::getPerihelionDistance() const {
    return m_perihelion_distance;
}
void OAIOrbitalData::setPerihelionDistance(const QString &perihelion_distance) {
    m_perihelion_distance = perihelion_distance;
    m_perihelion_distance_isSet = true;
}

bool OAIOrbitalData::is_perihelion_distance_Set() const{
    return m_perihelion_distance_isSet;
}

bool OAIOrbitalData::is_perihelion_distance_Valid() const{
    return m_perihelion_distance_isValid;
}

QString OAIOrbitalData::getPerihelionTime() const {
    return m_perihelion_time;
}
void OAIOrbitalData::setPerihelionTime(const QString &perihelion_time) {
    m_perihelion_time = perihelion_time;
    m_perihelion_time_isSet = true;
}

bool OAIOrbitalData::is_perihelion_time_Set() const{
    return m_perihelion_time_isSet;
}

bool OAIOrbitalData::is_perihelion_time_Valid() const{
    return m_perihelion_time_isValid;
}

QString OAIOrbitalData::getSemiMajorAxis() const {
    return m_semi_major_axis;
}
void OAIOrbitalData::setSemiMajorAxis(const QString &semi_major_axis) {
    m_semi_major_axis = semi_major_axis;
    m_semi_major_axis_isSet = true;
}

bool OAIOrbitalData::is_semi_major_axis_Set() const{
    return m_semi_major_axis_isSet;
}

bool OAIOrbitalData::is_semi_major_axis_Valid() const{
    return m_semi_major_axis_isValid;
}

bool OAIOrbitalData::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_aphelion_distance_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ascending_node_longitude_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_arc_in_days_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_eccentricity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_epoch_osculation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_equinox_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_first_observation_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_inclination_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_jupiter_tisserand_invariant_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_observation_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mean_anomaly_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mean_motion_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_minimum_orbit_intersection_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_observations_used_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_orbit_class.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_orbit_determination_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_orbit_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_orbit_uncertainty_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_orbital_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_perihelion_argument_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_perihelion_distance_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_perihelion_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_semi_major_axis_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIOrbitalData::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
