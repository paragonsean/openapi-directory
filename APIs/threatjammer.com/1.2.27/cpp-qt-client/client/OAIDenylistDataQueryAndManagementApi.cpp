/**
 * ThreatJammer.com User API
 *  The public API open to the users. [Read the docs and learn more.](https://threatjammer.com/docs).  ## General information  ### Description Threat Jammer supports two end-user REST APIs: the User API and the Report API. The end-user uses the User API to interact with the different databases, heuristics, and machine learning processes. Devices use the Report API to interact with Threat Jammer. This document will explain how to use the User API and interact with the different services, create a token, interpret the quota information, and create the HTTP request to interact with the User API.  ### Authentication The API is protected by a **Bearer authentication** schema. **Bearer authentication** (also called **token authentication**) is an HTTP authentication scheme that involves security tokens called bearer tokens. It is used to authenticate the user. All the different endpoints expect a `Bearer` token in the `Authorization` header.  Example:  ``` curl -X 'GET'   'https://dublin.api.threatjammer.com/test'   -H 'accept: application/json'   -H 'Authorization: Bearer YOUR_API_KEY' ```  You can obtain a token after registering on the [ThreatJammer.com](https://threatjammer.com) website for free.   ### Region specific tokens All the `Bearer` tokens contain information about the authorized region. The developers have to use a token created for the region they want to use. A token used in a different region will return a `401 Unauthorized` error.  ### Global errors  The API will return the following permanent errors: - a `401 Unauthorized` error if the token is not valid, or does not belong to the region. - a `401 Unauthorized` error if the token does not exist. - a `401 Unauthorized` error if the token is malformed. - a `403 Forbidden` error if the subscription level is not enough. Some endpoints are only available for paid subscription levels.  And these temporary errors: - a `429 Too Many Requests` error if the quota is exceeded (see below).  ### Quota limits  **Every request to the User API will consume one (1) quota point.**  The API has two rate limiting processes: - a quota limit of **5000** requests per month for the `FREE` account. The limit is reset every month. - a quota limit of **10** requests per minute for the `FREE` account. The limit is reset every minute and implements a sliding window mechanism.  
 *
 * The version of the OpenAPI document: 1.2.27
 * Contact: support@threatjammer.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDenylistDataQueryAndManagementApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIDenylistDataQueryAndManagementApi::OAIDenylistDataQueryAndManagementApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIDenylistDataQueryAndManagementApi::~OAIDenylistDataQueryAndManagementApi() {
}

void OAIDenylistDataQueryAndManagementApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("changeStatusOfTheDenylistV1DenylistPublicDenylistIdPut", defaultConf);
    _serverIndices.insert("changeStatusOfTheDenylistV1DenylistPublicDenylistIdPut", 0);
    _serverConfigs.insert("changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPut", defaultConf);
    _serverIndices.insert("changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPut", 0);
    _serverConfigs.insert("changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPut", defaultConf);
    _serverIndices.insert("changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPut", 0);
    _serverConfigs.insert("createPrivateDenylistOfTheUserV1DenylistPrivatePost", defaultConf);
    _serverIndices.insert("createPrivateDenylistOfTheUserV1DenylistPrivatePost", 0);
    _serverConfigs.insert("deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDelete", defaultConf);
    _serverIndices.insert("deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDelete", 0);
    _serverConfigs.insert("deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDelete", defaultConf);
    _serverIndices.insert("deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDelete", 0);
    _serverConfigs.insert("deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDelete", defaultConf);
    _serverIndices.insert("deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDelete", 0);
    _serverConfigs.insert("deleteTheDenylistV1DenylistPrivateDenylistIdDelete", defaultConf);
    _serverIndices.insert("deleteTheDenylistV1DenylistPrivateDenylistIdDelete", 0);
    _serverConfigs.insert("deleteTheDenylistV1DenylistPublicDenylistIdDelete", defaultConf);
    _serverIndices.insert("deleteTheDenylistV1DenylistPublicDenylistIdDelete", 0);
    _serverConfigs.insert("getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGet", defaultConf);
    _serverIndices.insert("getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGet", 0);
    _serverConfigs.insert("getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGet", defaultConf);
    _serverIndices.insert("getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGet", 0);
    _serverConfigs.insert("getAllPrivateDenylistsV1DenylistPrivateAllGet", defaultConf);
    _serverIndices.insert("getAllPrivateDenylistsV1DenylistPrivateAllGet", 0);
    _serverConfigs.insert("getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGet", defaultConf);
    _serverIndices.insert("getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGet", 0);
    _serverConfigs.insert("getAllPublicDenylistsV1DenylistPublicAllGet", defaultConf);
    _serverIndices.insert("getAllPublicDenylistsV1DenylistPublicAllGet", 0);
    _serverConfigs.insert("getDenylistContentV1DenylistPrivateDenylistIdContentGet", defaultConf);
    _serverIndices.insert("getDenylistContentV1DenylistPrivateDenylistIdContentGet", 0);
    _serverConfigs.insert("getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGet", defaultConf);
    _serverIndices.insert("getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGet", 0);
    _serverConfigs.insert("getSingleDenylistV1DenylistPrivateDenylistIdGet", defaultConf);
    _serverIndices.insert("getSingleDenylistV1DenylistPrivateDenylistIdGet", 0);
    _serverConfigs.insert("getSingleDenylistV1DenylistPublicDenylistIdGet", defaultConf);
    _serverIndices.insert("getSingleDenylistV1DenylistPublicDenylistIdGet", 0);
    _serverConfigs.insert("queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGet", defaultConf);
    _serverIndices.insert("queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGet", 0);
    _serverConfigs.insert("queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGet", defaultConf);
    _serverIndices.insert("queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGet", 0);
    _serverConfigs.insert("queryResourceDenylistsV1DenylistPrivateIpAddressGet", defaultConf);
    _serverIndices.insert("queryResourceDenylistsV1DenylistPrivateIpAddressGet", 0);
    _serverConfigs.insert("queryResourceDenylistsV1DenylistPublicIpAddressGet", defaultConf);
    _serverIndices.insert("queryResourceDenylistsV1DenylistPublicIpAddressGet", 0);
    _serverConfigs.insert("updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPut", defaultConf);
    _serverIndices.insert("updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPut", 0);
    _serverConfigs.insert("updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPut", defaultConf);
    _serverIndices.insert("updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPut", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIDenylistDataQueryAndManagementApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIDenylistDataQueryAndManagementApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIDenylistDataQueryAndManagementApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIDenylistDataQueryAndManagementApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIDenylistDataQueryAndManagementApi::setUsername(const QString &username) {
    _username = username;
}

void OAIDenylistDataQueryAndManagementApi::setPassword(const QString &password) {
    _password = password;
}


void OAIDenylistDataQueryAndManagementApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIDenylistDataQueryAndManagementApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIDenylistDataQueryAndManagementApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIDenylistDataQueryAndManagementApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDenylistDataQueryAndManagementApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDenylistDataQueryAndManagementApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIDenylistDataQueryAndManagementApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIDenylistDataQueryAndManagementApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIDenylistDataQueryAndManagementApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIDenylistDataQueryAndManagementApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIDenylistDataQueryAndManagementApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIDenylistDataQueryAndManagementApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIDenylistDataQueryAndManagementApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIDenylistDataQueryAndManagementApi::changeStatusOfTheDenylistV1DenylistPublicDenylistIdPut(const QString &denylist_id, const OAIBody_change_status_of_the_denylist_v1_denylist_public__denylist_id__put &oai_body_change_status_of_the_denylist_v1_denylist_public__denylist_id__put) {
    QString fullPath = QString(_serverConfigs["changeStatusOfTheDenylistV1DenylistPublicDenylistIdPut"][_serverIndices.value("changeStatusOfTheDenylistV1DenylistPublicDenylistIdPut")].URL()+"/v1/denylist/public/{denylist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body_change_status_of_the_denylist_v1_denylist_public__denylist_id__put.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutSignal(output);
        Q_EMIT changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutSignalE(output, error_type, error_str);
        Q_EMIT changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutSignalError(output, error_type, error_str);
        Q_EMIT changeStatusOfTheDenylistV1DenylistPublicDenylistIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPut(const QString &denylist_id, const OAIBody_change_status_of_the_origin_denylist_v1_denylist_private__denylist_id__origin_put &oai_body_change_status_of_the_origin_denylist_v1_denylist_private__denylist_id__origin_put) {
    QString fullPath = QString(_serverConfigs["changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPut"][_serverIndices.value("changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPut")].URL()+"/v1/denylist/private/{denylist_id}/origin");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body_change_status_of_the_origin_denylist_v1_denylist_private__denylist_id__origin_put.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutSignal(output);
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutSignalE(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutSignalError(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPrivateDenylistIdOriginPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPut(const QString &denylist_id, const OAIBody_change_status_of_the_origin_denylist_v1_denylist_public__denylist_id__origin_put &oai_body_change_status_of_the_origin_denylist_v1_denylist_public__denylist_id__origin_put) {
    QString fullPath = QString(_serverConfigs["changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPut"][_serverIndices.value("changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPut")].URL()+"/v1/denylist/public/{denylist_id}/origin");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body_change_status_of_the_origin_denylist_v1_denylist_public__denylist_id__origin_put.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutSignal(output);
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutSignalE(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutSignalError(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginDenylistV1DenylistPublicDenylistIdOriginPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::createPrivateDenylistOfTheUserV1DenylistPrivatePost(const OAIBody_create_private_denylist_of_the_user_v1_denylist_private_post &oai_body_create_private_denylist_of_the_user_v1_denylist_private_post) {
    QString fullPath = QString(_serverConfigs["createPrivateDenylistOfTheUserV1DenylistPrivatePost"][_serverIndices.value("createPrivateDenylistOfTheUserV1DenylistPrivatePost")].URL()+"/v1/denylist/private");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_body_create_private_denylist_of_the_user_v1_denylist_private_post.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::createPrivateDenylistOfTheUserV1DenylistPrivatePostCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::createPrivateDenylistOfTheUserV1DenylistPrivatePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createPrivateDenylistOfTheUserV1DenylistPrivatePostSignal(output);
        Q_EMIT createPrivateDenylistOfTheUserV1DenylistPrivatePostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createPrivateDenylistOfTheUserV1DenylistPrivatePostSignalE(output, error_type, error_str);
        Q_EMIT createPrivateDenylistOfTheUserV1DenylistPrivatePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createPrivateDenylistOfTheUserV1DenylistPrivatePostSignalError(output, error_type, error_str);
        Q_EMIT createPrivateDenylistOfTheUserV1DenylistPrivatePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDelete() {
    QString fullPath = QString(_serverConfigs["deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDelete"][_serverIndices.value("deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDelete")].URL()+"/v1/denylist/reported/ip/all");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteSignal(output);
        Q_EMIT deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteAllIpAddressesReportedByTheUserV1DenylistReportedIpAllDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDelete(const QString &ip_address) {
    QString fullPath = QString(_serverConfigs["deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDelete"][_serverIndices.value("deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDelete")].URL()+"/v1/denylist/reported/ip/{ip_address}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString ip_addressPathParam("{");
        ip_addressPathParam.append("ip_address").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "ip_address", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"ip_address"+pathSuffix : pathPrefix;
        fullPath.replace(ip_addressPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(ip_address)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteSignal(output);
        Q_EMIT deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteAnIpAddressReportedByTheUserV1DenylistReportedIpIpAddressDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDelete(const QString &denylist_id) {
    QString fullPath = QString(_serverConfigs["deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDelete"][_serverIndices.value("deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDelete")].URL()+"/v1/denylist/private/{denylist_id}/content");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteSignal(output);
        Q_EMIT deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteTheDenylistContentV1DenylistPrivateDenylistIdContentDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::deleteTheDenylistV1DenylistPrivateDenylistIdDelete(const QString &denylist_id) {
    QString fullPath = QString(_serverConfigs["deleteTheDenylistV1DenylistPrivateDenylistIdDelete"][_serverIndices.value("deleteTheDenylistV1DenylistPrivateDenylistIdDelete")].URL()+"/v1/denylist/private/{denylist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::deleteTheDenylistV1DenylistPrivateDenylistIdDeleteCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::deleteTheDenylistV1DenylistPrivateDenylistIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTheDenylistV1DenylistPrivateDenylistIdDeleteSignal(output);
        Q_EMIT deleteTheDenylistV1DenylistPrivateDenylistIdDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTheDenylistV1DenylistPrivateDenylistIdDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteTheDenylistV1DenylistPrivateDenylistIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTheDenylistV1DenylistPrivateDenylistIdDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteTheDenylistV1DenylistPrivateDenylistIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::deleteTheDenylistV1DenylistPublicDenylistIdDelete(const QString &denylist_id) {
    QString fullPath = QString(_serverConfigs["deleteTheDenylistV1DenylistPublicDenylistIdDelete"][_serverIndices.value("deleteTheDenylistV1DenylistPublicDenylistIdDelete")].URL()+"/v1/denylist/public/{denylist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::deleteTheDenylistV1DenylistPublicDenylistIdDeleteCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::deleteTheDenylistV1DenylistPublicDenylistIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTheDenylistV1DenylistPublicDenylistIdDeleteSignal(output);
        Q_EMIT deleteTheDenylistV1DenylistPublicDenylistIdDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTheDenylistV1DenylistPublicDenylistIdDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteTheDenylistV1DenylistPublicDenylistIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTheDenylistV1DenylistPublicDenylistIdDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteTheDenylistV1DenylistPublicDenylistIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGet(const QString &resource_type) {
    QString fullPath = QString(_serverConfigs["getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGet"][_serverIndices.value("getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGet")].URL()+"/v1/denylist/public/owned/{resource_type}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString resource_typePathParam("{");
        resource_typePathParam.append("resource_type").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "resource_type", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"resource_type"+pathSuffix : pathPrefix;
        fullPath.replace(resource_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(resource_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetSignal(output);
        Q_EMIT getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetSignalE(output, error_type, error_str);
        Q_EMIT getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetSignalError(output, error_type, error_str);
        Q_EMIT getAllOwnedDenylistsByResourceTypeV1DenylistPublicOwnedResourceTypeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGet(const QString &resource_type) {
    QString fullPath = QString(_serverConfigs["getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGet"][_serverIndices.value("getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGet")].URL()+"/v1/denylist/private/all/{resource_type}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString resource_typePathParam("{");
        resource_typePathParam.append("resource_type").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "resource_type", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"resource_type"+pathSuffix : pathPrefix;
        fullPath.replace(resource_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(resource_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetSignal(output);
        Q_EMIT getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPrivateDenylistsByResourceTypeV1DenylistPrivateAllResourceTypeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getAllPrivateDenylistsV1DenylistPrivateAllGet() {
    QString fullPath = QString(_serverConfigs["getAllPrivateDenylistsV1DenylistPrivateAllGet"][_serverIndices.value("getAllPrivateDenylistsV1DenylistPrivateAllGet")].URL()+"/v1/denylist/private/all");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getAllPrivateDenylistsV1DenylistPrivateAllGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getAllPrivateDenylistsV1DenylistPrivateAllGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPrivateDenylistsV1DenylistPrivateAllGetSignal(output);
        Q_EMIT getAllPrivateDenylistsV1DenylistPrivateAllGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPrivateDenylistsV1DenylistPrivateAllGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPrivateDenylistsV1DenylistPrivateAllGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPrivateDenylistsV1DenylistPrivateAllGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPrivateDenylistsV1DenylistPrivateAllGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGet(const QString &resource_type) {
    QString fullPath = QString(_serverConfigs["getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGet"][_serverIndices.value("getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGet")].URL()+"/v1/denylist/public/all/{resource_type}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString resource_typePathParam("{");
        resource_typePathParam.append("resource_type").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "resource_type", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"resource_type"+pathSuffix : pathPrefix;
        fullPath.replace(resource_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(resource_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetSignal(output);
        Q_EMIT getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPublicDenylistsByResourceTypeV1DenylistPublicAllResourceTypeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getAllPublicDenylistsV1DenylistPublicAllGet() {
    QString fullPath = QString(_serverConfigs["getAllPublicDenylistsV1DenylistPublicAllGet"][_serverIndices.value("getAllPublicDenylistsV1DenylistPublicAllGet")].URL()+"/v1/denylist/public/all");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getAllPublicDenylistsV1DenylistPublicAllGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getAllPublicDenylistsV1DenylistPublicAllGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPublicDenylistsV1DenylistPublicAllGetSignal(output);
        Q_EMIT getAllPublicDenylistsV1DenylistPublicAllGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPublicDenylistsV1DenylistPublicAllGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPublicDenylistsV1DenylistPublicAllGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPublicDenylistsV1DenylistPublicAllGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPublicDenylistsV1DenylistPublicAllGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getDenylistContentV1DenylistPrivateDenylistIdContentGet(const QString &denylist_id, const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &page_size) {
    QString fullPath = QString(_serverConfigs["getDenylistContentV1DenylistPrivateDenylistIdContentGet"][_serverIndices.value("getDenylistContentV1DenylistPrivateDenylistIdContentGet")].URL()+"/v1/denylist/private/{denylist_id}/content");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (page_size.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page_size", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page_size")).append(querySuffix).append(QUrl::toPercentEncoding(page_size.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getDenylistContentV1DenylistPrivateDenylistIdContentGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getDenylistContentV1DenylistPrivateDenylistIdContentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getDenylistContentV1DenylistPrivateDenylistIdContentGetSignal(output);
        Q_EMIT getDenylistContentV1DenylistPrivateDenylistIdContentGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getDenylistContentV1DenylistPrivateDenylistIdContentGetSignalE(output, error_type, error_str);
        Q_EMIT getDenylistContentV1DenylistPrivateDenylistIdContentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getDenylistContentV1DenylistPrivateDenylistIdContentGetSignalError(output, error_type, error_str);
        Q_EMIT getDenylistContentV1DenylistPrivateDenylistIdContentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGet() {
    QString fullPath = QString(_serverConfigs["getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGet"][_serverIndices.value("getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGet")].URL()+"/v1/denylist/public/owned");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetSignal(output);
        Q_EMIT getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetSignalE(output, error_type, error_str);
        Q_EMIT getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetSignalError(output, error_type, error_str);
        Q_EMIT getPublicDenylistsOwnedByTheUserV1DenylistPublicOwnedGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getSingleDenylistV1DenylistPrivateDenylistIdGet(const QString &denylist_id) {
    QString fullPath = QString(_serverConfigs["getSingleDenylistV1DenylistPrivateDenylistIdGet"][_serverIndices.value("getSingleDenylistV1DenylistPrivateDenylistIdGet")].URL()+"/v1/denylist/private/{denylist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getSingleDenylistV1DenylistPrivateDenylistIdGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getSingleDenylistV1DenylistPrivateDenylistIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclGroupListOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSingleDenylistV1DenylistPrivateDenylistIdGetSignal(output);
        Q_EMIT getSingleDenylistV1DenylistPrivateDenylistIdGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSingleDenylistV1DenylistPrivateDenylistIdGetSignalE(output, error_type, error_str);
        Q_EMIT getSingleDenylistV1DenylistPrivateDenylistIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSingleDenylistV1DenylistPrivateDenylistIdGetSignalError(output, error_type, error_str);
        Q_EMIT getSingleDenylistV1DenylistPrivateDenylistIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::getSingleDenylistV1DenylistPublicDenylistIdGet(const QString &denylist_id) {
    QString fullPath = QString(_serverConfigs["getSingleDenylistV1DenylistPublicDenylistIdGet"][_serverIndices.value("getSingleDenylistV1DenylistPublicDenylistIdGet")].URL()+"/v1/denylist/public/{denylist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::getSingleDenylistV1DenylistPublicDenylistIdGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::getSingleDenylistV1DenylistPublicDenylistIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSingleDenylistV1DenylistPublicDenylistIdGetSignal(output);
        Q_EMIT getSingleDenylistV1DenylistPublicDenylistIdGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSingleDenylistV1DenylistPublicDenylistIdGetSignalE(output, error_type, error_str);
        Q_EMIT getSingleDenylistV1DenylistPublicDenylistIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSingleDenylistV1DenylistPublicDenylistIdGetSignalError(output, error_type, error_str);
        Q_EMIT getSingleDenylistV1DenylistPublicDenylistIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGet(const ::OpenAPI::OptionalParam<QString> &dataset, const ::OpenAPI::OptionalParam<qint32> &reported_before, const ::OpenAPI::OptionalParam<qint32> &reported_after, const ::OpenAPI::OptionalParam<qint32> &expires_before, const ::OpenAPI::OptionalParam<qint32> &expires_after, const ::OpenAPI::OptionalParam<qint32> &greater_than, const ::OpenAPI::OptionalParam<qint32> &less_than, const ::OpenAPI::OptionalParam<QString> &ip_protocol_version, const ::OpenAPI::OptionalParam<QString> &output_format) {
    QString fullPath = QString(_serverConfigs["queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGet"][_serverIndices.value("queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGet")].URL()+"/v1/denylist/reported/ip");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (dataset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "dataset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("dataset")).append(querySuffix).append(QUrl::toPercentEncoding(dataset.stringValue()));
    }
    if (reported_before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "reported_before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("reported_before")).append(querySuffix).append(QUrl::toPercentEncoding(reported_before.stringValue()));
    }
    if (reported_after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "reported_after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("reported_after")).append(querySuffix).append(QUrl::toPercentEncoding(reported_after.stringValue()));
    }
    if (expires_before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "expires_before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("expires_before")).append(querySuffix).append(QUrl::toPercentEncoding(expires_before.stringValue()));
    }
    if (expires_after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "expires_after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("expires_after")).append(querySuffix).append(QUrl::toPercentEncoding(expires_after.stringValue()));
    }
    if (greater_than.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "greater_than", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("greater_than")).append(querySuffix).append(QUrl::toPercentEncoding(greater_than.stringValue()));
    }
    if (less_than.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "less_than", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("less_than")).append(querySuffix).append(QUrl::toPercentEncoding(less_than.stringValue()));
    }
    if (ip_protocol_version.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "ip_protocol_version", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("ip_protocol_version")).append(querySuffix).append(QUrl::toPercentEncoding(ip_protocol_version.stringValue()));
    }
    if (output_format.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "output_format", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("output_format")).append(querySuffix).append(QUrl::toPercentEncoding(output_format.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIPListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetSignal(output);
        Q_EMIT queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetSignalE(output, error_type, error_str);
        Q_EMIT queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetSignalError(output, error_type, error_str);
        Q_EMIT queryAllTheIpAddressesReportedByTheUserV1DenylistReportedIpGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGet(const QString &ip_address) {
    QString fullPath = QString(_serverConfigs["queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGet"][_serverIndices.value("queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGet")].URL()+"/v1/denylist/reported/ip/{ip_address}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString ip_addressPathParam("{");
        ip_addressPathParam.append("ip_address").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "ip_address", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"ip_address"+pathSuffix : pathPrefix;
        fullPath.replace(ip_addressPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(ip_address)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIPListOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetSignal(output);
        Q_EMIT queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetSignalE(output, error_type, error_str);
        Q_EMIT queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetSignalError(output, error_type, error_str);
        Q_EMIT queryAnIpAddressesReportedByTheUserV1DenylistReportedIpIpAddressGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::queryResourceDenylistsV1DenylistPrivateIpAddressGet(const OAIAddress &address) {
    QString fullPath = QString(_serverConfigs["queryResourceDenylistsV1DenylistPrivateIpAddressGet"][_serverIndices.value("queryResourceDenylistsV1DenylistPrivateIpAddressGet")].URL()+"/v1/denylist/private/ip/{address}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString addressPathParam("{");
        addressPathParam.append("address").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "address", false);
        QString paramString = (pathStyle == "matrix" && false) ? pathPrefix : pathPrefix+"address"+pathSuffix;
        QJsonObject parameter = address.asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                pathDelimiter = (pathStyle == "matrix" && false) ? ";" : getParamStyleDelimiter(pathStyle, key, false);
                paramString.append(pathDelimiter);
            }
            QString assignOperator = (false) ? "=" : ",";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(key+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(key+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.replace(addressPathParam, QUrl::toPercentEncoding(paramString));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::queryResourceDenylistsV1DenylistPrivateIpAddressGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::queryResourceDenylistsV1DenylistPrivateIpAddressGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAclListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryResourceDenylistsV1DenylistPrivateIpAddressGetSignal(output);
        Q_EMIT queryResourceDenylistsV1DenylistPrivateIpAddressGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryResourceDenylistsV1DenylistPrivateIpAddressGetSignalE(output, error_type, error_str);
        Q_EMIT queryResourceDenylistsV1DenylistPrivateIpAddressGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryResourceDenylistsV1DenylistPrivateIpAddressGetSignalError(output, error_type, error_str);
        Q_EMIT queryResourceDenylistsV1DenylistPrivateIpAddressGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::queryResourceDenylistsV1DenylistPublicIpAddressGet(const OAIAddress &address) {
    QString fullPath = QString(_serverConfigs["queryResourceDenylistsV1DenylistPublicIpAddressGet"][_serverIndices.value("queryResourceDenylistsV1DenylistPublicIpAddressGet")].URL()+"/v1/denylist/public/ip/{address}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString addressPathParam("{");
        addressPathParam.append("address").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "address", false);
        QString paramString = (pathStyle == "matrix" && false) ? pathPrefix : pathPrefix+"address"+pathSuffix;
        QJsonObject parameter = address.asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                pathDelimiter = (pathStyle == "matrix" && false) ? ";" : getParamStyleDelimiter(pathStyle, key, false);
                paramString.append(pathDelimiter);
            }
            QString assignOperator = (false) ? "=" : ",";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(key+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(key+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.replace(addressPathParam, QUrl::toPercentEncoding(paramString));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::queryResourceDenylistsV1DenylistPublicIpAddressGetCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::queryResourceDenylistsV1DenylistPublicIpAddressGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAclListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryResourceDenylistsV1DenylistPublicIpAddressGetSignal(output);
        Q_EMIT queryResourceDenylistsV1DenylistPublicIpAddressGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryResourceDenylistsV1DenylistPublicIpAddressGetSignalE(output, error_type, error_str);
        Q_EMIT queryResourceDenylistsV1DenylistPublicIpAddressGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryResourceDenylistsV1DenylistPublicIpAddressGetSignalError(output, error_type, error_str);
        Q_EMIT queryResourceDenylistsV1DenylistPublicIpAddressGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPut(const QString &denylist_id, const ::OpenAPI::OptionalParam<OAIBody_update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_put> &oai_body_update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_put) {
    QString fullPath = QString(_serverConfigs["updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPut"][_serverIndices.value("updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPut")].URL()+"/v1/denylist/private/{denylist_id}/content");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_body_update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_put.hasValue()){

        
        QByteArray output = oai_body_update_private_content_of_the_denylist_of_the_user_v1_denylist_private__denylist_id__content_put.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutSignal(output);
        Q_EMIT updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutSignalE(output, error_type, error_str);
        Q_EMIT updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutSignalError(output, error_type, error_str);
        Q_EMIT updatePrivateContentOfTheDenylistOfTheUserV1DenylistPrivateDenylistIdContentPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPut(const QString &denylist_id, const ::OpenAPI::OptionalParam<OAIBody_update_private_denylist_of_the_user_v1_denylist_private__denylist_id__put> &oai_body_update_private_denylist_of_the_user_v1_denylist_private__denylist_id__put) {
    QString fullPath = QString(_serverConfigs["updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPut"][_serverIndices.value("updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPut")].URL()+"/v1/denylist/private/{denylist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString denylist_idPathParam("{");
        denylist_idPathParam.append("denylist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "denylist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"denylist_id"+pathSuffix : pathPrefix;
        fullPath.replace(denylist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(denylist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_body_update_private_denylist_of_the_user_v1_denylist_private__denylist_id__put.hasValue()){

        
        QByteArray output = oai_body_update_private_denylist_of_the_user_v1_denylist_private__denylist_id__put.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDenylistDataQueryAndManagementApi::updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutCallback);
    connect(this, &OAIDenylistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDenylistDataQueryAndManagementApi::updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutSignal(output);
        Q_EMIT updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutSignalE(output, error_type, error_str);
        Q_EMIT updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutSignalError(output, error_type, error_str);
        Q_EMIT updatePrivateDenylistOfTheUserV1DenylistPrivateDenylistIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDenylistDataQueryAndManagementApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
