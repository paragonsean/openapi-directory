/**
 * ThreatJammer.com User API
 *  The public API open to the users. [Read the docs and learn more.](https://threatjammer.com/docs).  ## General information  ### Description Threat Jammer supports two end-user REST APIs: the User API and the Report API. The end-user uses the User API to interact with the different databases, heuristics, and machine learning processes. Devices use the Report API to interact with Threat Jammer. This document will explain how to use the User API and interact with the different services, create a token, interpret the quota information, and create the HTTP request to interact with the User API.  ### Authentication The API is protected by a **Bearer authentication** schema. **Bearer authentication** (also called **token authentication**) is an HTTP authentication scheme that involves security tokens called bearer tokens. It is used to authenticate the user. All the different endpoints expect a `Bearer` token in the `Authorization` header.  Example:  ``` curl -X 'GET'   'https://dublin.api.threatjammer.com/test'   -H 'accept: application/json'   -H 'Authorization: Bearer YOUR_API_KEY' ```  You can obtain a token after registering on the [ThreatJammer.com](https://threatjammer.com) website for free.   ### Region specific tokens All the `Bearer` tokens contain information about the authorized region. The developers have to use a token created for the region they want to use. A token used in a different region will return a `401 Unauthorized` error.  ### Global errors  The API will return the following permanent errors: - a `401 Unauthorized` error if the token is not valid, or does not belong to the region. - a `401 Unauthorized` error if the token does not exist. - a `401 Unauthorized` error if the token is malformed. - a `403 Forbidden` error if the subscription level is not enough. Some endpoints are only available for paid subscription levels.  And these temporary errors: - a `429 Too Many Requests` error if the quota is exceeded (see below).  ### Quota limits  **Every request to the User API will consume one (1) quota point.**  The API has two rate limiting processes: - a quota limit of **5000** requests per month for the `FREE` account. The limit is reset every month. - a quota limit of **10** requests per minute for the `FREE` account. The limit is reset every minute and implements a sliding window mechanism.  
 *
 * The version of the OpenAPI document: 1.2.27
 * Contact: support@threatjammer.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIOriginTokenManagementInThisRegionApi_H
#define OAI_OAIOriginTokenManagementInThisRegionApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include "OAIBody_delete_token_v1_origin_token_delete.h"
#include "OAIBody_disable_origin_token_v1_origin_token_disable_put.h"
#include "OAIBody_enable_origin_token_v1_origin_token_enable_put.h"
#include "OAIBody_query_origin_token_info_v1_origin_token_post.h"
#include "OAIHTTPValidationError.h"
#include "OAIOriginTokenCollectionOutput.h"
#include "OAIOriginTokenInput.h"
#include "OAIOriginTokenOutput.h"
#include <QJsonValue>
#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIOriginTokenManagementInThisRegionApi : public QObject {
    Q_OBJECT

public:
    OAIOriginTokenManagementInThisRegionApi(const int timeOut = 0);
    ~OAIOriginTokenManagementInThisRegionApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  oai_origin_token_input OAIOriginTokenInput [required]
    */
    virtual void createANewOriginTokenV1OriginTokenNewPost(const OAIOriginTokenInput &oai_origin_token_input);

    /**
    * @param[in]  oai_body_delete_token_v1_origin_token_delete OAIBody_delete_token_v1_origin_token_delete [required]
    */
    virtual void deleteTokenV1OriginTokenDelete(const OAIBody_delete_token_v1_origin_token_delete &oai_body_delete_token_v1_origin_token_delete);

    /**
    * @param[in]  oai_body_disable_origin_token_v1_origin_token_disable_put OAIBody_disable_origin_token_v1_origin_token_disable_put [required]
    */
    virtual void disableOriginTokenV1OriginTokenDisablePut(const OAIBody_disable_origin_token_v1_origin_token_disable_put &oai_body_disable_origin_token_v1_origin_token_disable_put);

    /**
    * @param[in]  oai_body_enable_origin_token_v1_origin_token_enable_put OAIBody_enable_origin_token_v1_origin_token_enable_put [required]
    */
    virtual void enableOriginTokenV1OriginTokenEnablePut(const OAIBody_enable_origin_token_v1_origin_token_enable_put &oai_body_enable_origin_token_v1_origin_token_enable_put);


    virtual void queryAllOriginTokensInTheRegionV1OriginTokenAllGet();

    /**
    * @param[in]  oai_body_query_origin_token_info_v1_origin_token_post OAIBody_query_origin_token_info_v1_origin_token_post [required]
    */
    virtual void queryOriginTokenInfoV1OriginTokenPost(const OAIBody_query_origin_token_info_v1_origin_token_post &oai_body_query_origin_token_info_v1_origin_token_post);


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void createANewOriginTokenV1OriginTokenNewPostCallback(OAIHttpRequestWorker *worker);
    void deleteTokenV1OriginTokenDeleteCallback(OAIHttpRequestWorker *worker);
    void disableOriginTokenV1OriginTokenDisablePutCallback(OAIHttpRequestWorker *worker);
    void enableOriginTokenV1OriginTokenEnablePutCallback(OAIHttpRequestWorker *worker);
    void queryAllOriginTokensInTheRegionV1OriginTokenAllGetCallback(OAIHttpRequestWorker *worker);
    void queryOriginTokenInfoV1OriginTokenPostCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void createANewOriginTokenV1OriginTokenNewPostSignal(OAIOriginTokenOutput summary);
    void deleteTokenV1OriginTokenDeleteSignal(QJsonValue summary);
    void disableOriginTokenV1OriginTokenDisablePutSignal(QJsonValue summary);
    void enableOriginTokenV1OriginTokenEnablePutSignal(QJsonValue summary);
    void queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignal(OAIOriginTokenCollectionOutput summary);
    void queryOriginTokenInfoV1OriginTokenPostSignal(OAIOriginTokenOutput summary);


    void createANewOriginTokenV1OriginTokenNewPostSignalFull(OAIHttpRequestWorker *worker, OAIOriginTokenOutput summary);
    void deleteTokenV1OriginTokenDeleteSignalFull(OAIHttpRequestWorker *worker, QJsonValue summary);
    void disableOriginTokenV1OriginTokenDisablePutSignalFull(OAIHttpRequestWorker *worker, QJsonValue summary);
    void enableOriginTokenV1OriginTokenEnablePutSignalFull(OAIHttpRequestWorker *worker, QJsonValue summary);
    void queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignalFull(OAIHttpRequestWorker *worker, OAIOriginTokenCollectionOutput summary);
    void queryOriginTokenInfoV1OriginTokenPostSignalFull(OAIHttpRequestWorker *worker, OAIOriginTokenOutput summary);

    Q_DECL_DEPRECATED_X("Use createANewOriginTokenV1OriginTokenNewPostSignalError() instead")
    void createANewOriginTokenV1OriginTokenNewPostSignalE(OAIOriginTokenOutput summary, QNetworkReply::NetworkError error_type, QString error_str);
    void createANewOriginTokenV1OriginTokenNewPostSignalError(OAIOriginTokenOutput summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use deleteTokenV1OriginTokenDeleteSignalError() instead")
    void deleteTokenV1OriginTokenDeleteSignalE(QJsonValue summary, QNetworkReply::NetworkError error_type, QString error_str);
    void deleteTokenV1OriginTokenDeleteSignalError(QJsonValue summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use disableOriginTokenV1OriginTokenDisablePutSignalError() instead")
    void disableOriginTokenV1OriginTokenDisablePutSignalE(QJsonValue summary, QNetworkReply::NetworkError error_type, QString error_str);
    void disableOriginTokenV1OriginTokenDisablePutSignalError(QJsonValue summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use enableOriginTokenV1OriginTokenEnablePutSignalError() instead")
    void enableOriginTokenV1OriginTokenEnablePutSignalE(QJsonValue summary, QNetworkReply::NetworkError error_type, QString error_str);
    void enableOriginTokenV1OriginTokenEnablePutSignalError(QJsonValue summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignalError() instead")
    void queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignalE(OAIOriginTokenCollectionOutput summary, QNetworkReply::NetworkError error_type, QString error_str);
    void queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignalError(OAIOriginTokenCollectionOutput summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use queryOriginTokenInfoV1OriginTokenPostSignalError() instead")
    void queryOriginTokenInfoV1OriginTokenPostSignalE(OAIOriginTokenOutput summary, QNetworkReply::NetworkError error_type, QString error_str);
    void queryOriginTokenInfoV1OriginTokenPostSignalError(OAIOriginTokenOutput summary, QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use createANewOriginTokenV1OriginTokenNewPostSignalErrorFull() instead")
    void createANewOriginTokenV1OriginTokenNewPostSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void createANewOriginTokenV1OriginTokenNewPostSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use deleteTokenV1OriginTokenDeleteSignalErrorFull() instead")
    void deleteTokenV1OriginTokenDeleteSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void deleteTokenV1OriginTokenDeleteSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use disableOriginTokenV1OriginTokenDisablePutSignalErrorFull() instead")
    void disableOriginTokenV1OriginTokenDisablePutSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void disableOriginTokenV1OriginTokenDisablePutSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use enableOriginTokenV1OriginTokenEnablePutSignalErrorFull() instead")
    void enableOriginTokenV1OriginTokenEnablePutSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void enableOriginTokenV1OriginTokenEnablePutSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignalErrorFull() instead")
    void queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void queryAllOriginTokensInTheRegionV1OriginTokenAllGetSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use queryOriginTokenInfoV1OriginTokenPostSignalErrorFull() instead")
    void queryOriginTokenInfoV1OriginTokenPostSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void queryOriginTokenInfoV1OriginTokenPostSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
