/**
 * ThreatJammer.com User API
 *  The public API open to the users. [Read the docs and learn more.](https://threatjammer.com/docs).  ## General information  ### Description Threat Jammer supports two end-user REST APIs: the User API and the Report API. The end-user uses the User API to interact with the different databases, heuristics, and machine learning processes. Devices use the Report API to interact with Threat Jammer. This document will explain how to use the User API and interact with the different services, create a token, interpret the quota information, and create the HTTP request to interact with the User API.  ### Authentication The API is protected by a **Bearer authentication** schema. **Bearer authentication** (also called **token authentication**) is an HTTP authentication scheme that involves security tokens called bearer tokens. It is used to authenticate the user. All the different endpoints expect a `Bearer` token in the `Authorization` header.  Example:  ``` curl -X 'GET'   'https://dublin.api.threatjammer.com/test'   -H 'accept: application/json'   -H 'Authorization: Bearer YOUR_API_KEY' ```  You can obtain a token after registering on the [ThreatJammer.com](https://threatjammer.com) website for free.   ### Region specific tokens All the `Bearer` tokens contain information about the authorized region. The developers have to use a token created for the region they want to use. A token used in a different region will return a `401 Unauthorized` error.  ### Global errors  The API will return the following permanent errors: - a `401 Unauthorized` error if the token is not valid, or does not belong to the region. - a `401 Unauthorized` error if the token does not exist. - a `401 Unauthorized` error if the token is malformed. - a `403 Forbidden` error if the subscription level is not enough. Some endpoints are only available for paid subscription levels.  And these temporary errors: - a `429 Too Many Requests` error if the quota is exceeded (see below).  ### Quota limits  **Every request to the User API will consume one (1) quota point.**  The API has two rate limiting processes: - a quota limit of **5000** requests per month for the `FREE` account. The limit is reset every month. - a quota limit of **10** requests per minute for the `FREE` account. The limit is reset every minute and implements a sliding window mechanism.  
 *
 * The version of the OpenAPI document: 1.2.27
 * Contact: support@threatjammer.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAllowlistDataQueryAndManagementApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIAllowlistDataQueryAndManagementApi::OAIAllowlistDataQueryAndManagementApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIAllowlistDataQueryAndManagementApi::~OAIAllowlistDataQueryAndManagementApi() {
}

void OAIAllowlistDataQueryAndManagementApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPut", defaultConf);
    _serverIndices.insert("changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPut", 0);
    _serverConfigs.insert("changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPut", defaultConf);
    _serverIndices.insert("changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPut", 0);
    _serverConfigs.insert("changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPut", defaultConf);
    _serverIndices.insert("changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPut", 0);
    _serverConfigs.insert("createPrivateAllowlistOfTheUserV1AllowlistPrivatePost", defaultConf);
    _serverIndices.insert("createPrivateAllowlistOfTheUserV1AllowlistPrivatePost", 0);
    _serverConfigs.insert("deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDelete", defaultConf);
    _serverIndices.insert("deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDelete", 0);
    _serverConfigs.insert("deleteTheAllowlistV1AllowlistPrivateAllowlistIdDelete", defaultConf);
    _serverIndices.insert("deleteTheAllowlistV1AllowlistPrivateAllowlistIdDelete", 0);
    _serverConfigs.insert("deleteTheAllowlistV1AllowlistPublicAllowlistIdDelete", defaultConf);
    _serverIndices.insert("deleteTheAllowlistV1AllowlistPublicAllowlistIdDelete", 0);
    _serverConfigs.insert("getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGet", defaultConf);
    _serverIndices.insert("getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGet", 0);
    _serverConfigs.insert("getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGet", defaultConf);
    _serverIndices.insert("getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGet", 0);
    _serverConfigs.insert("getAllPrivateAllowlistsV1AllowlistPrivateAllGet", defaultConf);
    _serverIndices.insert("getAllPrivateAllowlistsV1AllowlistPrivateAllGet", 0);
    _serverConfigs.insert("getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGet", defaultConf);
    _serverIndices.insert("getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGet", 0);
    _serverConfigs.insert("getAllPublicAllowlistsV1AllowlistPublicAllGet", defaultConf);
    _serverIndices.insert("getAllPublicAllowlistsV1AllowlistPublicAllGet", 0);
    _serverConfigs.insert("getAllowlistContentV1AllowlistPrivateAllowlistIdContentGet", defaultConf);
    _serverIndices.insert("getAllowlistContentV1AllowlistPrivateAllowlistIdContentGet", 0);
    _serverConfigs.insert("getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGet", defaultConf);
    _serverIndices.insert("getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGet", 0);
    _serverConfigs.insert("getSingleAllowlistV1AllowlistPrivateAllowlistIdGet", defaultConf);
    _serverIndices.insert("getSingleAllowlistV1AllowlistPrivateAllowlistIdGet", 0);
    _serverConfigs.insert("getSingleAllowlistV1AllowlistPublicAllowlistIdGet", defaultConf);
    _serverIndices.insert("getSingleAllowlistV1AllowlistPublicAllowlistIdGet", 0);
    _serverConfigs.insert("queryResourceAllowlistsV1AllowlistPublicIpAddressGet", defaultConf);
    _serverIndices.insert("queryResourceAllowlistsV1AllowlistPublicIpAddressGet", 0);
    _serverConfigs.insert("queryResourceDenylistsV1AllowlistPrivateIpAddressGet", defaultConf);
    _serverIndices.insert("queryResourceDenylistsV1AllowlistPrivateIpAddressGet", 0);
    _serverConfigs.insert("updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPut", defaultConf);
    _serverIndices.insert("updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPut", 0);
    _serverConfigs.insert("updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPut", defaultConf);
    _serverIndices.insert("updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPut", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIAllowlistDataQueryAndManagementApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIAllowlistDataQueryAndManagementApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIAllowlistDataQueryAndManagementApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIAllowlistDataQueryAndManagementApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIAllowlistDataQueryAndManagementApi::setUsername(const QString &username) {
    _username = username;
}

void OAIAllowlistDataQueryAndManagementApi::setPassword(const QString &password) {
    _password = password;
}


void OAIAllowlistDataQueryAndManagementApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIAllowlistDataQueryAndManagementApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIAllowlistDataQueryAndManagementApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIAllowlistDataQueryAndManagementApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAllowlistDataQueryAndManagementApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAllowlistDataQueryAndManagementApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIAllowlistDataQueryAndManagementApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIAllowlistDataQueryAndManagementApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIAllowlistDataQueryAndManagementApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIAllowlistDataQueryAndManagementApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIAllowlistDataQueryAndManagementApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIAllowlistDataQueryAndManagementApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIAllowlistDataQueryAndManagementApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPut(const QString &allowlist_id, const OAIBody_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__put &oai_body_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__put) {
    QString fullPath = QString(_serverConfigs["changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPut"][_serverIndices.value("changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPut")].URL()+"/v1/allowlist/public/{allowlist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body_change_status_of_the_allowlist_v1_allowlist_public__allowlist_id__put.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutSignal(output);
        Q_EMIT changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutSignalE(output, error_type, error_str);
        Q_EMIT changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutSignalError(output, error_type, error_str);
        Q_EMIT changeStatusOfTheAllowlistV1AllowlistPublicAllowlistIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPut(const QString &allowlist_id, const OAIBody_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_put &oai_body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_put) {
    QString fullPath = QString(_serverConfigs["changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPut"][_serverIndices.value("changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPut")].URL()+"/v1/allowlist/private/{allowlist_id}/origin");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body_change_status_of_the_origin_allowlist_v1_allowlist_private__allowlist_id__origin_put.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutSignal(output);
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutSignalE(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutSignalError(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPrivateAllowlistIdOriginPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPut(const QString &allowlist_id, const OAIBody_change_status_of_the_origin_allowlist_v1_allowlist_public__allowlist_id__origin_put &oai_body_change_status_of_the_origin_allowlist_v1_allowlist_public__allowlist_id__origin_put) {
    QString fullPath = QString(_serverConfigs["changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPut"][_serverIndices.value("changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPut")].URL()+"/v1/allowlist/public/{allowlist_id}/origin");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body_change_status_of_the_origin_allowlist_v1_allowlist_public__allowlist_id__origin_put.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutSignal(output);
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutSignalE(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutSignalError(output, error_type, error_str);
        Q_EMIT changeStatusOfTheOriginAllowlistV1AllowlistPublicAllowlistIdOriginPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::createPrivateAllowlistOfTheUserV1AllowlistPrivatePost(const OAIBody_create_private_allowlist_of_the_user_v1_allowlist_private_post &oai_body_create_private_allowlist_of_the_user_v1_allowlist_private_post) {
    QString fullPath = QString(_serverConfigs["createPrivateAllowlistOfTheUserV1AllowlistPrivatePost"][_serverIndices.value("createPrivateAllowlistOfTheUserV1AllowlistPrivatePost")].URL()+"/v1/allowlist/private");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_body_create_private_allowlist_of_the_user_v1_allowlist_private_post.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::createPrivateAllowlistOfTheUserV1AllowlistPrivatePostCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::createPrivateAllowlistOfTheUserV1AllowlistPrivatePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createPrivateAllowlistOfTheUserV1AllowlistPrivatePostSignal(output);
        Q_EMIT createPrivateAllowlistOfTheUserV1AllowlistPrivatePostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createPrivateAllowlistOfTheUserV1AllowlistPrivatePostSignalE(output, error_type, error_str);
        Q_EMIT createPrivateAllowlistOfTheUserV1AllowlistPrivatePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createPrivateAllowlistOfTheUserV1AllowlistPrivatePostSignalError(output, error_type, error_str);
        Q_EMIT createPrivateAllowlistOfTheUserV1AllowlistPrivatePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDelete(const QString &allowlist_id) {
    QString fullPath = QString(_serverConfigs["deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDelete"][_serverIndices.value("deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDelete")].URL()+"/v1/allowlist/private/{allowlist_id}/content");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteSignal(output);
        Q_EMIT deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteTheAllowlistContentV1AllowlistPrivateAllowlistIdContentDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistV1AllowlistPrivateAllowlistIdDelete(const QString &allowlist_id) {
    QString fullPath = QString(_serverConfigs["deleteTheAllowlistV1AllowlistPrivateAllowlistIdDelete"][_serverIndices.value("deleteTheAllowlistV1AllowlistPrivateAllowlistIdDelete")].URL()+"/v1/allowlist/private/{allowlist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteSignal(output);
        Q_EMIT deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteTheAllowlistV1AllowlistPrivateAllowlistIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistV1AllowlistPublicAllowlistIdDelete(const QString &allowlist_id) {
    QString fullPath = QString(_serverConfigs["deleteTheAllowlistV1AllowlistPublicAllowlistIdDelete"][_serverIndices.value("deleteTheAllowlistV1AllowlistPublicAllowlistIdDelete")].URL()+"/v1/allowlist/public/{allowlist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteSignal(output);
        Q_EMIT deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteSignalE(output, error_type, error_str);
        Q_EMIT deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteSignalError(output, error_type, error_str);
        Q_EMIT deleteTheAllowlistV1AllowlistPublicAllowlistIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGet(const QString &resource_type) {
    QString fullPath = QString(_serverConfigs["getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGet"][_serverIndices.value("getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGet")].URL()+"/v1/allowlist/public/owned/{resource_type}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString resource_typePathParam("{");
        resource_typePathParam.append("resource_type").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "resource_type", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"resource_type"+pathSuffix : pathPrefix;
        fullPath.replace(resource_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(resource_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetSignal(output);
        Q_EMIT getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetSignalE(output, error_type, error_str);
        Q_EMIT getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetSignalError(output, error_type, error_str);
        Q_EMIT getAllOwnedAllowlistsByResourceTypeV1AllowlistPublicOwnedResourceTypeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGet(const QString &resource_type) {
    QString fullPath = QString(_serverConfigs["getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGet"][_serverIndices.value("getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGet")].URL()+"/v1/allowlist/private/all/{resource_type}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString resource_typePathParam("{");
        resource_typePathParam.append("resource_type").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "resource_type", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"resource_type"+pathSuffix : pathPrefix;
        fullPath.replace(resource_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(resource_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetSignal(output);
        Q_EMIT getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPrivateAllowlistsByResourceTypeV1AllowlistPrivateAllResourceTypeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getAllPrivateAllowlistsV1AllowlistPrivateAllGet() {
    QString fullPath = QString(_serverConfigs["getAllPrivateAllowlistsV1AllowlistPrivateAllGet"][_serverIndices.value("getAllPrivateAllowlistsV1AllowlistPrivateAllGet")].URL()+"/v1/allowlist/private/all");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getAllPrivateAllowlistsV1AllowlistPrivateAllGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getAllPrivateAllowlistsV1AllowlistPrivateAllGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPrivateAllowlistsV1AllowlistPrivateAllGetSignal(output);
        Q_EMIT getAllPrivateAllowlistsV1AllowlistPrivateAllGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPrivateAllowlistsV1AllowlistPrivateAllGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPrivateAllowlistsV1AllowlistPrivateAllGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPrivateAllowlistsV1AllowlistPrivateAllGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPrivateAllowlistsV1AllowlistPrivateAllGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGet(const QString &resource_type) {
    QString fullPath = QString(_serverConfigs["getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGet"][_serverIndices.value("getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGet")].URL()+"/v1/allowlist/public/all/{resource_type}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString resource_typePathParam("{");
        resource_typePathParam.append("resource_type").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "resource_type", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"resource_type"+pathSuffix : pathPrefix;
        fullPath.replace(resource_typePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(resource_type)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetSignal(output);
        Q_EMIT getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPublicAllowlistsByResourceTypeV1AllowlistPublicAllResourceTypeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getAllPublicAllowlistsV1AllowlistPublicAllGet() {
    QString fullPath = QString(_serverConfigs["getAllPublicAllowlistsV1AllowlistPublicAllGet"][_serverIndices.value("getAllPublicAllowlistsV1AllowlistPublicAllGet")].URL()+"/v1/allowlist/public/all");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getAllPublicAllowlistsV1AllowlistPublicAllGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getAllPublicAllowlistsV1AllowlistPublicAllGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllPublicAllowlistsV1AllowlistPublicAllGetSignal(output);
        Q_EMIT getAllPublicAllowlistsV1AllowlistPublicAllGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllPublicAllowlistsV1AllowlistPublicAllGetSignalE(output, error_type, error_str);
        Q_EMIT getAllPublicAllowlistsV1AllowlistPublicAllGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllPublicAllowlistsV1AllowlistPublicAllGetSignalError(output, error_type, error_str);
        Q_EMIT getAllPublicAllowlistsV1AllowlistPublicAllGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getAllowlistContentV1AllowlistPrivateAllowlistIdContentGet(const QString &allowlist_id, const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &page_size) {
    QString fullPath = QString(_serverConfigs["getAllowlistContentV1AllowlistPrivateAllowlistIdContentGet"][_serverIndices.value("getAllowlistContentV1AllowlistPrivateAllowlistIdContentGet")].URL()+"/v1/allowlist/private/{allowlist_id}/content");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (page_size.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page_size", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page_size")).append(querySuffix).append(QUrl::toPercentEncoding(page_size.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetSignal(output);
        Q_EMIT getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetSignalE(output, error_type, error_str);
        Q_EMIT getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetSignalError(output, error_type, error_str);
        Q_EMIT getAllowlistContentV1AllowlistPrivateAllowlistIdContentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGet() {
    QString fullPath = QString(_serverConfigs["getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGet"][_serverIndices.value("getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGet")].URL()+"/v1/allowlist/public/owned");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetSignal(output);
        Q_EMIT getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetSignalE(output, error_type, error_str);
        Q_EMIT getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetSignalError(output, error_type, error_str);
        Q_EMIT getPublicAllowlistsOwnedByTheUserV1AllowlistPublicOwnedGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getSingleAllowlistV1AllowlistPrivateAllowlistIdGet(const QString &allowlist_id) {
    QString fullPath = QString(_serverConfigs["getSingleAllowlistV1AllowlistPrivateAllowlistIdGet"][_serverIndices.value("getSingleAllowlistV1AllowlistPrivateAllowlistIdGet")].URL()+"/v1/allowlist/private/{allowlist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getSingleAllowlistV1AllowlistPrivateAllowlistIdGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getSingleAllowlistV1AllowlistPrivateAllowlistIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateAclGroupListOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSingleAllowlistV1AllowlistPrivateAllowlistIdGetSignal(output);
        Q_EMIT getSingleAllowlistV1AllowlistPrivateAllowlistIdGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSingleAllowlistV1AllowlistPrivateAllowlistIdGetSignalE(output, error_type, error_str);
        Q_EMIT getSingleAllowlistV1AllowlistPrivateAllowlistIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSingleAllowlistV1AllowlistPrivateAllowlistIdGetSignalError(output, error_type, error_str);
        Q_EMIT getSingleAllowlistV1AllowlistPrivateAllowlistIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::getSingleAllowlistV1AllowlistPublicAllowlistIdGet(const QString &allowlist_id) {
    QString fullPath = QString(_serverConfigs["getSingleAllowlistV1AllowlistPublicAllowlistIdGet"][_serverIndices.value("getSingleAllowlistV1AllowlistPublicAllowlistIdGet")].URL()+"/v1/allowlist/public/{allowlist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::getSingleAllowlistV1AllowlistPublicAllowlistIdGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::getSingleAllowlistV1AllowlistPublicAllowlistIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPublicAclGroupListOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSingleAllowlistV1AllowlistPublicAllowlistIdGetSignal(output);
        Q_EMIT getSingleAllowlistV1AllowlistPublicAllowlistIdGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSingleAllowlistV1AllowlistPublicAllowlistIdGetSignalE(output, error_type, error_str);
        Q_EMIT getSingleAllowlistV1AllowlistPublicAllowlistIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSingleAllowlistV1AllowlistPublicAllowlistIdGetSignalError(output, error_type, error_str);
        Q_EMIT getSingleAllowlistV1AllowlistPublicAllowlistIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::queryResourceAllowlistsV1AllowlistPublicIpAddressGet(const OAIAddress &address) {
    QString fullPath = QString(_serverConfigs["queryResourceAllowlistsV1AllowlistPublicIpAddressGet"][_serverIndices.value("queryResourceAllowlistsV1AllowlistPublicIpAddressGet")].URL()+"/v1/allowlist/public/ip/{address}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString addressPathParam("{");
        addressPathParam.append("address").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "address", false);
        QString paramString = (pathStyle == "matrix" && false) ? pathPrefix : pathPrefix+"address"+pathSuffix;
        QJsonObject parameter = address.asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                pathDelimiter = (pathStyle == "matrix" && false) ? ";" : getParamStyleDelimiter(pathStyle, key, false);
                paramString.append(pathDelimiter);
            }
            QString assignOperator = (false) ? "=" : ",";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(key+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(key+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.replace(addressPathParam, QUrl::toPercentEncoding(paramString));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::queryResourceAllowlistsV1AllowlistPublicIpAddressGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::queryResourceAllowlistsV1AllowlistPublicIpAddressGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAclListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryResourceAllowlistsV1AllowlistPublicIpAddressGetSignal(output);
        Q_EMIT queryResourceAllowlistsV1AllowlistPublicIpAddressGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryResourceAllowlistsV1AllowlistPublicIpAddressGetSignalE(output, error_type, error_str);
        Q_EMIT queryResourceAllowlistsV1AllowlistPublicIpAddressGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryResourceAllowlistsV1AllowlistPublicIpAddressGetSignalError(output, error_type, error_str);
        Q_EMIT queryResourceAllowlistsV1AllowlistPublicIpAddressGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::queryResourceDenylistsV1AllowlistPrivateIpAddressGet(const OAIAddress &address) {
    QString fullPath = QString(_serverConfigs["queryResourceDenylistsV1AllowlistPrivateIpAddressGet"][_serverIndices.value("queryResourceDenylistsV1AllowlistPrivateIpAddressGet")].URL()+"/v1/allowlist/private/ip/{address}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString addressPathParam("{");
        addressPathParam.append("address").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "address", false);
        QString paramString = (pathStyle == "matrix" && false) ? pathPrefix : pathPrefix+"address"+pathSuffix;
        QJsonObject parameter = address.asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                pathDelimiter = (pathStyle == "matrix" && false) ? ";" : getParamStyleDelimiter(pathStyle, key, false);
                paramString.append(pathDelimiter);
            }
            QString assignOperator = (false) ? "=" : ",";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(key+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(key+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(key+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.replace(addressPathParam, QUrl::toPercentEncoding(paramString));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::queryResourceDenylistsV1AllowlistPrivateIpAddressGetCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::queryResourceDenylistsV1AllowlistPrivateIpAddressGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAclListCollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryResourceDenylistsV1AllowlistPrivateIpAddressGetSignal(output);
        Q_EMIT queryResourceDenylistsV1AllowlistPrivateIpAddressGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryResourceDenylistsV1AllowlistPrivateIpAddressGetSignalE(output, error_type, error_str);
        Q_EMIT queryResourceDenylistsV1AllowlistPrivateIpAddressGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryResourceDenylistsV1AllowlistPrivateIpAddressGetSignalError(output, error_type, error_str);
        Q_EMIT queryResourceDenylistsV1AllowlistPrivateIpAddressGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPut(const QString &allowlist_id, const ::OpenAPI::OptionalParam<OAIBody_update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__put> &oai_body_update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__put) {
    QString fullPath = QString(_serverConfigs["updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPut"][_serverIndices.value("updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPut")].URL()+"/v1/allowlist/private/{allowlist_id}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_body_update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__put.hasValue()){

        
        QByteArray output = oai_body_update_private_allowlist_of_the_user_v1_allowlist_private__allowlist_id__put.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutSignal(output);
        Q_EMIT updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutSignalE(output, error_type, error_str);
        Q_EMIT updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutSignalError(output, error_type, error_str);
        Q_EMIT updatePrivateAllowlistOfTheUserV1AllowlistPrivateAllowlistIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPut(const QString &allowlist_id, const ::OpenAPI::OptionalParam<OAIBody_update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_put> &oai_body_update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_put) {
    QString fullPath = QString(_serverConfigs["updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPut"][_serverIndices.value("updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPut")].URL()+"/v1/allowlist/private/{allowlist_id}/content");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString allowlist_idPathParam("{");
        allowlist_idPathParam.append("allowlist_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "allowlist_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"allowlist_id"+pathSuffix : pathPrefix;
        fullPath.replace(allowlist_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(allowlist_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_body_update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_put.hasValue()){

        
        QByteArray output = oai_body_update_private_content_of_the_allowlist_of_the_user_v1_allowlist_private__allowlist_id__content_put.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAllowlistDataQueryAndManagementApi::updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutCallback);
    connect(this, &OAIAllowlistDataQueryAndManagementApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAllowlistDataQueryAndManagementApi::updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QJsonValue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutSignal(output);
        Q_EMIT updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutSignalE(output, error_type, error_str);
        Q_EMIT updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutSignalError(output, error_type, error_str);
        Q_EMIT updatePrivateContentOfTheAllowlistOfTheUserV1AllowlistPrivateAllowlistIdContentPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAllowlistDataQueryAndManagementApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
