/**
 * ThreatJammer.com User API
 *  The public API open to the users. [Read the docs and learn more.](https://threatjammer.com/docs).  ## General information  ### Description Threat Jammer supports two end-user REST APIs: the User API and the Report API. The end-user uses the User API to interact with the different databases, heuristics, and machine learning processes. Devices use the Report API to interact with Threat Jammer. This document will explain how to use the User API and interact with the different services, create a token, interpret the quota information, and create the HTTP request to interact with the User API.  ### Authentication The API is protected by a **Bearer authentication** schema. **Bearer authentication** (also called **token authentication**) is an HTTP authentication scheme that involves security tokens called bearer tokens. It is used to authenticate the user. All the different endpoints expect a `Bearer` token in the `Authorization` header.  Example:  ``` curl -X 'GET'   'https://dublin.api.threatjammer.com/test'   -H 'accept: application/json'   -H 'Authorization: Bearer YOUR_API_KEY' ```  You can obtain a token after registering on the [ThreatJammer.com](https://threatjammer.com) website for free.   ### Region specific tokens All the `Bearer` tokens contain information about the authorized region. The developers have to use a token created for the region they want to use. A token used in a different region will return a `401 Unauthorized` error.  ### Global errors  The API will return the following permanent errors: - a `401 Unauthorized` error if the token is not valid, or does not belong to the region. - a `401 Unauthorized` error if the token does not exist. - a `401 Unauthorized` error if the token is malformed. - a `403 Forbidden` error if the subscription level is not enough. Some endpoints are only available for paid subscription levels.  And these temporary errors: - a `429 Too Many Requests` error if the quota is exceeded (see below).  ### Quota limits  **Every request to the User API will consume one (1) quota point.**  The API has two rate limiting processes: - a quota limit of **5000** requests per month for the `FREE` account. The limit is reset every month. - a quota limit of **10** requests per minute for the `FREE` account. The limit is reset every minute and implements a sliding window mechanism.  
 *
 * The version of the OpenAPI document: 1.2.27
 * Contact: support@threatjammer.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUserAgentApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIUserAgentApi::OAIUserAgentApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIUserAgentApi::~OAIUserAgentApi() {
}

void OAIUserAgentApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("parseUserAgentV1UaUserAgentUrlencodedGet", defaultConf);
    _serverIndices.insert("parseUserAgentV1UaUserAgentUrlencodedGet", 0);
    _serverConfigs.insert("parseUserAgentsCsvV1UaCsvPost", defaultConf);
    _serverIndices.insert("parseUserAgentsCsvV1UaCsvPost", 0);
    _serverConfigs.insert("parseUserAgentsV1UaPost", defaultConf);
    _serverIndices.insert("parseUserAgentsV1UaPost", 0);
    _serverConfigs.insert("queryDeviceByCodeV1UaDeviceCodeGet", defaultConf);
    _serverIndices.insert("queryDeviceByCodeV1UaDeviceCodeGet", 0);
    _serverConfigs.insert("queryFamilyByCodeV1UaFamilyCodeGet", defaultConf);
    _serverIndices.insert("queryFamilyByCodeV1UaFamilyCodeGet", 0);
    _serverConfigs.insert("queryOsByCodeV1UaOsCodeGet", defaultConf);
    _serverIndices.insert("queryOsByCodeV1UaOsCodeGet", 0);
    _serverConfigs.insert("queryTypeByCodeV1UaTypeCodeGet", defaultConf);
    _serverIndices.insert("queryTypeByCodeV1UaTypeCodeGet", 0);
    _serverConfigs.insert("queryVendorByCodeV1UaVendorCodeGet", defaultConf);
    _serverIndices.insert("queryVendorByCodeV1UaVendorCodeGet", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIUserAgentApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIUserAgentApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIUserAgentApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIUserAgentApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIUserAgentApi::setUsername(const QString &username) {
    _username = username;
}

void OAIUserAgentApi::setPassword(const QString &password) {
    _password = password;
}


void OAIUserAgentApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIUserAgentApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIUserAgentApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIUserAgentApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIUserAgentApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIUserAgentApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIUserAgentApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIUserAgentApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIUserAgentApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIUserAgentApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIUserAgentApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIUserAgentApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIUserAgentApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIUserAgentApi::parseUserAgentV1UaUserAgentUrlencodedGet(const QString &user_agent_urlencoded) {
    QString fullPath = QString(_serverConfigs["parseUserAgentV1UaUserAgentUrlencodedGet"][_serverIndices.value("parseUserAgentV1UaUserAgentUrlencodedGet")].URL()+"/v1/ua/{user_agent_urlencoded}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString user_agent_urlencodedPathParam("{");
        user_agent_urlencodedPathParam.append("user_agent_urlencoded").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_agent_urlencoded", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_agent_urlencoded"+pathSuffix : pathPrefix;
        fullPath.replace(user_agent_urlencodedPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_agent_urlencoded)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::parseUserAgentV1UaUserAgentUrlencodedGetCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::parseUserAgentV1UaUserAgentUrlencodedGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUAOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT parseUserAgentV1UaUserAgentUrlencodedGetSignal(output);
        Q_EMIT parseUserAgentV1UaUserAgentUrlencodedGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT parseUserAgentV1UaUserAgentUrlencodedGetSignalE(output, error_type, error_str);
        Q_EMIT parseUserAgentV1UaUserAgentUrlencodedGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT parseUserAgentV1UaUserAgentUrlencodedGetSignalError(output, error_type, error_str);
        Q_EMIT parseUserAgentV1UaUserAgentUrlencodedGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::parseUserAgentsCsvV1UaCsvPost(const OAIHttpFileElement &csv_file) {
    QString fullPath = QString(_serverConfigs["parseUserAgentsCsvV1UaCsvPost"][_serverIndices.value("parseUserAgentsCsvV1UaCsvPost")].URL()+"/v1/ua/csv");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_file("csv_file", csv_file.local_filename, csv_file.request_filename, csv_file.mime_type);
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::parseUserAgentsCsvV1UaCsvPostCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::parseUserAgentsCsvV1UaCsvPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUACollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT parseUserAgentsCsvV1UaCsvPostSignal(output);
        Q_EMIT parseUserAgentsCsvV1UaCsvPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT parseUserAgentsCsvV1UaCsvPostSignalE(output, error_type, error_str);
        Q_EMIT parseUserAgentsCsvV1UaCsvPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT parseUserAgentsCsvV1UaCsvPostSignalError(output, error_type, error_str);
        Q_EMIT parseUserAgentsCsvV1UaCsvPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::parseUserAgentsV1UaPost(const QSet<QString> &request_body) {
    QString fullPath = QString(_serverConfigs["parseUserAgentsV1UaPost"][_serverIndices.value("parseUserAgentsV1UaPost")].URL()+"/v1/ua");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {
        QJsonDocument doc(::OpenAPI::toJsonValue(request_body).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::parseUserAgentsV1UaPostCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::parseUserAgentsV1UaPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUACollectionOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT parseUserAgentsV1UaPostSignal(output);
        Q_EMIT parseUserAgentsV1UaPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT parseUserAgentsV1UaPostSignalE(output, error_type, error_str);
        Q_EMIT parseUserAgentsV1UaPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT parseUserAgentsV1UaPostSignalError(output, error_type, error_str);
        Q_EMIT parseUserAgentsV1UaPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::queryDeviceByCodeV1UaDeviceCodeGet(const QString &code) {
    QString fullPath = QString(_serverConfigs["queryDeviceByCodeV1UaDeviceCodeGet"][_serverIndices.value("queryDeviceByCodeV1UaDeviceCodeGet")].URL()+"/v1/ua/device/{code}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::queryDeviceByCodeV1UaDeviceCodeGetCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::queryDeviceByCodeV1UaDeviceCodeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDeviceOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryDeviceByCodeV1UaDeviceCodeGetSignal(output);
        Q_EMIT queryDeviceByCodeV1UaDeviceCodeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryDeviceByCodeV1UaDeviceCodeGetSignalE(output, error_type, error_str);
        Q_EMIT queryDeviceByCodeV1UaDeviceCodeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryDeviceByCodeV1UaDeviceCodeGetSignalError(output, error_type, error_str);
        Q_EMIT queryDeviceByCodeV1UaDeviceCodeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::queryFamilyByCodeV1UaFamilyCodeGet(const QString &code) {
    QString fullPath = QString(_serverConfigs["queryFamilyByCodeV1UaFamilyCodeGet"][_serverIndices.value("queryFamilyByCodeV1UaFamilyCodeGet")].URL()+"/v1/ua/family/{code}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::queryFamilyByCodeV1UaFamilyCodeGetCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::queryFamilyByCodeV1UaFamilyCodeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIFamilyOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryFamilyByCodeV1UaFamilyCodeGetSignal(output);
        Q_EMIT queryFamilyByCodeV1UaFamilyCodeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryFamilyByCodeV1UaFamilyCodeGetSignalE(output, error_type, error_str);
        Q_EMIT queryFamilyByCodeV1UaFamilyCodeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryFamilyByCodeV1UaFamilyCodeGetSignalError(output, error_type, error_str);
        Q_EMIT queryFamilyByCodeV1UaFamilyCodeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::queryOsByCodeV1UaOsCodeGet(const QString &code) {
    QString fullPath = QString(_serverConfigs["queryOsByCodeV1UaOsCodeGet"][_serverIndices.value("queryOsByCodeV1UaOsCodeGet")].URL()+"/v1/ua/os/{code}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::queryOsByCodeV1UaOsCodeGetCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::queryOsByCodeV1UaOsCodeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOSOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryOsByCodeV1UaOsCodeGetSignal(output);
        Q_EMIT queryOsByCodeV1UaOsCodeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryOsByCodeV1UaOsCodeGetSignalE(output, error_type, error_str);
        Q_EMIT queryOsByCodeV1UaOsCodeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryOsByCodeV1UaOsCodeGetSignalError(output, error_type, error_str);
        Q_EMIT queryOsByCodeV1UaOsCodeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::queryTypeByCodeV1UaTypeCodeGet(const QString &code) {
    QString fullPath = QString(_serverConfigs["queryTypeByCodeV1UaTypeCodeGet"][_serverIndices.value("queryTypeByCodeV1UaTypeCodeGet")].URL()+"/v1/ua/type/{code}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::queryTypeByCodeV1UaTypeCodeGetCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::queryTypeByCodeV1UaTypeCodeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITypeOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryTypeByCodeV1UaTypeCodeGetSignal(output);
        Q_EMIT queryTypeByCodeV1UaTypeCodeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryTypeByCodeV1UaTypeCodeGetSignalE(output, error_type, error_str);
        Q_EMIT queryTypeByCodeV1UaTypeCodeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryTypeByCodeV1UaTypeCodeGetSignalError(output, error_type, error_str);
        Q_EMIT queryTypeByCodeV1UaTypeCodeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::queryVendorByCodeV1UaVendorCodeGet(const QString &code) {
    QString fullPath = QString(_serverConfigs["queryVendorByCodeV1UaVendorCodeGet"][_serverIndices.value("queryVendorByCodeV1UaVendorCodeGet")].URL()+"/v1/ua/vendor/{code}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIUserAgentApi::queryVendorByCodeV1UaVendorCodeGetCallback);
    connect(this, &OAIUserAgentApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIUserAgentApi::queryVendorByCodeV1UaVendorCodeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVendorOutput output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT queryVendorByCodeV1UaVendorCodeGetSignal(output);
        Q_EMIT queryVendorByCodeV1UaVendorCodeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT queryVendorByCodeV1UaVendorCodeGetSignalE(output, error_type, error_str);
        Q_EMIT queryVendorByCodeV1UaVendorCodeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT queryVendorByCodeV1UaVendorCodeGetSignalError(output, error_type, error_str);
        Q_EMIT queryVendorByCodeV1UaVendorCodeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIUserAgentApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
