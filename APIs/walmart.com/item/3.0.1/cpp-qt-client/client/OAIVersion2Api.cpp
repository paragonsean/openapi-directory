/**
 * Item API
 * Please make sure you use the correct version of the APIs for your use case. To find out the appropriate version, go to the API Docs  drop down on the menu.
 *
 * The version of the OpenAPI document: 3.0.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVersion2Api.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIVersion2Api::OAIVersion2Api(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIVersion2Api::~OAIVersion2Api() {
}

void OAIVersion2Api::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://developer.walmart.com/proxy/item-api-doc-app/rest"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("v2doPostMultiPart", defaultConf);
    _serverIndices.insert("v2doPostMultiPart", 0);
    _serverConfigs.insert("v2getAllItemsStatus", defaultConf);
    _serverIndices.insert("v2getAllItemsStatus", 0);
    _serverConfigs.insert("v2getFeedItemStatus", defaultConf);
    _serverIndices.insert("v2getFeedItemStatus", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIVersion2Api::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIVersion2Api::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIVersion2Api::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIVersion2Api::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIVersion2Api::setUsername(const QString &username) {
    _username = username;
}

void OAIVersion2Api::setPassword(const QString &password) {
    _password = password;
}


void OAIVersion2Api::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIVersion2Api::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIVersion2Api::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIVersion2Api::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIVersion2Api::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIVersion2Api::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIVersion2Api::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIVersion2Api::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIVersion2Api::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIVersion2Api::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIVersion2Api::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIVersion2Api::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIVersion2Api::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIVersion2Api::v2doPostMultiPart(const QString &wm_consumer_channel_type, const QString &wm_consumer_id, const QString &wm_sec_timestamp, const QString &wm_sec_auth_signature, const QString &wm_svc_name, const QString &wm_qos_correlation_id, const OAIHttpFileElement &file, const ::OpenAPI::OptionalParam<QString> &feed_type) {
    QString fullPath = QString(_serverConfigs["v2doPostMultiPart"][_serverIndices.value("v2doPostMultiPart")].URL()+"/v2/feeds");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (feed_type.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "feedType", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("feedType")).append(querySuffix).append(QUrl::toPercentEncoding(feed_type.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_file("file", file.local_filename, file.request_filename, file.mime_type);
    }

    
    {
        if (!::OpenAPI::toStringValue(wm_consumer_channel_type).isEmpty()) {
            input.headers.insert("WM_CONSUMER.CHANNEL.TYPE", ::OpenAPI::toStringValue(wm_consumer_channel_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_consumer_id).isEmpty()) {
            input.headers.insert("WM_CONSUMER.ID", ::OpenAPI::toStringValue(wm_consumer_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_sec_timestamp).isEmpty()) {
            input.headers.insert("WM_SEC.TIMESTAMP", ::OpenAPI::toStringValue(wm_sec_timestamp));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_sec_auth_signature).isEmpty()) {
            input.headers.insert("WM_SEC.AUTH_SIGNATURE", ::OpenAPI::toStringValue(wm_sec_auth_signature));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_svc_name).isEmpty()) {
            input.headers.insert("WM_SVC.NAME", ::OpenAPI::toStringValue(wm_svc_name));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_qos_correlation_id).isEmpty()) {
            input.headers.insert("WM_QOS.CORRELATION_ID", ::OpenAPI::toStringValue(wm_qos_correlation_id));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVersion2Api::v2doPostMultiPartCallback);
    connect(this, &OAIVersion2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVersion2Api::v2doPostMultiPartCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v2doPostMultiPartSignal();
        Q_EMIT v2doPostMultiPartSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v2doPostMultiPartSignalE(error_type, error_str);
        Q_EMIT v2doPostMultiPartSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v2doPostMultiPartSignalError(error_type, error_str);
        Q_EMIT v2doPostMultiPartSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVersion2Api::v2getAllItemsStatus(const QString &feed_id, const QString &wm_consumer_channel_type, const QString &wm_consumer_id, const QString &wm_sec_timestamp, const QString &wm_sec_auth_signature, const QString &wm_svc_name, const QString &wm_qos_correlation_id, const ::OpenAPI::OptionalParam<QString> &include_details, const ::OpenAPI::OptionalParam<QString> &offset, const ::OpenAPI::OptionalParam<QString> &limit) {
    QString fullPath = QString(_serverConfigs["v2getAllItemsStatus"][_serverIndices.value("v2getAllItemsStatus")].URL()+"/v2/feeds/{feedId}");
    
    
    {
        QString feed_idPathParam("{");
        feed_idPathParam.append("feedId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "feedId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"feedId"+pathSuffix : pathPrefix;
        fullPath.replace(feed_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(feed_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (include_details.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "includeDetails", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("includeDetails")).append(querySuffix).append(QUrl::toPercentEncoding(include_details.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(limit.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(wm_consumer_channel_type).isEmpty()) {
            input.headers.insert("WM_CONSUMER.CHANNEL.TYPE", ::OpenAPI::toStringValue(wm_consumer_channel_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_consumer_id).isEmpty()) {
            input.headers.insert("WM_CONSUMER.ID", ::OpenAPI::toStringValue(wm_consumer_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_sec_timestamp).isEmpty()) {
            input.headers.insert("WM_SEC.TIMESTAMP", ::OpenAPI::toStringValue(wm_sec_timestamp));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_sec_auth_signature).isEmpty()) {
            input.headers.insert("WM_SEC.AUTH_SIGNATURE", ::OpenAPI::toStringValue(wm_sec_auth_signature));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_svc_name).isEmpty()) {
            input.headers.insert("WM_SVC.NAME", ::OpenAPI::toStringValue(wm_svc_name));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_qos_correlation_id).isEmpty()) {
            input.headers.insert("WM_QOS.CORRELATION_ID", ::OpenAPI::toStringValue(wm_qos_correlation_id));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVersion2Api::v2getAllItemsStatusCallback);
    connect(this, &OAIVersion2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVersion2Api::v2getAllItemsStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v2getAllItemsStatusSignal();
        Q_EMIT v2getAllItemsStatusSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v2getAllItemsStatusSignalE(error_type, error_str);
        Q_EMIT v2getAllItemsStatusSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v2getAllItemsStatusSignalError(error_type, error_str);
        Q_EMIT v2getAllItemsStatusSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVersion2Api::v2getFeedItemStatus(const QString &wm_consumer_channel_type, const QString &wm_consumer_id, const QString &wm_sec_timestamp, const QString &wm_sec_auth_signature, const QString &wm_svc_name, const QString &wm_qos_correlation_id, const ::OpenAPI::OptionalParam<QString> &feed_id, const ::OpenAPI::OptionalParam<QString> &include_details, const ::OpenAPI::OptionalParam<QString> &offset, const ::OpenAPI::OptionalParam<QString> &limit) {
    QString fullPath = QString(_serverConfigs["v2getFeedItemStatus"][_serverIndices.value("v2getFeedItemStatus")].URL()+"/v2/feeds");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (feed_id.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "feedId", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("feedId")).append(querySuffix).append(QUrl::toPercentEncoding(feed_id.stringValue()));
    }
    if (include_details.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "includeDetails", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("includeDetails")).append(querySuffix).append(QUrl::toPercentEncoding(include_details.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(limit.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(wm_consumer_channel_type).isEmpty()) {
            input.headers.insert("WM_CONSUMER.CHANNEL.TYPE", ::OpenAPI::toStringValue(wm_consumer_channel_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_consumer_id).isEmpty()) {
            input.headers.insert("WM_CONSUMER.ID", ::OpenAPI::toStringValue(wm_consumer_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_sec_timestamp).isEmpty()) {
            input.headers.insert("WM_SEC.TIMESTAMP", ::OpenAPI::toStringValue(wm_sec_timestamp));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_sec_auth_signature).isEmpty()) {
            input.headers.insert("WM_SEC.AUTH_SIGNATURE", ::OpenAPI::toStringValue(wm_sec_auth_signature));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_svc_name).isEmpty()) {
            input.headers.insert("WM_SVC.NAME", ::OpenAPI::toStringValue(wm_svc_name));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(wm_qos_correlation_id).isEmpty()) {
            input.headers.insert("WM_QOS.CORRELATION_ID", ::OpenAPI::toStringValue(wm_qos_correlation_id));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIVersion2Api::v2getFeedItemStatusCallback);
    connect(this, &OAIVersion2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIVersion2Api::v2getFeedItemStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v2getFeedItemStatusSignal();
        Q_EMIT v2getFeedItemStatusSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v2getFeedItemStatusSignalE(error_type, error_str);
        Q_EMIT v2getFeedItemStatusSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v2getFeedItemStatusSignalError(error_type, error_str);
        Q_EMIT v2getFeedItemStatusSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIVersion2Api::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
