/*
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Card;
import org.openapitools.client.model.CardPaymentTimeline;
import org.openapitools.client.model.DeviceDetails;
import org.openapitools.client.model.Error;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Reflects the current status of a card payment. Contains only non-confidential information.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:20:53.300629-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CardPaymentDetails {
  public static final String SERIALIZED_NAME_APPLICATION_CRYPTOGRAM = "application_cryptogram";
  @SerializedName(SERIALIZED_NAME_APPLICATION_CRYPTOGRAM)
  private String applicationCryptogram;

  public static final String SERIALIZED_NAME_APPLICATION_IDENTIFIER = "application_identifier";
  @SerializedName(SERIALIZED_NAME_APPLICATION_IDENTIFIER)
  private String applicationIdentifier;

  public static final String SERIALIZED_NAME_APPLICATION_NAME = "application_name";
  @SerializedName(SERIALIZED_NAME_APPLICATION_NAME)
  private String applicationName;

  public static final String SERIALIZED_NAME_AUTH_RESULT_CODE = "auth_result_code";
  @SerializedName(SERIALIZED_NAME_AUTH_RESULT_CODE)
  private String authResultCode;

  public static final String SERIALIZED_NAME_AVS_STATUS = "avs_status";
  @SerializedName(SERIALIZED_NAME_AVS_STATUS)
  private String avsStatus;

  public static final String SERIALIZED_NAME_CARD = "card";
  @SerializedName(SERIALIZED_NAME_CARD)
  private Card card;

  public static final String SERIALIZED_NAME_CARD_PAYMENT_TIMELINE = "card_payment_timeline";
  @SerializedName(SERIALIZED_NAME_CARD_PAYMENT_TIMELINE)
  private CardPaymentTimeline cardPaymentTimeline;

  public static final String SERIALIZED_NAME_CVV_STATUS = "cvv_status";
  @SerializedName(SERIALIZED_NAME_CVV_STATUS)
  private String cvvStatus;

  public static final String SERIALIZED_NAME_DEVICE_DETAILS = "device_details";
  @SerializedName(SERIALIZED_NAME_DEVICE_DETAILS)
  private DeviceDetails deviceDetails;

  public static final String SERIALIZED_NAME_ENTRY_METHOD = "entry_method";
  @SerializedName(SERIALIZED_NAME_ENTRY_METHOD)
  private String entryMethod;

  public static final String SERIALIZED_NAME_ERRORS = "errors";
  @SerializedName(SERIALIZED_NAME_ERRORS)
  private List<Error> errors = new ArrayList<>();

  public static final String SERIALIZED_NAME_REFUND_REQUIRES_CARD_PRESENCE = "refund_requires_card_presence";
  @SerializedName(SERIALIZED_NAME_REFUND_REQUIRES_CARD_PRESENCE)
  private Boolean refundRequiresCardPresence;

  public static final String SERIALIZED_NAME_STATEMENT_DESCRIPTION = "statement_description";
  @SerializedName(SERIALIZED_NAME_STATEMENT_DESCRIPTION)
  private String statementDescription;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_VERIFICATION_METHOD = "verification_method";
  @SerializedName(SERIALIZED_NAME_VERIFICATION_METHOD)
  private String verificationMethod;

  public static final String SERIALIZED_NAME_VERIFICATION_RESULTS = "verification_results";
  @SerializedName(SERIALIZED_NAME_VERIFICATION_RESULTS)
  private String verificationResults;

  public CardPaymentDetails() {
  }

  public CardPaymentDetails applicationCryptogram(String applicationCryptogram) {
    this.applicationCryptogram = applicationCryptogram;
    return this;
  }

  /**
   * For EMV payments, the cryptogram generated for the payment.
   * @return applicationCryptogram
   */
  @javax.annotation.Nullable
  public String getApplicationCryptogram() {
    return applicationCryptogram;
  }

  public void setApplicationCryptogram(String applicationCryptogram) {
    this.applicationCryptogram = applicationCryptogram;
  }


  public CardPaymentDetails applicationIdentifier(String applicationIdentifier) {
    this.applicationIdentifier = applicationIdentifier;
    return this;
  }

  /**
   * For EMV payments, the application ID identifies the EMV application used for the payment.
   * @return applicationIdentifier
   */
  @javax.annotation.Nullable
  public String getApplicationIdentifier() {
    return applicationIdentifier;
  }

  public void setApplicationIdentifier(String applicationIdentifier) {
    this.applicationIdentifier = applicationIdentifier;
  }


  public CardPaymentDetails applicationName(String applicationName) {
    this.applicationName = applicationName;
    return this;
  }

  /**
   * For EMV payments, the human-readable name of the EMV application used for the payment.
   * @return applicationName
   */
  @javax.annotation.Nullable
  public String getApplicationName() {
    return applicationName;
  }

  public void setApplicationName(String applicationName) {
    this.applicationName = applicationName;
  }


  public CardPaymentDetails authResultCode(String authResultCode) {
    this.authResultCode = authResultCode;
    return this;
  }

  /**
   * The status code returned by the card issuer that describes the payment&#39;s authorization status.
   * @return authResultCode
   */
  @javax.annotation.Nullable
  public String getAuthResultCode() {
    return authResultCode;
  }

  public void setAuthResultCode(String authResultCode) {
    this.authResultCode = authResultCode;
  }


  public CardPaymentDetails avsStatus(String avsStatus) {
    this.avsStatus = avsStatus;
    return this;
  }

  /**
   * The status code returned from the Address Verification System (AVS) check. The code can be &#x60;AVS_ACCEPTED&#x60;, &#x60;AVS_REJECTED&#x60;, or &#x60;AVS_NOT_CHECKED&#x60;.
   * @return avsStatus
   */
  @javax.annotation.Nullable
  public String getAvsStatus() {
    return avsStatus;
  }

  public void setAvsStatus(String avsStatus) {
    this.avsStatus = avsStatus;
  }


  public CardPaymentDetails card(Card card) {
    this.card = card;
    return this;
  }

  /**
   * Get card
   * @return card
   */
  @javax.annotation.Nullable
  public Card getCard() {
    return card;
  }

  public void setCard(Card card) {
    this.card = card;
  }


  public CardPaymentDetails cardPaymentTimeline(CardPaymentTimeline cardPaymentTimeline) {
    this.cardPaymentTimeline = cardPaymentTimeline;
    return this;
  }

  /**
   * Get cardPaymentTimeline
   * @return cardPaymentTimeline
   */
  @javax.annotation.Nullable
  public CardPaymentTimeline getCardPaymentTimeline() {
    return cardPaymentTimeline;
  }

  public void setCardPaymentTimeline(CardPaymentTimeline cardPaymentTimeline) {
    this.cardPaymentTimeline = cardPaymentTimeline;
  }


  public CardPaymentDetails cvvStatus(String cvvStatus) {
    this.cvvStatus = cvvStatus;
    return this;
  }

  /**
   * The status code returned from the Card Verification Value (CVV) check. The code can be &#x60;CVV_ACCEPTED&#x60;, &#x60;CVV_REJECTED&#x60;, or &#x60;CVV_NOT_CHECKED&#x60;.
   * @return cvvStatus
   */
  @javax.annotation.Nullable
  public String getCvvStatus() {
    return cvvStatus;
  }

  public void setCvvStatus(String cvvStatus) {
    this.cvvStatus = cvvStatus;
  }


  public CardPaymentDetails deviceDetails(DeviceDetails deviceDetails) {
    this.deviceDetails = deviceDetails;
    return this;
  }

  /**
   * Get deviceDetails
   * @return deviceDetails
   */
  @javax.annotation.Nullable
  public DeviceDetails getDeviceDetails() {
    return deviceDetails;
  }

  public void setDeviceDetails(DeviceDetails deviceDetails) {
    this.deviceDetails = deviceDetails;
  }


  public CardPaymentDetails entryMethod(String entryMethod) {
    this.entryMethod = entryMethod;
    return this;
  }

  /**
   * The method used to enter the card&#39;s details for the payment. The method can be &#x60;KEYED&#x60;, &#x60;SWIPED&#x60;, &#x60;EMV&#x60;, &#x60;ON_FILE&#x60;, or &#x60;CONTACTLESS&#x60;.
   * @return entryMethod
   */
  @javax.annotation.Nullable
  public String getEntryMethod() {
    return entryMethod;
  }

  public void setEntryMethod(String entryMethod) {
    this.entryMethod = entryMethod;
  }


  public CardPaymentDetails errors(List<Error> errors) {
    this.errors = errors;
    return this;
  }

  public CardPaymentDetails addErrorsItem(Error errorsItem) {
    if (this.errors == null) {
      this.errors = new ArrayList<>();
    }
    this.errors.add(errorsItem);
    return this;
  }

  /**
   * Information about errors encountered during the request.
   * @return errors
   */
  @javax.annotation.Nullable
  public List<Error> getErrors() {
    return errors;
  }

  public void setErrors(List<Error> errors) {
    this.errors = errors;
  }


  public CardPaymentDetails refundRequiresCardPresence(Boolean refundRequiresCardPresence) {
    this.refundRequiresCardPresence = refundRequiresCardPresence;
    return this;
  }

  /**
   * Whether the card must be physically present for the payment to be refunded.  If set to &#x60;true&#x60;, the card must be present.
   * @return refundRequiresCardPresence
   */
  @javax.annotation.Nullable
  public Boolean getRefundRequiresCardPresence() {
    return refundRequiresCardPresence;
  }

  public void setRefundRequiresCardPresence(Boolean refundRequiresCardPresence) {
    this.refundRequiresCardPresence = refundRequiresCardPresence;
  }


  public CardPaymentDetails statementDescription(String statementDescription) {
    this.statementDescription = statementDescription;
    return this;
  }

  /**
   * The statement description sent to the card networks.  Note: The actual statement description varies and is likely to be truncated and appended with additional information on a per issuer basis.
   * @return statementDescription
   */
  @javax.annotation.Nullable
  public String getStatementDescription() {
    return statementDescription;
  }

  public void setStatementDescription(String statementDescription) {
    this.statementDescription = statementDescription;
  }


  public CardPaymentDetails status(String status) {
    this.status = status;
    return this;
  }

  /**
   * The card payment&#39;s current state. The state can be AUTHORIZED, CAPTURED, VOIDED, or FAILED.
   * @return status
   */
  @javax.annotation.Nullable
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public CardPaymentDetails verificationMethod(String verificationMethod) {
    this.verificationMethod = verificationMethod;
    return this;
  }

  /**
   * For EMV payments, the method used to verify the cardholder&#39;s identity. The method can be &#x60;PIN&#x60;, &#x60;SIGNATURE&#x60;, &#x60;PIN_AND_SIGNATURE&#x60;, &#x60;ON_DEVICE&#x60;, or &#x60;NONE&#x60;.
   * @return verificationMethod
   */
  @javax.annotation.Nullable
  public String getVerificationMethod() {
    return verificationMethod;
  }

  public void setVerificationMethod(String verificationMethod) {
    this.verificationMethod = verificationMethod;
  }


  public CardPaymentDetails verificationResults(String verificationResults) {
    this.verificationResults = verificationResults;
    return this;
  }

  /**
   * For EMV payments, the results of the cardholder verification. The result can be &#x60;SUCCESS&#x60;, &#x60;FAILURE&#x60;, or &#x60;UNKNOWN&#x60;.
   * @return verificationResults
   */
  @javax.annotation.Nullable
  public String getVerificationResults() {
    return verificationResults;
  }

  public void setVerificationResults(String verificationResults) {
    this.verificationResults = verificationResults;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CardPaymentDetails cardPaymentDetails = (CardPaymentDetails) o;
    return Objects.equals(this.applicationCryptogram, cardPaymentDetails.applicationCryptogram) &&
        Objects.equals(this.applicationIdentifier, cardPaymentDetails.applicationIdentifier) &&
        Objects.equals(this.applicationName, cardPaymentDetails.applicationName) &&
        Objects.equals(this.authResultCode, cardPaymentDetails.authResultCode) &&
        Objects.equals(this.avsStatus, cardPaymentDetails.avsStatus) &&
        Objects.equals(this.card, cardPaymentDetails.card) &&
        Objects.equals(this.cardPaymentTimeline, cardPaymentDetails.cardPaymentTimeline) &&
        Objects.equals(this.cvvStatus, cardPaymentDetails.cvvStatus) &&
        Objects.equals(this.deviceDetails, cardPaymentDetails.deviceDetails) &&
        Objects.equals(this.entryMethod, cardPaymentDetails.entryMethod) &&
        Objects.equals(this.errors, cardPaymentDetails.errors) &&
        Objects.equals(this.refundRequiresCardPresence, cardPaymentDetails.refundRequiresCardPresence) &&
        Objects.equals(this.statementDescription, cardPaymentDetails.statementDescription) &&
        Objects.equals(this.status, cardPaymentDetails.status) &&
        Objects.equals(this.verificationMethod, cardPaymentDetails.verificationMethod) &&
        Objects.equals(this.verificationResults, cardPaymentDetails.verificationResults);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationCryptogram, applicationIdentifier, applicationName, authResultCode, avsStatus, card, cardPaymentTimeline, cvvStatus, deviceDetails, entryMethod, errors, refundRequiresCardPresence, statementDescription, status, verificationMethod, verificationResults);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CardPaymentDetails {\n");
    sb.append("    applicationCryptogram: ").append(toIndentedString(applicationCryptogram)).append("\n");
    sb.append("    applicationIdentifier: ").append(toIndentedString(applicationIdentifier)).append("\n");
    sb.append("    applicationName: ").append(toIndentedString(applicationName)).append("\n");
    sb.append("    authResultCode: ").append(toIndentedString(authResultCode)).append("\n");
    sb.append("    avsStatus: ").append(toIndentedString(avsStatus)).append("\n");
    sb.append("    card: ").append(toIndentedString(card)).append("\n");
    sb.append("    cardPaymentTimeline: ").append(toIndentedString(cardPaymentTimeline)).append("\n");
    sb.append("    cvvStatus: ").append(toIndentedString(cvvStatus)).append("\n");
    sb.append("    deviceDetails: ").append(toIndentedString(deviceDetails)).append("\n");
    sb.append("    entryMethod: ").append(toIndentedString(entryMethod)).append("\n");
    sb.append("    errors: ").append(toIndentedString(errors)).append("\n");
    sb.append("    refundRequiresCardPresence: ").append(toIndentedString(refundRequiresCardPresence)).append("\n");
    sb.append("    statementDescription: ").append(toIndentedString(statementDescription)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    verificationMethod: ").append(toIndentedString(verificationMethod)).append("\n");
    sb.append("    verificationResults: ").append(toIndentedString(verificationResults)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("application_cryptogram");
    openapiFields.add("application_identifier");
    openapiFields.add("application_name");
    openapiFields.add("auth_result_code");
    openapiFields.add("avs_status");
    openapiFields.add("card");
    openapiFields.add("card_payment_timeline");
    openapiFields.add("cvv_status");
    openapiFields.add("device_details");
    openapiFields.add("entry_method");
    openapiFields.add("errors");
    openapiFields.add("refund_requires_card_presence");
    openapiFields.add("statement_description");
    openapiFields.add("status");
    openapiFields.add("verification_method");
    openapiFields.add("verification_results");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CardPaymentDetails
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CardPaymentDetails.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CardPaymentDetails is not found in the empty JSON string", CardPaymentDetails.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CardPaymentDetails.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CardPaymentDetails` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("application_cryptogram") != null && !jsonObj.get("application_cryptogram").isJsonNull()) && !jsonObj.get("application_cryptogram").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `application_cryptogram` to be a primitive type in the JSON string but got `%s`", jsonObj.get("application_cryptogram").toString()));
      }
      if ((jsonObj.get("application_identifier") != null && !jsonObj.get("application_identifier").isJsonNull()) && !jsonObj.get("application_identifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `application_identifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("application_identifier").toString()));
      }
      if ((jsonObj.get("application_name") != null && !jsonObj.get("application_name").isJsonNull()) && !jsonObj.get("application_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `application_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("application_name").toString()));
      }
      if ((jsonObj.get("auth_result_code") != null && !jsonObj.get("auth_result_code").isJsonNull()) && !jsonObj.get("auth_result_code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `auth_result_code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("auth_result_code").toString()));
      }
      if ((jsonObj.get("avs_status") != null && !jsonObj.get("avs_status").isJsonNull()) && !jsonObj.get("avs_status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `avs_status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("avs_status").toString()));
      }
      // validate the optional field `card`
      if (jsonObj.get("card") != null && !jsonObj.get("card").isJsonNull()) {
        Card.validateJsonElement(jsonObj.get("card"));
      }
      // validate the optional field `card_payment_timeline`
      if (jsonObj.get("card_payment_timeline") != null && !jsonObj.get("card_payment_timeline").isJsonNull()) {
        CardPaymentTimeline.validateJsonElement(jsonObj.get("card_payment_timeline"));
      }
      if ((jsonObj.get("cvv_status") != null && !jsonObj.get("cvv_status").isJsonNull()) && !jsonObj.get("cvv_status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cvv_status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cvv_status").toString()));
      }
      // validate the optional field `device_details`
      if (jsonObj.get("device_details") != null && !jsonObj.get("device_details").isJsonNull()) {
        DeviceDetails.validateJsonElement(jsonObj.get("device_details"));
      }
      if ((jsonObj.get("entry_method") != null && !jsonObj.get("entry_method").isJsonNull()) && !jsonObj.get("entry_method").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entry_method` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entry_method").toString()));
      }
      if (jsonObj.get("errors") != null && !jsonObj.get("errors").isJsonNull()) {
        JsonArray jsonArrayerrors = jsonObj.getAsJsonArray("errors");
        if (jsonArrayerrors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("errors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `errors` to be an array in the JSON string but got `%s`", jsonObj.get("errors").toString()));
          }

          // validate the optional field `errors` (array)
          for (int i = 0; i < jsonArrayerrors.size(); i++) {
            Error.validateJsonElement(jsonArrayerrors.get(i));
          };
        }
      }
      if ((jsonObj.get("statement_description") != null && !jsonObj.get("statement_description").isJsonNull()) && !jsonObj.get("statement_description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `statement_description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("statement_description").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if ((jsonObj.get("verification_method") != null && !jsonObj.get("verification_method").isJsonNull()) && !jsonObj.get("verification_method").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `verification_method` to be a primitive type in the JSON string but got `%s`", jsonObj.get("verification_method").toString()));
      }
      if ((jsonObj.get("verification_results") != null && !jsonObj.get("verification_results").isJsonNull()) && !jsonObj.get("verification_results").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `verification_results` to be a primitive type in the JSON string but got `%s`", jsonObj.get("verification_results").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CardPaymentDetails.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CardPaymentDetails' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CardPaymentDetails> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CardPaymentDetails.class));

       return (TypeAdapter<T>) new TypeAdapter<CardPaymentDetails>() {
           @Override
           public void write(JsonWriter out, CardPaymentDetails value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CardPaymentDetails read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CardPaymentDetails given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CardPaymentDetails
   * @throws IOException if the JSON string is invalid with respect to CardPaymentDetails
   */
  public static CardPaymentDetails fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CardPaymentDetails.class);
  }

  /**
   * Convert an instance of CardPaymentDetails to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

