/*
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:20:53.300629-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class V1ListPaymentsRequest {
  public static final String SERIALIZED_NAME_BATCH_TOKEN = "batch_token";
  @SerializedName(SERIALIZED_NAME_BATCH_TOKEN)
  private String batchToken;

  public static final String SERIALIZED_NAME_BEGIN_TIME = "begin_time";
  @SerializedName(SERIALIZED_NAME_BEGIN_TIME)
  private String beginTime;

  public static final String SERIALIZED_NAME_END_TIME = "end_time";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private String endTime;

  public static final String SERIALIZED_NAME_INCLUDE_PARTIAL = "include_partial";
  @SerializedName(SERIALIZED_NAME_INCLUDE_PARTIAL)
  private Boolean includePartial;

  public static final String SERIALIZED_NAME_LIMIT = "limit";
  @SerializedName(SERIALIZED_NAME_LIMIT)
  private Integer limit;

  public static final String SERIALIZED_NAME_ORDER = "order";
  @SerializedName(SERIALIZED_NAME_ORDER)
  private String order;

  public V1ListPaymentsRequest() {
  }

  public V1ListPaymentsRequest batchToken(String batchToken) {
    this.batchToken = batchToken;
    return this;
  }

  /**
   * A pagination cursor to retrieve the next set of results for your original query to the endpoint.
   * @return batchToken
   */
  @javax.annotation.Nullable
  public String getBatchToken() {
    return batchToken;
  }

  public void setBatchToken(String batchToken) {
    this.batchToken = batchToken;
  }


  public V1ListPaymentsRequest beginTime(String beginTime) {
    this.beginTime = beginTime;
    return this;
  }

  /**
   * The beginning of the requested reporting period, in ISO 8601 format. If this value is before January 1, 2013 (2013-01-01T00:00:00Z), this endpoint returns an error. Default value: The current time minus one year.
   * @return beginTime
   */
  @javax.annotation.Nullable
  public String getBeginTime() {
    return beginTime;
  }

  public void setBeginTime(String beginTime) {
    this.beginTime = beginTime;
  }


  public V1ListPaymentsRequest endTime(String endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * The end of the requested reporting period, in ISO 8601 format. If this value is more than one year greater than begin_time, this endpoint returns an error. Default value: The current time.
   * @return endTime
   */
  @javax.annotation.Nullable
  public String getEndTime() {
    return endTime;
  }

  public void setEndTime(String endTime) {
    this.endTime = endTime;
  }


  public V1ListPaymentsRequest includePartial(Boolean includePartial) {
    this.includePartial = includePartial;
    return this;
  }

  /**
   * Indicates whether or not to include partial payments in the response. Partial payments will have the tenders collected so far, but the itemizations will be empty until the payment is completed.
   * @return includePartial
   */
  @javax.annotation.Nullable
  public Boolean getIncludePartial() {
    return includePartial;
  }

  public void setIncludePartial(Boolean includePartial) {
    this.includePartial = includePartial;
  }


  public V1ListPaymentsRequest limit(Integer limit) {
    this.limit = limit;
    return this;
  }

  /**
   * The maximum number of payments to return in a single response. This value cannot exceed 200.
   * @return limit
   */
  @javax.annotation.Nullable
  public Integer getLimit() {
    return limit;
  }

  public void setLimit(Integer limit) {
    this.limit = limit;
  }


  public V1ListPaymentsRequest order(String order) {
    this.order = order;
    return this;
  }

  /**
   * The order in which payments are listed in the response.
   * @return order
   */
  @javax.annotation.Nullable
  public String getOrder() {
    return order;
  }

  public void setOrder(String order) {
    this.order = order;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1ListPaymentsRequest v1ListPaymentsRequest = (V1ListPaymentsRequest) o;
    return Objects.equals(this.batchToken, v1ListPaymentsRequest.batchToken) &&
        Objects.equals(this.beginTime, v1ListPaymentsRequest.beginTime) &&
        Objects.equals(this.endTime, v1ListPaymentsRequest.endTime) &&
        Objects.equals(this.includePartial, v1ListPaymentsRequest.includePartial) &&
        Objects.equals(this.limit, v1ListPaymentsRequest.limit) &&
        Objects.equals(this.order, v1ListPaymentsRequest.order);
  }

  @Override
  public int hashCode() {
    return Objects.hash(batchToken, beginTime, endTime, includePartial, limit, order);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1ListPaymentsRequest {\n");
    sb.append("    batchToken: ").append(toIndentedString(batchToken)).append("\n");
    sb.append("    beginTime: ").append(toIndentedString(beginTime)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    includePartial: ").append(toIndentedString(includePartial)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    order: ").append(toIndentedString(order)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("batch_token");
    openapiFields.add("begin_time");
    openapiFields.add("end_time");
    openapiFields.add("include_partial");
    openapiFields.add("limit");
    openapiFields.add("order");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to V1ListPaymentsRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!V1ListPaymentsRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1ListPaymentsRequest is not found in the empty JSON string", V1ListPaymentsRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!V1ListPaymentsRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1ListPaymentsRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("batch_token") != null && !jsonObj.get("batch_token").isJsonNull()) && !jsonObj.get("batch_token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `batch_token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("batch_token").toString()));
      }
      if ((jsonObj.get("begin_time") != null && !jsonObj.get("begin_time").isJsonNull()) && !jsonObj.get("begin_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `begin_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("begin_time").toString()));
      }
      if ((jsonObj.get("end_time") != null && !jsonObj.get("end_time").isJsonNull()) && !jsonObj.get("end_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `end_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("end_time").toString()));
      }
      if ((jsonObj.get("order") != null && !jsonObj.get("order").isJsonNull()) && !jsonObj.get("order").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `order` to be a primitive type in the JSON string but got `%s`", jsonObj.get("order").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1ListPaymentsRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1ListPaymentsRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1ListPaymentsRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1ListPaymentsRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<V1ListPaymentsRequest>() {
           @Override
           public void write(JsonWriter out, V1ListPaymentsRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1ListPaymentsRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of V1ListPaymentsRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of V1ListPaymentsRequest
   * @throws IOException if the JSON string is invalid with respect to V1ListPaymentsRequest
   */
  public static V1ListPaymentsRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1ListPaymentsRequest.class);
  }

  /**
   * Convert an instance of V1ListPaymentsRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

