/*
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A filter to select customers based on exact or fuzzy matching of customer attributes against a specified query. Depending on the customer attributes,  the filter can be case-sensitive. This filter can be exact or fuzzy, but it cannot be both.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:20:53.300629-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CustomerTextFilter {
  public static final String SERIALIZED_NAME_EXACT = "exact";
  @SerializedName(SERIALIZED_NAME_EXACT)
  private String exact;

  public static final String SERIALIZED_NAME_FUZZY = "fuzzy";
  @SerializedName(SERIALIZED_NAME_FUZZY)
  private String fuzzy;

  public CustomerTextFilter() {
  }

  public CustomerTextFilter exact(String exact) {
    this.exact = exact;
    return this;
  }

  /**
   * Use the exact filter to select customers whose attributes match exactly the specified query.
   * @return exact
   */
  @javax.annotation.Nullable
  public String getExact() {
    return exact;
  }

  public void setExact(String exact) {
    this.exact = exact;
  }


  public CustomerTextFilter fuzzy(String fuzzy) {
    this.fuzzy = fuzzy;
    return this;
  }

  /**
   * Use the fuzzy filter to select customers whose attributes match the specified query  in a fuzzy manner. When the fuzzy option is used, search queries are tokenized, and then  each query token must be matched somewhere in the searched attribute. For single token queries,  this is effectively the same behavior as a partial match operation.
   * @return fuzzy
   */
  @javax.annotation.Nullable
  public String getFuzzy() {
    return fuzzy;
  }

  public void setFuzzy(String fuzzy) {
    this.fuzzy = fuzzy;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CustomerTextFilter customerTextFilter = (CustomerTextFilter) o;
    return Objects.equals(this.exact, customerTextFilter.exact) &&
        Objects.equals(this.fuzzy, customerTextFilter.fuzzy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(exact, fuzzy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CustomerTextFilter {\n");
    sb.append("    exact: ").append(toIndentedString(exact)).append("\n");
    sb.append("    fuzzy: ").append(toIndentedString(fuzzy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("exact");
    openapiFields.add("fuzzy");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CustomerTextFilter
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CustomerTextFilter.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CustomerTextFilter is not found in the empty JSON string", CustomerTextFilter.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CustomerTextFilter.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CustomerTextFilter` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("exact") != null && !jsonObj.get("exact").isJsonNull()) && !jsonObj.get("exact").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `exact` to be a primitive type in the JSON string but got `%s`", jsonObj.get("exact").toString()));
      }
      if ((jsonObj.get("fuzzy") != null && !jsonObj.get("fuzzy").isJsonNull()) && !jsonObj.get("fuzzy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fuzzy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fuzzy").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CustomerTextFilter.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CustomerTextFilter' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CustomerTextFilter> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CustomerTextFilter.class));

       return (TypeAdapter<T>) new TypeAdapter<CustomerTextFilter>() {
           @Override
           public void write(JsonWriter out, CustomerTextFilter value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CustomerTextFilter read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CustomerTextFilter given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CustomerTextFilter
   * @throws IOException if the JSON string is invalid with respect to CustomerTextFilter
   */
  public static CustomerTextFilter fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CustomerTextFilter.class);
  }

  /**
   * Convert an instance of CustomerTextFilter to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

