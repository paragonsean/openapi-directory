/*
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CatalogItemModifierListInfo;
import org.openapitools.client.model.CatalogItemOptionForItem;
import org.openapitools.client.model.CatalogObject;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A [CatalogObject](https://developer.squareup.com/reference/square_2021-08-18/objects/CatalogObject) instance of the &#x60;ITEM&#x60; type, also referred to as an item, in the catalog.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:20:53.300629-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CatalogItem {
  public static final String SERIALIZED_NAME_ABBREVIATION = "abbreviation";
  @SerializedName(SERIALIZED_NAME_ABBREVIATION)
  private String abbreviation;

  public static final String SERIALIZED_NAME_AVAILABLE_ELECTRONICALLY = "available_electronically";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_ELECTRONICALLY)
  private Boolean availableElectronically;

  public static final String SERIALIZED_NAME_AVAILABLE_FOR_PICKUP = "available_for_pickup";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_FOR_PICKUP)
  private Boolean availableForPickup;

  public static final String SERIALIZED_NAME_AVAILABLE_ONLINE = "available_online";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_ONLINE)
  private Boolean availableOnline;

  public static final String SERIALIZED_NAME_CATEGORY_ID = "category_id";
  @SerializedName(SERIALIZED_NAME_CATEGORY_ID)
  private String categoryId;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ITEM_OPTIONS = "item_options";
  @SerializedName(SERIALIZED_NAME_ITEM_OPTIONS)
  private List<CatalogItemOptionForItem> itemOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_LABEL_COLOR = "label_color";
  @SerializedName(SERIALIZED_NAME_LABEL_COLOR)
  private String labelColor;

  public static final String SERIALIZED_NAME_MODIFIER_LIST_INFO = "modifier_list_info";
  @SerializedName(SERIALIZED_NAME_MODIFIER_LIST_INFO)
  private List<CatalogItemModifierListInfo> modifierListInfo = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PRODUCT_TYPE = "product_type";
  @SerializedName(SERIALIZED_NAME_PRODUCT_TYPE)
  private String productType;

  public static final String SERIALIZED_NAME_SKIP_MODIFIER_SCREEN = "skip_modifier_screen";
  @SerializedName(SERIALIZED_NAME_SKIP_MODIFIER_SCREEN)
  private Boolean skipModifierScreen;

  public static final String SERIALIZED_NAME_SORT_NAME = "sort_name";
  @SerializedName(SERIALIZED_NAME_SORT_NAME)
  private String sortName;

  public static final String SERIALIZED_NAME_TAX_IDS = "tax_ids";
  @SerializedName(SERIALIZED_NAME_TAX_IDS)
  private List<String> taxIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_VARIATIONS = "variations";
  @SerializedName(SERIALIZED_NAME_VARIATIONS)
  private List<CatalogObject> variations = new ArrayList<>();

  public CatalogItem() {
  }

  public CatalogItem abbreviation(String abbreviation) {
    this.abbreviation = abbreviation;
    return this;
  }

  /**
   * The text of the item&#39;s display label in the Square Point of Sale app. Only up to the first five characters of the string are used. This attribute is searchable, and its value length is of Unicode code points.
   * @return abbreviation
   */
  @javax.annotation.Nullable
  public String getAbbreviation() {
    return abbreviation;
  }

  public void setAbbreviation(String abbreviation) {
    this.abbreviation = abbreviation;
  }


  public CatalogItem availableElectronically(Boolean availableElectronically) {
    this.availableElectronically = availableElectronically;
    return this;
  }

  /**
   * If &#x60;true&#x60;, the item can be added to electronically fulfilled orders from the merchant&#39;s online store.
   * @return availableElectronically
   */
  @javax.annotation.Nullable
  public Boolean getAvailableElectronically() {
    return availableElectronically;
  }

  public void setAvailableElectronically(Boolean availableElectronically) {
    this.availableElectronically = availableElectronically;
  }


  public CatalogItem availableForPickup(Boolean availableForPickup) {
    this.availableForPickup = availableForPickup;
    return this;
  }

  /**
   * If &#x60;true&#x60;, the item can be added to pickup orders from the merchant&#39;s online store.
   * @return availableForPickup
   */
  @javax.annotation.Nullable
  public Boolean getAvailableForPickup() {
    return availableForPickup;
  }

  public void setAvailableForPickup(Boolean availableForPickup) {
    this.availableForPickup = availableForPickup;
  }


  public CatalogItem availableOnline(Boolean availableOnline) {
    this.availableOnline = availableOnline;
    return this;
  }

  /**
   * If &#x60;true&#x60;, the item can be added to shipping orders from the merchant&#39;s online store.
   * @return availableOnline
   */
  @javax.annotation.Nullable
  public Boolean getAvailableOnline() {
    return availableOnline;
  }

  public void setAvailableOnline(Boolean availableOnline) {
    this.availableOnline = availableOnline;
  }


  public CatalogItem categoryId(String categoryId) {
    this.categoryId = categoryId;
    return this;
  }

  /**
   * The ID of the item&#39;s category, if any.
   * @return categoryId
   */
  @javax.annotation.Nullable
  public String getCategoryId() {
    return categoryId;
  }

  public void setCategoryId(String categoryId) {
    this.categoryId = categoryId;
  }


  public CatalogItem description(String description) {
    this.description = description;
    return this;
  }

  /**
   * The item&#39;s description. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public CatalogItem itemOptions(List<CatalogItemOptionForItem> itemOptions) {
    this.itemOptions = itemOptions;
    return this;
  }

  public CatalogItem addItemOptionsItem(CatalogItemOptionForItem itemOptionsItem) {
    if (this.itemOptions == null) {
      this.itemOptions = new ArrayList<>();
    }
    this.itemOptions.add(itemOptionsItem);
    return this;
  }

  /**
   * List of item options IDs for this item. Used to manage and group item variations in a specified order.  Maximum: 6 item options.
   * @return itemOptions
   */
  @javax.annotation.Nullable
  public List<CatalogItemOptionForItem> getItemOptions() {
    return itemOptions;
  }

  public void setItemOptions(List<CatalogItemOptionForItem> itemOptions) {
    this.itemOptions = itemOptions;
  }


  public CatalogItem labelColor(String labelColor) {
    this.labelColor = labelColor;
    return this;
  }

  /**
   * The color of the item&#39;s display label in the Square Point of Sale app. This must be a valid hex color code.
   * @return labelColor
   */
  @javax.annotation.Nullable
  public String getLabelColor() {
    return labelColor;
  }

  public void setLabelColor(String labelColor) {
    this.labelColor = labelColor;
  }


  public CatalogItem modifierListInfo(List<CatalogItemModifierListInfo> modifierListInfo) {
    this.modifierListInfo = modifierListInfo;
    return this;
  }

  public CatalogItem addModifierListInfoItem(CatalogItemModifierListInfo modifierListInfoItem) {
    if (this.modifierListInfo == null) {
      this.modifierListInfo = new ArrayList<>();
    }
    this.modifierListInfo.add(modifierListInfoItem);
    return this;
  }

  /**
   * A set of &#x60;CatalogItemModifierListInfo&#x60; objects representing the modifier lists that apply to this item, along with the overrides and min and max limits that are specific to this item. Modifier lists may also be added to or deleted from an item using &#x60;UpdateItemModifierLists&#x60;.
   * @return modifierListInfo
   */
  @javax.annotation.Nullable
  public List<CatalogItemModifierListInfo> getModifierListInfo() {
    return modifierListInfo;
  }

  public void setModifierListInfo(List<CatalogItemModifierListInfo> modifierListInfo) {
    this.modifierListInfo = modifierListInfo;
  }


  public CatalogItem name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The item&#39;s name. This is a searchable attribute for use in applicable query filters, its value must not be empty, and the length is of Unicode code points.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public CatalogItem productType(String productType) {
    this.productType = productType;
    return this;
  }

  /**
   * The product type of the item. May not be changed once an item has been created.  Only items of product type &#x60;REGULAR&#x60; or &#x60;APPOINTMENTS_SERVICE&#x60; may be created by this API; items with other product types are read-only.
   * @return productType
   */
  @javax.annotation.Nullable
  public String getProductType() {
    return productType;
  }

  public void setProductType(String productType) {
    this.productType = productType;
  }


  public CatalogItem skipModifierScreen(Boolean skipModifierScreen) {
    this.skipModifierScreen = skipModifierScreen;
    return this;
  }

  /**
   * If &#x60;false&#x60;, the Square Point of Sale app will present the &#x60;CatalogItem&#x60;&#39;s details screen immediately, allowing the merchant to choose &#x60;CatalogModifier&#x60;s before adding the item to the cart.  This is the default behavior.  If &#x60;true&#x60;, the Square Point of Sale app will immediately add the item to the cart with the pre-selected modifiers, and merchants can edit modifiers by drilling down onto the item&#39;s details.  Third-party clients are encouraged to implement similar behaviors.
   * @return skipModifierScreen
   */
  @javax.annotation.Nullable
  public Boolean getSkipModifierScreen() {
    return skipModifierScreen;
  }

  public void setSkipModifierScreen(Boolean skipModifierScreen) {
    this.skipModifierScreen = skipModifierScreen;
  }


  public CatalogItem sortName(String sortName) {
    this.sortName = sortName;
    return this;
  }

  /**
   * A name to sort the item by. If this name is unspecified, namely, the &#x60;sort_name&#x60; field is absent, the regular &#x60;name&#x60; field is used for sorting.  It is currently supported for sellers of the Japanese locale only.
   * @return sortName
   */
  @javax.annotation.Nullable
  public String getSortName() {
    return sortName;
  }

  public void setSortName(String sortName) {
    this.sortName = sortName;
  }


  public CatalogItem taxIds(List<String> taxIds) {
    this.taxIds = taxIds;
    return this;
  }

  public CatalogItem addTaxIdsItem(String taxIdsItem) {
    if (this.taxIds == null) {
      this.taxIds = new ArrayList<>();
    }
    this.taxIds.add(taxIdsItem);
    return this;
  }

  /**
   * A set of IDs indicating the taxes enabled for this item. When updating an item, any taxes listed here will be added to the item. Taxes may also be added to or deleted from an item using &#x60;UpdateItemTaxes&#x60;.
   * @return taxIds
   */
  @javax.annotation.Nullable
  public List<String> getTaxIds() {
    return taxIds;
  }

  public void setTaxIds(List<String> taxIds) {
    this.taxIds = taxIds;
  }


  public CatalogItem variations(List<CatalogObject> variations) {
    this.variations = variations;
    return this;
  }

  public CatalogItem addVariationsItem(CatalogObject variationsItem) {
    if (this.variations == null) {
      this.variations = new ArrayList<>();
    }
    this.variations.add(variationsItem);
    return this;
  }

  /**
   * A list of [CatalogItemVariation](https://developer.squareup.com/reference/square_2021-08-18/objects/CatalogItemVariation) objects for this item. An item must have at least one variation.
   * @return variations
   */
  @javax.annotation.Nullable
  public List<CatalogObject> getVariations() {
    return variations;
  }

  public void setVariations(List<CatalogObject> variations) {
    this.variations = variations;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CatalogItem catalogItem = (CatalogItem) o;
    return Objects.equals(this.abbreviation, catalogItem.abbreviation) &&
        Objects.equals(this.availableElectronically, catalogItem.availableElectronically) &&
        Objects.equals(this.availableForPickup, catalogItem.availableForPickup) &&
        Objects.equals(this.availableOnline, catalogItem.availableOnline) &&
        Objects.equals(this.categoryId, catalogItem.categoryId) &&
        Objects.equals(this.description, catalogItem.description) &&
        Objects.equals(this.itemOptions, catalogItem.itemOptions) &&
        Objects.equals(this.labelColor, catalogItem.labelColor) &&
        Objects.equals(this.modifierListInfo, catalogItem.modifierListInfo) &&
        Objects.equals(this.name, catalogItem.name) &&
        Objects.equals(this.productType, catalogItem.productType) &&
        Objects.equals(this.skipModifierScreen, catalogItem.skipModifierScreen) &&
        Objects.equals(this.sortName, catalogItem.sortName) &&
        Objects.equals(this.taxIds, catalogItem.taxIds) &&
        Objects.equals(this.variations, catalogItem.variations);
  }

  @Override
  public int hashCode() {
    return Objects.hash(abbreviation, availableElectronically, availableForPickup, availableOnline, categoryId, description, itemOptions, labelColor, modifierListInfo, name, productType, skipModifierScreen, sortName, taxIds, variations);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CatalogItem {\n");
    sb.append("    abbreviation: ").append(toIndentedString(abbreviation)).append("\n");
    sb.append("    availableElectronically: ").append(toIndentedString(availableElectronically)).append("\n");
    sb.append("    availableForPickup: ").append(toIndentedString(availableForPickup)).append("\n");
    sb.append("    availableOnline: ").append(toIndentedString(availableOnline)).append("\n");
    sb.append("    categoryId: ").append(toIndentedString(categoryId)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    itemOptions: ").append(toIndentedString(itemOptions)).append("\n");
    sb.append("    labelColor: ").append(toIndentedString(labelColor)).append("\n");
    sb.append("    modifierListInfo: ").append(toIndentedString(modifierListInfo)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    productType: ").append(toIndentedString(productType)).append("\n");
    sb.append("    skipModifierScreen: ").append(toIndentedString(skipModifierScreen)).append("\n");
    sb.append("    sortName: ").append(toIndentedString(sortName)).append("\n");
    sb.append("    taxIds: ").append(toIndentedString(taxIds)).append("\n");
    sb.append("    variations: ").append(toIndentedString(variations)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("abbreviation");
    openapiFields.add("available_electronically");
    openapiFields.add("available_for_pickup");
    openapiFields.add("available_online");
    openapiFields.add("category_id");
    openapiFields.add("description");
    openapiFields.add("item_options");
    openapiFields.add("label_color");
    openapiFields.add("modifier_list_info");
    openapiFields.add("name");
    openapiFields.add("product_type");
    openapiFields.add("skip_modifier_screen");
    openapiFields.add("sort_name");
    openapiFields.add("tax_ids");
    openapiFields.add("variations");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CatalogItem
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CatalogItem.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CatalogItem is not found in the empty JSON string", CatalogItem.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CatalogItem.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CatalogItem` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("abbreviation") != null && !jsonObj.get("abbreviation").isJsonNull()) && !jsonObj.get("abbreviation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `abbreviation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("abbreviation").toString()));
      }
      if ((jsonObj.get("category_id") != null && !jsonObj.get("category_id").isJsonNull()) && !jsonObj.get("category_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `category_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("category_id").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if (jsonObj.get("item_options") != null && !jsonObj.get("item_options").isJsonNull()) {
        JsonArray jsonArrayitemOptions = jsonObj.getAsJsonArray("item_options");
        if (jsonArrayitemOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("item_options").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `item_options` to be an array in the JSON string but got `%s`", jsonObj.get("item_options").toString()));
          }

          // validate the optional field `item_options` (array)
          for (int i = 0; i < jsonArrayitemOptions.size(); i++) {
            CatalogItemOptionForItem.validateJsonElement(jsonArrayitemOptions.get(i));
          };
        }
      }
      if ((jsonObj.get("label_color") != null && !jsonObj.get("label_color").isJsonNull()) && !jsonObj.get("label_color").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `label_color` to be a primitive type in the JSON string but got `%s`", jsonObj.get("label_color").toString()));
      }
      if (jsonObj.get("modifier_list_info") != null && !jsonObj.get("modifier_list_info").isJsonNull()) {
        JsonArray jsonArraymodifierListInfo = jsonObj.getAsJsonArray("modifier_list_info");
        if (jsonArraymodifierListInfo != null) {
          // ensure the json data is an array
          if (!jsonObj.get("modifier_list_info").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `modifier_list_info` to be an array in the JSON string but got `%s`", jsonObj.get("modifier_list_info").toString()));
          }

          // validate the optional field `modifier_list_info` (array)
          for (int i = 0; i < jsonArraymodifierListInfo.size(); i++) {
            CatalogItemModifierListInfo.validateJsonElement(jsonArraymodifierListInfo.get(i));
          };
        }
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("product_type") != null && !jsonObj.get("product_type").isJsonNull()) && !jsonObj.get("product_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `product_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("product_type").toString()));
      }
      if ((jsonObj.get("sort_name") != null && !jsonObj.get("sort_name").isJsonNull()) && !jsonObj.get("sort_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sort_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sort_name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tax_ids") != null && !jsonObj.get("tax_ids").isJsonNull() && !jsonObj.get("tax_ids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tax_ids` to be an array in the JSON string but got `%s`", jsonObj.get("tax_ids").toString()));
      }
      if (jsonObj.get("variations") != null && !jsonObj.get("variations").isJsonNull()) {
        JsonArray jsonArrayvariations = jsonObj.getAsJsonArray("variations");
        if (jsonArrayvariations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("variations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `variations` to be an array in the JSON string but got `%s`", jsonObj.get("variations").toString()));
          }

          // validate the optional field `variations` (array)
          for (int i = 0; i < jsonArrayvariations.size(); i++) {
            CatalogObject.validateJsonElement(jsonArrayvariations.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CatalogItem.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CatalogItem' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CatalogItem> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CatalogItem.class));

       return (TypeAdapter<T>) new TypeAdapter<CatalogItem>() {
           @Override
           public void write(JsonWriter out, CatalogItem value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CatalogItem read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CatalogItem given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CatalogItem
   * @throws IOException if the JSON string is invalid with respect to CatalogItem
   */
  public static CatalogItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CatalogItem.class);
  }

  /**
   * Convert an instance of CatalogItem to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

