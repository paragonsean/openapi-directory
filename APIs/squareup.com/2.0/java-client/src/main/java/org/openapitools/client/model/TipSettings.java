/*
 * Square Connect API
 * Client library for accessing the Square Connect APIs
 *
 * The version of the OpenAPI document: 2.0
 * Contact: developers@squareup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:20:53.300629-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TipSettings {
  public static final String SERIALIZED_NAME_ALLOW_TIPPING = "allow_tipping";
  @SerializedName(SERIALIZED_NAME_ALLOW_TIPPING)
  private Boolean allowTipping;

  public static final String SERIALIZED_NAME_CUSTOM_TIP_FIELD = "custom_tip_field";
  @SerializedName(SERIALIZED_NAME_CUSTOM_TIP_FIELD)
  private Boolean customTipField;

  public static final String SERIALIZED_NAME_SEPARATE_TIP_SCREEN = "separate_tip_screen";
  @SerializedName(SERIALIZED_NAME_SEPARATE_TIP_SCREEN)
  private Boolean separateTipScreen;

  public static final String SERIALIZED_NAME_SMART_TIPPING = "smart_tipping";
  @SerializedName(SERIALIZED_NAME_SMART_TIPPING)
  private Boolean smartTipping;

  public static final String SERIALIZED_NAME_TIP_PERCENTAGES = "tip_percentages";
  @SerializedName(SERIALIZED_NAME_TIP_PERCENTAGES)
  private List<Integer> tipPercentages = new ArrayList<>();

  public TipSettings() {
  }

  public TipSettings allowTipping(Boolean allowTipping) {
    this.allowTipping = allowTipping;
    return this;
  }

  /**
   * Indicates whether tipping is enabled for this checkout. Defaults to false.
   * @return allowTipping
   */
  @javax.annotation.Nullable
  public Boolean getAllowTipping() {
    return allowTipping;
  }

  public void setAllowTipping(Boolean allowTipping) {
    this.allowTipping = allowTipping;
  }


  public TipSettings customTipField(Boolean customTipField) {
    this.customTipField = customTipField;
    return this;
  }

  /**
   * Indicates whether custom tip amounts are allowed during the checkout flow. Defaults to false.
   * @return customTipField
   */
  @javax.annotation.Nullable
  public Boolean getCustomTipField() {
    return customTipField;
  }

  public void setCustomTipField(Boolean customTipField) {
    this.customTipField = customTipField;
  }


  public TipSettings separateTipScreen(Boolean separateTipScreen) {
    this.separateTipScreen = separateTipScreen;
    return this;
  }

  /**
   * Indicates whether tip options should be presented on the screen before presenting the signature screen during card payment. Defaults to false.
   * @return separateTipScreen
   */
  @javax.annotation.Nullable
  public Boolean getSeparateTipScreen() {
    return separateTipScreen;
  }

  public void setSeparateTipScreen(Boolean separateTipScreen) {
    this.separateTipScreen = separateTipScreen;
  }


  public TipSettings smartTipping(Boolean smartTipping) {
    this.smartTipping = smartTipping;
    return this;
  }

  /**
   * Enables the \&quot;Smart Tip Amounts\&quot; behavior. Exact tipping options depend on the region in which the Square seller is active.  For payments under 10.00, in the Australia, Canada, Ireland, United Kingdom, and United States, tipping options are presented as no tip, .50, 1.00 or 2.00.  For payment amounts of 10.00 or greater, tipping options are presented as the following percentages: 0%, 5%, 10%, 15%.  If set to true, the &#x60;tip_percentages&#x60; settings is ignored. Defaults to false.  To learn more about smart tipping, see [Accept Tips with the Square App](https://squareup.com/help/us/en/article/5069-accept-tips-with-the-square-app).
   * @return smartTipping
   */
  @javax.annotation.Nullable
  public Boolean getSmartTipping() {
    return smartTipping;
  }

  public void setSmartTipping(Boolean smartTipping) {
    this.smartTipping = smartTipping;
  }


  public TipSettings tipPercentages(List<Integer> tipPercentages) {
    this.tipPercentages = tipPercentages;
    return this;
  }

  public TipSettings addTipPercentagesItem(Integer tipPercentagesItem) {
    if (this.tipPercentages == null) {
      this.tipPercentages = new ArrayList<>();
    }
    this.tipPercentages.add(tipPercentagesItem);
    return this;
  }

  /**
   * A list of tip percentages that should be presented during the checkout flow, specified as up to 3 non-negative integers from 0 to 100 (inclusive). Defaults to 15, 20, and 25.
   * @return tipPercentages
   */
  @javax.annotation.Nullable
  public List<Integer> getTipPercentages() {
    return tipPercentages;
  }

  public void setTipPercentages(List<Integer> tipPercentages) {
    this.tipPercentages = tipPercentages;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TipSettings tipSettings = (TipSettings) o;
    return Objects.equals(this.allowTipping, tipSettings.allowTipping) &&
        Objects.equals(this.customTipField, tipSettings.customTipField) &&
        Objects.equals(this.separateTipScreen, tipSettings.separateTipScreen) &&
        Objects.equals(this.smartTipping, tipSettings.smartTipping) &&
        Objects.equals(this.tipPercentages, tipSettings.tipPercentages);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowTipping, customTipField, separateTipScreen, smartTipping, tipPercentages);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TipSettings {\n");
    sb.append("    allowTipping: ").append(toIndentedString(allowTipping)).append("\n");
    sb.append("    customTipField: ").append(toIndentedString(customTipField)).append("\n");
    sb.append("    separateTipScreen: ").append(toIndentedString(separateTipScreen)).append("\n");
    sb.append("    smartTipping: ").append(toIndentedString(smartTipping)).append("\n");
    sb.append("    tipPercentages: ").append(toIndentedString(tipPercentages)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allow_tipping");
    openapiFields.add("custom_tip_field");
    openapiFields.add("separate_tip_screen");
    openapiFields.add("smart_tipping");
    openapiFields.add("tip_percentages");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TipSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TipSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TipSettings is not found in the empty JSON string", TipSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TipSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TipSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("tip_percentages") != null && !jsonObj.get("tip_percentages").isJsonNull() && !jsonObj.get("tip_percentages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tip_percentages` to be an array in the JSON string but got `%s`", jsonObj.get("tip_percentages").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TipSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TipSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TipSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TipSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<TipSettings>() {
           @Override
           public void write(JsonWriter out, TipSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TipSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TipSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TipSettings
   * @throws IOException if the JSON string is invalid with respect to TipSettings
   */
  public static TipSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TipSettings.class);
  }

  /**
   * Convert an instance of TipSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

