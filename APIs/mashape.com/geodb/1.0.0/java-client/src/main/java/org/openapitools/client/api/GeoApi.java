/*
 * GeoDB Cities API
 * The GeoDB API focuses on getting global city and region data. Easily obtain country, region, and city data for use in your apps!  <ul>   <li>Filter cities by name prefix, country, location, time-zone, and even minimum population.</li>   <li>Sort cities by name, country code, elevation, and population - or any combination of these.</li>    <li>Get all country regions.</li> <li>Get all cities in a given region.</li>   <li>     Display results in multiple languages.</li> <li>RESTful API adheres to industry best-practices, including     HATEOAS-style links to facilitate paging results.   </li>    <li>Backed by cloud-based load-balanced infrastructure for resiliency and performance!</li>   <li>Data is periodically refreshed from GeoNames and WikiData.</li> </ul> <p>Notes: <ul>   <li>     Since the database is periodically updated, this may <strong>very rarely</strong> result in certain cities     being marked deleted (e.g., duplicates removed). By default, endpoints returning city data will exclude     cities marked deleted. However, in the unlikely event that this occurs while your app is paging through a set     of affected results - and you care about the paged results suddenly changing underneath - specify      <tt>includeDeleted=SINCE_YESTERDAY</tt> (or <tt>SINCE_LAST_WEEK</tt> if you're really paranoid!).   </li> </ul> <hr/> <h3>Useful Resources</h3> <ul>   <li>     SDKs     <ul>       <li>         <a href='https://www.npmjs.com/package/wft-geodb-angular-client'>Angular</a>,          <a href='https://github.com/wirefreethought/geodb-sample-angular-app'>Sample App</a>       </li>       <li><a href='https://github.com/wirefreethought/geodb-java-client'>Java</a></li>       <li><a href='https://www.npmjs.com/package/wft-geodb-js-client'>JavaScript</a></li>     </ul>     <li><a href='swagger.json'>Swagger Docs</a></li>     <li><a href='http://creativecommons.org/licenses/by/3.0/'>Usage License</a></li>   </li>       </ul> 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.BadRequestResponse;
import org.openapitools.client.model.CountriesResponse;
import org.openapitools.client.model.CountryResponse;
import org.openapitools.client.model.DateTimeResponse;
import org.openapitools.client.model.DistanceResponse;
import org.openapitools.client.model.ForbiddenResponse;
import org.openapitools.client.model.NotFoundResponse;
import org.openapitools.client.model.PopulatedPlaceResponse;
import org.openapitools.client.model.PopulatedPlacesResponse;
import org.openapitools.client.model.RegionResponse;
import org.openapitools.client.model.RegionsResponse;
import org.openapitools.client.model.TimeResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GeoApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public GeoApi() {
        this(Configuration.getDefaultApiClient());
    }

    public GeoApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for findAdminDivisionsUsingGET
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findAdminDivisionsUsingGETCall(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/adminDivisions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (location != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("location", location));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (countryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryIds", countryIds));
        }

        if (excludedCountryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludedCountryIds", excludedCountryIds));
        }

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findAdminDivisionsUsingGETValidateBeforeCall(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        return findAdminDivisionsUsingGETCall(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find administrative divisions
     * Find administrative divisions, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findAdminDivisionsUsingGET(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findAdminDivisionsUsingGETWithHttpInfo(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find administrative divisions
     * Find administrative divisions, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findAdminDivisionsUsingGETWithHttpInfo(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findAdminDivisionsUsingGETValidateBeforeCall(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find administrative divisions (asynchronously)
     * Find administrative divisions, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findAdminDivisionsUsingGETAsync(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findAdminDivisionsUsingGETValidateBeforeCall(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findCitiesNearAdminDivisionUsingGET
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesNearAdminDivisionUsingGETCall(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/adminDivisions/{divisionId}/nearbyCities"
            .replace("{" + "divisionId" + "}", localVarApiClient.escapeString(divisionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (countryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryIds", countryIds));
        }

        if (excludedCountryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludedCountryIds", excludedCountryIds));
        }

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findCitiesNearAdminDivisionUsingGETValidateBeforeCall(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'divisionId' is set
        if (divisionId == null) {
            throw new ApiException("Missing the required parameter 'divisionId' when calling findCitiesNearAdminDivisionUsingGET(Async)");
        }

        return findCitiesNearAdminDivisionUsingGETCall(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find cities near division
     * Find cities near the given administrative division, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findCitiesNearAdminDivisionUsingGET(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findCitiesNearAdminDivisionUsingGETWithHttpInfo(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find cities near division
     * Find cities near the given administrative division, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findCitiesNearAdminDivisionUsingGETWithHttpInfo(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findCitiesNearAdminDivisionUsingGETValidateBeforeCall(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find cities near division (asynchronously)
     * Find cities near the given administrative division, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesNearAdminDivisionUsingGETAsync(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findCitiesNearAdminDivisionUsingGETValidateBeforeCall(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findCitiesNearCityUsingGET
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesNearCityUsingGETCall(String cityId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/cities/{cityId}/nearbyCities"
            .replace("{" + "cityId" + "}", localVarApiClient.escapeString(cityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (countryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryIds", countryIds));
        }

        if (excludedCountryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludedCountryIds", excludedCountryIds));
        }

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findCitiesNearCityUsingGETValidateBeforeCall(String cityId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'cityId' is set
        if (cityId == null) {
            throw new ApiException("Missing the required parameter 'cityId' when calling findCitiesNearCityUsingGET(Async)");
        }

        return findCitiesNearCityUsingGETCall(cityId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find cities near city
     * Find cities near the given origin city, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findCitiesNearCityUsingGET(String cityId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findCitiesNearCityUsingGETWithHttpInfo(cityId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find cities near city
     * Find cities near the given origin city, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findCitiesNearCityUsingGETWithHttpInfo(String cityId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findCitiesNearCityUsingGETValidateBeforeCall(cityId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find cities near city (asynchronously)
     * Find cities near the given origin city, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesNearCityUsingGETAsync(String cityId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findCitiesNearCityUsingGETValidateBeforeCall(cityId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findCitiesNearLocationUsingGET
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesNearLocationUsingGETCall(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/locations/{locationId}/nearbyCities"
            .replace("{" + "locationId" + "}", localVarApiClient.escapeString(locationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (countryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryIds", countryIds));
        }

        if (excludedCountryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludedCountryIds", excludedCountryIds));
        }

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findCitiesNearLocationUsingGETValidateBeforeCall(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'locationId' is set
        if (locationId == null) {
            throw new ApiException("Missing the required parameter 'locationId' when calling findCitiesNearLocationUsingGET(Async)");
        }

        return findCitiesNearLocationUsingGETCall(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find cities near location
     * Find cities near the given location, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findCitiesNearLocationUsingGET(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findCitiesNearLocationUsingGETWithHttpInfo(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find cities near location
     * Find cities near the given location, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findCitiesNearLocationUsingGETWithHttpInfo(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findCitiesNearLocationUsingGETValidateBeforeCall(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find cities near location (asynchronously)
     * Find cities near the given location, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesNearLocationUsingGETAsync(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findCitiesNearLocationUsingGETValidateBeforeCall(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findCitiesUsingGET
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesUsingGETCall(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/cities";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (location != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("location", location));
        }

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (countryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryIds", countryIds));
        }

        if (excludedCountryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludedCountryIds", excludedCountryIds));
        }

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findCitiesUsingGETValidateBeforeCall(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        return findCitiesUsingGETCall(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find cities
     * Find cities, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findCitiesUsingGET(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findCitiesUsingGETWithHttpInfo(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find cities
     * Find cities, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findCitiesUsingGETWithHttpInfo(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findCitiesUsingGETValidateBeforeCall(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find cities (asynchronously)
     * Find cities, filtering by optional criteria. If no criteria are set, you will get back all known cities. 
     * @param location Only places near this location. Latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (optional)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findCitiesUsingGETAsync(String location, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findCitiesUsingGETValidateBeforeCall(location, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findDivisionsNearAdminDivisionUsingGET
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findDivisionsNearAdminDivisionUsingGETCall(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/adminDivisions/{divisionId}/nearbyDivisions"
            .replace("{" + "divisionId" + "}", localVarApiClient.escapeString(divisionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (countryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryIds", countryIds));
        }

        if (excludedCountryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludedCountryIds", excludedCountryIds));
        }

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findDivisionsNearAdminDivisionUsingGETValidateBeforeCall(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'divisionId' is set
        if (divisionId == null) {
            throw new ApiException("Missing the required parameter 'divisionId' when calling findDivisionsNearAdminDivisionUsingGET(Async)");
        }

        return findDivisionsNearAdminDivisionUsingGETCall(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find divisions near division
     * Find administrative divisions near the given origin division, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findDivisionsNearAdminDivisionUsingGET(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findDivisionsNearAdminDivisionUsingGETWithHttpInfo(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find divisions near division
     * Find administrative divisions near the given origin division, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findDivisionsNearAdminDivisionUsingGETWithHttpInfo(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findDivisionsNearAdminDivisionUsingGETValidateBeforeCall(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find divisions near division (asynchronously)
     * Find administrative divisions near the given origin division, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findDivisionsNearAdminDivisionUsingGETAsync(String divisionId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findDivisionsNearAdminDivisionUsingGETValidateBeforeCall(divisionId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findDivisionsNearLocationUsingGET
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findDivisionsNearLocationUsingGETCall(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/locations/{locationId}/nearbyDivisions"
            .replace("{" + "locationId" + "}", localVarApiClient.escapeString(locationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (radius != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("radius", radius));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        if (countryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryIds", countryIds));
        }

        if (excludedCountryIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludedCountryIds", excludedCountryIds));
        }

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findDivisionsNearLocationUsingGETValidateBeforeCall(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'locationId' is set
        if (locationId == null) {
            throw new ApiException("Missing the required parameter 'locationId' when calling findDivisionsNearLocationUsingGET(Async)");
        }

        return findDivisionsNearLocationUsingGETCall(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find divisions near location
     * Find administrative divisions near the given location, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findDivisionsNearLocationUsingGET(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findDivisionsNearLocationUsingGETWithHttpInfo(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find divisions near location
     * Find administrative divisions near the given location, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findDivisionsNearLocationUsingGETWithHttpInfo(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findDivisionsNearLocationUsingGETValidateBeforeCall(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find divisions near location (asynchronously)
     * Find administrative divisions near the given location, filtering by optional criteria. If no criteria are set, you will get back all known divisions. 
     * @param locationId A latitude/longitude in ISO-6709 format: ±DD.DDDD±DDD.DDDD (required)
     * @param radius The location radius within which to find places (optional)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param countryIds Only places in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param excludedCountryIds Only places NOT in these countries (comma-delimited country codes or WikiData ids) (optional)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort places.  Format: ±SORT_FIELD,±SORT_FIELD  where SORT_FIELD &#x3D; countryCode | elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findDivisionsNearLocationUsingGETAsync(String locationId, Integer radius, String distanceUnit, String countryIds, String excludedCountryIds, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findDivisionsNearLocationUsingGETValidateBeforeCall(locationId, radius, distanceUnit, countryIds, excludedCountryIds, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findRegionCitiesUsingGET
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findRegionCitiesUsingGETCall(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/countries/{countryId}/regions/{regionCode}/cities"
            .replace("{" + "countryId" + "}", localVarApiClient.escapeString(countryId.toString()))
            .replace("{" + "regionCode" + "}", localVarApiClient.escapeString(regionCode.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findRegionCitiesUsingGETValidateBeforeCall(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryId' is set
        if (countryId == null) {
            throw new ApiException("Missing the required parameter 'countryId' when calling findRegionCitiesUsingGET(Async)");
        }

        // verify the required parameter 'regionCode' is set
        if (regionCode == null) {
            throw new ApiException("Missing the required parameter 'regionCode' when calling findRegionCitiesUsingGET(Async)");
        }

        return findRegionCitiesUsingGETCall(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find country region cities
     * Get the cities in a specific country region. The country and region info is omitted in the response. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findRegionCitiesUsingGET(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findRegionCitiesUsingGETWithHttpInfo(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find country region cities
     * Get the cities in a specific country region. The country and region info is omitted in the response. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findRegionCitiesUsingGETWithHttpInfo(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findRegionCitiesUsingGETValidateBeforeCall(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find country region cities (asynchronously)
     * Get the cities in a specific country region. The country and region info is omitted in the response. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param types Only places for these types (comma-delimited): CITY | ADM2 (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findRegionCitiesUsingGETAsync(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, String types, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findRegionCitiesUsingGETValidateBeforeCall(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, types, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for findRegionDivisionsUsingGET
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findRegionDivisionsUsingGETCall(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/countries/{countryId}/regions/{regionCode}/adminDivisions"
            .replace("{" + "countryId" + "}", localVarApiClient.escapeString(countryId.toString()))
            .replace("{" + "regionCode" + "}", localVarApiClient.escapeString(regionCode.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (minPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minPopulation", minPopulation));
        }

        if (maxPopulation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxPopulation", maxPopulation));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (timeZoneIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeZoneIds", timeZoneIds));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (includeDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDeleted", includeDeleted));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call findRegionDivisionsUsingGETValidateBeforeCall(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryId' is set
        if (countryId == null) {
            throw new ApiException("Missing the required parameter 'countryId' when calling findRegionDivisionsUsingGET(Async)");
        }

        // verify the required parameter 'regionCode' is set
        if (regionCode == null) {
            throw new ApiException("Missing the required parameter 'regionCode' when calling findRegionDivisionsUsingGET(Async)");
        }

        return findRegionDivisionsUsingGETCall(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);

    }

    /**
     * Find country region administrative divisions
     * Get the administrative divisions in a specific country region. The country and region info is omitted in the response. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return PopulatedPlacesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlacesResponse findRegionDivisionsUsingGET(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        ApiResponse<PopulatedPlacesResponse> localVarResp = findRegionDivisionsUsingGETWithHttpInfo(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted);
        return localVarResp.getData();
    }

    /**
     * Find country region administrative divisions
     * Get the administrative divisions in a specific country region. The country and region info is omitted in the response. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @return ApiResponse&lt;PopulatedPlacesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlacesResponse> findRegionDivisionsUsingGETWithHttpInfo(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted) throws ApiException {
        okhttp3.Call localVarCall = findRegionDivisionsUsingGETValidateBeforeCall(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, null);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find country region administrative divisions (asynchronously)
     * Get the administrative divisions in a specific country region. The country and region info is omitted in the response. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param minPopulation Only places having at least this population (optional)
     * @param maxPopulation Only places having no more than this population (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param timeZoneIds Only places in these time-zones (comma-delimited) (optional)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort place results.  &#39;Format: ±SORT_FIELD,±SORT_FIELD&#39;  where SORT_FIELD &#x3D; elevation | name | population  (optional)
     * @param includeDeleted Whether to include any divisions marked deleted: ALL | SINCE_YESTERDAY | SINCE_LAST_WEEK | NONE (optional, default to NONE)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of populated places </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call findRegionDivisionsUsingGETAsync(String countryId, String regionCode, Integer minPopulation, Integer maxPopulation, String namePrefix, Boolean namePrefixDefaultLangResults, String timeZoneIds, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, String includeDeleted, final ApiCallback<PopulatedPlacesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = findRegionDivisionsUsingGETValidateBeforeCall(countryId, regionCode, minPopulation, maxPopulation, namePrefix, namePrefixDefaultLangResults, timeZoneIds, asciiMode, hateoasMode, languageCode, limit, offset, sort, includeDeleted, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlacesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAdminDivisionUsingGET
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAdminDivisionUsingGETCall(String divisionId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/adminDivisions/{divisionId}"
            .replace("{" + "divisionId" + "}", localVarApiClient.escapeString(divisionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAdminDivisionUsingGETValidateBeforeCall(String divisionId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'divisionId' is set
        if (divisionId == null) {
            throw new ApiException("Missing the required parameter 'divisionId' when calling getAdminDivisionUsingGET(Async)");
        }

        return getAdminDivisionUsingGETCall(divisionId, asciiMode, languageCode, _callback);

    }

    /**
     * Get administrative division details
     * Get the details for a specific administrative division, including location coordinates, population, and elevation above sea-level (if available). 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return PopulatedPlaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlaceResponse getAdminDivisionUsingGET(String divisionId, Boolean asciiMode, String languageCode) throws ApiException {
        ApiResponse<PopulatedPlaceResponse> localVarResp = getAdminDivisionUsingGETWithHttpInfo(divisionId, asciiMode, languageCode);
        return localVarResp.getData();
    }

    /**
     * Get administrative division details
     * Get the details for a specific administrative division, including location coordinates, population, and elevation above sea-level (if available). 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return ApiResponse&lt;PopulatedPlaceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlaceResponse> getAdminDivisionUsingGETWithHttpInfo(String divisionId, Boolean asciiMode, String languageCode) throws ApiException {
        okhttp3.Call localVarCall = getAdminDivisionUsingGETValidateBeforeCall(divisionId, asciiMode, languageCode, null);
        Type localVarReturnType = new TypeToken<PopulatedPlaceResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get administrative division details (asynchronously)
     * Get the details for a specific administrative division, including location coordinates, population, and elevation above sea-level (if available). 
     * @param divisionId An admin-division id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAdminDivisionUsingGETAsync(String divisionId, Boolean asciiMode, String languageCode, final ApiCallback<PopulatedPlaceResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAdminDivisionUsingGETValidateBeforeCall(divisionId, asciiMode, languageCode, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlaceResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCityDateTimeUsingGET
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-6801 date-time </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityDateTimeUsingGETCall(String cityId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/cities/{cityId}/dateTime"
            .replace("{" + "cityId" + "}", localVarApiClient.escapeString(cityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCityDateTimeUsingGETValidateBeforeCall(String cityId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'cityId' is set
        if (cityId == null) {
            throw new ApiException("Missing the required parameter 'cityId' when calling getCityDateTimeUsingGET(Async)");
        }

        return getCityDateTimeUsingGETCall(cityId, _callback);

    }

    /**
     * Get city date-time
     * Get city date-time
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @return DateTimeResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-6801 date-time </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public DateTimeResponse getCityDateTimeUsingGET(String cityId) throws ApiException {
        ApiResponse<DateTimeResponse> localVarResp = getCityDateTimeUsingGETWithHttpInfo(cityId);
        return localVarResp.getData();
    }

    /**
     * Get city date-time
     * Get city date-time
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @return ApiResponse&lt;DateTimeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-6801 date-time </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DateTimeResponse> getCityDateTimeUsingGETWithHttpInfo(String cityId) throws ApiException {
        okhttp3.Call localVarCall = getCityDateTimeUsingGETValidateBeforeCall(cityId, null);
        Type localVarReturnType = new TypeToken<DateTimeResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get city date-time (asynchronously)
     * Get city date-time
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-6801 date-time </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityDateTimeUsingGETAsync(String cityId, final ApiCallback<DateTimeResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCityDateTimeUsingGETValidateBeforeCall(cityId, _callback);
        Type localVarReturnType = new TypeToken<DateTimeResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCityDistanceUsingGET
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param toCityId Distance to this city (required)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A decimal distance (in miles or kilometers) </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityDistanceUsingGETCall(String cityId, String toCityId, String distanceUnit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/cities/{cityId}/distance"
            .replace("{" + "cityId" + "}", localVarApiClient.escapeString(cityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (toCityId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("toCityId", toCityId));
        }

        if (distanceUnit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("distanceUnit", distanceUnit));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCityDistanceUsingGETValidateBeforeCall(String cityId, String toCityId, String distanceUnit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'cityId' is set
        if (cityId == null) {
            throw new ApiException("Missing the required parameter 'cityId' when calling getCityDistanceUsingGET(Async)");
        }

        // verify the required parameter 'toCityId' is set
        if (toCityId == null) {
            throw new ApiException("Missing the required parameter 'toCityId' when calling getCityDistanceUsingGET(Async)");
        }

        return getCityDistanceUsingGETCall(cityId, toCityId, distanceUnit, _callback);

    }

    /**
     * Get city distance
     * Get distance from the given city
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param toCityId Distance to this city (required)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @return DistanceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A decimal distance (in miles or kilometers) </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public DistanceResponse getCityDistanceUsingGET(String cityId, String toCityId, String distanceUnit) throws ApiException {
        ApiResponse<DistanceResponse> localVarResp = getCityDistanceUsingGETWithHttpInfo(cityId, toCityId, distanceUnit);
        return localVarResp.getData();
    }

    /**
     * Get city distance
     * Get distance from the given city
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param toCityId Distance to this city (required)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @return ApiResponse&lt;DistanceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A decimal distance (in miles or kilometers) </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DistanceResponse> getCityDistanceUsingGETWithHttpInfo(String cityId, String toCityId, String distanceUnit) throws ApiException {
        okhttp3.Call localVarCall = getCityDistanceUsingGETValidateBeforeCall(cityId, toCityId, distanceUnit, null);
        Type localVarReturnType = new TypeToken<DistanceResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get city distance (asynchronously)
     * Get distance from the given city
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param toCityId Distance to this city (required)
     * @param distanceUnit The unit of distance: MI | KM (optional, default to MI)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A decimal distance (in miles or kilometers) </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityDistanceUsingGETAsync(String cityId, String toCityId, String distanceUnit, final ApiCallback<DistanceResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCityDistanceUsingGETValidateBeforeCall(cityId, toCityId, distanceUnit, _callback);
        Type localVarReturnType = new TypeToken<DistanceResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCityLocatedInUsingGET
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityLocatedInUsingGETCall(String cityId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/cities/{cityId}/locatedIn"
            .replace("{" + "cityId" + "}", localVarApiClient.escapeString(cityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCityLocatedInUsingGETValidateBeforeCall(String cityId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'cityId' is set
        if (cityId == null) {
            throw new ApiException("Missing the required parameter 'cityId' when calling getCityLocatedInUsingGET(Async)");
        }

        return getCityLocatedInUsingGETCall(cityId, asciiMode, languageCode, _callback);

    }

    /**
     * Get city admin region
     * Get the details for the containing populated place (e.g., its county or other administrative division), including location coordinates, population, and elevation above sea-level (if available). 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return PopulatedPlaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlaceResponse getCityLocatedInUsingGET(String cityId, Boolean asciiMode, String languageCode) throws ApiException {
        ApiResponse<PopulatedPlaceResponse> localVarResp = getCityLocatedInUsingGETWithHttpInfo(cityId, asciiMode, languageCode);
        return localVarResp.getData();
    }

    /**
     * Get city admin region
     * Get the details for the containing populated place (e.g., its county or other administrative division), including location coordinates, population, and elevation above sea-level (if available). 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return ApiResponse&lt;PopulatedPlaceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlaceResponse> getCityLocatedInUsingGETWithHttpInfo(String cityId, Boolean asciiMode, String languageCode) throws ApiException {
        okhttp3.Call localVarCall = getCityLocatedInUsingGETValidateBeforeCall(cityId, asciiMode, languageCode, null);
        Type localVarReturnType = new TypeToken<PopulatedPlaceResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get city admin region (asynchronously)
     * Get the details for the containing populated place (e.g., its county or other administrative division), including location coordinates, population, and elevation above sea-level (if available). 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityLocatedInUsingGETAsync(String cityId, Boolean asciiMode, String languageCode, final ApiCallback<PopulatedPlaceResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCityLocatedInUsingGETValidateBeforeCall(cityId, asciiMode, languageCode, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlaceResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCityTimeUsingGET
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-8601 time response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityTimeUsingGETCall(String cityId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/cities/{cityId}/time"
            .replace("{" + "cityId" + "}", localVarApiClient.escapeString(cityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCityTimeUsingGETValidateBeforeCall(String cityId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'cityId' is set
        if (cityId == null) {
            throw new ApiException("Missing the required parameter 'cityId' when calling getCityTimeUsingGET(Async)");
        }

        return getCityTimeUsingGETCall(cityId, _callback);

    }

    /**
     * Get city time
     * Get city time
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @return TimeResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-8601 time response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public TimeResponse getCityTimeUsingGET(String cityId) throws ApiException {
        ApiResponse<TimeResponse> localVarResp = getCityTimeUsingGETWithHttpInfo(cityId);
        return localVarResp.getData();
    }

    /**
     * Get city time
     * Get city time
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @return ApiResponse&lt;TimeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-8601 time response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TimeResponse> getCityTimeUsingGETWithHttpInfo(String cityId) throws ApiException {
        okhttp3.Call localVarCall = getCityTimeUsingGETValidateBeforeCall(cityId, null);
        Type localVarReturnType = new TypeToken<TimeResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get city time (asynchronously)
     * Get city time
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An ISO-8601 time response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityTimeUsingGETAsync(String cityId, final ApiCallback<TimeResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCityTimeUsingGETValidateBeforeCall(cityId, _callback);
        Type localVarReturnType = new TypeToken<TimeResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCityUsingGET
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityUsingGETCall(String cityId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/cities/{cityId}"
            .replace("{" + "cityId" + "}", localVarApiClient.escapeString(cityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCityUsingGETValidateBeforeCall(String cityId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'cityId' is set
        if (cityId == null) {
            throw new ApiException("Missing the required parameter 'cityId' when calling getCityUsingGET(Async)");
        }

        return getCityUsingGETCall(cityId, asciiMode, languageCode, _callback);

    }

    /**
     * Get city details
     * Get the details for a specific city, including location coordinates, population, and elevation above sea-level (if available). 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return PopulatedPlaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public PopulatedPlaceResponse getCityUsingGET(String cityId, Boolean asciiMode, String languageCode) throws ApiException {
        ApiResponse<PopulatedPlaceResponse> localVarResp = getCityUsingGETWithHttpInfo(cityId, asciiMode, languageCode);
        return localVarResp.getData();
    }

    /**
     * Get city details
     * Get the details for a specific city, including location coordinates, population, and elevation above sea-level (if available). 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return ApiResponse&lt;PopulatedPlaceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PopulatedPlaceResponse> getCityUsingGETWithHttpInfo(String cityId, Boolean asciiMode, String languageCode) throws ApiException {
        okhttp3.Call localVarCall = getCityUsingGETValidateBeforeCall(cityId, asciiMode, languageCode, null);
        Type localVarReturnType = new TypeToken<PopulatedPlaceResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get city details (asynchronously)
     * Get the details for a specific city, including location coordinates, population, and elevation above sea-level (if available). 
     * @param cityId A city id (either native &#39;id&#39; or &#39;wikiDataId&#39;) (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Populated-place details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCityUsingGETAsync(String cityId, Boolean asciiMode, String languageCode, final ApiCallback<PopulatedPlaceResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCityUsingGETValidateBeforeCall(cityId, asciiMode, languageCode, _callback);
        Type localVarReturnType = new TypeToken<PopulatedPlaceResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCountriesUsingGET
     * @param currencyCode Only countries supporting this currency (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort countries.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; code | name (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of countries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountriesUsingGETCall(String currencyCode, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/countries";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (currencyCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currencyCode", currencyCode));
        }

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCountriesUsingGETValidateBeforeCall(String currencyCode, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, final ApiCallback _callback) throws ApiException {
        return getCountriesUsingGETCall(currencyCode, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort, _callback);

    }

    /**
     * Find countries
     * Find countries, filtering by optional criteria. If no criteria are set, you will get back all known countries. 
     * @param currencyCode Only countries supporting this currency (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort countries.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; code | name (optional)
     * @return CountriesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of countries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public CountriesResponse getCountriesUsingGET(String currencyCode, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort) throws ApiException {
        ApiResponse<CountriesResponse> localVarResp = getCountriesUsingGETWithHttpInfo(currencyCode, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort);
        return localVarResp.getData();
    }

    /**
     * Find countries
     * Find countries, filtering by optional criteria. If no criteria are set, you will get back all known countries. 
     * @param currencyCode Only countries supporting this currency (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort countries.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; code | name (optional)
     * @return ApiResponse&lt;CountriesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of countries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CountriesResponse> getCountriesUsingGETWithHttpInfo(String currencyCode, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort) throws ApiException {
        okhttp3.Call localVarCall = getCountriesUsingGETValidateBeforeCall(currencyCode, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort, null);
        Type localVarReturnType = new TypeToken<CountriesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find countries (asynchronously)
     * Find countries, filtering by optional criteria. If no criteria are set, you will get back all known countries. 
     * @param currencyCode Only countries supporting this currency (optional)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort countries.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; code | name (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of countries </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountriesUsingGETAsync(String currencyCode, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, final ApiCallback<CountriesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCountriesUsingGETValidateBeforeCall(currencyCode, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort, _callback);
        Type localVarReturnType = new TypeToken<CountriesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCountryUsingGET
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountryUsingGETCall(String countryId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/countries/{countryId}"
            .replace("{" + "countryId" + "}", localVarApiClient.escapeString(countryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCountryUsingGETValidateBeforeCall(String countryId, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryId' is set
        if (countryId == null) {
            throw new ApiException("Missing the required parameter 'countryId' when calling getCountryUsingGET(Async)");
        }

        return getCountryUsingGETCall(countryId, asciiMode, languageCode, _callback);

    }

    /**
     * Get country details
     * Get the details for a specific country, including number of regions.
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return CountryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public CountryResponse getCountryUsingGET(String countryId, Boolean asciiMode, String languageCode) throws ApiException {
        ApiResponse<CountryResponse> localVarResp = getCountryUsingGETWithHttpInfo(countryId, asciiMode, languageCode);
        return localVarResp.getData();
    }

    /**
     * Get country details
     * Get the details for a specific country, including number of regions.
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return ApiResponse&lt;CountryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CountryResponse> getCountryUsingGETWithHttpInfo(String countryId, Boolean asciiMode, String languageCode) throws ApiException {
        okhttp3.Call localVarCall = getCountryUsingGETValidateBeforeCall(countryId, asciiMode, languageCode, null);
        Type localVarReturnType = new TypeToken<CountryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get country details (asynchronously)
     * Get the details for a specific country, including number of regions.
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountryUsingGETAsync(String countryId, Boolean asciiMode, String languageCode, final ApiCallback<CountryResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCountryUsingGETValidateBeforeCall(countryId, asciiMode, languageCode, _callback);
        Type localVarReturnType = new TypeToken<CountryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRegionUsingGET
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country region details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRegionUsingGETCall(String countryId, String regionCode, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/countries/{countryId}/regions/{regionCode}"
            .replace("{" + "countryId" + "}", localVarApiClient.escapeString(countryId.toString()))
            .replace("{" + "regionCode" + "}", localVarApiClient.escapeString(regionCode.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRegionUsingGETValidateBeforeCall(String countryId, String regionCode, Boolean asciiMode, String languageCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryId' is set
        if (countryId == null) {
            throw new ApiException("Missing the required parameter 'countryId' when calling getRegionUsingGET(Async)");
        }

        // verify the required parameter 'regionCode' is set
        if (regionCode == null) {
            throw new ApiException("Missing the required parameter 'regionCode' when calling getRegionUsingGET(Async)");
        }

        return getRegionUsingGETCall(countryId, regionCode, asciiMode, languageCode, _callback);

    }

    /**
     * Get region details
     * Get the details of a specific country region, including number of cities.
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return RegionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country region details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RegionResponse getRegionUsingGET(String countryId, String regionCode, Boolean asciiMode, String languageCode) throws ApiException {
        ApiResponse<RegionResponse> localVarResp = getRegionUsingGETWithHttpInfo(countryId, regionCode, asciiMode, languageCode);
        return localVarResp.getData();
    }

    /**
     * Get region details
     * Get the details of a specific country region, including number of cities.
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @return ApiResponse&lt;RegionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country region details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RegionResponse> getRegionUsingGETWithHttpInfo(String countryId, String regionCode, Boolean asciiMode, String languageCode) throws ApiException {
        okhttp3.Call localVarCall = getRegionUsingGETValidateBeforeCall(countryId, regionCode, asciiMode, languageCode, null);
        Type localVarReturnType = new TypeToken<RegionResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get region details (asynchronously)
     * Get the details of a specific country region, including number of cities.
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param regionCode An ISO-3166 or FIPS region code (required)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param languageCode Display results in this language (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Country region details </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRegionUsingGETAsync(String countryId, String regionCode, Boolean asciiMode, String languageCode, final ApiCallback<RegionResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRegionUsingGETValidateBeforeCall(countryId, regionCode, asciiMode, languageCode, _callback);
        Type localVarReturnType = new TypeToken<RegionResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRegionsUsingGET
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort regions.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; fipsCode | isoCode | name (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of country regions </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRegionsUsingGETCall(String countryId, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/geo/countries/{countryId}/regions"
            .replace("{" + "countryId" + "}", localVarApiClient.escapeString(countryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (namePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefix", namePrefix));
        }

        if (namePrefixDefaultLangResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("namePrefixDefaultLangResults", namePrefixDefaultLangResults));
        }

        if (asciiMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asciiMode", asciiMode));
        }

        if (hateoasMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hateoasMode", hateoasMode));
        }

        if (languageCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("languageCode", languageCode));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "UserSecurity" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRegionsUsingGETValidateBeforeCall(String countryId, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'countryId' is set
        if (countryId == null) {
            throw new ApiException("Missing the required parameter 'countryId' when calling getRegionsUsingGET(Async)");
        }

        return getRegionsUsingGETCall(countryId, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort, _callback);

    }

    /**
     * Find country regions
     * Get all regions in a specific country. These could be states, provinces, districts, or otherwise major political divisions. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort regions.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; fipsCode | isoCode | name (optional)
     * @return RegionsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of country regions </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RegionsResponse getRegionsUsingGET(String countryId, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort) throws ApiException {
        ApiResponse<RegionsResponse> localVarResp = getRegionsUsingGETWithHttpInfo(countryId, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort);
        return localVarResp.getData();
    }

    /**
     * Find country regions
     * Get all regions in a specific country. These could be states, provinces, districts, or otherwise major political divisions. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort regions.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; fipsCode | isoCode | name (optional)
     * @return ApiResponse&lt;RegionsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of country regions </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RegionsResponse> getRegionsUsingGETWithHttpInfo(String countryId, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort) throws ApiException {
        okhttp3.Call localVarCall = getRegionsUsingGETValidateBeforeCall(countryId, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort, null);
        Type localVarReturnType = new TypeToken<RegionsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find country regions (asynchronously)
     * Get all regions in a specific country. These could be states, provinces, districts, or otherwise major political divisions. 
     * @param countryId An ISO-3166 country code or WikiData id (required)
     * @param namePrefix Only entities whose names start with this prefix. If languageCode is set, the prefix will be matched on the name as it appears in that language.  (optional)
     * @param namePrefixDefaultLangResults When name-prefix matching, whether or not to match on names in the default language if a non-default languageCode is set.  (optional, default to true)
     * @param asciiMode Display results using ASCII characters (optional, default to false)
     * @param hateoasMode Include HATEOAS-style links in results (optional, default to true)
     * @param languageCode Display results in this language (optional)
     * @param limit The maximum number of results to retrieve (optional, default to 10)
     * @param offset The zero-ary offset index into the results (optional, default to 0)
     * @param sort How to sort regions.  Format: ±SORT_FIELD  where SORT_FIELD &#x3D; fipsCode | isoCode | name (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of country regions </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> 400 - Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> 401 - Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> 403 - Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> 404 - Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRegionsUsingGETAsync(String countryId, String namePrefix, Boolean namePrefixDefaultLangResults, Boolean asciiMode, Boolean hateoasMode, String languageCode, Integer limit, Integer offset, String sort, final ApiCallback<RegionsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRegionsUsingGETValidateBeforeCall(countryId, namePrefix, namePrefixDefaultLangResults, asciiMode, hateoasMode, languageCode, limit, offset, sort, _callback);
        Type localVarReturnType = new TypeToken<RegionsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
