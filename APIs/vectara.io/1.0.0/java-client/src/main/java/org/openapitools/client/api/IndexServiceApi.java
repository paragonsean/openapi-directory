/*
 * Vectara REST API
 * Vectara is a neural search platform, built for developers to get the most out of their data.  You can sign up for an account at [https://vectara.com](https://vectara.com).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@vectara.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import org.openapitools.client.model.FileUpload200Response;
import org.openapitools.client.model.FileUpload400Response;
import org.openapitools.client.model.GooglerpcStatus;
import org.openapitools.client.model.VectaraDeleteDocumentRequest;
import org.openapitools.client.model.VectaraIndexDocumentRequest;
import org.openapitools.client.model.VectaraIndexDocumentResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class IndexServiceApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public IndexServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public IndexServiceApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for delete
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraDeleteDocumentRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCall(Integer customerId, VectaraDeleteDocumentRequest vectaraDeleteDocumentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = vectaraDeleteDocumentRequest;

        // create path and map variables
        String localVarPath = "/v1/delete-doc";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (customerId != null) {
            localVarHeaderParams.put("customer-id", localVarApiClient.parameterToString(customerId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth", "oAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteValidateBeforeCall(Integer customerId, VectaraDeleteDocumentRequest vectaraDeleteDocumentRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling delete(Async)");
        }

        // verify the required parameter 'vectaraDeleteDocumentRequest' is set
        if (vectaraDeleteDocumentRequest == null) {
            throw new ApiException("Missing the required parameter 'vectaraDeleteDocumentRequest' when calling delete(Async)");
        }

        return deleteCall(customerId, vectaraDeleteDocumentRequest, _callback);

    }

    /**
     * 
     * Delete
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraDeleteDocumentRequest  (required)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public Object delete(Integer customerId, VectaraDeleteDocumentRequest vectaraDeleteDocumentRequest) throws ApiException {
        ApiResponse<Object> localVarResp = deleteWithHttpInfo(customerId, vectaraDeleteDocumentRequest);
        return localVarResp.getData();
    }

    /**
     * 
     * Delete
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraDeleteDocumentRequest  (required)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> deleteWithHttpInfo(Integer customerId, VectaraDeleteDocumentRequest vectaraDeleteDocumentRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteValidateBeforeCall(customerId, vectaraDeleteDocumentRequest, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Delete
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraDeleteDocumentRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteAsync(Integer customerId, VectaraDeleteDocumentRequest vectaraDeleteDocumentRequest, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteValidateBeforeCall(customerId, vectaraDeleteDocumentRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fileUpload
     * @param c Customer ID (required)
     * @param o Corpus ID (required)
     * @param d If true, the server returns the extracted document that was indexed (optional)
     * @param docMetadata A JSON string of any additional metadata you want attached to the file. (optional)
     * @param _file The file to be indexed into Vectara. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An invalid request was sent.  e.g. one or more parameters was missing, or the corpus does not exist. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The caller is not authorized to add documents to the corpus </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> A document already exists in the corpus with the same document ID, yet the contents of the indexed document are different than the file being uploaded. Since the indexer is idempotent, the same document (identified by the document ID) can be uploaded multiple times. The indexer does not support updates yet, so an error is returned when a different document is uploaded for the same document ID Note that when a raw file is uploaded, the file name is used as the document ID. </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> There is no more indexing quota left for the corpus or customer to index more documents.  Upgrade your account, add a credit card, or contact sales. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileUploadCall(Integer c, Integer o, Boolean d, String docMetadata, File _file, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/upload";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (docMetadata != null) {
            localVarFormParams.put("doc_metadata", docMetadata);
        }

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (c != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("c", c));
        }

        if (o != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("o", o));
        }

        if (d != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("d", d));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth", "oAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fileUploadValidateBeforeCall(Integer c, Integer o, Boolean d, String docMetadata, File _file, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'c' is set
        if (c == null) {
            throw new ApiException("Missing the required parameter 'c' when calling fileUpload(Async)");
        }

        // verify the required parameter 'o' is set
        if (o == null) {
            throw new ApiException("Missing the required parameter 'o' when calling fileUpload(Async)");
        }

        return fileUploadCall(c, o, d, docMetadata, _file, _callback);

    }

    /**
     * 
     * File Upload
     * @param c Customer ID (required)
     * @param o Corpus ID (required)
     * @param d If true, the server returns the extracted document that was indexed (optional)
     * @param docMetadata A JSON string of any additional metadata you want attached to the file. (optional)
     * @param _file The file to be indexed into Vectara. (optional)
     * @return FileUpload200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An invalid request was sent.  e.g. one or more parameters was missing, or the corpus does not exist. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The caller is not authorized to add documents to the corpus </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> A document already exists in the corpus with the same document ID, yet the contents of the indexed document are different than the file being uploaded. Since the indexer is idempotent, the same document (identified by the document ID) can be uploaded multiple times. The indexer does not support updates yet, so an error is returned when a different document is uploaded for the same document ID Note that when a raw file is uploaded, the file name is used as the document ID. </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> There is no more indexing quota left for the corpus or customer to index more documents.  Upgrade your account, add a credit card, or contact sales. </td><td>  -  </td></tr>
     </table>
     */
    public FileUpload200Response fileUpload(Integer c, Integer o, Boolean d, String docMetadata, File _file) throws ApiException {
        ApiResponse<FileUpload200Response> localVarResp = fileUploadWithHttpInfo(c, o, d, docMetadata, _file);
        return localVarResp.getData();
    }

    /**
     * 
     * File Upload
     * @param c Customer ID (required)
     * @param o Corpus ID (required)
     * @param d If true, the server returns the extracted document that was indexed (optional)
     * @param docMetadata A JSON string of any additional metadata you want attached to the file. (optional)
     * @param _file The file to be indexed into Vectara. (optional)
     * @return ApiResponse&lt;FileUpload200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An invalid request was sent.  e.g. one or more parameters was missing, or the corpus does not exist. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The caller is not authorized to add documents to the corpus </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> A document already exists in the corpus with the same document ID, yet the contents of the indexed document are different than the file being uploaded. Since the indexer is idempotent, the same document (identified by the document ID) can be uploaded multiple times. The indexer does not support updates yet, so an error is returned when a different document is uploaded for the same document ID Note that when a raw file is uploaded, the file name is used as the document ID. </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> There is no more indexing quota left for the corpus or customer to index more documents.  Upgrade your account, add a credit card, or contact sales. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FileUpload200Response> fileUploadWithHttpInfo(Integer c, Integer o, Boolean d, String docMetadata, File _file) throws ApiException {
        okhttp3.Call localVarCall = fileUploadValidateBeforeCall(c, o, d, docMetadata, _file, null);
        Type localVarReturnType = new TypeToken<FileUpload200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * File Upload
     * @param c Customer ID (required)
     * @param o Corpus ID (required)
     * @param d If true, the server returns the extracted document that was indexed (optional)
     * @param docMetadata A JSON string of any additional metadata you want attached to the file. (optional)
     * @param _file The file to be indexed into Vectara. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> An invalid request was sent.  e.g. one or more parameters was missing, or the corpus does not exist. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The caller is not authorized to add documents to the corpus </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> A document already exists in the corpus with the same document ID, yet the contents of the indexed document are different than the file being uploaded. Since the indexer is idempotent, the same document (identified by the document ID) can be uploaded multiple times. The indexer does not support updates yet, so an error is returned when a different document is uploaded for the same document ID Note that when a raw file is uploaded, the file name is used as the document ID. </td><td>  -  </td></tr>
        <tr><td> 507 </td><td> There is no more indexing quota left for the corpus or customer to index more documents.  Upgrade your account, add a credit card, or contact sales. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fileUploadAsync(Integer c, Integer o, Boolean d, String docMetadata, File _file, final ApiCallback<FileUpload200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = fileUploadValidateBeforeCall(c, o, d, docMetadata, _file, _callback);
        Type localVarReturnType = new TypeToken<FileUpload200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for index
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraIndexDocumentRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call indexCall(Integer customerId, VectaraIndexDocumentRequest vectaraIndexDocumentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = vectaraIndexDocumentRequest;

        // create path and map variables
        String localVarPath = "/v1/index";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (customerId != null) {
            localVarHeaderParams.put("customer-id", localVarApiClient.parameterToString(customerId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth", "oAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call indexValidateBeforeCall(Integer customerId, VectaraIndexDocumentRequest vectaraIndexDocumentRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling index(Async)");
        }

        // verify the required parameter 'vectaraIndexDocumentRequest' is set
        if (vectaraIndexDocumentRequest == null) {
            throw new ApiException("Missing the required parameter 'vectaraIndexDocumentRequest' when calling index(Async)");
        }

        return indexCall(customerId, vectaraIndexDocumentRequest, _callback);

    }

    /**
     * 
     * Index
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraIndexDocumentRequest  (required)
     * @return VectaraIndexDocumentResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public VectaraIndexDocumentResponse index(Integer customerId, VectaraIndexDocumentRequest vectaraIndexDocumentRequest) throws ApiException {
        ApiResponse<VectaraIndexDocumentResponse> localVarResp = indexWithHttpInfo(customerId, vectaraIndexDocumentRequest);
        return localVarResp.getData();
    }

    /**
     * 
     * Index
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraIndexDocumentRequest  (required)
     * @return ApiResponse&lt;VectaraIndexDocumentResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VectaraIndexDocumentResponse> indexWithHttpInfo(Integer customerId, VectaraIndexDocumentRequest vectaraIndexDocumentRequest) throws ApiException {
        okhttp3.Call localVarCall = indexValidateBeforeCall(customerId, vectaraIndexDocumentRequest, null);
        Type localVarReturnType = new TypeToken<VectaraIndexDocumentResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * Index
     * @param customerId The Customer ID to use for the request. (required)
     * @param vectaraIndexDocumentRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A successful response. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call indexAsync(Integer customerId, VectaraIndexDocumentRequest vectaraIndexDocumentRequest, final ApiCallback<VectaraIndexDocumentResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = indexValidateBeforeCall(customerId, vectaraIndexDocumentRequest, _callback);
        Type localVarReturnType = new TypeToken<VectaraIndexDocumentResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
