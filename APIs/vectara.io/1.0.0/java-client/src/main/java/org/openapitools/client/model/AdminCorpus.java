/*
 * Vectara REST API
 * Vectara is a neural search platform, built for developers to get the most out of their data.  You can sign up for an account at [https://vectara.com](https://vectara.com).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@vectara.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AdminDimension;
import org.openapitools.client.model.AdminFilterAttribute;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * AdminCorpus
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:22:56.835144-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AdminCorpus {
  public static final String SERIALIZED_NAME_CUSTOM_DIMENSIONS = "customDimensions";
  @SerializedName(SERIALIZED_NAME_CUSTOM_DIMENSIONS)
  private List<AdminDimension> customDimensions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DT_PROVISION = "dtProvision";
  @SerializedName(SERIALIZED_NAME_DT_PROVISION)
  private String dtProvision;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_ENCODER_ID = "encoderId";
  @SerializedName(SERIALIZED_NAME_ENCODER_ID)
  private String encoderId;

  public static final String SERIALIZED_NAME_ENCRYPTED = "encrypted";
  @SerializedName(SERIALIZED_NAME_ENCRYPTED)
  private Boolean encrypted;

  public static final String SERIALIZED_NAME_FILTER_ATTRIBUTES = "filterAttributes";
  @SerializedName(SERIALIZED_NAME_FILTER_ATTRIBUTES)
  private List<AdminFilterAttribute> filterAttributes = new ArrayList<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_METADATA_MAX_BYTES = "metadataMaxBytes";
  @SerializedName(SERIALIZED_NAME_METADATA_MAX_BYTES)
  private Long metadataMaxBytes;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SWAP_IENC = "swapIenc";
  @SerializedName(SERIALIZED_NAME_SWAP_IENC)
  private Boolean swapIenc;

  public static final String SERIALIZED_NAME_SWAP_QENC = "swapQenc";
  @SerializedName(SERIALIZED_NAME_SWAP_QENC)
  private Boolean swapQenc;

  public static final String SERIALIZED_NAME_TEXTLESS = "textless";
  @SerializedName(SERIALIZED_NAME_TEXTLESS)
  private Boolean textless;

  public AdminCorpus() {
  }

  public AdminCorpus customDimensions(List<AdminDimension> customDimensions) {
    this.customDimensions = customDimensions;
    return this;
  }

  public AdminCorpus addCustomDimensionsItem(AdminDimension customDimensionsItem) {
    if (this.customDimensions == null) {
      this.customDimensions = new ArrayList<>();
    }
    this.customDimensions.add(customDimensionsItem);
    return this;
  }

  /**
   * Get customDimensions
   * @return customDimensions
   */
  @javax.annotation.Nullable
  public List<AdminDimension> getCustomDimensions() {
    return customDimensions;
  }

  public void setCustomDimensions(List<AdminDimension> customDimensions) {
    this.customDimensions = customDimensions;
  }


  public AdminCorpus description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A description for the corpus.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public AdminCorpus dtProvision(String dtProvision) {
    this.dtProvision = dtProvision;
    return this;
  }

  /**
   * The time at which the corpus was provisioned.
   * @return dtProvision
   */
  @javax.annotation.Nullable
  public String getDtProvision() {
    return dtProvision;
  }

  public void setDtProvision(String dtProvision) {
    this.dtProvision = dtProvision;
  }


  public AdminCorpus enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Whether the corpus is enabled for use or not.
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public AdminCorpus encoderId(String encoderId) {
    this.encoderId = encoderId;
    return this;
  }

  /**
   * This is an advanced setting for changing the underlying model type.  The default value is \&quot;1\&quot;, which is Vectara&#39;s high-performing global model. Underlying models may be swapped for some paying customers by contacting our support team.
   * @return encoderId
   */
  @javax.annotation.Nullable
  public String getEncoderId() {
    return encoderId;
  }

  public void setEncoderId(String encoderId) {
    this.encoderId = encoderId;
  }


  public AdminCorpus encrypted(Boolean encrypted) {
    this.encrypted = encrypted;
    return this;
  }

  /**
   * Encryption is on by default and cannot be turned off.
   * @return encrypted
   */
  @javax.annotation.Nullable
  public Boolean getEncrypted() {
    return encrypted;
  }

  public void setEncrypted(Boolean encrypted) {
    this.encrypted = encrypted;
  }


  public AdminCorpus filterAttributes(List<AdminFilterAttribute> filterAttributes) {
    this.filterAttributes = filterAttributes;
    return this;
  }

  public AdminCorpus addFilterAttributesItem(AdminFilterAttribute filterAttributesItem) {
    if (this.filterAttributes == null) {
      this.filterAttributes = new ArrayList<>();
    }
    this.filterAttributes.add(filterAttributesItem);
    return this;
  }

  /**
   * Get filterAttributes
   * @return filterAttributes
   */
  @javax.annotation.Nullable
  public List<AdminFilterAttribute> getFilterAttributes() {
    return filterAttributes;
  }

  public void setFilterAttributes(List<AdminFilterAttribute> filterAttributes) {
    this.filterAttributes = filterAttributes;
  }


  public AdminCorpus id(Long id) {
    this.id = id;
    return this;
  }

  /**
   * The Corpus ID.
   * @return id
   */
  @javax.annotation.Nullable
  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }


  public AdminCorpus metadataMaxBytes(Long metadataMaxBytes) {
    this.metadataMaxBytes = metadataMaxBytes;
    return this;
  }

  /**
   * An optional maximum size of the metadata that each document can contain.
   * @return metadataMaxBytes
   */
  @javax.annotation.Nullable
  public Long getMetadataMaxBytes() {
    return metadataMaxBytes;
  }

  public void setMetadataMaxBytes(Long metadataMaxBytes) {
    this.metadataMaxBytes = metadataMaxBytes;
  }


  public AdminCorpus name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the corpus.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public AdminCorpus swapIenc(Boolean swapIenc) {
    this.swapIenc = swapIenc;
    return this;
  }

  /**
   * The default query encoder is designed for normal question-answering types of queries when the text contains the answer.  Swapping the index encoder is generally rare, but can be used to help directly match questions to questions.  This can be useful if you have a FAQ dataset and you want to directly match the user question to the question in the FAQ.
   * @return swapIenc
   */
  @javax.annotation.Nullable
  public Boolean getSwapIenc() {
    return swapIenc;
  }

  public void setSwapIenc(Boolean swapIenc) {
    this.swapIenc = swapIenc;
  }


  public AdminCorpus swapQenc(Boolean swapQenc) {
    this.swapQenc = swapQenc;
    return this;
  }

  /**
   * Get swapQenc
   * @return swapQenc
   */
  @javax.annotation.Nullable
  public Boolean getSwapQenc() {
    return swapQenc;
  }

  public void setSwapQenc(Boolean swapQenc) {
    this.swapQenc = swapQenc;
  }


  public AdminCorpus textless(Boolean textless) {
    this.textless = textless;
    return this;
  }

  /**
   * When a corpus is \&quot;textless\&quot;, Vectara does not store the original text. Instead, Vectara converts the text to vectors and only retains metadata.
   * @return textless
   */
  @javax.annotation.Nullable
  public Boolean getTextless() {
    return textless;
  }

  public void setTextless(Boolean textless) {
    this.textless = textless;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AdminCorpus adminCorpus = (AdminCorpus) o;
    return Objects.equals(this.customDimensions, adminCorpus.customDimensions) &&
        Objects.equals(this.description, adminCorpus.description) &&
        Objects.equals(this.dtProvision, adminCorpus.dtProvision) &&
        Objects.equals(this.enabled, adminCorpus.enabled) &&
        Objects.equals(this.encoderId, adminCorpus.encoderId) &&
        Objects.equals(this.encrypted, adminCorpus.encrypted) &&
        Objects.equals(this.filterAttributes, adminCorpus.filterAttributes) &&
        Objects.equals(this.id, adminCorpus.id) &&
        Objects.equals(this.metadataMaxBytes, adminCorpus.metadataMaxBytes) &&
        Objects.equals(this.name, adminCorpus.name) &&
        Objects.equals(this.swapIenc, adminCorpus.swapIenc) &&
        Objects.equals(this.swapQenc, adminCorpus.swapQenc) &&
        Objects.equals(this.textless, adminCorpus.textless);
  }

  @Override
  public int hashCode() {
    return Objects.hash(customDimensions, description, dtProvision, enabled, encoderId, encrypted, filterAttributes, id, metadataMaxBytes, name, swapIenc, swapQenc, textless);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AdminCorpus {\n");
    sb.append("    customDimensions: ").append(toIndentedString(customDimensions)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    dtProvision: ").append(toIndentedString(dtProvision)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    encoderId: ").append(toIndentedString(encoderId)).append("\n");
    sb.append("    encrypted: ").append(toIndentedString(encrypted)).append("\n");
    sb.append("    filterAttributes: ").append(toIndentedString(filterAttributes)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    metadataMaxBytes: ").append(toIndentedString(metadataMaxBytes)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    swapIenc: ").append(toIndentedString(swapIenc)).append("\n");
    sb.append("    swapQenc: ").append(toIndentedString(swapQenc)).append("\n");
    sb.append("    textless: ").append(toIndentedString(textless)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("customDimensions");
    openapiFields.add("description");
    openapiFields.add("dtProvision");
    openapiFields.add("enabled");
    openapiFields.add("encoderId");
    openapiFields.add("encrypted");
    openapiFields.add("filterAttributes");
    openapiFields.add("id");
    openapiFields.add("metadataMaxBytes");
    openapiFields.add("name");
    openapiFields.add("swapIenc");
    openapiFields.add("swapQenc");
    openapiFields.add("textless");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AdminCorpus
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AdminCorpus.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AdminCorpus is not found in the empty JSON string", AdminCorpus.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AdminCorpus.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AdminCorpus` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("customDimensions") != null && !jsonObj.get("customDimensions").isJsonNull()) {
        JsonArray jsonArraycustomDimensions = jsonObj.getAsJsonArray("customDimensions");
        if (jsonArraycustomDimensions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("customDimensions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `customDimensions` to be an array in the JSON string but got `%s`", jsonObj.get("customDimensions").toString()));
          }

          // validate the optional field `customDimensions` (array)
          for (int i = 0; i < jsonArraycustomDimensions.size(); i++) {
            AdminDimension.validateJsonElement(jsonArraycustomDimensions.get(i));
          };
        }
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("dtProvision") != null && !jsonObj.get("dtProvision").isJsonNull()) && !jsonObj.get("dtProvision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dtProvision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dtProvision").toString()));
      }
      if ((jsonObj.get("encoderId") != null && !jsonObj.get("encoderId").isJsonNull()) && !jsonObj.get("encoderId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `encoderId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("encoderId").toString()));
      }
      if (jsonObj.get("filterAttributes") != null && !jsonObj.get("filterAttributes").isJsonNull()) {
        JsonArray jsonArrayfilterAttributes = jsonObj.getAsJsonArray("filterAttributes");
        if (jsonArrayfilterAttributes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filterAttributes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filterAttributes` to be an array in the JSON string but got `%s`", jsonObj.get("filterAttributes").toString()));
          }

          // validate the optional field `filterAttributes` (array)
          for (int i = 0; i < jsonArrayfilterAttributes.size(); i++) {
            AdminFilterAttribute.validateJsonElement(jsonArrayfilterAttributes.get(i));
          };
        }
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AdminCorpus.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AdminCorpus' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AdminCorpus> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AdminCorpus.class));

       return (TypeAdapter<T>) new TypeAdapter<AdminCorpus>() {
           @Override
           public void write(JsonWriter out, AdminCorpus value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AdminCorpus read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AdminCorpus given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AdminCorpus
   * @throws IOException if the JSON string is invalid with respect to AdminCorpus
   */
  public static AdminCorpus fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AdminCorpus.class);
  }

  /**
   * Convert an instance of AdminCorpus to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

