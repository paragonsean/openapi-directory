/**
 * GoToWebinar
 * The GoToWebinar API provides seamless integration of webinar registrant and attendee data into your existing infrastructure or third-party applications. The ability to register participants, as well as pull lists of registrants and attendees for a webinar, allows organizers to manage the flow of information between their primary applications without manual intervention.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developer-support@logmein.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import DateTimeRange from './DateTimeRange';

/**
 * The WebinarReqCreate model module.
 * @module model/WebinarReqCreate
 * @version 1.0.0
 */
class WebinarReqCreate {
    /**
     * Constructs a new <code>WebinarReqCreate</code>.
     * Describes the details used to create a new single session webinar.
     * @alias module:model/WebinarReqCreate
     * @param subject {String} The name/subject of the webinar (128 characters maximum)
     * @param times {Array.<module:model/DateTimeRange>} Array with startTime and endTime for webinar. Since this call creates single session webinars, the array can only contain a single pair of startTime and endTime
     */
    constructor(subject, times) { 
        
        WebinarReqCreate.initialize(this, subject, times);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, subject, times) { 
        obj['isPasswordProtected'] = false;
        obj['subject'] = subject;
        obj['times'] = times;
        obj['type'] = 'single_session';
    }

    /**
     * Constructs a <code>WebinarReqCreate</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/WebinarReqCreate} obj Optional instance to populate.
     * @return {module:model/WebinarReqCreate} The populated <code>WebinarReqCreate</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new WebinarReqCreate();

            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('isPasswordProtected')) {
                obj['isPasswordProtected'] = ApiClient.convertToType(data['isPasswordProtected'], 'Boolean');
            }
            if (data.hasOwnProperty('subject')) {
                obj['subject'] = ApiClient.convertToType(data['subject'], 'String');
            }
            if (data.hasOwnProperty('timeZone')) {
                obj['timeZone'] = ApiClient.convertToType(data['timeZone'], 'String');
            }
            if (data.hasOwnProperty('times')) {
                obj['times'] = ApiClient.convertToType(data['times'], [DateTimeRange]);
            }
            if (data.hasOwnProperty('type')) {
                obj['type'] = ApiClient.convertToType(data['type'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>WebinarReqCreate</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>WebinarReqCreate</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of WebinarReqCreate.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // ensure the json data is a string
        if (data['subject'] && !(typeof data['subject'] === 'string' || data['subject'] instanceof String)) {
            throw new Error("Expected the field `subject` to be a primitive type in the JSON string but got " + data['subject']);
        }
        // ensure the json data is a string
        if (data['timeZone'] && !(typeof data['timeZone'] === 'string' || data['timeZone'] instanceof String)) {
            throw new Error("Expected the field `timeZone` to be a primitive type in the JSON string but got " + data['timeZone']);
        }
        if (data['times']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['times'])) {
                throw new Error("Expected the field `times` to be an array in the JSON data but got " + data['times']);
            }
            // validate the optional field `times` (array)
            for (const item of data['times']) {
                DateTimeRange.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['type'] && !(typeof data['type'] === 'string' || data['type'] instanceof String)) {
            throw new Error("Expected the field `type` to be a primitive type in the JSON string but got " + data['type']);
        }

        return true;
    }


}

WebinarReqCreate.RequiredProperties = ["subject", "times"];

/**
 * A short description of the webinar (2048 characters maximum)
 * @member {String} description
 */
WebinarReqCreate.prototype['description'] = undefined;

/**
 * A boolean flag indicating if the webinar is password protected or not.
 * @member {Boolean} isPasswordProtected
 * @default false
 */
WebinarReqCreate.prototype['isPasswordProtected'] = false;

/**
 * The name/subject of the webinar (128 characters maximum)
 * @member {String} subject
 */
WebinarReqCreate.prototype['subject'] = undefined;

/**
 * The time zone where the webinar is taking place (must be a valid time zone ID, see https://goto-developer.logmein.com/time-zones). If this parameter is not passed, the timezone of the organizer's profile will be used
 * @member {String} timeZone
 */
WebinarReqCreate.prototype['timeZone'] = undefined;

/**
 * Array with startTime and endTime for webinar. Since this call creates single session webinars, the array can only contain a single pair of startTime and endTime
 * @member {Array.<module:model/DateTimeRange>} times
 */
WebinarReqCreate.prototype['times'] = undefined;

/**
 * Specifies the webinar type. The default type value is \"single_session\", which is used to create a single webinar session. The possible values are \"single_session\", \"series\", \"sequence\". If type is set to \"single_session\", a single webinar session is created. If type is set to \"series\", a webinar series is created. In this case 2 or more timeframes must be specified for each webinar. Example: \"times\": [{\"startTime\": \"...\", \"endTime\": \"...\"},{\"startTime\": \"...\", \"endTime\": \"...\"},{\"startTime\": \"...\", \"endTime\": \"...\"}. If type is set to \"sequence\" a sequence of webinars is created. The times object in the body must be replaced by the \"recurrenceStart\" object. Example: \"recurrenceStart\": {\"startTime\":\"2012-06-12T16:00:00Z\", \"endTime\": \"2012-06-12T17:00:00Z\" }.  The \"recurrenceEnd\" and \"recurrencePattern\" body parameter must be specified. Example: , \"recurrenceEnd\": \"2012-07-10\", \"recurrencePattern\": \"daily\".
 * @member {String} type
 * @default 'single_session'
 */
WebinarReqCreate.prototype['type'] = 'single_session';






export default WebinarReqCreate;

