/**
 * GoToTraining
 * The GoToTraining API enables developers to use the stable and robust GoToTraining functionality as the basis for online trainings in a proprietary learning management system. The GoToTraining APIs provide the ability to access the scheduling, registration, management, and reporting functions of GoToTraining from external applications. With the ability to tightly integrate GoToTraining into your learning infrastructure, you can offer your learners a seamless user experience and provide them with a market leading virtual classroom environment.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developer-support@logmein.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITrainingsApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAITrainingsApi::OAITrainingsApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAITrainingsApi::~OAITrainingsApi() {
}

void OAITrainingsApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.getgo.com/G2T/rest"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("cancelTraining", defaultConf);
    _serverIndices.insert("cancelTraining", 0);
    _serverConfigs.insert("getAllTrainings", defaultConf);
    _serverIndices.insert("getAllTrainings", 0);
    _serverConfigs.insert("getManageTrainingURL", defaultConf);
    _serverIndices.insert("getManageTrainingURL", 0);
    _serverConfigs.insert("getOrganisersForTraining", defaultConf);
    _serverIndices.insert("getOrganisersForTraining", 0);
    _serverConfigs.insert("getStartUrl", defaultConf);
    _serverIndices.insert("getStartUrl", 0);
    _serverConfigs.insert("getTraining", defaultConf);
    _serverIndices.insert("getTraining", 0);
    _serverConfigs.insert("scheduleTraining", defaultConf);
    _serverIndices.insert("scheduleTraining", 0);
    _serverConfigs.insert("startTraining", defaultConf);
    _serverIndices.insert("startTraining", 0);
    _serverConfigs.insert("updateOrganisersForTraining", defaultConf);
    _serverIndices.insert("updateOrganisersForTraining", 0);
    _serverConfigs.insert("updateRegistrationSettingsForTraining", defaultConf);
    _serverIndices.insert("updateRegistrationSettingsForTraining", 0);
    _serverConfigs.insert("updateTrainingNameDescription", defaultConf);
    _serverIndices.insert("updateTrainingNameDescription", 0);
    _serverConfigs.insert("updateTrainingTimes", defaultConf);
    _serverIndices.insert("updateTrainingTimes", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAITrainingsApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAITrainingsApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAITrainingsApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAITrainingsApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAITrainingsApi::setUsername(const QString &username) {
    _username = username;
}

void OAITrainingsApi::setPassword(const QString &password) {
    _password = password;
}


void OAITrainingsApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAITrainingsApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAITrainingsApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAITrainingsApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITrainingsApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITrainingsApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAITrainingsApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAITrainingsApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAITrainingsApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAITrainingsApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAITrainingsApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAITrainingsApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAITrainingsApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAITrainingsApi::cancelTraining(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key) {
    QString fullPath = QString(_serverConfigs["cancelTraining"][_serverIndices.value("cancelTraining")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::cancelTrainingCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::cancelTrainingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT cancelTrainingSignal();
        Q_EMIT cancelTrainingSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT cancelTrainingSignalE(error_type, error_str);
        Q_EMIT cancelTrainingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT cancelTrainingSignalError(error_type, error_str);
        Q_EMIT cancelTrainingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::getAllTrainings(const QString &authorization, const qint64 &organizer_key) {
    QString fullPath = QString(_serverConfigs["getAllTrainings"][_serverIndices.value("getAllTrainings")].URL()+"/organizers/{organizerKey}/trainings");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::getAllTrainingsCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::getAllTrainingsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAITraining> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAITraining val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllTrainingsSignal(output);
        Q_EMIT getAllTrainingsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllTrainingsSignalE(output, error_type, error_str);
        Q_EMIT getAllTrainingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllTrainingsSignalError(output, error_type, error_str);
        Q_EMIT getAllTrainingsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::getManageTrainingURL(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key) {
    QString fullPath = QString(_serverConfigs["getManageTrainingURL"][_serverIndices.value("getManageTrainingURL")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}/manageUrl");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::getManageTrainingURLCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::getManageTrainingURLCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getManageTrainingURLSignal(output);
        Q_EMIT getManageTrainingURLSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getManageTrainingURLSignalE(output, error_type, error_str);
        Q_EMIT getManageTrainingURLSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getManageTrainingURLSignalError(output, error_type, error_str);
        Q_EMIT getManageTrainingURLSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::getOrganisersForTraining(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key) {
    QString fullPath = QString(_serverConfigs["getOrganisersForTraining"][_serverIndices.value("getOrganisersForTraining")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}/organizers");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::getOrganisersForTrainingCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::getOrganisersForTrainingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIOrganizer> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIOrganizer val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getOrganisersForTrainingSignal(output);
        Q_EMIT getOrganisersForTrainingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getOrganisersForTrainingSignalE(output, error_type, error_str);
        Q_EMIT getOrganisersForTrainingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getOrganisersForTrainingSignalError(output, error_type, error_str);
        Q_EMIT getOrganisersForTrainingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::getStartUrl(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key) {
    QString fullPath = QString(_serverConfigs["getStartUrl"][_serverIndices.value("getStartUrl")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}/startUrl");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::getStartUrlCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::getStartUrlCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStartUrlSignal(output);
        Q_EMIT getStartUrlSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStartUrlSignalE(output, error_type, error_str);
        Q_EMIT getStartUrlSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStartUrlSignalError(output, error_type, error_str);
        Q_EMIT getStartUrlSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::getTraining(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key) {
    QString fullPath = QString(_serverConfigs["getTraining"][_serverIndices.value("getTraining")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::getTrainingCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::getTrainingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITraining output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getTrainingSignal(output);
        Q_EMIT getTrainingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getTrainingSignalE(output, error_type, error_str);
        Q_EMIT getTrainingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getTrainingSignalError(output, error_type, error_str);
        Q_EMIT getTrainingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::scheduleTraining(const QString &authorization, const qint64 &organizer_key, const OAITrainingReqCreate &body) {
    QString fullPath = QString(_serverConfigs["scheduleTraining"][_serverIndices.value("scheduleTraining")].URL()+"/organizers/{organizerKey}/trainings");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::scheduleTrainingCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::scheduleTrainingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT scheduleTrainingSignal(output);
        Q_EMIT scheduleTrainingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT scheduleTrainingSignalE(output, error_type, error_str);
        Q_EMIT scheduleTrainingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT scheduleTrainingSignalError(output, error_type, error_str);
        Q_EMIT scheduleTrainingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::startTraining(const QString &authorization, const qint64 &training_key) {
    QString fullPath = QString(_serverConfigs["startTraining"][_serverIndices.value("startTraining")].URL()+"/trainings/{trainingKey}/start");
    
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::startTrainingCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::startTrainingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHostUrl output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT startTrainingSignal(output);
        Q_EMIT startTrainingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT startTrainingSignalE(output, error_type, error_str);
        Q_EMIT startTrainingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT startTrainingSignalError(output, error_type, error_str);
        Q_EMIT startTrainingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::updateOrganisersForTraining(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key, const OAITrainingOrganizers &body) {
    QString fullPath = QString(_serverConfigs["updateOrganisersForTraining"][_serverIndices.value("updateOrganisersForTraining")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}/organizers");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::updateOrganisersForTrainingCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::updateOrganisersForTrainingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateOrganisersForTrainingSignal();
        Q_EMIT updateOrganisersForTrainingSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateOrganisersForTrainingSignalE(error_type, error_str);
        Q_EMIT updateOrganisersForTrainingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateOrganisersForTrainingSignalError(error_type, error_str);
        Q_EMIT updateOrganisersForTrainingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::updateRegistrationSettingsForTraining(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key, const OAIRegistrationSettings &body) {
    QString fullPath = QString(_serverConfigs["updateRegistrationSettingsForTraining"][_serverIndices.value("updateRegistrationSettingsForTraining")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}/registrationSettings");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::updateRegistrationSettingsForTrainingCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::updateRegistrationSettingsForTrainingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateRegistrationSettingsForTrainingSignal();
        Q_EMIT updateRegistrationSettingsForTrainingSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateRegistrationSettingsForTrainingSignalE(error_type, error_str);
        Q_EMIT updateRegistrationSettingsForTrainingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateRegistrationSettingsForTrainingSignalError(error_type, error_str);
        Q_EMIT updateRegistrationSettingsForTrainingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::updateTrainingNameDescription(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key, const OAITrainingNameDescription &body) {
    QString fullPath = QString(_serverConfigs["updateTrainingNameDescription"][_serverIndices.value("updateTrainingNameDescription")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}/nameDescription");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::updateTrainingNameDescriptionCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::updateTrainingNameDescriptionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateTrainingNameDescriptionSignal();
        Q_EMIT updateTrainingNameDescriptionSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateTrainingNameDescriptionSignalE(error_type, error_str);
        Q_EMIT updateTrainingNameDescriptionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateTrainingNameDescriptionSignalError(error_type, error_str);
        Q_EMIT updateTrainingNameDescriptionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::updateTrainingTimes(const QString &authorization, const qint64 &organizer_key, const qint64 &training_key, const OAITrainingTimes &body) {
    QString fullPath = QString(_serverConfigs["updateTrainingTimes"][_serverIndices.value("updateTrainingTimes")].URL()+"/organizers/{organizerKey}/trainings/{trainingKey}/times");
    
    
    {
        QString organizer_keyPathParam("{");
        organizer_keyPathParam.append("organizerKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "organizerKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"organizerKey"+pathSuffix : pathPrefix;
        fullPath.replace(organizer_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(organizer_key)));
    }
    
    {
        QString training_keyPathParam("{");
        training_keyPathParam.append("trainingKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "trainingKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"trainingKey"+pathSuffix : pathPrefix;
        fullPath.replace(training_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(training_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(authorization).isEmpty()) {
            input.headers.insert("Authorization", ::OpenAPI::toStringValue(authorization));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITrainingsApi::updateTrainingTimesCallback);
    connect(this, &OAITrainingsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITrainingsApi::updateTrainingTimesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINotifiedParties output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateTrainingTimesSignal(output);
        Q_EMIT updateTrainingTimesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateTrainingTimesSignalE(output, error_type, error_str);
        Q_EMIT updateTrainingTimesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateTrainingTimesSignalError(output, error_type, error_str);
        Q_EMIT updateTrainingTimesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITrainingsApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
