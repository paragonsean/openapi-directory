# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class SingleSignOnRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, cookie_type: str=None, link_accounts: bool=None, provider: str=None, scopes: List[str]=None, token: str=None):
        """SingleSignOnRequest - a model defined in OpenAPI

        :param cookie_type: The cookie_type of this SingleSignOnRequest.
        :param link_accounts: The link_accounts of this SingleSignOnRequest.
        :param provider: The provider of this SingleSignOnRequest.
        :param scopes: The scopes of this SingleSignOnRequest.
        :param token: The token of this SingleSignOnRequest.
        """
        self.openapi_types = {
            'cookie_type': str,
            'link_accounts': bool,
            'provider': str,
            'scopes': List[str],
            'token': str
        }

        self.attribute_map = {
            'cookie_type': 'cookieType',
            'link_accounts': 'linkAccounts',
            'provider': 'provider',
            'scopes': 'scopes',
            'token': 'token'
        }

        self._cookie_type = cookie_type
        self._link_accounts = link_accounts
        self._provider = provider
        self._scopes = scopes
        self._token = token

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SingleSignOnRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SingleSignOnRequest of this SingleSignOnRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def cookie_type(self):
        """Gets the cookie_type of this SingleSignOnRequest.

        If you specify a cookie type then a content filter cookie will be returned along with the token(s). This is only intended for web based clients which need to pass the cookies to a server to render a page based on the user's content filters e.g subscription code.  If type `Session` the cookie will be session based. If type `Persistent` the cookie will have a medium term lifespan. If undefined no cookies will be set. 

        :return: The cookie_type of this SingleSignOnRequest.
        :rtype: str
        """
        return self._cookie_type

    @cookie_type.setter
    def cookie_type(self, cookie_type):
        """Sets the cookie_type of this SingleSignOnRequest.

        If you specify a cookie type then a content filter cookie will be returned along with the token(s). This is only intended for web based clients which need to pass the cookies to a server to render a page based on the user's content filters e.g subscription code.  If type `Session` the cookie will be session based. If type `Persistent` the cookie will have a medium term lifespan. If undefined no cookies will be set. 

        :param cookie_type: The cookie_type of this SingleSignOnRequest.
        :type cookie_type: str
        """
        allowed_values = ["Session", "Persistent"]  # noqa: E501
        if cookie_type not in allowed_values:
            raise ValueError(
                "Invalid value for `cookie_type` ({0}), must be one of {1}"
                .format(cookie_type, allowed_values)
            )

        self._cookie_type = cookie_type

    @property
    def link_accounts(self):
        """Gets the link_accounts of this SingleSignOnRequest.

        When a user attempts to sign in using single-sign-on, we may find an account created previously through the manual sign up flow with the same email. If this is the case then an option to link the two accounts can be made available.  If this flag is set to true then accounts will be linked automatically.  If this flag is not set or set to false and an existing account is found  then an http 401 with subcode `6001` will be returned. Client apps can then present the option to link the accounts. If the user decides to accept, then the same call can be repeated with this flag set to true. 

        :return: The link_accounts of this SingleSignOnRequest.
        :rtype: bool
        """
        return self._link_accounts

    @link_accounts.setter
    def link_accounts(self, link_accounts):
        """Sets the link_accounts of this SingleSignOnRequest.

        When a user attempts to sign in using single-sign-on, we may find an account created previously through the manual sign up flow with the same email. If this is the case then an option to link the two accounts can be made available.  If this flag is set to true then accounts will be linked automatically.  If this flag is not set or set to false and an existing account is found  then an http 401 with subcode `6001` will be returned. Client apps can then present the option to link the accounts. If the user decides to accept, then the same call can be repeated with this flag set to true. 

        :param link_accounts: The link_accounts of this SingleSignOnRequest.
        :type link_accounts: bool
        """

        self._link_accounts = link_accounts

    @property
    def provider(self):
        """Gets the provider of this SingleSignOnRequest.

        The third party single-sign-on provider.

        :return: The provider of this SingleSignOnRequest.
        :rtype: str
        """
        return self._provider

    @provider.setter
    def provider(self, provider):
        """Sets the provider of this SingleSignOnRequest.

        The third party single-sign-on provider.

        :param provider: The provider of this SingleSignOnRequest.
        :type provider: str
        """
        allowed_values = ["Facebook"]  # noqa: E501
        if provider not in allowed_values:
            raise ValueError(
                "Invalid value for `provider` ({0}), must be one of {1}"
                .format(provider, allowed_values)
            )

        self._provider = provider

    @property
    def scopes(self):
        """Gets the scopes of this SingleSignOnRequest.

        The scope(s) of the tokens required. For each scope listed an Account and Profile token of that scope will be returned. 

        :return: The scopes of this SingleSignOnRequest.
        :rtype: List[str]
        """
        return self._scopes

    @scopes.setter
    def scopes(self, scopes):
        """Sets the scopes of this SingleSignOnRequest.

        The scope(s) of the tokens required. For each scope listed an Account and Profile token of that scope will be returned. 

        :param scopes: The scopes of this SingleSignOnRequest.
        :type scopes: List[str]
        """
        allowed_values = ["Catalog", "Commerce", "Settings", "Playback"]  # noqa: E501
        if not set(scopes).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `scopes` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(scopes) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._scopes = scopes

    @property
    def token(self):
        """Gets the token of this SingleSignOnRequest.

        A token from the third party single-sign-on provider e.g. an identity token from Facebook.

        :return: The token of this SingleSignOnRequest.
        :rtype: str
        """
        return self._token

    @token.setter
    def token(self, token):
        """Sets the token of this SingleSignOnRequest.

        A token from the third party single-sign-on provider e.g. an identity token from Facebook.

        :param token: The token of this SingleSignOnRequest.
        :type token: str
        """
        if token is None:
            raise ValueError("Invalid value for `token`, must not be `None`")

        self._token = token
