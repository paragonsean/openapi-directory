/*
 * Rocket Services
 * An Orchestration Layer that takes ISL services and packages them in a more targeted way for front-end applications. This in turn makes client integration easier and reduces the complexity and size of front-end applications.  Rocket is also customisable - allowing UI engineers to ‘remix’ the existing back-end services into something that best suits the application they are developing. 
 *
 * The version of the OpenAPI document: 3.730.300-ref-1-39-0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ClassificationSummary;
import org.openapitools.client.model.Offer;
import org.openapitools.client.model.Theme;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ItemSummary
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:29:39.003134-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ItemSummary {
  public static final String SERIALIZED_NAME_ADVISORY_TEXT = "advisoryText";
  @SerializedName(SERIALIZED_NAME_ADVISORY_TEXT)
  private String advisoryText;

  public static final String SERIALIZED_NAME_AVAILABLE_EPISODE_COUNT = "availableEpisodeCount";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_EPISODE_COUNT)
  private Integer availableEpisodeCount;

  public static final String SERIALIZED_NAME_AVAILABLE_SEASON_COUNT = "availableSeasonCount";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_SEASON_COUNT)
  private Integer availableSeasonCount;

  public static final String SERIALIZED_NAME_AVERAGE_USER_RATING = "averageUserRating";
  @SerializedName(SERIALIZED_NAME_AVERAGE_USER_RATING)
  private BigDecimal averageUserRating;

  public static final String SERIALIZED_NAME_BADGE = "badge";
  @SerializedName(SERIALIZED_NAME_BADGE)
  private String badge;

  public static final String SERIALIZED_NAME_CHANNEL_SHORT_CODE = "channelShortCode";
  @SerializedName(SERIALIZED_NAME_CHANNEL_SHORT_CODE)
  private String channelShortCode;

  public static final String SERIALIZED_NAME_CLASSIFICATION = "classification";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION)
  private ClassificationSummary classification;

  public static final String SERIALIZED_NAME_CONTEXTUAL_TITLE = "contextualTitle";
  @SerializedName(SERIALIZED_NAME_CONTEXTUAL_TITLE)
  private String contextualTitle;

  public static final String SERIALIZED_NAME_CUSTOM_FIELDS = "customFields";
  @SerializedName(SERIALIZED_NAME_CUSTOM_FIELDS)
  private Map<String, Object> customFields = new HashMap<>();

  public static final String SERIALIZED_NAME_CUSTOM_ID = "customId";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ID)
  private String customId;

  public static final String SERIALIZED_NAME_DURATION = "duration";
  @SerializedName(SERIALIZED_NAME_DURATION)
  private Integer duration;

  public static final String SERIALIZED_NAME_EPISODE_COUNT = "episodeCount";
  @SerializedName(SERIALIZED_NAME_EPISODE_COUNT)
  private Integer episodeCount;

  public static final String SERIALIZED_NAME_EPISODE_NAME = "episodeName";
  @SerializedName(SERIALIZED_NAME_EPISODE_NAME)
  private String episodeName;

  public static final String SERIALIZED_NAME_EPISODE_NUMBER = "episodeNumber";
  @SerializedName(SERIALIZED_NAME_EPISODE_NUMBER)
  private Integer episodeNumber;

  public static final String SERIALIZED_NAME_GENRES = "genres";
  @SerializedName(SERIALIZED_NAME_GENRES)
  private List<String> genres = new ArrayList<>();

  public static final String SERIALIZED_NAME_HAS_CLOSED_CAPTIONS = "hasClosedCaptions";
  @SerializedName(SERIALIZED_NAME_HAS_CLOSED_CAPTIONS)
  private Boolean hasClosedCaptions;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IMAGES = "images";
  @SerializedName(SERIALIZED_NAME_IMAGES)
  private Map<String, URI> images = new HashMap<>();

  public static final String SERIALIZED_NAME_OFFERS = "offers";
  @SerializedName(SERIALIZED_NAME_OFFERS)
  private List<Offer> offers = new ArrayList<>();

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private String path;

  public static final String SERIALIZED_NAME_RELEASE_YEAR = "releaseYear";
  @SerializedName(SERIALIZED_NAME_RELEASE_YEAR)
  private Integer releaseYear;

  public static final String SERIALIZED_NAME_SCOPES = "scopes";
  @SerializedName(SERIALIZED_NAME_SCOPES)
  private List<String> scopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SEASON_ID = "seasonId";
  @SerializedName(SERIALIZED_NAME_SEASON_ID)
  private String seasonId;

  public static final String SERIALIZED_NAME_SEASON_NUMBER = "seasonNumber";
  @SerializedName(SERIALIZED_NAME_SEASON_NUMBER)
  private Integer seasonNumber;

  public static final String SERIALIZED_NAME_SHORT_DESCRIPTION = "shortDescription";
  @SerializedName(SERIALIZED_NAME_SHORT_DESCRIPTION)
  private String shortDescription;

  public static final String SERIALIZED_NAME_SHOW_ID = "showId";
  @SerializedName(SERIALIZED_NAME_SHOW_ID)
  private String showId;

  public static final String SERIALIZED_NAME_SHOW_TITLE = "showTitle";
  @SerializedName(SERIALIZED_NAME_SHOW_TITLE)
  private String showTitle;

  public static final String SERIALIZED_NAME_SUBTYPE = "subtype";
  @SerializedName(SERIALIZED_NAME_SUBTYPE)
  private String subtype;

  public static final String SERIALIZED_NAME_TAGLINE = "tagline";
  @SerializedName(SERIALIZED_NAME_TAGLINE)
  private String tagline;

  public static final String SERIALIZED_NAME_THEMES = "themes";
  @SerializedName(SERIALIZED_NAME_THEMES)
  private List<Theme> themes = new ArrayList<>();

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  /**
   * The type of item
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    MOVIE("movie"),
    
    SHOW("show"),
    
    SEASON("season"),
    
    EPISODE("episode"),
    
    PROGRAM("program"),
    
    LINK("link"),
    
    TRAILER("trailer"),
    
    CHANNEL("channel"),
    
    CUSTOM_ASSET("customAsset");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  protected TypeEnum type;

  public static final String SERIALIZED_NAME_WATCH_PATH = "watchPath";
  @SerializedName(SERIALIZED_NAME_WATCH_PATH)
  private String watchPath;

  public ItemSummary() {
  }

  public ItemSummary advisoryText(String advisoryText) {
    this.advisoryText = advisoryText;
    return this;
  }

  /**
   * Advisory text about this item, related to the classification
   * @return advisoryText
   */
  @javax.annotation.Nullable
  public String getAdvisoryText() {
    return advisoryText;
  }

  public void setAdvisoryText(String advisoryText) {
    this.advisoryText = advisoryText;
  }


  public ItemSummary availableEpisodeCount(Integer availableEpisodeCount) {
    this.availableEpisodeCount = availableEpisodeCount;
    return this;
  }

  /**
   * The number of available episodes in the season, if the item is a season.
   * @return availableEpisodeCount
   */
  @javax.annotation.Nullable
  public Integer getAvailableEpisodeCount() {
    return availableEpisodeCount;
  }

  public void setAvailableEpisodeCount(Integer availableEpisodeCount) {
    this.availableEpisodeCount = availableEpisodeCount;
  }


  public ItemSummary availableSeasonCount(Integer availableSeasonCount) {
    this.availableSeasonCount = availableSeasonCount;
    return this;
  }

  /**
   * The number of available seasons in the show, if the item is a show.
   * @return availableSeasonCount
   */
  @javax.annotation.Nullable
  public Integer getAvailableSeasonCount() {
    return availableSeasonCount;
  }

  public void setAvailableSeasonCount(Integer availableSeasonCount) {
    this.availableSeasonCount = availableSeasonCount;
  }


  public ItemSummary averageUserRating(BigDecimal averageUserRating) {
    this.averageUserRating = averageUserRating;
    return this;
  }

  /**
   * The average user rating. When based on user ratings from our system this will be out of 10. 
   * minimum: 0
   * @return averageUserRating
   */
  @javax.annotation.Nullable
  public BigDecimal getAverageUserRating() {
    return averageUserRating;
  }

  public void setAverageUserRating(BigDecimal averageUserRating) {
    this.averageUserRating = averageUserRating;
  }


  public ItemSummary badge(String badge) {
    this.badge = badge;
    return this;
  }

  /**
   * The badge this item has.
   * @return badge
   */
  @javax.annotation.Nullable
  public String getBadge() {
    return badge;
  }

  public void setBadge(String badge) {
    this.badge = badge;
  }


  public ItemSummary channelShortCode(String channelShortCode) {
    this.channelShortCode = channelShortCode;
    return this;
  }

  /**
   * The channel short code, if the item is a channel.
   * @return channelShortCode
   */
  @javax.annotation.Nullable
  public String getChannelShortCode() {
    return channelShortCode;
  }

  public void setChannelShortCode(String channelShortCode) {
    this.channelShortCode = channelShortCode;
  }


  public ItemSummary classification(ClassificationSummary classification) {
    this.classification = classification;
    return this;
  }

  /**
   * Get classification
   * @return classification
   */
  @javax.annotation.Nullable
  public ClassificationSummary getClassification() {
    return classification;
  }

  public void setClassification(ClassificationSummary classification) {
    this.classification = classification;
  }


  public ItemSummary contextualTitle(String contextualTitle) {
    this.contextualTitle = contextualTitle;
    return this;
  }

  /**
   * A contextually relative title to display after a parent title. Mostly applicable to Season, Episode and Trailer. 
   * @return contextualTitle
   */
  @javax.annotation.Nullable
  public String getContextualTitle() {
    return contextualTitle;
  }

  public void setContextualTitle(String contextualTitle) {
    this.contextualTitle = contextualTitle;
  }


  public ItemSummary customFields(Map<String, Object> customFields) {
    this.customFields = customFields;
    return this;
  }

  public ItemSummary putCustomFieldsItem(String key, Object customFieldsItem) {
    if (this.customFields == null) {
      this.customFields = new HashMap<>();
    }
    this.customFields.put(key, customFieldsItem);
    return this;
  }

  /**
   * A map of custom fields defined by a curator for an item.
   * @return customFields
   */
  @javax.annotation.Nullable
  public Map<String, Object> getCustomFields() {
    return customFields;
  }

  public void setCustomFields(Map<String, Object> customFields) {
    this.customFields = customFields;
  }


  public ItemSummary customId(String customId) {
    this.customId = customId;
    return this;
  }

  /**
   * A custom identifier for this item. For example the id for this item under a different content system. 
   * @return customId
   */
  @javax.annotation.Nullable
  public String getCustomId() {
    return customId;
  }

  public void setCustomId(String customId) {
    this.customId = customId;
  }


  public ItemSummary duration(Integer duration) {
    this.duration = duration;
    return this;
  }

  /**
   * The duration of the media in seconds.
   * minimum: 0
   * @return duration
   */
  @javax.annotation.Nullable
  public Integer getDuration() {
    return duration;
  }

  public void setDuration(Integer duration) {
    this.duration = duration;
  }


  public ItemSummary episodeCount(Integer episodeCount) {
    this.episodeCount = episodeCount;
    return this;
  }

  /**
   * The number of episodes in the season, if the item is a season.
   * @return episodeCount
   */
  @javax.annotation.Nullable
  public Integer getEpisodeCount() {
    return episodeCount;
  }

  public void setEpisodeCount(Integer episodeCount) {
    this.episodeCount = episodeCount;
  }


  public ItemSummary episodeName(String episodeName) {
    this.episodeName = episodeName;
    return this;
  }

  /**
   * The full name of an episode.
   * @return episodeName
   */
  @javax.annotation.Nullable
  public String getEpisodeName() {
    return episodeName;
  }

  public void setEpisodeName(String episodeName) {
    this.episodeName = episodeName;
  }


  public ItemSummary episodeNumber(Integer episodeNumber) {
    this.episodeNumber = episodeNumber;
    return this;
  }

  /**
   * The number of an episode, if the item is an episode.
   * @return episodeNumber
   */
  @javax.annotation.Nullable
  public Integer getEpisodeNumber() {
    return episodeNumber;
  }

  public void setEpisodeNumber(Integer episodeNumber) {
    this.episodeNumber = episodeNumber;
  }


  public ItemSummary genres(List<String> genres) {
    this.genres = genres;
    return this;
  }

  public ItemSummary addGenresItem(String genresItem) {
    if (this.genres == null) {
      this.genres = new ArrayList<>();
    }
    this.genres.add(genresItem);
    return this;
  }

  /**
   * The array of genres this item belongs to.
   * @return genres
   */
  @javax.annotation.Nullable
  public List<String> getGenres() {
    return genres;
  }

  public void setGenres(List<String> genres) {
    this.genres = genres;
  }


  public ItemSummary hasClosedCaptions(Boolean hasClosedCaptions) {
    this.hasClosedCaptions = hasClosedCaptions;
    return this;
  }

  /**
   * Whether closed captioning is available.
   * @return hasClosedCaptions
   */
  @javax.annotation.Nullable
  public Boolean getHasClosedCaptions() {
    return hasClosedCaptions;
  }

  public void setHasClosedCaptions(Boolean hasClosedCaptions) {
    this.hasClosedCaptions = hasClosedCaptions;
  }


  public ItemSummary id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Unique identifier for an Item
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public ItemSummary images(Map<String, URI> images) {
    this.images = images;
    return this;
  }

  public ItemSummary putImagesItem(String key, URI imagesItem) {
    if (this.images == null) {
      this.images = new HashMap<>();
    }
    this.images.put(key, imagesItem);
    return this;
  }

  /**
   * Get images
   * @return images
   */
  @javax.annotation.Nullable
  public Map<String, URI> getImages() {
    return images;
  }

  public void setImages(Map<String, URI> images) {
    this.images = images;
  }


  public ItemSummary offers(List<Offer> offers) {
    this.offers = offers;
    return this;
  }

  public ItemSummary addOffersItem(Offer offersItem) {
    if (this.offers == null) {
      this.offers = new ArrayList<>();
    }
    this.offers.add(offersItem);
    return this;
  }

  /**
   * The array of available offers for this item.
   * @return offers
   */
  @javax.annotation.Nullable
  public List<Offer> getOffers() {
    return offers;
  }

  public void setOffers(List<Offer> offers) {
    this.offers = offers;
  }


  public ItemSummary path(String path) {
    this.path = path;
    return this;
  }

  /**
   * The path to the detail page of this item. Can be used to load the item detail page via the /page endpoint.
   * @return path
   */
  @javax.annotation.Nonnull
  public String getPath() {
    return path;
  }

  public void setPath(String path) {
    this.path = path;
  }


  public ItemSummary releaseYear(Integer releaseYear) {
    this.releaseYear = releaseYear;
    return this;
  }

  /**
   * The year this item was released
   * @return releaseYear
   */
  @javax.annotation.Nullable
  public Integer getReleaseYear() {
    return releaseYear;
  }

  public void setReleaseYear(Integer releaseYear) {
    this.releaseYear = releaseYear;
  }


  public ItemSummary scopes(List<String> scopes) {
    this.scopes = scopes;
    return this;
  }

  public ItemSummary addScopesItem(String scopesItem) {
    if (this.scopes == null) {
      this.scopes = new ArrayList<>();
    }
    this.scopes.add(scopesItem);
    return this;
  }

  /**
   * The scopes for this item
   * @return scopes
   */
  @javax.annotation.Nullable
  public List<String> getScopes() {
    return scopes;
  }

  public void setScopes(List<String> scopes) {
    this.scopes = scopes;
  }


  public ItemSummary seasonId(String seasonId) {
    this.seasonId = seasonId;
    return this;
  }

  /**
   * The identifier of the season this item belongs to, if the item is an episode.
   * @return seasonId
   */
  @javax.annotation.Nullable
  public String getSeasonId() {
    return seasonId;
  }

  public void setSeasonId(String seasonId) {
    this.seasonId = seasonId;
  }


  public ItemSummary seasonNumber(Integer seasonNumber) {
    this.seasonNumber = seasonNumber;
    return this;
  }

  /**
   * The number of a season, if the item is a season.
   * @return seasonNumber
   */
  @javax.annotation.Nullable
  public Integer getSeasonNumber() {
    return seasonNumber;
  }

  public void setSeasonNumber(Integer seasonNumber) {
    this.seasonNumber = seasonNumber;
  }


  public ItemSummary shortDescription(String shortDescription) {
    this.shortDescription = shortDescription;
    return this;
  }

  /**
   * A truncated description of the item
   * @return shortDescription
   */
  @javax.annotation.Nullable
  public String getShortDescription() {
    return shortDescription;
  }

  public void setShortDescription(String shortDescription) {
    this.shortDescription = shortDescription;
  }


  public ItemSummary showId(String showId) {
    this.showId = showId;
    return this;
  }

  /**
   * The identifier of the show this item belongs to, if the item is a season or episode.
   * @return showId
   */
  @javax.annotation.Nullable
  public String getShowId() {
    return showId;
  }

  public void setShowId(String showId) {
    this.showId = showId;
  }


  public ItemSummary showTitle(String showTitle) {
    this.showTitle = showTitle;
    return this;
  }

  /**
   * Get showTitle
   * @return showTitle
   */
  @javax.annotation.Nullable
  public String getShowTitle() {
    return showTitle;
  }

  public void setShowTitle(String showTitle) {
    this.showTitle = showTitle;
  }


  public ItemSummary subtype(String subtype) {
    this.subtype = subtype;
    return this;
  }

  /**
   * Subtype of the item. Mainly used to identify different types when &#x60;type&#x60; is &#x60;customAsset&#x60; 
   * @return subtype
   */
  @javax.annotation.Nullable
  public String getSubtype() {
    return subtype;
  }

  public void setSubtype(String subtype) {
    this.subtype = subtype;
  }


  public ItemSummary tagline(String tagline) {
    this.tagline = tagline;
    return this;
  }

  /**
   * The tagline of the item
   * @return tagline
   */
  @javax.annotation.Nullable
  public String getTagline() {
    return tagline;
  }

  public void setTagline(String tagline) {
    this.tagline = tagline;
  }


  public ItemSummary themes(List<Theme> themes) {
    this.themes = themes;
    return this;
  }

  public ItemSummary addThemesItem(Theme themesItem) {
    if (this.themes == null) {
      this.themes = new ArrayList<>();
    }
    this.themes.add(themesItem);
    return this;
  }

  /**
   * Gets themes associated with the item
   * @return themes
   */
  @javax.annotation.Nullable
  public List<Theme> getThemes() {
    return themes;
  }

  public void setThemes(List<Theme> themes) {
    this.themes = themes;
  }


  public ItemSummary title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The display title of the item.
   * @return title
   */
  @javax.annotation.Nonnull
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public ItemSummary type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * The type of item
   * @return type
   */
  @javax.annotation.Nonnull
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  public ItemSummary watchPath(String watchPath) {
    this.watchPath = watchPath;
    return this;
  }

  /**
   * The path to watch this item, if the item is a watchable type, e.g. a &#x60;movie&#x60;, &#x60;program&#x60; and &#x60;episode&#x60;.
   * @return watchPath
   */
  @javax.annotation.Nullable
  public String getWatchPath() {
    return watchPath;
  }

  public void setWatchPath(String watchPath) {
    this.watchPath = watchPath;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ItemSummary itemSummary = (ItemSummary) o;
    return Objects.equals(this.advisoryText, itemSummary.advisoryText) &&
        Objects.equals(this.availableEpisodeCount, itemSummary.availableEpisodeCount) &&
        Objects.equals(this.availableSeasonCount, itemSummary.availableSeasonCount) &&
        Objects.equals(this.averageUserRating, itemSummary.averageUserRating) &&
        Objects.equals(this.badge, itemSummary.badge) &&
        Objects.equals(this.channelShortCode, itemSummary.channelShortCode) &&
        Objects.equals(this.classification, itemSummary.classification) &&
        Objects.equals(this.contextualTitle, itemSummary.contextualTitle) &&
        Objects.equals(this.customFields, itemSummary.customFields) &&
        Objects.equals(this.customId, itemSummary.customId) &&
        Objects.equals(this.duration, itemSummary.duration) &&
        Objects.equals(this.episodeCount, itemSummary.episodeCount) &&
        Objects.equals(this.episodeName, itemSummary.episodeName) &&
        Objects.equals(this.episodeNumber, itemSummary.episodeNumber) &&
        Objects.equals(this.genres, itemSummary.genres) &&
        Objects.equals(this.hasClosedCaptions, itemSummary.hasClosedCaptions) &&
        Objects.equals(this.id, itemSummary.id) &&
        Objects.equals(this.images, itemSummary.images) &&
        Objects.equals(this.offers, itemSummary.offers) &&
        Objects.equals(this.path, itemSummary.path) &&
        Objects.equals(this.releaseYear, itemSummary.releaseYear) &&
        Objects.equals(this.scopes, itemSummary.scopes) &&
        Objects.equals(this.seasonId, itemSummary.seasonId) &&
        Objects.equals(this.seasonNumber, itemSummary.seasonNumber) &&
        Objects.equals(this.shortDescription, itemSummary.shortDescription) &&
        Objects.equals(this.showId, itemSummary.showId) &&
        Objects.equals(this.showTitle, itemSummary.showTitle) &&
        Objects.equals(this.subtype, itemSummary.subtype) &&
        Objects.equals(this.tagline, itemSummary.tagline) &&
        Objects.equals(this.themes, itemSummary.themes) &&
        Objects.equals(this.title, itemSummary.title) &&
        Objects.equals(this.type, itemSummary.type) &&
        Objects.equals(this.watchPath, itemSummary.watchPath);
  }

  @Override
  public int hashCode() {
    return Objects.hash(advisoryText, availableEpisodeCount, availableSeasonCount, averageUserRating, badge, channelShortCode, classification, contextualTitle, customFields, customId, duration, episodeCount, episodeName, episodeNumber, genres, hasClosedCaptions, id, images, offers, path, releaseYear, scopes, seasonId, seasonNumber, shortDescription, showId, showTitle, subtype, tagline, themes, title, type, watchPath);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ItemSummary {\n");
    sb.append("    advisoryText: ").append(toIndentedString(advisoryText)).append("\n");
    sb.append("    availableEpisodeCount: ").append(toIndentedString(availableEpisodeCount)).append("\n");
    sb.append("    availableSeasonCount: ").append(toIndentedString(availableSeasonCount)).append("\n");
    sb.append("    averageUserRating: ").append(toIndentedString(averageUserRating)).append("\n");
    sb.append("    badge: ").append(toIndentedString(badge)).append("\n");
    sb.append("    channelShortCode: ").append(toIndentedString(channelShortCode)).append("\n");
    sb.append("    classification: ").append(toIndentedString(classification)).append("\n");
    sb.append("    contextualTitle: ").append(toIndentedString(contextualTitle)).append("\n");
    sb.append("    customFields: ").append(toIndentedString(customFields)).append("\n");
    sb.append("    customId: ").append(toIndentedString(customId)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    episodeCount: ").append(toIndentedString(episodeCount)).append("\n");
    sb.append("    episodeName: ").append(toIndentedString(episodeName)).append("\n");
    sb.append("    episodeNumber: ").append(toIndentedString(episodeNumber)).append("\n");
    sb.append("    genres: ").append(toIndentedString(genres)).append("\n");
    sb.append("    hasClosedCaptions: ").append(toIndentedString(hasClosedCaptions)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    images: ").append(toIndentedString(images)).append("\n");
    sb.append("    offers: ").append(toIndentedString(offers)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    releaseYear: ").append(toIndentedString(releaseYear)).append("\n");
    sb.append("    scopes: ").append(toIndentedString(scopes)).append("\n");
    sb.append("    seasonId: ").append(toIndentedString(seasonId)).append("\n");
    sb.append("    seasonNumber: ").append(toIndentedString(seasonNumber)).append("\n");
    sb.append("    shortDescription: ").append(toIndentedString(shortDescription)).append("\n");
    sb.append("    showId: ").append(toIndentedString(showId)).append("\n");
    sb.append("    showTitle: ").append(toIndentedString(showTitle)).append("\n");
    sb.append("    subtype: ").append(toIndentedString(subtype)).append("\n");
    sb.append("    tagline: ").append(toIndentedString(tagline)).append("\n");
    sb.append("    themes: ").append(toIndentedString(themes)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    watchPath: ").append(toIndentedString(watchPath)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("advisoryText");
    openapiFields.add("availableEpisodeCount");
    openapiFields.add("availableSeasonCount");
    openapiFields.add("averageUserRating");
    openapiFields.add("badge");
    openapiFields.add("channelShortCode");
    openapiFields.add("classification");
    openapiFields.add("contextualTitle");
    openapiFields.add("customFields");
    openapiFields.add("customId");
    openapiFields.add("duration");
    openapiFields.add("episodeCount");
    openapiFields.add("episodeName");
    openapiFields.add("episodeNumber");
    openapiFields.add("genres");
    openapiFields.add("hasClosedCaptions");
    openapiFields.add("id");
    openapiFields.add("images");
    openapiFields.add("offers");
    openapiFields.add("path");
    openapiFields.add("releaseYear");
    openapiFields.add("scopes");
    openapiFields.add("seasonId");
    openapiFields.add("seasonNumber");
    openapiFields.add("shortDescription");
    openapiFields.add("showId");
    openapiFields.add("showTitle");
    openapiFields.add("subtype");
    openapiFields.add("tagline");
    openapiFields.add("themes");
    openapiFields.add("title");
    openapiFields.add("type");
    openapiFields.add("watchPath");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("path");
    openapiRequiredFields.add("title");
    openapiRequiredFields.add("type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ItemSummary
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ItemSummary.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ItemSummary is not found in the empty JSON string", ItemSummary.openapiRequiredFields.toString()));
        }
      }

      String discriminatorValue = jsonElement.getAsJsonObject().get("type").getAsString();
      switch (discriminatorValue) {
        case "ItemDetail":
          ItemDetail.validateJsonElement(jsonElement);
          break;
        default:
          throw new IllegalArgumentException(String.format("The value of the `type` field `%s` does not match any key defined in the discriminator's mapping.", discriminatorValue));
      }
  }


  /**
   * Create an instance of ItemSummary given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ItemSummary
   * @throws IOException if the JSON string is invalid with respect to ItemSummary
   */
  public static ItemSummary fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ItemSummary.class);
  }

  /**
   * Convert an instance of ItemSummary to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

