/*
 * Rocket Services
 * An Orchestration Layer that takes ISL services and packages them in a more targeted way for front-end applications. This in turn makes client integration easier and reduces the complexity and size of front-end applications.  Rocket is also customisable - allowing UI engineers to ‘remix’ the existing back-end services into something that best suits the application they are developing. 
 *
 * The version of the OpenAPI document: 3.730.300-ref-1-39-0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.Account;
import org.openapitools.client.model.AccountDevices;
import org.openapitools.client.model.AccountNonce;
import org.openapitools.client.model.AccountUpdateRequest;
import org.openapitools.client.model.AddPaymentMethodRequest;
import org.openapitools.client.model.ChangePasswordRequest;
import org.openapitools.client.model.ChangePinRequest;
import org.openapitools.client.model.Device;
import org.openapitools.client.model.DeviceAuthorizationCode;
import org.openapitools.client.model.DeviceRegistrationRequest;
import org.openapitools.client.model.Entitlement;
import org.openapitools.client.model.MediaFile;
import org.openapitools.client.model.PaymentMethod;
import org.openapitools.client.model.ProfileCreationRequest;
import org.openapitools.client.model.ProfileDetail;
import org.openapitools.client.model.ProfileSummary;
import org.openapitools.client.model.ProfileUpdateRequest;
import org.openapitools.client.model.Purchase;
import org.openapitools.client.model.PurchaseRequest;
import org.openapitools.client.model.ServiceError;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for AccountApi
 */
@Disabled
public class AccountApiTest {

    private final AccountApi api = new AccountApi();

    /**
     * Add a new payment method to an account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addPaymentMethodTest() throws ApiException {
        AddPaymentMethodRequest addPaymentMethodRequest = null;
        List<String> ff = null;
        String lang = null;
        PaymentMethod response = api.addPaymentMethod(addPaymentMethodRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Authorize a device from a generated device authorization code.  This is the second step in the process of authorizing a device by pin code.  Firstly the device must request a generated authorization code via the &#x60;/authorization/device/code&#x60; endpoint.  This endpoint then authorizes the device associated with the code to sign in to a user account. Typically this endpoint will be called from a page presented in the web app under the account section.  Once authorized, the device will then be able to sign in to that account via the &#x60;/authorization/device&#x60; endpoint, without needing to provide the  credentials of the user. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void authorizeDeviceTest() throws ApiException {
        DeviceAuthorizationCode deviceAuthorizationCode = null;
        List<String> ff = null;
        String lang = null;
        api.authorizeDevice(deviceAuthorizationCode, ff, lang);
        // TODO: test validations
    }

    /**
     * Cancel a plan subscription.  A cancelled subscription will continue to be valid until the subscription expiry date or next renewal date. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelSubscriptionTest() throws ApiException {
        String id = null;
        List<String> ff = null;
        String lang = null;
        api.cancelSubscription(id, ff, lang);
        // TODO: test validations
    }

    /**
     * Change the password of an account.  The expected token scope is Settings. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changePasswordTest() throws ApiException {
        ChangePasswordRequest changePasswordRequest = null;
        List<String> ff = null;
        String lang = null;
        api.changePassword(changePasswordRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Change the pin of an account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changePinTest() throws ApiException {
        ChangePinRequest changePinRequest = null;
        List<String> ff = null;
        String lang = null;
        api.changePin(changePinRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Create a new profile under the active account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createProfileTest() throws ApiException {
        ProfileCreationRequest profileCreationRequest = null;
        List<String> ff = null;
        String lang = null;
        ProfileDetail response = api.createProfile(profileCreationRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Delete a profile with a specific id under the active account.  Note that you cannot delete the primary profile. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteProfileWithIdTest() throws ApiException {
        String id = null;
        List<String> ff = null;
        String lang = null;
        api.deleteProfileWithId(id, ff, lang);
        // TODO: test validations
    }

    /**
     * Deregister a playback device from an account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deregisterDeviceTest() throws ApiException {
        String id = null;
        List<String> ff = null;
        String lang = null;
        api.deregisterDevice(id, ff, lang);
        // TODO: test validations
    }

    /**
     * Generate a new account nonce.  A nonce may be required to help sign a response from a third party service which will be passed back to these services.  For example a Facebook single-sign-on request initiated by a client application may first get a nonce from here to include in the request. Facebook will then include the nonce in the auth token it issues. This token can be passed back to our services and the nonce checked for validity. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void generateNonceTest() throws ApiException {
        List<String> ff = null;
        String lang = null;
        AccountNonce response = api.generateNonce(ff, lang);
        // TODO: test validations
    }

    /**
     * Get the details of an account along with the profiles and entitlements under it.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAccountTest() throws ApiException {
        List<String> ff = null;
        String lang = null;
        Account response = api.getAccount(ff, lang);
        // TODO: test validations
    }

    /**
     * Get a registered device.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDeviceTest() throws ApiException {
        String id = null;
        List<String> ff = null;
        String lang = null;
        Device response = api.getDevice(id, ff, lang);
        // TODO: test validations
    }

    /**
     * Get all devices registered under this account.  Also includes information around device registration and deregistration limits. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDevicesTest() throws ApiException {
        List<String> ff = null;
        String lang = null;
        AccountDevices response = api.getDevices(ff, lang);
        // TODO: test validations
    }

    /**
     * Get all entitlements under the account.  This list is returned under the call to get account information so a call here is only required when wishing to refresh a local copy of entitlements. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEntitlementsTest() throws ApiException {
        List<String> ff = null;
        String lang = null;
        List<Entitlement> response = api.getEntitlements(ff, lang);
        // TODO: test validations
    }

    /**
     * Get the video files associated with an item given maximum resolution, device type and one or more delivery types.  This endpoint accepts an Account Catalog token, however if when requesting playback files you receive an *403 status code with error code 1* then the file you&#39;re requesting is classification restricted. This means you should switch to target the &#x60;/account/items/{id}/videos-guarded&#x60; endpoint, passing it an Account Playback token. If not already obtained, this token can be requested via the &#x60;/itv/pinauthorization&#x60; endpoint with an account level pin.  For convenience you may also access free / public files through this endpoint instead of the /items/{id}/videos endpoint, when authenticated.  Returns an array of video file objects which each include a url to a video.  The first entry in the array contains what is predicted to be the best match. The remainder of the entries, if any, may contain resolutions below what was requests. For example if you request HD-720 the response may also contain SD entries.  If you specify multiple delivery types, then the response array will insert types in the order you specify them in the query. For example &#x60;stream,progressive&#x60; would return an array with 0 or more stream files followed by 0 or more progressive files.  If no files are found a 404 is returned. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getItemMediaFilesTest() throws ApiException {
        String id = null;
        List<String> delivery = null;
        String resolution = null;
        List<String> formats = null;
        String device = null;
        String sub = null;
        List<String> segments = null;
        List<String> ff = null;
        String lang = null;
        List<MediaFile> response = api.getItemMediaFiles(id, delivery, resolution, formats, device, sub, segments, ff, lang);
        // TODO: test validations
    }

    /**
     * Get the video files associated with an item given maximum resolution, device type and one or more delivery types.  This endpoint is identical to the &#x60;/account/items/{id}/videos&#x60; however it expects an Account Playback token. This token, and in association this endpoint, is specifically for use when playback files are classification restricted and require an account level pin to access them.  Returns an array of video file objects which each include a url to a video.  The first entry in the array contains what is predicted to be the best match. The remainder of the entries, if any, may contain resolutions below what was requests. For example if you request HD-720 the response may also contain SD entries.  If you specify multiple delivery types, then the response array will insert types in the order you specify them in the query. For example &#x60;stream,progressive&#x60; would return an array with 0 or more stream files followed by 0 or more progressive files.  If no files are found a 404 is returned. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getItemMediaFilesGuardedTest() throws ApiException {
        String id = null;
        List<String> delivery = null;
        String resolution = null;
        List<String> formats = null;
        String device = null;
        String sub = null;
        List<String> segments = null;
        List<String> ff = null;
        String lang = null;
        List<MediaFile> response = api.getItemMediaFilesGuarded(id, delivery, resolution, formats, device, sub, segments, ff, lang);
        // TODO: test validations
    }

    /**
     * Get a payment method under an account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPaymentMethodTest() throws ApiException {
        String id = null;
        List<String> ff = null;
        String lang = null;
        PaymentMethod response = api.getPaymentMethod(id, ff, lang);
        // TODO: test validations
    }

    /**
     * Get the available payment methods under an account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPaymentMethodsTest() throws ApiException {
        List<String> ff = null;
        String lang = null;
        List<PaymentMethod> response = api.getPaymentMethods(ff, lang);
        // TODO: test validations
    }

    /**
     * Get the summary of a profile with a specific id under the active account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProfileWithIdTest() throws ApiException {
        String id = null;
        List<String> ff = null;
        String lang = null;
        ProfileSummary response = api.getProfileWithId(id, ff, lang);
        // TODO: test validations
    }

    /**
     * Get a list of all purchases made under an account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPurchasesTest() throws ApiException {
        List<String> ff = null;
        String lang = null;
        List<Purchase> response = api.getPurchases(ff, lang);
        // TODO: test validations
    }

    /**
     * Purchase a plan or item offer. The result of a successful transaction is a new entitlement. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void makePurchaseTest() throws ApiException {
        PurchaseRequest purchaseRequest = null;
        List<String> ff = null;
        String lang = null;
        Entitlement response = api.makePurchase(purchaseRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Register a playback device under an account.  If a device with the same id already exists a &#x60;409&#x60; conflict will be returned. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void registerDeviceTest() throws ApiException {
        DeviceRegistrationRequest deviceRegistrationRequest = null;
        List<String> ff = null;
        String lang = null;
        Device response = api.registerDevice(deviceRegistrationRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Remove a payment method from an account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removePaymentMethodTest() throws ApiException {
        String id = null;
        List<String> ff = null;
        String lang = null;
        api.removePaymentMethod(id, ff, lang);
        // TODO: test validations
    }

    /**
     * Rename a device
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void renameDeviceTest() throws ApiException {
        String id = null;
        String name = null;
        List<String> ff = null;
        String lang = null;
        api.renameDevice(id, name, ff, lang);
        // TODO: test validations
    }

    /**
     * Request that the email address tied to an account be verified.  This will send a verification email to the email address of the primary profile containing a link which, once clicked, completes the verification process via the /verify-email endpoint.  Note that when an account is created this email is sent automatically so there&#39;s no need to call this directly.  If the user doesn&#39;t click the link before it expires then this endpoint can be called to request a new verification email. In the future it may also be used if we add support for changing an account email address. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void requestEmailVerificationTest() throws ApiException {
        List<String> ff = null;
        String lang = null;
        api.requestEmailVerification(ff, lang);
        // TODO: test validations
    }

    /**
     * Update the details of an account.  With the exception of the address, this supports partial updates, so you can send just the properties you wish to update.  When the address is provided any properties which are omitted from the address will be cleared. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateAccountTest() throws ApiException {
        AccountUpdateRequest accountUpdateRequest = null;
        List<String> ff = null;
        String lang = null;
        api.updateAccount(accountUpdateRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Update the summary of a profile with a specific id under the active account.  This supports partial updates so you can send just the properties you wish to update. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateProfileWithIdTest() throws ApiException {
        String id = null;
        ProfileUpdateRequest profileUpdateRequest = null;
        List<String> ff = null;
        String lang = null;
        api.updateProfileWithId(id, profileUpdateRequest, ff, lang);
        // TODO: test validations
    }

    /**
     * Renew a cancelled subscription or switch subscription to a different plan.  When renewing a cancelled subscription membership, hit this endpoint with the id of subscription to renew.  To switch plans provide the id of the current active subscription membership of the account, and in the query specify the id of the plan to switch to. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateSubscriptionTest() throws ApiException {
        String id = null;
        String planId = null;
        List<String> ff = null;
        String lang = null;
        api.updateSubscription(id, planId, ff, lang);
        // TODO: test validations
    }

}
