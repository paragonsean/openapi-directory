/*
 * EU BON UTIS
 * The Unified Taxonomic Information Service (UTIS) is the taxonomic backbone for the EU-BON project
 *
 * The version of the OpenAPI document: 1.0
 * Contact: EditSupport@bgbm.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ServiceProviderInfo;
import org.openapitools.client.model.TnrMsg;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UtisControllerApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public UtisControllerApi() {
        this(Configuration.getDefaultApiClient());
    }

    public UtisControllerApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for capabilities
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call capabilitiesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/capabilities";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call capabilitiesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return capabilitiesCall(_callback);

    }

    /**
     * capabilities
     * capabilities
     * @return List&lt;ServiceProviderInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public List<ServiceProviderInfo> capabilities() throws ApiException {
        ApiResponse<List<ServiceProviderInfo>> localVarResp = capabilitiesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * capabilities
     * capabilities
     * @return ApiResponse&lt;List&lt;ServiceProviderInfo&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ServiceProviderInfo>> capabilitiesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = capabilitiesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<ServiceProviderInfo>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * capabilities (asynchronously)
     * capabilities
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call capabilitiesAsync(final ApiCallback<List<ServiceProviderInfo>> _callback) throws ApiException {

        okhttp3.Call localVarCall = capabilitiesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<ServiceProviderInfo>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for search
     * @param query The scientific name to search for. For example: \&quot;Bellis perennis\&quot;, \&quot;Prionus\&quot; or \&quot;Bolinus brandaris\&quot;. This is an exact search so wildcard characters are not supported. (required)
     * @param providers A list of provider id strings concatenated by comma characters. The default : \&quot;pesi,bgbm-cdm-server[col]\&quot; will be used if this parameter is not set. A list of all available provider ids can be obtained from the &#39;/capabilities&#39; service end point. Providers can be nested, that is a parent provider can have sub providers. If the id of the parent provider is supplied all subproviders will be queried. The query can also be restriced to one or more subproviders by using the following syntax: parent-id[sub-id-1,sub-id2,...] (optional, default to pesi,eunis,bgbm-cdm-server[col])
     * @param searchMode Specifies the searchMode. Possible search modes are: scientificNameExact, scientificNameLike (begins with), vernacularNameExact, vernacularNameLike (contains), findByIdentifier. If the a provider does not support the chosen searchMode it will be skipped and the status message in the tnrClientStatus will be set to &#39;unsupported search mode&#39; in this case. (optional, default to scientificNameExact)
     * @param addSynonymy Indicates whether the synonymy of the accepted taxon should be included into the response. Turning this option on may cause an increased response time. (optional, default to false)
     * @param timeout The maximum of milliseconds to wait for responses from any of the providers. If the timeout is exceeded the service will jut return the resonses that have been received so far. The default timeout is 0 ms (wait for ever) (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchCall(String query, String providers, String searchMode, Boolean addSynonymy, Long timeout, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (providers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("providers", providers));
        }

        if (searchMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("searchMode", searchMode));
        }

        if (addSynonymy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("addSynonymy", addSynonymy));
        }

        if (timeout != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timeout", timeout));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchValidateBeforeCall(String query, String providers, String searchMode, Boolean addSynonymy, Long timeout, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'query' is set
        if (query == null) {
            throw new ApiException("Missing the required parameter 'query' when calling search(Async)");
        }

        return searchCall(query, providers, searchMode, addSynonymy, timeout, _callback);

    }

    /**
     * search
     * search
     * @param query The scientific name to search for. For example: \&quot;Bellis perennis\&quot;, \&quot;Prionus\&quot; or \&quot;Bolinus brandaris\&quot;. This is an exact search so wildcard characters are not supported. (required)
     * @param providers A list of provider id strings concatenated by comma characters. The default : \&quot;pesi,bgbm-cdm-server[col]\&quot; will be used if this parameter is not set. A list of all available provider ids can be obtained from the &#39;/capabilities&#39; service end point. Providers can be nested, that is a parent provider can have sub providers. If the id of the parent provider is supplied all subproviders will be queried. The query can also be restriced to one or more subproviders by using the following syntax: parent-id[sub-id-1,sub-id2,...] (optional, default to pesi,eunis,bgbm-cdm-server[col])
     * @param searchMode Specifies the searchMode. Possible search modes are: scientificNameExact, scientificNameLike (begins with), vernacularNameExact, vernacularNameLike (contains), findByIdentifier. If the a provider does not support the chosen searchMode it will be skipped and the status message in the tnrClientStatus will be set to &#39;unsupported search mode&#39; in this case. (optional, default to scientificNameExact)
     * @param addSynonymy Indicates whether the synonymy of the accepted taxon should be included into the response. Turning this option on may cause an increased response time. (optional, default to false)
     * @param timeout The maximum of milliseconds to wait for responses from any of the providers. If the timeout is exceeded the service will jut return the resonses that have been received so far. The default timeout is 0 ms (wait for ever) (optional, default to 0)
     * @return TnrMsg
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public TnrMsg search(String query, String providers, String searchMode, Boolean addSynonymy, Long timeout) throws ApiException {
        ApiResponse<TnrMsg> localVarResp = searchWithHttpInfo(query, providers, searchMode, addSynonymy, timeout);
        return localVarResp.getData();
    }

    /**
     * search
     * search
     * @param query The scientific name to search for. For example: \&quot;Bellis perennis\&quot;, \&quot;Prionus\&quot; or \&quot;Bolinus brandaris\&quot;. This is an exact search so wildcard characters are not supported. (required)
     * @param providers A list of provider id strings concatenated by comma characters. The default : \&quot;pesi,bgbm-cdm-server[col]\&quot; will be used if this parameter is not set. A list of all available provider ids can be obtained from the &#39;/capabilities&#39; service end point. Providers can be nested, that is a parent provider can have sub providers. If the id of the parent provider is supplied all subproviders will be queried. The query can also be restriced to one or more subproviders by using the following syntax: parent-id[sub-id-1,sub-id2,...] (optional, default to pesi,eunis,bgbm-cdm-server[col])
     * @param searchMode Specifies the searchMode. Possible search modes are: scientificNameExact, scientificNameLike (begins with), vernacularNameExact, vernacularNameLike (contains), findByIdentifier. If the a provider does not support the chosen searchMode it will be skipped and the status message in the tnrClientStatus will be set to &#39;unsupported search mode&#39; in this case. (optional, default to scientificNameExact)
     * @param addSynonymy Indicates whether the synonymy of the accepted taxon should be included into the response. Turning this option on may cause an increased response time. (optional, default to false)
     * @param timeout The maximum of milliseconds to wait for responses from any of the providers. If the timeout is exceeded the service will jut return the resonses that have been received so far. The default timeout is 0 ms (wait for ever) (optional, default to 0)
     * @return ApiResponse&lt;TnrMsg&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TnrMsg> searchWithHttpInfo(String query, String providers, String searchMode, Boolean addSynonymy, Long timeout) throws ApiException {
        okhttp3.Call localVarCall = searchValidateBeforeCall(query, providers, searchMode, addSynonymy, timeout, null);
        Type localVarReturnType = new TypeToken<TnrMsg>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * search (asynchronously)
     * search
     * @param query The scientific name to search for. For example: \&quot;Bellis perennis\&quot;, \&quot;Prionus\&quot; or \&quot;Bolinus brandaris\&quot;. This is an exact search so wildcard characters are not supported. (required)
     * @param providers A list of provider id strings concatenated by comma characters. The default : \&quot;pesi,bgbm-cdm-server[col]\&quot; will be used if this parameter is not set. A list of all available provider ids can be obtained from the &#39;/capabilities&#39; service end point. Providers can be nested, that is a parent provider can have sub providers. If the id of the parent provider is supplied all subproviders will be queried. The query can also be restriced to one or more subproviders by using the following syntax: parent-id[sub-id-1,sub-id2,...] (optional, default to pesi,eunis,bgbm-cdm-server[col])
     * @param searchMode Specifies the searchMode. Possible search modes are: scientificNameExact, scientificNameLike (begins with), vernacularNameExact, vernacularNameLike (contains), findByIdentifier. If the a provider does not support the chosen searchMode it will be skipped and the status message in the tnrClientStatus will be set to &#39;unsupported search mode&#39; in this case. (optional, default to scientificNameExact)
     * @param addSynonymy Indicates whether the synonymy of the accepted taxon should be included into the response. Turning this option on may cause an increased response time. (optional, default to false)
     * @param timeout The maximum of milliseconds to wait for responses from any of the providers. If the timeout is exceeded the service will jut return the resonses that have been received so far. The default timeout is 0 ms (wait for ever) (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchAsync(String query, String providers, String searchMode, Boolean addSynonymy, Long timeout, final ApiCallback<TnrMsg> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchValidateBeforeCall(query, providers, searchMode, addSynonymy, timeout, _callback);
        Type localVarReturnType = new TypeToken<TnrMsg>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
