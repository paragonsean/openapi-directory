/**
 * Betriebsstellen
 * This REST-API enables you to query station and stop infos
 *
 * The version of the OpenAPI document: v1
 * Contact: Joachim.Schirrmacher@deutschebahn.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIStation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIStation::OAIStation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIStation::OAIStation() {
    this->initializeModel();
}

OAIStation::~OAIStation() {}

void OAIStation::initializeModel() {

    m_rb_isSet = false;
    m_rb_isValid = false;

    m_uic_isSet = false;
    m_uic_isValid = false;

    m_abbrev_isSet = false;
    m_abbrev_isValid = false;

    m_border_station_isSet = false;
    m_border_station_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_location_code_isSet = false;
    m_location_code_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_r_short_isSet = false;
    m_r_short_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_time_table_relevant_isSet = false;
    m_time_table_relevant_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_valid_from_isSet = false;
    m_valid_from_isValid = false;

    m_valid_till_isSet = false;
    m_valid_till_isValid = false;
}

void OAIStation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIStation::fromJsonObject(QJsonObject json) {

    m_rb_isValid = ::OpenAPI::fromJsonValue(m_rb, json[QString("RB")]);
    m_rb_isSet = !json[QString("RB")].isNull() && m_rb_isValid;

    m_uic_isValid = ::OpenAPI::fromJsonValue(m_uic, json[QString("UIC")]);
    m_uic_isSet = !json[QString("UIC")].isNull() && m_uic_isValid;

    m_abbrev_isValid = ::OpenAPI::fromJsonValue(m_abbrev, json[QString("abbrev")]);
    m_abbrev_isSet = !json[QString("abbrev")].isNull() && m_abbrev_isValid;

    m_border_station_isValid = ::OpenAPI::fromJsonValue(m_border_station, json[QString("borderStation")]);
    m_border_station_isSet = !json[QString("borderStation")].isNull() && m_border_station_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_location_code_isValid = ::OpenAPI::fromJsonValue(m_location_code, json[QString("locationCode")]);
    m_location_code_isSet = !json[QString("locationCode")].isNull() && m_location_code_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_r_short_isValid = ::OpenAPI::fromJsonValue(m_r_short, json[QString("short")]);
    m_r_short_isSet = !json[QString("short")].isNull() && m_r_short_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_time_table_relevant_isValid = ::OpenAPI::fromJsonValue(m_time_table_relevant, json[QString("timeTableRelevant")]);
    m_time_table_relevant_isSet = !json[QString("timeTableRelevant")].isNull() && m_time_table_relevant_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_valid_from_isValid = ::OpenAPI::fromJsonValue(m_valid_from, json[QString("validFrom")]);
    m_valid_from_isSet = !json[QString("validFrom")].isNull() && m_valid_from_isValid;

    m_valid_till_isValid = ::OpenAPI::fromJsonValue(m_valid_till, json[QString("validTill")]);
    m_valid_till_isSet = !json[QString("validTill")].isNull() && m_valid_till_isValid;
}

QString OAIStation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIStation::asJsonObject() const {
    QJsonObject obj;
    if (m_rb_isSet) {
        obj.insert(QString("RB"), ::OpenAPI::toJsonValue(m_rb));
    }
    if (m_uic_isSet) {
        obj.insert(QString("UIC"), ::OpenAPI::toJsonValue(m_uic));
    }
    if (m_abbrev_isSet) {
        obj.insert(QString("abbrev"), ::OpenAPI::toJsonValue(m_abbrev));
    }
    if (m_border_station_isSet) {
        obj.insert(QString("borderStation"), ::OpenAPI::toJsonValue(m_border_station));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_location_code_isSet) {
        obj.insert(QString("locationCode"), ::OpenAPI::toJsonValue(m_location_code));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_r_short_isSet) {
        obj.insert(QString("short"), ::OpenAPI::toJsonValue(m_r_short));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_time_table_relevant_isSet) {
        obj.insert(QString("timeTableRelevant"), ::OpenAPI::toJsonValue(m_time_table_relevant));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_valid_from_isSet) {
        obj.insert(QString("validFrom"), ::OpenAPI::toJsonValue(m_valid_from));
    }
    if (m_valid_till_isSet) {
        obj.insert(QString("validTill"), ::OpenAPI::toJsonValue(m_valid_till));
    }
    return obj;
}

qint32 OAIStation::getRb() const {
    return m_rb;
}
void OAIStation::setRb(const qint32 &rb) {
    m_rb = rb;
    m_rb_isSet = true;
}

bool OAIStation::is_rb_Set() const{
    return m_rb_isSet;
}

bool OAIStation::is_rb_Valid() const{
    return m_rb_isValid;
}

QString OAIStation::getUic() const {
    return m_uic;
}
void OAIStation::setUic(const QString &uic) {
    m_uic = uic;
    m_uic_isSet = true;
}

bool OAIStation::is_uic_Set() const{
    return m_uic_isSet;
}

bool OAIStation::is_uic_Valid() const{
    return m_uic_isValid;
}

QString OAIStation::getAbbrev() const {
    return m_abbrev;
}
void OAIStation::setAbbrev(const QString &abbrev) {
    m_abbrev = abbrev;
    m_abbrev_isSet = true;
}

bool OAIStation::is_abbrev_Set() const{
    return m_abbrev_isSet;
}

bool OAIStation::is_abbrev_Valid() const{
    return m_abbrev_isValid;
}

bool OAIStation::isBorderStation() const {
    return m_border_station;
}
void OAIStation::setBorderStation(const bool &border_station) {
    m_border_station = border_station;
    m_border_station_isSet = true;
}

bool OAIStation::is_border_station_Set() const{
    return m_border_station_isSet;
}

bool OAIStation::is_border_station_Valid() const{
    return m_border_station_isValid;
}

qint32 OAIStation::getId() const {
    return m_id;
}
void OAIStation::setId(const qint32 &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIStation::is_id_Set() const{
    return m_id_isSet;
}

bool OAIStation::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIStation::getLocationCode() const {
    return m_location_code;
}
void OAIStation::setLocationCode(const QString &location_code) {
    m_location_code = location_code;
    m_location_code_isSet = true;
}

bool OAIStation::is_location_code_Set() const{
    return m_location_code_isSet;
}

bool OAIStation::is_location_code_Valid() const{
    return m_location_code_isValid;
}

QString OAIStation::getName() const {
    return m_name;
}
void OAIStation::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIStation::is_name_Set() const{
    return m_name_isSet;
}

bool OAIStation::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIStation::getRShort() const {
    return m_r_short;
}
void OAIStation::setRShort(const QString &r_short) {
    m_r_short = r_short;
    m_r_short_isSet = true;
}

bool OAIStation::is_r_short_Set() const{
    return m_r_short_isSet;
}

bool OAIStation::is_r_short_Valid() const{
    return m_r_short_isValid;
}

QString OAIStation::getStatus() const {
    return m_status;
}
void OAIStation::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIStation::is_status_Set() const{
    return m_status_isSet;
}

bool OAIStation::is_status_Valid() const{
    return m_status_isValid;
}

bool OAIStation::isTimeTableRelevant() const {
    return m_time_table_relevant;
}
void OAIStation::setTimeTableRelevant(const bool &time_table_relevant) {
    m_time_table_relevant = time_table_relevant;
    m_time_table_relevant_isSet = true;
}

bool OAIStation::is_time_table_relevant_Set() const{
    return m_time_table_relevant_isSet;
}

bool OAIStation::is_time_table_relevant_Valid() const{
    return m_time_table_relevant_isValid;
}

QString OAIStation::getType() const {
    return m_type;
}
void OAIStation::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIStation::is_type_Set() const{
    return m_type_isSet;
}

bool OAIStation::is_type_Valid() const{
    return m_type_isValid;
}

QString OAIStation::getValidFrom() const {
    return m_valid_from;
}
void OAIStation::setValidFrom(const QString &valid_from) {
    m_valid_from = valid_from;
    m_valid_from_isSet = true;
}

bool OAIStation::is_valid_from_Set() const{
    return m_valid_from_isSet;
}

bool OAIStation::is_valid_from_Valid() const{
    return m_valid_from_isValid;
}

QString OAIStation::getValidTill() const {
    return m_valid_till;
}
void OAIStation::setValidTill(const QString &valid_till) {
    m_valid_till = valid_till;
    m_valid_till_isSet = true;
}

bool OAIStation::is_valid_till_Set() const{
    return m_valid_till_isSet;
}

bool OAIStation::is_valid_till_Valid() const{
    return m_valid_till_isValid;
}

bool OAIStation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_rb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uic_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_abbrev_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_border_station_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_location_code_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_short_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_table_relevant_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_valid_from_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_valid_till_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIStation::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
