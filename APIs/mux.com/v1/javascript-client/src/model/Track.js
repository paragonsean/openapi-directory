/**
 * Mux API
 * Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.
 *
 * The version of the OpenAPI document: v1
 * Contact: devex@mux.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The Track model module.
 * @module model/Track
 * @version v1
 */
class Track {
    /**
     * Constructs a new <code>Track</code>.
     * @alias module:model/Track
     */
    constructor() { 
        
        Track.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Track</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Track} obj Optional instance to populate.
     * @return {module:model/Track} The populated <code>Track</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Track();

            if (data.hasOwnProperty('closed_captions')) {
                obj['closed_captions'] = ApiClient.convertToType(data['closed_captions'], 'Boolean');
            }
            if (data.hasOwnProperty('duration')) {
                obj['duration'] = ApiClient.convertToType(data['duration'], 'Number');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('language_code')) {
                obj['language_code'] = ApiClient.convertToType(data['language_code'], 'String');
            }
            if (data.hasOwnProperty('max_channel_layout')) {
                obj['max_channel_layout'] = ApiClient.convertToType(data['max_channel_layout'], 'String');
            }
            if (data.hasOwnProperty('max_channels')) {
                obj['max_channels'] = ApiClient.convertToType(data['max_channels'], 'Number');
            }
            if (data.hasOwnProperty('max_frame_rate')) {
                obj['max_frame_rate'] = ApiClient.convertToType(data['max_frame_rate'], 'Number');
            }
            if (data.hasOwnProperty('max_height')) {
                obj['max_height'] = ApiClient.convertToType(data['max_height'], 'Number');
            }
            if (data.hasOwnProperty('max_width')) {
                obj['max_width'] = ApiClient.convertToType(data['max_width'], 'Number');
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('passthrough')) {
                obj['passthrough'] = ApiClient.convertToType(data['passthrough'], 'String');
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = ApiClient.convertToType(data['status'], 'String');
            }
            if (data.hasOwnProperty('text_source')) {
                obj['text_source'] = ApiClient.convertToType(data['text_source'], 'String');
            }
            if (data.hasOwnProperty('text_type')) {
                obj['text_type'] = ApiClient.convertToType(data['text_type'], 'String');
            }
            if (data.hasOwnProperty('type')) {
                obj['type'] = ApiClient.convertToType(data['type'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Track</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Track</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['language_code'] && !(typeof data['language_code'] === 'string' || data['language_code'] instanceof String)) {
            throw new Error("Expected the field `language_code` to be a primitive type in the JSON string but got " + data['language_code']);
        }
        // ensure the json data is a string
        if (data['max_channel_layout'] && !(typeof data['max_channel_layout'] === 'string' || data['max_channel_layout'] instanceof String)) {
            throw new Error("Expected the field `max_channel_layout` to be a primitive type in the JSON string but got " + data['max_channel_layout']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // ensure the json data is a string
        if (data['passthrough'] && !(typeof data['passthrough'] === 'string' || data['passthrough'] instanceof String)) {
            throw new Error("Expected the field `passthrough` to be a primitive type in the JSON string but got " + data['passthrough']);
        }
        // ensure the json data is a string
        if (data['status'] && !(typeof data['status'] === 'string' || data['status'] instanceof String)) {
            throw new Error("Expected the field `status` to be a primitive type in the JSON string but got " + data['status']);
        }
        // ensure the json data is a string
        if (data['text_source'] && !(typeof data['text_source'] === 'string' || data['text_source'] instanceof String)) {
            throw new Error("Expected the field `text_source` to be a primitive type in the JSON string but got " + data['text_source']);
        }
        // ensure the json data is a string
        if (data['text_type'] && !(typeof data['text_type'] === 'string' || data['text_type'] instanceof String)) {
            throw new Error("Expected the field `text_type` to be a primitive type in the JSON string but got " + data['text_type']);
        }
        // ensure the json data is a string
        if (data['type'] && !(typeof data['type'] === 'string' || data['type'] instanceof String)) {
            throw new Error("Expected the field `type` to be a primitive type in the JSON string but got " + data['type']);
        }

        return true;
    }


}



/**
 * Indicates the track provides Subtitles for the Deaf or Hard-of-hearing (SDH). This parameter is only set tracks where `type` is `text` and `text_type` is `subtitles`.
 * @member {Boolean} closed_captions
 */
Track.prototype['closed_captions'] = undefined;

/**
 * The duration in seconds of the track media. This parameter is not set for `text` type tracks. This field is optional and may not be set. The top level `duration` field of an asset will always be set.
 * @member {Number} duration
 */
Track.prototype['duration'] = undefined;

/**
 * Unique identifier for the Track
 * @member {String} id
 */
Track.prototype['id'] = undefined;

/**
 * The language code value represents [BCP 47](https://tools.ietf.org/html/bcp47) specification compliant value. For example, `en` for English or `en-US` for the US version of English. This parameter is only set for `text` and `audio` track types.
 * @member {String} language_code
 */
Track.prototype['language_code'] = undefined;

/**
 * Only set for the `audio` type track.
 * @member {String} max_channel_layout
 */
Track.prototype['max_channel_layout'] = undefined;

/**
 * The maximum number of audio channels the track supports. Only set for the `audio` type track.
 * @member {Number} max_channels
 */
Track.prototype['max_channels'] = undefined;

/**
 * The maximum frame rate available for the track. Only set for the `video` type track. This field may return `-1` if the frame rate of the input cannot be reliably determined.
 * @member {Number} max_frame_rate
 */
Track.prototype['max_frame_rate'] = undefined;

/**
 * The maximum height in pixels available for the track. Only set for the `video` type track.
 * @member {Number} max_height
 */
Track.prototype['max_height'] = undefined;

/**
 * The maximum width in pixels available for the track. Only set for the `video` type track.
 * @member {Number} max_width
 */
Track.prototype['max_width'] = undefined;

/**
 * The name of the track containing a human-readable description. The HLS manifest will associate a subtitle `text` or `audio` track with this value. For example, the value should be \"English\" for a subtitle text track for the `language_code` value of `en-US`. This parameter is only set for `text` and `audio` track types.
 * @member {String} name
 */
Track.prototype['name'] = undefined;

/**
 * Arbitrary user-supplied metadata set for the track either when creating the asset or track. This parameter is only set for `text` type tracks. Max 255 characters.
 * @member {String} passthrough
 */
Track.prototype['passthrough'] = undefined;

/**
 * The status of the track. This parameter is only set for `text` type tracks.
 * @member {module:model/Track.StatusEnum} status
 */
Track.prototype['status'] = undefined;

/**
 * The source of the text contained in a Track of type `text`. Valid `text_source` values are listed below. * `uploaded`: Tracks uploaded to Mux as caption or subtitle files using the Create Asset Track API. * `embedded`: Tracks extracted from an embedded stream of CEA-608 closed captions. * `generated_vod`: Tracks generated by automatic speech recognition on an on-demand asset. * `generated_live`: Tracks generated by automatic speech recognition on a live stream configured with `generated_subtitles`. If an Asset has both `generated_live` and `generated_live_final` tracks that are `ready`, then only the `generated_live_final` track will be included during playback. * `generated_live_final`: Tracks generated by automatic speech recognition on a live stream using `generated_subtitles`. The accuracy, timing, and formatting of these subtitles is improved compared to the corresponding `generated_live` tracks. However, `generated_live_final` tracks will not be available in `ready` status until the live stream ends. If an Asset has both `generated_live` and `generated_live_final` tracks that are `ready`, then only the `generated_live_final` track will be included during playback. 
 * @member {module:model/Track.TextSourceEnum} text_source
 */
Track.prototype['text_source'] = undefined;

/**
 * This parameter is only set for `text` type tracks.
 * @member {module:model/Track.TextTypeEnum} text_type
 */
Track.prototype['text_type'] = undefined;

/**
 * The type of track
 * @member {module:model/Track.TypeEnum} type
 */
Track.prototype['type'] = undefined;





/**
 * Allowed values for the <code>status</code> property.
 * @enum {String}
 * @readonly
 */
Track['StatusEnum'] = {

    /**
     * value: "preparing"
     * @const
     */
    "preparing": "preparing",

    /**
     * value: "ready"
     * @const
     */
    "ready": "ready",

    /**
     * value: "errored"
     * @const
     */
    "errored": "errored",

    /**
     * value: "deleted"
     * @const
     */
    "deleted": "deleted"
};


/**
 * Allowed values for the <code>text_source</code> property.
 * @enum {String}
 * @readonly
 */
Track['TextSourceEnum'] = {

    /**
     * value: "uploaded"
     * @const
     */
    "uploaded": "uploaded",

    /**
     * value: "embedded"
     * @const
     */
    "embedded": "embedded",

    /**
     * value: "generated_live"
     * @const
     */
    "generated_live": "generated_live",

    /**
     * value: "generated_live_final"
     * @const
     */
    "generated_live_final": "generated_live_final"
};


/**
 * Allowed values for the <code>text_type</code> property.
 * @enum {String}
 * @readonly
 */
Track['TextTypeEnum'] = {

    /**
     * value: "subtitles"
     * @const
     */
    "subtitles": "subtitles"
};


/**
 * Allowed values for the <code>type</code> property.
 * @enum {String}
 * @readonly
 */
Track['TypeEnum'] = {

    /**
     * value: "video"
     * @const
     */
    "video": "video",

    /**
     * value: "audio"
     * @const
     */
    "audio": "audio",

    /**
     * value: "text"
     * @const
     */
    "text": "text"
};



export default Track;

