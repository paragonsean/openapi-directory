/**
 * Mux API
 * Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.
 *
 * The version of the OpenAPI document: v1
 * Contact: devex@mux.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import AssetErrors from './AssetErrors';
import AssetMaster from './AssetMaster';
import AssetNonStandardInputReasons from './AssetNonStandardInputReasons';
import AssetRecordingTimesInner from './AssetRecordingTimesInner';
import AssetStaticRenditions from './AssetStaticRenditions';
import PlaybackID from './PlaybackID';
import Track from './Track';

/**
 * The Asset model module.
 * @module model/Asset
 * @version v1
 */
class Asset {
    /**
     * Constructs a new <code>Asset</code>.
     * @alias module:model/Asset
     */
    constructor() { 
        
        Asset.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
        obj['master_access'] = 'none';
        obj['mp4_support'] = 'none';
        obj['normalize_audio'] = false;
    }

    /**
     * Constructs a <code>Asset</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Asset} obj Optional instance to populate.
     * @return {module:model/Asset} The populated <code>Asset</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Asset();

            if (data.hasOwnProperty('aspect_ratio')) {
                obj['aspect_ratio'] = ApiClient.convertToType(data['aspect_ratio'], 'String');
            }
            if (data.hasOwnProperty('created_at')) {
                obj['created_at'] = ApiClient.convertToType(data['created_at'], 'String');
            }
            if (data.hasOwnProperty('duration')) {
                obj['duration'] = ApiClient.convertToType(data['duration'], 'Number');
            }
            if (data.hasOwnProperty('encoding_tier')) {
                obj['encoding_tier'] = ApiClient.convertToType(data['encoding_tier'], 'String');
            }
            if (data.hasOwnProperty('errors')) {
                obj['errors'] = AssetErrors.constructFromObject(data['errors']);
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('is_live')) {
                obj['is_live'] = ApiClient.convertToType(data['is_live'], 'Boolean');
            }
            if (data.hasOwnProperty('live_stream_id')) {
                obj['live_stream_id'] = ApiClient.convertToType(data['live_stream_id'], 'String');
            }
            if (data.hasOwnProperty('master')) {
                obj['master'] = AssetMaster.constructFromObject(data['master']);
            }
            if (data.hasOwnProperty('master_access')) {
                obj['master_access'] = ApiClient.convertToType(data['master_access'], 'String');
            }
            if (data.hasOwnProperty('max_resolution_tier')) {
                obj['max_resolution_tier'] = ApiClient.convertToType(data['max_resolution_tier'], 'String');
            }
            if (data.hasOwnProperty('max_stored_frame_rate')) {
                obj['max_stored_frame_rate'] = ApiClient.convertToType(data['max_stored_frame_rate'], 'Number');
            }
            if (data.hasOwnProperty('max_stored_resolution')) {
                obj['max_stored_resolution'] = ApiClient.convertToType(data['max_stored_resolution'], 'String');
            }
            if (data.hasOwnProperty('mp4_support')) {
                obj['mp4_support'] = ApiClient.convertToType(data['mp4_support'], 'String');
            }
            if (data.hasOwnProperty('non_standard_input_reasons')) {
                obj['non_standard_input_reasons'] = AssetNonStandardInputReasons.constructFromObject(data['non_standard_input_reasons']);
            }
            if (data.hasOwnProperty('normalize_audio')) {
                obj['normalize_audio'] = ApiClient.convertToType(data['normalize_audio'], 'Boolean');
            }
            if (data.hasOwnProperty('passthrough')) {
                obj['passthrough'] = ApiClient.convertToType(data['passthrough'], 'String');
            }
            if (data.hasOwnProperty('per_title_encode')) {
                obj['per_title_encode'] = ApiClient.convertToType(data['per_title_encode'], 'Boolean');
            }
            if (data.hasOwnProperty('playback_ids')) {
                obj['playback_ids'] = ApiClient.convertToType(data['playback_ids'], [PlaybackID]);
            }
            if (data.hasOwnProperty('recording_times')) {
                obj['recording_times'] = ApiClient.convertToType(data['recording_times'], [AssetRecordingTimesInner]);
            }
            if (data.hasOwnProperty('resolution_tier')) {
                obj['resolution_tier'] = ApiClient.convertToType(data['resolution_tier'], 'String');
            }
            if (data.hasOwnProperty('source_asset_id')) {
                obj['source_asset_id'] = ApiClient.convertToType(data['source_asset_id'], 'String');
            }
            if (data.hasOwnProperty('static_renditions')) {
                obj['static_renditions'] = AssetStaticRenditions.constructFromObject(data['static_renditions']);
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = ApiClient.convertToType(data['status'], 'String');
            }
            if (data.hasOwnProperty('test')) {
                obj['test'] = ApiClient.convertToType(data['test'], 'Boolean');
            }
            if (data.hasOwnProperty('tracks')) {
                obj['tracks'] = ApiClient.convertToType(data['tracks'], [Track]);
            }
            if (data.hasOwnProperty('upload_id')) {
                obj['upload_id'] = ApiClient.convertToType(data['upload_id'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Asset</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Asset</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['aspect_ratio'] && !(typeof data['aspect_ratio'] === 'string' || data['aspect_ratio'] instanceof String)) {
            throw new Error("Expected the field `aspect_ratio` to be a primitive type in the JSON string but got " + data['aspect_ratio']);
        }
        // ensure the json data is a string
        if (data['created_at'] && !(typeof data['created_at'] === 'string' || data['created_at'] instanceof String)) {
            throw new Error("Expected the field `created_at` to be a primitive type in the JSON string but got " + data['created_at']);
        }
        // ensure the json data is a string
        if (data['encoding_tier'] && !(typeof data['encoding_tier'] === 'string' || data['encoding_tier'] instanceof String)) {
            throw new Error("Expected the field `encoding_tier` to be a primitive type in the JSON string but got " + data['encoding_tier']);
        }
        // validate the optional field `errors`
        if (data['errors']) { // data not null
          AssetErrors.validateJSON(data['errors']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['live_stream_id'] && !(typeof data['live_stream_id'] === 'string' || data['live_stream_id'] instanceof String)) {
            throw new Error("Expected the field `live_stream_id` to be a primitive type in the JSON string but got " + data['live_stream_id']);
        }
        // validate the optional field `master`
        if (data['master']) { // data not null
          AssetMaster.validateJSON(data['master']);
        }
        // ensure the json data is a string
        if (data['master_access'] && !(typeof data['master_access'] === 'string' || data['master_access'] instanceof String)) {
            throw new Error("Expected the field `master_access` to be a primitive type in the JSON string but got " + data['master_access']);
        }
        // ensure the json data is a string
        if (data['max_resolution_tier'] && !(typeof data['max_resolution_tier'] === 'string' || data['max_resolution_tier'] instanceof String)) {
            throw new Error("Expected the field `max_resolution_tier` to be a primitive type in the JSON string but got " + data['max_resolution_tier']);
        }
        // ensure the json data is a string
        if (data['max_stored_resolution'] && !(typeof data['max_stored_resolution'] === 'string' || data['max_stored_resolution'] instanceof String)) {
            throw new Error("Expected the field `max_stored_resolution` to be a primitive type in the JSON string but got " + data['max_stored_resolution']);
        }
        // ensure the json data is a string
        if (data['mp4_support'] && !(typeof data['mp4_support'] === 'string' || data['mp4_support'] instanceof String)) {
            throw new Error("Expected the field `mp4_support` to be a primitive type in the JSON string but got " + data['mp4_support']);
        }
        // validate the optional field `non_standard_input_reasons`
        if (data['non_standard_input_reasons']) { // data not null
          AssetNonStandardInputReasons.validateJSON(data['non_standard_input_reasons']);
        }
        // ensure the json data is a string
        if (data['passthrough'] && !(typeof data['passthrough'] === 'string' || data['passthrough'] instanceof String)) {
            throw new Error("Expected the field `passthrough` to be a primitive type in the JSON string but got " + data['passthrough']);
        }
        if (data['playback_ids']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['playback_ids'])) {
                throw new Error("Expected the field `playback_ids` to be an array in the JSON data but got " + data['playback_ids']);
            }
            // validate the optional field `playback_ids` (array)
            for (const item of data['playback_ids']) {
                PlaybackID.validateJSON(item);
            };
        }
        if (data['recording_times']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['recording_times'])) {
                throw new Error("Expected the field `recording_times` to be an array in the JSON data but got " + data['recording_times']);
            }
            // validate the optional field `recording_times` (array)
            for (const item of data['recording_times']) {
                AssetRecordingTimesInner.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['resolution_tier'] && !(typeof data['resolution_tier'] === 'string' || data['resolution_tier'] instanceof String)) {
            throw new Error("Expected the field `resolution_tier` to be a primitive type in the JSON string but got " + data['resolution_tier']);
        }
        // ensure the json data is a string
        if (data['source_asset_id'] && !(typeof data['source_asset_id'] === 'string' || data['source_asset_id'] instanceof String)) {
            throw new Error("Expected the field `source_asset_id` to be a primitive type in the JSON string but got " + data['source_asset_id']);
        }
        // validate the optional field `static_renditions`
        if (data['static_renditions']) { // data not null
          AssetStaticRenditions.validateJSON(data['static_renditions']);
        }
        // ensure the json data is a string
        if (data['status'] && !(typeof data['status'] === 'string' || data['status'] instanceof String)) {
            throw new Error("Expected the field `status` to be a primitive type in the JSON string but got " + data['status']);
        }
        if (data['tracks']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['tracks'])) {
                throw new Error("Expected the field `tracks` to be an array in the JSON data but got " + data['tracks']);
            }
            // validate the optional field `tracks` (array)
            for (const item of data['tracks']) {
                Track.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['upload_id'] && !(typeof data['upload_id'] === 'string' || data['upload_id'] instanceof String)) {
            throw new Error("Expected the field `upload_id` to be a primitive type in the JSON string but got " + data['upload_id']);
        }

        return true;
    }


}



/**
 * The aspect ratio of the asset in the form of `width:height`, for example `16:9`.
 * @member {String} aspect_ratio
 */
Asset.prototype['aspect_ratio'] = undefined;

/**
 * Time the Asset was created, defined as a Unix timestamp (seconds since epoch).
 * @member {String} created_at
 */
Asset.prototype['created_at'] = undefined;

/**
 * The duration of the asset in seconds (max duration for a single asset is 12 hours).
 * @member {Number} duration
 */
Asset.prototype['duration'] = undefined;

/**
 * The encoding tier informs the cost, quality, and available platform features for the asset. By default the `smart` encoding tier is used.
 * @member {module:model/Asset.EncodingTierEnum} encoding_tier
 */
Asset.prototype['encoding_tier'] = undefined;

/**
 * @member {module:model/AssetErrors} errors
 */
Asset.prototype['errors'] = undefined;

/**
 * Unique identifier for the Asset. Max 255 characters.
 * @member {String} id
 */
Asset.prototype['id'] = undefined;

/**
 * Indicates whether the live stream that created this asset is currently `active` and not in `idle` state. This is an optional parameter added when the asset is created from a live stream.
 * @member {Boolean} is_live
 */
Asset.prototype['is_live'] = undefined;

/**
 * Unique identifier for the live stream. This is an optional parameter added when the asset is created from a live stream.
 * @member {String} live_stream_id
 */
Asset.prototype['live_stream_id'] = undefined;

/**
 * @member {module:model/AssetMaster} master
 */
Asset.prototype['master'] = undefined;

/**
 * @member {module:model/Asset.MasterAccessEnum} master_access
 * @default 'none'
 */
Asset.prototype['master_access'] = 'none';

/**
 * Max resolution tier can be used to control the maximum `resolution_tier` your asset is encoded, stored, and streamed at. If not set, this defaults to `1080p`.
 * @member {module:model/Asset.MaxResolutionTierEnum} max_resolution_tier
 */
Asset.prototype['max_resolution_tier'] = undefined;

/**
 * The maximum frame rate that has been stored for the asset. The asset may be delivered at lower frame rates depending on the device and bandwidth, however it cannot be delivered at a higher value than is stored. This field may return -1 if the frame rate of the input cannot be reliably determined.
 * @member {Number} max_stored_frame_rate
 */
Asset.prototype['max_stored_frame_rate'] = undefined;

/**
 * This field is deprecated. Please use `resolution_tier` instead. The maximum resolution that has been stored for the asset. The asset may be delivered at lower resolutions depending on the device and bandwidth, however it cannot be delivered at a higher value than is stored.
 * @member {module:model/Asset.MaxStoredResolutionEnum} max_stored_resolution
 */
Asset.prototype['max_stored_resolution'] = undefined;

/**
 * @member {module:model/Asset.Mp4SupportEnum} mp4_support
 * @default 'none'
 */
Asset.prototype['mp4_support'] = 'none';

/**
 * @member {module:model/AssetNonStandardInputReasons} non_standard_input_reasons
 */
Asset.prototype['non_standard_input_reasons'] = undefined;

/**
 * Normalize the audio track loudness level. This parameter is only applicable to on-demand (not live) assets.
 * @member {Boolean} normalize_audio
 * @default false
 */
Asset.prototype['normalize_audio'] = false;

/**
 * Arbitrary user-supplied metadata set for the asset. Max 255 characters.
 * @member {String} passthrough
 */
Asset.prototype['passthrough'] = undefined;

/**
 * @member {Boolean} per_title_encode
 */
Asset.prototype['per_title_encode'] = undefined;

/**
 * An array of Playback ID objects. Use these to create HLS playback URLs. See [Play your videos](https://docs.mux.com/guides/video/play-your-videos) for more details.
 * @member {Array.<module:model/PlaybackID>} playback_ids
 */
Asset.prototype['playback_ids'] = undefined;

/**
 * An array of individual live stream recording sessions. A recording session is created on each encoder connection during the live stream. Additionally any time slate media is inserted during brief interruptions in the live stream media or times when the live streaming software disconnects, a recording session representing the slate media will be added with a \"slate\" type.
 * @member {Array.<module:model/AssetRecordingTimesInner>} recording_times
 */
Asset.prototype['recording_times'] = undefined;

/**
 * The resolution tier that the asset was ingested at, affecting billing for ingest & storage. This field also represents the highest resolution tier that the content can be delivered at, however the actual resolution may be lower depending on the device, bandwidth, and exact resolution of the uploaded asset.
 * @member {module:model/Asset.ResolutionTierEnum} resolution_tier
 */
Asset.prototype['resolution_tier'] = undefined;

/**
 * Asset Identifier of the video used as the source for creating the clip.
 * @member {String} source_asset_id
 */
Asset.prototype['source_asset_id'] = undefined;

/**
 * @member {module:model/AssetStaticRenditions} static_renditions
 */
Asset.prototype['static_renditions'] = undefined;

/**
 * The status of the asset.
 * @member {module:model/Asset.StatusEnum} status
 */
Asset.prototype['status'] = undefined;

/**
 * True means this live stream is a test asset. A test asset can help evaluate the Mux Video APIs without incurring any cost. There is no limit on number of test assets created. Test assets are watermarked with the Mux logo, limited to 10 seconds, and deleted after 24 hrs.
 * @member {Boolean} test
 */
Asset.prototype['test'] = undefined;

/**
 * The individual media tracks that make up an asset.
 * @member {Array.<module:model/Track>} tracks
 */
Asset.prototype['tracks'] = undefined;

/**
 * Unique identifier for the Direct Upload. This is an optional parameter added when the asset is created from a direct upload.
 * @member {String} upload_id
 */
Asset.prototype['upload_id'] = undefined;





/**
 * Allowed values for the <code>encoding_tier</code> property.
 * @enum {String}
 * @readonly
 */
Asset['EncodingTierEnum'] = {

    /**
     * value: "smart"
     * @const
     */
    "smart": "smart",

    /**
     * value: "baseline"
     * @const
     */
    "baseline": "baseline"
};


/**
 * Allowed values for the <code>master_access</code> property.
 * @enum {String}
 * @readonly
 */
Asset['MasterAccessEnum'] = {

    /**
     * value: "temporary"
     * @const
     */
    "temporary": "temporary",

    /**
     * value: "none"
     * @const
     */
    "none": "none"
};


/**
 * Allowed values for the <code>max_resolution_tier</code> property.
 * @enum {String}
 * @readonly
 */
Asset['MaxResolutionTierEnum'] = {

    /**
     * value: "1080p"
     * @const
     */
    "1080p": "1080p",

    /**
     * value: "1440p"
     * @const
     */
    "1440p": "1440p",

    /**
     * value: "2160p"
     * @const
     */
    "2160p": "2160p"
};


/**
 * Allowed values for the <code>max_stored_resolution</code> property.
 * @enum {String}
 * @readonly
 */
Asset['MaxStoredResolutionEnum'] = {

    /**
     * value: "Audio only"
     * @const
     */
    "Audio only": "Audio only",

    /**
     * value: "SD"
     * @const
     */
    "SD": "SD",

    /**
     * value: "HD"
     * @const
     */
    "HD": "HD",

    /**
     * value: "FHD"
     * @const
     */
    "FHD": "FHD",

    /**
     * value: "UHD"
     * @const
     */
    "UHD": "UHD"
};


/**
 * Allowed values for the <code>mp4_support</code> property.
 * @enum {String}
 * @readonly
 */
Asset['Mp4SupportEnum'] = {

    /**
     * value: "standard"
     * @const
     */
    "standard": "standard",

    /**
     * value: "none"
     * @const
     */
    "none": "none"
};


/**
 * Allowed values for the <code>resolution_tier</code> property.
 * @enum {String}
 * @readonly
 */
Asset['ResolutionTierEnum'] = {

    /**
     * value: "audio-only"
     * @const
     */
    "audio-only": "audio-only",

    /**
     * value: "720p"
     * @const
     */
    "720p": "720p",

    /**
     * value: "1080p"
     * @const
     */
    "1080p": "1080p",

    /**
     * value: "1440p"
     * @const
     */
    "1440p": "1440p",

    /**
     * value: "2160p"
     * @const
     */
    "2160p": "2160p"
};


/**
 * Allowed values for the <code>status</code> property.
 * @enum {String}
 * @readonly
 */
Asset['StatusEnum'] = {

    /**
     * value: "preparing"
     * @const
     */
    "preparing": "preparing",

    /**
     * value: "ready"
     * @const
     */
    "ready": "ready",

    /**
     * value: "errored"
     * @const
     */
    "errored": "errored"
};



export default Asset;

