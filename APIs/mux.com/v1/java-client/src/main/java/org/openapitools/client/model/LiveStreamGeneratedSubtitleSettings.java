/*
 * Mux API
 * Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.
 *
 * The version of the OpenAPI document: v1
 * Contact: devex@mux.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * LiveStreamGeneratedSubtitleSettings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:54:45.471488-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LiveStreamGeneratedSubtitleSettings {
  /**
   * The language to generate subtitles in.
   */
  @JsonAdapter(LanguageCodeEnum.Adapter.class)
  public enum LanguageCodeEnum {
    EN("en"),
    
    EN_US("en-US");

    private String value;

    LanguageCodeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LanguageCodeEnum fromValue(String value) {
      for (LanguageCodeEnum b : LanguageCodeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LanguageCodeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LanguageCodeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LanguageCodeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LanguageCodeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LanguageCodeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LANGUAGE_CODE = "language_code";
  @SerializedName(SERIALIZED_NAME_LANGUAGE_CODE)
  private LanguageCodeEnum languageCode = LanguageCodeEnum.EN;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PASSTHROUGH = "passthrough";
  @SerializedName(SERIALIZED_NAME_PASSTHROUGH)
  private String passthrough;

  public static final String SERIALIZED_NAME_TRANSCRIPTION_VOCABULARY_IDS = "transcription_vocabulary_ids";
  @SerializedName(SERIALIZED_NAME_TRANSCRIPTION_VOCABULARY_IDS)
  private List<String> transcriptionVocabularyIds = new ArrayList<>();

  public LiveStreamGeneratedSubtitleSettings() {
  }

  public LiveStreamGeneratedSubtitleSettings languageCode(LanguageCodeEnum languageCode) {
    this.languageCode = languageCode;
    return this;
  }

  /**
   * The language to generate subtitles in.
   * @return languageCode
   */
  @javax.annotation.Nullable
  public LanguageCodeEnum getLanguageCode() {
    return languageCode;
  }

  public void setLanguageCode(LanguageCodeEnum languageCode) {
    this.languageCode = languageCode;
  }


  public LiveStreamGeneratedSubtitleSettings name(String name) {
    this.name = name;
    return this;
  }

  /**
   * A name for this live stream subtitle track.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public LiveStreamGeneratedSubtitleSettings passthrough(String passthrough) {
    this.passthrough = passthrough;
    return this;
  }

  /**
   * Arbitrary metadata set for the live stream subtitle track. Max 255 characters.
   * @return passthrough
   */
  @javax.annotation.Nullable
  public String getPassthrough() {
    return passthrough;
  }

  public void setPassthrough(String passthrough) {
    this.passthrough = passthrough;
  }


  public LiveStreamGeneratedSubtitleSettings transcriptionVocabularyIds(List<String> transcriptionVocabularyIds) {
    this.transcriptionVocabularyIds = transcriptionVocabularyIds;
    return this;
  }

  public LiveStreamGeneratedSubtitleSettings addTranscriptionVocabularyIdsItem(String transcriptionVocabularyIdsItem) {
    if (this.transcriptionVocabularyIds == null) {
      this.transcriptionVocabularyIds = new ArrayList<>();
    }
    this.transcriptionVocabularyIds.add(transcriptionVocabularyIdsItem);
    return this;
  }

  /**
   * Unique identifiers for existing Transcription Vocabularies to use while generating subtitles for the live stream. If the Transcription Vocabularies provided collectively have more than 1000 phrases, only the first 1000 phrases will be included.
   * @return transcriptionVocabularyIds
   */
  @javax.annotation.Nullable
  public List<String> getTranscriptionVocabularyIds() {
    return transcriptionVocabularyIds;
  }

  public void setTranscriptionVocabularyIds(List<String> transcriptionVocabularyIds) {
    this.transcriptionVocabularyIds = transcriptionVocabularyIds;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LiveStreamGeneratedSubtitleSettings liveStreamGeneratedSubtitleSettings = (LiveStreamGeneratedSubtitleSettings) o;
    return Objects.equals(this.languageCode, liveStreamGeneratedSubtitleSettings.languageCode) &&
        Objects.equals(this.name, liveStreamGeneratedSubtitleSettings.name) &&
        Objects.equals(this.passthrough, liveStreamGeneratedSubtitleSettings.passthrough) &&
        Objects.equals(this.transcriptionVocabularyIds, liveStreamGeneratedSubtitleSettings.transcriptionVocabularyIds);
  }

  @Override
  public int hashCode() {
    return Objects.hash(languageCode, name, passthrough, transcriptionVocabularyIds);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LiveStreamGeneratedSubtitleSettings {\n");
    sb.append("    languageCode: ").append(toIndentedString(languageCode)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    passthrough: ").append(toIndentedString(passthrough)).append("\n");
    sb.append("    transcriptionVocabularyIds: ").append(toIndentedString(transcriptionVocabularyIds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("language_code");
    openapiFields.add("name");
    openapiFields.add("passthrough");
    openapiFields.add("transcription_vocabulary_ids");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LiveStreamGeneratedSubtitleSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LiveStreamGeneratedSubtitleSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LiveStreamGeneratedSubtitleSettings is not found in the empty JSON string", LiveStreamGeneratedSubtitleSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LiveStreamGeneratedSubtitleSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LiveStreamGeneratedSubtitleSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("language_code") != null && !jsonObj.get("language_code").isJsonNull()) && !jsonObj.get("language_code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `language_code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("language_code").toString()));
      }
      // validate the optional field `language_code`
      if (jsonObj.get("language_code") != null && !jsonObj.get("language_code").isJsonNull()) {
        LanguageCodeEnum.validateJsonElement(jsonObj.get("language_code"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("passthrough") != null && !jsonObj.get("passthrough").isJsonNull()) && !jsonObj.get("passthrough").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `passthrough` to be a primitive type in the JSON string but got `%s`", jsonObj.get("passthrough").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("transcription_vocabulary_ids") != null && !jsonObj.get("transcription_vocabulary_ids").isJsonNull() && !jsonObj.get("transcription_vocabulary_ids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `transcription_vocabulary_ids` to be an array in the JSON string but got `%s`", jsonObj.get("transcription_vocabulary_ids").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LiveStreamGeneratedSubtitleSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LiveStreamGeneratedSubtitleSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LiveStreamGeneratedSubtitleSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LiveStreamGeneratedSubtitleSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<LiveStreamGeneratedSubtitleSettings>() {
           @Override
           public void write(JsonWriter out, LiveStreamGeneratedSubtitleSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LiveStreamGeneratedSubtitleSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LiveStreamGeneratedSubtitleSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LiveStreamGeneratedSubtitleSettings
   * @throws IOException if the JSON string is invalid with respect to LiveStreamGeneratedSubtitleSettings
   */
  public static LiveStreamGeneratedSubtitleSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LiveStreamGeneratedSubtitleSettings.class);
  }

  /**
   * Convert an instance of LiveStreamGeneratedSubtitleSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

