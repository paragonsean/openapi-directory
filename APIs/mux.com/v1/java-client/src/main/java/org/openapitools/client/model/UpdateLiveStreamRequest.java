/*
 * Mux API
 * Mux is how developers build online video. This API encompasses both Mux Video and Mux Data functionality to help you build your video-related projects better and faster than ever before.
 *
 * The version of the OpenAPI document: v1
 * Contact: devex@mux.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateLiveStreamRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:54:45.471488-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateLiveStreamRequest {
  /**
   * Latency is the time from when the streamer transmits a frame of video to when you see it in the player. Set this as an alternative to setting low latency or reduced latency flags. The Low Latency value is a beta feature. Read more here: https://mux.com/blog/introducing-low-latency-live-streaming/
   */
  @JsonAdapter(LatencyModeEnum.Adapter.class)
  public enum LatencyModeEnum {
    LOW("low"),
    
    REDUCED("reduced"),
    
    STANDARD("standard");

    private String value;

    LatencyModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LatencyModeEnum fromValue(String value) {
      for (LatencyModeEnum b : LatencyModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LatencyModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LatencyModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LatencyModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LatencyModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LatencyModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LATENCY_MODE = "latency_mode";
  @SerializedName(SERIALIZED_NAME_LATENCY_MODE)
  private LatencyModeEnum latencyMode;

  public static final String SERIALIZED_NAME_MAX_CONTINUOUS_DURATION = "max_continuous_duration";
  @SerializedName(SERIALIZED_NAME_MAX_CONTINUOUS_DURATION)
  private Integer maxContinuousDuration = 43200;

  public static final String SERIALIZED_NAME_PASSTHROUGH = "passthrough";
  @SerializedName(SERIALIZED_NAME_PASSTHROUGH)
  private String passthrough;

  public static final String SERIALIZED_NAME_RECONNECT_SLATE_URL = "reconnect_slate_url";
  @SerializedName(SERIALIZED_NAME_RECONNECT_SLATE_URL)
  private String reconnectSlateUrl;

  public static final String SERIALIZED_NAME_RECONNECT_WINDOW = "reconnect_window";
  @SerializedName(SERIALIZED_NAME_RECONNECT_WINDOW)
  private Float reconnectWindow = 60f;

  public static final String SERIALIZED_NAME_USE_SLATE_FOR_STANDARD_LATENCY = "use_slate_for_standard_latency";
  @SerializedName(SERIALIZED_NAME_USE_SLATE_FOR_STANDARD_LATENCY)
  private Boolean useSlateForStandardLatency = false;

  public UpdateLiveStreamRequest() {
  }

  public UpdateLiveStreamRequest latencyMode(LatencyModeEnum latencyMode) {
    this.latencyMode = latencyMode;
    return this;
  }

  /**
   * Latency is the time from when the streamer transmits a frame of video to when you see it in the player. Set this as an alternative to setting low latency or reduced latency flags. The Low Latency value is a beta feature. Read more here: https://mux.com/blog/introducing-low-latency-live-streaming/
   * @return latencyMode
   */
  @javax.annotation.Nullable
  public LatencyModeEnum getLatencyMode() {
    return latencyMode;
  }

  public void setLatencyMode(LatencyModeEnum latencyMode) {
    this.latencyMode = latencyMode;
  }


  public UpdateLiveStreamRequest maxContinuousDuration(Integer maxContinuousDuration) {
    this.maxContinuousDuration = maxContinuousDuration;
    return this;
  }

  /**
   * The time in seconds a live stream may be continuously active before being disconnected. Defaults to 12 hours.
   * minimum: 60
   * maximum: 43200
   * @return maxContinuousDuration
   */
  @javax.annotation.Nullable
  public Integer getMaxContinuousDuration() {
    return maxContinuousDuration;
  }

  public void setMaxContinuousDuration(Integer maxContinuousDuration) {
    this.maxContinuousDuration = maxContinuousDuration;
  }


  public UpdateLiveStreamRequest passthrough(String passthrough) {
    this.passthrough = passthrough;
    return this;
  }

  /**
   * Arbitrary user-supplied metadata set for the live stream. Max 255 characters. In order to clear this value, the field should be included with an empty-string value.
   * @return passthrough
   */
  @javax.annotation.Nullable
  public String getPassthrough() {
    return passthrough;
  }

  public void setPassthrough(String passthrough) {
    this.passthrough = passthrough;
  }


  public UpdateLiveStreamRequest reconnectSlateUrl(String reconnectSlateUrl) {
    this.reconnectSlateUrl = reconnectSlateUrl;
    return this;
  }

  /**
   * The URL of the image file that Mux should download and use as slate media during interruptions of the live stream media. This file will be downloaded each time a new recorded asset is created from the live stream. Set this to a blank string to clear the value so that the default slate media will be used.
   * @return reconnectSlateUrl
   */
  @javax.annotation.Nullable
  public String getReconnectSlateUrl() {
    return reconnectSlateUrl;
  }

  public void setReconnectSlateUrl(String reconnectSlateUrl) {
    this.reconnectSlateUrl = reconnectSlateUrl;
  }


  public UpdateLiveStreamRequest reconnectWindow(Float reconnectWindow) {
    this.reconnectWindow = reconnectWindow;
    return this;
  }

  /**
   * When live streaming software disconnects from Mux, either intentionally or due to a drop in the network, the Reconnect Window is the time in seconds that Mux should wait for the streaming software to reconnect before considering the live stream finished and completing the recorded asset.  If not specified directly, Standard Latency streams have a Reconnect Window of 60 seconds; Reduced and Low Latency streams have a default of 0 seconds, or no Reconnect Window. For that reason, we suggest specifying a value other than zero for Reduced and Low Latency streams.  Reduced and Low Latency streams with a Reconnect Window greater than zero will insert slate media into the recorded asset while waiting for the streaming software to reconnect or when there are brief interruptions in the live stream media. When using a Reconnect Window setting higher than 60 seconds with a Standard Latency stream, we highly recommend enabling slate with the &#x60;use_slate_for_standard_latency&#x60; option. 
   * minimum: 0
   * maximum: 1800
   * @return reconnectWindow
   */
  @javax.annotation.Nullable
  public Float getReconnectWindow() {
    return reconnectWindow;
  }

  public void setReconnectWindow(Float reconnectWindow) {
    this.reconnectWindow = reconnectWindow;
  }


  public UpdateLiveStreamRequest useSlateForStandardLatency(Boolean useSlateForStandardLatency) {
    this.useSlateForStandardLatency = useSlateForStandardLatency;
    return this;
  }

  /**
   * By default, Standard Latency live streams do not have slate media inserted while waiting for live streaming software to reconnect to Mux. Setting this to true enables slate insertion on a Standard Latency stream.
   * @return useSlateForStandardLatency
   */
  @javax.annotation.Nullable
  public Boolean getUseSlateForStandardLatency() {
    return useSlateForStandardLatency;
  }

  public void setUseSlateForStandardLatency(Boolean useSlateForStandardLatency) {
    this.useSlateForStandardLatency = useSlateForStandardLatency;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateLiveStreamRequest updateLiveStreamRequest = (UpdateLiveStreamRequest) o;
    return Objects.equals(this.latencyMode, updateLiveStreamRequest.latencyMode) &&
        Objects.equals(this.maxContinuousDuration, updateLiveStreamRequest.maxContinuousDuration) &&
        Objects.equals(this.passthrough, updateLiveStreamRequest.passthrough) &&
        Objects.equals(this.reconnectSlateUrl, updateLiveStreamRequest.reconnectSlateUrl) &&
        Objects.equals(this.reconnectWindow, updateLiveStreamRequest.reconnectWindow) &&
        Objects.equals(this.useSlateForStandardLatency, updateLiveStreamRequest.useSlateForStandardLatency);
  }

  @Override
  public int hashCode() {
    return Objects.hash(latencyMode, maxContinuousDuration, passthrough, reconnectSlateUrl, reconnectWindow, useSlateForStandardLatency);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateLiveStreamRequest {\n");
    sb.append("    latencyMode: ").append(toIndentedString(latencyMode)).append("\n");
    sb.append("    maxContinuousDuration: ").append(toIndentedString(maxContinuousDuration)).append("\n");
    sb.append("    passthrough: ").append(toIndentedString(passthrough)).append("\n");
    sb.append("    reconnectSlateUrl: ").append(toIndentedString(reconnectSlateUrl)).append("\n");
    sb.append("    reconnectWindow: ").append(toIndentedString(reconnectWindow)).append("\n");
    sb.append("    useSlateForStandardLatency: ").append(toIndentedString(useSlateForStandardLatency)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("latency_mode");
    openapiFields.add("max_continuous_duration");
    openapiFields.add("passthrough");
    openapiFields.add("reconnect_slate_url");
    openapiFields.add("reconnect_window");
    openapiFields.add("use_slate_for_standard_latency");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateLiveStreamRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateLiveStreamRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateLiveStreamRequest is not found in the empty JSON string", UpdateLiveStreamRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateLiveStreamRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateLiveStreamRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("latency_mode") != null && !jsonObj.get("latency_mode").isJsonNull()) && !jsonObj.get("latency_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `latency_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("latency_mode").toString()));
      }
      // validate the optional field `latency_mode`
      if (jsonObj.get("latency_mode") != null && !jsonObj.get("latency_mode").isJsonNull()) {
        LatencyModeEnum.validateJsonElement(jsonObj.get("latency_mode"));
      }
      if ((jsonObj.get("passthrough") != null && !jsonObj.get("passthrough").isJsonNull()) && !jsonObj.get("passthrough").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `passthrough` to be a primitive type in the JSON string but got `%s`", jsonObj.get("passthrough").toString()));
      }
      if ((jsonObj.get("reconnect_slate_url") != null && !jsonObj.get("reconnect_slate_url").isJsonNull()) && !jsonObj.get("reconnect_slate_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reconnect_slate_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reconnect_slate_url").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateLiveStreamRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateLiveStreamRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateLiveStreamRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateLiveStreamRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateLiveStreamRequest>() {
           @Override
           public void write(JsonWriter out, UpdateLiveStreamRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateLiveStreamRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateLiveStreamRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateLiveStreamRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateLiveStreamRequest
   */
  public static UpdateLiveStreamRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateLiveStreamRequest.class);
  }

  /**
   * Convert an instance of UpdateLiveStreamRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

