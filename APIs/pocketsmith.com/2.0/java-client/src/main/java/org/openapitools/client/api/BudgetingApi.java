/*
 * PocketSmith
 * The PocketSmith API
 *
 * The version of the OpenAPI document: 2.0
 * Contact: api@pocketsmith.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.BudgetAnalysisPackage;
import org.openapitools.client.model.Error;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BudgetingApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public BudgetingApi() {
        this(Configuration.getDefaultApiClient());
    }

    public BudgetingApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for usersIdBudgetGet
     * @param id The unique identifier of the account. (required)
     * @param rollUp Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdBudgetGetCall(Integer id, Boolean rollUp, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/budget"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (rollUp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("roll_up", rollUp));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "developerKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIdBudgetGetValidateBeforeCall(Integer id, Boolean rollUp, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling usersIdBudgetGet(Async)");
        }

        return usersIdBudgetGetCall(id, rollUp, _callback);

    }

    /**
     * List budget for user
     * Lists the user&#39;s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
     * @param id The unique identifier of the account. (required)
     * @param rollUp Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @return List&lt;BudgetAnalysisPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public List<BudgetAnalysisPackage> usersIdBudgetGet(Integer id, Boolean rollUp) throws ApiException {
        ApiResponse<List<BudgetAnalysisPackage>> localVarResp = usersIdBudgetGetWithHttpInfo(id, rollUp);
        return localVarResp.getData();
    }

    /**
     * List budget for user
     * Lists the user&#39;s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
     * @param id The unique identifier of the account. (required)
     * @param rollUp Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @return ApiResponse&lt;List&lt;BudgetAnalysisPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<BudgetAnalysisPackage>> usersIdBudgetGetWithHttpInfo(Integer id, Boolean rollUp) throws ApiException {
        okhttp3.Call localVarCall = usersIdBudgetGetValidateBeforeCall(id, rollUp, null);
        Type localVarReturnType = new TypeToken<List<BudgetAnalysisPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List budget for user (asynchronously)
     * Lists the user&#39;s budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
     * @param id The unique identifier of the account. (required)
     * @param rollUp Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdBudgetGetAsync(Integer id, Boolean rollUp, final ApiCallback<List<BudgetAnalysisPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIdBudgetGetValidateBeforeCall(id, rollUp, _callback);
        Type localVarReturnType = new TypeToken<List<BudgetAnalysisPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIdBudgetSummaryGet
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdBudgetSummaryGetCall(Integer id, String period, Integer interval, String startDate, String endDate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/budget_summary"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_date", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_date", endDate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "developerKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIdBudgetSummaryGetValidateBeforeCall(Integer id, String period, Integer interval, String startDate, String endDate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling usersIdBudgetSummaryGet(Async)");
        }

        // verify the required parameter 'period' is set
        if (period == null) {
            throw new ApiException("Missing the required parameter 'period' when calling usersIdBudgetSummaryGet(Async)");
        }

        // verify the required parameter 'interval' is set
        if (interval == null) {
            throw new ApiException("Missing the required parameter 'interval' when calling usersIdBudgetSummaryGet(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling usersIdBudgetSummaryGet(Async)");
        }

        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling usersIdBudgetSummaryGet(Async)");
        }

        return usersIdBudgetSummaryGetCall(id, period, interval, startDate, endDate, _callback);

    }

    /**
     * Get budget summary for user
     * Get the user&#39;s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @return List&lt;BudgetAnalysisPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public List<BudgetAnalysisPackage> usersIdBudgetSummaryGet(Integer id, String period, Integer interval, String startDate, String endDate) throws ApiException {
        ApiResponse<List<BudgetAnalysisPackage>> localVarResp = usersIdBudgetSummaryGetWithHttpInfo(id, period, interval, startDate, endDate);
        return localVarResp.getData();
    }

    /**
     * Get budget summary for user
     * Get the user&#39;s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @return ApiResponse&lt;List&lt;BudgetAnalysisPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<BudgetAnalysisPackage>> usersIdBudgetSummaryGetWithHttpInfo(Integer id, String period, Integer interval, String startDate, String endDate) throws ApiException {
        okhttp3.Call localVarCall = usersIdBudgetSummaryGetValidateBeforeCall(id, period, interval, startDate, endDate, null);
        Type localVarReturnType = new TypeToken<List<BudgetAnalysisPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get budget summary for user (asynchronously)
     * Get the user&#39;s budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdBudgetSummaryGetAsync(Integer id, String period, Integer interval, String startDate, String endDate, final ApiCallback<List<BudgetAnalysisPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIdBudgetSummaryGetValidateBeforeCall(id, period, interval, startDate, endDate, _callback);
        Type localVarReturnType = new TypeToken<List<BudgetAnalysisPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIdForecastCacheDelete
     * @param id The unique identifier of the user. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdForecastCacheDeleteCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/forecast_cache"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "developerKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIdForecastCacheDeleteValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling usersIdForecastCacheDelete(Async)");
        }

        return usersIdForecastCacheDeleteCall(id, _callback);

    }

    /**
     * Delete forecast cache for user
     * Delete the user&#39;s cached forecast by recalculating the forecast.
     * @param id The unique identifier of the user. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public void usersIdForecastCacheDelete(Integer id) throws ApiException {
        usersIdForecastCacheDeleteWithHttpInfo(id);
    }

    /**
     * Delete forecast cache for user
     * Delete the user&#39;s cached forecast by recalculating the forecast.
     * @param id The unique identifier of the user. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> usersIdForecastCacheDeleteWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = usersIdForecastCacheDeleteValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete forecast cache for user (asynchronously)
     * Delete the user&#39;s cached forecast by recalculating the forecast.
     * @param id The unique identifier of the user. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdForecastCacheDeleteAsync(Integer id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIdForecastCacheDeleteValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for usersIdTrendAnalysisGet
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param categories A comma-separated list of category IDs to analyse. (required)
     * @param scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdTrendAnalysisGetCall(Integer id, String period, Integer interval, String startDate, String endDate, String categories, String scenarios, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/trend_analysis"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_date", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_date", endDate));
        }

        if (categories != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("categories", categories));
        }

        if (scenarios != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scenarios", scenarios));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "developerKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersIdTrendAnalysisGetValidateBeforeCall(Integer id, String period, Integer interval, String startDate, String endDate, String categories, String scenarios, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling usersIdTrendAnalysisGet(Async)");
        }

        // verify the required parameter 'period' is set
        if (period == null) {
            throw new ApiException("Missing the required parameter 'period' when calling usersIdTrendAnalysisGet(Async)");
        }

        // verify the required parameter 'interval' is set
        if (interval == null) {
            throw new ApiException("Missing the required parameter 'interval' when calling usersIdTrendAnalysisGet(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling usersIdTrendAnalysisGet(Async)");
        }

        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling usersIdTrendAnalysisGet(Async)");
        }

        // verify the required parameter 'categories' is set
        if (categories == null) {
            throw new ApiException("Missing the required parameter 'categories' when calling usersIdTrendAnalysisGet(Async)");
        }

        // verify the required parameter 'scenarios' is set
        if (scenarios == null) {
            throw new ApiException("Missing the required parameter 'scenarios' when calling usersIdTrendAnalysisGet(Async)");
        }

        return usersIdTrendAnalysisGetCall(id, period, interval, startDate, endDate, categories, scenarios, _callback);

    }

    /**
     * Get trend analysis for user
     * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param categories A comma-separated list of category IDs to analyse. (required)
     * @param scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @return List&lt;BudgetAnalysisPackage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public List<BudgetAnalysisPackage> usersIdTrendAnalysisGet(Integer id, String period, Integer interval, String startDate, String endDate, String categories, String scenarios) throws ApiException {
        ApiResponse<List<BudgetAnalysisPackage>> localVarResp = usersIdTrendAnalysisGetWithHttpInfo(id, period, interval, startDate, endDate, categories, scenarios);
        return localVarResp.getData();
    }

    /**
     * Get trend analysis for user
     * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param categories A comma-separated list of category IDs to analyse. (required)
     * @param scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @return ApiResponse&lt;List&lt;BudgetAnalysisPackage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<BudgetAnalysisPackage>> usersIdTrendAnalysisGetWithHttpInfo(Integer id, String period, Integer interval, String startDate, String endDate, String categories, String scenarios) throws ApiException {
        okhttp3.Call localVarCall = usersIdTrendAnalysisGetValidateBeforeCall(id, period, interval, startDate, endDate, categories, scenarios, null);
        Type localVarReturnType = new TypeToken<List<BudgetAnalysisPackage>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get trend analysis for user (asynchronously)
     * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
     * @param id The unique identifier of the user. (required)
     * @param period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param categories A comma-separated list of category IDs to analyse. (required)
     * @param scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Not Allowed </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call usersIdTrendAnalysisGetAsync(Integer id, String period, Integer interval, String startDate, String endDate, String categories, String scenarios, final ApiCallback<List<BudgetAnalysisPackage>> _callback) throws ApiException {

        okhttp3.Call localVarCall = usersIdTrendAnalysisGetValidateBeforeCall(id, period, interval, startDate, endDate, categories, scenarios, _callback);
        Type localVarReturnType = new TypeToken<List<BudgetAnalysisPackage>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
