/**
 * PocketSmith
 * The PocketSmith API
 *
 * The version of the OpenAPI document: 2.0
 * Contact: api@pocketsmith.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import BudgetAnalysisPackage from '../model/BudgetAnalysisPackage';
import Error from '../model/Error';

/**
* Budgeting service.
* @module api/BudgetingApi
* @version 2.0
*/
export default class BudgetingApi {

    /**
    * Constructs a new BudgetingApi. 
    * @alias module:api/BudgetingApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the usersIdBudgetGet operation.
     * @callback module:api/BudgetingApi~usersIdBudgetGetCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/BudgetAnalysisPackage>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List budget for user
     * Lists the user's budget, consisting of one or more budget analysis packages, one per category. Akin to the list on the Budget page in PocketSmith.
     * @param {Number} id The unique identifier of the account.
     * @param {Object} opts Optional parameters
     * @param {Boolean} [rollUp] Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent.
     * @param {module:api/BudgetingApi~usersIdBudgetGetCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/BudgetAnalysisPackage>}
     */
    usersIdBudgetGet(id, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling usersIdBudgetGet");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'roll_up': opts['rollUp']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['developerKey'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [BudgetAnalysisPackage];
      return this.apiClient.callApi(
        '/users/{id}/budget', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the usersIdBudgetSummaryGet operation.
     * @callback module:api/BudgetingApi~usersIdBudgetSummaryGetCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/BudgetAnalysisPackage>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get budget summary for user
     * Get the user's budget summary, containing an expense and income analysis for all categories (excluding transfer categories) for the given period and date range. Akin to the overall budget shown on the Budget page in PocketSmith.
     * @param {Number} id The unique identifier of the user.
     * @param {module:model/String} period The period to analyse in, one of `weeks`, `months` or `years`. Also supported is `event`, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it's highly unlikely that event period analysis will be possible.
     * @param {Number} interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
     * @param {String} startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {String} endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {module:api/BudgetingApi~usersIdBudgetSummaryGetCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/BudgetAnalysisPackage>}
     */
    usersIdBudgetSummaryGet(id, period, interval, startDate, endDate, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling usersIdBudgetSummaryGet");
      }
      // verify the required parameter 'period' is set
      if (period === undefined || period === null) {
        throw new Error("Missing the required parameter 'period' when calling usersIdBudgetSummaryGet");
      }
      // verify the required parameter 'interval' is set
      if (interval === undefined || interval === null) {
        throw new Error("Missing the required parameter 'interval' when calling usersIdBudgetSummaryGet");
      }
      // verify the required parameter 'startDate' is set
      if (startDate === undefined || startDate === null) {
        throw new Error("Missing the required parameter 'startDate' when calling usersIdBudgetSummaryGet");
      }
      // verify the required parameter 'endDate' is set
      if (endDate === undefined || endDate === null) {
        throw new Error("Missing the required parameter 'endDate' when calling usersIdBudgetSummaryGet");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'period': period,
        'interval': interval,
        'start_date': startDate,
        'end_date': endDate
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['developerKey'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [BudgetAnalysisPackage];
      return this.apiClient.callApi(
        '/users/{id}/budget_summary', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the usersIdForecastCacheDelete operation.
     * @callback module:api/BudgetingApi~usersIdForecastCacheDeleteCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete forecast cache for user
     * Delete the user's cached forecast by recalculating the forecast.
     * @param {Number} id The unique identifier of the user.
     * @param {module:api/BudgetingApi~usersIdForecastCacheDeleteCallback} callback The callback function, accepting three arguments: error, data, response
     */
    usersIdForecastCacheDelete(id, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling usersIdForecastCacheDelete");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['developerKey'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{id}/forecast_cache', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the usersIdTrendAnalysisGet operation.
     * @callback module:api/BudgetingApi~usersIdTrendAnalysisGetCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/BudgetAnalysisPackage>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get trend analysis for user
     * Get an income and/or expense budget analysis for the given date range and period across any number of categories and scenarios. Akin to the Trends page in PocketSmith.
     * @param {Number} id The unique identifier of the user.
     * @param {module:model/String} period The period to analyse in, one of `weeks`, `months` or `years`. Also supported is `event`, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it's highly unlikely that event period analysis will be possible.
     * @param {Number} interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly.
     * @param {String} startDate The date to start analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {String} endDate The date to stop analysing the budget from. This will be bumped out to make full periods as necessary.
     * @param {String} categories A comma-separated list of category IDs to analyse.
     * @param {String} scenarios A comma-separated list of scenario IDs to analyse. You're likely going to want to include all a user's scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included.
     * @param {module:api/BudgetingApi~usersIdTrendAnalysisGetCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/BudgetAnalysisPackage>}
     */
    usersIdTrendAnalysisGet(id, period, interval, startDate, endDate, categories, scenarios, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling usersIdTrendAnalysisGet");
      }
      // verify the required parameter 'period' is set
      if (period === undefined || period === null) {
        throw new Error("Missing the required parameter 'period' when calling usersIdTrendAnalysisGet");
      }
      // verify the required parameter 'interval' is set
      if (interval === undefined || interval === null) {
        throw new Error("Missing the required parameter 'interval' when calling usersIdTrendAnalysisGet");
      }
      // verify the required parameter 'startDate' is set
      if (startDate === undefined || startDate === null) {
        throw new Error("Missing the required parameter 'startDate' when calling usersIdTrendAnalysisGet");
      }
      // verify the required parameter 'endDate' is set
      if (endDate === undefined || endDate === null) {
        throw new Error("Missing the required parameter 'endDate' when calling usersIdTrendAnalysisGet");
      }
      // verify the required parameter 'categories' is set
      if (categories === undefined || categories === null) {
        throw new Error("Missing the required parameter 'categories' when calling usersIdTrendAnalysisGet");
      }
      // verify the required parameter 'scenarios' is set
      if (scenarios === undefined || scenarios === null) {
        throw new Error("Missing the required parameter 'scenarios' when calling usersIdTrendAnalysisGet");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
        'period': period,
        'interval': interval,
        'start_date': startDate,
        'end_date': endDate,
        'categories': categories,
        'scenarios': scenarios
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['developerKey'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [BudgetAnalysisPackage];
      return this.apiClient.callApi(
        '/users/{id}/trend_analysis', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
