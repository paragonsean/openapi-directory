/**
 * ElevenLabs API Documentation
 * This is the documentation for the ElevenLabs API. You can use this API to use our service programmatically, this is done by using your xi-api-key. <br/> You can view your xi-api-key using the 'Profile' tab on https://beta.elevenlabs.io. Our API is experimental so all endpoints are subject to change.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVerificationAttemptResponseModel.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVerificationAttemptResponseModel::OAIVerificationAttemptResponseModel(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVerificationAttemptResponseModel::OAIVerificationAttemptResponseModel() {
    this->initializeModel();
}

OAIVerificationAttemptResponseModel::~OAIVerificationAttemptResponseModel() {}

void OAIVerificationAttemptResponseModel::initializeModel() {

    m_accepted_isSet = false;
    m_accepted_isValid = false;

    m_date_unix_isSet = false;
    m_date_unix_isValid = false;

    m_levenshtein_distance_isSet = false;
    m_levenshtein_distance_isValid = false;

    m_recording_isSet = false;
    m_recording_isValid = false;

    m_similarity_isSet = false;
    m_similarity_isValid = false;

    m_text_isSet = false;
    m_text_isValid = false;
}

void OAIVerificationAttemptResponseModel::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVerificationAttemptResponseModel::fromJsonObject(QJsonObject json) {

    m_accepted_isValid = ::OpenAPI::fromJsonValue(m_accepted, json[QString("accepted")]);
    m_accepted_isSet = !json[QString("accepted")].isNull() && m_accepted_isValid;

    m_date_unix_isValid = ::OpenAPI::fromJsonValue(m_date_unix, json[QString("date_unix")]);
    m_date_unix_isSet = !json[QString("date_unix")].isNull() && m_date_unix_isValid;

    m_levenshtein_distance_isValid = ::OpenAPI::fromJsonValue(m_levenshtein_distance, json[QString("levenshtein_distance")]);
    m_levenshtein_distance_isSet = !json[QString("levenshtein_distance")].isNull() && m_levenshtein_distance_isValid;

    m_recording_isValid = ::OpenAPI::fromJsonValue(m_recording, json[QString("recording")]);
    m_recording_isSet = !json[QString("recording")].isNull() && m_recording_isValid;

    m_similarity_isValid = ::OpenAPI::fromJsonValue(m_similarity, json[QString("similarity")]);
    m_similarity_isSet = !json[QString("similarity")].isNull() && m_similarity_isValid;

    m_text_isValid = ::OpenAPI::fromJsonValue(m_text, json[QString("text")]);
    m_text_isSet = !json[QString("text")].isNull() && m_text_isValid;
}

QString OAIVerificationAttemptResponseModel::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVerificationAttemptResponseModel::asJsonObject() const {
    QJsonObject obj;
    if (m_accepted_isSet) {
        obj.insert(QString("accepted"), ::OpenAPI::toJsonValue(m_accepted));
    }
    if (m_date_unix_isSet) {
        obj.insert(QString("date_unix"), ::OpenAPI::toJsonValue(m_date_unix));
    }
    if (m_levenshtein_distance_isSet) {
        obj.insert(QString("levenshtein_distance"), ::OpenAPI::toJsonValue(m_levenshtein_distance));
    }
    if (m_recording.isSet()) {
        obj.insert(QString("recording"), ::OpenAPI::toJsonValue(m_recording));
    }
    if (m_similarity_isSet) {
        obj.insert(QString("similarity"), ::OpenAPI::toJsonValue(m_similarity));
    }
    if (m_text_isSet) {
        obj.insert(QString("text"), ::OpenAPI::toJsonValue(m_text));
    }
    return obj;
}

bool OAIVerificationAttemptResponseModel::isAccepted() const {
    return m_accepted;
}
void OAIVerificationAttemptResponseModel::setAccepted(const bool &accepted) {
    m_accepted = accepted;
    m_accepted_isSet = true;
}

bool OAIVerificationAttemptResponseModel::is_accepted_Set() const{
    return m_accepted_isSet;
}

bool OAIVerificationAttemptResponseModel::is_accepted_Valid() const{
    return m_accepted_isValid;
}

qint32 OAIVerificationAttemptResponseModel::getDateUnix() const {
    return m_date_unix;
}
void OAIVerificationAttemptResponseModel::setDateUnix(const qint32 &date_unix) {
    m_date_unix = date_unix;
    m_date_unix_isSet = true;
}

bool OAIVerificationAttemptResponseModel::is_date_unix_Set() const{
    return m_date_unix_isSet;
}

bool OAIVerificationAttemptResponseModel::is_date_unix_Valid() const{
    return m_date_unix_isValid;
}

double OAIVerificationAttemptResponseModel::getLevenshteinDistance() const {
    return m_levenshtein_distance;
}
void OAIVerificationAttemptResponseModel::setLevenshteinDistance(const double &levenshtein_distance) {
    m_levenshtein_distance = levenshtein_distance;
    m_levenshtein_distance_isSet = true;
}

bool OAIVerificationAttemptResponseModel::is_levenshtein_distance_Set() const{
    return m_levenshtein_distance_isSet;
}

bool OAIVerificationAttemptResponseModel::is_levenshtein_distance_Valid() const{
    return m_levenshtein_distance_isValid;
}

OAIRecordingResponseModel OAIVerificationAttemptResponseModel::getRecording() const {
    return m_recording;
}
void OAIVerificationAttemptResponseModel::setRecording(const OAIRecordingResponseModel &recording) {
    m_recording = recording;
    m_recording_isSet = true;
}

bool OAIVerificationAttemptResponseModel::is_recording_Set() const{
    return m_recording_isSet;
}

bool OAIVerificationAttemptResponseModel::is_recording_Valid() const{
    return m_recording_isValid;
}

double OAIVerificationAttemptResponseModel::getSimilarity() const {
    return m_similarity;
}
void OAIVerificationAttemptResponseModel::setSimilarity(const double &similarity) {
    m_similarity = similarity;
    m_similarity_isSet = true;
}

bool OAIVerificationAttemptResponseModel::is_similarity_Set() const{
    return m_similarity_isSet;
}

bool OAIVerificationAttemptResponseModel::is_similarity_Valid() const{
    return m_similarity_isValid;
}

QString OAIVerificationAttemptResponseModel::getText() const {
    return m_text;
}
void OAIVerificationAttemptResponseModel::setText(const QString &text) {
    m_text = text;
    m_text_isSet = true;
}

bool OAIVerificationAttemptResponseModel::is_text_Set() const{
    return m_text_isSet;
}

bool OAIVerificationAttemptResponseModel::is_text_Valid() const{
    return m_text_isValid;
}

bool OAIVerificationAttemptResponseModel::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accepted_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_unix_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_levenshtein_distance_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_recording.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_similarity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_text_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVerificationAttemptResponseModel::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_accepted_isValid && m_date_unix_isValid && m_levenshtein_distance_isValid && m_recording_isValid && m_similarity_isValid && m_text_isValid && true;
}

} // namespace OpenAPI
