/**
 * Nordigen Account Information Services API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0 (v2)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import CreditorAccountWrite from './CreditorAccountWrite';
import InstructedAmount from './InstructedAmount';
import PaymentProductEnum from './PaymentProductEnum';
import PaymentStatusEnum from './PaymentStatusEnum';
import PaymentTypeEnum from './PaymentTypeEnum';
import PeriodicPayment from './PeriodicPayment';

/**
 * The PaymentWrite model module.
 * @module model/PaymentWrite
 * @version 2.0 (v2)
 */
class PaymentWrite {
    /**
     * Constructs a new <code>PaymentWrite</code>.
     * PaymentWriteSerializer.
     * @alias module:model/PaymentWrite
     * @param instructedAmount {module:model/InstructedAmount} Instructed amount
     * @param redirect {String} Redirect URL to your application after payment is done
     */
    constructor(instructedAmount, redirect) { 
        
        PaymentWrite.initialize(this, instructedAmount, redirect);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, instructedAmount, redirect) { 
        obj['description'] = 'GOCARDLESS';
        obj['instructed_amount'] = instructedAmount;
        obj['link'] = 'https://ob.nordigen.com/pis/start/ec728ca1-e25f-4eab-8fa6-66b94439722f/{$INSTITUTION_ID}';
        obj['redirect'] = redirect;
        obj['submit_payment'] = false;
    }

    /**
     * Constructs a <code>PaymentWrite</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/PaymentWrite} obj Optional instance to populate.
     * @return {module:model/PaymentWrite} The populated <code>PaymentWrite</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new PaymentWrite();

            if (data.hasOwnProperty('creditor_account')) {
                obj['creditor_account'] = ApiClient.convertToType(data['creditor_account'], 'String');
            }
            if (data.hasOwnProperty('creditor_object')) {
                obj['creditor_object'] = ApiClient.convertToType(data['creditor_object'], CreditorAccountWrite);
            }
            if (data.hasOwnProperty('custom_payment_id')) {
                obj['custom_payment_id'] = ApiClient.convertToType(data['custom_payment_id'], 'String');
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('instructed_amount')) {
                obj['instructed_amount'] = ApiClient.convertToType(data['instructed_amount'], InstructedAmount);
            }
            if (data.hasOwnProperty('link')) {
                obj['link'] = ApiClient.convertToType(data['link'], 'String');
            }
            if (data.hasOwnProperty('payment_id')) {
                obj['payment_id'] = ApiClient.convertToType(data['payment_id'], 'String');
            }
            if (data.hasOwnProperty('payment_product')) {
                obj['payment_product'] = ApiClient.convertToType(data['payment_product'], PaymentProductEnum);
            }
            if (data.hasOwnProperty('payment_status')) {
                obj['payment_status'] = ApiClient.convertToType(data['payment_status'], PaymentStatusEnum);
            }
            if (data.hasOwnProperty('payment_type')) {
                obj['payment_type'] = ApiClient.convertToType(data['payment_type'], PaymentTypeEnum);
            }
            if (data.hasOwnProperty('periodic_payment')) {
                obj['periodic_payment'] = PeriodicPayment.constructFromObject(data['periodic_payment']);
            }
            if (data.hasOwnProperty('redirect')) {
                obj['redirect'] = ApiClient.convertToType(data['redirect'], 'String');
            }
            if (data.hasOwnProperty('requested_execution_date')) {
                obj['requested_execution_date'] = ApiClient.convertToType(data['requested_execution_date'], 'Date');
            }
            if (data.hasOwnProperty('submit_payment')) {
                obj['submit_payment'] = ApiClient.convertToType(data['submit_payment'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>PaymentWrite</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>PaymentWrite</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of PaymentWrite.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['creditor_account'] && !(typeof data['creditor_account'] === 'string' || data['creditor_account'] instanceof String)) {
            throw new Error("Expected the field `creditor_account` to be a primitive type in the JSON string but got " + data['creditor_account']);
        }
        // validate the optional field `creditor_object`
        if (data['creditor_object']) { // data not null
          CreditorAccountWrite.validateJSON(data['creditor_object']);
        }
        // ensure the json data is a string
        if (data['custom_payment_id'] && !(typeof data['custom_payment_id'] === 'string' || data['custom_payment_id'] instanceof String)) {
            throw new Error("Expected the field `custom_payment_id` to be a primitive type in the JSON string but got " + data['custom_payment_id']);
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // validate the optional field `instructed_amount`
        if (data['instructed_amount']) { // data not null
          InstructedAmount.validateJSON(data['instructed_amount']);
        }
        // ensure the json data is a string
        if (data['link'] && !(typeof data['link'] === 'string' || data['link'] instanceof String)) {
            throw new Error("Expected the field `link` to be a primitive type in the JSON string but got " + data['link']);
        }
        // ensure the json data is a string
        if (data['payment_id'] && !(typeof data['payment_id'] === 'string' || data['payment_id'] instanceof String)) {
            throw new Error("Expected the field `payment_id` to be a primitive type in the JSON string but got " + data['payment_id']);
        }
        // validate the optional field `periodic_payment`
        if (data['periodic_payment']) { // data not null
          PeriodicPayment.validateJSON(data['periodic_payment']);
        }
        // ensure the json data is a string
        if (data['redirect'] && !(typeof data['redirect'] === 'string' || data['redirect'] instanceof String)) {
            throw new Error("Expected the field `redirect` to be a primitive type in the JSON string but got " + data['redirect']);
        }

        return true;
    }


}

PaymentWrite.RequiredProperties = ["instructed_amount", "redirect"];

/**
 * Registered creditor account
 * @member {String} creditor_account
 */
PaymentWrite.prototype['creditor_account'] = undefined;

/**
 * Creditor account
 * @member {module:model/CreditorAccountWrite} creditor_object
 */
PaymentWrite.prototype['creditor_object'] = undefined;

/**
 * Payment Custom Payment ID
 * @member {String} custom_payment_id
 */
PaymentWrite.prototype['custom_payment_id'] = undefined;

/**
 * Payment description
 * @member {String} description
 * @default 'GOCARDLESS'
 */
PaymentWrite.prototype['description'] = 'GOCARDLESS';

/**
 * Instructed amount
 * @member {module:model/InstructedAmount} instructed_amount
 */
PaymentWrite.prototype['instructed_amount'] = undefined;

/**
 * Link to initiate authorization with Institution
 * @member {String} link
 * @default 'https://ob.nordigen.com/pis/start/ec728ca1-e25f-4eab-8fa6-66b94439722f/{$INSTITUTION_ID}'
 */
PaymentWrite.prototype['link'] = 'https://ob.nordigen.com/pis/start/ec728ca1-e25f-4eab-8fa6-66b94439722f/{$INSTITUTION_ID}';

/**
 * Payment ID
 * @member {String} payment_id
 */
PaymentWrite.prototype['payment_id'] = undefined;

/**
 * Payment product  * `T2P` - target-2-payments * `SCT` - sepa-credit-transfers * `ISCT` - instant-sepa-credit-transfer * `CBCT` - cross-border-credit-transfers * `BACS` - Back Payment Scheme * `CHAPS` - CHAPS Payment Scheme * `FPS` - Faster Payment Scheme * `SWIFT` - Swift Payment Service * `BT` - Balance Transfer * `MT` - Money Transfer
 * @member {module:model/PaymentProductEnum} payment_product
 */
PaymentWrite.prototype['payment_product'] = undefined;

/**
 * Payment end to end identification  * `INIT` - Initiated. Payment has been initiated. * `ERRE` - ExecutionError. We experienced error on payment execution. * `ERRS` - StatusError. We experienced error retrieving payment status. Try again. * `ACCC` - AcceptedSettlementCompleted. Settlement on the creditor's account has been completed * `ACCP` - AcceptedCustomerProfile. Preceding check of technical validation was successful. Customer profile check was successful * `ACSC` - AcceptedSettlementCompleted. Settlement on the debtor’s account has been completed * `ACSP` - AcceptedSettlementInProcess. All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution * `ACTC` - AcceptedTechnicalValidation. Authentication and syntactical and semantical validation are successful * `ACWC` - AcceptedWithChange. Instruction is accepted but a change will be made, such as date or remittance not sent * `ACWP` - AcceptedWithoutPosting. Payment instruction included in the credit transfer is accepted without being posted to the creditor customer’s account * `RCVD` - Received. Payment initiation has been received by the receiving agent * `PDNG` - Pending. Payment initiation or individual transaction included in the payment initiation is pending. Further checks and status update will be performed * `RJCT` - Rejected. Payment initiation or individual transaction included in the payment initiation has been rejected. * `CANC` - Cancelled. Payment initiation has been cancelled before execution * `ACFC` - AcceptedFundsChecked. Pre-ceeding check of technical validation and customer profile was successful and an automatic funds check was positive * `PATC` - PartiallyAcceptedTechnicalCorrect. The payment initiation needs multiple authentications, where some but not yet all have been performed * `PART` - PartiallyAccepted. A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status
 * @member {module:model/PaymentStatusEnum} payment_status
 */
PaymentWrite.prototype['payment_status'] = undefined;

/**
 * Payment Type  * `single-payment` - payment * `bulk-payment` - bulk-payments * `periodic-payment` - periodic-payments
 * @member {module:model/PaymentTypeEnum} payment_type
 */
PaymentWrite.prototype['payment_type'] = undefined;

/**
 * @member {module:model/PeriodicPayment} periodic_payment
 */
PaymentWrite.prototype['periodic_payment'] = undefined;

/**
 * Redirect URL to your application after payment is done
 * @member {String} redirect
 */
PaymentWrite.prototype['redirect'] = undefined;

/**
 * Payment Execution date (for periodic payments)
 * @member {Date} requested_execution_date
 */
PaymentWrite.prototype['requested_execution_date'] = undefined;

/**
 * Indicates whether payment should be submitted separately
 * @member {Boolean} submit_payment
 * @default false
 */
PaymentWrite.prototype['submit_payment'] = false;






export default PaymentWrite;

