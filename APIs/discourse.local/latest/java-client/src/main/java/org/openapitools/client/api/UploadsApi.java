/*
 * Discourse API Documentation
 * This page contains the documentation on how to use Discourse through API calls.  > Note: For any endpoints not listed you can follow the [reverse engineer the Discourse API](https://meta.discourse.org/t/-/20576) guide to figure out how to use an API endpoint.  ### Request Content-Type  The Content-Type for POST and PUT requests can be set to `application/x-www-form-urlencoded`, `multipart/form-data`, or `application/json`.  ### Endpoint Names and Response Content-Type  Most API endpoints provide the same content as their HTML counterparts. For example the URL `/categories` serves a list of categories, the `/categories.json` API provides the same information in JSON format.  Instead of sending API requests to `/categories.json` you may also send them to `/categories` and add an `Accept: application/json` header to the request to get the JSON response. Sending requests with the `Accept` header is necessary if you want to use URLs for related endpoints returned by the API, such as pagination URLs. These URLs are returned without the `.json` prefix so you need to add the header in order to get the correct response format.  ### Authentication  Some endpoints do not require any authentication, pretty much anything else will require you to be authenticated.  To become authenticated you will need to create an API Key from the admin panel.  Once you have your API Key you can pass it in along with your API Username as an HTTP header like this:  ``` curl -X GET \"http://127.0.0.1:3000/admin/users/list/active.json\" \\ -H \"Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19\" \\ -H \"Api-Username: system\" ```  and this is how POST requests will look:  ``` curl -X POST \"http://127.0.0.1:3000/categories\" \\ -H \"Content-Type: multipart/form-data;\" \\ -H \"Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19\" \\ -H \"Api-Username: system\" \\ -F \"name=89853c20-4409-e91a-a8ea-f6cdff96aaaa\" \\ -F \"color=49d9e9\" \\ -F \"text_color=f0fcfd\" ```  ### Boolean values  If an endpoint accepts a boolean be sure to specify it as a lowercase `true` or `false` value unless noted otherwise. 
 *
 * The version of the OpenAPI document: latest
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AbortMultipartRequest;
import org.openapitools.client.model.BatchPresignMultipartParts200Response;
import org.openapitools.client.model.BatchPresignMultipartPartsRequest;
import org.openapitools.client.model.CompleteExternalUploadRequest;
import org.openapitools.client.model.CompleteMultipartRequest;
import org.openapitools.client.model.CreateMultipartUpload200Response;
import org.openapitools.client.model.CreateMultipartUploadRequest;
import org.openapitools.client.model.CreateUpload200Response;
import org.openapitools.client.model.DeleteGroup200Response;
import org.openapitools.client.model.GeneratePresignedPut200Response;
import org.openapitools.client.model.GeneratePresignedPutRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UploadsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public UploadsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public UploadsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for abortMultipart
     * @param abortMultipartRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call abortMultipartCall(AbortMultipartRequest abortMultipartRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = abortMultipartRequest;

        // create path and map variables
        String localVarPath = "/uploads/abort-multipart.json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call abortMultipartValidateBeforeCall(AbortMultipartRequest abortMultipartRequest, final ApiCallback _callback) throws ApiException {
        return abortMultipartCall(abortMultipartRequest, _callback);

    }

    /**
     * Abort multipart upload
     * This endpoint aborts the multipart upload initiated with /create-multipart. This should be used when cancelling the upload. It does not matter if parts were already uploaded into the external storage provider.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param abortMultipartRequest  (optional)
     * @return DeleteGroup200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public DeleteGroup200Response abortMultipart(AbortMultipartRequest abortMultipartRequest) throws ApiException {
        ApiResponse<DeleteGroup200Response> localVarResp = abortMultipartWithHttpInfo(abortMultipartRequest);
        return localVarResp.getData();
    }

    /**
     * Abort multipart upload
     * This endpoint aborts the multipart upload initiated with /create-multipart. This should be used when cancelling the upload. It does not matter if parts were already uploaded into the external storage provider.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param abortMultipartRequest  (optional)
     * @return ApiResponse&lt;DeleteGroup200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DeleteGroup200Response> abortMultipartWithHttpInfo(AbortMultipartRequest abortMultipartRequest) throws ApiException {
        okhttp3.Call localVarCall = abortMultipartValidateBeforeCall(abortMultipartRequest, null);
        Type localVarReturnType = new TypeToken<DeleteGroup200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Abort multipart upload (asynchronously)
     * This endpoint aborts the multipart upload initiated with /create-multipart. This should be used when cancelling the upload. It does not matter if parts were already uploaded into the external storage provider.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param abortMultipartRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call abortMultipartAsync(AbortMultipartRequest abortMultipartRequest, final ApiCallback<DeleteGroup200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = abortMultipartValidateBeforeCall(abortMultipartRequest, _callback);
        Type localVarReturnType = new TypeToken<DeleteGroup200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for batchPresignMultipartParts
     * @param batchPresignMultipartPartsRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call batchPresignMultipartPartsCall(BatchPresignMultipartPartsRequest batchPresignMultipartPartsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = batchPresignMultipartPartsRequest;

        // create path and map variables
        String localVarPath = "/uploads/batch-presign-multipart-parts.json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call batchPresignMultipartPartsValidateBeforeCall(BatchPresignMultipartPartsRequest batchPresignMultipartPartsRequest, final ApiCallback _callback) throws ApiException {
        return batchPresignMultipartPartsCall(batchPresignMultipartPartsRequest, _callback);

    }

    /**
     * Generates batches of presigned URLs for multipart parts
     * Multipart uploads are uploaded in chunks or parts to individual presigned URLs, similar to the one generated by /generate-presigned-put. The part numbers provided must be between 1 and 10000. The total number of parts will depend on the chunk size in bytes that you intend to use to upload each chunk. For example a 12MB file may have 2 5MB chunks and a final 2MB chunk, for part numbers 1, 2, and 3.  This endpoint will return a presigned URL for each part number provided, which you can then use to send PUT requests for the binary chunk corresponding to that part. When the part is uploaded, the provider should return an ETag for the part, and this should be stored along with the part number, because this is needed to complete the multipart upload.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param batchPresignMultipartPartsRequest  (optional)
     * @return BatchPresignMultipartParts200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public BatchPresignMultipartParts200Response batchPresignMultipartParts(BatchPresignMultipartPartsRequest batchPresignMultipartPartsRequest) throws ApiException {
        ApiResponse<BatchPresignMultipartParts200Response> localVarResp = batchPresignMultipartPartsWithHttpInfo(batchPresignMultipartPartsRequest);
        return localVarResp.getData();
    }

    /**
     * Generates batches of presigned URLs for multipart parts
     * Multipart uploads are uploaded in chunks or parts to individual presigned URLs, similar to the one generated by /generate-presigned-put. The part numbers provided must be between 1 and 10000. The total number of parts will depend on the chunk size in bytes that you intend to use to upload each chunk. For example a 12MB file may have 2 5MB chunks and a final 2MB chunk, for part numbers 1, 2, and 3.  This endpoint will return a presigned URL for each part number provided, which you can then use to send PUT requests for the binary chunk corresponding to that part. When the part is uploaded, the provider should return an ETag for the part, and this should be stored along with the part number, because this is needed to complete the multipart upload.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param batchPresignMultipartPartsRequest  (optional)
     * @return ApiResponse&lt;BatchPresignMultipartParts200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BatchPresignMultipartParts200Response> batchPresignMultipartPartsWithHttpInfo(BatchPresignMultipartPartsRequest batchPresignMultipartPartsRequest) throws ApiException {
        okhttp3.Call localVarCall = batchPresignMultipartPartsValidateBeforeCall(batchPresignMultipartPartsRequest, null);
        Type localVarReturnType = new TypeToken<BatchPresignMultipartParts200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Generates batches of presigned URLs for multipart parts (asynchronously)
     * Multipart uploads are uploaded in chunks or parts to individual presigned URLs, similar to the one generated by /generate-presigned-put. The part numbers provided must be between 1 and 10000. The total number of parts will depend on the chunk size in bytes that you intend to use to upload each chunk. For example a 12MB file may have 2 5MB chunks and a final 2MB chunk, for part numbers 1, 2, and 3.  This endpoint will return a presigned URL for each part number provided, which you can then use to send PUT requests for the binary chunk corresponding to that part. When the part is uploaded, the provider should return an ETag for the part, and this should be stored along with the part number, because this is needed to complete the multipart upload.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param batchPresignMultipartPartsRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call batchPresignMultipartPartsAsync(BatchPresignMultipartPartsRequest batchPresignMultipartPartsRequest, final ApiCallback<BatchPresignMultipartParts200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = batchPresignMultipartPartsValidateBeforeCall(batchPresignMultipartPartsRequest, _callback);
        Type localVarReturnType = new TypeToken<BatchPresignMultipartParts200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for completeExternalUpload
     * @param completeExternalUploadRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call completeExternalUploadCall(CompleteExternalUploadRequest completeExternalUploadRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = completeExternalUploadRequest;

        // create path and map variables
        String localVarPath = "/uploads/complete-external-upload.json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call completeExternalUploadValidateBeforeCall(CompleteExternalUploadRequest completeExternalUploadRequest, final ApiCallback _callback) throws ApiException {
        return completeExternalUploadCall(completeExternalUploadRequest, _callback);

    }

    /**
     * Completes a direct external upload
     * Completes an external upload initialized with /get-presigned-put. The file will be moved from its temporary location in external storage to a final destination in the S3 bucket. An Upload record will also be created in the database in most cases.  If a sha1-checksum was provided in the initial request it will also be compared with the uploaded file in storage to make sure the same file was uploaded. The file size will be compared for the same reason.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param completeExternalUploadRequest  (optional)
     * @return CreateUpload200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public CreateUpload200Response completeExternalUpload(CompleteExternalUploadRequest completeExternalUploadRequest) throws ApiException {
        ApiResponse<CreateUpload200Response> localVarResp = completeExternalUploadWithHttpInfo(completeExternalUploadRequest);
        return localVarResp.getData();
    }

    /**
     * Completes a direct external upload
     * Completes an external upload initialized with /get-presigned-put. The file will be moved from its temporary location in external storage to a final destination in the S3 bucket. An Upload record will also be created in the database in most cases.  If a sha1-checksum was provided in the initial request it will also be compared with the uploaded file in storage to make sure the same file was uploaded. The file size will be compared for the same reason.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param completeExternalUploadRequest  (optional)
     * @return ApiResponse&lt;CreateUpload200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateUpload200Response> completeExternalUploadWithHttpInfo(CompleteExternalUploadRequest completeExternalUploadRequest) throws ApiException {
        okhttp3.Call localVarCall = completeExternalUploadValidateBeforeCall(completeExternalUploadRequest, null);
        Type localVarReturnType = new TypeToken<CreateUpload200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Completes a direct external upload (asynchronously)
     * Completes an external upload initialized with /get-presigned-put. The file will be moved from its temporary location in external storage to a final destination in the S3 bucket. An Upload record will also be created in the database in most cases.  If a sha1-checksum was provided in the initial request it will also be compared with the uploaded file in storage to make sure the same file was uploaded. The file size will be compared for the same reason.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param completeExternalUploadRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call completeExternalUploadAsync(CompleteExternalUploadRequest completeExternalUploadRequest, final ApiCallback<CreateUpload200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = completeExternalUploadValidateBeforeCall(completeExternalUploadRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateUpload200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for completeMultipart
     * @param completeMultipartRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call completeMultipartCall(CompleteMultipartRequest completeMultipartRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = completeMultipartRequest;

        // create path and map variables
        String localVarPath = "/uploads/complete-multipart.json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call completeMultipartValidateBeforeCall(CompleteMultipartRequest completeMultipartRequest, final ApiCallback _callback) throws ApiException {
        return completeMultipartCall(completeMultipartRequest, _callback);

    }

    /**
     * Complete multipart upload
     * Completes the multipart upload in the external store, and copies the file from its temporary location to its final location in the store. All of the parts must have been uploaded to the external storage provider. An Upload record will be completed in most cases once the file is copied to its final location.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param completeMultipartRequest  (optional)
     * @return CreateUpload200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public CreateUpload200Response completeMultipart(CompleteMultipartRequest completeMultipartRequest) throws ApiException {
        ApiResponse<CreateUpload200Response> localVarResp = completeMultipartWithHttpInfo(completeMultipartRequest);
        return localVarResp.getData();
    }

    /**
     * Complete multipart upload
     * Completes the multipart upload in the external store, and copies the file from its temporary location to its final location in the store. All of the parts must have been uploaded to the external storage provider. An Upload record will be completed in most cases once the file is copied to its final location.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param completeMultipartRequest  (optional)
     * @return ApiResponse&lt;CreateUpload200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateUpload200Response> completeMultipartWithHttpInfo(CompleteMultipartRequest completeMultipartRequest) throws ApiException {
        okhttp3.Call localVarCall = completeMultipartValidateBeforeCall(completeMultipartRequest, null);
        Type localVarReturnType = new TypeToken<CreateUpload200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Complete multipart upload (asynchronously)
     * Completes the multipart upload in the external store, and copies the file from its temporary location to its final location in the store. All of the parts must have been uploaded to the external storage provider. An Upload record will be completed in most cases once the file is copied to its final location.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param completeMultipartRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call completeMultipartAsync(CompleteMultipartRequest completeMultipartRequest, final ApiCallback<CreateUpload200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = completeMultipartValidateBeforeCall(completeMultipartRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateUpload200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createMultipartUpload
     * @param createMultipartUploadRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createMultipartUploadCall(CreateMultipartUploadRequest createMultipartUploadRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createMultipartUploadRequest;

        // create path and map variables
        String localVarPath = "/uploads/create-multipart.json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createMultipartUploadValidateBeforeCall(CreateMultipartUploadRequest createMultipartUploadRequest, final ApiCallback _callback) throws ApiException {
        return createMultipartUploadCall(createMultipartUploadRequest, _callback);

    }

    /**
     * Creates a multipart external upload
     * Creates a multipart upload in the external storage provider, storing a temporary reference to the external upload similar to /get-presigned-put.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param createMultipartUploadRequest  (optional)
     * @return CreateMultipartUpload200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public CreateMultipartUpload200Response createMultipartUpload(CreateMultipartUploadRequest createMultipartUploadRequest) throws ApiException {
        ApiResponse<CreateMultipartUpload200Response> localVarResp = createMultipartUploadWithHttpInfo(createMultipartUploadRequest);
        return localVarResp.getData();
    }

    /**
     * Creates a multipart external upload
     * Creates a multipart upload in the external storage provider, storing a temporary reference to the external upload similar to /get-presigned-put.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param createMultipartUploadRequest  (optional)
     * @return ApiResponse&lt;CreateMultipartUpload200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateMultipartUpload200Response> createMultipartUploadWithHttpInfo(CreateMultipartUploadRequest createMultipartUploadRequest) throws ApiException {
        okhttp3.Call localVarCall = createMultipartUploadValidateBeforeCall(createMultipartUploadRequest, null);
        Type localVarReturnType = new TypeToken<CreateMultipartUpload200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates a multipart external upload (asynchronously)
     * Creates a multipart upload in the external storage provider, storing a temporary reference to the external upload similar to /get-presigned-put.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param createMultipartUploadRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createMultipartUploadAsync(CreateMultipartUploadRequest createMultipartUploadRequest, final ApiCallback<CreateMultipartUpload200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = createMultipartUploadValidateBeforeCall(createMultipartUploadRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateMultipartUpload200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createUpload
     * @param type  (required)
     * @param _file  (optional)
     * @param synchronous Use this flag to return an id and url (optional)
     * @param userId required if uploading an avatar (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> file uploaded </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createUploadCall(String type, Object _file, Boolean synchronous, Integer userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/uploads.json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        if (synchronous != null) {
            localVarFormParams.put("synchronous", synchronous);
        }

        if (type != null) {
            localVarFormParams.put("type", type);
        }

        if (userId != null) {
            localVarFormParams.put("user_id", userId);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createUploadValidateBeforeCall(String type, Object _file, Boolean synchronous, Integer userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'type' is set
        if (type == null) {
            throw new ApiException("Missing the required parameter 'type' when calling createUpload(Async)");
        }

        return createUploadCall(type, _file, synchronous, userId, _callback);

    }

    /**
     * Creates an upload
     * 
     * @param type  (required)
     * @param _file  (optional)
     * @param synchronous Use this flag to return an id and url (optional)
     * @param userId required if uploading an avatar (optional)
     * @return CreateUpload200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> file uploaded </td><td>  -  </td></tr>
     </table>
     */
    public CreateUpload200Response createUpload(String type, Object _file, Boolean synchronous, Integer userId) throws ApiException {
        ApiResponse<CreateUpload200Response> localVarResp = createUploadWithHttpInfo(type, _file, synchronous, userId);
        return localVarResp.getData();
    }

    /**
     * Creates an upload
     * 
     * @param type  (required)
     * @param _file  (optional)
     * @param synchronous Use this flag to return an id and url (optional)
     * @param userId required if uploading an avatar (optional)
     * @return ApiResponse&lt;CreateUpload200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> file uploaded </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateUpload200Response> createUploadWithHttpInfo(String type, Object _file, Boolean synchronous, Integer userId) throws ApiException {
        okhttp3.Call localVarCall = createUploadValidateBeforeCall(type, _file, synchronous, userId, null);
        Type localVarReturnType = new TypeToken<CreateUpload200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates an upload (asynchronously)
     * 
     * @param type  (required)
     * @param _file  (optional)
     * @param synchronous Use this flag to return an id and url (optional)
     * @param userId required if uploading an avatar (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> file uploaded </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createUploadAsync(String type, Object _file, Boolean synchronous, Integer userId, final ApiCallback<CreateUpload200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = createUploadValidateBeforeCall(type, _file, synchronous, userId, _callback);
        Type localVarReturnType = new TypeToken<CreateUpload200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for generatePresignedPut
     * @param generatePresignedPutRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call generatePresignedPutCall(GeneratePresignedPutRequest generatePresignedPutRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = generatePresignedPutRequest;

        // create path and map variables
        String localVarPath = "/uploads/generate-presigned-put.json";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call generatePresignedPutValidateBeforeCall(GeneratePresignedPutRequest generatePresignedPutRequest, final ApiCallback _callback) throws ApiException {
        return generatePresignedPutCall(generatePresignedPutRequest, _callback);

    }

    /**
     * Initiates a direct external upload
     * Direct external uploads bypass the usual method of creating uploads via the POST /uploads route, and upload directly to an external provider, which by default is S3. This route begins the process, and will return a unique identifier for the external upload as well as a presigned URL which is where the file binary blob should be uploaded to.  Once the upload is complete to the external service, you must call the POST /complete-external-upload route using the unique identifier returned by this route, which will create any required Upload record in the Discourse database and also move file from its temporary location to the final destination in the external storage service.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param generatePresignedPutRequest  (optional)
     * @return GeneratePresignedPut200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public GeneratePresignedPut200Response generatePresignedPut(GeneratePresignedPutRequest generatePresignedPutRequest) throws ApiException {
        ApiResponse<GeneratePresignedPut200Response> localVarResp = generatePresignedPutWithHttpInfo(generatePresignedPutRequest);
        return localVarResp.getData();
    }

    /**
     * Initiates a direct external upload
     * Direct external uploads bypass the usual method of creating uploads via the POST /uploads route, and upload directly to an external provider, which by default is S3. This route begins the process, and will return a unique identifier for the external upload as well as a presigned URL which is where the file binary blob should be uploaded to.  Once the upload is complete to the external service, you must call the POST /complete-external-upload route using the unique identifier returned by this route, which will create any required Upload record in the Discourse database and also move file from its temporary location to the final destination in the external storage service.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param generatePresignedPutRequest  (optional)
     * @return ApiResponse&lt;GeneratePresignedPut200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GeneratePresignedPut200Response> generatePresignedPutWithHttpInfo(GeneratePresignedPutRequest generatePresignedPutRequest) throws ApiException {
        okhttp3.Call localVarCall = generatePresignedPutValidateBeforeCall(generatePresignedPutRequest, null);
        Type localVarReturnType = new TypeToken<GeneratePresignedPut200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Initiates a direct external upload (asynchronously)
     * Direct external uploads bypass the usual method of creating uploads via the POST /uploads route, and upload directly to an external provider, which by default is S3. This route begins the process, and will return a unique identifier for the external upload as well as a presigned URL which is where the file binary blob should be uploaded to.  Once the upload is complete to the external service, you must call the POST /complete-external-upload route using the unique identifier returned by this route, which will create any required Upload record in the Discourse database and also move file from its temporary location to the final destination in the external storage service.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and &#x60;enable_direct_s3_uploads&#x60; must be set to true for this endpoint to function.  
     * @param generatePresignedPutRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> external upload initialized </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call generatePresignedPutAsync(GeneratePresignedPutRequest generatePresignedPutRequest, final ApiCallback<GeneratePresignedPut200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = generatePresignedPutValidateBeforeCall(generatePresignedPutRequest, _callback);
        Type localVarReturnType = new TypeToken<GeneratePresignedPut200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
