/**
 * OSF APIv2 Documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@osf.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINodesApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAINodesApi::OAINodesApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAINodesApi::~OAINodesApi() {
}

void OAINodesApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.test.osf.io/v2"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("nodesAddonRead", defaultConf);
    _serverIndices.insert("nodesAddonRead", 0);
    _serverConfigs.insert("nodesAddonsFoldersList", defaultConf);
    _serverIndices.insert("nodesAddonsFoldersList", 0);
    _serverConfigs.insert("nodesAddonsList", defaultConf);
    _serverIndices.insert("nodesAddonsList", 0);
    _serverConfigs.insert("nodesChildrenCreate", defaultConf);
    _serverIndices.insert("nodesChildrenCreate", 0);
    _serverConfigs.insert("nodesChildrenList", defaultConf);
    _serverIndices.insert("nodesChildrenList", 0);
    _serverConfigs.insert("nodesCitationList", defaultConf);
    _serverIndices.insert("nodesCitationList", 0);
    _serverConfigs.insert("nodesCitationRead", defaultConf);
    _serverIndices.insert("nodesCitationRead", 0);
    _serverConfigs.insert("nodesCommentCreate", defaultConf);
    _serverIndices.insert("nodesCommentCreate", 0);
    _serverConfigs.insert("nodesCommentsList", defaultConf);
    _serverIndices.insert("nodesCommentsList", 0);
    _serverConfigs.insert("nodesContributorsCreate", defaultConf);
    _serverIndices.insert("nodesContributorsCreate", 0);
    _serverConfigs.insert("nodesContributorsDelete", defaultConf);
    _serverIndices.insert("nodesContributorsDelete", 0);
    _serverConfigs.insert("nodesContributorsList", defaultConf);
    _serverIndices.insert("nodesContributorsList", 0);
    _serverConfigs.insert("nodesContributorsPartialUpdate", defaultConf);
    _serverIndices.insert("nodesContributorsPartialUpdate", 0);
    _serverConfigs.insert("nodesContributorsRead", defaultConf);
    _serverIndices.insert("nodesContributorsRead", 0);
    _serverConfigs.insert("nodesCreate", defaultConf);
    _serverIndices.insert("nodesCreate", 0);
    _serverConfigs.insert("nodesDelete", defaultConf);
    _serverIndices.insert("nodesDelete", 0);
    _serverConfigs.insert("nodesDraftRegistrationsCreate", defaultConf);
    _serverIndices.insert("nodesDraftRegistrationsCreate", 0);
    _serverConfigs.insert("nodesDraftRegistrationsDelete", defaultConf);
    _serverIndices.insert("nodesDraftRegistrationsDelete", 0);
    _serverConfigs.insert("nodesDraftRegistrationsList", defaultConf);
    _serverIndices.insert("nodesDraftRegistrationsList", 0);
    _serverConfigs.insert("nodesDraftRegistrationsPartialUpdate", defaultConf);
    _serverIndices.insert("nodesDraftRegistrationsPartialUpdate", 0);
    _serverConfigs.insert("nodesFilesList", defaultConf);
    _serverIndices.insert("nodesFilesList", 0);
    _serverConfigs.insert("nodesFilesRead", defaultConf);
    _serverIndices.insert("nodesFilesRead", 0);
    _serverConfigs.insert("nodesForksCreate", defaultConf);
    _serverIndices.insert("nodesForksCreate", 0);
    _serverConfigs.insert("nodesForksList", defaultConf);
    _serverIndices.insert("nodesForksList", 0);
    _serverConfigs.insert("nodesIdentifiersList", defaultConf);
    _serverIndices.insert("nodesIdentifiersList", 0);
    _serverConfigs.insert("nodesInstitutionsList", defaultConf);
    _serverIndices.insert("nodesInstitutionsList", 0);
    _serverConfigs.insert("nodesLinkedNodesList", defaultConf);
    _serverIndices.insert("nodesLinkedNodesList", 0);
    _serverConfigs.insert("nodesList", defaultConf);
    _serverIndices.insert("nodesList", 0);
    _serverConfigs.insert("nodesLogsList", defaultConf);
    _serverIndices.insert("nodesLogsList", 0);
    _serverConfigs.insert("nodesNodeAddonUpdate", defaultConf);
    _serverIndices.insert("nodesNodeAddonUpdate", 0);
    _serverConfigs.insert("nodesPartialUpdate", defaultConf);
    _serverIndices.insert("nodesPartialUpdate", 0);
    _serverConfigs.insert("nodesPreprintsList", defaultConf);
    _serverIndices.insert("nodesPreprintsList", 0);
    _serverConfigs.insert("nodesProvidersList", defaultConf);
    _serverIndices.insert("nodesProvidersList", 0);
    _serverConfigs.insert("nodesProvidersRead", defaultConf);
    _serverIndices.insert("nodesProvidersRead", 0);
    _serverConfigs.insert("nodesRead", defaultConf);
    _serverIndices.insert("nodesRead", 0);
    _serverConfigs.insert("nodesRegistrationsList", defaultConf);
    _serverIndices.insert("nodesRegistrationsList", 0);
    _serverConfigs.insert("nodesViewOnlyLinksList", defaultConf);
    _serverIndices.insert("nodesViewOnlyLinksList", 0);
    _serverConfigs.insert("nodesViewOnlyLinksRead", defaultConf);
    _serverIndices.insert("nodesViewOnlyLinksRead", 0);
    _serverConfigs.insert("nodesWikisList", defaultConf);
    _serverIndices.insert("nodesWikisList", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAINodesApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAINodesApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAINodesApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAINodesApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAINodesApi::setUsername(const QString &username) {
    _username = username;
}

void OAINodesApi::setPassword(const QString &password) {
    _password = password;
}


void OAINodesApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAINodesApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAINodesApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAINodesApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAINodesApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAINodesApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAINodesApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAINodesApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAINodesApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAINodesApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAINodesApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAINodesApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAINodesApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAINodesApi::nodesAddonRead(const QString &node_id, const QString &provider) {
    QString fullPath = QString(_serverConfigs["nodesAddonRead"][_serverIndices.value("nodesAddonRead")].URL()+"/nodes/{node_id}/addons/{provider}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString providerPathParam("{");
        providerPathParam.append("provider").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider"+pathSuffix : pathPrefix;
        fullPath.replace(providerPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesAddonReadCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesAddonReadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINode_Addon output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesAddonReadSignal(output);
        Q_EMIT nodesAddonReadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesAddonReadSignalE(output, error_type, error_str);
        Q_EMIT nodesAddonReadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesAddonReadSignalError(output, error_type, error_str);
        Q_EMIT nodesAddonReadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesAddonsFoldersList(const QString &node_id, const QString &provider) {
    QString fullPath = QString(_serverConfigs["nodesAddonsFoldersList"][_serverIndices.value("nodesAddonsFoldersList")].URL()+"/nodes/{node_id}/addons/{provider}/folders/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString providerPathParam("{");
        providerPathParam.append("provider").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider"+pathSuffix : pathPrefix;
        fullPath.replace(providerPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesAddonsFoldersListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesAddonsFoldersListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAddon> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAddon val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesAddonsFoldersListSignal(output);
        Q_EMIT nodesAddonsFoldersListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesAddonsFoldersListSignalE(output, error_type, error_str);
        Q_EMIT nodesAddonsFoldersListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesAddonsFoldersListSignalError(output, error_type, error_str);
        Q_EMIT nodesAddonsFoldersListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesAddonsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesAddonsList"][_serverIndices.value("nodesAddonsList")].URL()+"/nodes/{node_id}/addons/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesAddonsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesAddonsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAddon> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAddon val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesAddonsListSignal(output);
        Q_EMIT nodesAddonsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesAddonsListSignalE(output, error_type, error_str);
        Q_EMIT nodesAddonsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesAddonsListSignalError(output, error_type, error_str);
        Q_EMIT nodesAddonsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesChildrenCreate(const QString &node_id, const OAINode &oai_node) {
    QString fullPath = QString(_serverConfigs["nodesChildrenCreate"][_serverIndices.value("nodesChildrenCreate")].URL()+"/nodes/{node_id}/children/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_node.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesChildrenCreateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesChildrenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesChildrenCreateSignal();
        Q_EMIT nodesChildrenCreateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesChildrenCreateSignalE(error_type, error_str);
        Q_EMIT nodesChildrenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesChildrenCreateSignalError(error_type, error_str);
        Q_EMIT nodesChildrenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesChildrenList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesChildrenList"][_serverIndices.value("nodesChildrenList")].URL()+"/nodes/{node_id}/children/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesChildrenListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesChildrenListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINode> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAINode val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesChildrenListSignal(output);
        Q_EMIT nodesChildrenListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesChildrenListSignalE(output, error_type, error_str);
        Q_EMIT nodesChildrenListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesChildrenListSignalError(output, error_type, error_str);
        Q_EMIT nodesChildrenListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesCitationList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesCitationList"][_serverIndices.value("nodesCitationList")].URL()+"/nodes/{node_id}/citation/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesCitationListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesCitationListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICitation_Detail output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesCitationListSignal(output);
        Q_EMIT nodesCitationListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesCitationListSignalE(output, error_type, error_str);
        Q_EMIT nodesCitationListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesCitationListSignalError(output, error_type, error_str);
        Q_EMIT nodesCitationListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesCitationRead(const QString &style_id, const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesCitationRead"][_serverIndices.value("nodesCitationRead")].URL()+"/nodes/{node_id}/citation/{style_id}/");
    
    
    {
        QString style_idPathParam("{");
        style_idPathParam.append("style_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "style_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"style_id"+pathSuffix : pathPrefix;
        fullPath.replace(style_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(style_id)));
    }
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesCitationReadCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesCitationReadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStyled_Citation output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesCitationReadSignal(output);
        Q_EMIT nodesCitationReadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesCitationReadSignalE(output, error_type, error_str);
        Q_EMIT nodesCitationReadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesCitationReadSignalError(output, error_type, error_str);
        Q_EMIT nodesCitationReadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesCommentCreate(const QString &node_id, const OAIComment &oai_comment) {
    QString fullPath = QString(_serverConfigs["nodesCommentCreate"][_serverIndices.value("nodesCommentCreate")].URL()+"/nodes/{node_id}/comments/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_comment.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesCommentCreateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesCommentCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesCommentCreateSignal();
        Q_EMIT nodesCommentCreateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesCommentCreateSignalE(error_type, error_str);
        Q_EMIT nodesCommentCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesCommentCreateSignalError(error_type, error_str);
        Q_EMIT nodesCommentCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesCommentsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesCommentsList"][_serverIndices.value("nodesCommentsList")].URL()+"/nodes/{node_id}/comments/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesCommentsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesCommentsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIComment> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIComment val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesCommentsListSignal(output);
        Q_EMIT nodesCommentsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesCommentsListSignalE(output, error_type, error_str);
        Q_EMIT nodesCommentsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesCommentsListSignalError(output, error_type, error_str);
        Q_EMIT nodesCommentsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesContributorsCreate(const QString &node_id, const OAIContributor &oai_contributor) {
    QString fullPath = QString(_serverConfigs["nodesContributorsCreate"][_serverIndices.value("nodesContributorsCreate")].URL()+"/nodes/{node_id}/contributors/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_contributor.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesContributorsCreateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesContributorsCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesContributorsCreateSignal();
        Q_EMIT nodesContributorsCreateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesContributorsCreateSignalE(error_type, error_str);
        Q_EMIT nodesContributorsCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesContributorsCreateSignalError(error_type, error_str);
        Q_EMIT nodesContributorsCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesContributorsDelete(const QString &node_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["nodesContributorsDelete"][_serverIndices.value("nodesContributorsDelete")].URL()+"/nodes/{node_id}/contributors/{user_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesContributorsDeleteCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesContributorsDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesContributorsDeleteSignal();
        Q_EMIT nodesContributorsDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesContributorsDeleteSignalE(error_type, error_str);
        Q_EMIT nodesContributorsDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesContributorsDeleteSignalError(error_type, error_str);
        Q_EMIT nodesContributorsDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesContributorsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesContributorsList"][_serverIndices.value("nodesContributorsList")].URL()+"/nodes/{node_id}/contributors/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesContributorsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesContributorsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIContributor> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIContributor val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesContributorsListSignal(output);
        Q_EMIT nodesContributorsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesContributorsListSignalE(output, error_type, error_str);
        Q_EMIT nodesContributorsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesContributorsListSignalError(output, error_type, error_str);
        Q_EMIT nodesContributorsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesContributorsPartialUpdate(const QString &node_id, const QString &user_id, const OAIContributor &oai_contributor) {
    QString fullPath = QString(_serverConfigs["nodesContributorsPartialUpdate"][_serverIndices.value("nodesContributorsPartialUpdate")].URL()+"/nodes/{node_id}/contributors/{user_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_contributor.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesContributorsPartialUpdateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesContributorsPartialUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesContributorsPartialUpdateSignal();
        Q_EMIT nodesContributorsPartialUpdateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesContributorsPartialUpdateSignalE(error_type, error_str);
        Q_EMIT nodesContributorsPartialUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesContributorsPartialUpdateSignalError(error_type, error_str);
        Q_EMIT nodesContributorsPartialUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesContributorsRead(const QString &node_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["nodesContributorsRead"][_serverIndices.value("nodesContributorsRead")].URL()+"/nodes/{node_id}/contributors/{user_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesContributorsReadCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesContributorsReadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIContributor> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIContributor val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesContributorsReadSignal(output);
        Q_EMIT nodesContributorsReadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesContributorsReadSignalE(output, error_type, error_str);
        Q_EMIT nodesContributorsReadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesContributorsReadSignalError(output, error_type, error_str);
        Q_EMIT nodesContributorsReadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesCreate(const OAINode &oai_node) {
    QString fullPath = QString(_serverConfigs["nodesCreate"][_serverIndices.value("nodesCreate")].URL()+"/nodes/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_node.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesCreateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesCreateSignal();
        Q_EMIT nodesCreateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesCreateSignalE(error_type, error_str);
        Q_EMIT nodesCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesCreateSignalError(error_type, error_str);
        Q_EMIT nodesCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesDelete(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesDelete"][_serverIndices.value("nodesDelete")].URL()+"/nodes/{node_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesDeleteCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesDeleteSignal();
        Q_EMIT nodesDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesDeleteSignalE(error_type, error_str);
        Q_EMIT nodesDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesDeleteSignalError(error_type, error_str);
        Q_EMIT nodesDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesDraftRegistrationsCreate(const QString &node_id, const OAIDraft_Registration &oai_draft_registration) {
    QString fullPath = QString(_serverConfigs["nodesDraftRegistrationsCreate"][_serverIndices.value("nodesDraftRegistrationsCreate")].URL()+"/nodes/{node_id}/draft_registrations/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_draft_registration.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesDraftRegistrationsCreateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesDraftRegistrationsCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesDraftRegistrationsCreateSignal();
        Q_EMIT nodesDraftRegistrationsCreateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesDraftRegistrationsCreateSignalE(error_type, error_str);
        Q_EMIT nodesDraftRegistrationsCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesDraftRegistrationsCreateSignalError(error_type, error_str);
        Q_EMIT nodesDraftRegistrationsCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesDraftRegistrationsDelete(const QString &node_id, const QString &draft_id) {
    QString fullPath = QString(_serverConfigs["nodesDraftRegistrationsDelete"][_serverIndices.value("nodesDraftRegistrationsDelete")].URL()+"/nodes/{node_id}/draft_registrations/{draft_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString draft_idPathParam("{");
        draft_idPathParam.append("draft_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "draft_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"draft_id"+pathSuffix : pathPrefix;
        fullPath.replace(draft_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(draft_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesDraftRegistrationsDeleteCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesDraftRegistrationsDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesDraftRegistrationsDeleteSignal();
        Q_EMIT nodesDraftRegistrationsDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesDraftRegistrationsDeleteSignalE(error_type, error_str);
        Q_EMIT nodesDraftRegistrationsDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesDraftRegistrationsDeleteSignalError(error_type, error_str);
        Q_EMIT nodesDraftRegistrationsDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesDraftRegistrationsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesDraftRegistrationsList"][_serverIndices.value("nodesDraftRegistrationsList")].URL()+"/nodes/{node_id}/draft_registrations/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesDraftRegistrationsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesDraftRegistrationsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIDraft_Registration> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIDraft_Registration val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesDraftRegistrationsListSignal(output);
        Q_EMIT nodesDraftRegistrationsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesDraftRegistrationsListSignalE(output, error_type, error_str);
        Q_EMIT nodesDraftRegistrationsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesDraftRegistrationsListSignalError(output, error_type, error_str);
        Q_EMIT nodesDraftRegistrationsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesDraftRegistrationsPartialUpdate(const QString &node_id, const QString &draft_id, const OAIDraft_Registration &oai_draft_registration) {
    QString fullPath = QString(_serverConfigs["nodesDraftRegistrationsPartialUpdate"][_serverIndices.value("nodesDraftRegistrationsPartialUpdate")].URL()+"/nodes/{node_id}/draft_registrations/{draft_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString draft_idPathParam("{");
        draft_idPathParam.append("draft_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "draft_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"draft_id"+pathSuffix : pathPrefix;
        fullPath.replace(draft_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(draft_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_draft_registration.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesDraftRegistrationsPartialUpdateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesDraftRegistrationsPartialUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesDraftRegistrationsPartialUpdateSignal();
        Q_EMIT nodesDraftRegistrationsPartialUpdateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesDraftRegistrationsPartialUpdateSignalE(error_type, error_str);
        Q_EMIT nodesDraftRegistrationsPartialUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesDraftRegistrationsPartialUpdateSignalError(error_type, error_str);
        Q_EMIT nodesDraftRegistrationsPartialUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesFilesList(const QString &node_id, const QString &provider) {
    QString fullPath = QString(_serverConfigs["nodesFilesList"][_serverIndices.value("nodesFilesList")].URL()+"/nodes/{node_id}/files/{provider}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString providerPathParam("{");
        providerPathParam.append("provider").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider"+pathSuffix : pathPrefix;
        fullPath.replace(providerPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesFilesListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesFilesListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIFile> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIFile val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesFilesListSignal(output);
        Q_EMIT nodesFilesListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesFilesListSignalE(output, error_type, error_str);
        Q_EMIT nodesFilesListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesFilesListSignalError(output, error_type, error_str);
        Q_EMIT nodesFilesListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesFilesRead(const QString &node_id, const QString &provider, const QString &path) {
    QString fullPath = QString(_serverConfigs["nodesFilesRead"][_serverIndices.value("nodesFilesRead")].URL()+"/nodes/{node_id}/files/{provider}/{path}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString providerPathParam("{");
        providerPathParam.append("provider").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider"+pathSuffix : pathPrefix;
        fullPath.replace(providerPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider)));
    }
    
    {
        QString pathPathParam("{");
        pathPathParam.append("path").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "path", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"path"+pathSuffix : pathPrefix;
        fullPath.replace(pathPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(path)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesFilesReadCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesFilesReadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIFile output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesFilesReadSignal(output);
        Q_EMIT nodesFilesReadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesFilesReadSignalE(output, error_type, error_str);
        Q_EMIT nodesFilesReadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesFilesReadSignalError(output, error_type, error_str);
        Q_EMIT nodesFilesReadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesForksCreate(const QString &node_id, const OAINode &oai_node) {
    QString fullPath = QString(_serverConfigs["nodesForksCreate"][_serverIndices.value("nodesForksCreate")].URL()+"/nodes/{node_id}/forks/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_node.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesForksCreateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesForksCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesForksCreateSignal();
        Q_EMIT nodesForksCreateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesForksCreateSignalE(error_type, error_str);
        Q_EMIT nodesForksCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesForksCreateSignalError(error_type, error_str);
        Q_EMIT nodesForksCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesForksList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesForksList"][_serverIndices.value("nodesForksList")].URL()+"/nodes/{node_id}/forks/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesForksListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesForksListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINode> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAINode val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesForksListSignal(output);
        Q_EMIT nodesForksListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesForksListSignalE(output, error_type, error_str);
        Q_EMIT nodesForksListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesForksListSignalError(output, error_type, error_str);
        Q_EMIT nodesForksListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesIdentifiersList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesIdentifiersList"][_serverIndices.value("nodesIdentifiersList")].URL()+"/nodes/{node_id}/identifiers/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesIdentifiersListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesIdentifiersListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIdentifier> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIIdentifier val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesIdentifiersListSignal(output);
        Q_EMIT nodesIdentifiersListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesIdentifiersListSignalE(output, error_type, error_str);
        Q_EMIT nodesIdentifiersListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesIdentifiersListSignalError(output, error_type, error_str);
        Q_EMIT nodesIdentifiersListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesInstitutionsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesInstitutionsList"][_serverIndices.value("nodesInstitutionsList")].URL()+"/nodes/{node_id}/institutions/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesInstitutionsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesInstitutionsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIInstitution> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIInstitution val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesInstitutionsListSignal(output);
        Q_EMIT nodesInstitutionsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesInstitutionsListSignalE(output, error_type, error_str);
        Q_EMIT nodesInstitutionsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesInstitutionsListSignalError(output, error_type, error_str);
        Q_EMIT nodesInstitutionsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesLinkedNodesList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesLinkedNodesList"][_serverIndices.value("nodesLinkedNodesList")].URL()+"/nodes/{node_id}/linked_nodes/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesLinkedNodesListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesLinkedNodesListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINode> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAINode val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesLinkedNodesListSignal(output);
        Q_EMIT nodesLinkedNodesListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesLinkedNodesListSignalE(output, error_type, error_str);
        Q_EMIT nodesLinkedNodesListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesLinkedNodesListSignalError(output, error_type, error_str);
        Q_EMIT nodesLinkedNodesListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesList() {
    QString fullPath = QString(_serverConfigs["nodesList"][_serverIndices.value("nodesList")].URL()+"/nodes/");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINode> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAINode val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesListSignal(output);
        Q_EMIT nodesListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesListSignalE(output, error_type, error_str);
        Q_EMIT nodesListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesListSignalError(output, error_type, error_str);
        Q_EMIT nodesListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesLogsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesLogsList"][_serverIndices.value("nodesLogsList")].URL()+"/nodes/{node_id}/logs/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesLogsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesLogsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILog> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAILog val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesLogsListSignal(output);
        Q_EMIT nodesLogsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesLogsListSignalE(output, error_type, error_str);
        Q_EMIT nodesLogsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesLogsListSignalError(output, error_type, error_str);
        Q_EMIT nodesLogsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesNodeAddonUpdate(const QString &node_id, const QString &provider, const OAIObject &body) {
    QString fullPath = QString(_serverConfigs["nodesNodeAddonUpdate"][_serverIndices.value("nodesNodeAddonUpdate")].URL()+"/nodes/{node_id}/addons/{provider}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString providerPathParam("{");
        providerPathParam.append("provider").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider"+pathSuffix : pathPrefix;
        fullPath.replace(providerPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesNodeAddonUpdateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesNodeAddonUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesNodeAddonUpdateSignal();
        Q_EMIT nodesNodeAddonUpdateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesNodeAddonUpdateSignalE(error_type, error_str);
        Q_EMIT nodesNodeAddonUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesNodeAddonUpdateSignalError(error_type, error_str);
        Q_EMIT nodesNodeAddonUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesPartialUpdate(const QString &node_id, const OAIObject &body) {
    QString fullPath = QString(_serverConfigs["nodesPartialUpdate"][_serverIndices.value("nodesPartialUpdate")].URL()+"/nodes/{node_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesPartialUpdateCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesPartialUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesPartialUpdateSignal();
        Q_EMIT nodesPartialUpdateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesPartialUpdateSignalE(error_type, error_str);
        Q_EMIT nodesPartialUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesPartialUpdateSignalError(error_type, error_str);
        Q_EMIT nodesPartialUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesPreprintsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesPreprintsList"][_serverIndices.value("nodesPreprintsList")].URL()+"/nodes/{node_id}/preprints/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesPreprintsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesPreprintsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIPreprint> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIPreprint val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesPreprintsListSignal(output);
        Q_EMIT nodesPreprintsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesPreprintsListSignalE(output, error_type, error_str);
        Q_EMIT nodesPreprintsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesPreprintsListSignalError(output, error_type, error_str);
        Q_EMIT nodesPreprintsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesProvidersList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesProvidersList"][_serverIndices.value("nodesProvidersList")].URL()+"/nodes/{node_id}/files/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesProvidersListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesProvidersListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIFile> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIFile val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesProvidersListSignal(output);
        Q_EMIT nodesProvidersListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesProvidersListSignalE(output, error_type, error_str);
        Q_EMIT nodesProvidersListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesProvidersListSignalError(output, error_type, error_str);
        Q_EMIT nodesProvidersListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesProvidersRead(const QString &node_id, const QString &provider) {
    QString fullPath = QString(_serverConfigs["nodesProvidersRead"][_serverIndices.value("nodesProvidersRead")].URL()+"/nodes/{node_id}/files/providers/{provider}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString providerPathParam("{");
        providerPathParam.append("provider").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "provider", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"provider"+pathSuffix : pathPrefix;
        fullPath.replace(providerPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(provider)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesProvidersReadCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesProvidersReadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIFile output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesProvidersReadSignal(output);
        Q_EMIT nodesProvidersReadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesProvidersReadSignalE(output, error_type, error_str);
        Q_EMIT nodesProvidersReadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesProvidersReadSignalError(output, error_type, error_str);
        Q_EMIT nodesProvidersReadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesRead(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesRead"][_serverIndices.value("nodesRead")].URL()+"/nodes/{node_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesReadCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesReadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINode output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesReadSignal(output);
        Q_EMIT nodesReadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesReadSignalE(output, error_type, error_str);
        Q_EMIT nodesReadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesReadSignalError(output, error_type, error_str);
        Q_EMIT nodesReadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesRegistrationsList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesRegistrationsList"][_serverIndices.value("nodesRegistrationsList")].URL()+"/nodes/{node_id}/registrations/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesRegistrationsListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesRegistrationsListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIRegistration> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIRegistration val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesRegistrationsListSignal(output);
        Q_EMIT nodesRegistrationsListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesRegistrationsListSignalE(output, error_type, error_str);
        Q_EMIT nodesRegistrationsListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesRegistrationsListSignalError(output, error_type, error_str);
        Q_EMIT nodesRegistrationsListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesViewOnlyLinksList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesViewOnlyLinksList"][_serverIndices.value("nodesViewOnlyLinksList")].URL()+"/nodes/{node_id}/view_only_links/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesViewOnlyLinksListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesViewOnlyLinksListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIView_only_links> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIView_only_links val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesViewOnlyLinksListSignal(output);
        Q_EMIT nodesViewOnlyLinksListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesViewOnlyLinksListSignalE(output, error_type, error_str);
        Q_EMIT nodesViewOnlyLinksListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesViewOnlyLinksListSignalError(output, error_type, error_str);
        Q_EMIT nodesViewOnlyLinksListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesViewOnlyLinksRead(const QString &node_id, const QString &link_id) {
    QString fullPath = QString(_serverConfigs["nodesViewOnlyLinksRead"][_serverIndices.value("nodesViewOnlyLinksRead")].URL()+"/nodes/{node_id}/view_only_links/{link_id}/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    
    {
        QString link_idPathParam("{");
        link_idPathParam.append("link_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "link_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"link_id"+pathSuffix : pathPrefix;
        fullPath.replace(link_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(link_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesViewOnlyLinksReadCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesViewOnlyLinksReadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIView_only_links output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesViewOnlyLinksReadSignal(output);
        Q_EMIT nodesViewOnlyLinksReadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesViewOnlyLinksReadSignalE(output, error_type, error_str);
        Q_EMIT nodesViewOnlyLinksReadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesViewOnlyLinksReadSignalError(output, error_type, error_str);
        Q_EMIT nodesViewOnlyLinksReadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::nodesWikisList(const QString &node_id) {
    QString fullPath = QString(_serverConfigs["nodesWikisList"][_serverIndices.value("nodesWikisList")].URL()+"/nodes/{node_id}/wikis/");
    
    
    {
        QString node_idPathParam("{");
        node_idPathParam.append("node_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "node_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"node_id"+pathSuffix : pathPrefix;
        fullPath.replace(node_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(node_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAINodesApi::nodesWikisListCallback);
    connect(this, &OAINodesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAINodesApi::nodesWikisListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIWiki> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIWiki val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT nodesWikisListSignal(output);
        Q_EMIT nodesWikisListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT nodesWikisListSignalE(output, error_type, error_str);
        Q_EMIT nodesWikisListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT nodesWikisListSignalError(output, error_type, error_str);
        Q_EMIT nodesWikisListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAINodesApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
