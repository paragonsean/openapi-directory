/*
 * OSF APIv2 Documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@osf.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Addon;
import org.openapitools.client.model.CitationDetail;
import org.openapitools.client.model.Comment;
import org.openapitools.client.model.Contributor;
import org.openapitools.client.model.DraftRegistration;
import org.openapitools.client.model.Identifier;
import org.openapitools.client.model.Institution;
import org.openapitools.client.model.Log;
import org.openapitools.client.model.ModelFile;
import org.openapitools.client.model.Node;
import org.openapitools.client.model.NodeAddon;
import org.openapitools.client.model.Preprint;
import org.openapitools.client.model.Registration;
import org.openapitools.client.model.StyledCitation;
import org.openapitools.client.model.ViewOnlyLinks;
import org.openapitools.client.model.Wiki;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class NodesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public NodesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public NodesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for nodesAddonRead
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesAddonReadCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/addons/{provider}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "provider" + "}", localVarApiClient.escapeString(provider.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesAddonReadValidateBeforeCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesAddonRead(Async)");
        }

        // verify the required parameter 'provider' is set
        if (provider == null) {
            throw new ApiException("Missing the required parameter 'provider' when calling nodesAddonRead(Async)");
        }

        return nodesAddonReadCall(nodeId, provider, _callback);

    }

    /**
     * Retrieve an addon
     * Retrieve details of an individual addon connected to this node. #### Permissions NodeSettings that are attached to public nodes will give read-only access to everyone. Private nodes require explicit read permission. Write and admin access are the same for public and private nodes. Administrators on a parent node have implicit read permissions for all child nodes. Any users with write or admin access to the node are able to deauthorize an enabled addon, but only the addon authorizer is able to change the configuration (i.e. selected folder) of an already-configured NodeSettings entity. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the details of the requested addon, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @return NodeAddon
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public NodeAddon nodesAddonRead(String nodeId, String provider) throws ApiException {
        ApiResponse<NodeAddon> localVarResp = nodesAddonReadWithHttpInfo(nodeId, provider);
        return localVarResp.getData();
    }

    /**
     * Retrieve an addon
     * Retrieve details of an individual addon connected to this node. #### Permissions NodeSettings that are attached to public nodes will give read-only access to everyone. Private nodes require explicit read permission. Write and admin access are the same for public and private nodes. Administrators on a parent node have implicit read permissions for all child nodes. Any users with write or admin access to the node are able to deauthorize an enabled addon, but only the addon authorizer is able to change the configuration (i.e. selected folder) of an already-configured NodeSettings entity. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the details of the requested addon, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @return ApiResponse&lt;NodeAddon&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NodeAddon> nodesAddonReadWithHttpInfo(String nodeId, String provider) throws ApiException {
        okhttp3.Call localVarCall = nodesAddonReadValidateBeforeCall(nodeId, provider, null);
        Type localVarReturnType = new TypeToken<NodeAddon>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve an addon (asynchronously)
     * Retrieve details of an individual addon connected to this node. #### Permissions NodeSettings that are attached to public nodes will give read-only access to everyone. Private nodes require explicit read permission. Write and admin access are the same for public and private nodes. Administrators on a parent node have implicit read permissions for all child nodes. Any users with write or admin access to the node are able to deauthorize an enabled addon, but only the addon authorizer is able to change the configuration (i.e. selected folder) of an already-configured NodeSettings entity. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the details of the requested addon, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesAddonReadAsync(String nodeId, String provider, final ApiCallback<NodeAddon> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesAddonReadValidateBeforeCall(nodeId, provider, _callback);
        Type localVarReturnType = new TypeToken<NodeAddon>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesAddonsFoldersList
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the provider (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesAddonsFoldersListCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/addons/{provider}/folders/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "provider" + "}", localVarApiClient.escapeString(provider.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesAddonsFoldersListValidateBeforeCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesAddonsFoldersList(Async)");
        }

        // verify the required parameter 'provider' is set
        if (provider == null) {
            throw new ApiException("Missing the required parameter 'provider' when calling nodesAddonsFoldersList(Async)");
        }

        return nodesAddonsFoldersListCall(nodeId, provider, _callback);

    }

    /**
     * List all addon folders
     *  A paginated list of folders retrieved from the associated third-party (provider) service. #### Permissions Folders are visible only to the user that authorized the addon. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of addon folder objects. Each resource in the array is a separate addon folder object and contains the full representation of the addon folder, meaning additional requests to a addon folder&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the provider (required)
     * @return List&lt;Addon&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Addon> nodesAddonsFoldersList(String nodeId, String provider) throws ApiException {
        ApiResponse<List<Addon>> localVarResp = nodesAddonsFoldersListWithHttpInfo(nodeId, provider);
        return localVarResp.getData();
    }

    /**
     * List all addon folders
     *  A paginated list of folders retrieved from the associated third-party (provider) service. #### Permissions Folders are visible only to the user that authorized the addon. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of addon folder objects. Each resource in the array is a separate addon folder object and contains the full representation of the addon folder, meaning additional requests to a addon folder&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the provider (required)
     * @return ApiResponse&lt;List&lt;Addon&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Addon>> nodesAddonsFoldersListWithHttpInfo(String nodeId, String provider) throws ApiException {
        okhttp3.Call localVarCall = nodesAddonsFoldersListValidateBeforeCall(nodeId, provider, null);
        Type localVarReturnType = new TypeToken<List<Addon>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all addon folders (asynchronously)
     *  A paginated list of folders retrieved from the associated third-party (provider) service. #### Permissions Folders are visible only to the user that authorized the addon. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of addon folder objects. Each resource in the array is a separate addon folder object and contains the full representation of the addon folder, meaning additional requests to a addon folder&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the provider (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesAddonsFoldersListAsync(String nodeId, String provider, final ApiCallback<List<Addon>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesAddonsFoldersListValidateBeforeCall(nodeId, provider, _callback);
        Type localVarReturnType = new TypeToken<List<Addon>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesAddonsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesAddonsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/addons/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesAddonsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesAddonsList(Async)");
        }

        return nodesAddonsListCall(nodeId, _callback);

    }

    /**
     * List all addons
     *  A paginated list of addons connected to the given node or project. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of at most 10 addon objects. Each resource in the array is a separate addon object and contains the full representation of the addon, meaning additional requests to a addon&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Addon&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Addon> nodesAddonsList(String nodeId) throws ApiException {
        ApiResponse<List<Addon>> localVarResp = nodesAddonsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all addons
     *  A paginated list of addons connected to the given node or project. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of at most 10 addon objects. Each resource in the array is a separate addon object and contains the full representation of the addon, meaning additional requests to a addon&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Addon&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Addon>> nodesAddonsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesAddonsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Addon>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all addons (asynchronously)
     *  A paginated list of addons connected to the given node or project. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of at most 10 addon objects. Each resource in the array is a separate addon object and contains the full representation of the addon, meaning additional requests to a addon&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesAddonsListAsync(String nodeId, final ApiCallback<List<Addon>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesAddonsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Addon>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesChildrenCreate
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesChildrenCreateCall(String nodeId, Node node, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = node;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/children/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesChildrenCreateValidateBeforeCall(String nodeId, Node node, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesChildrenCreate(Async)");
        }

        // verify the required parameter 'node' is set
        if (node == null) {
            throw new ApiException("Missing the required parameter 'node' when calling nodesChildrenCreate(Async)");
        }

        return nodesChildrenCreateCall(nodeId, node, _callback);

    }

    /**
     * Create a child node
     * Creates a new child node.  Note: Creating a child node via this endpoint will function the same as creating a node via the node list endpoint, but the child node will have the given node set as its parent. #### Permissions Only write contributors may create children nodes. #### Required Required fields for creating a node include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;title&#x60;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;category&#x60;  Note: nodes default to **private** unless the &#x60;public&#x60; field is explicitly set to **true** in the request payload. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public void nodesChildrenCreate(String nodeId, Node node) throws ApiException {
        nodesChildrenCreateWithHttpInfo(nodeId, node);
    }

    /**
     * Create a child node
     * Creates a new child node.  Note: Creating a child node via this endpoint will function the same as creating a node via the node list endpoint, but the child node will have the given node set as its parent. #### Permissions Only write contributors may create children nodes. #### Required Required fields for creating a node include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;title&#x60;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;category&#x60;  Note: nodes default to **private** unless the &#x60;public&#x60; field is explicitly set to **true** in the request payload. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesChildrenCreateWithHttpInfo(String nodeId, Node node) throws ApiException {
        okhttp3.Call localVarCall = nodesChildrenCreateValidateBeforeCall(nodeId, node, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create a child node (asynchronously)
     * Creates a new child node.  Note: Creating a child node via this endpoint will function the same as creating a node via the node list endpoint, but the child node will have the given node set as its parent. #### Permissions Only write contributors may create children nodes. #### Required Required fields for creating a node include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;title&#x60;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;category&#x60;  Note: nodes default to **private** unless the &#x60;public&#x60; field is explicitly set to **true** in the request payload. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesChildrenCreateAsync(String nodeId, Node node, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesChildrenCreateValidateBeforeCall(nodeId, node, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesChildrenList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesChildrenListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/children/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesChildrenListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesChildrenList(Async)");
        }

        return nodesChildrenListCall(nodeId, _callback);

    }

    /**
     * List all child nodes
     *  A paginated list of the next level child nodes for the given node. The returned nodes are sorted by their &#x60;date_modified&#x60;, with the most recently updated child nodes appearing first.  The list will include child nodes that are public, as well as child nodes that are private, if the authenticated user has permission to view them. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 child nodes. If the given node has zero child nodes, the &#x60;data&#x60; key will contain an empty array. Each resource in the array is a separate node object and contains the full representation of the child node, meaning additional requests to the child node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error. #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/children/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, &#x60;preprint&#x60;, and &#x60;contributors&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting true or false in the query will cause the match to fail.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Node&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Node> nodesChildrenList(String nodeId) throws ApiException {
        ApiResponse<List<Node>> localVarResp = nodesChildrenListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all child nodes
     *  A paginated list of the next level child nodes for the given node. The returned nodes are sorted by their &#x60;date_modified&#x60;, with the most recently updated child nodes appearing first.  The list will include child nodes that are public, as well as child nodes that are private, if the authenticated user has permission to view them. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 child nodes. If the given node has zero child nodes, the &#x60;data&#x60; key will contain an empty array. Each resource in the array is a separate node object and contains the full representation of the child node, meaning additional requests to the child node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error. #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/children/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, &#x60;preprint&#x60;, and &#x60;contributors&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting true or false in the query will cause the match to fail.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Node&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Node>> nodesChildrenListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesChildrenListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all child nodes (asynchronously)
     *  A paginated list of the next level child nodes for the given node. The returned nodes are sorted by their &#x60;date_modified&#x60;, with the most recently updated child nodes appearing first.  The list will include child nodes that are public, as well as child nodes that are private, if the authenticated user has permission to view them. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 child nodes. If the given node has zero child nodes, the &#x60;data&#x60; key will contain an empty array. Each resource in the array is a separate node object and contains the full representation of the child node, meaning additional requests to the child node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error. #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/children/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, &#x60;preprint&#x60;, and &#x60;contributors&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting true or false in the query will cause the match to fail.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesChildrenListAsync(String nodeId, final ApiCallback<List<Node>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesChildrenListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesCitationList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCitationListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/citation/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesCitationListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesCitationList(Async)");
        }

        return nodesCitationListCall(nodeId, _callback);

    }

    /**
     * Retrieve citation details
     * The citation details for a node, in CSL format. #### Returns Returns a JSON object with a &#x60;data&#x60; key that contains the representation of the details necessary for the node citation.
     * @param nodeId The unique identifier of the node. (required)
     * @return CitationDetail
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public CitationDetail nodesCitationList(String nodeId) throws ApiException {
        ApiResponse<CitationDetail> localVarResp = nodesCitationListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * Retrieve citation details
     * The citation details for a node, in CSL format. #### Returns Returns a JSON object with a &#x60;data&#x60; key that contains the representation of the details necessary for the node citation.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;CitationDetail&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CitationDetail> nodesCitationListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesCitationListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<CitationDetail>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve citation details (asynchronously)
     * The citation details for a node, in CSL format. #### Returns Returns a JSON object with a &#x60;data&#x60; key that contains the representation of the details necessary for the node citation.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCitationListAsync(String nodeId, final ApiCallback<CitationDetail> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesCitationListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<CitationDetail>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesCitationRead
     * @param styleId The unique identifier of the citation style. (required)
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCitationReadCall(String styleId, String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/citation/{style_id}/"
            .replace("{" + "style_id" + "}", localVarApiClient.escapeString(styleId.toString()))
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesCitationReadValidateBeforeCall(String styleId, String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'styleId' is set
        if (styleId == null) {
            throw new ApiException("Missing the required parameter 'styleId' when calling nodesCitationRead(Async)");
        }

        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesCitationRead(Async)");
        }

        return nodesCitationReadCall(styleId, nodeId, _callback);

    }

    /**
     * Retrieve a styled citation
     * The citation for a node in a specific style. #### Returns Returns a JSON object with a &#x60;data&#x60; key that contains the representation of the node citation, in the requested style.
     * @param styleId The unique identifier of the citation style. (required)
     * @param nodeId The unique identifier of the node. (required)
     * @return StyledCitation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public StyledCitation nodesCitationRead(String styleId, String nodeId) throws ApiException {
        ApiResponse<StyledCitation> localVarResp = nodesCitationReadWithHttpInfo(styleId, nodeId);
        return localVarResp.getData();
    }

    /**
     * Retrieve a styled citation
     * The citation for a node in a specific style. #### Returns Returns a JSON object with a &#x60;data&#x60; key that contains the representation of the node citation, in the requested style.
     * @param styleId The unique identifier of the citation style. (required)
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;StyledCitation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<StyledCitation> nodesCitationReadWithHttpInfo(String styleId, String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesCitationReadValidateBeforeCall(styleId, nodeId, null);
        Type localVarReturnType = new TypeToken<StyledCitation>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a styled citation (asynchronously)
     * The citation for a node in a specific style. #### Returns Returns a JSON object with a &#x60;data&#x60; key that contains the representation of the node citation, in the requested style.
     * @param styleId The unique identifier of the citation style. (required)
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCitationReadAsync(String styleId, String nodeId, final ApiCallback<StyledCitation> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesCitationReadValidateBeforeCall(styleId, nodeId, _callback);
        Type localVarReturnType = new TypeToken<StyledCitation>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesCommentCreate
     * @param nodeId The unique identifier of the node you want to comment on. (required)
     * @param comment  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCommentCreateCall(String nodeId, Comment comment, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = comment;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/comments/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesCommentCreateValidateBeforeCall(String nodeId, Comment comment, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesCommentCreate(Async)");
        }

        // verify the required parameter 'comment' is set
        if (comment == null) {
            throw new ApiException("Missing the required parameter 'comment' when calling nodesCommentCreate(Async)");
        }

        return nodesCommentCreateCall(nodeId, comment, _callback);

    }

    /**
     * Create a comment
     * Create a comment on a given node overview page or a reply to a comment on that node.  To create a comment on the node overview page, the target &#x60;type&#x60; would be \&quot;nodes\&quot; and the target &#x60;id&#x60; would be the node &#x60;id&#x60;.  To reply to a comment on this node, the target &#x60;type&#x60; would be \&quot;comments\&quot; and the target &#x60;id&#x60; would be the &#x60;id&#x60; of the comment to reply to. #### Required A relationship object with a &#x60;data&#x60; key, containing the target (&#x60;comments&#x60; or &#x60;nodes&#x60;) type and a target &#x60;id&#x60; is required. In addition, the &#x60;content&#x60; attribute describing the relationship between the node and the comment is required. #### Returns Returns a JSON object with a data key containing the representation of the new comment, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node you want to comment on. (required)
     * @param comment  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public void nodesCommentCreate(String nodeId, Comment comment) throws ApiException {
        nodesCommentCreateWithHttpInfo(nodeId, comment);
    }

    /**
     * Create a comment
     * Create a comment on a given node overview page or a reply to a comment on that node.  To create a comment on the node overview page, the target &#x60;type&#x60; would be \&quot;nodes\&quot; and the target &#x60;id&#x60; would be the node &#x60;id&#x60;.  To reply to a comment on this node, the target &#x60;type&#x60; would be \&quot;comments\&quot; and the target &#x60;id&#x60; would be the &#x60;id&#x60; of the comment to reply to. #### Required A relationship object with a &#x60;data&#x60; key, containing the target (&#x60;comments&#x60; or &#x60;nodes&#x60;) type and a target &#x60;id&#x60; is required. In addition, the &#x60;content&#x60; attribute describing the relationship between the node and the comment is required. #### Returns Returns a JSON object with a data key containing the representation of the new comment, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node you want to comment on. (required)
     * @param comment  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesCommentCreateWithHttpInfo(String nodeId, Comment comment) throws ApiException {
        okhttp3.Call localVarCall = nodesCommentCreateValidateBeforeCall(nodeId, comment, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create a comment (asynchronously)
     * Create a comment on a given node overview page or a reply to a comment on that node.  To create a comment on the node overview page, the target &#x60;type&#x60; would be \&quot;nodes\&quot; and the target &#x60;id&#x60; would be the node &#x60;id&#x60;.  To reply to a comment on this node, the target &#x60;type&#x60; would be \&quot;comments\&quot; and the target &#x60;id&#x60; would be the &#x60;id&#x60; of the comment to reply to. #### Required A relationship object with a &#x60;data&#x60; key, containing the target (&#x60;comments&#x60; or &#x60;nodes&#x60;) type and a target &#x60;id&#x60; is required. In addition, the &#x60;content&#x60; attribute describing the relationship between the node and the comment is required. #### Returns Returns a JSON object with a data key containing the representation of the new comment, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node you want to comment on. (required)
     * @param comment  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCommentCreateAsync(String nodeId, Comment comment, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesCommentCreateValidateBeforeCall(nodeId, comment, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesCommentsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCommentsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/comments/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesCommentsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesCommentsList(Async)");
        }

        return nodesCommentsListCall(nodeId, _callback);

    }

    /**
     * List all comments
     *  A paginated list of comments related to a given node.  The returned comments are sorted by their creation date, with the most recent comments appearing first. #### Permissions Comments on public nodes are given read-only access to everyone.  If the node comment-level is &#x60;private&#x60;, only contributors have permission to comment.  If the comment-level is &#x60;public&#x60;, any logged-in OSF user can comment.  Comments on private nodes are only visible to contributors and administrators on the parent node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of comment objects. Each resource in the array is a separate comment object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include comments that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/comments/?filter[target_id]&#x3D;jg7sezmdnt93  Nodes may be filtered by their &#x60;deleted&#x60;, &#x60;target_id&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting &#x60;true&#x60; or &#x60;false&#x60; in the query will cause the match to fail.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Comment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Comment> nodesCommentsList(String nodeId) throws ApiException {
        ApiResponse<List<Comment>> localVarResp = nodesCommentsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all comments
     *  A paginated list of comments related to a given node.  The returned comments are sorted by their creation date, with the most recent comments appearing first. #### Permissions Comments on public nodes are given read-only access to everyone.  If the node comment-level is &#x60;private&#x60;, only contributors have permission to comment.  If the comment-level is &#x60;public&#x60;, any logged-in OSF user can comment.  Comments on private nodes are only visible to contributors and administrators on the parent node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of comment objects. Each resource in the array is a separate comment object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include comments that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/comments/?filter[target_id]&#x3D;jg7sezmdnt93  Nodes may be filtered by their &#x60;deleted&#x60;, &#x60;target_id&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting &#x60;true&#x60; or &#x60;false&#x60; in the query will cause the match to fail.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Comment&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Comment>> nodesCommentsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesCommentsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Comment>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all comments (asynchronously)
     *  A paginated list of comments related to a given node.  The returned comments are sorted by their creation date, with the most recent comments appearing first. #### Permissions Comments on public nodes are given read-only access to everyone.  If the node comment-level is &#x60;private&#x60;, only contributors have permission to comment.  If the comment-level is &#x60;public&#x60;, any logged-in OSF user can comment.  Comments on private nodes are only visible to contributors and administrators on the parent node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of comment objects. Each resource in the array is a separate comment object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include comments that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/comments/?filter[target_id]&#x3D;jg7sezmdnt93  Nodes may be filtered by their &#x60;deleted&#x60;, &#x60;target_id&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting &#x60;true&#x60; or &#x60;false&#x60; in the query will cause the match to fail.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCommentsListAsync(String nodeId, final ApiCallback<List<Comment>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesCommentsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Comment>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesContributorsCreate
     * @param nodeId The unique identifier of the node. (required)
     * @param contributor  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsCreateCall(String nodeId, Contributor contributor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = contributor;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/contributors/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesContributorsCreateValidateBeforeCall(String nodeId, Contributor contributor, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesContributorsCreate(Async)");
        }

        // verify the required parameter 'contributor' is set
        if (contributor == null) {
            throw new ApiException("Missing the required parameter 'contributor' when calling nodesContributorsCreate(Async)");
        }

        return nodesContributorsCreateCall(nodeId, contributor, _callback);

    }

    /**
     * Create a contributor
     * Adds a contributor to a node, effectively creating a relationship between the node and a user.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot; contributors. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not. #### Permissions Only project administrators can add contributors to a node. #### Required A relationship object with a &#x60;data&#x60; key, containing the &#x60;users&#x60; type and valid user ID is required.  All attributes describing the relationship between the node and the user are optional. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the new contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param contributor  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public void nodesContributorsCreate(String nodeId, Contributor contributor) throws ApiException {
        nodesContributorsCreateWithHttpInfo(nodeId, contributor);
    }

    /**
     * Create a contributor
     * Adds a contributor to a node, effectively creating a relationship between the node and a user.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot; contributors. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not. #### Permissions Only project administrators can add contributors to a node. #### Required A relationship object with a &#x60;data&#x60; key, containing the &#x60;users&#x60; type and valid user ID is required.  All attributes describing the relationship between the node and the user are optional. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the new contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param contributor  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesContributorsCreateWithHttpInfo(String nodeId, Contributor contributor) throws ApiException {
        okhttp3.Call localVarCall = nodesContributorsCreateValidateBeforeCall(nodeId, contributor, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create a contributor (asynchronously)
     * Adds a contributor to a node, effectively creating a relationship between the node and a user.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot; contributors. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not. #### Permissions Only project administrators can add contributors to a node. #### Required A relationship object with a &#x60;data&#x60; key, containing the &#x60;users&#x60; type and valid user ID is required.  All attributes describing the relationship between the node and the user are optional. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the new contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param contributor  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsCreateAsync(String nodeId, Contributor contributor, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesContributorsCreateValidateBeforeCall(nodeId, contributor, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesContributorsDelete
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsDeleteCall(String nodeId, String userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/contributors/{user_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesContributorsDeleteValidateBeforeCall(String nodeId, String userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesContributorsDelete(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling nodesContributorsDelete(Async)");
        }

        return nodesContributorsDeleteCall(nodeId, userId, _callback);

    }

    /**
     * Delete a contributor
     * Removes a contributor from a node. This request only removes the relationship between the node and the user, it does not delete the user itself.  A node must always have at least one admin, and attempting to remove the only admin from a node will result in a **400 Bad Request** response. #### Permissions A user can remove themselves as a node contributor. Otherwise, only project administrators can remove contributors. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public void nodesContributorsDelete(String nodeId, String userId) throws ApiException {
        nodesContributorsDeleteWithHttpInfo(nodeId, userId);
    }

    /**
     * Delete a contributor
     * Removes a contributor from a node. This request only removes the relationship between the node and the user, it does not delete the user itself.  A node must always have at least one admin, and attempting to remove the only admin from a node will result in a **400 Bad Request** response. #### Permissions A user can remove themselves as a node contributor. Otherwise, only project administrators can remove contributors. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesContributorsDeleteWithHttpInfo(String nodeId, String userId) throws ApiException {
        okhttp3.Call localVarCall = nodesContributorsDeleteValidateBeforeCall(nodeId, userId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a contributor (asynchronously)
     * Removes a contributor from a node. This request only removes the relationship between the node and the user, it does not delete the user itself.  A node must always have at least one admin, and attempting to remove the only admin from a node will result in a **400 Bad Request** response. #### Permissions A user can remove themselves as a node contributor. Otherwise, only project administrators can remove contributors. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsDeleteAsync(String nodeId, String userId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesContributorsDeleteValidateBeforeCall(nodeId, userId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesContributorsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/contributors/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesContributorsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesContributorsList(Async)");
        }

        return nodesContributorsListCall(nodeId, _callback);

    }

    /**
     * List all contributors
     * A paginated list of the node&#39;s contributors, sorted by their index.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot;. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not.  Note that if an anonymous view_only key is being used to view the list of contributors, the user relationship will not be exposed and the contributor ID will be an empty string.  #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 contributors. Each resource in the array contains the full representation of the contributor, meaning additional requests to a contributor&#39;s detail view are not necessary. Additionally, the full representation of the user this contributor represents is automatically embedded within the &#x60;data&#x60; key of the response.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include contributors that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/y9jdt/contributors/?filter[bibliographic]&#x3D;true.  Contributors may be filtered by their &#x60;bibliographic&#x60; and &#x60;permission&#x60; attributes.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Contributor&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Contributor> nodesContributorsList(String nodeId) throws ApiException {
        ApiResponse<List<Contributor>> localVarResp = nodesContributorsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all contributors
     * A paginated list of the node&#39;s contributors, sorted by their index.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot;. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not.  Note that if an anonymous view_only key is being used to view the list of contributors, the user relationship will not be exposed and the contributor ID will be an empty string.  #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 contributors. Each resource in the array contains the full representation of the contributor, meaning additional requests to a contributor&#39;s detail view are not necessary. Additionally, the full representation of the user this contributor represents is automatically embedded within the &#x60;data&#x60; key of the response.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include contributors that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/y9jdt/contributors/?filter[bibliographic]&#x3D;true.  Contributors may be filtered by their &#x60;bibliographic&#x60; and &#x60;permission&#x60; attributes.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Contributor&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Contributor>> nodesContributorsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesContributorsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Contributor>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all contributors (asynchronously)
     * A paginated list of the node&#39;s contributors, sorted by their index.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot;. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not.  Note that if an anonymous view_only key is being used to view the list of contributors, the user relationship will not be exposed and the contributor ID will be an empty string.  #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 contributors. Each resource in the array contains the full representation of the contributor, meaning additional requests to a contributor&#39;s detail view are not necessary. Additionally, the full representation of the user this contributor represents is automatically embedded within the &#x60;data&#x60; key of the response.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include contributors that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/y9jdt/contributors/?filter[bibliographic]&#x3D;true.  Contributors may be filtered by their &#x60;bibliographic&#x60; and &#x60;permission&#x60; attributes.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsListAsync(String nodeId, final ApiCallback<List<Contributor>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesContributorsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Contributor>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesContributorsPartialUpdate
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param contributor  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsPartialUpdateCall(String nodeId, String userId, Contributor contributor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = contributor;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/contributors/{user_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesContributorsPartialUpdateValidateBeforeCall(String nodeId, String userId, Contributor contributor, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesContributorsPartialUpdate(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling nodesContributorsPartialUpdate(Async)");
        }

        // verify the required parameter 'contributor' is set
        if (contributor == null) {
            throw new ApiException("Missing the required parameter 'contributor' when calling nodesContributorsPartialUpdate(Async)");
        }

        return nodesContributorsPartialUpdateCall(nodeId, userId, contributor, _callback);

    }

    /**
     * Update a contributor
     * Updates a contributor by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Contributors can be updated with either a **PUT** or **PATCH** request. Since this endpoint has no mandatory attributes, PUT and PATCH are functionally the same. #### Permissions Only project administrators can update the contributors on a node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.  If the given user is not already in the contributor list, a 404 Not Found error will be returned. A node must always have at least one admin, and any attempt to downgrade the permissions of a sole admin will result in a 400 Bad Request error.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param contributor  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public void nodesContributorsPartialUpdate(String nodeId, String userId, Contributor contributor) throws ApiException {
        nodesContributorsPartialUpdateWithHttpInfo(nodeId, userId, contributor);
    }

    /**
     * Update a contributor
     * Updates a contributor by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Contributors can be updated with either a **PUT** or **PATCH** request. Since this endpoint has no mandatory attributes, PUT and PATCH are functionally the same. #### Permissions Only project administrators can update the contributors on a node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.  If the given user is not already in the contributor list, a 404 Not Found error will be returned. A node must always have at least one admin, and any attempt to downgrade the permissions of a sole admin will result in a 400 Bad Request error.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param contributor  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesContributorsPartialUpdateWithHttpInfo(String nodeId, String userId, Contributor contributor) throws ApiException {
        okhttp3.Call localVarCall = nodesContributorsPartialUpdateValidateBeforeCall(nodeId, userId, contributor, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update a contributor (asynchronously)
     * Updates a contributor by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Contributors can be updated with either a **PUT** or **PATCH** request. Since this endpoint has no mandatory attributes, PUT and PATCH are functionally the same. #### Permissions Only project administrators can update the contributors on a node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.  If the given user is not already in the contributor list, a 404 Not Found error will be returned. A node must always have at least one admin, and any attempt to downgrade the permissions of a sole admin will result in a 400 Bad Request error.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param contributor  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsPartialUpdateAsync(String nodeId, String userId, Contributor contributor, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesContributorsPartialUpdateValidateBeforeCall(nodeId, userId, contributor, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesContributorsRead
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsReadCall(String nodeId, String userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/contributors/{user_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesContributorsReadValidateBeforeCall(String nodeId, String userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesContributorsRead(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling nodesContributorsRead(Async)");
        }

        return nodesContributorsReadCall(nodeId, userId, _callback);

    }

    /**
     * Retrieve a contributor
     * Retrieves the details of a given contributor.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot;. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @return List&lt;Contributor&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Contributor> nodesContributorsRead(String nodeId, String userId) throws ApiException {
        ApiResponse<List<Contributor>> localVarResp = nodesContributorsReadWithHttpInfo(nodeId, userId);
        return localVarResp.getData();
    }

    /**
     * Retrieve a contributor
     * Retrieves the details of a given contributor.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot;. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @return ApiResponse&lt;List&lt;Contributor&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Contributor>> nodesContributorsReadWithHttpInfo(String nodeId, String userId) throws ApiException {
        okhttp3.Call localVarCall = nodesContributorsReadValidateBeforeCall(nodeId, userId, null);
        Type localVarReturnType = new TypeToken<List<Contributor>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a contributor (asynchronously)
     * Retrieves the details of a given contributor.  Contributors are users who can make changes to the node or, in the case of private nodes, have read access to the node.  Contributors are categorized as either \&quot;bibliographic\&quot; or \&quot;non-bibliographic\&quot;. From a permissions standpoint, both are the same, but bibliographic contributors are included in citations and are listed on the project overview page on the OSF, while non-bibliographic contributors are not. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested contributor, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param userId The unique identifier of the user. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesContributorsReadAsync(String nodeId, String userId, final ApiCallback<List<Contributor>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesContributorsReadValidateBeforeCall(nodeId, userId, _callback);
        Type localVarReturnType = new TypeToken<List<Contributor>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesCreate
     * @param node  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCreateCall(Node node, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = node;

        // create path and map variables
        String localVarPath = "/nodes/";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesCreateValidateBeforeCall(Node node, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'node' is set
        if (node == null) {
            throw new ApiException("Missing the required parameter 'node' when calling nodesCreate(Async)");
        }

        return nodesCreateCall(node, _callback);

    }

    /**
     * Create a node
     * Creates a new node.  On the OSF, nodes are considered **projects** or **components**. The difference between a project and a component is that a project is a top-level node, and a component is a child of a project.  Additionally, nodes have a &#x60;category&#x60; field that includes **project** as an option. The categorization determines what icon is displayed with the node on the OSF, and helps with search organization. Projects (top-level nodes) may have a category other than project, and components (children) may have a category of **project**. #### Required Required fields for creating a node include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;title&#x60;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;category&#x60;  Note: Nodes default to **private** unless the &#x60;public&#x60; field is explicitly set to **true** in the request payload. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param node  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public void nodesCreate(Node node) throws ApiException {
        nodesCreateWithHttpInfo(node);
    }

    /**
     * Create a node
     * Creates a new node.  On the OSF, nodes are considered **projects** or **components**. The difference between a project and a component is that a project is a top-level node, and a component is a child of a project.  Additionally, nodes have a &#x60;category&#x60; field that includes **project** as an option. The categorization determines what icon is displayed with the node on the OSF, and helps with search organization. Projects (top-level nodes) may have a category other than project, and components (children) may have a category of **project**. #### Required Required fields for creating a node include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;title&#x60;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;category&#x60;  Note: Nodes default to **private** unless the &#x60;public&#x60; field is explicitly set to **true** in the request payload. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param node  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesCreateWithHttpInfo(Node node) throws ApiException {
        okhttp3.Call localVarCall = nodesCreateValidateBeforeCall(node, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create a node (asynchronously)
     * Creates a new node.  On the OSF, nodes are considered **projects** or **components**. The difference between a project and a component is that a project is a top-level node, and a component is a child of a project.  Additionally, nodes have a &#x60;category&#x60; field that includes **project** as an option. The categorization determines what icon is displayed with the node on the OSF, and helps with search organization. Projects (top-level nodes) may have a category other than project, and components (children) may have a category of **project**. #### Required Required fields for creating a node include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;title&#x60;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp&#x60;category&#x60;  Note: Nodes default to **private** unless the &#x60;public&#x60; field is explicitly set to **true** in the request payload. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param node  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesCreateAsync(Node node, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesCreateValidateBeforeCall(node, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesDelete
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDeleteCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesDeleteValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesDelete(Async)");
        }

        return nodesDeleteCall(nodeId, _callback);

    }

    /**
     * Delete a node
     *  Permanently deletes a node. This action cannot be undone. #### Permissions Only project administrators may delete a node. Attempting to delete a node for which you are not an administrator will result in a **403 Forbidden** response. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public void nodesDelete(String nodeId) throws ApiException {
        nodesDeleteWithHttpInfo(nodeId);
    }

    /**
     * Delete a node
     *  Permanently deletes a node. This action cannot be undone. #### Permissions Only project administrators may delete a node. Attempting to delete a node for which you are not an administrator will result in a **403 Forbidden** response. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesDeleteWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesDeleteValidateBeforeCall(nodeId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a node (asynchronously)
     *  Permanently deletes a node. This action cannot be undone. #### Permissions Only project administrators may delete a node. Attempting to delete a node for which you are not an administrator will result in a **403 Forbidden** response. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDeleteAsync(String nodeId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesDeleteValidateBeforeCall(nodeId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesDraftRegistrationsCreate
     * @param nodeId The unique identifier of the node. (required)
     * @param draftRegistration  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsCreateCall(String nodeId, DraftRegistration draftRegistration, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = draftRegistration;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/draft_registrations/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesDraftRegistrationsCreateValidateBeforeCall(String nodeId, DraftRegistration draftRegistration, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesDraftRegistrationsCreate(Async)");
        }

        // verify the required parameter 'draftRegistration' is set
        if (draftRegistration == null) {
            throw new ApiException("Missing the required parameter 'draftRegistration' when calling nodesDraftRegistrationsCreate(Async)");
        }

        return nodesDraftRegistrationsCreateCall(nodeId, draftRegistration, _callback);

    }

    /**
     * Create a draft registration based on your current project Node.
     * Initiate a draft registration of the current node. Draft Registrations contain Registration questions that will become part of the Registration. A Registration is a frozen version of the project that can never be deleted, but can be withdrawn and have it&#39;s metadata edited.  Your original project remains editable but will now have the draft registration linked to it. #### Permissions Only project administrators may view create registrations. #### Required Required fields for creating a draft registration include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x60;schema_id&#x60; #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created draft registration, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftRegistration  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public void nodesDraftRegistrationsCreate(String nodeId, DraftRegistration draftRegistration) throws ApiException {
        nodesDraftRegistrationsCreateWithHttpInfo(nodeId, draftRegistration);
    }

    /**
     * Create a draft registration based on your current project Node.
     * Initiate a draft registration of the current node. Draft Registrations contain Registration questions that will become part of the Registration. A Registration is a frozen version of the project that can never be deleted, but can be withdrawn and have it&#39;s metadata edited.  Your original project remains editable but will now have the draft registration linked to it. #### Permissions Only project administrators may view create registrations. #### Required Required fields for creating a draft registration include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x60;schema_id&#x60; #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created draft registration, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftRegistration  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesDraftRegistrationsCreateWithHttpInfo(String nodeId, DraftRegistration draftRegistration) throws ApiException {
        okhttp3.Call localVarCall = nodesDraftRegistrationsCreateValidateBeforeCall(nodeId, draftRegistration, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create a draft registration based on your current project Node. (asynchronously)
     * Initiate a draft registration of the current node. Draft Registrations contain Registration questions that will become part of the Registration. A Registration is a frozen version of the project that can never be deleted, but can be withdrawn and have it&#39;s metadata edited.  Your original project remains editable but will now have the draft registration linked to it. #### Permissions Only project administrators may view create registrations. #### Required Required fields for creating a draft registration include:  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x60;schema_id&#x60; #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the created draft registration, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftRegistration  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsCreateAsync(String nodeId, DraftRegistration draftRegistration, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesDraftRegistrationsCreateValidateBeforeCall(nodeId, draftRegistration, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesDraftRegistrationsDelete
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsDeleteCall(String nodeId, String draftId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/draft_registrations/{draft_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "draft_id" + "}", localVarApiClient.escapeString(draftId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesDraftRegistrationsDeleteValidateBeforeCall(String nodeId, String draftId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesDraftRegistrationsDelete(Async)");
        }

        // verify the required parameter 'draftId' is set
        if (draftId == null) {
            throw new ApiException("Missing the required parameter 'draftId' when calling nodesDraftRegistrationsDelete(Async)");
        }

        return nodesDraftRegistrationsDeleteCall(nodeId, draftId, _callback);

    }

    /**
     * Delete a draft registration
     * Permanently deletes a draft registration. A draft that has already been registered cannot be deleted. #### Permissions Only project administrators may delete draft registrations. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes]() to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void nodesDraftRegistrationsDelete(String nodeId, String draftId) throws ApiException {
        nodesDraftRegistrationsDeleteWithHttpInfo(nodeId, draftId);
    }

    /**
     * Delete a draft registration
     * Permanently deletes a draft registration. A draft that has already been registered cannot be deleted. #### Permissions Only project administrators may delete draft registrations. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes]() to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesDraftRegistrationsDeleteWithHttpInfo(String nodeId, String draftId) throws ApiException {
        okhttp3.Call localVarCall = nodesDraftRegistrationsDeleteValidateBeforeCall(nodeId, draftId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a draft registration (asynchronously)
     * Permanently deletes a draft registration. A draft that has already been registered cannot be deleted. #### Permissions Only project administrators may delete draft registrations. #### Returns If the request is successful, no content is returned.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes]() to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsDeleteAsync(String nodeId, String draftId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesDraftRegistrationsDeleteValidateBeforeCall(nodeId, draftId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesDraftRegistrationsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/draft_registrations/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesDraftRegistrationsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesDraftRegistrationsList(Async)");
        }

        return nodesDraftRegistrationsListCall(nodeId, _callback);

    }

    /**
     * List all draft registrations
     * A paginated list of all of the draft registrations of a given node.  Draft Registrations contain Registration questions that will become part of the Registration. A Registration is a frozen version of the project that can never be deleted, but can be withdrawn and have it&#39;s metadata edited.  Your original project remains editable but will now have the draft registration linked to it. #### Permissions Only project administrators may view draft registrations. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 draft registrations. Each resource in the array is a separate draft registration object and contains the full representation of the draft registration, meaning additional requests to a draft registration&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;DraftRegistration&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<DraftRegistration> nodesDraftRegistrationsList(String nodeId) throws ApiException {
        ApiResponse<List<DraftRegistration>> localVarResp = nodesDraftRegistrationsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all draft registrations
     * A paginated list of all of the draft registrations of a given node.  Draft Registrations contain Registration questions that will become part of the Registration. A Registration is a frozen version of the project that can never be deleted, but can be withdrawn and have it&#39;s metadata edited.  Your original project remains editable but will now have the draft registration linked to it. #### Permissions Only project administrators may view draft registrations. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 draft registrations. Each resource in the array is a separate draft registration object and contains the full representation of the draft registration, meaning additional requests to a draft registration&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;DraftRegistration&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DraftRegistration>> nodesDraftRegistrationsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesDraftRegistrationsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<DraftRegistration>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all draft registrations (asynchronously)
     * A paginated list of all of the draft registrations of a given node.  Draft Registrations contain Registration questions that will become part of the Registration. A Registration is a frozen version of the project that can never be deleted, but can be withdrawn and have it&#39;s metadata edited.  Your original project remains editable but will now have the draft registration linked to it. #### Permissions Only project administrators may view draft registrations. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 draft registrations. Each resource in the array is a separate draft registration object and contains the full representation of the draft registration, meaning additional requests to a draft registration&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsListAsync(String nodeId, final ApiCallback<List<DraftRegistration>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesDraftRegistrationsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<DraftRegistration>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesDraftRegistrationsPartialUpdate
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @param draftRegistration  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsPartialUpdateCall(String nodeId, String draftId, DraftRegistration draftRegistration, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = draftRegistration;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/draft_registrations/{draft_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "draft_id" + "}", localVarApiClient.escapeString(draftId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesDraftRegistrationsPartialUpdateValidateBeforeCall(String nodeId, String draftId, DraftRegistration draftRegistration, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesDraftRegistrationsPartialUpdate(Async)");
        }

        // verify the required parameter 'draftId' is set
        if (draftId == null) {
            throw new ApiException("Missing the required parameter 'draftId' when calling nodesDraftRegistrationsPartialUpdate(Async)");
        }

        // verify the required parameter 'draftRegistration' is set
        if (draftRegistration == null) {
            throw new ApiException("Missing the required parameter 'draftRegistration' when calling nodesDraftRegistrationsPartialUpdate(Async)");
        }

        return nodesDraftRegistrationsPartialUpdateCall(nodeId, draftId, draftRegistration, _callback);

    }

    /**
     * Update a draft registration
     * Updates a draft registration by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Draft Registrations contain Registration questions that will become part of the Registration. Answer the questions in the draft registration supplement by sending update requests until you are ready to submit the draft.  The registration supplement of a draft registration cannot be updated after the draft has been created.  When updating a draft registration, &#x60;registration_metadata&#x60; is required. It must be a dictionary with keys as question ids in the registration form, and values as nested dictionaries matching the specific format in the [registration schema](TODO: link me pls).  If a question is multiple-choice, the question response must exactly match one of the possible choices. #### Permissions Only project administrators may update draft registrations. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated draft registration, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @param draftRegistration  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public void nodesDraftRegistrationsPartialUpdate(String nodeId, String draftId, DraftRegistration draftRegistration) throws ApiException {
        nodesDraftRegistrationsPartialUpdateWithHttpInfo(nodeId, draftId, draftRegistration);
    }

    /**
     * Update a draft registration
     * Updates a draft registration by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Draft Registrations contain Registration questions that will become part of the Registration. Answer the questions in the draft registration supplement by sending update requests until you are ready to submit the draft.  The registration supplement of a draft registration cannot be updated after the draft has been created.  When updating a draft registration, &#x60;registration_metadata&#x60; is required. It must be a dictionary with keys as question ids in the registration form, and values as nested dictionaries matching the specific format in the [registration schema](TODO: link me pls).  If a question is multiple-choice, the question response must exactly match one of the possible choices. #### Permissions Only project administrators may update draft registrations. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated draft registration, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @param draftRegistration  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesDraftRegistrationsPartialUpdateWithHttpInfo(String nodeId, String draftId, DraftRegistration draftRegistration) throws ApiException {
        okhttp3.Call localVarCall = nodesDraftRegistrationsPartialUpdateValidateBeforeCall(nodeId, draftId, draftRegistration, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update a draft registration (asynchronously)
     * Updates a draft registration by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Draft Registrations contain Registration questions that will become part of the Registration. Answer the questions in the draft registration supplement by sending update requests until you are ready to submit the draft.  The registration supplement of a draft registration cannot be updated after the draft has been created.  When updating a draft registration, &#x60;registration_metadata&#x60; is required. It must be a dictionary with keys as question ids in the registration form, and values as nested dictionaries matching the specific format in the [registration schema](TODO: link me pls).  If a question is multiple-choice, the question response must exactly match one of the possible choices. #### Permissions Only project administrators may update draft registrations. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated draft registration, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param draftId The unique identifier of the draft registration. (required)
     * @param draftRegistration  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesDraftRegistrationsPartialUpdateAsync(String nodeId, String draftId, DraftRegistration draftRegistration, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesDraftRegistrationsPartialUpdateValidateBeforeCall(nodeId, draftId, draftRegistration, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesFilesList
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesFilesListCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/files/{provider}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "provider" + "}", localVarApiClient.escapeString(provider.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesFilesListValidateBeforeCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesFilesList(Async)");
        }

        // verify the required parameter 'provider' is set
        if (provider == null) {
            throw new ApiException("Missing the required parameter 'provider' when calling nodesFilesList(Async)");
        }

        return nodesFilesListCall(nodeId, provider, _callback);

    }

    /**
     * List all node files
     * List of all the files/folders that are attached to your project for a given storage provider. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of files. Each resource in the array is a separate file object and contains the full representation of the file.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  #### Filtering  You can optionally request that the response only include files that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/files/osfstorage/?filter[kind]&#x3D;file  Node files may be filtered by &#x60;id&#x60;, &#x60;name&#x60;, &#x60;node&#x60;, &#x60;kind&#x60;, &#x60;path&#x60;, &#x60;provider&#x60;, &#x60;size&#x60;, and &#x60;last_touched&#x60;.  ### Waterbutler API actions  Files can be modified through the Waterbutler API routes found in &#x60;links&#x60; (&#x60;new_folder&#x60;, &#x60;move&#x60;, &#x60;upload&#x60;, &#x60;download&#x60;, and &#x60;delete&#x60;).  #### Download (files)  To download a file, issue a GET request against the download link. The response will have the Content-Disposition header set, which will will trigger a download in a browser.  #### Create Subfolder (folders)  You can create a subfolder of an existing folder by issuing a PUT request against the new_folder link. The ?kind&#x3D;folder portion of the query parameter is already included in the new_folder link. The name of the new subfolder should be provided in the name query parameter. The response will contain a WaterButler folder entity. If a folder with that name already exists in the parent directory, the server will return a 409 Conflict error response.  #### Upload New File (folders)  To upload a file to a folder, issue a PUT request to the folder&#39;s upload link with the raw file data in the request body, and the kind and name query parameters set to &#39;file&#39; and the desired name of the file. The response will contain a WaterButler file entity that describes the new file. If a file with the same name already exists in the folder, the server will return a 409 Conflict error response.  #### Update Existing File (file)  To update an existing file, issue a PUT request to the file&#39;s upload link with the raw file data in the request body and the kind query parameter set to \&quot;file\&quot;. The update action will create a new version of the file. The response will contain a WaterButler file entity that describes the updated file.  #### Rename (files, folders)  To rename a file or folder, issue a POST request to the move link with the action body parameter set to \&quot;rename\&quot; and the rename body parameter set to the desired name. The response will contain either a folder entity or file entity with the new name.  #### Move &amp; Copy (files, folders)  Move and copy actions both use the same request structure, a POST to the move url, but with different values for the action body parameters. The path parameter is also required and should be the OSF path attribute of the folder being written to. The rename and conflict parameters are optional. If you wish to change the name of the file or folder at its destination, set the rename parameter to the new name. The conflict param governs how name clashes are resolved. Possible values are replace and keep. replace is the default and will overwrite the file that already exists in the target folder. keep will attempt to keep both by adding a suffix to the new file&#39;s name until it no longer conflicts. The suffix will be &#39; (x)&#39; where x is a increasing integer starting from 1. This behavior is intended to mimic that of the OS X Finder. The response will contain either a folder entity or file entity with the new name. Files and folders can also be moved between nodes and providers. The resource parameter is the id of the node under which the file/folder should be moved. It must agree with the path parameter, that is the path must identify a valid folder under the node identified by resource. Likewise, the provider parameter may be used to move the file/folder to another storage provider, but both the resource and path parameters must belong to a node and folder already extant on that provider. Both resource and provider default to the current node and providers. If a moved/copied file is overwriting an existing file, a 200 OK response will be returned. Otherwise, a 201 Created will be returned.  #### Delete (file, folders)  To delete a file or folder send a DELETE request to the delete link. Nothing will be returned in the response body.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @return List&lt;ModelFile&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ModelFile> nodesFilesList(String nodeId, String provider) throws ApiException {
        ApiResponse<List<ModelFile>> localVarResp = nodesFilesListWithHttpInfo(nodeId, provider);
        return localVarResp.getData();
    }

    /**
     * List all node files
     * List of all the files/folders that are attached to your project for a given storage provider. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of files. Each resource in the array is a separate file object and contains the full representation of the file.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  #### Filtering  You can optionally request that the response only include files that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/files/osfstorage/?filter[kind]&#x3D;file  Node files may be filtered by &#x60;id&#x60;, &#x60;name&#x60;, &#x60;node&#x60;, &#x60;kind&#x60;, &#x60;path&#x60;, &#x60;provider&#x60;, &#x60;size&#x60;, and &#x60;last_touched&#x60;.  ### Waterbutler API actions  Files can be modified through the Waterbutler API routes found in &#x60;links&#x60; (&#x60;new_folder&#x60;, &#x60;move&#x60;, &#x60;upload&#x60;, &#x60;download&#x60;, and &#x60;delete&#x60;).  #### Download (files)  To download a file, issue a GET request against the download link. The response will have the Content-Disposition header set, which will will trigger a download in a browser.  #### Create Subfolder (folders)  You can create a subfolder of an existing folder by issuing a PUT request against the new_folder link. The ?kind&#x3D;folder portion of the query parameter is already included in the new_folder link. The name of the new subfolder should be provided in the name query parameter. The response will contain a WaterButler folder entity. If a folder with that name already exists in the parent directory, the server will return a 409 Conflict error response.  #### Upload New File (folders)  To upload a file to a folder, issue a PUT request to the folder&#39;s upload link with the raw file data in the request body, and the kind and name query parameters set to &#39;file&#39; and the desired name of the file. The response will contain a WaterButler file entity that describes the new file. If a file with the same name already exists in the folder, the server will return a 409 Conflict error response.  #### Update Existing File (file)  To update an existing file, issue a PUT request to the file&#39;s upload link with the raw file data in the request body and the kind query parameter set to \&quot;file\&quot;. The update action will create a new version of the file. The response will contain a WaterButler file entity that describes the updated file.  #### Rename (files, folders)  To rename a file or folder, issue a POST request to the move link with the action body parameter set to \&quot;rename\&quot; and the rename body parameter set to the desired name. The response will contain either a folder entity or file entity with the new name.  #### Move &amp; Copy (files, folders)  Move and copy actions both use the same request structure, a POST to the move url, but with different values for the action body parameters. The path parameter is also required and should be the OSF path attribute of the folder being written to. The rename and conflict parameters are optional. If you wish to change the name of the file or folder at its destination, set the rename parameter to the new name. The conflict param governs how name clashes are resolved. Possible values are replace and keep. replace is the default and will overwrite the file that already exists in the target folder. keep will attempt to keep both by adding a suffix to the new file&#39;s name until it no longer conflicts. The suffix will be &#39; (x)&#39; where x is a increasing integer starting from 1. This behavior is intended to mimic that of the OS X Finder. The response will contain either a folder entity or file entity with the new name. Files and folders can also be moved between nodes and providers. The resource parameter is the id of the node under which the file/folder should be moved. It must agree with the path parameter, that is the path must identify a valid folder under the node identified by resource. Likewise, the provider parameter may be used to move the file/folder to another storage provider, but both the resource and path parameters must belong to a node and folder already extant on that provider. Both resource and provider default to the current node and providers. If a moved/copied file is overwriting an existing file, a 200 OK response will be returned. Otherwise, a 201 Created will be returned.  #### Delete (file, folders)  To delete a file or folder send a DELETE request to the delete link. Nothing will be returned in the response body.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @return ApiResponse&lt;List&lt;ModelFile&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ModelFile>> nodesFilesListWithHttpInfo(String nodeId, String provider) throws ApiException {
        okhttp3.Call localVarCall = nodesFilesListValidateBeforeCall(nodeId, provider, null);
        Type localVarReturnType = new TypeToken<List<ModelFile>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all node files (asynchronously)
     * List of all the files/folders that are attached to your project for a given storage provider. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of files. Each resource in the array is a separate file object and contains the full representation of the file.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  #### Filtering  You can optionally request that the response only include files that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/files/osfstorage/?filter[kind]&#x3D;file  Node files may be filtered by &#x60;id&#x60;, &#x60;name&#x60;, &#x60;node&#x60;, &#x60;kind&#x60;, &#x60;path&#x60;, &#x60;provider&#x60;, &#x60;size&#x60;, and &#x60;last_touched&#x60;.  ### Waterbutler API actions  Files can be modified through the Waterbutler API routes found in &#x60;links&#x60; (&#x60;new_folder&#x60;, &#x60;move&#x60;, &#x60;upload&#x60;, &#x60;download&#x60;, and &#x60;delete&#x60;).  #### Download (files)  To download a file, issue a GET request against the download link. The response will have the Content-Disposition header set, which will will trigger a download in a browser.  #### Create Subfolder (folders)  You can create a subfolder of an existing folder by issuing a PUT request against the new_folder link. The ?kind&#x3D;folder portion of the query parameter is already included in the new_folder link. The name of the new subfolder should be provided in the name query parameter. The response will contain a WaterButler folder entity. If a folder with that name already exists in the parent directory, the server will return a 409 Conflict error response.  #### Upload New File (folders)  To upload a file to a folder, issue a PUT request to the folder&#39;s upload link with the raw file data in the request body, and the kind and name query parameters set to &#39;file&#39; and the desired name of the file. The response will contain a WaterButler file entity that describes the new file. If a file with the same name already exists in the folder, the server will return a 409 Conflict error response.  #### Update Existing File (file)  To update an existing file, issue a PUT request to the file&#39;s upload link with the raw file data in the request body and the kind query parameter set to \&quot;file\&quot;. The update action will create a new version of the file. The response will contain a WaterButler file entity that describes the updated file.  #### Rename (files, folders)  To rename a file or folder, issue a POST request to the move link with the action body parameter set to \&quot;rename\&quot; and the rename body parameter set to the desired name. The response will contain either a folder entity or file entity with the new name.  #### Move &amp; Copy (files, folders)  Move and copy actions both use the same request structure, a POST to the move url, but with different values for the action body parameters. The path parameter is also required and should be the OSF path attribute of the folder being written to. The rename and conflict parameters are optional. If you wish to change the name of the file or folder at its destination, set the rename parameter to the new name. The conflict param governs how name clashes are resolved. Possible values are replace and keep. replace is the default and will overwrite the file that already exists in the target folder. keep will attempt to keep both by adding a suffix to the new file&#39;s name until it no longer conflicts. The suffix will be &#39; (x)&#39; where x is a increasing integer starting from 1. This behavior is intended to mimic that of the OS X Finder. The response will contain either a folder entity or file entity with the new name. Files and folders can also be moved between nodes and providers. The resource parameter is the id of the node under which the file/folder should be moved. It must agree with the path parameter, that is the path must identify a valid folder under the node identified by resource. Likewise, the provider parameter may be used to move the file/folder to another storage provider, but both the resource and path parameters must belong to a node and folder already extant on that provider. Both resource and provider default to the current node and providers. If a moved/copied file is overwriting an existing file, a 200 OK response will be returned. Otherwise, a 201 Created will be returned.  #### Delete (file, folders)  To delete a file or folder send a DELETE request to the delete link. Nothing will be returned in the response body.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesFilesListAsync(String nodeId, String provider, final ApiCallback<List<ModelFile>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesFilesListValidateBeforeCall(nodeId, provider, _callback);
        Type localVarReturnType = new TypeToken<List<ModelFile>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesFilesRead
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param path The unique identifier of the file path. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesFilesReadCall(String nodeId, String provider, String path, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/files/{provider}/{path}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "provider" + "}", localVarApiClient.escapeString(provider.toString()))
            .replace("{" + "path" + "}", localVarApiClient.escapeString(path.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesFilesReadValidateBeforeCall(String nodeId, String provider, String path, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesFilesRead(Async)");
        }

        // verify the required parameter 'provider' is set
        if (provider == null) {
            throw new ApiException("Missing the required parameter 'provider' when calling nodesFilesRead(Async)");
        }

        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling nodesFilesRead(Async)");
        }

        return nodesFilesReadCall(nodeId, provider, path, _callback);

    }

    /**
     * Retrieve a file
     * Retrieves the details of a file attached to given node (project or component) for the given storage provider. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested file object, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param path The unique identifier of the file path. (required)
     * @return ModelFile
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelFile nodesFilesRead(String nodeId, String provider, String path) throws ApiException {
        ApiResponse<ModelFile> localVarResp = nodesFilesReadWithHttpInfo(nodeId, provider, path);
        return localVarResp.getData();
    }

    /**
     * Retrieve a file
     * Retrieves the details of a file attached to given node (project or component) for the given storage provider. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested file object, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param path The unique identifier of the file path. (required)
     * @return ApiResponse&lt;ModelFile&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelFile> nodesFilesReadWithHttpInfo(String nodeId, String provider, String path) throws ApiException {
        okhttp3.Call localVarCall = nodesFilesReadValidateBeforeCall(nodeId, provider, path, null);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a file (asynchronously)
     * Retrieves the details of a file attached to given node (project or component) for the given storage provider. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested file object, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param path The unique identifier of the file path. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesFilesReadAsync(String nodeId, String provider, String path, final ApiCallback<ModelFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesFilesReadValidateBeforeCall(nodeId, provider, path, _callback);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesForksCreate
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesForksCreateCall(String nodeId, Node node, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = node;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/forks/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesForksCreateValidateBeforeCall(String nodeId, Node node, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesForksCreate(Async)");
        }

        // verify the required parameter 'node' is set
        if (node == null) {
            throw new ApiException("Missing the required parameter 'node' when calling nodesForksCreate(Async)");
        }

        return nodesForksCreateCall(nodeId, node, _callback);

    }

    /**
     * Create a fork of this node
     * Creates a fork of the given node.  Forking a project creates a copy of an existing node and all of its contents. The fork always points back to the original node, forming a network of nodes.  You might use a fork to copy another&#39;s work to build on and extend. For example, a professor may create an OSF project of materials for individual student use. Each student forks the project to have his or her own copy of the materials to start his/her own work.  When creating a fork, your fork will only contain public components of the current node and components for which you are a contributor. Private components that you do not have access to will not be forked. #### Required There are no required attributes when creating a fork, as all of the forked node&#39;s attributes will be copied from the current node.  The &#x60;title&#x60; field is optional, with the default title being \&quot;Fork of \&quot; prepended to the current node&#39;s title. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the complete srepresentation of the forked node, if the request is successful. If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public void nodesForksCreate(String nodeId, Node node) throws ApiException {
        nodesForksCreateWithHttpInfo(nodeId, node);
    }

    /**
     * Create a fork of this node
     * Creates a fork of the given node.  Forking a project creates a copy of an existing node and all of its contents. The fork always points back to the original node, forming a network of nodes.  You might use a fork to copy another&#39;s work to build on and extend. For example, a professor may create an OSF project of materials for individual student use. Each student forks the project to have his or her own copy of the materials to start his/her own work.  When creating a fork, your fork will only contain public components of the current node and components for which you are a contributor. Private components that you do not have access to will not be forked. #### Required There are no required attributes when creating a fork, as all of the forked node&#39;s attributes will be copied from the current node.  The &#x60;title&#x60; field is optional, with the default title being \&quot;Fork of \&quot; prepended to the current node&#39;s title. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the complete srepresentation of the forked node, if the request is successful. If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesForksCreateWithHttpInfo(String nodeId, Node node) throws ApiException {
        okhttp3.Call localVarCall = nodesForksCreateValidateBeforeCall(nodeId, node, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create a fork of this node (asynchronously)
     * Creates a fork of the given node.  Forking a project creates a copy of an existing node and all of its contents. The fork always points back to the original node, forming a network of nodes.  You might use a fork to copy another&#39;s work to build on and extend. For example, a professor may create an OSF project of materials for individual student use. Each student forks the project to have his or her own copy of the materials to start his/her own work.  When creating a fork, your fork will only contain public components of the current node and components for which you are a contributor. Private components that you do not have access to will not be forked. #### Required There are no required attributes when creating a fork, as all of the forked node&#39;s attributes will be copied from the current node.  The &#x60;title&#x60; field is optional, with the default title being \&quot;Fork of \&quot; prepended to the current node&#39;s title. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the complete srepresentation of the forked node, if the request is successful. If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param node  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesForksCreateAsync(String nodeId, Node node, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesForksCreateValidateBeforeCall(nodeId, node, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesForksList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesForksListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/forks/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesForksListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesForksList(Async)");
        }

        return nodesForksListCall(nodeId, _callback);

    }

    /**
     * List all forks of this node
     *  A paginated list of the current node&#39;s forks. The returned fork nodes are sorted by their &#x60;forked_date&#x60;, with the most recently forked nodes appearing first.  Forking a project creates a copy of an existing node and all of its contents. The fork always points back to the original node, forming a network of nodes. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 forked nodes. If the current node has zero forked nodes, the &#x60;data&#x60; key will contain an empty array. Each resource in the array is a separate node object and contains the full representation of the forked node, meaning additional requests to the forked node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Node&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Node> nodesForksList(String nodeId) throws ApiException {
        ApiResponse<List<Node>> localVarResp = nodesForksListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all forks of this node
     *  A paginated list of the current node&#39;s forks. The returned fork nodes are sorted by their &#x60;forked_date&#x60;, with the most recently forked nodes appearing first.  Forking a project creates a copy of an existing node and all of its contents. The fork always points back to the original node, forming a network of nodes. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 forked nodes. If the current node has zero forked nodes, the &#x60;data&#x60; key will contain an empty array. Each resource in the array is a separate node object and contains the full representation of the forked node, meaning additional requests to the forked node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Node&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Node>> nodesForksListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesForksListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all forks of this node (asynchronously)
     *  A paginated list of the current node&#39;s forks. The returned fork nodes are sorted by their &#x60;forked_date&#x60;, with the most recently forked nodes appearing first.  Forking a project creates a copy of an existing node and all of its contents. The fork always points back to the original node, forming a network of nodes. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 forked nodes. If the current node has zero forked nodes, the &#x60;data&#x60; key will contain an empty array. Each resource in the array is a separate node object and contains the full representation of the forked node, meaning additional requests to the forked node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesForksListAsync(String nodeId, final ApiCallback<List<Node>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesForksListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesIdentifiersList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesIdentifiersListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/identifiers/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesIdentifiersListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesIdentifiersList(Async)");
        }

        return nodesIdentifiersListCall(nodeId, _callback);

    }

    /**
     * List all identifiers
     * List all identifiers associated with a given node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of identifiers. Each resource in the array is a separate identifier object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering  You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/identifiers/?filter[category]&#x3D;ark  Identifiers may be filtered by their &#x60;category&#x60; e.g &#x60;ark&#x60; or &#x60;doi&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Identifier&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Identifier> nodesIdentifiersList(String nodeId) throws ApiException {
        ApiResponse<List<Identifier>> localVarResp = nodesIdentifiersListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all identifiers
     * List all identifiers associated with a given node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of identifiers. Each resource in the array is a separate identifier object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering  You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/identifiers/?filter[category]&#x3D;ark  Identifiers may be filtered by their &#x60;category&#x60; e.g &#x60;ark&#x60; or &#x60;doi&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Identifier&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Identifier>> nodesIdentifiersListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesIdentifiersListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Identifier>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all identifiers (asynchronously)
     * List all identifiers associated with a given node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of identifiers. Each resource in the array is a separate identifier object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering  You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/identifiers/?filter[category]&#x3D;ark  Identifiers may be filtered by their &#x60;category&#x60; e.g &#x60;ark&#x60; or &#x60;doi&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesIdentifiersListAsync(String nodeId, final ApiCallback<List<Identifier>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesIdentifiersListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Identifier>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesInstitutionsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesInstitutionsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/institutions/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesInstitutionsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesInstitutionsList(Async)");
        }

        return nodesInstitutionsListCall(nodeId, _callback);

    }

    /**
     * List all institutions
     * List of all institutions affiliated with this node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 affilited institutions. Each resource in the array is a separate institution object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Institution&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Institution> nodesInstitutionsList(String nodeId) throws ApiException {
        ApiResponse<List<Institution>> localVarResp = nodesInstitutionsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all institutions
     * List of all institutions affiliated with this node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 affilited institutions. Each resource in the array is a separate institution object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Institution&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Institution>> nodesInstitutionsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesInstitutionsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Institution>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all institutions (asynchronously)
     * List of all institutions affiliated with this node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 affilited institutions. Each resource in the array is a separate institution object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesInstitutionsListAsync(String nodeId, final ApiCallback<List<Institution>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesInstitutionsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Institution>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesLinkedNodesList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesLinkedNodesListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/linked_nodes/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesLinkedNodesListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesLinkedNodesList(Async)");
        }

        return nodesLinkedNodesListCall(nodeId, _callback);

    }

    /**
     * List all linked nodes
     * List of all nodes linked to the given node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 nodes. Each resource in the array is a separate node object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;registration&#x60;, or &#x60;tags&#x60;. &#x60;title&#x60;, &#x60;description&#x60;, and &#x60;category&#x60; are string fields and will be filteres using simple substring matching. &#x60;public&#x60;, &#x60;registration&#x60; are boolean and can be filtered using truthy values, such as &#x60;true&#x60;, &#x60;false&#x60;, &#x60;0&#x60;, &#x60;1&#x60;. &#x60;tags&#x60; is an array of simple strings.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Node&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Node> nodesLinkedNodesList(String nodeId) throws ApiException {
        ApiResponse<List<Node>> localVarResp = nodesLinkedNodesListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all linked nodes
     * List of all nodes linked to the given node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 nodes. Each resource in the array is a separate node object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;registration&#x60;, or &#x60;tags&#x60;. &#x60;title&#x60;, &#x60;description&#x60;, and &#x60;category&#x60; are string fields and will be filteres using simple substring matching. &#x60;public&#x60;, &#x60;registration&#x60; are boolean and can be filtered using truthy values, such as &#x60;true&#x60;, &#x60;false&#x60;, &#x60;0&#x60;, &#x60;1&#x60;. &#x60;tags&#x60; is an array of simple strings.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Node&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Node>> nodesLinkedNodesListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesLinkedNodesListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all linked nodes (asynchronously)
     * List of all nodes linked to the given node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 nodes. Each resource in the array is a separate node object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;registration&#x60;, or &#x60;tags&#x60;. &#x60;title&#x60;, &#x60;description&#x60;, and &#x60;category&#x60; are string fields and will be filteres using simple substring matching. &#x60;public&#x60;, &#x60;registration&#x60; are boolean and can be filtered using truthy values, such as &#x60;true&#x60;, &#x60;false&#x60;, &#x60;0&#x60;, &#x60;1&#x60;. &#x60;tags&#x60; is an array of simple strings.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesLinkedNodesListAsync(String nodeId, final ApiCallback<List<Node>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesLinkedNodesListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesList
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesListCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesListValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return nodesListCall(_callback);

    }

    /**
     * List all nodes
     *  A paginated list of nodes, representing projects and components, on the OSF.  The returned nodes are those which are public or which the user has access to view.  The returned nodes are sorted by their &#x60;date_modified&#x60;, with the most recently updated nodes appearing first.  Registrations cannot be accessed through this endpoint (use the [registrations](#tag/Registrations) endpoints instead). #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 nodes. Each resource in the array is a separate node object and contains the full representation of the node, meaning additional requests to a node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error. #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, &#x60;preprint&#x60;, and &#x60;contributors&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting true or false in the query will cause the match to fail.
     * @return List&lt;Node&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Node> nodesList() throws ApiException {
        ApiResponse<List<Node>> localVarResp = nodesListWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * List all nodes
     *  A paginated list of nodes, representing projects and components, on the OSF.  The returned nodes are those which are public or which the user has access to view.  The returned nodes are sorted by their &#x60;date_modified&#x60;, with the most recently updated nodes appearing first.  Registrations cannot be accessed through this endpoint (use the [registrations](#tag/Registrations) endpoints instead). #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 nodes. Each resource in the array is a separate node object and contains the full representation of the node, meaning additional requests to a node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error. #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, &#x60;preprint&#x60;, and &#x60;contributors&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting true or false in the query will cause the match to fail.
     * @return ApiResponse&lt;List&lt;Node&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Node>> nodesListWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = nodesListValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all nodes (asynchronously)
     *  A paginated list of nodes, representing projects and components, on the OSF.  The returned nodes are those which are public or which the user has access to view.  The returned nodes are sorted by their &#x60;date_modified&#x60;, with the most recently updated nodes appearing first.  Registrations cannot be accessed through this endpoint (use the [registrations](#tag/Registrations) endpoints instead). #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of 10 nodes. Each resource in the array is a separate node object and contains the full representation of the node, meaning additional requests to a node&#39;s detail view are not necessary.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  This request should never return an error. #### Filtering You can optionally request that the response only include nodes that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/?filter[title]&#x3D;reproducibility.  Nodes may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, &#x60;preprint&#x60;, and &#x60;contributors&#x60;.  Most fields are string fields and will be filtered using simple substring matching. Public and preprint are boolean fields, and can be filtered using truthy values, such as **true**, **false**, **0** or **1**. Note that quoting true or false in the query will cause the match to fail.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesListAsync(final ApiCallback<List<Node>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesListValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<Node>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesLogsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesLogsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/logs/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesLogsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesLogsList(Async)");
        }

        return nodesLogsListCall(nodeId, _callback);

    }

    /**
     * List all logs
     * A paginated list of all logs associated with a given node.  The returned logs are sorted by their &#x60;date&#x60;, with the most recents logs appearing first.  This list includes the logs of the specified node as well as the logs of that node&#39;s children to which the current user has read-only access.  #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 logs. Each resource in the array is a separate logs object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include logs that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/logs/?filter[action]&#x3D;made_private.  Nodes may be filtered by their &#x60;action&#x60;, and &#x60;date&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Log&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Log> nodesLogsList(String nodeId) throws ApiException {
        ApiResponse<List<Log>> localVarResp = nodesLogsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all logs
     * A paginated list of all logs associated with a given node.  The returned logs are sorted by their &#x60;date&#x60;, with the most recents logs appearing first.  This list includes the logs of the specified node as well as the logs of that node&#39;s children to which the current user has read-only access.  #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 logs. Each resource in the array is a separate logs object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include logs that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/logs/?filter[action]&#x3D;made_private.  Nodes may be filtered by their &#x60;action&#x60;, and &#x60;date&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Log&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Log>> nodesLogsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesLogsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Log>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all logs (asynchronously)
     * A paginated list of all logs associated with a given node.  The returned logs are sorted by their &#x60;date&#x60;, with the most recents logs appearing first.  This list includes the logs of the specified node as well as the logs of that node&#39;s children to which the current user has read-only access.  #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 logs. Each resource in the array is a separate logs object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering You can optionally request that the response only include logs that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/logs/?filter[action]&#x3D;made_private.  Nodes may be filtered by their &#x60;action&#x60;, and &#x60;date&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesLogsListAsync(String nodeId, final ApiCallback<List<Log>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesLogsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Log>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesNodeAddonUpdate
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesNodeAddonUpdateCall(String nodeId, String provider, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/addons/{provider}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "provider" + "}", localVarApiClient.escapeString(provider.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesNodeAddonUpdateValidateBeforeCall(String nodeId, String provider, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesNodeAddonUpdate(Async)");
        }

        // verify the required parameter 'provider' is set
        if (provider == null) {
            throw new ApiException("Missing the required parameter 'provider' when calling nodesNodeAddonUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling nodesNodeAddonUpdate(Async)");
        }

        return nodesNodeAddonUpdateCall(nodeId, provider, body, _callback);

    }

    /**
     * Update an addon
     * Updates a node addon by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Node addon can be updated with either a **PUT** or **PATCH** request. The &#x60;external_account_id&#x60;, &#x60;enabled&#x60;, and &#x60;folder_id&#x60; fields are mandatory in a **PUT**, and optional in **PATCH**. Non-string values will be accepted and stringified, however we make no promises about the stringification output.  To delete or deauthorize a node addon, issue a **PUT** with all fields set to &#x60;null&#x60; or &#x60;False&#x60;, or a **PATCH** with enabled set &#x60;False&#x60;. #### Permissions NodeSettings that are attached to public nodes will give read-only access to everyone. Private nodes require explicit read permission. Write and admin access are the same for public and private nodes. Administrators on a parent node have implicit read permissions for all child nodes. Any users with write or admin access to the node are able to deauthorize an enabled addon, but only the addon authorizer is able to change the configuration (i.e. selected folder) of an already-configured NodeSettings entity.  #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated node addon, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @param body  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public void nodesNodeAddonUpdate(String nodeId, String provider, Object body) throws ApiException {
        nodesNodeAddonUpdateWithHttpInfo(nodeId, provider, body);
    }

    /**
     * Update an addon
     * Updates a node addon by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Node addon can be updated with either a **PUT** or **PATCH** request. The &#x60;external_account_id&#x60;, &#x60;enabled&#x60;, and &#x60;folder_id&#x60; fields are mandatory in a **PUT**, and optional in **PATCH**. Non-string values will be accepted and stringified, however we make no promises about the stringification output.  To delete or deauthorize a node addon, issue a **PUT** with all fields set to &#x60;null&#x60; or &#x60;False&#x60;, or a **PATCH** with enabled set &#x60;False&#x60;. #### Permissions NodeSettings that are attached to public nodes will give read-only access to everyone. Private nodes require explicit read permission. Write and admin access are the same for public and private nodes. Administrators on a parent node have implicit read permissions for all child nodes. Any users with write or admin access to the node are able to deauthorize an enabled addon, but only the addon authorizer is able to change the configuration (i.e. selected folder) of an already-configured NodeSettings entity.  #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated node addon, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @param body  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesNodeAddonUpdateWithHttpInfo(String nodeId, String provider, Object body) throws ApiException {
        okhttp3.Call localVarCall = nodesNodeAddonUpdateValidateBeforeCall(nodeId, provider, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update an addon (asynchronously)
     * Updates a node addon by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Node addon can be updated with either a **PUT** or **PATCH** request. The &#x60;external_account_id&#x60;, &#x60;enabled&#x60;, and &#x60;folder_id&#x60; fields are mandatory in a **PUT**, and optional in **PATCH**. Non-string values will be accepted and stringified, however we make no promises about the stringification output.  To delete or deauthorize a node addon, issue a **PUT** with all fields set to &#x60;null&#x60; or &#x60;False&#x60;, or a **PATCH** with enabled set &#x60;False&#x60;. #### Permissions NodeSettings that are attached to public nodes will give read-only access to everyone. Private nodes require explicit read permission. Write and admin access are the same for public and private nodes. Administrators on a parent node have implicit read permissions for all child nodes. Any users with write or admin access to the node are able to deauthorize an enabled addon, but only the addon authorizer is able to change the configuration (i.e. selected folder) of an already-configured NodeSettings entity.  #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated node addon, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the addon. (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesNodeAddonUpdateAsync(String nodeId, String provider, Object body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesNodeAddonUpdateValidateBeforeCall(nodeId, provider, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesPartialUpdate
     * @param nodeId The unique identifier of the node. (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesPartialUpdateCall(String nodeId, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesPartialUpdateValidateBeforeCall(String nodeId, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesPartialUpdate(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling nodesPartialUpdate(Async)");
        }

        return nodesPartialUpdateCall(nodeId, body, _callback);

    }

    /**
     * Update a node
     * Updates a node by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Nodes can be updated with either a **PUT** or **PATCH** request. The &#x60;title&#x60; and &#x60;category&#x60; fields are mandatory in a **PUT** request, and optional in a **PATCH**. #### Permissions Only write contributors may update a node. Attempting to update a node for which you do not have write access will result in a **403 Forbidden** response. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param body  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public void nodesPartialUpdate(String nodeId, Object body) throws ApiException {
        nodesPartialUpdateWithHttpInfo(nodeId, body);
    }

    /**
     * Update a node
     * Updates a node by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Nodes can be updated with either a **PUT** or **PATCH** request. The &#x60;title&#x60; and &#x60;category&#x60; fields are mandatory in a **PUT** request, and optional in a **PATCH**. #### Permissions Only write contributors may update a node. Attempting to update a node for which you do not have write access will result in a **403 Forbidden** response. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param body  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> nodesPartialUpdateWithHttpInfo(String nodeId, Object body) throws ApiException {
        okhttp3.Call localVarCall = nodesPartialUpdateValidateBeforeCall(nodeId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update a node (asynchronously)
     * Updates a node by setting the values of the attributes specified in the request body. Any unspecified attributes will be left unchanged.  Nodes can be updated with either a **PUT** or **PATCH** request. The &#x60;title&#x60; and &#x60;category&#x60; fields are mandatory in a **PUT** request, and optional in a **PATCH**. #### Permissions Only write contributors may update a node. Attempting to update a node for which you do not have write access will result in a **403 Forbidden** response. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the new representation of the updated node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesPartialUpdateAsync(String nodeId, Object body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesPartialUpdateValidateBeforeCall(nodeId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesPreprintsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesPreprintsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/preprints/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesPreprintsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesPreprintsList(Async)");
        }

        return nodesPreprintsListCall(nodeId, _callback);

    }

    /**
     * List all preprints
     * A paginated list of preprints related to a given node. The returned preprints are sorted by their creation date, with the most recent preprints appearing first.  **Note: This API endpoint is under active development, and is subject to change in the future.** #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 preprints. Each resource in the array is a separate preprint object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Preprint&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Preprint> nodesPreprintsList(String nodeId) throws ApiException {
        ApiResponse<List<Preprint>> localVarResp = nodesPreprintsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all preprints
     * A paginated list of preprints related to a given node. The returned preprints are sorted by their creation date, with the most recent preprints appearing first.  **Note: This API endpoint is under active development, and is subject to change in the future.** #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 preprints. Each resource in the array is a separate preprint object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Preprint&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Preprint>> nodesPreprintsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesPreprintsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Preprint>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all preprints (asynchronously)
     * A paginated list of preprints related to a given node. The returned preprints are sorted by their creation date, with the most recent preprints appearing first.  **Note: This API endpoint is under active development, and is subject to change in the future.** #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 preprints. Each resource in the array is a separate preprint object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesPreprintsListAsync(String nodeId, final ApiCallback<List<Preprint>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesPreprintsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Preprint>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesProvidersList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesProvidersListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/files/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesProvidersListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesProvidersList(Async)");
        }

        return nodesProvidersListCall(nodeId, _callback);

    }

    /**
     * List all storage providers
     * List of all storage providers that are configured for this node  Users of the OSF may access their data on a [number of cloud-storage services](https://api.osf.io/v2/#storage-providers) that have integrations with the OSF. We call these **providers**. By default, every node has access to the OSF-provided storage but may use as many of the supported providers as desired.   #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of files. Each resource in the array is a separate file object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  Note: In the OSF filesystem model, providers are treated as folders, but with special properties that distinguish them from regular folders. Every provider folder is considered a root folder, and may not be deleted through the regular file API.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;ModelFile&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ModelFile> nodesProvidersList(String nodeId) throws ApiException {
        ApiResponse<List<ModelFile>> localVarResp = nodesProvidersListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all storage providers
     * List of all storage providers that are configured for this node  Users of the OSF may access their data on a [number of cloud-storage services](https://api.osf.io/v2/#storage-providers) that have integrations with the OSF. We call these **providers**. By default, every node has access to the OSF-provided storage but may use as many of the supported providers as desired.   #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of files. Each resource in the array is a separate file object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  Note: In the OSF filesystem model, providers are treated as folders, but with special properties that distinguish them from regular folders. Every provider folder is considered a root folder, and may not be deleted through the regular file API.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;ModelFile&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ModelFile>> nodesProvidersListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesProvidersListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<ModelFile>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all storage providers (asynchronously)
     * List of all storage providers that are configured for this node  Users of the OSF may access their data on a [number of cloud-storage services](https://api.osf.io/v2/#storage-providers) that have integrations with the OSF. We call these **providers**. By default, every node has access to the OSF-provided storage but may use as many of the supported providers as desired.   #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of files. Each resource in the array is a separate file object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  Note: In the OSF filesystem model, providers are treated as folders, but with special properties that distinguish them from regular folders. Every provider folder is considered a root folder, and may not be deleted through the regular file API.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesProvidersListAsync(String nodeId, final ApiCallback<List<ModelFile>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesProvidersListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<ModelFile>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesProvidersRead
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesProvidersReadCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/files/providers/{provider}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "provider" + "}", localVarApiClient.escapeString(provider.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesProvidersReadValidateBeforeCall(String nodeId, String provider, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesProvidersRead(Async)");
        }

        // verify the required parameter 'provider' is set
        if (provider == null) {
            throw new ApiException("Missing the required parameter 'provider' when calling nodesProvidersRead(Async)");
        }

        return nodesProvidersReadCall(nodeId, provider, _callback);

    }

    /**
     * Retrieve a storage provider
     * Retrieves the details of a storage provider enabled on this node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested file object, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @return ModelFile
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelFile nodesProvidersRead(String nodeId, String provider) throws ApiException {
        ApiResponse<ModelFile> localVarResp = nodesProvidersReadWithHttpInfo(nodeId, provider);
        return localVarResp.getData();
    }

    /**
     * Retrieve a storage provider
     * Retrieves the details of a storage provider enabled on this node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested file object, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @return ApiResponse&lt;ModelFile&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelFile> nodesProvidersReadWithHttpInfo(String nodeId, String provider) throws ApiException {
        okhttp3.Call localVarCall = nodesProvidersReadValidateBeforeCall(nodeId, provider, null);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a storage provider (asynchronously)
     * Retrieves the details of a storage provider enabled on this node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested file object, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param provider The unique identifier of the storage provider. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesProvidersReadAsync(String nodeId, String provider, final ApiCallback<ModelFile> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesProvidersReadValidateBeforeCall(nodeId, provider, _callback);
        Type localVarReturnType = new TypeToken<ModelFile>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesRead
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesReadCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesReadValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesRead(Async)");
        }

        return nodesReadCall(nodeId, _callback);

    }

    /**
     * Retrieve a node
     * Retrieves the details of a given node (project or component). #### Permissions Only project contributors may retrieve the details of a private node. Attempting to retreive a private node for which you are not a contributor will result in a **403 Forbidden** response.  Authentication is not required to view the details of a public node, as public nodes give read-only access to everyone. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @return Node
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Node nodesRead(String nodeId) throws ApiException {
        ApiResponse<Node> localVarResp = nodesReadWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * Retrieve a node
     * Retrieves the details of a given node (project or component). #### Permissions Only project contributors may retrieve the details of a private node. Attempting to retreive a private node for which you are not a contributor will result in a **403 Forbidden** response.  Authentication is not required to view the details of a public node, as public nodes give read-only access to everyone. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;Node&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Node> nodesReadWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesReadValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<Node>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a node (asynchronously)
     * Retrieves the details of a given node (project or component). #### Permissions Only project contributors may retrieve the details of a private node. Attempting to retreive a private node for which you are not a contributor will result in a **403 Forbidden** response.  Authentication is not required to view the details of a public node, as public nodes give read-only access to everyone. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested node, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesReadAsync(String nodeId, final ApiCallback<Node> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesReadValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<Node>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesRegistrationsList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesRegistrationsListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/registrations/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesRegistrationsListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesRegistrationsList(Async)");
        }

        return nodesRegistrationsListCall(nodeId, _callback);

    }

    /**
     * List all registrations
     * List of all registrations of the given node. #### Returns  Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 registrations. Each resource in the array is a separate registrations object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering  You can optionally request that the response only include registrations that match your filters by utilizing the filter query parameter, e.g. https://api.osf.io/v2/registrations/?filter[title]&#x3D;open.  Registrations may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, and &#x60;contributors&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Registration&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Registration> nodesRegistrationsList(String nodeId) throws ApiException {
        ApiResponse<List<Registration>> localVarResp = nodesRegistrationsListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all registrations
     * List of all registrations of the given node. #### Returns  Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 registrations. Each resource in the array is a separate registrations object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering  You can optionally request that the response only include registrations that match your filters by utilizing the filter query parameter, e.g. https://api.osf.io/v2/registrations/?filter[title]&#x3D;open.  Registrations may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, and &#x60;contributors&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Registration&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Registration>> nodesRegistrationsListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesRegistrationsListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Registration>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all registrations (asynchronously)
     * List of all registrations of the given node. #### Returns  Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 registrations. Each resource in the array is a separate registrations object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination). #### Filtering  You can optionally request that the response only include registrations that match your filters by utilizing the filter query parameter, e.g. https://api.osf.io/v2/registrations/?filter[title]&#x3D;open.  Registrations may be filtered by their &#x60;id&#x60;, &#x60;title&#x60;, &#x60;category&#x60;, &#x60;description&#x60;, &#x60;public&#x60;, &#x60;tags&#x60;, &#x60;date_created&#x60;, &#x60;date_modified&#x60;, &#x60;root&#x60;, &#x60;parent&#x60;, and &#x60;contributors&#x60;.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesRegistrationsListAsync(String nodeId, final ApiCallback<List<Registration>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesRegistrationsListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Registration>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesViewOnlyLinksList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesViewOnlyLinksListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/view_only_links/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesViewOnlyLinksListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesViewOnlyLinksList(Async)");
        }

        return nodesViewOnlyLinksListCall(nodeId, _callback);

    }

    /**
     * List all view only links
     * List of view only links on a node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 view only links. Each resource in the array is a view only link object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  #### Permissions  View only links on a node, public or private, are readable and writeable only by users that are administrators on the node.  #### Filtering  You can optionally request that the response only include view only links that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/view_only_links/?filter[anonymous]&#x3D;true.  View Only Links may be filtered based on their &#x60;name&#x60;, &#x60;anonymous&#x60; and &#x60;date_created&#x60; fields. Possible comparison operators include &#39;gt&#39; (greater than), &#39;gte&#39;(greater than or equal to), &#39;lt&#39; (less than) and &#39;lte&#39; (less than or equal to). The date must be in the format YYYY-MM-DD and the time is optional.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;ViewOnlyLinks&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ViewOnlyLinks> nodesViewOnlyLinksList(String nodeId) throws ApiException {
        ApiResponse<List<ViewOnlyLinks>> localVarResp = nodesViewOnlyLinksListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all view only links
     * List of view only links on a node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 view only links. Each resource in the array is a view only link object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  #### Permissions  View only links on a node, public or private, are readable and writeable only by users that are administrators on the node.  #### Filtering  You can optionally request that the response only include view only links that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/view_only_links/?filter[anonymous]&#x3D;true.  View Only Links may be filtered based on their &#x60;name&#x60;, &#x60;anonymous&#x60; and &#x60;date_created&#x60; fields. Possible comparison operators include &#39;gt&#39; (greater than), &#39;gte&#39;(greater than or equal to), &#39;lt&#39; (less than) and &#39;lte&#39; (less than or equal to). The date must be in the format YYYY-MM-DD and the time is optional.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;ViewOnlyLinks&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ViewOnlyLinks>> nodesViewOnlyLinksListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesViewOnlyLinksListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<ViewOnlyLinks>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all view only links (asynchronously)
     * List of view only links on a node. #### Returns Returns a JSON object containing &#x60;data&#x60; and &#x60;links&#x60; keys.  The &#x60;data&#x60; key contains an array of up to 10 view only links. Each resource in the array is a view only link object.  The &#x60;links&#x60; key contains a dictionary of links that can be used for [pagination](#tag/Pagination).  #### Permissions  View only links on a node, public or private, are readable and writeable only by users that are administrators on the node.  #### Filtering  You can optionally request that the response only include view only links that match your filters by utilizing the &#x60;filter&#x60; query parameter, e.g. https://api.osf.io/v2/nodes/ezcuj/view_only_links/?filter[anonymous]&#x3D;true.  View Only Links may be filtered based on their &#x60;name&#x60;, &#x60;anonymous&#x60; and &#x60;date_created&#x60; fields. Possible comparison operators include &#39;gt&#39; (greater than), &#39;gte&#39;(greater than or equal to), &#39;lt&#39; (less than) and &#39;lte&#39; (less than or equal to). The date must be in the format YYYY-MM-DD and the time is optional.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesViewOnlyLinksListAsync(String nodeId, final ApiCallback<List<ViewOnlyLinks>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesViewOnlyLinksListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<ViewOnlyLinks>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesViewOnlyLinksRead
     * @param nodeId The unique identifier of the node. (required)
     * @param linkId The unique identifier of the view only link. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesViewOnlyLinksReadCall(String nodeId, String linkId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/view_only_links/{link_id}/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "link_id" + "}", localVarApiClient.escapeString(linkId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesViewOnlyLinksReadValidateBeforeCall(String nodeId, String linkId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesViewOnlyLinksRead(Async)");
        }

        // verify the required parameter 'linkId' is set
        if (linkId == null) {
            throw new ApiException("Missing the required parameter 'linkId' when calling nodesViewOnlyLinksRead(Async)");
        }

        return nodesViewOnlyLinksReadCall(nodeId, linkId, _callback);

    }

    /**
     * Retrieve a view only link
     * Retrieves the details of a view only link on a node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested view only link, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed. #### Permissions  View only links on a node, public or private, are readable and writeable only by users that are administrators on the node.
     * @param nodeId The unique identifier of the node. (required)
     * @param linkId The unique identifier of the view only link. (required)
     * @return ViewOnlyLinks
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ViewOnlyLinks nodesViewOnlyLinksRead(String nodeId, String linkId) throws ApiException {
        ApiResponse<ViewOnlyLinks> localVarResp = nodesViewOnlyLinksReadWithHttpInfo(nodeId, linkId);
        return localVarResp.getData();
    }

    /**
     * Retrieve a view only link
     * Retrieves the details of a view only link on a node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested view only link, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed. #### Permissions  View only links on a node, public or private, are readable and writeable only by users that are administrators on the node.
     * @param nodeId The unique identifier of the node. (required)
     * @param linkId The unique identifier of the view only link. (required)
     * @return ApiResponse&lt;ViewOnlyLinks&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ViewOnlyLinks> nodesViewOnlyLinksReadWithHttpInfo(String nodeId, String linkId) throws ApiException {
        okhttp3.Call localVarCall = nodesViewOnlyLinksReadValidateBeforeCall(nodeId, linkId, null);
        Type localVarReturnType = new TypeToken<ViewOnlyLinks>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a view only link (asynchronously)
     * Retrieves the details of a view only link on a node. #### Returns Returns a JSON object with a &#x60;data&#x60; key containing the representation of the requested view only link, if the request is successful.  If the request is unsuccessful, an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed. #### Permissions  View only links on a node, public or private, are readable and writeable only by users that are administrators on the node.
     * @param nodeId The unique identifier of the node. (required)
     * @param linkId The unique identifier of the view only link. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesViewOnlyLinksReadAsync(String nodeId, String linkId, final ApiCallback<ViewOnlyLinks> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesViewOnlyLinksReadValidateBeforeCall(nodeId, linkId, _callback);
        Type localVarReturnType = new TypeToken<ViewOnlyLinks>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for nodesWikisList
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesWikisListCall(String nodeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/nodes/{node_id}/wikis/"
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call nodesWikisListValidateBeforeCall(String nodeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling nodesWikisList(Async)");
        }

        return nodesWikisListCall(nodeId, _callback);

    }

    /**
     * List all wikis
     * List of wiki pages on a node. #### Returns Paginated list of the node&#39;s current wiki page versions ordered by their date_modified. Each resource contains the full representation of the wiki, meaning additional requests to an individual wiki&#39;s detail view are not necessary.  Note that if an anonymous view_only key is being used, the user relationship will not be exposed.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed. #### Filtering Wiki pages can be filtered based on their &#x60;name&#x60; and &#x60;date_modified&#x60; fields. + &#x60;filter[name]&#x3D;&lt;Str&gt;&#x60; -- filter wiki pages by name + &#x60;filter[date_modified][comparison_operator]&#x3D;YYYY-MM-DDTH:M:S&#x60; -- filter wiki pages based on date modified.  Possible comparison operators include &#39;gt&#39; (greater than), &#39;gte&#39;(greater than or equal to), &#39;lt&#39; (less than) and &#39;lte&#39; (less than or equal to). The date must be in the format YYYY-MM-DD and the time is optional.
     * @param nodeId The unique identifier of the node. (required)
     * @return List&lt;Wiki&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<Wiki> nodesWikisList(String nodeId) throws ApiException {
        ApiResponse<List<Wiki>> localVarResp = nodesWikisListWithHttpInfo(nodeId);
        return localVarResp.getData();
    }

    /**
     * List all wikis
     * List of wiki pages on a node. #### Returns Paginated list of the node&#39;s current wiki page versions ordered by their date_modified. Each resource contains the full representation of the wiki, meaning additional requests to an individual wiki&#39;s detail view are not necessary.  Note that if an anonymous view_only key is being used, the user relationship will not be exposed.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed. #### Filtering Wiki pages can be filtered based on their &#x60;name&#x60; and &#x60;date_modified&#x60; fields. + &#x60;filter[name]&#x3D;&lt;Str&gt;&#x60; -- filter wiki pages by name + &#x60;filter[date_modified][comparison_operator]&#x3D;YYYY-MM-DDTH:M:S&#x60; -- filter wiki pages based on date modified.  Possible comparison operators include &#39;gt&#39; (greater than), &#39;gte&#39;(greater than or equal to), &#39;lt&#39; (less than) and &#39;lte&#39; (less than or equal to). The date must be in the format YYYY-MM-DD and the time is optional.
     * @param nodeId The unique identifier of the node. (required)
     * @return ApiResponse&lt;List&lt;Wiki&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Wiki>> nodesWikisListWithHttpInfo(String nodeId) throws ApiException {
        okhttp3.Call localVarCall = nodesWikisListValidateBeforeCall(nodeId, null);
        Type localVarReturnType = new TypeToken<List<Wiki>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all wikis (asynchronously)
     * List of wiki pages on a node. #### Returns Paginated list of the node&#39;s current wiki page versions ordered by their date_modified. Each resource contains the full representation of the wiki, meaning additional requests to an individual wiki&#39;s detail view are not necessary.  Note that if an anonymous view_only key is being used, the user relationship will not be exposed.  If the request is unsuccessful, a JSON object with an &#x60;errors&#x60; key containing information about the failure will be returned. Refer to the [list of error codes](#tag/Errors-and-Error-Codes) to understand why this request may have failed. #### Filtering Wiki pages can be filtered based on their &#x60;name&#x60; and &#x60;date_modified&#x60; fields. + &#x60;filter[name]&#x3D;&lt;Str&gt;&#x60; -- filter wiki pages by name + &#x60;filter[date_modified][comparison_operator]&#x3D;YYYY-MM-DDTH:M:S&#x60; -- filter wiki pages based on date modified.  Possible comparison operators include &#39;gt&#39; (greater than), &#39;gte&#39;(greater than or equal to), &#39;lt&#39; (less than) and &#39;lte&#39; (less than or equal to). The date must be in the format YYYY-MM-DD and the time is optional.
     * @param nodeId The unique identifier of the node. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call nodesWikisListAsync(String nodeId, final ApiCallback<List<Wiki>> _callback) throws ApiException {

        okhttp3.Call localVarCall = nodesWikisListValidateBeforeCall(nodeId, _callback);
        Type localVarReturnType = new TypeToken<List<Wiki>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
