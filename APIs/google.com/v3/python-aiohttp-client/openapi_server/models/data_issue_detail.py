# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class DataIssueDetail(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, data_issue_severity: str=None, data_issue_type: str=None, is_self_resolving: bool=None):
        """DataIssueDetail - a model defined in OpenAPI

        :param data_issue_severity: The data_issue_severity of this DataIssueDetail.
        :param data_issue_type: The data_issue_type of this DataIssueDetail.
        :param is_self_resolving: The is_self_resolving of this DataIssueDetail.
        """
        self.openapi_types = {
            'data_issue_severity': str,
            'data_issue_type': str,
            'is_self_resolving': bool
        }

        self.attribute_map = {
            'data_issue_severity': 'dataIssueSeverity',
            'data_issue_type': 'dataIssueType',
            'is_self_resolving': 'isSelfResolving'
        }

        self._data_issue_severity = data_issue_severity
        self._data_issue_type = data_issue_type
        self._is_self_resolving = is_self_resolving

    @classmethod
    def from_dict(cls, dikt: dict) -> 'DataIssueDetail':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The DataIssueDetail of this DataIssueDetail.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def data_issue_severity(self):
        """Gets the data_issue_severity of this DataIssueDetail.

        The severity of the data issue.

        :return: The data_issue_severity of this DataIssueDetail.
        :rtype: str
        """
        return self._data_issue_severity

    @data_issue_severity.setter
    def data_issue_severity(self, data_issue_severity):
        """Sets the data_issue_severity of this DataIssueDetail.

        The severity of the data issue.

        :param data_issue_severity: The data_issue_severity of this DataIssueDetail.
        :type data_issue_severity: str
        """
        allowed_values = ["DATA_ISSUE_SEVERITY_UNSPECIFIED", "ERROR", "WARNING", "INFO"]  # noqa: E501
        if data_issue_severity not in allowed_values:
            raise ValueError(
                "Invalid value for `data_issue_severity` ({0}), must be one of {1}"
                .format(data_issue_severity, allowed_values)
            )

        self._data_issue_severity = data_issue_severity

    @property
    def data_issue_type(self):
        """Gets the data_issue_type of this DataIssueDetail.

        The type of the data issue.

        :return: The data_issue_type of this DataIssueDetail.
        :rtype: str
        """
        return self._data_issue_type

    @data_issue_type.setter
    def data_issue_type(self, data_issue_type):
        """Sets the data_issue_type of this DataIssueDetail.

        The type of the data issue.

        :param data_issue_type: The data_issue_type of this DataIssueDetail.
        :type data_issue_type: str
        """
        allowed_values = ["FEED_DATA_ISSUE_UNSPECIFIED", "FEED_DATA_ISSUE_UNKNOWN", "NO_DATA_ISSUE", "DUPLICATE_ADDRESS", "MISSING_PHYSICAL_STREET_ADDRESS", "MISSING_STREET_NAME", "MISSING_STREET_NUMBER", "MISSING_ADDRESS", "MISSING_COUNTRY", "INVALID_POSTAL_CODE", "INVALID_POSTAL_CODE_SUFFIX", "UNEXPECTED_POSTAL_CODE_SUFFIX", "UNEXPECTED_POSTAL_CODE", "INVALID_AMENITIES", "INVALID_EMAIL_ADDRESS", "DUPLICATE_LATLONG", "LATLONG_INCONSISTENT_WITH_ADDRESS", "MISSING_LATLONG", "COULD_NOT_GEOCODE", "MISSING_HOTEL_NAME", "HOTEL_NAME_EMPTY", "INVALID_HOTEL_NAME", "HOTEL_NAME_TOO_LONG", "PARSE_ERROR_IN_XML", "UNEXPECTED_ATTRIBUTE_IN_XML", "DUPLICATE_PHONE_NUMBER", "MISSING_PHONE_NUMBER", "MISSING_VOICE_PHONE_NUMBER", "INVALID_PHONE_NUMBER_FORMAT", "INVALID_PHONE_NUMBER", "INVALID_PHONE_NUMBER_COUNTRY_CODE", "PHONE_NUMBER_TOO_LONG", "PHONE_NUMBER_TOO_SHORT", "INVALID_WEBSITE_URL", "ADWORDS_ATTRIBUTE_TOO_LONG", "BRAND_NOT_ALLOWED", "FLAGGED_DUE_TO_SUSPICIOUS_METADATA", "NOT_ENOUGH_IMAGES_PROVIDED", "IMAGE_PROCESSING_IN_PROGRESS", "CANNOT_FETCH_IMAGES", "INCOMPATIBLE_IMAGE_SIZE_OR_LOW_QUALITY", "MISSING_LANG_IN_RAW_LISTING", "IS_HOTEL", "MISSING_REQ_ATTR", "MISSING_NAME", "MISSING_LANG_IN_NAME", "VR_NAME_TOO_LONG", "TEST_PROPERTY", "NON_VR_ACCOMMODATION_TYPE_BASED_ON_LISTING_NAME", "BRAND_NAME_TOO_LONG", "MISSING_BRAND_NAME", "INVALID_REVIEW_RATING", "INVALID_CHECKIN_FORMAT", "INVALID_CHECKOUT_FORMAT"]  # noqa: E501
        if data_issue_type not in allowed_values:
            raise ValueError(
                "Invalid value for `data_issue_type` ({0}), must be one of {1}"
                .format(data_issue_type, allowed_values)
            )

        self._data_issue_type = data_issue_type

    @property
    def is_self_resolving(self):
        """Gets the is_self_resolving of this DataIssueDetail.

        Whether or not the issue is self-resolving. If true, the issue is expected to resolve itself. If false or not set, action is needed to resolve the issue. Refer to documentation on the data issue’s type for further information.

        :return: The is_self_resolving of this DataIssueDetail.
        :rtype: bool
        """
        return self._is_self_resolving

    @is_self_resolving.setter
    def is_self_resolving(self, is_self_resolving):
        """Sets the is_self_resolving of this DataIssueDetail.

        Whether or not the issue is self-resolving. If true, the issue is expected to resolve itself. If false or not set, action is needed to resolve the issue. Refer to documentation on the data issue’s type for further information.

        :param is_self_resolving: The is_self_resolving of this DataIssueDetail.
        :type is_self_resolving: bool
        """

        self._is_self_resolving = is_self_resolving
