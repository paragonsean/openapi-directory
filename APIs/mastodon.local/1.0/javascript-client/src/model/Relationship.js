/**
 * Mastodon API Specification (https://github.com/mastodon/mastodon)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: sardo@hey.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The Relationship model module.
 * @module model/Relationship
 * @version 1.0
 */
class Relationship {
    /**
     * Constructs a new <code>Relationship</code>.
     * Represents the relationship between accounts, such as following / blocking / muting / etc.
     * @alias module:model/Relationship
     * @param blockedBy {Boolean} Is this user blocking you?
     * @param blocking {Boolean} Are you blocking this user?
     * @param domainBlocking {Boolean} Are you blocking this user's domain?
     * @param endorsed {Boolean} Are you featuring this user on your profile?
     * @param followedBy {Boolean} Are you followed by this user?
     * @param following {Boolean} Are you following this user?
     * @param id {String} The account id. Cast from an integer, but not guaranteed to be a number.
     * @param muting {Boolean} Are you muting this user?
     * @param mutingNotifications {Boolean} Are you muting notifications from this user?
     * @param note {String} This user's profile bio
     * @param notifying {Boolean} Have you enabled notifications for this user?
     * @param requested {Boolean} Do you have a pending follow request for this user?
     * @param showingReblogs {Boolean} Are you receiving this user's boosts in your home timeline?
     */
    constructor(blockedBy, blocking, domainBlocking, endorsed, followedBy, following, id, muting, mutingNotifications, note, notifying, requested, showingReblogs) { 
        
        Relationship.initialize(this, blockedBy, blocking, domainBlocking, endorsed, followedBy, following, id, muting, mutingNotifications, note, notifying, requested, showingReblogs);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, blockedBy, blocking, domainBlocking, endorsed, followedBy, following, id, muting, mutingNotifications, note, notifying, requested, showingReblogs) { 
        obj['blocked_by'] = blockedBy;
        obj['blocking'] = blocking;
        obj['domain_blocking'] = domainBlocking;
        obj['endorsed'] = endorsed;
        obj['followed_by'] = followedBy;
        obj['following'] = following;
        obj['id'] = id;
        obj['muting'] = muting;
        obj['muting_notifications'] = mutingNotifications;
        obj['note'] = note;
        obj['notifying'] = notifying;
        obj['requested'] = requested;
        obj['showing_reblogs'] = showingReblogs;
    }

    /**
     * Constructs a <code>Relationship</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Relationship} obj Optional instance to populate.
     * @return {module:model/Relationship} The populated <code>Relationship</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Relationship();

            if (data.hasOwnProperty('blocked_by')) {
                obj['blocked_by'] = ApiClient.convertToType(data['blocked_by'], 'Boolean');
            }
            if (data.hasOwnProperty('blocking')) {
                obj['blocking'] = ApiClient.convertToType(data['blocking'], 'Boolean');
            }
            if (data.hasOwnProperty('domain_blocking')) {
                obj['domain_blocking'] = ApiClient.convertToType(data['domain_blocking'], 'Boolean');
            }
            if (data.hasOwnProperty('endorsed')) {
                obj['endorsed'] = ApiClient.convertToType(data['endorsed'], 'Boolean');
            }
            if (data.hasOwnProperty('followed_by')) {
                obj['followed_by'] = ApiClient.convertToType(data['followed_by'], 'Boolean');
            }
            if (data.hasOwnProperty('following')) {
                obj['following'] = ApiClient.convertToType(data['following'], 'Boolean');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('muting')) {
                obj['muting'] = ApiClient.convertToType(data['muting'], 'Boolean');
            }
            if (data.hasOwnProperty('muting_notifications')) {
                obj['muting_notifications'] = ApiClient.convertToType(data['muting_notifications'], 'Boolean');
            }
            if (data.hasOwnProperty('note')) {
                obj['note'] = ApiClient.convertToType(data['note'], 'String');
            }
            if (data.hasOwnProperty('notifying')) {
                obj['notifying'] = ApiClient.convertToType(data['notifying'], 'Boolean');
            }
            if (data.hasOwnProperty('requested')) {
                obj['requested'] = ApiClient.convertToType(data['requested'], 'Boolean');
            }
            if (data.hasOwnProperty('showing_reblogs')) {
                obj['showing_reblogs'] = ApiClient.convertToType(data['showing_reblogs'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Relationship</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Relationship</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of Relationship.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['note'] && !(typeof data['note'] === 'string' || data['note'] instanceof String)) {
            throw new Error("Expected the field `note` to be a primitive type in the JSON string but got " + data['note']);
        }

        return true;
    }


}

Relationship.RequiredProperties = ["blocked_by", "blocking", "domain_blocking", "endorsed", "followed_by", "following", "id", "muting", "muting_notifications", "note", "notifying", "requested", "showing_reblogs"];

/**
 * Is this user blocking you?
 * @member {Boolean} blocked_by
 */
Relationship.prototype['blocked_by'] = undefined;

/**
 * Are you blocking this user?
 * @member {Boolean} blocking
 */
Relationship.prototype['blocking'] = undefined;

/**
 * Are you blocking this user's domain?
 * @member {Boolean} domain_blocking
 */
Relationship.prototype['domain_blocking'] = undefined;

/**
 * Are you featuring this user on your profile?
 * @member {Boolean} endorsed
 */
Relationship.prototype['endorsed'] = undefined;

/**
 * Are you followed by this user?
 * @member {Boolean} followed_by
 */
Relationship.prototype['followed_by'] = undefined;

/**
 * Are you following this user?
 * @member {Boolean} following
 */
Relationship.prototype['following'] = undefined;

/**
 * The account id. Cast from an integer, but not guaranteed to be a number.
 * @member {String} id
 */
Relationship.prototype['id'] = undefined;

/**
 * Are you muting this user?
 * @member {Boolean} muting
 */
Relationship.prototype['muting'] = undefined;

/**
 * Are you muting notifications from this user?
 * @member {Boolean} muting_notifications
 */
Relationship.prototype['muting_notifications'] = undefined;

/**
 * This user's profile bio
 * @member {String} note
 */
Relationship.prototype['note'] = undefined;

/**
 * Have you enabled notifications for this user?
 * @member {Boolean} notifying
 */
Relationship.prototype['notifying'] = undefined;

/**
 * Do you have a pending follow request for this user?
 * @member {Boolean} requested
 */
Relationship.prototype['requested'] = undefined;

/**
 * Are you receiving this user's boosts in your home timeline?
 * @member {Boolean} showing_reblogs
 */
Relationship.prototype['showing_reblogs'] = undefined;






export default Relationship;

