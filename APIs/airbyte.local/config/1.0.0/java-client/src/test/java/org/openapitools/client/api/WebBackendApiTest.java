/*
 * Airbyte Configuration API
 * Airbyte Configuration API [https://airbyte.io](https://airbyte.io).  This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.  Here are some conventions that this API follows: * All endpoints are http POST methods. * All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params. * The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`. * For all `update` methods, the whole object must be passed in, even the fields that did not change.  Authentication (OSS): * When authenticating to the Configuration API, you must use Basic Authentication by setting the Authentication Header to Basic and base64 encoding the username and password (which are `airbyte` and `password` by default - so base64 encoding `airbyte:password` results in `YWlyYnl0ZTpwYXNzd29yZA==`). So the full header reads `'Authorization': \"Basic YWlyYnl0ZTpwYXNzd29yZA==\"` 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@airbyte.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.ConnectionIdRequestBody;
import org.openapitools.client.model.ConnectionStateType;
import org.openapitools.client.model.InvalidInputExceptionInfo;
import org.openapitools.client.model.NotFoundKnownExceptionInfo;
import org.openapitools.client.model.WebBackendCheckUpdatesRead;
import org.openapitools.client.model.WebBackendConnectionCreate;
import org.openapitools.client.model.WebBackendConnectionListRequestBody;
import org.openapitools.client.model.WebBackendConnectionRead;
import org.openapitools.client.model.WebBackendConnectionReadList;
import org.openapitools.client.model.WebBackendConnectionRequestBody;
import org.openapitools.client.model.WebBackendConnectionUpdate;
import org.openapitools.client.model.WebBackendGeographiesListResult;
import org.openapitools.client.model.WebBackendWorkspaceState;
import org.openapitools.client.model.WebBackendWorkspaceStateResult;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for WebBackendApi
 */
@Disabled
public class WebBackendApiTest {

    private final WebBackendApi api = new WebBackendApi();

    /**
     * Fetch the current state type for a connection.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getStateTypeTest() throws ApiException {
        ConnectionIdRequestBody connectionIdRequestBody = null;
        ConnectionStateType response = api.getStateType(connectionIdRequestBody);
        // TODO: test validations
    }

    /**
     * Returns a summary of source and destination definitions that could be updated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webBackendCheckUpdatesTest() throws ApiException {
        WebBackendCheckUpdatesRead response = api.webBackendCheckUpdates();
        // TODO: test validations
    }

    /**
     * Create a connection
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webBackendCreateConnectionTest() throws ApiException {
        WebBackendConnectionCreate webBackendConnectionCreate = null;
        WebBackendConnectionRead response = api.webBackendCreateConnection(webBackendConnectionCreate);
        // TODO: test validations
    }

    /**
     * Get a connection
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webBackendGetConnectionTest() throws ApiException {
        WebBackendConnectionRequestBody webBackendConnectionRequestBody = null;
        WebBackendConnectionRead response = api.webBackendGetConnection(webBackendConnectionRequestBody);
        // TODO: test validations
    }

    /**
     * Returns the current state of a workspace
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webBackendGetWorkspaceStateTest() throws ApiException {
        WebBackendWorkspaceState webBackendWorkspaceState = null;
        WebBackendWorkspaceStateResult response = api.webBackendGetWorkspaceState(webBackendWorkspaceState);
        // TODO: test validations
    }

    /**
     * Returns all non-deleted connections for a workspace.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webBackendListConnectionsForWorkspaceTest() throws ApiException {
        WebBackendConnectionListRequestBody webBackendConnectionListRequestBody = null;
        WebBackendConnectionReadList response = api.webBackendListConnectionsForWorkspace(webBackendConnectionListRequestBody);
        // TODO: test validations
    }

    /**
     * Returns available geographies can be selected to run data syncs in a particular geography. The &#39;auto&#39; entry indicates that the sync will be automatically assigned to a geography according to the platform default behavior. Entries other than &#39;auto&#39; are two-letter country codes that follow the ISO 3166-1 alpha-2 standard. 
     *
     * Returns all available geographies in which a data sync can run.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webBackendListGeographiesTest() throws ApiException {
        WebBackendGeographiesListResult response = api.webBackendListGeographies();
        // TODO: test validations
    }

    /**
     * Update a connection
     *
     * Apply a patch-style update to a connection. Only fields present on the update request body will be updated. Any operations that lack an ID will be created. Then, the newly created operationId will be applied to the connection along with the rest of the operationIds in the request body. Apply a patch-style update to a connection. Only fields present on the update request body will be updated. Note that if a catalog is present in the request body, the connection&#39;s entire catalog will be replaced with the catalog from the request. This means that to modify a single stream, the entire new catalog containing the updated stream needs to be sent. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webBackendUpdateConnectionTest() throws ApiException {
        WebBackendConnectionUpdate webBackendConnectionUpdate = null;
        WebBackendConnectionRead response = api.webBackendUpdateConnection(webBackendConnectionUpdate);
        // TODO: test validations
    }

}
