/*
 * Avaza API Documentation
 * Welcome to the autogenerated documentation & test tool for Avaza's API. <br/><br/><strong>API Security & Authentication</strong><br/>Authentication options include OAuth2 Implicit and Authorization Code flows, and Personal Access Token. All connections should be encrypted over SSL/TLS <br/><br/>You can set up and manage your api authentication credentials from within your Avaza account. (requires Administrator permissions on your Avaza account).<br/><br/> OAuth2 Authorization endpoint: https://any.avaza.com/oauth2/authorize  <br/>OAuth2 Token endpoint: https://any.avaza.com/oauth2/token<br/>Base URL for subsequent API Requests: https://api.avaza.com/ <br/><br/>Blogpost about authenticating with Avaza's API:  https://www.avaza.com/avaza-api-oauth2-authentication/ <br/>Blogpost on using Avaza's webhooks: https://www.avaza.com/avaza-api-webhook-notifications/<br/>The OAuth flow currently issues Access Tokens that last 1 day, and Refresh tokens that last 180 days<br/>The Api respects the security Roles assigned to the authenticating Avaza user and filters the data return appropriately. <br/><br><strong>Support</strong><br/>For API Support, and to request access please contact Avaza Support Team via our support chat. <br/><br/><strong>User Contributed Libraries:</strong><br/>Graciously contributed by 3rd party users like you. <br/>Note these are not tested or endorsesd by Avaza. We encourage you to review before use, and use at own risk.<br/> <ul><li> - <a target='blank' href='https://packagist.org/packages/debiprasad/oauth2-avaza'>PHP OAuth Client Package for Azava API (by Debiprasad Sahoo)</a></li></ul>
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateExpense
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:11:56.431364-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateExpense {
  public static final String SERIALIZED_NAME_AMOUNT = "Amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private Double amount;

  public static final String SERIALIZED_NAME_CURRENCY_CODE = "CurrencyCode";
  @SerializedName(SERIALIZED_NAME_CURRENCY_CODE)
  private String currencyCode;

  public static final String SERIALIZED_NAME_CUSTOMER_I_D_F_K = "CustomerIDFK";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_I_D_F_K)
  private Integer customerIDFK;

  public static final String SERIALIZED_NAME_EXCHANGE_RATE = "ExchangeRate";
  @SerializedName(SERIALIZED_NAME_EXCHANGE_RATE)
  private Double exchangeRate;

  public static final String SERIALIZED_NAME_EXPENSE_CATEGORY_I_D_F_K = "ExpenseCategoryIDFK";
  @SerializedName(SERIALIZED_NAME_EXPENSE_CATEGORY_I_D_F_K)
  private Integer expenseCategoryIDFK;

  public static final String SERIALIZED_NAME_EXPENSE_DATE = "ExpenseDate";
  @SerializedName(SERIALIZED_NAME_EXPENSE_DATE)
  private OffsetDateTime expenseDate;

  public static final String SERIALIZED_NAME_EXPENSE_I_D = "ExpenseID";
  @SerializedName(SERIALIZED_NAME_EXPENSE_I_D)
  private Long expenseID;

  public static final String SERIALIZED_NAME_EXPENSE_PAYMENT_METHOD_I_D_F_K = "ExpensePaymentMethodIDFK";
  @SerializedName(SERIALIZED_NAME_EXPENSE_PAYMENT_METHOD_I_D_F_K)
  private Integer expensePaymentMethodIDFK;

  public static final String SERIALIZED_NAME_FIELDS_TO_UPDATE = "FieldsToUpdate";
  @SerializedName(SERIALIZED_NAME_FIELDS_TO_UPDATE)
  private List<String> fieldsToUpdate = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILE_ATTACHMENT_I_DS = "FileAttachmentIDs";
  @SerializedName(SERIALIZED_NAME_FILE_ATTACHMENT_I_DS)
  private List<Long> fileAttachmentIDs = new ArrayList<>();

  public static final String SERIALIZED_NAME_GROUP_TRIP_NAME = "GroupTripName";
  @SerializedName(SERIALIZED_NAME_GROUP_TRIP_NAME)
  private String groupTripName;

  public static final String SERIALIZED_NAME_MERCHANT = "Merchant";
  @SerializedName(SERIALIZED_NAME_MERCHANT)
  private String merchant;

  public static final String SERIALIZED_NAME_MERCHANT_TAX_NUMBER = "MerchantTaxNumber";
  @SerializedName(SERIALIZED_NAME_MERCHANT_TAX_NUMBER)
  private String merchantTaxNumber;

  public static final String SERIALIZED_NAME_NOTES = "Notes";
  @SerializedName(SERIALIZED_NAME_NOTES)
  private String notes;

  public static final String SERIALIZED_NAME_PROJECT_I_D_F_K = "ProjectIDFK";
  @SerializedName(SERIALIZED_NAME_PROJECT_I_D_F_K)
  private Integer projectIDFK;

  public static final String SERIALIZED_NAME_QUANTITY = "Quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  private Double quantity;

  public static final String SERIALIZED_NAME_TASK_I_D_F_K = "TaskIDFK";
  @SerializedName(SERIALIZED_NAME_TASK_I_D_F_K)
  private Integer taskIDFK;

  public static final String SERIALIZED_NAME_TAX_I_D_F_K = "TaxIDFK";
  @SerializedName(SERIALIZED_NAME_TAX_I_D_F_K)
  private Integer taxIDFK;

  public static final String SERIALIZED_NAME_TRANSACTION_TAX_CONFIG_CODE = "TransactionTaxConfigCode";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_TAX_CONFIG_CODE)
  private String transactionTaxConfigCode;

  public static final String SERIALIZED_NAME_VERIFY_AND_SAVE = "VerifyAndSave";
  @SerializedName(SERIALIZED_NAME_VERIFY_AND_SAVE)
  private Boolean verifyAndSave;

  public static final String SERIALIZED_NAME_IS_CHARGEABLE = "isChargeable";
  @SerializedName(SERIALIZED_NAME_IS_CHARGEABLE)
  private Boolean isChargeable;

  public static final String SERIALIZED_NAME_IS_REIMBURSABLE = "isReimbursable";
  @SerializedName(SERIALIZED_NAME_IS_REIMBURSABLE)
  private Boolean isReimbursable;

  public UpdateExpense() {
  }

  public UpdateExpense amount(Double amount) {
    this.amount = amount;
    return this;
  }

  /**
   * Expense Amount (Required). Must be &amp;gt;&#x3D; 0
   * @return amount
   */
  @javax.annotation.Nullable
  public Double getAmount() {
    return amount;
  }

  public void setAmount(Double amount) {
    this.amount = amount;
  }


  public UpdateExpense currencyCode(String currencyCode) {
    this.currencyCode = currencyCode;
    return this;
  }

  /**
   * A 3-letter ISO CurrencyCode for the expense currency. (e.g. USD). If not provided, defaults to the Account base currency.
   * @return currencyCode
   */
  @javax.annotation.Nullable
  public String getCurrencyCode() {
    return currencyCode;
  }

  public void setCurrencyCode(String currencyCode) {
    this.currencyCode = currencyCode;
  }


  public UpdateExpense customerIDFK(Integer customerIDFK) {
    this.customerIDFK = customerIDFK;
    return this;
  }

  /**
   * The Avaza Customer ID to associate the Expense with.
   * @return customerIDFK
   */
  @javax.annotation.Nullable
  public Integer getCustomerIDFK() {
    return customerIDFK;
  }

  public void setCustomerIDFK(Integer customerIDFK) {
    this.customerIDFK = customerIDFK;
  }


  public UpdateExpense exchangeRate(Double exchangeRate) {
    this.exchangeRate = exchangeRate;
    return this;
  }

  /**
   * Optional (Only relevant if the expense currency is different to your account currency. If not provided we will look up the market exchange rate for you based on the expense date.) Exchange Rate &#x3D; Expense Currency Amount / Base Currency Amount (e.g. if Expense currency is in AUD, and Base Currency is in USD, Exchange Rate &#x3D; AUD $140 / USD $100 &#x3D; 1.4)
   * @return exchangeRate
   */
  @javax.annotation.Nullable
  public Double getExchangeRate() {
    return exchangeRate;
  }

  public void setExchangeRate(Double exchangeRate) {
    this.exchangeRate = exchangeRate;
  }


  public UpdateExpense expenseCategoryIDFK(Integer expenseCategoryIDFK) {
    this.expenseCategoryIDFK = expenseCategoryIDFK;
    return this;
  }

  /**
   * The expense category to link the Expense to.
   * @return expenseCategoryIDFK
   */
  @javax.annotation.Nullable
  public Integer getExpenseCategoryIDFK() {
    return expenseCategoryIDFK;
  }

  public void setExpenseCategoryIDFK(Integer expenseCategoryIDFK) {
    this.expenseCategoryIDFK = expenseCategoryIDFK;
  }


  public UpdateExpense expenseDate(OffsetDateTime expenseDate) {
    this.expenseDate = expenseDate;
    return this;
  }

  /**
   * The date of the expense entry
   * @return expenseDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExpenseDate() {
    return expenseDate;
  }

  public void setExpenseDate(OffsetDateTime expenseDate) {
    this.expenseDate = expenseDate;
  }


  public UpdateExpense expenseID(Long expenseID) {
    this.expenseID = expenseID;
    return this;
  }

  /**
   * Get expenseID
   * @return expenseID
   */
  @javax.annotation.Nonnull
  public Long getExpenseID() {
    return expenseID;
  }

  public void setExpenseID(Long expenseID) {
    this.expenseID = expenseID;
  }


  public UpdateExpense expensePaymentMethodIDFK(Integer expensePaymentMethodIDFK) {
    this.expensePaymentMethodIDFK = expensePaymentMethodIDFK;
    return this;
  }

  /**
   * (Optional) ID of Expense Payment Method.
   * @return expensePaymentMethodIDFK
   */
  @javax.annotation.Nullable
  public Integer getExpensePaymentMethodIDFK() {
    return expensePaymentMethodIDFK;
  }

  public void setExpensePaymentMethodIDFK(Integer expensePaymentMethodIDFK) {
    this.expensePaymentMethodIDFK = expensePaymentMethodIDFK;
  }


  public UpdateExpense fieldsToUpdate(List<String> fieldsToUpdate) {
    this.fieldsToUpdate = fieldsToUpdate;
    return this;
  }

  public UpdateExpense addFieldsToUpdateItem(String fieldsToUpdateItem) {
    if (this.fieldsToUpdate == null) {
      this.fieldsToUpdate = new ArrayList<>();
    }
    this.fieldsToUpdate.add(fieldsToUpdateItem);
    return this;
  }

  /**
   * Get fieldsToUpdate
   * @return fieldsToUpdate
   */
  @javax.annotation.Nonnull
  public List<String> getFieldsToUpdate() {
    return fieldsToUpdate;
  }

  public void setFieldsToUpdate(List<String> fieldsToUpdate) {
    this.fieldsToUpdate = fieldsToUpdate;
  }


  public UpdateExpense fileAttachmentIDs(List<Long> fileAttachmentIDs) {
    this.fileAttachmentIDs = fileAttachmentIDs;
    return this;
  }

  public UpdateExpense addFileAttachmentIDsItem(Long fileAttachmentIDsItem) {
    if (this.fileAttachmentIDs == null) {
      this.fileAttachmentIDs = new ArrayList<>();
    }
    this.fileAttachmentIDs.add(fileAttachmentIDsItem);
    return this;
  }

  /**
   * Array of File Attachment IDs to associate with this expense. The files need to have already been uploaded. Currently only accepts a single file.
   * @return fileAttachmentIDs
   */
  @javax.annotation.Nullable
  public List<Long> getFileAttachmentIDs() {
    return fileAttachmentIDs;
  }

  public void setFileAttachmentIDs(List<Long> fileAttachmentIDs) {
    this.fileAttachmentIDs = fileAttachmentIDs;
  }


  public UpdateExpense groupTripName(String groupTripName) {
    this.groupTripName = groupTripName;
    return this;
  }

  /**
   * Links the expense to a Grouping/Trip report. If no matching name found, creates a new Group/Trip Report name.
   * @return groupTripName
   */
  @javax.annotation.Nullable
  public String getGroupTripName() {
    return groupTripName;
  }

  public void setGroupTripName(String groupTripName) {
    this.groupTripName = groupTripName;
  }


  public UpdateExpense merchant(String merchant) {
    this.merchant = merchant;
    return this;
  }

  /**
   * The name of the merchant.
   * @return merchant
   */
  @javax.annotation.Nullable
  public String getMerchant() {
    return merchant;
  }

  public void setMerchant(String merchant) {
    this.merchant = merchant;
  }


  public UpdateExpense merchantTaxNumber(String merchantTaxNumber) {
    this.merchantTaxNumber = merchantTaxNumber;
    return this;
  }

  /**
   * A Tax number identifier for the merchant.
   * @return merchantTaxNumber
   */
  @javax.annotation.Nullable
  public String getMerchantTaxNumber() {
    return merchantTaxNumber;
  }

  public void setMerchantTaxNumber(String merchantTaxNumber) {
    this.merchantTaxNumber = merchantTaxNumber;
  }


  public UpdateExpense notes(String notes) {
    this.notes = notes;
    return this;
  }

  /**
   * Expense Notes
   * @return notes
   */
  @javax.annotation.Nullable
  public String getNotes() {
    return notes;
  }

  public void setNotes(String notes) {
    this.notes = notes;
  }


  public UpdateExpense projectIDFK(Integer projectIDFK) {
    this.projectIDFK = projectIDFK;
    return this;
  }

  /**
   * The Avaza project ID to associate the Expense with.
   * @return projectIDFK
   */
  @javax.annotation.Nullable
  public Integer getProjectIDFK() {
    return projectIDFK;
  }

  public void setProjectIDFK(Integer projectIDFK) {
    this.projectIDFK = projectIDFK;
  }


  public UpdateExpense quantity(Double quantity) {
    this.quantity = quantity;
    return this;
  }

  /**
   * Conditional - available for expenses that are assigned a unit priced based expense category. e.g Mileage
   * @return quantity
   */
  @javax.annotation.Nullable
  public Double getQuantity() {
    return quantity;
  }

  public void setQuantity(Double quantity) {
    this.quantity = quantity;
  }


  public UpdateExpense taskIDFK(Integer taskIDFK) {
    this.taskIDFK = taskIDFK;
    return this;
  }

  /**
   * (optional) TaskID of a Task to link the new Expense to. A Customer and Project must be provided also.
   * @return taskIDFK
   */
  @javax.annotation.Nullable
  public Integer getTaskIDFK() {
    return taskIDFK;
  }

  public void setTaskIDFK(Integer taskIDFK) {
    this.taskIDFK = taskIDFK;
  }


  public UpdateExpense taxIDFK(Integer taxIDFK) {
    this.taxIDFK = taxIDFK;
    return this;
  }

  /**
   * Avaza Tax ID the expense belongs to.
   * @return taxIDFK
   */
  @javax.annotation.Nullable
  public Integer getTaxIDFK() {
    return taxIDFK;
  }

  public void setTaxIDFK(Integer taxIDFK) {
    this.taxIDFK = taxIDFK;
  }


  public UpdateExpense transactionTaxConfigCode(String transactionTaxConfigCode) {
    this.transactionTaxConfigCode = transactionTaxConfigCode;
    return this;
  }

  /**
   * Optional - Enter \&quot;INC\&quot; if the tax amount is included in the expense amount otherwise enter \&quot;EX\&quot; when the amount exlcudes the tax. Defaults to \&quot;Ex\&quot;. The tax amount on the expense will be autocalculated.
   * @return transactionTaxConfigCode
   */
  @javax.annotation.Nullable
  public String getTransactionTaxConfigCode() {
    return transactionTaxConfigCode;
  }

  public void setTransactionTaxConfigCode(String transactionTaxConfigCode) {
    this.transactionTaxConfigCode = transactionTaxConfigCode;
  }


  public UpdateExpense verifyAndSave(Boolean verifyAndSave) {
    this.verifyAndSave = verifyAndSave;
    return this;
  }

  /**
   * Pass false if creating a draft expense. True otherwise.
   * @return verifyAndSave
   */
  @javax.annotation.Nullable
  public Boolean getVerifyAndSave() {
    return verifyAndSave;
  }

  public void setVerifyAndSave(Boolean verifyAndSave) {
    this.verifyAndSave = verifyAndSave;
  }


  public UpdateExpense isChargeable(Boolean isChargeable) {
    this.isChargeable = isChargeable;
    return this;
  }

  /**
   * aka Billable. Defaults to false if not provided. If set to true, a CustomerIDFK or CustomerName must be provided.
   * @return isChargeable
   */
  @javax.annotation.Nullable
  public Boolean getIsChargeable() {
    return isChargeable;
  }

  public void setIsChargeable(Boolean isChargeable) {
    this.isChargeable = isChargeable;
  }


  public UpdateExpense isReimbursable(Boolean isReimbursable) {
    this.isReimbursable = isReimbursable;
    return this;
  }

  /**
   * Defaults to false if not provided.
   * @return isReimbursable
   */
  @javax.annotation.Nullable
  public Boolean getIsReimbursable() {
    return isReimbursable;
  }

  public void setIsReimbursable(Boolean isReimbursable) {
    this.isReimbursable = isReimbursable;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateExpense updateExpense = (UpdateExpense) o;
    return Objects.equals(this.amount, updateExpense.amount) &&
        Objects.equals(this.currencyCode, updateExpense.currencyCode) &&
        Objects.equals(this.customerIDFK, updateExpense.customerIDFK) &&
        Objects.equals(this.exchangeRate, updateExpense.exchangeRate) &&
        Objects.equals(this.expenseCategoryIDFK, updateExpense.expenseCategoryIDFK) &&
        Objects.equals(this.expenseDate, updateExpense.expenseDate) &&
        Objects.equals(this.expenseID, updateExpense.expenseID) &&
        Objects.equals(this.expensePaymentMethodIDFK, updateExpense.expensePaymentMethodIDFK) &&
        Objects.equals(this.fieldsToUpdate, updateExpense.fieldsToUpdate) &&
        Objects.equals(this.fileAttachmentIDs, updateExpense.fileAttachmentIDs) &&
        Objects.equals(this.groupTripName, updateExpense.groupTripName) &&
        Objects.equals(this.merchant, updateExpense.merchant) &&
        Objects.equals(this.merchantTaxNumber, updateExpense.merchantTaxNumber) &&
        Objects.equals(this.notes, updateExpense.notes) &&
        Objects.equals(this.projectIDFK, updateExpense.projectIDFK) &&
        Objects.equals(this.quantity, updateExpense.quantity) &&
        Objects.equals(this.taskIDFK, updateExpense.taskIDFK) &&
        Objects.equals(this.taxIDFK, updateExpense.taxIDFK) &&
        Objects.equals(this.transactionTaxConfigCode, updateExpense.transactionTaxConfigCode) &&
        Objects.equals(this.verifyAndSave, updateExpense.verifyAndSave) &&
        Objects.equals(this.isChargeable, updateExpense.isChargeable) &&
        Objects.equals(this.isReimbursable, updateExpense.isReimbursable);
  }

  @Override
  public int hashCode() {
    return Objects.hash(amount, currencyCode, customerIDFK, exchangeRate, expenseCategoryIDFK, expenseDate, expenseID, expensePaymentMethodIDFK, fieldsToUpdate, fileAttachmentIDs, groupTripName, merchant, merchantTaxNumber, notes, projectIDFK, quantity, taskIDFK, taxIDFK, transactionTaxConfigCode, verifyAndSave, isChargeable, isReimbursable);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateExpense {\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    currencyCode: ").append(toIndentedString(currencyCode)).append("\n");
    sb.append("    customerIDFK: ").append(toIndentedString(customerIDFK)).append("\n");
    sb.append("    exchangeRate: ").append(toIndentedString(exchangeRate)).append("\n");
    sb.append("    expenseCategoryIDFK: ").append(toIndentedString(expenseCategoryIDFK)).append("\n");
    sb.append("    expenseDate: ").append(toIndentedString(expenseDate)).append("\n");
    sb.append("    expenseID: ").append(toIndentedString(expenseID)).append("\n");
    sb.append("    expensePaymentMethodIDFK: ").append(toIndentedString(expensePaymentMethodIDFK)).append("\n");
    sb.append("    fieldsToUpdate: ").append(toIndentedString(fieldsToUpdate)).append("\n");
    sb.append("    fileAttachmentIDs: ").append(toIndentedString(fileAttachmentIDs)).append("\n");
    sb.append("    groupTripName: ").append(toIndentedString(groupTripName)).append("\n");
    sb.append("    merchant: ").append(toIndentedString(merchant)).append("\n");
    sb.append("    merchantTaxNumber: ").append(toIndentedString(merchantTaxNumber)).append("\n");
    sb.append("    notes: ").append(toIndentedString(notes)).append("\n");
    sb.append("    projectIDFK: ").append(toIndentedString(projectIDFK)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    taskIDFK: ").append(toIndentedString(taskIDFK)).append("\n");
    sb.append("    taxIDFK: ").append(toIndentedString(taxIDFK)).append("\n");
    sb.append("    transactionTaxConfigCode: ").append(toIndentedString(transactionTaxConfigCode)).append("\n");
    sb.append("    verifyAndSave: ").append(toIndentedString(verifyAndSave)).append("\n");
    sb.append("    isChargeable: ").append(toIndentedString(isChargeable)).append("\n");
    sb.append("    isReimbursable: ").append(toIndentedString(isReimbursable)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Amount");
    openapiFields.add("CurrencyCode");
    openapiFields.add("CustomerIDFK");
    openapiFields.add("ExchangeRate");
    openapiFields.add("ExpenseCategoryIDFK");
    openapiFields.add("ExpenseDate");
    openapiFields.add("ExpenseID");
    openapiFields.add("ExpensePaymentMethodIDFK");
    openapiFields.add("FieldsToUpdate");
    openapiFields.add("FileAttachmentIDs");
    openapiFields.add("GroupTripName");
    openapiFields.add("Merchant");
    openapiFields.add("MerchantTaxNumber");
    openapiFields.add("Notes");
    openapiFields.add("ProjectIDFK");
    openapiFields.add("Quantity");
    openapiFields.add("TaskIDFK");
    openapiFields.add("TaxIDFK");
    openapiFields.add("TransactionTaxConfigCode");
    openapiFields.add("VerifyAndSave");
    openapiFields.add("isChargeable");
    openapiFields.add("isReimbursable");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ExpenseID");
    openapiRequiredFields.add("FieldsToUpdate");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateExpense
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateExpense.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateExpense is not found in the empty JSON string", UpdateExpense.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateExpense.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateExpense` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : UpdateExpense.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("CurrencyCode") != null && !jsonObj.get("CurrencyCode").isJsonNull()) && !jsonObj.get("CurrencyCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrencyCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrencyCode").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("FieldsToUpdate") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("FieldsToUpdate").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `FieldsToUpdate` to be an array in the JSON string but got `%s`", jsonObj.get("FieldsToUpdate").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("FileAttachmentIDs") != null && !jsonObj.get("FileAttachmentIDs").isJsonNull() && !jsonObj.get("FileAttachmentIDs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `FileAttachmentIDs` to be an array in the JSON string but got `%s`", jsonObj.get("FileAttachmentIDs").toString()));
      }
      if ((jsonObj.get("GroupTripName") != null && !jsonObj.get("GroupTripName").isJsonNull()) && !jsonObj.get("GroupTripName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `GroupTripName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("GroupTripName").toString()));
      }
      if ((jsonObj.get("Merchant") != null && !jsonObj.get("Merchant").isJsonNull()) && !jsonObj.get("Merchant").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Merchant` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Merchant").toString()));
      }
      if ((jsonObj.get("MerchantTaxNumber") != null && !jsonObj.get("MerchantTaxNumber").isJsonNull()) && !jsonObj.get("MerchantTaxNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MerchantTaxNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MerchantTaxNumber").toString()));
      }
      if ((jsonObj.get("Notes") != null && !jsonObj.get("Notes").isJsonNull()) && !jsonObj.get("Notes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Notes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Notes").toString()));
      }
      if ((jsonObj.get("TransactionTaxConfigCode") != null && !jsonObj.get("TransactionTaxConfigCode").isJsonNull()) && !jsonObj.get("TransactionTaxConfigCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TransactionTaxConfigCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TransactionTaxConfigCode").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateExpense.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateExpense' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateExpense> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateExpense.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateExpense>() {
           @Override
           public void write(JsonWriter out, UpdateExpense value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateExpense read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateExpense given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateExpense
   * @throws IOException if the JSON string is invalid with respect to UpdateExpense
   */
  public static UpdateExpense fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateExpense.class);
  }

  /**
   * Convert an instance of UpdateExpense to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

