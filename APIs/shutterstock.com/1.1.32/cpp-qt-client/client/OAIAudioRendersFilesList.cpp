/**
 * Shutterstock API Explorer
 * The Shutterstock API provides access to Shutterstock's library of media, as well as information about customers' accounts and the contributors that provide the media.
 *
 * The version of the OpenAPI document: 1.1.32
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAudioRendersFilesList.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAudioRendersFilesList::OAIAudioRendersFilesList(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAudioRendersFilesList::OAIAudioRendersFilesList() {
    this->initializeModel();
}

OAIAudioRendersFilesList::~OAIAudioRendersFilesList() {}

void OAIAudioRendersFilesList::initializeModel() {

    m_bits_sample_isSet = false;
    m_bits_sample_isValid = false;

    m_content_type_isSet = false;
    m_content_type_isValid = false;

    m_download_url_isSet = false;
    m_download_url_isValid = false;

    m_filename_isSet = false;
    m_filename_isValid = false;

    m_frequency_hz_isSet = false;
    m_frequency_hz_isValid = false;

    m_kbits_second_isSet = false;
    m_kbits_second_isValid = false;

    m_size_bytes_isSet = false;
    m_size_bytes_isValid = false;

    m_tracks_isSet = false;
    m_tracks_isValid = false;
}

void OAIAudioRendersFilesList::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAudioRendersFilesList::fromJsonObject(QJsonObject json) {

    m_bits_sample_isValid = ::OpenAPI::fromJsonValue(m_bits_sample, json[QString("bits_sample")]);
    m_bits_sample_isSet = !json[QString("bits_sample")].isNull() && m_bits_sample_isValid;

    m_content_type_isValid = ::OpenAPI::fromJsonValue(m_content_type, json[QString("content_type")]);
    m_content_type_isSet = !json[QString("content_type")].isNull() && m_content_type_isValid;

    m_download_url_isValid = ::OpenAPI::fromJsonValue(m_download_url, json[QString("download_url")]);
    m_download_url_isSet = !json[QString("download_url")].isNull() && m_download_url_isValid;

    m_filename_isValid = ::OpenAPI::fromJsonValue(m_filename, json[QString("filename")]);
    m_filename_isSet = !json[QString("filename")].isNull() && m_filename_isValid;

    m_frequency_hz_isValid = ::OpenAPI::fromJsonValue(m_frequency_hz, json[QString("frequency_hz")]);
    m_frequency_hz_isSet = !json[QString("frequency_hz")].isNull() && m_frequency_hz_isValid;

    m_kbits_second_isValid = ::OpenAPI::fromJsonValue(m_kbits_second, json[QString("kbits_second")]);
    m_kbits_second_isSet = !json[QString("kbits_second")].isNull() && m_kbits_second_isValid;

    m_size_bytes_isValid = ::OpenAPI::fromJsonValue(m_size_bytes, json[QString("size_bytes")]);
    m_size_bytes_isSet = !json[QString("size_bytes")].isNull() && m_size_bytes_isValid;

    m_tracks_isValid = ::OpenAPI::fromJsonValue(m_tracks, json[QString("tracks")]);
    m_tracks_isSet = !json[QString("tracks")].isNull() && m_tracks_isValid;
}

QString OAIAudioRendersFilesList::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAudioRendersFilesList::asJsonObject() const {
    QJsonObject obj;
    if (m_bits_sample_isSet) {
        obj.insert(QString("bits_sample"), ::OpenAPI::toJsonValue(m_bits_sample));
    }
    if (m_content_type_isSet) {
        obj.insert(QString("content_type"), ::OpenAPI::toJsonValue(m_content_type));
    }
    if (m_download_url_isSet) {
        obj.insert(QString("download_url"), ::OpenAPI::toJsonValue(m_download_url));
    }
    if (m_filename_isSet) {
        obj.insert(QString("filename"), ::OpenAPI::toJsonValue(m_filename));
    }
    if (m_frequency_hz_isSet) {
        obj.insert(QString("frequency_hz"), ::OpenAPI::toJsonValue(m_frequency_hz));
    }
    if (m_kbits_second_isSet) {
        obj.insert(QString("kbits_second"), ::OpenAPI::toJsonValue(m_kbits_second));
    }
    if (m_size_bytes_isSet) {
        obj.insert(QString("size_bytes"), ::OpenAPI::toJsonValue(m_size_bytes));
    }
    if (m_tracks.size() > 0) {
        obj.insert(QString("tracks"), ::OpenAPI::toJsonValue(m_tracks));
    }
    return obj;
}

double OAIAudioRendersFilesList::getBitsSample() const {
    return m_bits_sample;
}
void OAIAudioRendersFilesList::setBitsSample(const double &bits_sample) {
    m_bits_sample = bits_sample;
    m_bits_sample_isSet = true;
}

bool OAIAudioRendersFilesList::is_bits_sample_Set() const{
    return m_bits_sample_isSet;
}

bool OAIAudioRendersFilesList::is_bits_sample_Valid() const{
    return m_bits_sample_isValid;
}

QString OAIAudioRendersFilesList::getContentType() const {
    return m_content_type;
}
void OAIAudioRendersFilesList::setContentType(const QString &content_type) {
    m_content_type = content_type;
    m_content_type_isSet = true;
}

bool OAIAudioRendersFilesList::is_content_type_Set() const{
    return m_content_type_isSet;
}

bool OAIAudioRendersFilesList::is_content_type_Valid() const{
    return m_content_type_isValid;
}

QString OAIAudioRendersFilesList::getDownloadUrl() const {
    return m_download_url;
}
void OAIAudioRendersFilesList::setDownloadUrl(const QString &download_url) {
    m_download_url = download_url;
    m_download_url_isSet = true;
}

bool OAIAudioRendersFilesList::is_download_url_Set() const{
    return m_download_url_isSet;
}

bool OAIAudioRendersFilesList::is_download_url_Valid() const{
    return m_download_url_isValid;
}

QString OAIAudioRendersFilesList::getFilename() const {
    return m_filename;
}
void OAIAudioRendersFilesList::setFilename(const QString &filename) {
    m_filename = filename;
    m_filename_isSet = true;
}

bool OAIAudioRendersFilesList::is_filename_Set() const{
    return m_filename_isSet;
}

bool OAIAudioRendersFilesList::is_filename_Valid() const{
    return m_filename_isValid;
}

double OAIAudioRendersFilesList::getFrequencyHz() const {
    return m_frequency_hz;
}
void OAIAudioRendersFilesList::setFrequencyHz(const double &frequency_hz) {
    m_frequency_hz = frequency_hz;
    m_frequency_hz_isSet = true;
}

bool OAIAudioRendersFilesList::is_frequency_hz_Set() const{
    return m_frequency_hz_isSet;
}

bool OAIAudioRendersFilesList::is_frequency_hz_Valid() const{
    return m_frequency_hz_isValid;
}

double OAIAudioRendersFilesList::getKbitsSecond() const {
    return m_kbits_second;
}
void OAIAudioRendersFilesList::setKbitsSecond(const double &kbits_second) {
    m_kbits_second = kbits_second;
    m_kbits_second_isSet = true;
}

bool OAIAudioRendersFilesList::is_kbits_second_Set() const{
    return m_kbits_second_isSet;
}

bool OAIAudioRendersFilesList::is_kbits_second_Valid() const{
    return m_kbits_second_isValid;
}

double OAIAudioRendersFilesList::getSizeBytes() const {
    return m_size_bytes;
}
void OAIAudioRendersFilesList::setSizeBytes(const double &size_bytes) {
    m_size_bytes = size_bytes;
    m_size_bytes_isSet = true;
}

bool OAIAudioRendersFilesList::is_size_bytes_Set() const{
    return m_size_bytes_isSet;
}

bool OAIAudioRendersFilesList::is_size_bytes_Valid() const{
    return m_size_bytes_isValid;
}

QList<QString> OAIAudioRendersFilesList::getTracks() const {
    return m_tracks;
}
void OAIAudioRendersFilesList::setTracks(const QList<QString> &tracks) {
    m_tracks = tracks;
    m_tracks_isSet = true;
}

bool OAIAudioRendersFilesList::is_tracks_Set() const{
    return m_tracks_isSet;
}

bool OAIAudioRendersFilesList::is_tracks_Valid() const{
    return m_tracks_isValid;
}

bool OAIAudioRendersFilesList::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_bits_sample_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_download_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_filename_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_frequency_hz_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kbits_second_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_bytes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tracks.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAudioRendersFilesList::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_bits_sample_isValid && m_content_type_isValid && m_download_url_isValid && m_filename_isValid && m_frequency_hz_isValid && m_kbits_second_isValid && m_size_bytes_isValid && m_tracks_isValid && true;
}

} // namespace OpenAPI
