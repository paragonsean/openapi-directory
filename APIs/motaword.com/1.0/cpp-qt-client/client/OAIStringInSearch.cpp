/**
 * MotaWord API
 * Use MotaWord API to post and track your translation projects.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIStringInSearch.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIStringInSearch::OAIStringInSearch(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIStringInSearch::OAIStringInSearch() {
    this->initializeModel();
}

OAIStringInSearch::~OAIStringInSearch() {}

void OAIStringInSearch::initializeModel() {

    m_file_id_isSet = false;
    m_file_id_isValid = false;

    m_internal_project_id_isSet = false;
    m_internal_project_id_isValid = false;

    m_last_updated_isSet = false;
    m_last_updated_isValid = false;

    m_project_id_isSet = false;
    m_project_id_isValid = false;

    m_search_score_isSet = false;
    m_search_score_isValid = false;

    m_source_isSet = false;
    m_source_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_string_id_isSet = false;
    m_string_id_isValid = false;

    m_target_isSet = false;
    m_target_isValid = false;

    m_targets_isSet = false;
    m_targets_isValid = false;

    m_tm_name_isSet = false;
    m_tm_name_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIStringInSearch::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIStringInSearch::fromJsonObject(QJsonObject json) {

    m_file_id_isValid = ::OpenAPI::fromJsonValue(m_file_id, json[QString("file_id")]);
    m_file_id_isSet = !json[QString("file_id")].isNull() && m_file_id_isValid;

    m_internal_project_id_isValid = ::OpenAPI::fromJsonValue(m_internal_project_id, json[QString("internal_project_id")]);
    m_internal_project_id_isSet = !json[QString("internal_project_id")].isNull() && m_internal_project_id_isValid;

    m_last_updated_isValid = ::OpenAPI::fromJsonValue(m_last_updated, json[QString("last_updated")]);
    m_last_updated_isSet = !json[QString("last_updated")].isNull() && m_last_updated_isValid;

    m_project_id_isValid = ::OpenAPI::fromJsonValue(m_project_id, json[QString("project_id")]);
    m_project_id_isSet = !json[QString("project_id")].isNull() && m_project_id_isValid;

    m_search_score_isValid = ::OpenAPI::fromJsonValue(m_search_score, json[QString("search_score")]);
    m_search_score_isSet = !json[QString("search_score")].isNull() && m_search_score_isValid;

    m_source_isValid = ::OpenAPI::fromJsonValue(m_source, json[QString("source")]);
    m_source_isSet = !json[QString("source")].isNull() && m_source_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_string_id_isValid = ::OpenAPI::fromJsonValue(m_string_id, json[QString("string_id")]);
    m_string_id_isSet = !json[QString("string_id")].isNull() && m_string_id_isValid;

    m_target_isValid = ::OpenAPI::fromJsonValue(m_target, json[QString("target")]);
    m_target_isSet = !json[QString("target")].isNull() && m_target_isValid;

    m_targets_isValid = ::OpenAPI::fromJsonValue(m_targets, json[QString("targets")]);
    m_targets_isSet = !json[QString("targets")].isNull() && m_targets_isValid;

    m_tm_name_isValid = ::OpenAPI::fromJsonValue(m_tm_name, json[QString("tm_name")]);
    m_tm_name_isSet = !json[QString("tm_name")].isNull() && m_tm_name_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIStringInSearch::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIStringInSearch::asJsonObject() const {
    QJsonObject obj;
    if (m_file_id_isSet) {
        obj.insert(QString("file_id"), ::OpenAPI::toJsonValue(m_file_id));
    }
    if (m_internal_project_id_isSet) {
        obj.insert(QString("internal_project_id"), ::OpenAPI::toJsonValue(m_internal_project_id));
    }
    if (m_last_updated_isSet) {
        obj.insert(QString("last_updated"), ::OpenAPI::toJsonValue(m_last_updated));
    }
    if (m_project_id_isSet) {
        obj.insert(QString("project_id"), ::OpenAPI::toJsonValue(m_project_id));
    }
    if (m_search_score_isSet) {
        obj.insert(QString("search_score"), ::OpenAPI::toJsonValue(m_search_score));
    }
    if (m_source_isSet) {
        obj.insert(QString("source"), ::OpenAPI::toJsonValue(m_source));
    }
    if (m_status.isSet()) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_string_id_isSet) {
        obj.insert(QString("string_id"), ::OpenAPI::toJsonValue(m_string_id));
    }
    if (m_target_isSet) {
        obj.insert(QString("target"), ::OpenAPI::toJsonValue(m_target));
    }
    if (m_targets.size() > 0) {
        obj.insert(QString("targets"), ::OpenAPI::toJsonValue(m_targets));
    }
    if (m_tm_name_isSet) {
        obj.insert(QString("tm_name"), ::OpenAPI::toJsonValue(m_tm_name));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

qint64 OAIStringInSearch::getFileId() const {
    return m_file_id;
}
void OAIStringInSearch::setFileId(const qint64 &file_id) {
    m_file_id = file_id;
    m_file_id_isSet = true;
}

bool OAIStringInSearch::is_file_id_Set() const{
    return m_file_id_isSet;
}

bool OAIStringInSearch::is_file_id_Valid() const{
    return m_file_id_isValid;
}

qint64 OAIStringInSearch::getInternalProjectId() const {
    return m_internal_project_id;
}
void OAIStringInSearch::setInternalProjectId(const qint64 &internal_project_id) {
    m_internal_project_id = internal_project_id;
    m_internal_project_id_isSet = true;
}

bool OAIStringInSearch::is_internal_project_id_Set() const{
    return m_internal_project_id_isSet;
}

bool OAIStringInSearch::is_internal_project_id_Valid() const{
    return m_internal_project_id_isValid;
}

QDateTime OAIStringInSearch::getLastUpdated() const {
    return m_last_updated;
}
void OAIStringInSearch::setLastUpdated(const QDateTime &last_updated) {
    m_last_updated = last_updated;
    m_last_updated_isSet = true;
}

bool OAIStringInSearch::is_last_updated_Set() const{
    return m_last_updated_isSet;
}

bool OAIStringInSearch::is_last_updated_Valid() const{
    return m_last_updated_isValid;
}

qint64 OAIStringInSearch::getProjectId() const {
    return m_project_id;
}
void OAIStringInSearch::setProjectId(const qint64 &project_id) {
    m_project_id = project_id;
    m_project_id_isSet = true;
}

bool OAIStringInSearch::is_project_id_Set() const{
    return m_project_id_isSet;
}

bool OAIStringInSearch::is_project_id_Valid() const{
    return m_project_id_isValid;
}

float OAIStringInSearch::getSearchScore() const {
    return m_search_score;
}
void OAIStringInSearch::setSearchScore(const float &search_score) {
    m_search_score = search_score;
    m_search_score_isSet = true;
}

bool OAIStringInSearch::is_search_score_Set() const{
    return m_search_score_isSet;
}

bool OAIStringInSearch::is_search_score_Valid() const{
    return m_search_score_isValid;
}

QString OAIStringInSearch::getSource() const {
    return m_source;
}
void OAIStringInSearch::setSource(const QString &source) {
    m_source = source;
    m_source_isSet = true;
}

bool OAIStringInSearch::is_source_Set() const{
    return m_source_isSet;
}

bool OAIStringInSearch::is_source_Valid() const{
    return m_source_isValid;
}

OAIStringTranslationState OAIStringInSearch::getStatus() const {
    return m_status;
}
void OAIStringInSearch::setStatus(const OAIStringTranslationState &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIStringInSearch::is_status_Set() const{
    return m_status_isSet;
}

bool OAIStringInSearch::is_status_Valid() const{
    return m_status_isValid;
}

qint64 OAIStringInSearch::getStringId() const {
    return m_string_id;
}
void OAIStringInSearch::setStringId(const qint64 &string_id) {
    m_string_id = string_id;
    m_string_id_isSet = true;
}

bool OAIStringInSearch::is_string_id_Set() const{
    return m_string_id_isSet;
}

bool OAIStringInSearch::is_string_id_Valid() const{
    return m_string_id_isValid;
}

QString OAIStringInSearch::getTarget() const {
    return m_target;
}
void OAIStringInSearch::setTarget(const QString &target) {
    m_target = target;
    m_target_isSet = true;
}

bool OAIStringInSearch::is_target_Set() const{
    return m_target_isSet;
}

bool OAIStringInSearch::is_target_Valid() const{
    return m_target_isValid;
}

QList<QString> OAIStringInSearch::getTargets() const {
    return m_targets;
}
void OAIStringInSearch::setTargets(const QList<QString> &targets) {
    m_targets = targets;
    m_targets_isSet = true;
}

bool OAIStringInSearch::is_targets_Set() const{
    return m_targets_isSet;
}

bool OAIStringInSearch::is_targets_Valid() const{
    return m_targets_isValid;
}

QString OAIStringInSearch::getTmName() const {
    return m_tm_name;
}
void OAIStringInSearch::setTmName(const QString &tm_name) {
    m_tm_name = tm_name;
    m_tm_name_isSet = true;
}

bool OAIStringInSearch::is_tm_name_Set() const{
    return m_tm_name_isSet;
}

bool OAIStringInSearch::is_tm_name_Valid() const{
    return m_tm_name_isValid;
}

QString OAIStringInSearch::getType() const {
    return m_type;
}
void OAIStringInSearch::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIStringInSearch::is_type_Set() const{
    return m_type_isSet;
}

bool OAIStringInSearch::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIStringInSearch::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_file_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_internal_project_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_updated_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_project_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_search_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_source_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_string_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_target_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_targets.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_tm_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIStringInSearch::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
