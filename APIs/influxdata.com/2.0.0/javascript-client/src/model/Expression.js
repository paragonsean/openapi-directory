/**
 * Influx OSS API Service
 * # Authentication  &lt;!-- ReDoc-Inject: &lt;security-definitions&gt; --&gt;
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ArrayExpression from './ArrayExpression';
import BinaryExpression from './BinaryExpression';
import BooleanLiteral from './BooleanLiteral';
import CallExpression from './CallExpression';
import ConditionalExpression from './ConditionalExpression';
import DateTimeLiteral from './DateTimeLiteral';
import DictExpression from './DictExpression';
import DictItem from './DictItem';
import Duration from './Duration';
import DurationLiteral from './DurationLiteral';
import FloatLiteral from './FloatLiteral';
import FunctionExpression from './FunctionExpression';
import Identifier from './Identifier';
import IndexExpression from './IndexExpression';
import IntegerLiteral from './IntegerLiteral';
import LogicalExpression from './LogicalExpression';
import MemberExpression from './MemberExpression';
import Node from './Node';
import ObjectExpression from './ObjectExpression';
import ParenExpression from './ParenExpression';
import PipeExpression from './PipeExpression';
import PipeLiteral from './PipeLiteral';
import Property from './Property';
import PropertyKey from './PropertyKey';
import RegexpLiteral from './RegexpLiteral';
import StringLiteral from './StringLiteral';
import UnaryExpression from './UnaryExpression';
import UnsignedIntegerLiteral from './UnsignedIntegerLiteral';

/**
 * The Expression model module.
 * @module model/Expression
 * @version 2.0.0
 */
class Expression {
    /**
     * Constructs a new <code>Expression</code>.
     * @alias module:model/Expression
     * @param {(module:model/ArrayExpression|module:model/BinaryExpression|module:model/BooleanLiteral|module:model/CallExpression|module:model/ConditionalExpression|module:model/DateTimeLiteral|module:model/DictExpression|module:model/DurationLiteral|module:model/FloatLiteral|module:model/FunctionExpression|module:model/Identifier|module:model/IndexExpression|module:model/IntegerLiteral|module:model/LogicalExpression|module:model/MemberExpression|module:model/ObjectExpression|module:model/ParenExpression|module:model/PipeExpression|module:model/PipeLiteral|module:model/RegexpLiteral|module:model/StringLiteral|module:model/UnaryExpression|module:model/UnsignedIntegerLiteral)} instance The actual instance to initialize Expression.
     */
    constructor(instance = null) {
        if (instance === null) {
            this.actualInstance = null;
            return;
        }
        var match = 0;
        var errorMessages = [];
        try {
            if (typeof instance === "ArrayExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                ArrayExpression.validateJSON(instance); // throw an exception if no match
                // create ArrayExpression from JS object
                this.actualInstance = ArrayExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into ArrayExpression
            errorMessages.push("Failed to construct ArrayExpression: " + err)
        }

        try {
            if (typeof instance === "DictExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                DictExpression.validateJSON(instance); // throw an exception if no match
                // create DictExpression from JS object
                this.actualInstance = DictExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into DictExpression
            errorMessages.push("Failed to construct DictExpression: " + err)
        }

        try {
            if (typeof instance === "FunctionExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                FunctionExpression.validateJSON(instance); // throw an exception if no match
                // create FunctionExpression from JS object
                this.actualInstance = FunctionExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into FunctionExpression
            errorMessages.push("Failed to construct FunctionExpression: " + err)
        }

        try {
            if (typeof instance === "BinaryExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                BinaryExpression.validateJSON(instance); // throw an exception if no match
                // create BinaryExpression from JS object
                this.actualInstance = BinaryExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into BinaryExpression
            errorMessages.push("Failed to construct BinaryExpression: " + err)
        }

        try {
            if (typeof instance === "CallExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                CallExpression.validateJSON(instance); // throw an exception if no match
                // create CallExpression from JS object
                this.actualInstance = CallExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into CallExpression
            errorMessages.push("Failed to construct CallExpression: " + err)
        }

        try {
            if (typeof instance === "ConditionalExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                ConditionalExpression.validateJSON(instance); // throw an exception if no match
                // create ConditionalExpression from JS object
                this.actualInstance = ConditionalExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into ConditionalExpression
            errorMessages.push("Failed to construct ConditionalExpression: " + err)
        }

        try {
            if (typeof instance === "LogicalExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                LogicalExpression.validateJSON(instance); // throw an exception if no match
                // create LogicalExpression from JS object
                this.actualInstance = LogicalExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into LogicalExpression
            errorMessages.push("Failed to construct LogicalExpression: " + err)
        }

        try {
            if (typeof instance === "MemberExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                MemberExpression.validateJSON(instance); // throw an exception if no match
                // create MemberExpression from JS object
                this.actualInstance = MemberExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into MemberExpression
            errorMessages.push("Failed to construct MemberExpression: " + err)
        }

        try {
            if (typeof instance === "IndexExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                IndexExpression.validateJSON(instance); // throw an exception if no match
                // create IndexExpression from JS object
                this.actualInstance = IndexExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into IndexExpression
            errorMessages.push("Failed to construct IndexExpression: " + err)
        }

        try {
            if (typeof instance === "ObjectExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                ObjectExpression.validateJSON(instance); // throw an exception if no match
                // create ObjectExpression from JS object
                this.actualInstance = ObjectExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into ObjectExpression
            errorMessages.push("Failed to construct ObjectExpression: " + err)
        }

        try {
            if (typeof instance === "ParenExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                ParenExpression.validateJSON(instance); // throw an exception if no match
                // create ParenExpression from JS object
                this.actualInstance = ParenExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into ParenExpression
            errorMessages.push("Failed to construct ParenExpression: " + err)
        }

        try {
            if (typeof instance === "PipeExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                PipeExpression.validateJSON(instance); // throw an exception if no match
                // create PipeExpression from JS object
                this.actualInstance = PipeExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into PipeExpression
            errorMessages.push("Failed to construct PipeExpression: " + err)
        }

        try {
            if (typeof instance === "UnaryExpression") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                UnaryExpression.validateJSON(instance); // throw an exception if no match
                // create UnaryExpression from JS object
                this.actualInstance = UnaryExpression.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into UnaryExpression
            errorMessages.push("Failed to construct UnaryExpression: " + err)
        }

        try {
            if (typeof instance === "BooleanLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                BooleanLiteral.validateJSON(instance); // throw an exception if no match
                // create BooleanLiteral from JS object
                this.actualInstance = BooleanLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into BooleanLiteral
            errorMessages.push("Failed to construct BooleanLiteral: " + err)
        }

        try {
            if (typeof instance === "DateTimeLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                DateTimeLiteral.validateJSON(instance); // throw an exception if no match
                // create DateTimeLiteral from JS object
                this.actualInstance = DateTimeLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into DateTimeLiteral
            errorMessages.push("Failed to construct DateTimeLiteral: " + err)
        }

        try {
            if (typeof instance === "DurationLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                DurationLiteral.validateJSON(instance); // throw an exception if no match
                // create DurationLiteral from JS object
                this.actualInstance = DurationLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into DurationLiteral
            errorMessages.push("Failed to construct DurationLiteral: " + err)
        }

        try {
            if (typeof instance === "FloatLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                FloatLiteral.validateJSON(instance); // throw an exception if no match
                // create FloatLiteral from JS object
                this.actualInstance = FloatLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into FloatLiteral
            errorMessages.push("Failed to construct FloatLiteral: " + err)
        }

        try {
            if (typeof instance === "IntegerLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                IntegerLiteral.validateJSON(instance); // throw an exception if no match
                // create IntegerLiteral from JS object
                this.actualInstance = IntegerLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into IntegerLiteral
            errorMessages.push("Failed to construct IntegerLiteral: " + err)
        }

        try {
            if (typeof instance === "PipeLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                PipeLiteral.validateJSON(instance); // throw an exception if no match
                // create PipeLiteral from JS object
                this.actualInstance = PipeLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into PipeLiteral
            errorMessages.push("Failed to construct PipeLiteral: " + err)
        }

        try {
            if (typeof instance === "RegexpLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                RegexpLiteral.validateJSON(instance); // throw an exception if no match
                // create RegexpLiteral from JS object
                this.actualInstance = RegexpLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into RegexpLiteral
            errorMessages.push("Failed to construct RegexpLiteral: " + err)
        }

        try {
            if (typeof instance === "StringLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                StringLiteral.validateJSON(instance); // throw an exception if no match
                // create StringLiteral from JS object
                this.actualInstance = StringLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into StringLiteral
            errorMessages.push("Failed to construct StringLiteral: " + err)
        }

        try {
            if (typeof instance === "UnsignedIntegerLiteral") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                UnsignedIntegerLiteral.validateJSON(instance); // throw an exception if no match
                // create UnsignedIntegerLiteral from JS object
                this.actualInstance = UnsignedIntegerLiteral.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into UnsignedIntegerLiteral
            errorMessages.push("Failed to construct UnsignedIntegerLiteral: " + err)
        }

        try {
            if (typeof instance === "Identifier") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                Identifier.validateJSON(instance); // throw an exception if no match
                // create Identifier from JS object
                this.actualInstance = Identifier.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into Identifier
            errorMessages.push("Failed to construct Identifier: " + err)
        }

        if (match > 1) {
            throw new Error("Multiple matches found constructing `Expression` with oneOf schemas ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral. Input: " + JSON.stringify(instance));
        } else if (match === 0) {
            this.actualInstance = null; // clear the actual instance in case there are multiple matches
            throw new Error("No match found constructing `Expression` with oneOf schemas ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral. Details: " +
                            errorMessages.join(", "));
        } else { // only 1 match
            // the input is valid
        }
    }

    /**
     * Constructs a <code>Expression</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Expression} obj Optional instance to populate.
     * @return {module:model/Expression} The populated <code>Expression</code> instance.
     */
    static constructFromObject(data, obj) {
        return new Expression(data);
    }

    /**
     * Gets the actual instance, which can be <code>ArrayExpression</code>, <code>BinaryExpression</code>, <code>BooleanLiteral</code>, <code>CallExpression</code>, <code>ConditionalExpression</code>, <code>DateTimeLiteral</code>, <code>DictExpression</code>, <code>DurationLiteral</code>, <code>FloatLiteral</code>, <code>FunctionExpression</code>, <code>Identifier</code>, <code>IndexExpression</code>, <code>IntegerLiteral</code>, <code>LogicalExpression</code>, <code>MemberExpression</code>, <code>ObjectExpression</code>, <code>ParenExpression</code>, <code>PipeExpression</code>, <code>PipeLiteral</code>, <code>RegexpLiteral</code>, <code>StringLiteral</code>, <code>UnaryExpression</code>, <code>UnsignedIntegerLiteral</code>.
     * @return {(module:model/ArrayExpression|module:model/BinaryExpression|module:model/BooleanLiteral|module:model/CallExpression|module:model/ConditionalExpression|module:model/DateTimeLiteral|module:model/DictExpression|module:model/DurationLiteral|module:model/FloatLiteral|module:model/FunctionExpression|module:model/Identifier|module:model/IndexExpression|module:model/IntegerLiteral|module:model/LogicalExpression|module:model/MemberExpression|module:model/ObjectExpression|module:model/ParenExpression|module:model/PipeExpression|module:model/PipeLiteral|module:model/RegexpLiteral|module:model/StringLiteral|module:model/UnaryExpression|module:model/UnsignedIntegerLiteral)} The actual instance.
     */
    getActualInstance() {
        return this.actualInstance;
    }

    /**
     * Sets the actual instance, which can be <code>ArrayExpression</code>, <code>BinaryExpression</code>, <code>BooleanLiteral</code>, <code>CallExpression</code>, <code>ConditionalExpression</code>, <code>DateTimeLiteral</code>, <code>DictExpression</code>, <code>DurationLiteral</code>, <code>FloatLiteral</code>, <code>FunctionExpression</code>, <code>Identifier</code>, <code>IndexExpression</code>, <code>IntegerLiteral</code>, <code>LogicalExpression</code>, <code>MemberExpression</code>, <code>ObjectExpression</code>, <code>ParenExpression</code>, <code>PipeExpression</code>, <code>PipeLiteral</code>, <code>RegexpLiteral</code>, <code>StringLiteral</code>, <code>UnaryExpression</code>, <code>UnsignedIntegerLiteral</code>.
     * @param {(module:model/ArrayExpression|module:model/BinaryExpression|module:model/BooleanLiteral|module:model/CallExpression|module:model/ConditionalExpression|module:model/DateTimeLiteral|module:model/DictExpression|module:model/DurationLiteral|module:model/FloatLiteral|module:model/FunctionExpression|module:model/Identifier|module:model/IndexExpression|module:model/IntegerLiteral|module:model/LogicalExpression|module:model/MemberExpression|module:model/ObjectExpression|module:model/ParenExpression|module:model/PipeExpression|module:model/PipeLiteral|module:model/RegexpLiteral|module:model/StringLiteral|module:model/UnaryExpression|module:model/UnsignedIntegerLiteral)} obj The actual instance.
     */
    setActualInstance(obj) {
       this.actualInstance = Expression.constructFromObject(obj).getActualInstance();
    }

    /**
     * Returns the JSON representation of the actual instance.
     * @return {string}
     */
    toJSON = function(){
        return this.getActualInstance();
    }

    /**
     * Create an instance of Expression from a JSON string.
     * @param {string} json_string JSON string.
     * @return {module:model/Expression} An instance of Expression.
     */
    static fromJSON = function(json_string){
        return Expression.constructFromObject(JSON.parse(json_string));
    }
}

/**
 * Elements of the dictionary
 * @member {Array.<module:model/DictItem>} elements
 */
Expression.prototype['elements'] = undefined;

/**
 * Type of AST node
 * @member {String} type
 */
Expression.prototype['type'] = undefined;

/**
 * @member {module:model/Node} body
 */
Expression.prototype['body'] = undefined;

/**
 * Function parameters
 * @member {Array.<module:model/Property>} params
 */
Expression.prototype['params'] = undefined;

/**
 * @member {module:model/Expression} left
 */
Expression.prototype['left'] = undefined;

/**
 * @member {String} operator
 */
Expression.prototype['operator'] = undefined;

/**
 * @member {module:model/Expression} right
 */
Expression.prototype['right'] = undefined;

/**
 * Function arguments
 * @member {Array.<module:model/Expression>} arguments
 */
Expression.prototype['arguments'] = undefined;

/**
 * @member {module:model/Expression} callee
 */
Expression.prototype['callee'] = undefined;

/**
 * @member {module:model/Expression} alternate
 */
Expression.prototype['alternate'] = undefined;

/**
 * @member {module:model/Expression} consequent
 */
Expression.prototype['consequent'] = undefined;

/**
 * @member {module:model/Expression} test
 */
Expression.prototype['test'] = undefined;

/**
 * @member {module:model/Expression} object
 */
Expression.prototype['object'] = undefined;

/**
 * @member {module:model/PropertyKey} property
 */
Expression.prototype['property'] = undefined;

/**
 * @member {module:model/Expression} array
 */
Expression.prototype['array'] = undefined;

/**
 * @member {module:model/Expression} index
 */
Expression.prototype['index'] = undefined;

/**
 * Object properties
 * @member {Array.<module:model/Property>} properties
 */
Expression.prototype['properties'] = undefined;

/**
 * @member {module:model/Expression} expression
 */
Expression.prototype['expression'] = undefined;

/**
 * @member {module:model/Expression} argument
 */
Expression.prototype['argument'] = undefined;

/**
 * @member {module:model/CallExpression} call
 */
Expression.prototype['call'] = undefined;

/**
 * @member {String} value
 */
Expression.prototype['value'] = undefined;

/**
 * Duration values
 * @member {Array.<module:model/Duration>} values
 */
Expression.prototype['values'] = undefined;

/**
 * @member {String} name
 */
Expression.prototype['name'] = undefined;


Expression.OneOf = ["ArrayExpression", "BinaryExpression", "BooleanLiteral", "CallExpression", "ConditionalExpression", "DateTimeLiteral", "DictExpression", "DurationLiteral", "FloatLiteral", "FunctionExpression", "Identifier", "IndexExpression", "IntegerLiteral", "LogicalExpression", "MemberExpression", "ObjectExpression", "ParenExpression", "PipeExpression", "PipeLiteral", "RegexpLiteral", "StringLiteral", "UnaryExpression", "UnsignedIntegerLiteral"];

export default Expression;

