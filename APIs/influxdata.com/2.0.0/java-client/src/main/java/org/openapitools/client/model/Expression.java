/*
 * Influx OSS API Service
 * # Authentication  &lt;!-- ReDoc-Inject: &lt;security-definitions&gt; --&gt;
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ArrayExpression;
import org.openapitools.client.model.BinaryExpression;
import org.openapitools.client.model.BooleanLiteral;
import org.openapitools.client.model.CallExpression;
import org.openapitools.client.model.ConditionalExpression;
import org.openapitools.client.model.DateTimeLiteral;
import org.openapitools.client.model.DictExpression;
import org.openapitools.client.model.DictItem;
import org.openapitools.client.model.Duration;
import org.openapitools.client.model.DurationLiteral;
import org.openapitools.client.model.FloatLiteral;
import org.openapitools.client.model.FunctionExpression;
import org.openapitools.client.model.Identifier;
import org.openapitools.client.model.IndexExpression;
import org.openapitools.client.model.IntegerLiteral;
import org.openapitools.client.model.LogicalExpression;
import org.openapitools.client.model.MemberExpression;
import org.openapitools.client.model.Node;
import org.openapitools.client.model.ObjectExpression;
import org.openapitools.client.model.ParenExpression;
import org.openapitools.client.model.PipeExpression;
import org.openapitools.client.model.PipeLiteral;
import org.openapitools.client.model.Property;
import org.openapitools.client.model.PropertyKey;
import org.openapitools.client.model.RegexpLiteral;
import org.openapitools.client.model.StringLiteral;
import org.openapitools.client.model.UnaryExpression;
import org.openapitools.client.model.UnsignedIntegerLiteral;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:22:51.322764-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Expression extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(Expression.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!Expression.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'Expression' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<ArrayExpression> adapterArrayExpression = gson.getDelegateAdapter(this, TypeToken.get(ArrayExpression.class));
            final TypeAdapter<DictExpression> adapterDictExpression = gson.getDelegateAdapter(this, TypeToken.get(DictExpression.class));
            final TypeAdapter<FunctionExpression> adapterFunctionExpression = gson.getDelegateAdapter(this, TypeToken.get(FunctionExpression.class));
            final TypeAdapter<BinaryExpression> adapterBinaryExpression = gson.getDelegateAdapter(this, TypeToken.get(BinaryExpression.class));
            final TypeAdapter<CallExpression> adapterCallExpression = gson.getDelegateAdapter(this, TypeToken.get(CallExpression.class));
            final TypeAdapter<ConditionalExpression> adapterConditionalExpression = gson.getDelegateAdapter(this, TypeToken.get(ConditionalExpression.class));
            final TypeAdapter<LogicalExpression> adapterLogicalExpression = gson.getDelegateAdapter(this, TypeToken.get(LogicalExpression.class));
            final TypeAdapter<MemberExpression> adapterMemberExpression = gson.getDelegateAdapter(this, TypeToken.get(MemberExpression.class));
            final TypeAdapter<IndexExpression> adapterIndexExpression = gson.getDelegateAdapter(this, TypeToken.get(IndexExpression.class));
            final TypeAdapter<ObjectExpression> adapterObjectExpression = gson.getDelegateAdapter(this, TypeToken.get(ObjectExpression.class));
            final TypeAdapter<ParenExpression> adapterParenExpression = gson.getDelegateAdapter(this, TypeToken.get(ParenExpression.class));
            final TypeAdapter<PipeExpression> adapterPipeExpression = gson.getDelegateAdapter(this, TypeToken.get(PipeExpression.class));
            final TypeAdapter<UnaryExpression> adapterUnaryExpression = gson.getDelegateAdapter(this, TypeToken.get(UnaryExpression.class));
            final TypeAdapter<BooleanLiteral> adapterBooleanLiteral = gson.getDelegateAdapter(this, TypeToken.get(BooleanLiteral.class));
            final TypeAdapter<DateTimeLiteral> adapterDateTimeLiteral = gson.getDelegateAdapter(this, TypeToken.get(DateTimeLiteral.class));
            final TypeAdapter<DurationLiteral> adapterDurationLiteral = gson.getDelegateAdapter(this, TypeToken.get(DurationLiteral.class));
            final TypeAdapter<FloatLiteral> adapterFloatLiteral = gson.getDelegateAdapter(this, TypeToken.get(FloatLiteral.class));
            final TypeAdapter<IntegerLiteral> adapterIntegerLiteral = gson.getDelegateAdapter(this, TypeToken.get(IntegerLiteral.class));
            final TypeAdapter<PipeLiteral> adapterPipeLiteral = gson.getDelegateAdapter(this, TypeToken.get(PipeLiteral.class));
            final TypeAdapter<RegexpLiteral> adapterRegexpLiteral = gson.getDelegateAdapter(this, TypeToken.get(RegexpLiteral.class));
            final TypeAdapter<StringLiteral> adapterStringLiteral = gson.getDelegateAdapter(this, TypeToken.get(StringLiteral.class));
            final TypeAdapter<UnsignedIntegerLiteral> adapterUnsignedIntegerLiteral = gson.getDelegateAdapter(this, TypeToken.get(UnsignedIntegerLiteral.class));
            final TypeAdapter<Identifier> adapterIdentifier = gson.getDelegateAdapter(this, TypeToken.get(Identifier.class));

            return (TypeAdapter<T>) new TypeAdapter<Expression>() {
                @Override
                public void write(JsonWriter out, Expression value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `ArrayExpression`
                    if (value.getActualInstance() instanceof ArrayExpression) {
                        JsonElement element = adapterArrayExpression.toJsonTree((ArrayExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DictExpression`
                    if (value.getActualInstance() instanceof DictExpression) {
                        JsonElement element = adapterDictExpression.toJsonTree((DictExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `FunctionExpression`
                    if (value.getActualInstance() instanceof FunctionExpression) {
                        JsonElement element = adapterFunctionExpression.toJsonTree((FunctionExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BinaryExpression`
                    if (value.getActualInstance() instanceof BinaryExpression) {
                        JsonElement element = adapterBinaryExpression.toJsonTree((BinaryExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CallExpression`
                    if (value.getActualInstance() instanceof CallExpression) {
                        JsonElement element = adapterCallExpression.toJsonTree((CallExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `ConditionalExpression`
                    if (value.getActualInstance() instanceof ConditionalExpression) {
                        JsonElement element = adapterConditionalExpression.toJsonTree((ConditionalExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `LogicalExpression`
                    if (value.getActualInstance() instanceof LogicalExpression) {
                        JsonElement element = adapterLogicalExpression.toJsonTree((LogicalExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `MemberExpression`
                    if (value.getActualInstance() instanceof MemberExpression) {
                        JsonElement element = adapterMemberExpression.toJsonTree((MemberExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `IndexExpression`
                    if (value.getActualInstance() instanceof IndexExpression) {
                        JsonElement element = adapterIndexExpression.toJsonTree((IndexExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `ObjectExpression`
                    if (value.getActualInstance() instanceof ObjectExpression) {
                        JsonElement element = adapterObjectExpression.toJsonTree((ObjectExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `ParenExpression`
                    if (value.getActualInstance() instanceof ParenExpression) {
                        JsonElement element = adapterParenExpression.toJsonTree((ParenExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PipeExpression`
                    if (value.getActualInstance() instanceof PipeExpression) {
                        JsonElement element = adapterPipeExpression.toJsonTree((PipeExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `UnaryExpression`
                    if (value.getActualInstance() instanceof UnaryExpression) {
                        JsonElement element = adapterUnaryExpression.toJsonTree((UnaryExpression)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BooleanLiteral`
                    if (value.getActualInstance() instanceof BooleanLiteral) {
                        JsonElement element = adapterBooleanLiteral.toJsonTree((BooleanLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DateTimeLiteral`
                    if (value.getActualInstance() instanceof DateTimeLiteral) {
                        JsonElement element = adapterDateTimeLiteral.toJsonTree((DateTimeLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DurationLiteral`
                    if (value.getActualInstance() instanceof DurationLiteral) {
                        JsonElement element = adapterDurationLiteral.toJsonTree((DurationLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `FloatLiteral`
                    if (value.getActualInstance() instanceof FloatLiteral) {
                        JsonElement element = adapterFloatLiteral.toJsonTree((FloatLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `IntegerLiteral`
                    if (value.getActualInstance() instanceof IntegerLiteral) {
                        JsonElement element = adapterIntegerLiteral.toJsonTree((IntegerLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PipeLiteral`
                    if (value.getActualInstance() instanceof PipeLiteral) {
                        JsonElement element = adapterPipeLiteral.toJsonTree((PipeLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `RegexpLiteral`
                    if (value.getActualInstance() instanceof RegexpLiteral) {
                        JsonElement element = adapterRegexpLiteral.toJsonTree((RegexpLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `StringLiteral`
                    if (value.getActualInstance() instanceof StringLiteral) {
                        JsonElement element = adapterStringLiteral.toJsonTree((StringLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `UnsignedIntegerLiteral`
                    if (value.getActualInstance() instanceof UnsignedIntegerLiteral) {
                        JsonElement element = adapterUnsignedIntegerLiteral.toJsonTree((UnsignedIntegerLiteral)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `Identifier`
                    if (value.getActualInstance() instanceof Identifier) {
                        JsonElement element = adapterIdentifier.toJsonTree((Identifier)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral");
                }

                @Override
                public Expression read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize ArrayExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ArrayExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterArrayExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'ArrayExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for ArrayExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'ArrayExpression'", e);
                    }
                    // deserialize DictExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DictExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterDictExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DictExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DictExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DictExpression'", e);
                    }
                    // deserialize FunctionExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        FunctionExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterFunctionExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'FunctionExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for FunctionExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'FunctionExpression'", e);
                    }
                    // deserialize BinaryExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BinaryExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterBinaryExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BinaryExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BinaryExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BinaryExpression'", e);
                    }
                    // deserialize CallExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CallExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterCallExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'CallExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CallExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CallExpression'", e);
                    }
                    // deserialize ConditionalExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ConditionalExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterConditionalExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'ConditionalExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for ConditionalExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'ConditionalExpression'", e);
                    }
                    // deserialize LogicalExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        LogicalExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterLogicalExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'LogicalExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for LogicalExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'LogicalExpression'", e);
                    }
                    // deserialize MemberExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MemberExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterMemberExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'MemberExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for MemberExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'MemberExpression'", e);
                    }
                    // deserialize IndexExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        IndexExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterIndexExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'IndexExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for IndexExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'IndexExpression'", e);
                    }
                    // deserialize ObjectExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ObjectExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterObjectExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'ObjectExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for ObjectExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'ObjectExpression'", e);
                    }
                    // deserialize ParenExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        ParenExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterParenExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'ParenExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for ParenExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'ParenExpression'", e);
                    }
                    // deserialize PipeExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PipeExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterPipeExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PipeExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PipeExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PipeExpression'", e);
                    }
                    // deserialize UnaryExpression
                    try {
                        // validate the JSON object to see if any exception is thrown
                        UnaryExpression.validateJsonElement(jsonElement);
                        actualAdapter = adapterUnaryExpression;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'UnaryExpression'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for UnaryExpression failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'UnaryExpression'", e);
                    }
                    // deserialize BooleanLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BooleanLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterBooleanLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BooleanLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BooleanLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BooleanLiteral'", e);
                    }
                    // deserialize DateTimeLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DateTimeLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterDateTimeLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DateTimeLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DateTimeLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DateTimeLiteral'", e);
                    }
                    // deserialize DurationLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DurationLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterDurationLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DurationLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DurationLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DurationLiteral'", e);
                    }
                    // deserialize FloatLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        FloatLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterFloatLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'FloatLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for FloatLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'FloatLiteral'", e);
                    }
                    // deserialize IntegerLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        IntegerLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterIntegerLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'IntegerLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for IntegerLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'IntegerLiteral'", e);
                    }
                    // deserialize PipeLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PipeLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterPipeLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PipeLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PipeLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PipeLiteral'", e);
                    }
                    // deserialize RegexpLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        RegexpLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterRegexpLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'RegexpLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for RegexpLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'RegexpLiteral'", e);
                    }
                    // deserialize StringLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        StringLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterStringLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'StringLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for StringLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'StringLiteral'", e);
                    }
                    // deserialize UnsignedIntegerLiteral
                    try {
                        // validate the JSON object to see if any exception is thrown
                        UnsignedIntegerLiteral.validateJsonElement(jsonElement);
                        actualAdapter = adapterUnsignedIntegerLiteral;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'UnsignedIntegerLiteral'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for UnsignedIntegerLiteral failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'UnsignedIntegerLiteral'", e);
                    }
                    // deserialize Identifier
                    try {
                        // validate the JSON object to see if any exception is thrown
                        Identifier.validateJsonElement(jsonElement);
                        actualAdapter = adapterIdentifier;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'Identifier'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for Identifier failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'Identifier'", e);
                    }

                    if (match == 1) {
                        Expression ret = new Expression();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for Expression: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public Expression() {
        super("oneOf", Boolean.FALSE);
    }

    public Expression(Object o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("ArrayExpression", ArrayExpression.class);
        schemas.put("DictExpression", DictExpression.class);
        schemas.put("FunctionExpression", FunctionExpression.class);
        schemas.put("BinaryExpression", BinaryExpression.class);
        schemas.put("CallExpression", CallExpression.class);
        schemas.put("ConditionalExpression", ConditionalExpression.class);
        schemas.put("LogicalExpression", LogicalExpression.class);
        schemas.put("MemberExpression", MemberExpression.class);
        schemas.put("IndexExpression", IndexExpression.class);
        schemas.put("ObjectExpression", ObjectExpression.class);
        schemas.put("ParenExpression", ParenExpression.class);
        schemas.put("PipeExpression", PipeExpression.class);
        schemas.put("UnaryExpression", UnaryExpression.class);
        schemas.put("BooleanLiteral", BooleanLiteral.class);
        schemas.put("DateTimeLiteral", DateTimeLiteral.class);
        schemas.put("DurationLiteral", DurationLiteral.class);
        schemas.put("FloatLiteral", FloatLiteral.class);
        schemas.put("IntegerLiteral", IntegerLiteral.class);
        schemas.put("PipeLiteral", PipeLiteral.class);
        schemas.put("RegexpLiteral", RegexpLiteral.class);
        schemas.put("StringLiteral", StringLiteral.class);
        schemas.put("UnsignedIntegerLiteral", UnsignedIntegerLiteral.class);
        schemas.put("Identifier", Identifier.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return Expression.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral
     *
     * It could be an instance of the 'oneOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof ArrayExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DictExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof FunctionExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BinaryExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CallExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ConditionalExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof LogicalExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MemberExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof IndexExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ObjectExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof ParenExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PipeExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof UnaryExpression) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BooleanLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DateTimeLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DurationLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof FloatLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof IntegerLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PipeLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof RegexpLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof StringLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof UnsignedIntegerLiteral) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof Identifier) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral");
    }

    /**
     * Get the actual instance, which can be the following:
     * ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral
     *
     * @return The actual instance (ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral)
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `ArrayExpression`. If the actual instance is not `ArrayExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ArrayExpression`
     * @throws ClassCastException if the instance is not `ArrayExpression`
     */
    public ArrayExpression getArrayExpression() throws ClassCastException {
        return (ArrayExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `DictExpression`. If the actual instance is not `DictExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DictExpression`
     * @throws ClassCastException if the instance is not `DictExpression`
     */
    public DictExpression getDictExpression() throws ClassCastException {
        return (DictExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `FunctionExpression`. If the actual instance is not `FunctionExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FunctionExpression`
     * @throws ClassCastException if the instance is not `FunctionExpression`
     */
    public FunctionExpression getFunctionExpression() throws ClassCastException {
        return (FunctionExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BinaryExpression`. If the actual instance is not `BinaryExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BinaryExpression`
     * @throws ClassCastException if the instance is not `BinaryExpression`
     */
    public BinaryExpression getBinaryExpression() throws ClassCastException {
        return (BinaryExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CallExpression`. If the actual instance is not `CallExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CallExpression`
     * @throws ClassCastException if the instance is not `CallExpression`
     */
    public CallExpression getCallExpression() throws ClassCastException {
        return (CallExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ConditionalExpression`. If the actual instance is not `ConditionalExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ConditionalExpression`
     * @throws ClassCastException if the instance is not `ConditionalExpression`
     */
    public ConditionalExpression getConditionalExpression() throws ClassCastException {
        return (ConditionalExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `LogicalExpression`. If the actual instance is not `LogicalExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `LogicalExpression`
     * @throws ClassCastException if the instance is not `LogicalExpression`
     */
    public LogicalExpression getLogicalExpression() throws ClassCastException {
        return (LogicalExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `MemberExpression`. If the actual instance is not `MemberExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MemberExpression`
     * @throws ClassCastException if the instance is not `MemberExpression`
     */
    public MemberExpression getMemberExpression() throws ClassCastException {
        return (MemberExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `IndexExpression`. If the actual instance is not `IndexExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `IndexExpression`
     * @throws ClassCastException if the instance is not `IndexExpression`
     */
    public IndexExpression getIndexExpression() throws ClassCastException {
        return (IndexExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ObjectExpression`. If the actual instance is not `ObjectExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ObjectExpression`
     * @throws ClassCastException if the instance is not `ObjectExpression`
     */
    public ObjectExpression getObjectExpression() throws ClassCastException {
        return (ObjectExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `ParenExpression`. If the actual instance is not `ParenExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ParenExpression`
     * @throws ClassCastException if the instance is not `ParenExpression`
     */
    public ParenExpression getParenExpression() throws ClassCastException {
        return (ParenExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PipeExpression`. If the actual instance is not `PipeExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PipeExpression`
     * @throws ClassCastException if the instance is not `PipeExpression`
     */
    public PipeExpression getPipeExpression() throws ClassCastException {
        return (PipeExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `UnaryExpression`. If the actual instance is not `UnaryExpression`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UnaryExpression`
     * @throws ClassCastException if the instance is not `UnaryExpression`
     */
    public UnaryExpression getUnaryExpression() throws ClassCastException {
        return (UnaryExpression)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BooleanLiteral`. If the actual instance is not `BooleanLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BooleanLiteral`
     * @throws ClassCastException if the instance is not `BooleanLiteral`
     */
    public BooleanLiteral getBooleanLiteral() throws ClassCastException {
        return (BooleanLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `DateTimeLiteral`. If the actual instance is not `DateTimeLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DateTimeLiteral`
     * @throws ClassCastException if the instance is not `DateTimeLiteral`
     */
    public DateTimeLiteral getDateTimeLiteral() throws ClassCastException {
        return (DateTimeLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `DurationLiteral`. If the actual instance is not `DurationLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DurationLiteral`
     * @throws ClassCastException if the instance is not `DurationLiteral`
     */
    public DurationLiteral getDurationLiteral() throws ClassCastException {
        return (DurationLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `FloatLiteral`. If the actual instance is not `FloatLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FloatLiteral`
     * @throws ClassCastException if the instance is not `FloatLiteral`
     */
    public FloatLiteral getFloatLiteral() throws ClassCastException {
        return (FloatLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `IntegerLiteral`. If the actual instance is not `IntegerLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `IntegerLiteral`
     * @throws ClassCastException if the instance is not `IntegerLiteral`
     */
    public IntegerLiteral getIntegerLiteral() throws ClassCastException {
        return (IntegerLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PipeLiteral`. If the actual instance is not `PipeLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PipeLiteral`
     * @throws ClassCastException if the instance is not `PipeLiteral`
     */
    public PipeLiteral getPipeLiteral() throws ClassCastException {
        return (PipeLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `RegexpLiteral`. If the actual instance is not `RegexpLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RegexpLiteral`
     * @throws ClassCastException if the instance is not `RegexpLiteral`
     */
    public RegexpLiteral getRegexpLiteral() throws ClassCastException {
        return (RegexpLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `StringLiteral`. If the actual instance is not `StringLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `StringLiteral`
     * @throws ClassCastException if the instance is not `StringLiteral`
     */
    public StringLiteral getStringLiteral() throws ClassCastException {
        return (StringLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `UnsignedIntegerLiteral`. If the actual instance is not `UnsignedIntegerLiteral`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UnsignedIntegerLiteral`
     * @throws ClassCastException if the instance is not `UnsignedIntegerLiteral`
     */
    public UnsignedIntegerLiteral getUnsignedIntegerLiteral() throws ClassCastException {
        return (UnsignedIntegerLiteral)super.getActualInstance();
    }
    /**
     * Get the actual instance of `Identifier`. If the actual instance is not `Identifier`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `Identifier`
     * @throws ClassCastException if the instance is not `Identifier`
     */
    public Identifier getIdentifier() throws ClassCastException {
        return (Identifier)super.getActualInstance();
    }

    /**
     * Validates the JSON Element and throws an exception if issues found
     *
     * @param jsonElement JSON Element
     * @throws IOException if the JSON Element is invalid with respect to Expression
     */
    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
        // validate oneOf schemas one by one
        int validCount = 0;
        ArrayList<String> errorMessages = new ArrayList<>();
        // validate the json string with ArrayExpression
        try {
            ArrayExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for ArrayExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DictExpression
        try {
            DictExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DictExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with FunctionExpression
        try {
            FunctionExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for FunctionExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BinaryExpression
        try {
            BinaryExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BinaryExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CallExpression
        try {
            CallExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CallExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with ConditionalExpression
        try {
            ConditionalExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for ConditionalExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with LogicalExpression
        try {
            LogicalExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for LogicalExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with MemberExpression
        try {
            MemberExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for MemberExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with IndexExpression
        try {
            IndexExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for IndexExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with ObjectExpression
        try {
            ObjectExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for ObjectExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with ParenExpression
        try {
            ParenExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for ParenExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PipeExpression
        try {
            PipeExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PipeExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with UnaryExpression
        try {
            UnaryExpression.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for UnaryExpression failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BooleanLiteral
        try {
            BooleanLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BooleanLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DateTimeLiteral
        try {
            DateTimeLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DateTimeLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DurationLiteral
        try {
            DurationLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DurationLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with FloatLiteral
        try {
            FloatLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for FloatLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with IntegerLiteral
        try {
            IntegerLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for IntegerLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PipeLiteral
        try {
            PipeLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PipeLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with RegexpLiteral
        try {
            RegexpLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for RegexpLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with StringLiteral
        try {
            StringLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for StringLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with UnsignedIntegerLiteral
        try {
            UnsignedIntegerLiteral.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for UnsignedIntegerLiteral failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with Identifier
        try {
            Identifier.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for Identifier failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        if (validCount != 1) {
            throw new IOException(String.format("The JSON string is invalid for Expression with oneOf schemas: ArrayExpression, BinaryExpression, BooleanLiteral, CallExpression, ConditionalExpression, DateTimeLiteral, DictExpression, DurationLiteral, FloatLiteral, FunctionExpression, Identifier, IndexExpression, IntegerLiteral, LogicalExpression, MemberExpression, ObjectExpression, ParenExpression, PipeExpression, PipeLiteral, RegexpLiteral, StringLiteral, UnaryExpression, UnsignedIntegerLiteral. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonElement.toString()));
        }
    }

    /**
     * Create an instance of Expression given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of Expression
     * @throws IOException if the JSON string is invalid with respect to Expression
     */
    public static Expression fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, Expression.class);
    }

    /**
     * Convert an instance of Expression to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}

