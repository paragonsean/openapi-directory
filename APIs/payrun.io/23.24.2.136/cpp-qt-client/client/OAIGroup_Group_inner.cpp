/**
 * PayRun.IO
 * Open, scableable, transparent payroll API.
 *
 * The version of the OpenAPI document: 23.24.2.136
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGroup_Group_inner.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGroup_Group_inner::OAIGroup_Group_inner(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGroup_Group_inner::OAIGroup_Group_inner() {
    this->initializeModel();
}

OAIGroup_Group_inner::~OAIGroup_Group_inner() {}

void OAIGroup_Group_inner::initializeModel() {

    m_group_name_isSet = false;
    m_group_name_isValid = false;

    m_item_name_isSet = false;
    m_item_name_isValid = false;

    m_loop_expression_isSet = false;
    m_loop_expression_isValid = false;

    m_predicate_isSet = false;
    m_predicate_isValid = false;

    m_selector_isSet = false;
    m_selector_isValid = false;

    m_unique_key_variable_isSet = false;
    m_unique_key_variable_isValid = false;

    m_condition_isSet = false;
    m_condition_isValid = false;

    m_filter_isSet = false;
    m_filter_isValid = false;

    m_order_isSet = false;
    m_order_isValid = false;

    m_output_isSet = false;
    m_output_isValid = false;
}

void OAIGroup_Group_inner::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGroup_Group_inner::fromJsonObject(QJsonObject json) {

    m_group_name_isValid = ::OpenAPI::fromJsonValue(m_group_name, json[QString("@GroupName")]);
    m_group_name_isSet = !json[QString("@GroupName")].isNull() && m_group_name_isValid;

    m_item_name_isValid = ::OpenAPI::fromJsonValue(m_item_name, json[QString("@ItemName")]);
    m_item_name_isSet = !json[QString("@ItemName")].isNull() && m_item_name_isValid;

    m_loop_expression_isValid = ::OpenAPI::fromJsonValue(m_loop_expression, json[QString("@LoopExpression")]);
    m_loop_expression_isSet = !json[QString("@LoopExpression")].isNull() && m_loop_expression_isValid;

    m_predicate_isValid = ::OpenAPI::fromJsonValue(m_predicate, json[QString("@Predicate")]);
    m_predicate_isSet = !json[QString("@Predicate")].isNull() && m_predicate_isValid;

    m_selector_isValid = ::OpenAPI::fromJsonValue(m_selector, json[QString("@Selector")]);
    m_selector_isSet = !json[QString("@Selector")].isNull() && m_selector_isValid;

    m_unique_key_variable_isValid = ::OpenAPI::fromJsonValue(m_unique_key_variable, json[QString("@UniqueKeyVariable")]);
    m_unique_key_variable_isSet = !json[QString("@UniqueKeyVariable")].isNull() && m_unique_key_variable_isValid;

    m_condition_isValid = ::OpenAPI::fromJsonValue(m_condition, json[QString("Condition")]);
    m_condition_isSet = !json[QString("Condition")].isNull() && m_condition_isValid;

    m_filter_isValid = ::OpenAPI::fromJsonValue(m_filter, json[QString("Filter")]);
    m_filter_isSet = !json[QString("Filter")].isNull() && m_filter_isValid;

    m_order_isValid = ::OpenAPI::fromJsonValue(m_order, json[QString("Order")]);
    m_order_isSet = !json[QString("Order")].isNull() && m_order_isValid;

    m_output_isValid = ::OpenAPI::fromJsonValue(m_output, json[QString("Output")]);
    m_output_isSet = !json[QString("Output")].isNull() && m_output_isValid;
}

QString OAIGroup_Group_inner::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGroup_Group_inner::asJsonObject() const {
    QJsonObject obj;
    if (m_group_name_isSet) {
        obj.insert(QString("@GroupName"), ::OpenAPI::toJsonValue(m_group_name));
    }
    if (m_item_name_isSet) {
        obj.insert(QString("@ItemName"), ::OpenAPI::toJsonValue(m_item_name));
    }
    if (m_loop_expression_isSet) {
        obj.insert(QString("@LoopExpression"), ::OpenAPI::toJsonValue(m_loop_expression));
    }
    if (m_predicate_isSet) {
        obj.insert(QString("@Predicate"), ::OpenAPI::toJsonValue(m_predicate));
    }
    if (m_selector_isSet) {
        obj.insert(QString("@Selector"), ::OpenAPI::toJsonValue(m_selector));
    }
    if (m_unique_key_variable_isSet) {
        obj.insert(QString("@UniqueKeyVariable"), ::OpenAPI::toJsonValue(m_unique_key_variable));
    }
    if (m_condition.size() > 0) {
        obj.insert(QString("Condition"), ::OpenAPI::toJsonValue(m_condition));
    }
    if (m_filter.size() > 0) {
        obj.insert(QString("Filter"), ::OpenAPI::toJsonValue(m_filter));
    }
    if (m_order.size() > 0) {
        obj.insert(QString("Order"), ::OpenAPI::toJsonValue(m_order));
    }
    if (m_output.size() > 0) {
        obj.insert(QString("Output"), ::OpenAPI::toJsonValue(m_output));
    }
    return obj;
}

QString OAIGroup_Group_inner::getGroupName() const {
    return m_group_name;
}
void OAIGroup_Group_inner::setGroupName(const QString &group_name) {
    m_group_name = group_name;
    m_group_name_isSet = true;
}

bool OAIGroup_Group_inner::is_group_name_Set() const{
    return m_group_name_isSet;
}

bool OAIGroup_Group_inner::is_group_name_Valid() const{
    return m_group_name_isValid;
}

QString OAIGroup_Group_inner::getItemName() const {
    return m_item_name;
}
void OAIGroup_Group_inner::setItemName(const QString &item_name) {
    m_item_name = item_name;
    m_item_name_isSet = true;
}

bool OAIGroup_Group_inner::is_item_name_Set() const{
    return m_item_name_isSet;
}

bool OAIGroup_Group_inner::is_item_name_Valid() const{
    return m_item_name_isValid;
}

QString OAIGroup_Group_inner::getLoopExpression() const {
    return m_loop_expression;
}
void OAIGroup_Group_inner::setLoopExpression(const QString &loop_expression) {
    m_loop_expression = loop_expression;
    m_loop_expression_isSet = true;
}

bool OAIGroup_Group_inner::is_loop_expression_Set() const{
    return m_loop_expression_isSet;
}

bool OAIGroup_Group_inner::is_loop_expression_Valid() const{
    return m_loop_expression_isValid;
}

QString OAIGroup_Group_inner::getPredicate() const {
    return m_predicate;
}
void OAIGroup_Group_inner::setPredicate(const QString &predicate) {
    m_predicate = predicate;
    m_predicate_isSet = true;
}

bool OAIGroup_Group_inner::is_predicate_Set() const{
    return m_predicate_isSet;
}

bool OAIGroup_Group_inner::is_predicate_Valid() const{
    return m_predicate_isValid;
}

QString OAIGroup_Group_inner::getSelector() const {
    return m_selector;
}
void OAIGroup_Group_inner::setSelector(const QString &selector) {
    m_selector = selector;
    m_selector_isSet = true;
}

bool OAIGroup_Group_inner::is_selector_Set() const{
    return m_selector_isSet;
}

bool OAIGroup_Group_inner::is_selector_Valid() const{
    return m_selector_isValid;
}

QString OAIGroup_Group_inner::getUniqueKeyVariable() const {
    return m_unique_key_variable;
}
void OAIGroup_Group_inner::setUniqueKeyVariable(const QString &unique_key_variable) {
    m_unique_key_variable = unique_key_variable;
    m_unique_key_variable_isSet = true;
}

bool OAIGroup_Group_inner::is_unique_key_variable_Set() const{
    return m_unique_key_variable_isSet;
}

bool OAIGroup_Group_inner::is_unique_key_variable_Valid() const{
    return m_unique_key_variable_isValid;
}

QList<OAICondition_inner> OAIGroup_Group_inner::getCondition() const {
    return m_condition;
}
void OAIGroup_Group_inner::setCondition(const QList<OAICondition_inner> &condition) {
    m_condition = condition;
    m_condition_isSet = true;
}

bool OAIGroup_Group_inner::is_condition_Set() const{
    return m_condition_isSet;
}

bool OAIGroup_Group_inner::is_condition_Valid() const{
    return m_condition_isValid;
}

QList<OAIFilter_inner> OAIGroup_Group_inner::getFilter() const {
    return m_filter;
}
void OAIGroup_Group_inner::setFilter(const QList<OAIFilter_inner> &filter) {
    m_filter = filter;
    m_filter_isSet = true;
}

bool OAIGroup_Group_inner::is_filter_Set() const{
    return m_filter_isSet;
}

bool OAIGroup_Group_inner::is_filter_Valid() const{
    return m_filter_isValid;
}

QList<OAIOrder_inner> OAIGroup_Group_inner::getOrder() const {
    return m_order;
}
void OAIGroup_Group_inner::setOrder(const QList<OAIOrder_inner> &order) {
    m_order = order;
    m_order_isSet = true;
}

bool OAIGroup_Group_inner::is_order_Set() const{
    return m_order_isSet;
}

bool OAIGroup_Group_inner::is_order_Valid() const{
    return m_order_isValid;
}

QList<OAIOutput_inner> OAIGroup_Group_inner::getOutput() const {
    return m_output;
}
void OAIGroup_Group_inner::setOutput(const QList<OAIOutput_inner> &output) {
    m_output = output;
    m_output_isSet = true;
}

bool OAIGroup_Group_inner::is_output_Set() const{
    return m_output_isSet;
}

bool OAIGroup_Group_inner::is_output_Valid() const{
    return m_output_isValid;
}

bool OAIGroup_Group_inner::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_group_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_item_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_loop_expression_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_predicate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_selector_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unique_key_variable_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_condition.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_filter.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_order.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_output.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGroup_Group_inner::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
