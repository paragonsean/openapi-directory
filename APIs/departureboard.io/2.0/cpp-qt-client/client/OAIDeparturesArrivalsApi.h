/**
 * departureboard.io API
 * The departureboard.io is a high performance API written in Golang. Its goal is to provide to main functions:<br><br> (1): A JSON API interface to the legacy National Rail SOAP API: Giving developers the ability to pull live information on departures, arrivals, and services from National Rail, without having to use the legacy SOAP API provided by National Rail. Information is still pulled directly from National Rail in the background, providing the same level of real-time data without the additional complexity of having to interact with SOAP. <br><br>(2): A JSON API interface for additional National Rail information: Giving developers the ability to pull a range of information about the Rail Network, via a JSON API interface. This is not an offering that National Rail currently provide, and is custom developed. Data is sourced from periodically updated XML documents, parsed, and provided for consumption via the departureboard.io API.<br><br>This API is completely free to use for non-commercial purposes. You can explore the various sections of the documentation using the links below.<br><br> For more information please see <a href=\"https://api.departureboard.io\">https://api.departureboard.io</a>
 *
 * The version of the OpenAPI document: 2.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIDeparturesArrivalsApi_H
#define OAI_OAIDeparturesArrivalsApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIDeparturesArrivalsApi : public QObject {
    Q_OBJECT

public:
    OAIDeparturesArrivalsApi(const int timeOut = 0);
    ~OAIDeparturesArrivalsApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  crs QString [required]
    * @param[in]  api_key QString [required]
    * @param[in]  num_services qint32 [optional]
    * @param[in]  time_offset qint32 [optional]
    * @param[in]  time_window qint32 [optional]
    * @param[in]  service_details bool [optional]
    * @param[in]  filter_station QString [optional]
    * @param[in]  filter_type QString [optional]
    */
    virtual void getArrivalsAndDeparturesByCRS(const QString &crs, const QString &api_key, const ::OpenAPI::OptionalParam<qint32> &num_services = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_offset = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_window = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<bool> &service_details = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<QString> &filter_station = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &filter_type = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  crs QString [required]
    * @param[in]  api_key QString [required]
    * @param[in]  num_services qint32 [optional]
    * @param[in]  time_offset qint32 [optional]
    * @param[in]  time_window qint32 [optional]
    * @param[in]  service_details bool [optional]
    * @param[in]  filter_station QString [optional]
    */
    virtual void getArrivalsByCRS(const QString &crs, const QString &api_key, const ::OpenAPI::OptionalParam<qint32> &num_services = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_offset = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_window = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<bool> &service_details = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<QString> &filter_station = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  crs QString [required]
    * @param[in]  api_key QString [required]
    * @param[in]  num_services qint32 [optional]
    * @param[in]  time_offset qint32 [optional]
    * @param[in]  time_window qint32 [optional]
    * @param[in]  service_details bool [optional]
    * @param[in]  filter_station QString [optional]
    */
    virtual void getDeparturesByCRS(const QString &crs, const QString &api_key, const ::OpenAPI::OptionalParam<qint32> &num_services = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_offset = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_window = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<bool> &service_details = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<QString> &filter_station = ::OpenAPI::OptionalParam<QString>());


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void getArrivalsAndDeparturesByCRSCallback(OAIHttpRequestWorker *worker);
    void getArrivalsByCRSCallback(OAIHttpRequestWorker *worker);
    void getDeparturesByCRSCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void getArrivalsAndDeparturesByCRSSignal();
    void getArrivalsByCRSSignal();
    void getDeparturesByCRSSignal();


    void getArrivalsAndDeparturesByCRSSignalFull(OAIHttpRequestWorker *worker);
    void getArrivalsByCRSSignalFull(OAIHttpRequestWorker *worker);
    void getDeparturesByCRSSignalFull(OAIHttpRequestWorker *worker);

    Q_DECL_DEPRECATED_X("Use getArrivalsAndDeparturesByCRSSignalError() instead")
    void getArrivalsAndDeparturesByCRSSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void getArrivalsAndDeparturesByCRSSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArrivalsByCRSSignalError() instead")
    void getArrivalsByCRSSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void getArrivalsByCRSSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getDeparturesByCRSSignalError() instead")
    void getDeparturesByCRSSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void getDeparturesByCRSSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use getArrivalsAndDeparturesByCRSSignalErrorFull() instead")
    void getArrivalsAndDeparturesByCRSSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getArrivalsAndDeparturesByCRSSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArrivalsByCRSSignalErrorFull() instead")
    void getArrivalsByCRSSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getArrivalsByCRSSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getDeparturesByCRSSignalErrorFull() instead")
    void getDeparturesByCRSSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getDeparturesByCRSSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
