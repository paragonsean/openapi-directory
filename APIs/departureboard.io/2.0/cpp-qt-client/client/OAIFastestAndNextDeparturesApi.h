/**
 * departureboard.io API
 * The departureboard.io is a high performance API written in Golang. Its goal is to provide to main functions:<br><br> (1): A JSON API interface to the legacy National Rail SOAP API: Giving developers the ability to pull live information on departures, arrivals, and services from National Rail, without having to use the legacy SOAP API provided by National Rail. Information is still pulled directly from National Rail in the background, providing the same level of real-time data without the additional complexity of having to interact with SOAP. <br><br>(2): A JSON API interface for additional National Rail information: Giving developers the ability to pull a range of information about the Rail Network, via a JSON API interface. This is not an offering that National Rail currently provide, and is custom developed. Data is sourced from periodically updated XML documents, parsed, and provided for consumption via the departureboard.io API.<br><br>This API is completely free to use for non-commercial purposes. You can explore the various sections of the documentation using the links below.<br><br> For more information please see <a href=\"https://api.departureboard.io\">https://api.departureboard.io</a>
 *
 * The version of the OpenAPI document: 2.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIFastestAndNextDeparturesApi_H
#define OAI_OAIFastestAndNextDeparturesApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIFastestAndNextDeparturesApi : public QObject {
    Q_OBJECT

public:
    OAIFastestAndNextDeparturesApi(const int timeOut = 0);
    ~OAIFastestAndNextDeparturesApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  crs QString [required]
    * @param[in]  api_key QString [required]
    * @param[in]  filter_list QString [required]
    * @param[in]  time_offset qint32 [optional]
    * @param[in]  time_window qint32 [optional]
    * @param[in]  service_details bool [optional]
    */
    virtual void getFastestDeparturesByCRS(const QString &crs, const QString &api_key, const QString &filter_list, const ::OpenAPI::OptionalParam<qint32> &time_offset = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_window = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<bool> &service_details = ::OpenAPI::OptionalParam<bool>());

    /**
    * @param[in]  crs QString [required]
    * @param[in]  api_key QString [required]
    * @param[in]  filter_list QString [required]
    * @param[in]  time_offset qint32 [optional]
    * @param[in]  time_window qint32 [optional]
    * @param[in]  service_details bool [optional]
    */
    virtual void getNextDeparturesByCRS(const QString &crs, const QString &api_key, const QString &filter_list, const ::OpenAPI::OptionalParam<qint32> &time_offset = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &time_window = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<bool> &service_details = ::OpenAPI::OptionalParam<bool>());


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void getFastestDeparturesByCRSCallback(OAIHttpRequestWorker *worker);
    void getNextDeparturesByCRSCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void getFastestDeparturesByCRSSignal();
    void getNextDeparturesByCRSSignal();


    void getFastestDeparturesByCRSSignalFull(OAIHttpRequestWorker *worker);
    void getNextDeparturesByCRSSignalFull(OAIHttpRequestWorker *worker);

    Q_DECL_DEPRECATED_X("Use getFastestDeparturesByCRSSignalError() instead")
    void getFastestDeparturesByCRSSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void getFastestDeparturesByCRSSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getNextDeparturesByCRSSignalError() instead")
    void getNextDeparturesByCRSSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void getNextDeparturesByCRSSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use getFastestDeparturesByCRSSignalErrorFull() instead")
    void getFastestDeparturesByCRSSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getFastestDeparturesByCRSSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getNextDeparturesByCRSSignalErrorFull() instead")
    void getNextDeparturesByCRSSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getNextDeparturesByCRSSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
