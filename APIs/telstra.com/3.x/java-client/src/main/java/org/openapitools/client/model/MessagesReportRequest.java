/*
 * Messaging API v3.x
 * Send and receive SMS & MMS programmatically, leveraging Australia's leading mobile network. With Telstra's Messaging API, we take out the complexity to allow seamless messaging integration into your app, with just a few lines of code. Our REST API is enterprise grade, allowing you to communicate with engaging SMS & MMS messaging in your web and mobile apps in near real-time on a global scale.  # Introduction  # Features  # Getting Access to the API  # Getting Started  # Frequently Asked Questions 
 *
 * The version of the OpenAPI document: 3.x
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * MessagesReportRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:00:10.449267-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MessagesReportRequest {
  public static final String SERIALIZED_NAME_END_DATE = "endDate";
  @SerializedName(SERIALIZED_NAME_END_DATE)
  private LocalDate endDate;

  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_REPORT_CALLBACK_URL = "reportCallbackUrl";
  @SerializedName(SERIALIZED_NAME_REPORT_CALLBACK_URL)
  private String reportCallbackUrl;

  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private LocalDate startDate;

  public MessagesReportRequest() {
  }

  public MessagesReportRequest endDate(LocalDate endDate) {
    this.endDate = endDate;
    return this;
  }

  /**
   * Type the end date (inclusive) of your reporting period here.  Your endDate must be a date in the past, and less than three months from your startDate. Use ISO format(yyyy-mm-dd). 
   * @return endDate
   */
  @javax.annotation.Nonnull
  public LocalDate getEndDate() {
    return endDate;
  }

  public void setEndDate(LocalDate endDate) {
    this.endDate = endDate;
  }


  public MessagesReportRequest filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * Filter your messages report by:   * tag - use one of the tags assigned to your message(s)   * number - either the Virtual Number used to send the message, or the Recipient Number the message was sent to. 
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public MessagesReportRequest reportCallbackUrl(String reportCallbackUrl) {
    this.reportCallbackUrl = reportCallbackUrl;
    return this;
  }

  /**
   * Tell us the callbackUrl you want us to notify when your report is ready for download.  Sample callback response:  &lt;pre&gt;&lt;code class&#x3D;\&quot;language-sh\&quot;&gt;{   \&quot;reportId\&quot;:\&quot;1520b774-46b0-4415-a05f-7bcb1c032c59\&quot;,   \&quot;reportStatus\&quot;:\&quot;completed\&quot;,   \&quot;timestamp\&quot;:\&quot;2022-11-10T05:06:42.823Z\&quot; }&lt;/code&gt;&lt;/pre&gt; 
   * @return reportCallbackUrl
   */
  @javax.annotation.Nullable
  public String getReportCallbackUrl() {
    return reportCallbackUrl;
  }

  public void setReportCallbackUrl(String reportCallbackUrl) {
    this.reportCallbackUrl = reportCallbackUrl;
  }


  public MessagesReportRequest startDate(LocalDate startDate) {
    this.startDate = startDate;
    return this;
  }

  /**
   * Set the time period you want to generate a report for by typing the start date (inclusive) here.  Note that we only retain data for three months, so please ensure your startDate is not more than three months old.  Use ISO format(yyyy-mm-dd), e.g. 2019-08-24. 
   * @return startDate
   */
  @javax.annotation.Nonnull
  public LocalDate getStartDate() {
    return startDate;
  }

  public void setStartDate(LocalDate startDate) {
    this.startDate = startDate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MessagesReportRequest messagesReportRequest = (MessagesReportRequest) o;
    return Objects.equals(this.endDate, messagesReportRequest.endDate) &&
        Objects.equals(this.filter, messagesReportRequest.filter) &&
        Objects.equals(this.reportCallbackUrl, messagesReportRequest.reportCallbackUrl) &&
        Objects.equals(this.startDate, messagesReportRequest.startDate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(endDate, filter, reportCallbackUrl, startDate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MessagesReportRequest {\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    reportCallbackUrl: ").append(toIndentedString(reportCallbackUrl)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("endDate");
    openapiFields.add("filter");
    openapiFields.add("reportCallbackUrl");
    openapiFields.add("startDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("endDate");
    openapiRequiredFields.add("startDate");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MessagesReportRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MessagesReportRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MessagesReportRequest is not found in the empty JSON string", MessagesReportRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MessagesReportRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MessagesReportRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MessagesReportRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      if ((jsonObj.get("reportCallbackUrl") != null && !jsonObj.get("reportCallbackUrl").isJsonNull()) && !jsonObj.get("reportCallbackUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reportCallbackUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reportCallbackUrl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MessagesReportRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MessagesReportRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MessagesReportRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MessagesReportRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<MessagesReportRequest>() {
           @Override
           public void write(JsonWriter out, MessagesReportRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MessagesReportRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MessagesReportRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MessagesReportRequest
   * @throws IOException if the JSON string is invalid with respect to MessagesReportRequest
   */
  public static MessagesReportRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MessagesReportRequest.class);
  }

  /**
   * Convert an instance of MessagesReportRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

