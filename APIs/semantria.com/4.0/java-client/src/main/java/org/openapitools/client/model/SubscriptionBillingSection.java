/*
 * Semantria
 * Semantria applies Text and Sentiment Analysis to tweets, facebook posts, surveys, reviews or enterprise content.
 *
 * The version of the OpenAPI document: 4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SubscriptionBillingSection
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:11:53.720541-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SubscriptionBillingSection {
  public static final String SERIALIZED_NAME_APP_SEATS_ALLOCATED = "app_seats_allocated";
  @SerializedName(SERIALIZED_NAME_APP_SEATS_ALLOCATED)
  private Integer appSeatsAllocated;

  public static final String SERIALIZED_NAME_APP_SEATS_PERMITTED = "app_seats_permitted";
  @SerializedName(SERIALIZED_NAME_APP_SEATS_PERMITTED)
  private Integer appSeatsPermitted;

  public static final String SERIALIZED_NAME_DATA_CALLS_BALANCE = "data_calls_balance";
  @SerializedName(SERIALIZED_NAME_DATA_CALLS_BALANCE)
  private Integer dataCallsBalance;

  public static final String SERIALIZED_NAME_DATA_CALLS_LIMIT = "data_calls_limit";
  @SerializedName(SERIALIZED_NAME_DATA_CALLS_LIMIT)
  private Integer dataCallsLimit;

  public static final String SERIALIZED_NAME_DATA_CALLS_LIMIT_INTERVAL = "data_calls_limit_interval";
  @SerializedName(SERIALIZED_NAME_DATA_CALLS_LIMIT_INTERVAL)
  private Integer dataCallsLimitInterval;

  public static final String SERIALIZED_NAME_DOCS_BALANCE = "docs_balance";
  @SerializedName(SERIALIZED_NAME_DOCS_BALANCE)
  private Integer docsBalance;

  public static final String SERIALIZED_NAME_DOCS_LIMIT = "docs_limit";
  @SerializedName(SERIALIZED_NAME_DOCS_LIMIT)
  private Integer docsLimit;

  public static final String SERIALIZED_NAME_DOCS_LIMIT_INTERVAL = "docs_limit_interval";
  @SerializedName(SERIALIZED_NAME_DOCS_LIMIT_INTERVAL)
  private Integer docsLimitInterval;

  public static final String SERIALIZED_NAME_DOCS_SUGGESTED = "docs_suggested";
  @SerializedName(SERIALIZED_NAME_DOCS_SUGGESTED)
  private Integer docsSuggested;

  public static final String SERIALIZED_NAME_DOCS_SUGGESTED_INTERVAL = "docs_suggested_interval";
  @SerializedName(SERIALIZED_NAME_DOCS_SUGGESTED_INTERVAL)
  private Integer docsSuggestedInterval;

  public static final String SERIALIZED_NAME_EXPIRATION_DATE = "expiration_date";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_DATE)
  private String expirationDate;

  public static final String SERIALIZED_NAME_LIMIT_TYPE = "limit_type";
  @SerializedName(SERIALIZED_NAME_LIMIT_TYPE)
  private String limitType;

  public static final String SERIALIZED_NAME_POLLING_CALLS_BALANCE = "polling_calls_balance";
  @SerializedName(SERIALIZED_NAME_POLLING_CALLS_BALANCE)
  private Integer pollingCallsBalance;

  public static final String SERIALIZED_NAME_POLLING_CALLS_LIMIT = "polling_calls_limit";
  @SerializedName(SERIALIZED_NAME_POLLING_CALLS_LIMIT)
  private Integer pollingCallsLimit;

  public static final String SERIALIZED_NAME_POLLING_CALLS_LIMIT_INTERVAL = "polling_calls_limit_interval";
  @SerializedName(SERIALIZED_NAME_POLLING_CALLS_LIMIT_INTERVAL)
  private Integer pollingCallsLimitInterval;

  public static final String SERIALIZED_NAME_PRIORITY = "priority";
  @SerializedName(SERIALIZED_NAME_PRIORITY)
  private String priority;

  public static final String SERIALIZED_NAME_SETTINGS_CALLS_BALANCE = "settings_calls_balance";
  @SerializedName(SERIALIZED_NAME_SETTINGS_CALLS_BALANCE)
  private Integer settingsCallsBalance;

  public static final String SERIALIZED_NAME_SETTINGS_CALLS_LIMIT = "settings_calls_limit";
  @SerializedName(SERIALIZED_NAME_SETTINGS_CALLS_LIMIT)
  private Integer settingsCallsLimit;

  public static final String SERIALIZED_NAME_SETTINGS_CALLS_LIMIT_INTERVAL = "settings_calls_limit_interval";
  @SerializedName(SERIALIZED_NAME_SETTINGS_CALLS_LIMIT_INTERVAL)
  private Integer settingsCallsLimitInterval;

  public SubscriptionBillingSection() {
  }

  public SubscriptionBillingSection appSeatsAllocated(Integer appSeatsAllocated) {
    this.appSeatsAllocated = appSeatsAllocated;
    return this;
  }

  /**
   * Number of allocated application cells permitted to work with the API
   * minimum: 0
   * @return appSeatsAllocated
   */
  @javax.annotation.Nonnull
  public Integer getAppSeatsAllocated() {
    return appSeatsAllocated;
  }

  public void setAppSeatsAllocated(Integer appSeatsAllocated) {
    this.appSeatsAllocated = appSeatsAllocated;
  }


  public SubscriptionBillingSection appSeatsPermitted(Integer appSeatsPermitted) {
    this.appSeatsPermitted = appSeatsPermitted;
    return this;
  }

  /**
   * Number of permitted application to work with the same API account
   * minimum: 0
   * @return appSeatsPermitted
   */
  @javax.annotation.Nonnull
  public Integer getAppSeatsPermitted() {
    return appSeatsPermitted;
  }

  public void setAppSeatsPermitted(Integer appSeatsPermitted) {
    this.appSeatsPermitted = appSeatsPermitted;
  }


  public SubscriptionBillingSection dataCallsBalance(Integer dataCallsBalance) {
    this.dataCallsBalance = dataCallsBalance;
    return this;
  }

  /**
   * Represents actual value of remained data API calls
   * minimum: 0
   * @return dataCallsBalance
   */
  @javax.annotation.Nonnull
  public Integer getDataCallsBalance() {
    return dataCallsBalance;
  }

  public void setDataCallsBalance(Integer dataCallsBalance) {
    this.dataCallsBalance = dataCallsBalance;
  }


  public SubscriptionBillingSection dataCallsLimit(Integer dataCallsLimit) {
    this.dataCallsLimit = dataCallsLimit;
    return this;
  }

  /**
   * Represents the limit of data API calls per \&quot;data_calls_limit_interval\&quot; value
   * minimum: 0
   * @return dataCallsLimit
   */
  @javax.annotation.Nonnull
  public Integer getDataCallsLimit() {
    return dataCallsLimit;
  }

  public void setDataCallsLimit(Integer dataCallsLimit) {
    this.dataCallsLimit = dataCallsLimit;
  }


  public SubscriptionBillingSection dataCallsLimitInterval(Integer dataCallsLimitInterval) {
    this.dataCallsLimitInterval = dataCallsLimitInterval;
    return this;
  }

  /**
   * Represents an interval for the \&quot;data_calls_limit\&quot; value of current subscription
   * minimum: 0
   * @return dataCallsLimitInterval
   */
  @javax.annotation.Nonnull
  public Integer getDataCallsLimitInterval() {
    return dataCallsLimitInterval;
  }

  public void setDataCallsLimitInterval(Integer dataCallsLimitInterval) {
    this.dataCallsLimitInterval = dataCallsLimitInterval;
  }


  public SubscriptionBillingSection docsBalance(Integer docsBalance) {
    this.docsBalance = docsBalance;
    return this;
  }

  /**
   * Current transaction balance. Applicable for pay-as-you-go subscriptions only
   * minimum: 0
   * @return docsBalance
   */
  @javax.annotation.Nonnull
  public Integer getDocsBalance() {
    return docsBalance;
  }

  public void setDocsBalance(Integer docsBalance) {
    this.docsBalance = docsBalance;
  }


  public SubscriptionBillingSection docsLimit(Integer docsLimit) {
    this.docsLimit = docsLimit;
    return this;
  }

  /**
   * Represents the transactions limit per \&quot;docs_limit_interval\&quot; value
   * minimum: 0
   * @return docsLimit
   */
  @javax.annotation.Nonnull
  public Integer getDocsLimit() {
    return docsLimit;
  }

  public void setDocsLimit(Integer docsLimit) {
    this.docsLimit = docsLimit;
  }


  public SubscriptionBillingSection docsLimitInterval(Integer docsLimitInterval) {
    this.docsLimitInterval = docsLimitInterval;
    return this;
  }

  /**
   * Represents the timeframe for the \&quot;docs_limit\&quot; value of current subscription
   * minimum: 0
   * @return docsLimitInterval
   */
  @javax.annotation.Nonnull
  public Integer getDocsLimitInterval() {
    return docsLimitInterval;
  }

  public void setDocsLimitInterval(Integer docsLimitInterval) {
    this.docsLimitInterval = docsLimitInterval;
  }


  public SubscriptionBillingSection docsSuggested(Integer docsSuggested) {
    this.docsSuggested = docsSuggested;
    return this;
  }

  /**
   * Represents the amount of favorable documents suggested for throughput subscriptions
   * minimum: 0
   * @return docsSuggested
   */
  @javax.annotation.Nonnull
  public Integer getDocsSuggested() {
    return docsSuggested;
  }

  public void setDocsSuggested(Integer docsSuggested) {
    this.docsSuggested = docsSuggested;
  }


  public SubscriptionBillingSection docsSuggestedInterval(Integer docsSuggestedInterval) {
    this.docsSuggestedInterval = docsSuggestedInterval;
    return this;
  }

  /**
   * Represents the timeframe for the “docs_suggested” value of the current subscription
   * minimum: 0
   * @return docsSuggestedInterval
   */
  @javax.annotation.Nonnull
  public Integer getDocsSuggestedInterval() {
    return docsSuggestedInterval;
  }

  public void setDocsSuggestedInterval(Integer docsSuggestedInterval) {
    this.docsSuggestedInterval = docsSuggestedInterval;
  }


  public SubscriptionBillingSection expirationDate(String expirationDate) {
    this.expirationDate = expirationDate;
    return this;
  }

  /**
   * Expiration date of current subscription. Defined as a Unix time stamp
   * @return expirationDate
   */
  @javax.annotation.Nonnull
  public String getExpirationDate() {
    return expirationDate;
  }

  public void setExpirationDate(String expirationDate) {
    this.expirationDate = expirationDate;
  }


  public SubscriptionBillingSection limitType(String limitType) {
    this.limitType = limitType;
    return this;
  }

  /**
   * Subscription type can have either pay-as-you-go or throughput value
   * @return limitType
   */
  @javax.annotation.Nonnull
  public String getLimitType() {
    return limitType;
  }

  public void setLimitType(String limitType) {
    this.limitType = limitType;
  }


  public SubscriptionBillingSection pollingCallsBalance(Integer pollingCallsBalance) {
    this.pollingCallsBalance = pollingCallsBalance;
    return this;
  }

  /**
   * Represents actual value of remained polling API calls
   * minimum: 0
   * @return pollingCallsBalance
   */
  @javax.annotation.Nonnull
  public Integer getPollingCallsBalance() {
    return pollingCallsBalance;
  }

  public void setPollingCallsBalance(Integer pollingCallsBalance) {
    this.pollingCallsBalance = pollingCallsBalance;
  }


  public SubscriptionBillingSection pollingCallsLimit(Integer pollingCallsLimit) {
    this.pollingCallsLimit = pollingCallsLimit;
    return this;
  }

  /**
   * Represents the limit of polling API calls per \&quot;polling_calls_limit_interval\&quot; value
   * minimum: 0
   * @return pollingCallsLimit
   */
  @javax.annotation.Nonnull
  public Integer getPollingCallsLimit() {
    return pollingCallsLimit;
  }

  public void setPollingCallsLimit(Integer pollingCallsLimit) {
    this.pollingCallsLimit = pollingCallsLimit;
  }


  public SubscriptionBillingSection pollingCallsLimitInterval(Integer pollingCallsLimitInterval) {
    this.pollingCallsLimitInterval = pollingCallsLimitInterval;
    return this;
  }

  /**
   * Represents an interval for the \&quot;polling_calls_limit\&quot; value of current subscription
   * minimum: 0
   * @return pollingCallsLimitInterval
   */
  @javax.annotation.Nonnull
  public Integer getPollingCallsLimitInterval() {
    return pollingCallsLimitInterval;
  }

  public void setPollingCallsLimitInterval(Integer pollingCallsLimitInterval) {
    this.pollingCallsLimitInterval = pollingCallsLimitInterval;
  }


  public SubscriptionBillingSection priority(String priority) {
    this.priority = priority;
    return this;
  }

  /**
   * Processing priority of current subscriber. Can have low, normal or high value
   * @return priority
   */
  @javax.annotation.Nonnull
  public String getPriority() {
    return priority;
  }

  public void setPriority(String priority) {
    this.priority = priority;
  }


  public SubscriptionBillingSection settingsCallsBalance(Integer settingsCallsBalance) {
    this.settingsCallsBalance = settingsCallsBalance;
    return this;
  }

  /**
   * Represents actual value of remained settings API calls
   * minimum: 0
   * @return settingsCallsBalance
   */
  @javax.annotation.Nonnull
  public Integer getSettingsCallsBalance() {
    return settingsCallsBalance;
  }

  public void setSettingsCallsBalance(Integer settingsCallsBalance) {
    this.settingsCallsBalance = settingsCallsBalance;
  }


  public SubscriptionBillingSection settingsCallsLimit(Integer settingsCallsLimit) {
    this.settingsCallsLimit = settingsCallsLimit;
    return this;
  }

  /**
   * Represents the limit of settings API calls per \&quot;settings_calls_limit_interval\&quot; value
   * minimum: 0
   * @return settingsCallsLimit
   */
  @javax.annotation.Nonnull
  public Integer getSettingsCallsLimit() {
    return settingsCallsLimit;
  }

  public void setSettingsCallsLimit(Integer settingsCallsLimit) {
    this.settingsCallsLimit = settingsCallsLimit;
  }


  public SubscriptionBillingSection settingsCallsLimitInterval(Integer settingsCallsLimitInterval) {
    this.settingsCallsLimitInterval = settingsCallsLimitInterval;
    return this;
  }

  /**
   * Represents an interval for the \&quot;settings_calls_limit\&quot; value of current subscription
   * minimum: 0
   * @return settingsCallsLimitInterval
   */
  @javax.annotation.Nonnull
  public Integer getSettingsCallsLimitInterval() {
    return settingsCallsLimitInterval;
  }

  public void setSettingsCallsLimitInterval(Integer settingsCallsLimitInterval) {
    this.settingsCallsLimitInterval = settingsCallsLimitInterval;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SubscriptionBillingSection subscriptionBillingSection = (SubscriptionBillingSection) o;
    return Objects.equals(this.appSeatsAllocated, subscriptionBillingSection.appSeatsAllocated) &&
        Objects.equals(this.appSeatsPermitted, subscriptionBillingSection.appSeatsPermitted) &&
        Objects.equals(this.dataCallsBalance, subscriptionBillingSection.dataCallsBalance) &&
        Objects.equals(this.dataCallsLimit, subscriptionBillingSection.dataCallsLimit) &&
        Objects.equals(this.dataCallsLimitInterval, subscriptionBillingSection.dataCallsLimitInterval) &&
        Objects.equals(this.docsBalance, subscriptionBillingSection.docsBalance) &&
        Objects.equals(this.docsLimit, subscriptionBillingSection.docsLimit) &&
        Objects.equals(this.docsLimitInterval, subscriptionBillingSection.docsLimitInterval) &&
        Objects.equals(this.docsSuggested, subscriptionBillingSection.docsSuggested) &&
        Objects.equals(this.docsSuggestedInterval, subscriptionBillingSection.docsSuggestedInterval) &&
        Objects.equals(this.expirationDate, subscriptionBillingSection.expirationDate) &&
        Objects.equals(this.limitType, subscriptionBillingSection.limitType) &&
        Objects.equals(this.pollingCallsBalance, subscriptionBillingSection.pollingCallsBalance) &&
        Objects.equals(this.pollingCallsLimit, subscriptionBillingSection.pollingCallsLimit) &&
        Objects.equals(this.pollingCallsLimitInterval, subscriptionBillingSection.pollingCallsLimitInterval) &&
        Objects.equals(this.priority, subscriptionBillingSection.priority) &&
        Objects.equals(this.settingsCallsBalance, subscriptionBillingSection.settingsCallsBalance) &&
        Objects.equals(this.settingsCallsLimit, subscriptionBillingSection.settingsCallsLimit) &&
        Objects.equals(this.settingsCallsLimitInterval, subscriptionBillingSection.settingsCallsLimitInterval);
  }

  @Override
  public int hashCode() {
    return Objects.hash(appSeatsAllocated, appSeatsPermitted, dataCallsBalance, dataCallsLimit, dataCallsLimitInterval, docsBalance, docsLimit, docsLimitInterval, docsSuggested, docsSuggestedInterval, expirationDate, limitType, pollingCallsBalance, pollingCallsLimit, pollingCallsLimitInterval, priority, settingsCallsBalance, settingsCallsLimit, settingsCallsLimitInterval);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SubscriptionBillingSection {\n");
    sb.append("    appSeatsAllocated: ").append(toIndentedString(appSeatsAllocated)).append("\n");
    sb.append("    appSeatsPermitted: ").append(toIndentedString(appSeatsPermitted)).append("\n");
    sb.append("    dataCallsBalance: ").append(toIndentedString(dataCallsBalance)).append("\n");
    sb.append("    dataCallsLimit: ").append(toIndentedString(dataCallsLimit)).append("\n");
    sb.append("    dataCallsLimitInterval: ").append(toIndentedString(dataCallsLimitInterval)).append("\n");
    sb.append("    docsBalance: ").append(toIndentedString(docsBalance)).append("\n");
    sb.append("    docsLimit: ").append(toIndentedString(docsLimit)).append("\n");
    sb.append("    docsLimitInterval: ").append(toIndentedString(docsLimitInterval)).append("\n");
    sb.append("    docsSuggested: ").append(toIndentedString(docsSuggested)).append("\n");
    sb.append("    docsSuggestedInterval: ").append(toIndentedString(docsSuggestedInterval)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("    limitType: ").append(toIndentedString(limitType)).append("\n");
    sb.append("    pollingCallsBalance: ").append(toIndentedString(pollingCallsBalance)).append("\n");
    sb.append("    pollingCallsLimit: ").append(toIndentedString(pollingCallsLimit)).append("\n");
    sb.append("    pollingCallsLimitInterval: ").append(toIndentedString(pollingCallsLimitInterval)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    settingsCallsBalance: ").append(toIndentedString(settingsCallsBalance)).append("\n");
    sb.append("    settingsCallsLimit: ").append(toIndentedString(settingsCallsLimit)).append("\n");
    sb.append("    settingsCallsLimitInterval: ").append(toIndentedString(settingsCallsLimitInterval)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("app_seats_allocated");
    openapiFields.add("app_seats_permitted");
    openapiFields.add("data_calls_balance");
    openapiFields.add("data_calls_limit");
    openapiFields.add("data_calls_limit_interval");
    openapiFields.add("docs_balance");
    openapiFields.add("docs_limit");
    openapiFields.add("docs_limit_interval");
    openapiFields.add("docs_suggested");
    openapiFields.add("docs_suggested_interval");
    openapiFields.add("expiration_date");
    openapiFields.add("limit_type");
    openapiFields.add("polling_calls_balance");
    openapiFields.add("polling_calls_limit");
    openapiFields.add("polling_calls_limit_interval");
    openapiFields.add("priority");
    openapiFields.add("settings_calls_balance");
    openapiFields.add("settings_calls_limit");
    openapiFields.add("settings_calls_limit_interval");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("app_seats_allocated");
    openapiRequiredFields.add("app_seats_permitted");
    openapiRequiredFields.add("data_calls_balance");
    openapiRequiredFields.add("data_calls_limit");
    openapiRequiredFields.add("data_calls_limit_interval");
    openapiRequiredFields.add("docs_balance");
    openapiRequiredFields.add("docs_limit");
    openapiRequiredFields.add("docs_limit_interval");
    openapiRequiredFields.add("docs_suggested");
    openapiRequiredFields.add("docs_suggested_interval");
    openapiRequiredFields.add("expiration_date");
    openapiRequiredFields.add("limit_type");
    openapiRequiredFields.add("polling_calls_balance");
    openapiRequiredFields.add("polling_calls_limit");
    openapiRequiredFields.add("polling_calls_limit_interval");
    openapiRequiredFields.add("priority");
    openapiRequiredFields.add("settings_calls_balance");
    openapiRequiredFields.add("settings_calls_limit");
    openapiRequiredFields.add("settings_calls_limit_interval");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SubscriptionBillingSection
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SubscriptionBillingSection.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SubscriptionBillingSection is not found in the empty JSON string", SubscriptionBillingSection.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SubscriptionBillingSection.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SubscriptionBillingSection` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : SubscriptionBillingSection.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("expiration_date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expiration_date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expiration_date").toString()));
      }
      if (!jsonObj.get("limit_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `limit_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("limit_type").toString()));
      }
      if (!jsonObj.get("priority").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priority` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priority").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SubscriptionBillingSection.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SubscriptionBillingSection' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SubscriptionBillingSection> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SubscriptionBillingSection.class));

       return (TypeAdapter<T>) new TypeAdapter<SubscriptionBillingSection>() {
           @Override
           public void write(JsonWriter out, SubscriptionBillingSection value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SubscriptionBillingSection read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SubscriptionBillingSection given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SubscriptionBillingSection
   * @throws IOException if the JSON string is invalid with respect to SubscriptionBillingSection
   */
  public static SubscriptionBillingSection fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SubscriptionBillingSection.class);
  }

  /**
   * Convert an instance of SubscriptionBillingSection to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

