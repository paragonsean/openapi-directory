/*
 * Semantria
 * Semantria applies Text and Sentiment Analysis to tweets, facebook posts, surveys, reviews or enterprise content.
 *
 * The version of the OpenAPI document: 4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SubscriptionBasicSection
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:11:53.720541-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SubscriptionBasicSection {
  public static final String SERIALIZED_NAME_AUTO_RESPONSE_LIMIT = "auto_response_limit";
  @SerializedName(SERIALIZED_NAME_AUTO_RESPONSE_LIMIT)
  private Integer autoResponseLimit;

  public static final String SERIALIZED_NAME_BATCH_LIMIT = "batch_limit";
  @SerializedName(SERIALIZED_NAME_BATCH_LIMIT)
  private Integer batchLimit;

  public static final String SERIALIZED_NAME_BLACKLIST_LIMIT = "blacklist_limit";
  @SerializedName(SERIALIZED_NAME_BLACKLIST_LIMIT)
  private Integer blacklistLimit;

  public static final String SERIALIZED_NAME_CALLBACK_BATCH_LIMIT = "callback_batch_limit";
  @SerializedName(SERIALIZED_NAME_CALLBACK_BATCH_LIMIT)
  private Integer callbackBatchLimit;

  public static final String SERIALIZED_NAME_CATEGORIES_LIMIT = "categories_limit";
  @SerializedName(SERIALIZED_NAME_CATEGORIES_LIMIT)
  private Integer categoriesLimit;

  public static final String SERIALIZED_NAME_CATEGORY_SAMPLES_LIMIT = "category_samples_limit";
  @SerializedName(SERIALIZED_NAME_CATEGORY_SAMPLES_LIMIT)
  private Integer categorySamplesLimit;

  public static final String SERIALIZED_NAME_CHARACTERS_LIMIT = "characters_limit";
  @SerializedName(SERIALIZED_NAME_CHARACTERS_LIMIT)
  private Integer charactersLimit;

  public static final String SERIALIZED_NAME_COLLECTION_LIMIT = "collection_limit";
  @SerializedName(SERIALIZED_NAME_COLLECTION_LIMIT)
  private Integer collectionLimit;

  public static final String SERIALIZED_NAME_CONFIGURATIONS_LIMIT = "configurations_limit";
  @SerializedName(SERIALIZED_NAME_CONFIGURATIONS_LIMIT)
  private Integer configurationsLimit;

  public static final String SERIALIZED_NAME_ENTITIES_LIMIT = "entities_limit";
  @SerializedName(SERIALIZED_NAME_ENTITIES_LIMIT)
  private Integer entitiesLimit;

  public static final String SERIALIZED_NAME_OUTPUT_DATA_LIMIT = "output_data_limit";
  @SerializedName(SERIALIZED_NAME_OUTPUT_DATA_LIMIT)
  private Integer outputDataLimit;

  public static final String SERIALIZED_NAME_PROCESSED_BATCH_LIMIT = "processed_batch_limit";
  @SerializedName(SERIALIZED_NAME_PROCESSED_BATCH_LIMIT)
  private Integer processedBatchLimit;

  public static final String SERIALIZED_NAME_QUERIES_LIMIT = "queries_limit";
  @SerializedName(SERIALIZED_NAME_QUERIES_LIMIT)
  private Integer queriesLimit;

  public static final String SERIALIZED_NAME_RETURN_SOURCE_TEXT = "return_source_text";
  @SerializedName(SERIALIZED_NAME_RETURN_SOURCE_TEXT)
  private Boolean returnSourceText;

  public static final String SERIALIZED_NAME_SENTIMENT_LIMIT = "sentiment_limit";
  @SerializedName(SERIALIZED_NAME_SENTIMENT_LIMIT)
  private Integer sentimentLimit;

  public SubscriptionBasicSection() {
  }

  public SubscriptionBasicSection autoResponseLimit(Integer autoResponseLimit) {
    this.autoResponseLimit = autoResponseLimit;
    return this;
  }

  /**
   * Represents the maximum size of outgoing batch for auto-response feature
   * minimum: 0
   * @return autoResponseLimit
   */
  @javax.annotation.Nonnull
  public Integer getAutoResponseLimit() {
    return autoResponseLimit;
  }

  public void setAutoResponseLimit(Integer autoResponseLimit) {
    this.autoResponseLimit = autoResponseLimit;
  }


  public SubscriptionBasicSection batchLimit(Integer batchLimit) {
    this.batchLimit = batchLimit;
    return this;
  }

  /**
   * Represents the maximum size of the incoming batch in documents
   * minimum: 0
   * @return batchLimit
   */
  @javax.annotation.Nonnull
  public Integer getBatchLimit() {
    return batchLimit;
  }

  public void setBatchLimit(Integer batchLimit) {
    this.batchLimit = batchLimit;
  }


  public SubscriptionBasicSection blacklistLimit(Integer blacklistLimit) {
    this.blacklistLimit = blacklistLimit;
    return this;
  }

  /**
   * Represents the maximum number of allowed blacklist items
   * minimum: 0
   * @return blacklistLimit
   */
  @javax.annotation.Nonnull
  public Integer getBlacklistLimit() {
    return blacklistLimit;
  }

  public void setBlacklistLimit(Integer blacklistLimit) {
    this.blacklistLimit = blacklistLimit;
  }


  public SubscriptionBasicSection callbackBatchLimit(Integer callbackBatchLimit) {
    this.callbackBatchLimit = callbackBatchLimit;
    return this;
  }

  /**
   * Represents the maximum size of outgoing batch for callback data retrieving mode
   * minimum: 0
   * @return callbackBatchLimit
   */
  @javax.annotation.Nonnull
  public Integer getCallbackBatchLimit() {
    return callbackBatchLimit;
  }

  public void setCallbackBatchLimit(Integer callbackBatchLimit) {
    this.callbackBatchLimit = callbackBatchLimit;
  }


  public SubscriptionBasicSection categoriesLimit(Integer categoriesLimit) {
    this.categoriesLimit = categoriesLimit;
    return this;
  }

  /**
   * Represents the maximum number of allowed categories
   * minimum: 0
   * @return categoriesLimit
   */
  @javax.annotation.Nonnull
  public Integer getCategoriesLimit() {
    return categoriesLimit;
  }

  public void setCategoriesLimit(Integer categoriesLimit) {
    this.categoriesLimit = categoriesLimit;
  }


  public SubscriptionBasicSection categorySamplesLimit(Integer categorySamplesLimit) {
    this.categorySamplesLimit = categorySamplesLimit;
    return this;
  }

  /**
   * Represents the maximum number of allowed category samples
   * minimum: 0
   * @return categorySamplesLimit
   */
  @javax.annotation.Nonnull
  public Integer getCategorySamplesLimit() {
    return categorySamplesLimit;
  }

  public void setCategorySamplesLimit(Integer categorySamplesLimit) {
    this.categorySamplesLimit = categorySamplesLimit;
  }


  public SubscriptionBasicSection charactersLimit(Integer charactersLimit) {
    this.charactersLimit = charactersLimit;
    return this;
  }

  /**
   * Represents the maximum length of the document allowed for processing
   * minimum: 0
   * @return charactersLimit
   */
  @javax.annotation.Nonnull
  public Integer getCharactersLimit() {
    return charactersLimit;
  }

  public void setCharactersLimit(Integer charactersLimit) {
    this.charactersLimit = charactersLimit;
  }


  public SubscriptionBasicSection collectionLimit(Integer collectionLimit) {
    this.collectionLimit = collectionLimit;
    return this;
  }

  /**
   * Represents the maximum size of collection in documents
   * minimum: 0
   * @return collectionLimit
   */
  @javax.annotation.Nonnull
  public Integer getCollectionLimit() {
    return collectionLimit;
  }

  public void setCollectionLimit(Integer collectionLimit) {
    this.collectionLimit = collectionLimit;
  }


  public SubscriptionBasicSection configurationsLimit(Integer configurationsLimit) {
    this.configurationsLimit = configurationsLimit;
    return this;
  }

  /**
   * Represents the maximum number of allowed configurations
   * minimum: 0
   * @return configurationsLimit
   */
  @javax.annotation.Nonnull
  public Integer getConfigurationsLimit() {
    return configurationsLimit;
  }

  public void setConfigurationsLimit(Integer configurationsLimit) {
    this.configurationsLimit = configurationsLimit;
  }


  public SubscriptionBasicSection entitiesLimit(Integer entitiesLimit) {
    this.entitiesLimit = entitiesLimit;
    return this;
  }

  /**
   * Represents the maximum number of allowed entities
   * minimum: 0
   * @return entitiesLimit
   */
  @javax.annotation.Nonnull
  public Integer getEntitiesLimit() {
    return entitiesLimit;
  }

  public void setEntitiesLimit(Integer entitiesLimit) {
    this.entitiesLimit = entitiesLimit;
  }


  public SubscriptionBasicSection outputDataLimit(Integer outputDataLimit) {
    this.outputDataLimit = outputDataLimit;
    return this;
  }

  /**
   * Represent the maximum number allowed as output limit of configuration
   * minimum: 0
   * @return outputDataLimit
   */
  @javax.annotation.Nonnull
  public Integer getOutputDataLimit() {
    return outputDataLimit;
  }

  public void setOutputDataLimit(Integer outputDataLimit) {
    this.outputDataLimit = outputDataLimit;
  }


  public SubscriptionBasicSection processedBatchLimit(Integer processedBatchLimit) {
    this.processedBatchLimit = processedBatchLimit;
    return this;
  }

  /**
   * Represents the maximum size of outgoing batch for pulling data retrieving mode
   * minimum: 0
   * @return processedBatchLimit
   */
  @javax.annotation.Nonnull
  public Integer getProcessedBatchLimit() {
    return processedBatchLimit;
  }

  public void setProcessedBatchLimit(Integer processedBatchLimit) {
    this.processedBatchLimit = processedBatchLimit;
  }


  public SubscriptionBasicSection queriesLimit(Integer queriesLimit) {
    this.queriesLimit = queriesLimit;
    return this;
  }

  /**
   * Represents the maximum number of allowed queries
   * minimum: 0
   * @return queriesLimit
   */
  @javax.annotation.Nonnull
  public Integer getQueriesLimit() {
    return queriesLimit;
  }

  public void setQueriesLimit(Integer queriesLimit) {
    this.queriesLimit = queriesLimit;
  }


  public SubscriptionBasicSection returnSourceText(Boolean returnSourceText) {
    this.returnSourceText = returnSourceText;
    return this;
  }

  /**
   * Indicates whether responding of source text along with the analysis data is allowed or not
   * @return returnSourceText
   */
  @javax.annotation.Nonnull
  public Boolean getReturnSourceText() {
    return returnSourceText;
  }

  public void setReturnSourceText(Boolean returnSourceText) {
    this.returnSourceText = returnSourceText;
  }


  public SubscriptionBasicSection sentimentLimit(Integer sentimentLimit) {
    this.sentimentLimit = sentimentLimit;
    return this;
  }

  /**
   * Represents the maximum number of allowed sentiment-bearing phrases
   * minimum: 0
   * @return sentimentLimit
   */
  @javax.annotation.Nonnull
  public Integer getSentimentLimit() {
    return sentimentLimit;
  }

  public void setSentimentLimit(Integer sentimentLimit) {
    this.sentimentLimit = sentimentLimit;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SubscriptionBasicSection subscriptionBasicSection = (SubscriptionBasicSection) o;
    return Objects.equals(this.autoResponseLimit, subscriptionBasicSection.autoResponseLimit) &&
        Objects.equals(this.batchLimit, subscriptionBasicSection.batchLimit) &&
        Objects.equals(this.blacklistLimit, subscriptionBasicSection.blacklistLimit) &&
        Objects.equals(this.callbackBatchLimit, subscriptionBasicSection.callbackBatchLimit) &&
        Objects.equals(this.categoriesLimit, subscriptionBasicSection.categoriesLimit) &&
        Objects.equals(this.categorySamplesLimit, subscriptionBasicSection.categorySamplesLimit) &&
        Objects.equals(this.charactersLimit, subscriptionBasicSection.charactersLimit) &&
        Objects.equals(this.collectionLimit, subscriptionBasicSection.collectionLimit) &&
        Objects.equals(this.configurationsLimit, subscriptionBasicSection.configurationsLimit) &&
        Objects.equals(this.entitiesLimit, subscriptionBasicSection.entitiesLimit) &&
        Objects.equals(this.outputDataLimit, subscriptionBasicSection.outputDataLimit) &&
        Objects.equals(this.processedBatchLimit, subscriptionBasicSection.processedBatchLimit) &&
        Objects.equals(this.queriesLimit, subscriptionBasicSection.queriesLimit) &&
        Objects.equals(this.returnSourceText, subscriptionBasicSection.returnSourceText) &&
        Objects.equals(this.sentimentLimit, subscriptionBasicSection.sentimentLimit);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoResponseLimit, batchLimit, blacklistLimit, callbackBatchLimit, categoriesLimit, categorySamplesLimit, charactersLimit, collectionLimit, configurationsLimit, entitiesLimit, outputDataLimit, processedBatchLimit, queriesLimit, returnSourceText, sentimentLimit);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SubscriptionBasicSection {\n");
    sb.append("    autoResponseLimit: ").append(toIndentedString(autoResponseLimit)).append("\n");
    sb.append("    batchLimit: ").append(toIndentedString(batchLimit)).append("\n");
    sb.append("    blacklistLimit: ").append(toIndentedString(blacklistLimit)).append("\n");
    sb.append("    callbackBatchLimit: ").append(toIndentedString(callbackBatchLimit)).append("\n");
    sb.append("    categoriesLimit: ").append(toIndentedString(categoriesLimit)).append("\n");
    sb.append("    categorySamplesLimit: ").append(toIndentedString(categorySamplesLimit)).append("\n");
    sb.append("    charactersLimit: ").append(toIndentedString(charactersLimit)).append("\n");
    sb.append("    collectionLimit: ").append(toIndentedString(collectionLimit)).append("\n");
    sb.append("    configurationsLimit: ").append(toIndentedString(configurationsLimit)).append("\n");
    sb.append("    entitiesLimit: ").append(toIndentedString(entitiesLimit)).append("\n");
    sb.append("    outputDataLimit: ").append(toIndentedString(outputDataLimit)).append("\n");
    sb.append("    processedBatchLimit: ").append(toIndentedString(processedBatchLimit)).append("\n");
    sb.append("    queriesLimit: ").append(toIndentedString(queriesLimit)).append("\n");
    sb.append("    returnSourceText: ").append(toIndentedString(returnSourceText)).append("\n");
    sb.append("    sentimentLimit: ").append(toIndentedString(sentimentLimit)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("auto_response_limit");
    openapiFields.add("batch_limit");
    openapiFields.add("blacklist_limit");
    openapiFields.add("callback_batch_limit");
    openapiFields.add("categories_limit");
    openapiFields.add("category_samples_limit");
    openapiFields.add("characters_limit");
    openapiFields.add("collection_limit");
    openapiFields.add("configurations_limit");
    openapiFields.add("entities_limit");
    openapiFields.add("output_data_limit");
    openapiFields.add("processed_batch_limit");
    openapiFields.add("queries_limit");
    openapiFields.add("return_source_text");
    openapiFields.add("sentiment_limit");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("auto_response_limit");
    openapiRequiredFields.add("batch_limit");
    openapiRequiredFields.add("blacklist_limit");
    openapiRequiredFields.add("callback_batch_limit");
    openapiRequiredFields.add("categories_limit");
    openapiRequiredFields.add("category_samples_limit");
    openapiRequiredFields.add("characters_limit");
    openapiRequiredFields.add("collection_limit");
    openapiRequiredFields.add("configurations_limit");
    openapiRequiredFields.add("entities_limit");
    openapiRequiredFields.add("output_data_limit");
    openapiRequiredFields.add("processed_batch_limit");
    openapiRequiredFields.add("queries_limit");
    openapiRequiredFields.add("return_source_text");
    openapiRequiredFields.add("sentiment_limit");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SubscriptionBasicSection
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SubscriptionBasicSection.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SubscriptionBasicSection is not found in the empty JSON string", SubscriptionBasicSection.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SubscriptionBasicSection.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SubscriptionBasicSection` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : SubscriptionBasicSection.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SubscriptionBasicSection.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SubscriptionBasicSection' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SubscriptionBasicSection> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SubscriptionBasicSection.class));

       return (TypeAdapter<T>) new TypeAdapter<SubscriptionBasicSection>() {
           @Override
           public void write(JsonWriter out, SubscriptionBasicSection value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SubscriptionBasicSection read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SubscriptionBasicSection given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SubscriptionBasicSection
   * @throws IOException if the JSON string is invalid with respect to SubscriptionBasicSection
   */
  public static SubscriptionBasicSection fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SubscriptionBasicSection.class);
  }

  /**
   * Convert an instance of SubscriptionBasicSection to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

