/**
 * Semantria
 * Semantria applies Text and Sentiment Analysis to tweets, facebook posts, surveys, reviews or enterprise content.
 *
 * The version of the OpenAPI document: 4.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAISubscriptionBasicSection.h
 *
 * 
 */

#ifndef OAISubscriptionBasicSection_H
#define OAISubscriptionBasicSection_H

#include <QJsonObject>


#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {

class OAISubscriptionBasicSection : public OAIObject {
public:
    OAISubscriptionBasicSection();
    OAISubscriptionBasicSection(QString json);
    ~OAISubscriptionBasicSection() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    qint32 getAutoResponseLimit() const;
    void setAutoResponseLimit(const qint32 &auto_response_limit);
    bool is_auto_response_limit_Set() const;
    bool is_auto_response_limit_Valid() const;

    qint32 getBatchLimit() const;
    void setBatchLimit(const qint32 &batch_limit);
    bool is_batch_limit_Set() const;
    bool is_batch_limit_Valid() const;

    qint32 getBlacklistLimit() const;
    void setBlacklistLimit(const qint32 &blacklist_limit);
    bool is_blacklist_limit_Set() const;
    bool is_blacklist_limit_Valid() const;

    qint32 getCallbackBatchLimit() const;
    void setCallbackBatchLimit(const qint32 &callback_batch_limit);
    bool is_callback_batch_limit_Set() const;
    bool is_callback_batch_limit_Valid() const;

    qint32 getCategoriesLimit() const;
    void setCategoriesLimit(const qint32 &categories_limit);
    bool is_categories_limit_Set() const;
    bool is_categories_limit_Valid() const;

    qint32 getCategorySamplesLimit() const;
    void setCategorySamplesLimit(const qint32 &category_samples_limit);
    bool is_category_samples_limit_Set() const;
    bool is_category_samples_limit_Valid() const;

    qint32 getCharactersLimit() const;
    void setCharactersLimit(const qint32 &characters_limit);
    bool is_characters_limit_Set() const;
    bool is_characters_limit_Valid() const;

    qint32 getCollectionLimit() const;
    void setCollectionLimit(const qint32 &collection_limit);
    bool is_collection_limit_Set() const;
    bool is_collection_limit_Valid() const;

    qint32 getConfigurationsLimit() const;
    void setConfigurationsLimit(const qint32 &configurations_limit);
    bool is_configurations_limit_Set() const;
    bool is_configurations_limit_Valid() const;

    qint32 getEntitiesLimit() const;
    void setEntitiesLimit(const qint32 &entities_limit);
    bool is_entities_limit_Set() const;
    bool is_entities_limit_Valid() const;

    qint32 getOutputDataLimit() const;
    void setOutputDataLimit(const qint32 &output_data_limit);
    bool is_output_data_limit_Set() const;
    bool is_output_data_limit_Valid() const;

    qint32 getProcessedBatchLimit() const;
    void setProcessedBatchLimit(const qint32 &processed_batch_limit);
    bool is_processed_batch_limit_Set() const;
    bool is_processed_batch_limit_Valid() const;

    qint32 getQueriesLimit() const;
    void setQueriesLimit(const qint32 &queries_limit);
    bool is_queries_limit_Set() const;
    bool is_queries_limit_Valid() const;

    bool isReturnSourceText() const;
    void setReturnSourceText(const bool &return_source_text);
    bool is_return_source_text_Set() const;
    bool is_return_source_text_Valid() const;

    qint32 getSentimentLimit() const;
    void setSentimentLimit(const qint32 &sentiment_limit);
    bool is_sentiment_limit_Set() const;
    bool is_sentiment_limit_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    qint32 m_auto_response_limit;
    bool m_auto_response_limit_isSet;
    bool m_auto_response_limit_isValid;

    qint32 m_batch_limit;
    bool m_batch_limit_isSet;
    bool m_batch_limit_isValid;

    qint32 m_blacklist_limit;
    bool m_blacklist_limit_isSet;
    bool m_blacklist_limit_isValid;

    qint32 m_callback_batch_limit;
    bool m_callback_batch_limit_isSet;
    bool m_callback_batch_limit_isValid;

    qint32 m_categories_limit;
    bool m_categories_limit_isSet;
    bool m_categories_limit_isValid;

    qint32 m_category_samples_limit;
    bool m_category_samples_limit_isSet;
    bool m_category_samples_limit_isValid;

    qint32 m_characters_limit;
    bool m_characters_limit_isSet;
    bool m_characters_limit_isValid;

    qint32 m_collection_limit;
    bool m_collection_limit_isSet;
    bool m_collection_limit_isValid;

    qint32 m_configurations_limit;
    bool m_configurations_limit_isSet;
    bool m_configurations_limit_isValid;

    qint32 m_entities_limit;
    bool m_entities_limit_isSet;
    bool m_entities_limit_isValid;

    qint32 m_output_data_limit;
    bool m_output_data_limit_isSet;
    bool m_output_data_limit_isValid;

    qint32 m_processed_batch_limit;
    bool m_processed_batch_limit_isSet;
    bool m_processed_batch_limit_isValid;

    qint32 m_queries_limit;
    bool m_queries_limit_isSet;
    bool m_queries_limit_isValid;

    bool m_return_source_text;
    bool m_return_source_text_isSet;
    bool m_return_source_text_isValid;

    qint32 m_sentiment_limit;
    bool m_sentiment_limit_isSet;
    bool m_sentiment_limit_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAISubscriptionBasicSection)

#endif // OAISubscriptionBasicSection_H
