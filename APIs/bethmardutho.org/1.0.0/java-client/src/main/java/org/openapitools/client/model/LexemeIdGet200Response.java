/*
 * SEDRA IV API
 * The SEDRA API is documented in **OpenAPI format** and uses [ReDoc](https://github.com/Rebilly/ReDoc) for documentation. # Introduction This document describes the JSON API for the Syriac Electronic Data Research Archive (SEDRA). The SEDRA project is a linguistic and literary database of Syriac language and literature focusing on providing electronic access to the corpus of Syriac lexicons with linguistic information added to each entry in those lexicons. The API is a mechanism to provide the linguistic information stored in SEDRA to a broader audience. Additionally there is a XML API for Syriac words which conforms to a prototype Semitic Languages schema which can be found in the XSD file https://sedra.bethmardutho.org/api/semiticLanguages.xsd. # Cross-Origin Resource Sharing This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with the [W3C spec](https://www.w3.org/TR/cors/) and allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site. # Samples Explaining how to lookup words in the SEDRA API is complex and would clutter the API description. For that reason we have chosen to give the explanation of how to lookup words in its own section. SEDRA can lookup words by the SEDRA word Id. However, it will often be the case that the consumer of information provided by the SEDRA API does not know the SEDRA word Id. It is for that reason that the SEDRA API provides a method to lookup words by the Syriac text. But that process is complicated by the nature of Syriac writing. So the SEDRA API will lookup words for consonantal, partially vocalized, and fully vocalized Syriac text. Using the word Id will provide the most accurate results as the exact word will be returned. Fully vocalized text will provide the next most accurate result. The least accurate results will be returned by partially vocalized and consonantal Syriac words in that order. Following are some samples to help understand how this works. 1. By Word Id [30862](https://sedra.bethmardutho.org/api/word/30862.json) 2. By fully vocalized Syriac word [ܐܰܒܳܪܳܐ](https://sedra.bethmardutho.org/api/word/ܐܰܒܳܪܳܐ.json) 3. By partially vocalized Syriac word [ܐܶܒܪܐ](https://sedra.bethmardutho.org/api/word/ܐܶܒܪܐ.json) 4. By consonantal Syriac word [ܐܒܪܐ](https://sedra.bethmardutho.org/api/word/ܐܒܪܐ.json).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: sedra@bethmardutho.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * LexemeIdGet200Response
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:29:20.574350-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LexemeIdGet200Response {
  /**
   * The category of the Syriac lexeme or word.
   */
  @JsonAdapter(CategoryTypeEnum.Adapter.class)
  public enum CategoryTypeEnum {
    ADJECTIVE("adjective"),
    
    ADJECTIVE_OF_PLACE("adjective of place"),
    
    ADVERB("adverb"),
    
    ADVERB_ENDING_WITH_AIYT("adverb ending with aiyt"),
    
    DENOMINATIVE("denominative"),
    
    IDIOM("idiom"),
    
    NOUN("noun"),
    
    NUMERAL("numeral"),
    
    PARTICIPLE_ADJECTIVE("participle adjective"),
    
    PARTICLE("particle"),
    
    PRONOUN("pronoun"),
    
    PROPER_NOUN("proper noun"),
    
    SUBSTANTIVE("substantive"),
    
    VERB("verb"),
    
    PROPER_NOUN_INDIVIDUAL_039_S_NAME_E_G_EPHREM_("proper noun (individual&#039;s name; e.g. Ephrem)"),
    
    PROPER_NOUN_PLACE_NAME_("proper noun (place name)"),
    
    PROPER_NOUN_NATIONS_E_G_HUNS_("proper noun (nations; e.g. Huns)"),
    
    DEMONYM("demonym"),
    
    PREPOSITION("preposition"),
    
    INTERJECTION("interjection");

    private String value;

    CategoryTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CategoryTypeEnum fromValue(String value) {
      for (CategoryTypeEnum b : CategoryTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CategoryTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CategoryTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CategoryTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CategoryTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CategoryTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CATEGORY_TYPE = "categoryType";
  @SerializedName(SERIALIZED_NAME_CATEGORY_TYPE)
  private CategoryTypeEnum categoryType;

  public static final String SERIALIZED_NAME_ETYMOLOGIES = "etymologies";
  @SerializedName(SERIALIZED_NAME_ETYMOLOGIES)
  private Object etymologies = null;

  public static final String SERIALIZED_NAME_GLOSSES = "glosses";
  @SerializedName(SERIALIZED_NAME_GLOSSES)
  private Object glosses = null;

  public static final String SERIALIZED_NAME_KAYLO = "kaylo";
  @SerializedName(SERIALIZED_NAME_KAYLO)
  private Object kaylo = null;

  public static final String SERIALIZED_NAME_LEXEME = "lexeme";
  @SerializedName(SERIALIZED_NAME_LEXEME)
  private Object lexeme = null;

  public static final String SERIALIZED_NAME_ROOT = "root";
  @SerializedName(SERIALIZED_NAME_ROOT)
  private Object root = null;

  public static final String SERIALIZED_NAME_SYRIAC = "syriac";
  @SerializedName(SERIALIZED_NAME_SYRIAC)
  private String syriac;

  public static final String SERIALIZED_NAME_WORDS = "words";
  @SerializedName(SERIALIZED_NAME_WORDS)
  private List<Object> words = new ArrayList<>();

  public LexemeIdGet200Response() {
  }

  public LexemeIdGet200Response categoryType(CategoryTypeEnum categoryType) {
    this.categoryType = categoryType;
    return this;
  }

  /**
   * The category of the Syriac lexeme or word.
   * @return categoryType
   */
  @javax.annotation.Nullable
  public CategoryTypeEnum getCategoryType() {
    return categoryType;
  }

  public void setCategoryType(CategoryTypeEnum categoryType) {
    this.categoryType = categoryType;
  }


  public LexemeIdGet200Response etymologies(Object etymologies) {
    this.etymologies = etymologies;
    return this;
  }

  /**
   * Get etymologies
   * @return etymologies
   */
  @javax.annotation.Nullable
  public Object getEtymologies() {
    return etymologies;
  }

  public void setEtymologies(Object etymologies) {
    this.etymologies = etymologies;
  }


  public LexemeIdGet200Response glosses(Object glosses) {
    this.glosses = glosses;
    return this;
  }

  /**
   * Get glosses
   * @return glosses
   */
  @javax.annotation.Nullable
  public Object getGlosses() {
    return glosses;
  }

  public void setGlosses(Object glosses) {
    this.glosses = glosses;
  }


  public LexemeIdGet200Response kaylo(Object kaylo) {
    this.kaylo = kaylo;
    return this;
  }

  /**
   * Get kaylo
   * @return kaylo
   */
  @javax.annotation.Nullable
  public Object getKaylo() {
    return kaylo;
  }

  public void setKaylo(Object kaylo) {
    this.kaylo = kaylo;
  }


  public LexemeIdGet200Response lexeme(Object lexeme) {
    this.lexeme = lexeme;
    return this;
  }

  /**
   * Get lexeme
   * @return lexeme
   */
  @javax.annotation.Nonnull
  public Object getLexeme() {
    return lexeme;
  }

  public void setLexeme(Object lexeme) {
    this.lexeme = lexeme;
  }


  public LexemeIdGet200Response root(Object root) {
    this.root = root;
    return this;
  }

  /**
   * Get root
   * @return root
   */
  @javax.annotation.Nullable
  public Object getRoot() {
    return root;
  }

  public void setRoot(Object root) {
    this.root = root;
  }


  public LexemeIdGet200Response syriac(String syriac) {
    this.syriac = syriac;
    return this;
  }

  /**
   * Consonantal form of this Syriac lexeme.
   * @return syriac
   */
  @javax.annotation.Nonnull
  public String getSyriac() {
    return syriac;
  }

  public void setSyriac(String syriac) {
    this.syriac = syriac;
  }


  public LexemeIdGet200Response words(List<Object> words) {
    this.words = words;
    return this;
  }

  public LexemeIdGet200Response addWordsItem(Object wordsItem) {
    if (this.words == null) {
      this.words = new ArrayList<>();
    }
    this.words.add(wordsItem);
    return this;
  }

  /**
   * Get words
   * @return words
   */
  @javax.annotation.Nullable
  public List<Object> getWords() {
    return words;
  }

  public void setWords(List<Object> words) {
    this.words = words;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LexemeIdGet200Response lexemeIdGet200Response = (LexemeIdGet200Response) o;
    return Objects.equals(this.categoryType, lexemeIdGet200Response.categoryType) &&
        Objects.equals(this.etymologies, lexemeIdGet200Response.etymologies) &&
        Objects.equals(this.glosses, lexemeIdGet200Response.glosses) &&
        Objects.equals(this.kaylo, lexemeIdGet200Response.kaylo) &&
        Objects.equals(this.lexeme, lexemeIdGet200Response.lexeme) &&
        Objects.equals(this.root, lexemeIdGet200Response.root) &&
        Objects.equals(this.syriac, lexemeIdGet200Response.syriac) &&
        Objects.equals(this.words, lexemeIdGet200Response.words);
  }

  @Override
  public int hashCode() {
    return Objects.hash(categoryType, etymologies, glosses, kaylo, lexeme, root, syriac, words);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LexemeIdGet200Response {\n");
    sb.append("    categoryType: ").append(toIndentedString(categoryType)).append("\n");
    sb.append("    etymologies: ").append(toIndentedString(etymologies)).append("\n");
    sb.append("    glosses: ").append(toIndentedString(glosses)).append("\n");
    sb.append("    kaylo: ").append(toIndentedString(kaylo)).append("\n");
    sb.append("    lexeme: ").append(toIndentedString(lexeme)).append("\n");
    sb.append("    root: ").append(toIndentedString(root)).append("\n");
    sb.append("    syriac: ").append(toIndentedString(syriac)).append("\n");
    sb.append("    words: ").append(toIndentedString(words)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("categoryType");
    openapiFields.add("etymologies");
    openapiFields.add("glosses");
    openapiFields.add("kaylo");
    openapiFields.add("lexeme");
    openapiFields.add("root");
    openapiFields.add("syriac");
    openapiFields.add("words");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("lexeme");
    openapiRequiredFields.add("syriac");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LexemeIdGet200Response
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LexemeIdGet200Response.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LexemeIdGet200Response is not found in the empty JSON string", LexemeIdGet200Response.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LexemeIdGet200Response.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LexemeIdGet200Response` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LexemeIdGet200Response.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("categoryType") != null && !jsonObj.get("categoryType").isJsonNull()) && !jsonObj.get("categoryType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `categoryType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("categoryType").toString()));
      }
      // validate the optional field `categoryType`
      if (jsonObj.get("categoryType") != null && !jsonObj.get("categoryType").isJsonNull()) {
        CategoryTypeEnum.validateJsonElement(jsonObj.get("categoryType"));
      }
      if (!jsonObj.get("syriac").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `syriac` to be a primitive type in the JSON string but got `%s`", jsonObj.get("syriac").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("words") != null && !jsonObj.get("words").isJsonNull() && !jsonObj.get("words").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `words` to be an array in the JSON string but got `%s`", jsonObj.get("words").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LexemeIdGet200Response.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LexemeIdGet200Response' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LexemeIdGet200Response> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LexemeIdGet200Response.class));

       return (TypeAdapter<T>) new TypeAdapter<LexemeIdGet200Response>() {
           @Override
           public void write(JsonWriter out, LexemeIdGet200Response value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LexemeIdGet200Response read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LexemeIdGet200Response given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LexemeIdGet200Response
   * @throws IOException if the JSON string is invalid with respect to LexemeIdGet200Response
   */
  public static LexemeIdGet200Response fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LexemeIdGet200Response.class);
  }

  /**
   * Convert an instance of LexemeIdGet200Response to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

