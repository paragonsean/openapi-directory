/**
 * ETSI GS MEC 010-2 - Part 2: Application lifecycle, rules and requirements management
 * ETSI GS MEC 010-2 - Part 2: Application lifecycle, rules and requirements management described using OpenAPI.
 *
 * The version of the OpenAPI document: 2.1.1
 * Contact: cti_support@etsi.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITrafficFilter.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITrafficFilter::OAITrafficFilter(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITrafficFilter::OAITrafficFilter() {
    this->initializeModel();
}

OAITrafficFilter::~OAITrafficFilter() {}

void OAITrafficFilter::initializeModel() {

    m_d_scp_isSet = false;
    m_d_scp_isValid = false;

    m_dst_address_isSet = false;
    m_dst_address_isValid = false;

    m_dst_port_isSet = false;
    m_dst_port_isValid = false;

    m_dst_tunnel_port_isSet = false;
    m_dst_tunnel_port_isValid = false;

    m_protocol_isSet = false;
    m_protocol_isValid = false;

    m_q_ci_isSet = false;
    m_q_ci_isValid = false;

    m_src_address_isSet = false;
    m_src_address_isValid = false;

    m_src_port_isSet = false;
    m_src_port_isValid = false;

    m_src_tunnel_address_isSet = false;
    m_src_tunnel_address_isValid = false;

    m_src_tunnel_port_isSet = false;
    m_src_tunnel_port_isValid = false;

    m_t_c_isSet = false;
    m_t_c_isValid = false;

    m_tag_isSet = false;
    m_tag_isValid = false;

    m_tgt_tunnel_address_isSet = false;
    m_tgt_tunnel_address_isValid = false;
}

void OAITrafficFilter::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITrafficFilter::fromJsonObject(QJsonObject json) {

    m_d_scp_isValid = ::OpenAPI::fromJsonValue(m_d_scp, json[QString("dSCP")]);
    m_d_scp_isSet = !json[QString("dSCP")].isNull() && m_d_scp_isValid;

    m_dst_address_isValid = ::OpenAPI::fromJsonValue(m_dst_address, json[QString("dstAddress")]);
    m_dst_address_isSet = !json[QString("dstAddress")].isNull() && m_dst_address_isValid;

    m_dst_port_isValid = ::OpenAPI::fromJsonValue(m_dst_port, json[QString("dstPort")]);
    m_dst_port_isSet = !json[QString("dstPort")].isNull() && m_dst_port_isValid;

    m_dst_tunnel_port_isValid = ::OpenAPI::fromJsonValue(m_dst_tunnel_port, json[QString("dstTunnelPort")]);
    m_dst_tunnel_port_isSet = !json[QString("dstTunnelPort")].isNull() && m_dst_tunnel_port_isValid;

    m_protocol_isValid = ::OpenAPI::fromJsonValue(m_protocol, json[QString("protocol")]);
    m_protocol_isSet = !json[QString("protocol")].isNull() && m_protocol_isValid;

    m_q_ci_isValid = ::OpenAPI::fromJsonValue(m_q_ci, json[QString("qCI")]);
    m_q_ci_isSet = !json[QString("qCI")].isNull() && m_q_ci_isValid;

    m_src_address_isValid = ::OpenAPI::fromJsonValue(m_src_address, json[QString("srcAddress")]);
    m_src_address_isSet = !json[QString("srcAddress")].isNull() && m_src_address_isValid;

    m_src_port_isValid = ::OpenAPI::fromJsonValue(m_src_port, json[QString("srcPort")]);
    m_src_port_isSet = !json[QString("srcPort")].isNull() && m_src_port_isValid;

    m_src_tunnel_address_isValid = ::OpenAPI::fromJsonValue(m_src_tunnel_address, json[QString("srcTunnelAddress")]);
    m_src_tunnel_address_isSet = !json[QString("srcTunnelAddress")].isNull() && m_src_tunnel_address_isValid;

    m_src_tunnel_port_isValid = ::OpenAPI::fromJsonValue(m_src_tunnel_port, json[QString("srcTunnelPort")]);
    m_src_tunnel_port_isSet = !json[QString("srcTunnelPort")].isNull() && m_src_tunnel_port_isValid;

    m_t_c_isValid = ::OpenAPI::fromJsonValue(m_t_c, json[QString("tC")]);
    m_t_c_isSet = !json[QString("tC")].isNull() && m_t_c_isValid;

    m_tag_isValid = ::OpenAPI::fromJsonValue(m_tag, json[QString("tag")]);
    m_tag_isSet = !json[QString("tag")].isNull() && m_tag_isValid;

    m_tgt_tunnel_address_isValid = ::OpenAPI::fromJsonValue(m_tgt_tunnel_address, json[QString("tgtTunnelAddress")]);
    m_tgt_tunnel_address_isSet = !json[QString("tgtTunnelAddress")].isNull() && m_tgt_tunnel_address_isValid;
}

QString OAITrafficFilter::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITrafficFilter::asJsonObject() const {
    QJsonObject obj;
    if (m_d_scp_isSet) {
        obj.insert(QString("dSCP"), ::OpenAPI::toJsonValue(m_d_scp));
    }
    if (m_dst_address.size() > 0) {
        obj.insert(QString("dstAddress"), ::OpenAPI::toJsonValue(m_dst_address));
    }
    if (m_dst_port.size() > 0) {
        obj.insert(QString("dstPort"), ::OpenAPI::toJsonValue(m_dst_port));
    }
    if (m_dst_tunnel_port.size() > 0) {
        obj.insert(QString("dstTunnelPort"), ::OpenAPI::toJsonValue(m_dst_tunnel_port));
    }
    if (m_protocol.size() > 0) {
        obj.insert(QString("protocol"), ::OpenAPI::toJsonValue(m_protocol));
    }
    if (m_q_ci_isSet) {
        obj.insert(QString("qCI"), ::OpenAPI::toJsonValue(m_q_ci));
    }
    if (m_src_address.size() > 0) {
        obj.insert(QString("srcAddress"), ::OpenAPI::toJsonValue(m_src_address));
    }
    if (m_src_port.size() > 0) {
        obj.insert(QString("srcPort"), ::OpenAPI::toJsonValue(m_src_port));
    }
    if (m_src_tunnel_address.size() > 0) {
        obj.insert(QString("srcTunnelAddress"), ::OpenAPI::toJsonValue(m_src_tunnel_address));
    }
    if (m_src_tunnel_port.size() > 0) {
        obj.insert(QString("srcTunnelPort"), ::OpenAPI::toJsonValue(m_src_tunnel_port));
    }
    if (m_t_c_isSet) {
        obj.insert(QString("tC"), ::OpenAPI::toJsonValue(m_t_c));
    }
    if (m_tag.size() > 0) {
        obj.insert(QString("tag"), ::OpenAPI::toJsonValue(m_tag));
    }
    if (m_tgt_tunnel_address.size() > 0) {
        obj.insert(QString("tgtTunnelAddress"), ::OpenAPI::toJsonValue(m_tgt_tunnel_address));
    }
    return obj;
}

qint32 OAITrafficFilter::getDScp() const {
    return m_d_scp;
}
void OAITrafficFilter::setDScp(const qint32 &d_scp) {
    m_d_scp = d_scp;
    m_d_scp_isSet = true;
}

bool OAITrafficFilter::is_d_scp_Set() const{
    return m_d_scp_isSet;
}

bool OAITrafficFilter::is_d_scp_Valid() const{
    return m_d_scp_isValid;
}

QList<QString> OAITrafficFilter::getDstAddress() const {
    return m_dst_address;
}
void OAITrafficFilter::setDstAddress(const QList<QString> &dst_address) {
    m_dst_address = dst_address;
    m_dst_address_isSet = true;
}

bool OAITrafficFilter::is_dst_address_Set() const{
    return m_dst_address_isSet;
}

bool OAITrafficFilter::is_dst_address_Valid() const{
    return m_dst_address_isValid;
}

QList<QString> OAITrafficFilter::getDstPort() const {
    return m_dst_port;
}
void OAITrafficFilter::setDstPort(const QList<QString> &dst_port) {
    m_dst_port = dst_port;
    m_dst_port_isSet = true;
}

bool OAITrafficFilter::is_dst_port_Set() const{
    return m_dst_port_isSet;
}

bool OAITrafficFilter::is_dst_port_Valid() const{
    return m_dst_port_isValid;
}

QList<QString> OAITrafficFilter::getDstTunnelPort() const {
    return m_dst_tunnel_port;
}
void OAITrafficFilter::setDstTunnelPort(const QList<QString> &dst_tunnel_port) {
    m_dst_tunnel_port = dst_tunnel_port;
    m_dst_tunnel_port_isSet = true;
}

bool OAITrafficFilter::is_dst_tunnel_port_Set() const{
    return m_dst_tunnel_port_isSet;
}

bool OAITrafficFilter::is_dst_tunnel_port_Valid() const{
    return m_dst_tunnel_port_isValid;
}

QList<QString> OAITrafficFilter::getProtocol() const {
    return m_protocol;
}
void OAITrafficFilter::setProtocol(const QList<QString> &protocol) {
    m_protocol = protocol;
    m_protocol_isSet = true;
}

bool OAITrafficFilter::is_protocol_Set() const{
    return m_protocol_isSet;
}

bool OAITrafficFilter::is_protocol_Valid() const{
    return m_protocol_isValid;
}

qint32 OAITrafficFilter::getQCi() const {
    return m_q_ci;
}
void OAITrafficFilter::setQCi(const qint32 &q_ci) {
    m_q_ci = q_ci;
    m_q_ci_isSet = true;
}

bool OAITrafficFilter::is_q_ci_Set() const{
    return m_q_ci_isSet;
}

bool OAITrafficFilter::is_q_ci_Valid() const{
    return m_q_ci_isValid;
}

QList<QString> OAITrafficFilter::getSrcAddress() const {
    return m_src_address;
}
void OAITrafficFilter::setSrcAddress(const QList<QString> &src_address) {
    m_src_address = src_address;
    m_src_address_isSet = true;
}

bool OAITrafficFilter::is_src_address_Set() const{
    return m_src_address_isSet;
}

bool OAITrafficFilter::is_src_address_Valid() const{
    return m_src_address_isValid;
}

QList<QString> OAITrafficFilter::getSrcPort() const {
    return m_src_port;
}
void OAITrafficFilter::setSrcPort(const QList<QString> &src_port) {
    m_src_port = src_port;
    m_src_port_isSet = true;
}

bool OAITrafficFilter::is_src_port_Set() const{
    return m_src_port_isSet;
}

bool OAITrafficFilter::is_src_port_Valid() const{
    return m_src_port_isValid;
}

QList<QString> OAITrafficFilter::getSrcTunnelAddress() const {
    return m_src_tunnel_address;
}
void OAITrafficFilter::setSrcTunnelAddress(const QList<QString> &src_tunnel_address) {
    m_src_tunnel_address = src_tunnel_address;
    m_src_tunnel_address_isSet = true;
}

bool OAITrafficFilter::is_src_tunnel_address_Set() const{
    return m_src_tunnel_address_isSet;
}

bool OAITrafficFilter::is_src_tunnel_address_Valid() const{
    return m_src_tunnel_address_isValid;
}

QList<QString> OAITrafficFilter::getSrcTunnelPort() const {
    return m_src_tunnel_port;
}
void OAITrafficFilter::setSrcTunnelPort(const QList<QString> &src_tunnel_port) {
    m_src_tunnel_port = src_tunnel_port;
    m_src_tunnel_port_isSet = true;
}

bool OAITrafficFilter::is_src_tunnel_port_Set() const{
    return m_src_tunnel_port_isSet;
}

bool OAITrafficFilter::is_src_tunnel_port_Valid() const{
    return m_src_tunnel_port_isValid;
}

qint32 OAITrafficFilter::getTC() const {
    return m_t_c;
}
void OAITrafficFilter::setTC(const qint32 &t_c) {
    m_t_c = t_c;
    m_t_c_isSet = true;
}

bool OAITrafficFilter::is_t_c_Set() const{
    return m_t_c_isSet;
}

bool OAITrafficFilter::is_t_c_Valid() const{
    return m_t_c_isValid;
}

QList<QString> OAITrafficFilter::getTag() const {
    return m_tag;
}
void OAITrafficFilter::setTag(const QList<QString> &tag) {
    m_tag = tag;
    m_tag_isSet = true;
}

bool OAITrafficFilter::is_tag_Set() const{
    return m_tag_isSet;
}

bool OAITrafficFilter::is_tag_Valid() const{
    return m_tag_isValid;
}

QList<QString> OAITrafficFilter::getTgtTunnelAddress() const {
    return m_tgt_tunnel_address;
}
void OAITrafficFilter::setTgtTunnelAddress(const QList<QString> &tgt_tunnel_address) {
    m_tgt_tunnel_address = tgt_tunnel_address;
    m_tgt_tunnel_address_isSet = true;
}

bool OAITrafficFilter::is_tgt_tunnel_address_Set() const{
    return m_tgt_tunnel_address_isSet;
}

bool OAITrafficFilter::is_tgt_tunnel_address_Valid() const{
    return m_tgt_tunnel_address_isValid;
}

bool OAITrafficFilter::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_d_scp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dst_address.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_dst_port.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_dst_tunnel_port.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_protocol.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_q_ci_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_src_address.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_src_port.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_src_tunnel_address.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_src_tunnel_port.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_t_c_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tag.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_tgt_tunnel_address.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITrafficFilter::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
