/*
 * Gitea API.
 * This documentation describes the Gitea API.
 *
 * The version of the OpenAPI document: 1.20.0+dev-539-g5e389228f
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ExternalTracker;
import org.openapitools.client.model.ExternalWiki;
import org.openapitools.client.model.InternalTracker;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * EditRepoOption options when editing a repository&#39;s properties
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:09:48.734827-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class EditRepoOption {
  public static final String SERIALIZED_NAME_ALLOW_MANUAL_MERGE = "allow_manual_merge";
  @SerializedName(SERIALIZED_NAME_ALLOW_MANUAL_MERGE)
  private Boolean allowManualMerge;

  public static final String SERIALIZED_NAME_ALLOW_MERGE_COMMITS = "allow_merge_commits";
  @SerializedName(SERIALIZED_NAME_ALLOW_MERGE_COMMITS)
  private Boolean allowMergeCommits;

  public static final String SERIALIZED_NAME_ALLOW_REBASE = "allow_rebase";
  @SerializedName(SERIALIZED_NAME_ALLOW_REBASE)
  private Boolean allowRebase;

  public static final String SERIALIZED_NAME_ALLOW_REBASE_EXPLICIT = "allow_rebase_explicit";
  @SerializedName(SERIALIZED_NAME_ALLOW_REBASE_EXPLICIT)
  private Boolean allowRebaseExplicit;

  public static final String SERIALIZED_NAME_ALLOW_REBASE_UPDATE = "allow_rebase_update";
  @SerializedName(SERIALIZED_NAME_ALLOW_REBASE_UPDATE)
  private Boolean allowRebaseUpdate;

  public static final String SERIALIZED_NAME_ALLOW_SQUASH_MERGE = "allow_squash_merge";
  @SerializedName(SERIALIZED_NAME_ALLOW_SQUASH_MERGE)
  private Boolean allowSquashMerge;

  public static final String SERIALIZED_NAME_ARCHIVED = "archived";
  @SerializedName(SERIALIZED_NAME_ARCHIVED)
  private Boolean archived;

  public static final String SERIALIZED_NAME_AUTODETECT_MANUAL_MERGE = "autodetect_manual_merge";
  @SerializedName(SERIALIZED_NAME_AUTODETECT_MANUAL_MERGE)
  private Boolean autodetectManualMerge;

  public static final String SERIALIZED_NAME_DEFAULT_ALLOW_MAINTAINER_EDIT = "default_allow_maintainer_edit";
  @SerializedName(SERIALIZED_NAME_DEFAULT_ALLOW_MAINTAINER_EDIT)
  private Boolean defaultAllowMaintainerEdit;

  public static final String SERIALIZED_NAME_DEFAULT_BRANCH = "default_branch";
  @SerializedName(SERIALIZED_NAME_DEFAULT_BRANCH)
  private String defaultBranch;

  public static final String SERIALIZED_NAME_DEFAULT_DELETE_BRANCH_AFTER_MERGE = "default_delete_branch_after_merge";
  @SerializedName(SERIALIZED_NAME_DEFAULT_DELETE_BRANCH_AFTER_MERGE)
  private Boolean defaultDeleteBranchAfterMerge;

  public static final String SERIALIZED_NAME_DEFAULT_MERGE_STYLE = "default_merge_style";
  @SerializedName(SERIALIZED_NAME_DEFAULT_MERGE_STYLE)
  private String defaultMergeStyle;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ENABLE_PRUNE = "enable_prune";
  @SerializedName(SERIALIZED_NAME_ENABLE_PRUNE)
  private Boolean enablePrune;

  public static final String SERIALIZED_NAME_EXTERNAL_TRACKER = "external_tracker";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_TRACKER)
  private ExternalTracker externalTracker;

  public static final String SERIALIZED_NAME_EXTERNAL_WIKI = "external_wiki";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_WIKI)
  private ExternalWiki externalWiki;

  public static final String SERIALIZED_NAME_HAS_ACTIONS = "has_actions";
  @SerializedName(SERIALIZED_NAME_HAS_ACTIONS)
  private Boolean hasActions;

  public static final String SERIALIZED_NAME_HAS_ISSUES = "has_issues";
  @SerializedName(SERIALIZED_NAME_HAS_ISSUES)
  private Boolean hasIssues;

  public static final String SERIALIZED_NAME_HAS_PACKAGES = "has_packages";
  @SerializedName(SERIALIZED_NAME_HAS_PACKAGES)
  private Boolean hasPackages;

  public static final String SERIALIZED_NAME_HAS_PROJECTS = "has_projects";
  @SerializedName(SERIALIZED_NAME_HAS_PROJECTS)
  private Boolean hasProjects;

  public static final String SERIALIZED_NAME_HAS_PULL_REQUESTS = "has_pull_requests";
  @SerializedName(SERIALIZED_NAME_HAS_PULL_REQUESTS)
  private Boolean hasPullRequests;

  public static final String SERIALIZED_NAME_HAS_RELEASES = "has_releases";
  @SerializedName(SERIALIZED_NAME_HAS_RELEASES)
  private Boolean hasReleases;

  public static final String SERIALIZED_NAME_HAS_WIKI = "has_wiki";
  @SerializedName(SERIALIZED_NAME_HAS_WIKI)
  private Boolean hasWiki;

  public static final String SERIALIZED_NAME_IGNORE_WHITESPACE_CONFLICTS = "ignore_whitespace_conflicts";
  @SerializedName(SERIALIZED_NAME_IGNORE_WHITESPACE_CONFLICTS)
  private Boolean ignoreWhitespaceConflicts;

  public static final String SERIALIZED_NAME_INTERNAL_TRACKER = "internal_tracker";
  @SerializedName(SERIALIZED_NAME_INTERNAL_TRACKER)
  private InternalTracker internalTracker;

  public static final String SERIALIZED_NAME_MIRROR_INTERVAL = "mirror_interval";
  @SerializedName(SERIALIZED_NAME_MIRROR_INTERVAL)
  private String mirrorInterval;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PRIVATE = "private";
  @SerializedName(SERIALIZED_NAME_PRIVATE)
  private Boolean _private;

  public static final String SERIALIZED_NAME_TEMPLATE = "template";
  @SerializedName(SERIALIZED_NAME_TEMPLATE)
  private Boolean template;

  public static final String SERIALIZED_NAME_WEBSITE = "website";
  @SerializedName(SERIALIZED_NAME_WEBSITE)
  private String website;

  public EditRepoOption() {
  }

  public EditRepoOption allowManualMerge(Boolean allowManualMerge) {
    this.allowManualMerge = allowManualMerge;
    return this;
  }

  /**
   * either &#x60;true&#x60; to allow mark pr as merged manually, or &#x60;false&#x60; to prevent it.
   * @return allowManualMerge
   */
  @javax.annotation.Nullable
  public Boolean getAllowManualMerge() {
    return allowManualMerge;
  }

  public void setAllowManualMerge(Boolean allowManualMerge) {
    this.allowManualMerge = allowManualMerge;
  }


  public EditRepoOption allowMergeCommits(Boolean allowMergeCommits) {
    this.allowMergeCommits = allowMergeCommits;
    return this;
  }

  /**
   * either &#x60;true&#x60; to allow merging pull requests with a merge commit, or &#x60;false&#x60; to prevent merging pull requests with merge commits.
   * @return allowMergeCommits
   */
  @javax.annotation.Nullable
  public Boolean getAllowMergeCommits() {
    return allowMergeCommits;
  }

  public void setAllowMergeCommits(Boolean allowMergeCommits) {
    this.allowMergeCommits = allowMergeCommits;
  }


  public EditRepoOption allowRebase(Boolean allowRebase) {
    this.allowRebase = allowRebase;
    return this;
  }

  /**
   * either &#x60;true&#x60; to allow rebase-merging pull requests, or &#x60;false&#x60; to prevent rebase-merging.
   * @return allowRebase
   */
  @javax.annotation.Nullable
  public Boolean getAllowRebase() {
    return allowRebase;
  }

  public void setAllowRebase(Boolean allowRebase) {
    this.allowRebase = allowRebase;
  }


  public EditRepoOption allowRebaseExplicit(Boolean allowRebaseExplicit) {
    this.allowRebaseExplicit = allowRebaseExplicit;
    return this;
  }

  /**
   * either &#x60;true&#x60; to allow rebase with explicit merge commits (--no-ff), or &#x60;false&#x60; to prevent rebase with explicit merge commits.
   * @return allowRebaseExplicit
   */
  @javax.annotation.Nullable
  public Boolean getAllowRebaseExplicit() {
    return allowRebaseExplicit;
  }

  public void setAllowRebaseExplicit(Boolean allowRebaseExplicit) {
    this.allowRebaseExplicit = allowRebaseExplicit;
  }


  public EditRepoOption allowRebaseUpdate(Boolean allowRebaseUpdate) {
    this.allowRebaseUpdate = allowRebaseUpdate;
    return this;
  }

  /**
   * either &#x60;true&#x60; to allow updating pull request branch by rebase, or &#x60;false&#x60; to prevent it.
   * @return allowRebaseUpdate
   */
  @javax.annotation.Nullable
  public Boolean getAllowRebaseUpdate() {
    return allowRebaseUpdate;
  }

  public void setAllowRebaseUpdate(Boolean allowRebaseUpdate) {
    this.allowRebaseUpdate = allowRebaseUpdate;
  }


  public EditRepoOption allowSquashMerge(Boolean allowSquashMerge) {
    this.allowSquashMerge = allowSquashMerge;
    return this;
  }

  /**
   * either &#x60;true&#x60; to allow squash-merging pull requests, or &#x60;false&#x60; to prevent squash-merging.
   * @return allowSquashMerge
   */
  @javax.annotation.Nullable
  public Boolean getAllowSquashMerge() {
    return allowSquashMerge;
  }

  public void setAllowSquashMerge(Boolean allowSquashMerge) {
    this.allowSquashMerge = allowSquashMerge;
  }


  public EditRepoOption archived(Boolean archived) {
    this.archived = archived;
    return this;
  }

  /**
   * set to &#x60;true&#x60; to archive this repository.
   * @return archived
   */
  @javax.annotation.Nullable
  public Boolean getArchived() {
    return archived;
  }

  public void setArchived(Boolean archived) {
    this.archived = archived;
  }


  public EditRepoOption autodetectManualMerge(Boolean autodetectManualMerge) {
    this.autodetectManualMerge = autodetectManualMerge;
    return this;
  }

  /**
   * either &#x60;true&#x60; to enable AutodetectManualMerge, or &#x60;false&#x60; to prevent it. Note: In some special cases, misjudgments can occur.
   * @return autodetectManualMerge
   */
  @javax.annotation.Nullable
  public Boolean getAutodetectManualMerge() {
    return autodetectManualMerge;
  }

  public void setAutodetectManualMerge(Boolean autodetectManualMerge) {
    this.autodetectManualMerge = autodetectManualMerge;
  }


  public EditRepoOption defaultAllowMaintainerEdit(Boolean defaultAllowMaintainerEdit) {
    this.defaultAllowMaintainerEdit = defaultAllowMaintainerEdit;
    return this;
  }

  /**
   * set to &#x60;true&#x60; to allow edits from maintainers by default
   * @return defaultAllowMaintainerEdit
   */
  @javax.annotation.Nullable
  public Boolean getDefaultAllowMaintainerEdit() {
    return defaultAllowMaintainerEdit;
  }

  public void setDefaultAllowMaintainerEdit(Boolean defaultAllowMaintainerEdit) {
    this.defaultAllowMaintainerEdit = defaultAllowMaintainerEdit;
  }


  public EditRepoOption defaultBranch(String defaultBranch) {
    this.defaultBranch = defaultBranch;
    return this;
  }

  /**
   * sets the default branch for this repository.
   * @return defaultBranch
   */
  @javax.annotation.Nullable
  public String getDefaultBranch() {
    return defaultBranch;
  }

  public void setDefaultBranch(String defaultBranch) {
    this.defaultBranch = defaultBranch;
  }


  public EditRepoOption defaultDeleteBranchAfterMerge(Boolean defaultDeleteBranchAfterMerge) {
    this.defaultDeleteBranchAfterMerge = defaultDeleteBranchAfterMerge;
    return this;
  }

  /**
   * set to &#x60;true&#x60; to delete pr branch after merge by default
   * @return defaultDeleteBranchAfterMerge
   */
  @javax.annotation.Nullable
  public Boolean getDefaultDeleteBranchAfterMerge() {
    return defaultDeleteBranchAfterMerge;
  }

  public void setDefaultDeleteBranchAfterMerge(Boolean defaultDeleteBranchAfterMerge) {
    this.defaultDeleteBranchAfterMerge = defaultDeleteBranchAfterMerge;
  }


  public EditRepoOption defaultMergeStyle(String defaultMergeStyle) {
    this.defaultMergeStyle = defaultMergeStyle;
    return this;
  }

  /**
   * set to a merge style to be used by this repository: \&quot;merge\&quot;, \&quot;rebase\&quot;, \&quot;rebase-merge\&quot;, or \&quot;squash\&quot;.
   * @return defaultMergeStyle
   */
  @javax.annotation.Nullable
  public String getDefaultMergeStyle() {
    return defaultMergeStyle;
  }

  public void setDefaultMergeStyle(String defaultMergeStyle) {
    this.defaultMergeStyle = defaultMergeStyle;
  }


  public EditRepoOption description(String description) {
    this.description = description;
    return this;
  }

  /**
   * a short description of the repository.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public EditRepoOption enablePrune(Boolean enablePrune) {
    this.enablePrune = enablePrune;
    return this;
  }

  /**
   * enable prune - remove obsolete remote-tracking references
   * @return enablePrune
   */
  @javax.annotation.Nullable
  public Boolean getEnablePrune() {
    return enablePrune;
  }

  public void setEnablePrune(Boolean enablePrune) {
    this.enablePrune = enablePrune;
  }


  public EditRepoOption externalTracker(ExternalTracker externalTracker) {
    this.externalTracker = externalTracker;
    return this;
  }

  /**
   * Get externalTracker
   * @return externalTracker
   */
  @javax.annotation.Nullable
  public ExternalTracker getExternalTracker() {
    return externalTracker;
  }

  public void setExternalTracker(ExternalTracker externalTracker) {
    this.externalTracker = externalTracker;
  }


  public EditRepoOption externalWiki(ExternalWiki externalWiki) {
    this.externalWiki = externalWiki;
    return this;
  }

  /**
   * Get externalWiki
   * @return externalWiki
   */
  @javax.annotation.Nullable
  public ExternalWiki getExternalWiki() {
    return externalWiki;
  }

  public void setExternalWiki(ExternalWiki externalWiki) {
    this.externalWiki = externalWiki;
  }


  public EditRepoOption hasActions(Boolean hasActions) {
    this.hasActions = hasActions;
    return this;
  }

  /**
   * either &#x60;true&#x60; to enable actions unit, or &#x60;false&#x60; to disable them.
   * @return hasActions
   */
  @javax.annotation.Nullable
  public Boolean getHasActions() {
    return hasActions;
  }

  public void setHasActions(Boolean hasActions) {
    this.hasActions = hasActions;
  }


  public EditRepoOption hasIssues(Boolean hasIssues) {
    this.hasIssues = hasIssues;
    return this;
  }

  /**
   * either &#x60;true&#x60; to enable issues for this repository or &#x60;false&#x60; to disable them.
   * @return hasIssues
   */
  @javax.annotation.Nullable
  public Boolean getHasIssues() {
    return hasIssues;
  }

  public void setHasIssues(Boolean hasIssues) {
    this.hasIssues = hasIssues;
  }


  public EditRepoOption hasPackages(Boolean hasPackages) {
    this.hasPackages = hasPackages;
    return this;
  }

  /**
   * either &#x60;true&#x60; to enable packages unit, or &#x60;false&#x60; to disable them.
   * @return hasPackages
   */
  @javax.annotation.Nullable
  public Boolean getHasPackages() {
    return hasPackages;
  }

  public void setHasPackages(Boolean hasPackages) {
    this.hasPackages = hasPackages;
  }


  public EditRepoOption hasProjects(Boolean hasProjects) {
    this.hasProjects = hasProjects;
    return this;
  }

  /**
   * either &#x60;true&#x60; to enable project unit, or &#x60;false&#x60; to disable them.
   * @return hasProjects
   */
  @javax.annotation.Nullable
  public Boolean getHasProjects() {
    return hasProjects;
  }

  public void setHasProjects(Boolean hasProjects) {
    this.hasProjects = hasProjects;
  }


  public EditRepoOption hasPullRequests(Boolean hasPullRequests) {
    this.hasPullRequests = hasPullRequests;
    return this;
  }

  /**
   * either &#x60;true&#x60; to allow pull requests, or &#x60;false&#x60; to prevent pull request.
   * @return hasPullRequests
   */
  @javax.annotation.Nullable
  public Boolean getHasPullRequests() {
    return hasPullRequests;
  }

  public void setHasPullRequests(Boolean hasPullRequests) {
    this.hasPullRequests = hasPullRequests;
  }


  public EditRepoOption hasReleases(Boolean hasReleases) {
    this.hasReleases = hasReleases;
    return this;
  }

  /**
   * either &#x60;true&#x60; to enable releases unit, or &#x60;false&#x60; to disable them.
   * @return hasReleases
   */
  @javax.annotation.Nullable
  public Boolean getHasReleases() {
    return hasReleases;
  }

  public void setHasReleases(Boolean hasReleases) {
    this.hasReleases = hasReleases;
  }


  public EditRepoOption hasWiki(Boolean hasWiki) {
    this.hasWiki = hasWiki;
    return this;
  }

  /**
   * either &#x60;true&#x60; to enable the wiki for this repository or &#x60;false&#x60; to disable it.
   * @return hasWiki
   */
  @javax.annotation.Nullable
  public Boolean getHasWiki() {
    return hasWiki;
  }

  public void setHasWiki(Boolean hasWiki) {
    this.hasWiki = hasWiki;
  }


  public EditRepoOption ignoreWhitespaceConflicts(Boolean ignoreWhitespaceConflicts) {
    this.ignoreWhitespaceConflicts = ignoreWhitespaceConflicts;
    return this;
  }

  /**
   * either &#x60;true&#x60; to ignore whitespace for conflicts, or &#x60;false&#x60; to not ignore whitespace.
   * @return ignoreWhitespaceConflicts
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreWhitespaceConflicts() {
    return ignoreWhitespaceConflicts;
  }

  public void setIgnoreWhitespaceConflicts(Boolean ignoreWhitespaceConflicts) {
    this.ignoreWhitespaceConflicts = ignoreWhitespaceConflicts;
  }


  public EditRepoOption internalTracker(InternalTracker internalTracker) {
    this.internalTracker = internalTracker;
    return this;
  }

  /**
   * Get internalTracker
   * @return internalTracker
   */
  @javax.annotation.Nullable
  public InternalTracker getInternalTracker() {
    return internalTracker;
  }

  public void setInternalTracker(InternalTracker internalTracker) {
    this.internalTracker = internalTracker;
  }


  public EditRepoOption mirrorInterval(String mirrorInterval) {
    this.mirrorInterval = mirrorInterval;
    return this;
  }

  /**
   * set to a string like &#x60;8h30m0s&#x60; to set the mirror interval time
   * @return mirrorInterval
   */
  @javax.annotation.Nullable
  public String getMirrorInterval() {
    return mirrorInterval;
  }

  public void setMirrorInterval(String mirrorInterval) {
    this.mirrorInterval = mirrorInterval;
  }


  public EditRepoOption name(String name) {
    this.name = name;
    return this;
  }

  /**
   * name of the repository
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public EditRepoOption _private(Boolean _private) {
    this._private = _private;
    return this;
  }

  /**
   * either &#x60;true&#x60; to make the repository private or &#x60;false&#x60; to make it public. Note: you will get a 422 error if the organization restricts changing repository visibility to organization owners and a non-owner tries to change the value of private.
   * @return _private
   */
  @javax.annotation.Nullable
  public Boolean getPrivate() {
    return _private;
  }

  public void setPrivate(Boolean _private) {
    this._private = _private;
  }


  public EditRepoOption template(Boolean template) {
    this.template = template;
    return this;
  }

  /**
   * either &#x60;true&#x60; to make this repository a template or &#x60;false&#x60; to make it a normal repository
   * @return template
   */
  @javax.annotation.Nullable
  public Boolean getTemplate() {
    return template;
  }

  public void setTemplate(Boolean template) {
    this.template = template;
  }


  public EditRepoOption website(String website) {
    this.website = website;
    return this;
  }

  /**
   * a URL with more information about the repository.
   * @return website
   */
  @javax.annotation.Nullable
  public String getWebsite() {
    return website;
  }

  public void setWebsite(String website) {
    this.website = website;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EditRepoOption editRepoOption = (EditRepoOption) o;
    return Objects.equals(this.allowManualMerge, editRepoOption.allowManualMerge) &&
        Objects.equals(this.allowMergeCommits, editRepoOption.allowMergeCommits) &&
        Objects.equals(this.allowRebase, editRepoOption.allowRebase) &&
        Objects.equals(this.allowRebaseExplicit, editRepoOption.allowRebaseExplicit) &&
        Objects.equals(this.allowRebaseUpdate, editRepoOption.allowRebaseUpdate) &&
        Objects.equals(this.allowSquashMerge, editRepoOption.allowSquashMerge) &&
        Objects.equals(this.archived, editRepoOption.archived) &&
        Objects.equals(this.autodetectManualMerge, editRepoOption.autodetectManualMerge) &&
        Objects.equals(this.defaultAllowMaintainerEdit, editRepoOption.defaultAllowMaintainerEdit) &&
        Objects.equals(this.defaultBranch, editRepoOption.defaultBranch) &&
        Objects.equals(this.defaultDeleteBranchAfterMerge, editRepoOption.defaultDeleteBranchAfterMerge) &&
        Objects.equals(this.defaultMergeStyle, editRepoOption.defaultMergeStyle) &&
        Objects.equals(this.description, editRepoOption.description) &&
        Objects.equals(this.enablePrune, editRepoOption.enablePrune) &&
        Objects.equals(this.externalTracker, editRepoOption.externalTracker) &&
        Objects.equals(this.externalWiki, editRepoOption.externalWiki) &&
        Objects.equals(this.hasActions, editRepoOption.hasActions) &&
        Objects.equals(this.hasIssues, editRepoOption.hasIssues) &&
        Objects.equals(this.hasPackages, editRepoOption.hasPackages) &&
        Objects.equals(this.hasProjects, editRepoOption.hasProjects) &&
        Objects.equals(this.hasPullRequests, editRepoOption.hasPullRequests) &&
        Objects.equals(this.hasReleases, editRepoOption.hasReleases) &&
        Objects.equals(this.hasWiki, editRepoOption.hasWiki) &&
        Objects.equals(this.ignoreWhitespaceConflicts, editRepoOption.ignoreWhitespaceConflicts) &&
        Objects.equals(this.internalTracker, editRepoOption.internalTracker) &&
        Objects.equals(this.mirrorInterval, editRepoOption.mirrorInterval) &&
        Objects.equals(this.name, editRepoOption.name) &&
        Objects.equals(this._private, editRepoOption._private) &&
        Objects.equals(this.template, editRepoOption.template) &&
        Objects.equals(this.website, editRepoOption.website);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowManualMerge, allowMergeCommits, allowRebase, allowRebaseExplicit, allowRebaseUpdate, allowSquashMerge, archived, autodetectManualMerge, defaultAllowMaintainerEdit, defaultBranch, defaultDeleteBranchAfterMerge, defaultMergeStyle, description, enablePrune, externalTracker, externalWiki, hasActions, hasIssues, hasPackages, hasProjects, hasPullRequests, hasReleases, hasWiki, ignoreWhitespaceConflicts, internalTracker, mirrorInterval, name, _private, template, website);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EditRepoOption {\n");
    sb.append("    allowManualMerge: ").append(toIndentedString(allowManualMerge)).append("\n");
    sb.append("    allowMergeCommits: ").append(toIndentedString(allowMergeCommits)).append("\n");
    sb.append("    allowRebase: ").append(toIndentedString(allowRebase)).append("\n");
    sb.append("    allowRebaseExplicit: ").append(toIndentedString(allowRebaseExplicit)).append("\n");
    sb.append("    allowRebaseUpdate: ").append(toIndentedString(allowRebaseUpdate)).append("\n");
    sb.append("    allowSquashMerge: ").append(toIndentedString(allowSquashMerge)).append("\n");
    sb.append("    archived: ").append(toIndentedString(archived)).append("\n");
    sb.append("    autodetectManualMerge: ").append(toIndentedString(autodetectManualMerge)).append("\n");
    sb.append("    defaultAllowMaintainerEdit: ").append(toIndentedString(defaultAllowMaintainerEdit)).append("\n");
    sb.append("    defaultBranch: ").append(toIndentedString(defaultBranch)).append("\n");
    sb.append("    defaultDeleteBranchAfterMerge: ").append(toIndentedString(defaultDeleteBranchAfterMerge)).append("\n");
    sb.append("    defaultMergeStyle: ").append(toIndentedString(defaultMergeStyle)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    enablePrune: ").append(toIndentedString(enablePrune)).append("\n");
    sb.append("    externalTracker: ").append(toIndentedString(externalTracker)).append("\n");
    sb.append("    externalWiki: ").append(toIndentedString(externalWiki)).append("\n");
    sb.append("    hasActions: ").append(toIndentedString(hasActions)).append("\n");
    sb.append("    hasIssues: ").append(toIndentedString(hasIssues)).append("\n");
    sb.append("    hasPackages: ").append(toIndentedString(hasPackages)).append("\n");
    sb.append("    hasProjects: ").append(toIndentedString(hasProjects)).append("\n");
    sb.append("    hasPullRequests: ").append(toIndentedString(hasPullRequests)).append("\n");
    sb.append("    hasReleases: ").append(toIndentedString(hasReleases)).append("\n");
    sb.append("    hasWiki: ").append(toIndentedString(hasWiki)).append("\n");
    sb.append("    ignoreWhitespaceConflicts: ").append(toIndentedString(ignoreWhitespaceConflicts)).append("\n");
    sb.append("    internalTracker: ").append(toIndentedString(internalTracker)).append("\n");
    sb.append("    mirrorInterval: ").append(toIndentedString(mirrorInterval)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    _private: ").append(toIndentedString(_private)).append("\n");
    sb.append("    template: ").append(toIndentedString(template)).append("\n");
    sb.append("    website: ").append(toIndentedString(website)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allow_manual_merge");
    openapiFields.add("allow_merge_commits");
    openapiFields.add("allow_rebase");
    openapiFields.add("allow_rebase_explicit");
    openapiFields.add("allow_rebase_update");
    openapiFields.add("allow_squash_merge");
    openapiFields.add("archived");
    openapiFields.add("autodetect_manual_merge");
    openapiFields.add("default_allow_maintainer_edit");
    openapiFields.add("default_branch");
    openapiFields.add("default_delete_branch_after_merge");
    openapiFields.add("default_merge_style");
    openapiFields.add("description");
    openapiFields.add("enable_prune");
    openapiFields.add("external_tracker");
    openapiFields.add("external_wiki");
    openapiFields.add("has_actions");
    openapiFields.add("has_issues");
    openapiFields.add("has_packages");
    openapiFields.add("has_projects");
    openapiFields.add("has_pull_requests");
    openapiFields.add("has_releases");
    openapiFields.add("has_wiki");
    openapiFields.add("ignore_whitespace_conflicts");
    openapiFields.add("internal_tracker");
    openapiFields.add("mirror_interval");
    openapiFields.add("name");
    openapiFields.add("private");
    openapiFields.add("template");
    openapiFields.add("website");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to EditRepoOption
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EditRepoOption.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EditRepoOption is not found in the empty JSON string", EditRepoOption.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!EditRepoOption.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EditRepoOption` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("default_branch") != null && !jsonObj.get("default_branch").isJsonNull()) && !jsonObj.get("default_branch").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `default_branch` to be a primitive type in the JSON string but got `%s`", jsonObj.get("default_branch").toString()));
      }
      if ((jsonObj.get("default_merge_style") != null && !jsonObj.get("default_merge_style").isJsonNull()) && !jsonObj.get("default_merge_style").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `default_merge_style` to be a primitive type in the JSON string but got `%s`", jsonObj.get("default_merge_style").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // validate the optional field `external_tracker`
      if (jsonObj.get("external_tracker") != null && !jsonObj.get("external_tracker").isJsonNull()) {
        ExternalTracker.validateJsonElement(jsonObj.get("external_tracker"));
      }
      // validate the optional field `external_wiki`
      if (jsonObj.get("external_wiki") != null && !jsonObj.get("external_wiki").isJsonNull()) {
        ExternalWiki.validateJsonElement(jsonObj.get("external_wiki"));
      }
      // validate the optional field `internal_tracker`
      if (jsonObj.get("internal_tracker") != null && !jsonObj.get("internal_tracker").isJsonNull()) {
        InternalTracker.validateJsonElement(jsonObj.get("internal_tracker"));
      }
      if ((jsonObj.get("mirror_interval") != null && !jsonObj.get("mirror_interval").isJsonNull()) && !jsonObj.get("mirror_interval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mirror_interval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mirror_interval").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("website") != null && !jsonObj.get("website").isJsonNull()) && !jsonObj.get("website").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `website` to be a primitive type in the JSON string but got `%s`", jsonObj.get("website").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EditRepoOption.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EditRepoOption' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EditRepoOption> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EditRepoOption.class));

       return (TypeAdapter<T>) new TypeAdapter<EditRepoOption>() {
           @Override
           public void write(JsonWriter out, EditRepoOption value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EditRepoOption read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of EditRepoOption given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of EditRepoOption
   * @throws IOException if the JSON string is invalid with respect to EditRepoOption
   */
  public static EditRepoOption fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EditRepoOption.class);
  }

  /**
   * Convert an instance of EditRepoOption to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

