/*
 * Background Removal API
 * Remove the background of any image
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * RemoveBgJson
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:59:19.553431-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RemoveBgJson {
  public static final String SERIALIZED_NAME_ADD_SHADOW = "add_shadow";
  @SerializedName(SERIALIZED_NAME_ADD_SHADOW)
  private Boolean addShadow = false;

  public static final String SERIALIZED_NAME_BG_COLOR = "bg_color";
  @SerializedName(SERIALIZED_NAME_BG_COLOR)
  private String bgColor;

  public static final String SERIALIZED_NAME_BG_IMAGE_URL = "bg_image_url";
  @SerializedName(SERIALIZED_NAME_BG_IMAGE_URL)
  private String bgImageUrl;

  /**
   * Request either the finalized image (\&quot;rgba\&quot;, default) or an alpha mask (\&quot;alpha\&quot;). Note: Since remove.bg also applies RGB color corrections on edges, using only the alpha mask often leads to a lower final image quality. Therefore \&quot;rgba\&quot; is recommended. 
   */
  @JsonAdapter(ChannelsEnum.Adapter.class)
  public enum ChannelsEnum {
    RGBA("rgba"),
    
    ALPHA("alpha");

    private String value;

    ChannelsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ChannelsEnum fromValue(String value) {
      for (ChannelsEnum b : ChannelsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ChannelsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ChannelsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ChannelsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ChannelsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ChannelsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CHANNELS = "channels";
  @SerializedName(SERIALIZED_NAME_CHANNELS)
  private ChannelsEnum channels = ChannelsEnum.RGBA;

  public static final String SERIALIZED_NAME_CROP = "crop";
  @SerializedName(SERIALIZED_NAME_CROP)
  private Boolean crop = false;

  public static final String SERIALIZED_NAME_CROP_MARGIN = "crop_margin";
  @SerializedName(SERIALIZED_NAME_CROP_MARGIN)
  private String cropMargin = "0";

  /**
   * Result image format: \&quot;auto\&quot; &#x3D; Use PNG format if transparent regions exist, otherwise use JPG format (default), \&quot;png\&quot; &#x3D; PNG format with alpha transparency, \&quot;jpg\&quot; &#x3D; JPG format, no transparency, \&quot;zip\&quot; &#x3D; ZIP format, contains color image and alpha matte image, supports transparency (recommended). 
   */
  @JsonAdapter(FormatEnum.Adapter.class)
  public enum FormatEnum {
    AUTO("auto"),
    
    PNG("png"),
    
    JPG("jpg"),
    
    ZIP("zip");

    private String value;

    FormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FormatEnum fromValue(String value) {
      for (FormatEnum b : FormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FormatEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FormatEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  private FormatEnum format = FormatEnum.AUTO;

  public static final String SERIALIZED_NAME_IMAGE_FILE_B64 = "image_file_b64";
  @SerializedName(SERIALIZED_NAME_IMAGE_FILE_B64)
  private String imageFileB64;

  public static final String SERIALIZED_NAME_IMAGE_URL = "image_url";
  @SerializedName(SERIALIZED_NAME_IMAGE_URL)
  private String imageUrl;

  public static final String SERIALIZED_NAME_POSITION = "position";
  @SerializedName(SERIALIZED_NAME_POSITION)
  private String position = "original";

  public static final String SERIALIZED_NAME_ROI = "roi";
  @SerializedName(SERIALIZED_NAME_ROI)
  private String roi = "0% 0% 100% 100%";

  public static final String SERIALIZED_NAME_SCALE = "scale";
  @SerializedName(SERIALIZED_NAME_SCALE)
  private String scale = "original";

  public static final String SERIALIZED_NAME_SEMITRANSPARENCY = "semitransparency";
  @SerializedName(SERIALIZED_NAME_SEMITRANSPARENCY)
  private Boolean semitransparency = true;

  /**
   * Maximum output image resolution: \&quot;preview\&quot; (default) &#x3D; Resize image to 0.25 megapixels (e.g. 625×400 pixels) – 0.25 credits per image, \&quot;full\&quot; &#x3D; Use original image resolution, up to 25 megapixels (e.g. 6250x4000) with formats ZIP or JPG, or up to 10 megapixels (e.g. 4000x2500) with PNG – 1 credit per image), \&quot;auto\&quot; &#x3D; Use highest available resolution (based on image size and available credits).  For backwards-compatibility this parameter also accepts the values \&quot;medium\&quot; (up to 1.5 megapixels) and \&quot;hd\&quot; (up to 4 megapixels) for 1 credit per image. The value \&quot;full\&quot; is also available under the name \&quot;4k\&quot; and the value \&quot;preview\&quot; is aliased as \&quot;small\&quot; and \&quot;regular\&quot;. 
   */
  @JsonAdapter(SizeEnum.Adapter.class)
  public enum SizeEnum {
    PREVIEW("preview"),
    
    FULL("full"),
    
    AUTO("auto");

    private String value;

    SizeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SizeEnum fromValue(String value) {
      for (SizeEnum b : SizeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SizeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SizeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SizeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SizeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SizeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private SizeEnum size = SizeEnum.PREVIEW;

  /**
   * Foreground type: \&quot;auto\&quot; &#x3D; Automatically detect kind of foreground, \&quot;person\&quot; &#x3D; Use person(s) as foreground, \&quot;product\&quot; &#x3D; Use product(s) as foreground. \&quot;car\&quot; &#x3D; Use car as foreground, 
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    AUTO("auto"),
    
    PERSON("person"),
    
    PRODUCT("product"),
    
    CAR("car");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type = TypeEnum.AUTO;

  /**
   * Classification level of the detected foreground type: \&quot;none\&quot; &#x3D; No classification (X-Type Header won&#39;t bet set on the response) \&quot;1\&quot; &#x3D; Use coarse classification classes: [person, product, animal, car, other] \&quot;2\&quot; &#x3D; Use more specific classification classes: [person, product, animal, car, car_interior, car_part, transportation, graphics, other] \&quot;latest\&quot; &#x3D; Always use the latest classification classes available 
   */
  @JsonAdapter(TypeLevelEnum.Adapter.class)
  public enum TypeLevelEnum {
    NONE("none"),
    
    _1("1"),
    
    _2("2"),
    
    LATEST("latest");

    private String value;

    TypeLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeLevelEnum fromValue(String value) {
      for (TypeLevelEnum b : TypeLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeLevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeLevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE_LEVEL = "type_level";
  @SerializedName(SERIALIZED_NAME_TYPE_LEVEL)
  private TypeLevelEnum typeLevel = TypeLevelEnum._1;

  public RemoveBgJson() {
  }

  public RemoveBgJson addShadow(Boolean addShadow) {
    this.addShadow = addShadow;
    return this;
  }

  /**
   * Whether to add an artificial shadow to the result (default: false). NOTE: Adding shadows is currently only supported for car photos. Other subjects are returned without shadow, even if set to true (this might change in the future). 
   * @return addShadow
   */
  @javax.annotation.Nullable
  public Boolean getAddShadow() {
    return addShadow;
  }

  public void setAddShadow(Boolean addShadow) {
    this.addShadow = addShadow;
  }


  public RemoveBgJson bgColor(String bgColor) {
    this.bgColor = bgColor;
    return this;
  }

  /**
   * Adds a solid color background. Can be a hex color code (e.g. 81d4fa, fff) or a color name (e.g. green). For semi-transparency, 4-/8-digit hex codes are also supported (e.g. 81d4fa77). (If this parameter is present, the other bg_ parameters must be empty.) 
   * @return bgColor
   */
  @javax.annotation.Nullable
  public String getBgColor() {
    return bgColor;
  }

  public void setBgColor(String bgColor) {
    this.bgColor = bgColor;
  }


  public RemoveBgJson bgImageUrl(String bgImageUrl) {
    this.bgImageUrl = bgImageUrl;
    return this;
  }

  /**
   * Adds a background image from a URL. The image is centered and resized to fill the canvas while preserving the aspect ratio, unless it already has the exact same dimensions as the foreground image. (If this parameter is present, the other bg_ parameters must be empty.)
   * @return bgImageUrl
   */
  @javax.annotation.Nullable
  public String getBgImageUrl() {
    return bgImageUrl;
  }

  public void setBgImageUrl(String bgImageUrl) {
    this.bgImageUrl = bgImageUrl;
  }


  public RemoveBgJson channels(ChannelsEnum channels) {
    this.channels = channels;
    return this;
  }

  /**
   * Request either the finalized image (\&quot;rgba\&quot;, default) or an alpha mask (\&quot;alpha\&quot;). Note: Since remove.bg also applies RGB color corrections on edges, using only the alpha mask often leads to a lower final image quality. Therefore \&quot;rgba\&quot; is recommended. 
   * @return channels
   */
  @javax.annotation.Nullable
  public ChannelsEnum getChannels() {
    return channels;
  }

  public void setChannels(ChannelsEnum channels) {
    this.channels = channels;
  }


  public RemoveBgJson crop(Boolean crop) {
    this.crop = crop;
    return this;
  }

  /**
   * Whether to crop off all empty regions (default: false). Note that cropping has no effect on the amount of charged credits. 
   * @return crop
   */
  @javax.annotation.Nullable
  public Boolean getCrop() {
    return crop;
  }

  public void setCrop(Boolean crop) {
    this.crop = crop;
  }


  public RemoveBgJson cropMargin(String cropMargin) {
    this.cropMargin = cropMargin;
    return this;
  }

  /**
   * Adds a margin around the cropped subject (default: 0). Can be an absolute value (e.g. \&quot;30px\&quot;) or relative to the subject size (e.g. \&quot;10%\&quot;). Can be a single value (all sides), two values (top/bottom and left/right) or four values (top, right, bottom, left). This parameter only has an effect when \&quot;crop&#x3D;true\&quot;. The maximum margin that can be added on each side is 50% of the subject dimensions or 500 pixels. 
   * @return cropMargin
   */
  @javax.annotation.Nullable
  public String getCropMargin() {
    return cropMargin;
  }

  public void setCropMargin(String cropMargin) {
    this.cropMargin = cropMargin;
  }


  public RemoveBgJson format(FormatEnum format) {
    this.format = format;
    return this;
  }

  /**
   * Result image format: \&quot;auto\&quot; &#x3D; Use PNG format if transparent regions exist, otherwise use JPG format (default), \&quot;png\&quot; &#x3D; PNG format with alpha transparency, \&quot;jpg\&quot; &#x3D; JPG format, no transparency, \&quot;zip\&quot; &#x3D; ZIP format, contains color image and alpha matte image, supports transparency (recommended). 
   * @return format
   */
  @javax.annotation.Nullable
  public FormatEnum getFormat() {
    return format;
  }

  public void setFormat(FormatEnum format) {
    this.format = format;
  }


  public RemoveBgJson imageFileB64(String imageFileB64) {
    this.imageFileB64 = imageFileB64;
    return this;
  }

  /**
   * Source image file (base64-encoded string). (If this parameter is present, the other image source parameters must be empty.)
   * @return imageFileB64
   */
  @javax.annotation.Nullable
  public String getImageFileB64() {
    return imageFileB64;
  }

  public void setImageFileB64(String imageFileB64) {
    this.imageFileB64 = imageFileB64;
  }


  public RemoveBgJson imageUrl(String imageUrl) {
    this.imageUrl = imageUrl;
    return this;
  }

  /**
   * Source image URL. (If this parameter is present, the other image source parameters must be empty.)
   * @return imageUrl
   */
  @javax.annotation.Nullable
  public String getImageUrl() {
    return imageUrl;
  }

  public void setImageUrl(String imageUrl) {
    this.imageUrl = imageUrl;
  }


  public RemoveBgJson position(String position) {
    this.position = position;
    return this;
  }

  /**
   * Positions the subject within the image canvas. Can be \&quot;original\&quot; (default unless \&quot;scale\&quot; is given), \&quot;center\&quot; (default when \&quot;scale\&quot; is given) or a value from \&quot;0%\&quot; to \&quot;100%\&quot; (both horizontal and vertical) or two values (horizontal, vertical). 
   * @return position
   */
  @javax.annotation.Nullable
  public String getPosition() {
    return position;
  }

  public void setPosition(String position) {
    this.position = position;
  }


  public RemoveBgJson roi(String roi) {
    this.roi = roi;
    return this;
  }

  /**
   * Region of interest: Only contents of this rectangular region can be detected as foreground. Everything outside is considered background and will be removed. The rectangle is defined as two x/y coordinates in the format \&quot;x1 y1 x2 y2\&quot;. The coordinates can be in absolute pixels (suffix &#39;px&#39;) or relative to the width/height of the image (suffix &#39;%&#39;). By default, the whole image is the region of interest (\&quot;0% 0% 100% 100%\&quot;). 
   * @return roi
   */
  @javax.annotation.Nullable
  public String getRoi() {
    return roi;
  }

  public void setRoi(String roi) {
    this.roi = roi;
  }


  public RemoveBgJson scale(String scale) {
    this.scale = scale;
    return this;
  }

  /**
   * Scales the subject relative to the total image size. Can be any value from \&quot;10%\&quot; to \&quot;100%\&quot;, or \&quot;original\&quot; (default). Scaling the subject implies \&quot;position&#x3D;center\&quot; (unless specified otherwise). 
   * @return scale
   */
  @javax.annotation.Nullable
  public String getScale() {
    return scale;
  }

  public void setScale(String scale) {
    this.scale = scale;
  }


  public RemoveBgJson semitransparency(Boolean semitransparency) {
    this.semitransparency = semitransparency;
    return this;
  }

  /**
   * Whether to have semi-transparent regions in the result (default: true). NOTE: Semitransparency is currently only supported for car windows (this might change in the future). Other objects are returned without semitransparency, even if set to true. 
   * @return semitransparency
   */
  @javax.annotation.Nullable
  public Boolean getSemitransparency() {
    return semitransparency;
  }

  public void setSemitransparency(Boolean semitransparency) {
    this.semitransparency = semitransparency;
  }


  public RemoveBgJson size(SizeEnum size) {
    this.size = size;
    return this;
  }

  /**
   * Maximum output image resolution: \&quot;preview\&quot; (default) &#x3D; Resize image to 0.25 megapixels (e.g. 625×400 pixels) – 0.25 credits per image, \&quot;full\&quot; &#x3D; Use original image resolution, up to 25 megapixels (e.g. 6250x4000) with formats ZIP or JPG, or up to 10 megapixels (e.g. 4000x2500) with PNG – 1 credit per image), \&quot;auto\&quot; &#x3D; Use highest available resolution (based on image size and available credits).  For backwards-compatibility this parameter also accepts the values \&quot;medium\&quot; (up to 1.5 megapixels) and \&quot;hd\&quot; (up to 4 megapixels) for 1 credit per image. The value \&quot;full\&quot; is also available under the name \&quot;4k\&quot; and the value \&quot;preview\&quot; is aliased as \&quot;small\&quot; and \&quot;regular\&quot;. 
   * @return size
   */
  @javax.annotation.Nullable
  public SizeEnum getSize() {
    return size;
  }

  public void setSize(SizeEnum size) {
    this.size = size;
  }


  public RemoveBgJson type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Foreground type: \&quot;auto\&quot; &#x3D; Automatically detect kind of foreground, \&quot;person\&quot; &#x3D; Use person(s) as foreground, \&quot;product\&quot; &#x3D; Use product(s) as foreground. \&quot;car\&quot; &#x3D; Use car as foreground, 
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  public RemoveBgJson typeLevel(TypeLevelEnum typeLevel) {
    this.typeLevel = typeLevel;
    return this;
  }

  /**
   * Classification level of the detected foreground type: \&quot;none\&quot; &#x3D; No classification (X-Type Header won&#39;t bet set on the response) \&quot;1\&quot; &#x3D; Use coarse classification classes: [person, product, animal, car, other] \&quot;2\&quot; &#x3D; Use more specific classification classes: [person, product, animal, car, car_interior, car_part, transportation, graphics, other] \&quot;latest\&quot; &#x3D; Always use the latest classification classes available 
   * @return typeLevel
   */
  @javax.annotation.Nullable
  public TypeLevelEnum getTypeLevel() {
    return typeLevel;
  }

  public void setTypeLevel(TypeLevelEnum typeLevel) {
    this.typeLevel = typeLevel;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RemoveBgJson removeBgJson = (RemoveBgJson) o;
    return Objects.equals(this.addShadow, removeBgJson.addShadow) &&
        Objects.equals(this.bgColor, removeBgJson.bgColor) &&
        Objects.equals(this.bgImageUrl, removeBgJson.bgImageUrl) &&
        Objects.equals(this.channels, removeBgJson.channels) &&
        Objects.equals(this.crop, removeBgJson.crop) &&
        Objects.equals(this.cropMargin, removeBgJson.cropMargin) &&
        Objects.equals(this.format, removeBgJson.format) &&
        Objects.equals(this.imageFileB64, removeBgJson.imageFileB64) &&
        Objects.equals(this.imageUrl, removeBgJson.imageUrl) &&
        Objects.equals(this.position, removeBgJson.position) &&
        Objects.equals(this.roi, removeBgJson.roi) &&
        Objects.equals(this.scale, removeBgJson.scale) &&
        Objects.equals(this.semitransparency, removeBgJson.semitransparency) &&
        Objects.equals(this.size, removeBgJson.size) &&
        Objects.equals(this.type, removeBgJson.type) &&
        Objects.equals(this.typeLevel, removeBgJson.typeLevel);
  }

  @Override
  public int hashCode() {
    return Objects.hash(addShadow, bgColor, bgImageUrl, channels, crop, cropMargin, format, imageFileB64, imageUrl, position, roi, scale, semitransparency, size, type, typeLevel);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RemoveBgJson {\n");
    sb.append("    addShadow: ").append(toIndentedString(addShadow)).append("\n");
    sb.append("    bgColor: ").append(toIndentedString(bgColor)).append("\n");
    sb.append("    bgImageUrl: ").append(toIndentedString(bgImageUrl)).append("\n");
    sb.append("    channels: ").append(toIndentedString(channels)).append("\n");
    sb.append("    crop: ").append(toIndentedString(crop)).append("\n");
    sb.append("    cropMargin: ").append(toIndentedString(cropMargin)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    imageFileB64: ").append(toIndentedString(imageFileB64)).append("\n");
    sb.append("    imageUrl: ").append(toIndentedString(imageUrl)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("    roi: ").append(toIndentedString(roi)).append("\n");
    sb.append("    scale: ").append(toIndentedString(scale)).append("\n");
    sb.append("    semitransparency: ").append(toIndentedString(semitransparency)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    typeLevel: ").append(toIndentedString(typeLevel)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("add_shadow");
    openapiFields.add("bg_color");
    openapiFields.add("bg_image_url");
    openapiFields.add("channels");
    openapiFields.add("crop");
    openapiFields.add("crop_margin");
    openapiFields.add("format");
    openapiFields.add("image_file_b64");
    openapiFields.add("image_url");
    openapiFields.add("position");
    openapiFields.add("roi");
    openapiFields.add("scale");
    openapiFields.add("semitransparency");
    openapiFields.add("size");
    openapiFields.add("type");
    openapiFields.add("type_level");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RemoveBgJson
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RemoveBgJson.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RemoveBgJson is not found in the empty JSON string", RemoveBgJson.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RemoveBgJson.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RemoveBgJson` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("bg_color") != null && !jsonObj.get("bg_color").isJsonNull()) && !jsonObj.get("bg_color").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bg_color` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bg_color").toString()));
      }
      if ((jsonObj.get("bg_image_url") != null && !jsonObj.get("bg_image_url").isJsonNull()) && !jsonObj.get("bg_image_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bg_image_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bg_image_url").toString()));
      }
      if ((jsonObj.get("channels") != null && !jsonObj.get("channels").isJsonNull()) && !jsonObj.get("channels").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `channels` to be a primitive type in the JSON string but got `%s`", jsonObj.get("channels").toString()));
      }
      // validate the optional field `channels`
      if (jsonObj.get("channels") != null && !jsonObj.get("channels").isJsonNull()) {
        ChannelsEnum.validateJsonElement(jsonObj.get("channels"));
      }
      if ((jsonObj.get("crop_margin") != null && !jsonObj.get("crop_margin").isJsonNull()) && !jsonObj.get("crop_margin").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crop_margin` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crop_margin").toString()));
      }
      if ((jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      // validate the optional field `format`
      if (jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) {
        FormatEnum.validateJsonElement(jsonObj.get("format"));
      }
      if ((jsonObj.get("image_file_b64") != null && !jsonObj.get("image_file_b64").isJsonNull()) && !jsonObj.get("image_file_b64").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `image_file_b64` to be a primitive type in the JSON string but got `%s`", jsonObj.get("image_file_b64").toString()));
      }
      if ((jsonObj.get("image_url") != null && !jsonObj.get("image_url").isJsonNull()) && !jsonObj.get("image_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `image_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("image_url").toString()));
      }
      if ((jsonObj.get("position") != null && !jsonObj.get("position").isJsonNull()) && !jsonObj.get("position").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `position` to be a primitive type in the JSON string but got `%s`", jsonObj.get("position").toString()));
      }
      if ((jsonObj.get("roi") != null && !jsonObj.get("roi").isJsonNull()) && !jsonObj.get("roi").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roi` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roi").toString()));
      }
      if ((jsonObj.get("scale") != null && !jsonObj.get("scale").isJsonNull()) && !jsonObj.get("scale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scale").toString()));
      }
      if ((jsonObj.get("size") != null && !jsonObj.get("size").isJsonNull()) && !jsonObj.get("size").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `size` to be a primitive type in the JSON string but got `%s`", jsonObj.get("size").toString()));
      }
      // validate the optional field `size`
      if (jsonObj.get("size") != null && !jsonObj.get("size").isJsonNull()) {
        SizeEnum.validateJsonElement(jsonObj.get("size"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
      if ((jsonObj.get("type_level") != null && !jsonObj.get("type_level").isJsonNull()) && !jsonObj.get("type_level").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type_level` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type_level").toString()));
      }
      // validate the optional field `type_level`
      if (jsonObj.get("type_level") != null && !jsonObj.get("type_level").isJsonNull()) {
        TypeLevelEnum.validateJsonElement(jsonObj.get("type_level"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RemoveBgJson.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RemoveBgJson' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RemoveBgJson> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RemoveBgJson.class));

       return (TypeAdapter<T>) new TypeAdapter<RemoveBgJson>() {
           @Override
           public void write(JsonWriter out, RemoveBgJson value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RemoveBgJson read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RemoveBgJson given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RemoveBgJson
   * @throws IOException if the JSON string is invalid with respect to RemoveBgJson
   */
  public static RemoveBgJson fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RemoveBgJson.class);
  }

  /**
   * Convert an instance of RemoveBgJson to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

