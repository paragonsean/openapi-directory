/*
 * API docs | logoraisr.com
 * <p style=\"font-size:110%;\">Dig into our logoraisr API reference documentation. We also offer an OpenAPI specification to allow easy integration into your systems. You can download the json file by clicking on the download button.<p><br><p style=\"font-size:110%; font-weight:bold\">OpenAPI 2.0 Validation Status</p><img src=\"https://online.swagger.io/validator?url=https://docs.logoraisr.com/\">
 *
 * The version of the OpenAPI document: v1
 * Contact: support@logoraisr.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Process
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:00:25.150422-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Process {
  public static final String SERIALIZED_NAME_CROP = "crop";
  @SerializedName(SERIALIZED_NAME_CROP)
  private String crop;

  public static final String SERIALIZED_NAME_FLIP = "flip";
  @SerializedName(SERIALIZED_NAME_FLIP)
  private Boolean flip;

  public static final String SERIALIZED_NAME_MIRROR = "mirror";
  @SerializedName(SERIALIZED_NAME_MIRROR)
  private Boolean mirror;

  public static final String SERIALIZED_NAME_PROCESSING_ALGORITHM = "processing_algorithm";
  @SerializedName(SERIALIZED_NAME_PROCESSING_ALGORITHM)
  private String processingAlgorithm;

  public static final String SERIALIZED_NAME_RESIZE = "resize";
  @SerializedName(SERIALIZED_NAME_RESIZE)
  private String resize;

  public static final String SERIALIZED_NAME_ROTATE = "rotate";
  @SerializedName(SERIALIZED_NAME_ROTATE)
  private Integer rotate;

  public Process() {
  }

  public Process crop(String crop) {
    this.crop = crop;
    return this;
  }

  /**
   * Crops the image according to the specified mechanism. If you specify the size \&quot;WidthexHeight\&quot;, the image will be cropped centered. If coordinates \&quot;x1,y1,x2,y2\&quot; are given, the image is cropped according to the coordinates. The image will be cropped to the size of the stories if \&quot;faces\&quot; are specified as. Example Centered: \&quot;crop\&quot;: \&quot;200x300\&quot;. Example Region: \&quot;crop\&quot;: \&quot;200,300,150,300\&quot;. Example Faces: \&quot;crop\&quot;: \&quot;faces\&quot;.
   * @return crop
   */
  @javax.annotation.Nullable
  public String getCrop() {
    return crop;
  }

  public void setCrop(String crop) {
    this.crop = crop;
  }


  public Process flip(Boolean flip) {
    this.flip = flip;
    return this;
  }

  /**
   * Flips the image around the horizontal axis, from top to bottom. Example: \&quot;flip\&quot;: true
   * @return flip
   */
  @javax.annotation.Nullable
  public Boolean getFlip() {
    return flip;
  }

  public void setFlip(Boolean flip) {
    this.flip = flip;
  }


  public Process mirror(Boolean mirror) {
    this.mirror = mirror;
    return this;
  }

  /**
   * Mirrors the image around the vertical axis, i.e. from right to left. Example: \&quot;mirror\&quot;: true
   * @return mirror
   */
  @javax.annotation.Nullable
  public Boolean getMirror() {
    return mirror;
  }

  public void setMirror(Boolean mirror) {
    this.mirror = mirror;
  }


  public Process processingAlgorithm(String processingAlgorithm) {
    this.processingAlgorithm = processingAlgorithm;
    return this;
  }

  /**
   * Schl√ºssel welcher Verarbeitungs-Algorithmus angewendet wird. Zur Auswahl stehen \&quot;logo-to-vector\&quot;, \&quot;logo-super-resolution\&quot;, \&quot;logo-segmentation\&quot; und \&quot;image-processing\&quot;.
   * @return processingAlgorithm
   */
  @javax.annotation.Nonnull
  public String getProcessingAlgorithm() {
    return processingAlgorithm;
  }

  public void setProcessingAlgorithm(String processingAlgorithm) {
    this.processingAlgorithm = processingAlgorithm;
  }


  public Process resize(String resize) {
    this.resize = resize;
    return this;
  }

  /**
   * Changes the size of the image according to the specified size. Example: \&quot;resize\&quot;: \&quot;200x300\&quot;.
   * @return resize
   */
  @javax.annotation.Nullable
  public String getResize() {
    return resize;
  }

  public void setResize(String resize) {
    this.resize = resize;
  }


  public Process rotate(Integer rotate) {
    this.rotate = rotate;
    return this;
  }

  /**
   * Rotates the image around the center according to the specified degree. Example: \&quot;rotate\&quot;: 90
   * minimum: 0
   * maximum: 360
   * @return rotate
   */
  @javax.annotation.Nullable
  public Integer getRotate() {
    return rotate;
  }

  public void setRotate(Integer rotate) {
    this.rotate = rotate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Process process = (Process) o;
    return Objects.equals(this.crop, process.crop) &&
        Objects.equals(this.flip, process.flip) &&
        Objects.equals(this.mirror, process.mirror) &&
        Objects.equals(this.processingAlgorithm, process.processingAlgorithm) &&
        Objects.equals(this.resize, process.resize) &&
        Objects.equals(this.rotate, process.rotate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(crop, flip, mirror, processingAlgorithm, resize, rotate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Process {\n");
    sb.append("    crop: ").append(toIndentedString(crop)).append("\n");
    sb.append("    flip: ").append(toIndentedString(flip)).append("\n");
    sb.append("    mirror: ").append(toIndentedString(mirror)).append("\n");
    sb.append("    processingAlgorithm: ").append(toIndentedString(processingAlgorithm)).append("\n");
    sb.append("    resize: ").append(toIndentedString(resize)).append("\n");
    sb.append("    rotate: ").append(toIndentedString(rotate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("crop");
    openapiFields.add("flip");
    openapiFields.add("mirror");
    openapiFields.add("processing_algorithm");
    openapiFields.add("resize");
    openapiFields.add("rotate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("processing_algorithm");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Process
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Process.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Process is not found in the empty JSON string", Process.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Process.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Process` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Process.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("crop") != null && !jsonObj.get("crop").isJsonNull()) && !jsonObj.get("crop").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crop` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crop").toString()));
      }
      if (!jsonObj.get("processing_algorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `processing_algorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("processing_algorithm").toString()));
      }
      if ((jsonObj.get("resize") != null && !jsonObj.get("resize").isJsonNull()) && !jsonObj.get("resize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resize").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Process.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Process' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Process> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Process.class));

       return (TypeAdapter<T>) new TypeAdapter<Process>() {
           @Override
           public void write(JsonWriter out, Process value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Process read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Process given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Process
   * @throws IOException if the JSON string is invalid with respect to Process
   */
  public static Process fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Process.class);
  }

  /**
   * Convert an instance of Process to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

