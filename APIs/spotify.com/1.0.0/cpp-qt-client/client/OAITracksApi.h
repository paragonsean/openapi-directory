/**
 * Spotify Web API
 * You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAITracksApi_H
#define OAI_OAITracksApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include "OAIAdd_tracks_to_playlist_request.h"
#include "OAIAudioAnalysisObject.h"
#include "OAIAudioFeaturesObject.h"
#include "OAIGet_an_artists_top_tracks_200_response.h"
#include "OAIGet_multiple_albums_401_response.h"
#include "OAIGet_several_audio_features_200_response.h"
#include "OAIGet_users_top_artists_and_tracks_200_response.h"
#include "OAIPagingPlaylistTrackObject.h"
#include "OAIPagingSavedTrackObject.h"
#include "OAIPagingSimplifiedTrackObject.h"
#include "OAIRecommendationsObject.h"
#include "OAIRemove_tracks_playlist_request.h"
#include "OAIReorder_or_replace_playlists_tracks_200_response.h"
#include "OAIReorder_or_replace_playlists_tracks_request.h"
#include "OAISave_albums_user_request.h"
#include "OAISave_tracks_user_request.h"
#include "OAITrackObject.h"
#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAITracksApi : public QObject {
    Q_OBJECT

public:
    OAITracksApi(const int timeOut = 0);
    ~OAITracksApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  playlist_id QString [required]
    * @param[in]  position qint32 [optional]
    * @param[in]  uris QString [optional]
    * @param[in]  oai_add_tracks_to_playlist_request OAIAdd_tracks_to_playlist_request [optional]
    */
    virtual void addTracksToPlaylist(const QString &playlist_id, const ::OpenAPI::OptionalParam<qint32> &position = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<QString> &uris = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<OAIAdd_tracks_to_playlist_request> &oai_add_tracks_to_playlist_request = ::OpenAPI::OptionalParam<OAIAdd_tracks_to_playlist_request>());

    /**
    * @param[in]  ids QString [required]
    */
    virtual void checkUsersSavedTracks(const QString &ids);

    /**
    * @param[in]  id QString [required]
    * @param[in]  market QString [optional]
    * @param[in]  limit qint32 [optional]
    * @param[in]  offset qint32 [optional]
    */
    virtual void getAnAlbumsTracks(const QString &id, const ::OpenAPI::OptionalParam<QString> &market = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<qint32> &limit = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &offset = ::OpenAPI::OptionalParam<qint32>());

    /**
    * @param[in]  id QString [required]
    * @param[in]  market QString [optional]
    */
    virtual void getAnArtistsTopTracks(const QString &id, const ::OpenAPI::OptionalParam<QString> &market = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  id QString [required]
    */
    virtual void getAudioAnalysis(const QString &id);

    /**
    * @param[in]  id QString [required]
    */
    virtual void getAudioFeatures(const QString &id);

    /**
    * @param[in]  playlist_id QString [required]
    * @param[in]  market QString [optional]
    * @param[in]  fields QString [optional]
    * @param[in]  limit qint32 [optional]
    * @param[in]  offset qint32 [optional]
    * @param[in]  additional_types QString [optional]
    */
    virtual void getPlaylistsTracks(const QString &playlist_id, const ::OpenAPI::OptionalParam<QString> &market = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &fields = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<qint32> &limit = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &offset = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<QString> &additional_types = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  seed_artists QString [required]
    * @param[in]  seed_genres QString [required]
    * @param[in]  seed_tracks QString [required]
    * @param[in]  limit qint32 [optional]
    * @param[in]  market QString [optional]
    * @param[in]  min_acousticness double [optional]
    * @param[in]  max_acousticness double [optional]
    * @param[in]  target_acousticness double [optional]
    * @param[in]  min_danceability double [optional]
    * @param[in]  max_danceability double [optional]
    * @param[in]  target_danceability double [optional]
    * @param[in]  min_duration_ms qint32 [optional]
    * @param[in]  max_duration_ms qint32 [optional]
    * @param[in]  target_duration_ms qint32 [optional]
    * @param[in]  min_energy double [optional]
    * @param[in]  max_energy double [optional]
    * @param[in]  target_energy double [optional]
    * @param[in]  min_instrumentalness double [optional]
    * @param[in]  max_instrumentalness double [optional]
    * @param[in]  target_instrumentalness double [optional]
    * @param[in]  min_key qint32 [optional]
    * @param[in]  max_key qint32 [optional]
    * @param[in]  target_key qint32 [optional]
    * @param[in]  min_liveness double [optional]
    * @param[in]  max_liveness double [optional]
    * @param[in]  target_liveness double [optional]
    * @param[in]  min_loudness double [optional]
    * @param[in]  max_loudness double [optional]
    * @param[in]  target_loudness double [optional]
    * @param[in]  min_mode qint32 [optional]
    * @param[in]  max_mode qint32 [optional]
    * @param[in]  target_mode qint32 [optional]
    * @param[in]  min_popularity qint32 [optional]
    * @param[in]  max_popularity qint32 [optional]
    * @param[in]  target_popularity qint32 [optional]
    * @param[in]  min_speechiness double [optional]
    * @param[in]  max_speechiness double [optional]
    * @param[in]  target_speechiness double [optional]
    * @param[in]  min_tempo double [optional]
    * @param[in]  max_tempo double [optional]
    * @param[in]  target_tempo double [optional]
    * @param[in]  min_time_signature qint32 [optional]
    * @param[in]  max_time_signature qint32 [optional]
    * @param[in]  target_time_signature qint32 [optional]
    * @param[in]  min_valence double [optional]
    * @param[in]  max_valence double [optional]
    * @param[in]  target_valence double [optional]
    */
    virtual void getRecommendations(const QString &seed_artists, const QString &seed_genres, const QString &seed_tracks, const ::OpenAPI::OptionalParam<qint32> &limit = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<QString> &market = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<double> &min_acousticness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_acousticness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_acousticness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &min_danceability = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_danceability = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_danceability = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<qint32> &min_duration_ms = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &max_duration_ms = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &target_duration_ms = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<double> &min_energy = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_energy = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_energy = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &min_instrumentalness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_instrumentalness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_instrumentalness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<qint32> &min_key = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &max_key = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &target_key = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<double> &min_liveness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_liveness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_liveness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &min_loudness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_loudness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_loudness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<qint32> &min_mode = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &max_mode = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &target_mode = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &min_popularity = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &max_popularity = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &target_popularity = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<double> &min_speechiness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_speechiness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_speechiness = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &min_tempo = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_tempo = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_tempo = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<qint32> &min_time_signature = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &max_time_signature = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &target_time_signature = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<double> &min_valence = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &max_valence = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &target_valence = ::OpenAPI::OptionalParam<double>());

    /**
    * @param[in]  ids QString [required]
    */
    virtual void getSeveralAudioFeatures(const QString &ids);

    /**
    * @param[in]  ids QString [required]
    * @param[in]  market QString [optional]
    */
    virtual void getSeveralTracks(const QString &ids, const ::OpenAPI::OptionalParam<QString> &market = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  id QString [required]
    * @param[in]  market QString [optional]
    */
    virtual void getTrack(const QString &id, const ::OpenAPI::OptionalParam<QString> &market = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  market QString [optional]
    * @param[in]  limit qint32 [optional]
    * @param[in]  offset qint32 [optional]
    */
    virtual void getUsersSavedTracks(const ::OpenAPI::OptionalParam<QString> &market = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<qint32> &limit = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &offset = ::OpenAPI::OptionalParam<qint32>());

    /**
    * @param[in]  type QString [required]
    * @param[in]  time_range QString [optional]
    * @param[in]  limit qint32 [optional]
    * @param[in]  offset qint32 [optional]
    */
    virtual void getUsersTopArtistsAndTracks(const QString &type, const ::OpenAPI::OptionalParam<QString> &time_range = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<qint32> &limit = ::OpenAPI::OptionalParam<qint32>(), const ::OpenAPI::OptionalParam<qint32> &offset = ::OpenAPI::OptionalParam<qint32>());

    /**
    * @param[in]  playlist_id QString [required]
    * @param[in]  oai_remove_tracks_playlist_request OAIRemove_tracks_playlist_request [optional]
    */
    virtual void removeTracksPlaylist(const QString &playlist_id, const ::OpenAPI::OptionalParam<OAIRemove_tracks_playlist_request> &oai_remove_tracks_playlist_request = ::OpenAPI::OptionalParam<OAIRemove_tracks_playlist_request>());

    /**
    * @param[in]  ids QString [required]
    * @param[in]  oai_save_albums_user_request OAISave_albums_user_request [optional]
    */
    virtual void removeTracksUser(const QString &ids, const ::OpenAPI::OptionalParam<OAISave_albums_user_request> &oai_save_albums_user_request = ::OpenAPI::OptionalParam<OAISave_albums_user_request>());

    /**
    * @param[in]  playlist_id QString [required]
    * @param[in]  uris QString [optional]
    * @param[in]  oai_reorder_or_replace_playlists_tracks_request OAIReorder_or_replace_playlists_tracks_request [optional]
    */
    virtual void reorderOrReplacePlaylistsTracks(const QString &playlist_id, const ::OpenAPI::OptionalParam<QString> &uris = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<OAIReorder_or_replace_playlists_tracks_request> &oai_reorder_or_replace_playlists_tracks_request = ::OpenAPI::OptionalParam<OAIReorder_or_replace_playlists_tracks_request>());

    /**
    * @param[in]  ids QString [required]
    * @param[in]  oai_save_tracks_user_request OAISave_tracks_user_request [optional]
    */
    virtual void saveTracksUser(const QString &ids, const ::OpenAPI::OptionalParam<OAISave_tracks_user_request> &oai_save_tracks_user_request = ::OpenAPI::OptionalParam<OAISave_tracks_user_request>());


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void addTracksToPlaylistCallback(OAIHttpRequestWorker *worker);
    void checkUsersSavedTracksCallback(OAIHttpRequestWorker *worker);
    void getAnAlbumsTracksCallback(OAIHttpRequestWorker *worker);
    void getAnArtistsTopTracksCallback(OAIHttpRequestWorker *worker);
    void getAudioAnalysisCallback(OAIHttpRequestWorker *worker);
    void getAudioFeaturesCallback(OAIHttpRequestWorker *worker);
    void getPlaylistsTracksCallback(OAIHttpRequestWorker *worker);
    void getRecommendationsCallback(OAIHttpRequestWorker *worker);
    void getSeveralAudioFeaturesCallback(OAIHttpRequestWorker *worker);
    void getSeveralTracksCallback(OAIHttpRequestWorker *worker);
    void getTrackCallback(OAIHttpRequestWorker *worker);
    void getUsersSavedTracksCallback(OAIHttpRequestWorker *worker);
    void getUsersTopArtistsAndTracksCallback(OAIHttpRequestWorker *worker);
    void removeTracksPlaylistCallback(OAIHttpRequestWorker *worker);
    void removeTracksUserCallback(OAIHttpRequestWorker *worker);
    void reorderOrReplacePlaylistsTracksCallback(OAIHttpRequestWorker *worker);
    void saveTracksUserCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void addTracksToPlaylistSignal(OAIReorder_or_replace_playlists_tracks_200_response summary);
    void checkUsersSavedTracksSignal(QList<bool> summary);
    void getAnAlbumsTracksSignal(OAIPagingSimplifiedTrackObject summary);
    void getAnArtistsTopTracksSignal(OAIGet_an_artists_top_tracks_200_response summary);
    void getAudioAnalysisSignal(OAIAudioAnalysisObject summary);
    void getAudioFeaturesSignal(OAIAudioFeaturesObject summary);
    void getPlaylistsTracksSignal(OAIPagingPlaylistTrackObject summary);
    void getRecommendationsSignal(OAIRecommendationsObject summary);
    void getSeveralAudioFeaturesSignal(OAIGet_several_audio_features_200_response summary);
    void getSeveralTracksSignal(OAIGet_an_artists_top_tracks_200_response summary);
    void getTrackSignal(OAITrackObject summary);
    void getUsersSavedTracksSignal(OAIPagingSavedTrackObject summary);
    void getUsersTopArtistsAndTracksSignal(OAIGet_users_top_artists_and_tracks_200_response summary);
    void removeTracksPlaylistSignal(OAIReorder_or_replace_playlists_tracks_200_response summary);
    void removeTracksUserSignal();
    void reorderOrReplacePlaylistsTracksSignal(OAIReorder_or_replace_playlists_tracks_200_response summary);
    void saveTracksUserSignal();


    void addTracksToPlaylistSignalFull(OAIHttpRequestWorker *worker, OAIReorder_or_replace_playlists_tracks_200_response summary);
    void checkUsersSavedTracksSignalFull(OAIHttpRequestWorker *worker, QList<bool> summary);
    void getAnAlbumsTracksSignalFull(OAIHttpRequestWorker *worker, OAIPagingSimplifiedTrackObject summary);
    void getAnArtistsTopTracksSignalFull(OAIHttpRequestWorker *worker, OAIGet_an_artists_top_tracks_200_response summary);
    void getAudioAnalysisSignalFull(OAIHttpRequestWorker *worker, OAIAudioAnalysisObject summary);
    void getAudioFeaturesSignalFull(OAIHttpRequestWorker *worker, OAIAudioFeaturesObject summary);
    void getPlaylistsTracksSignalFull(OAIHttpRequestWorker *worker, OAIPagingPlaylistTrackObject summary);
    void getRecommendationsSignalFull(OAIHttpRequestWorker *worker, OAIRecommendationsObject summary);
    void getSeveralAudioFeaturesSignalFull(OAIHttpRequestWorker *worker, OAIGet_several_audio_features_200_response summary);
    void getSeveralTracksSignalFull(OAIHttpRequestWorker *worker, OAIGet_an_artists_top_tracks_200_response summary);
    void getTrackSignalFull(OAIHttpRequestWorker *worker, OAITrackObject summary);
    void getUsersSavedTracksSignalFull(OAIHttpRequestWorker *worker, OAIPagingSavedTrackObject summary);
    void getUsersTopArtistsAndTracksSignalFull(OAIHttpRequestWorker *worker, OAIGet_users_top_artists_and_tracks_200_response summary);
    void removeTracksPlaylistSignalFull(OAIHttpRequestWorker *worker, OAIReorder_or_replace_playlists_tracks_200_response summary);
    void removeTracksUserSignalFull(OAIHttpRequestWorker *worker);
    void reorderOrReplacePlaylistsTracksSignalFull(OAIHttpRequestWorker *worker, OAIReorder_or_replace_playlists_tracks_200_response summary);
    void saveTracksUserSignalFull(OAIHttpRequestWorker *worker);

    Q_DECL_DEPRECATED_X("Use addTracksToPlaylistSignalError() instead")
    void addTracksToPlaylistSignalE(OAIReorder_or_replace_playlists_tracks_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void addTracksToPlaylistSignalError(OAIReorder_or_replace_playlists_tracks_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use checkUsersSavedTracksSignalError() instead")
    void checkUsersSavedTracksSignalE(QList<bool> summary, QNetworkReply::NetworkError error_type, QString error_str);
    void checkUsersSavedTracksSignalError(QList<bool> summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAnAlbumsTracksSignalError() instead")
    void getAnAlbumsTracksSignalE(OAIPagingSimplifiedTrackObject summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getAnAlbumsTracksSignalError(OAIPagingSimplifiedTrackObject summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAnArtistsTopTracksSignalError() instead")
    void getAnArtistsTopTracksSignalE(OAIGet_an_artists_top_tracks_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getAnArtistsTopTracksSignalError(OAIGet_an_artists_top_tracks_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAudioAnalysisSignalError() instead")
    void getAudioAnalysisSignalE(OAIAudioAnalysisObject summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getAudioAnalysisSignalError(OAIAudioAnalysisObject summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAudioFeaturesSignalError() instead")
    void getAudioFeaturesSignalE(OAIAudioFeaturesObject summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getAudioFeaturesSignalError(OAIAudioFeaturesObject summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getPlaylistsTracksSignalError() instead")
    void getPlaylistsTracksSignalE(OAIPagingPlaylistTrackObject summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getPlaylistsTracksSignalError(OAIPagingPlaylistTrackObject summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getRecommendationsSignalError() instead")
    void getRecommendationsSignalE(OAIRecommendationsObject summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getRecommendationsSignalError(OAIRecommendationsObject summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getSeveralAudioFeaturesSignalError() instead")
    void getSeveralAudioFeaturesSignalE(OAIGet_several_audio_features_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getSeveralAudioFeaturesSignalError(OAIGet_several_audio_features_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getSeveralTracksSignalError() instead")
    void getSeveralTracksSignalE(OAIGet_an_artists_top_tracks_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getSeveralTracksSignalError(OAIGet_an_artists_top_tracks_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getTrackSignalError() instead")
    void getTrackSignalE(OAITrackObject summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getTrackSignalError(OAITrackObject summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getUsersSavedTracksSignalError() instead")
    void getUsersSavedTracksSignalE(OAIPagingSavedTrackObject summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getUsersSavedTracksSignalError(OAIPagingSavedTrackObject summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getUsersTopArtistsAndTracksSignalError() instead")
    void getUsersTopArtistsAndTracksSignalE(OAIGet_users_top_artists_and_tracks_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getUsersTopArtistsAndTracksSignalError(OAIGet_users_top_artists_and_tracks_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use removeTracksPlaylistSignalError() instead")
    void removeTracksPlaylistSignalE(OAIReorder_or_replace_playlists_tracks_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void removeTracksPlaylistSignalError(OAIReorder_or_replace_playlists_tracks_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use removeTracksUserSignalError() instead")
    void removeTracksUserSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void removeTracksUserSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use reorderOrReplacePlaylistsTracksSignalError() instead")
    void reorderOrReplacePlaylistsTracksSignalE(OAIReorder_or_replace_playlists_tracks_200_response summary, QNetworkReply::NetworkError error_type, QString error_str);
    void reorderOrReplacePlaylistsTracksSignalError(OAIReorder_or_replace_playlists_tracks_200_response summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use saveTracksUserSignalError() instead")
    void saveTracksUserSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void saveTracksUserSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use addTracksToPlaylistSignalErrorFull() instead")
    void addTracksToPlaylistSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void addTracksToPlaylistSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use checkUsersSavedTracksSignalErrorFull() instead")
    void checkUsersSavedTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void checkUsersSavedTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAnAlbumsTracksSignalErrorFull() instead")
    void getAnAlbumsTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getAnAlbumsTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAnArtistsTopTracksSignalErrorFull() instead")
    void getAnArtistsTopTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getAnArtistsTopTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAudioAnalysisSignalErrorFull() instead")
    void getAudioAnalysisSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getAudioAnalysisSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getAudioFeaturesSignalErrorFull() instead")
    void getAudioFeaturesSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getAudioFeaturesSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getPlaylistsTracksSignalErrorFull() instead")
    void getPlaylistsTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getPlaylistsTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getRecommendationsSignalErrorFull() instead")
    void getRecommendationsSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getRecommendationsSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getSeveralAudioFeaturesSignalErrorFull() instead")
    void getSeveralAudioFeaturesSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getSeveralAudioFeaturesSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getSeveralTracksSignalErrorFull() instead")
    void getSeveralTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getSeveralTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getTrackSignalErrorFull() instead")
    void getTrackSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getTrackSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getUsersSavedTracksSignalErrorFull() instead")
    void getUsersSavedTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getUsersSavedTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getUsersTopArtistsAndTracksSignalErrorFull() instead")
    void getUsersTopArtistsAndTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getUsersTopArtistsAndTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use removeTracksPlaylistSignalErrorFull() instead")
    void removeTracksPlaylistSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void removeTracksPlaylistSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use removeTracksUserSignalErrorFull() instead")
    void removeTracksUserSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void removeTracksUserSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use reorderOrReplacePlaylistsTracksSignalErrorFull() instead")
    void reorderOrReplacePlaylistsTracksSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void reorderOrReplacePlaylistsTracksSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use saveTracksUserSignalErrorFull() instead")
    void saveTracksUserSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void saveTracksUserSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
