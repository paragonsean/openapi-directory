/**
 * Spotify Web API with fixes and improvements from sonallux
 * You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 
 *
 * The version of the OpenAPI document: 2023.2.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAudioAnalysisObject_meta.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAudioAnalysisObject_meta::OAIAudioAnalysisObject_meta(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAudioAnalysisObject_meta::OAIAudioAnalysisObject_meta() {
    this->initializeModel();
}

OAIAudioAnalysisObject_meta::~OAIAudioAnalysisObject_meta() {}

void OAIAudioAnalysisObject_meta::initializeModel() {

    m_analysis_time_isSet = false;
    m_analysis_time_isValid = false;

    m_analyzer_version_isSet = false;
    m_analyzer_version_isValid = false;

    m_detailed_status_isSet = false;
    m_detailed_status_isValid = false;

    m_input_process_isSet = false;
    m_input_process_isValid = false;

    m_platform_isSet = false;
    m_platform_isValid = false;

    m_status_code_isSet = false;
    m_status_code_isValid = false;

    m_timestamp_isSet = false;
    m_timestamp_isValid = false;
}

void OAIAudioAnalysisObject_meta::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAudioAnalysisObject_meta::fromJsonObject(QJsonObject json) {

    m_analysis_time_isValid = ::OpenAPI::fromJsonValue(m_analysis_time, json[QString("analysis_time")]);
    m_analysis_time_isSet = !json[QString("analysis_time")].isNull() && m_analysis_time_isValid;

    m_analyzer_version_isValid = ::OpenAPI::fromJsonValue(m_analyzer_version, json[QString("analyzer_version")]);
    m_analyzer_version_isSet = !json[QString("analyzer_version")].isNull() && m_analyzer_version_isValid;

    m_detailed_status_isValid = ::OpenAPI::fromJsonValue(m_detailed_status, json[QString("detailed_status")]);
    m_detailed_status_isSet = !json[QString("detailed_status")].isNull() && m_detailed_status_isValid;

    m_input_process_isValid = ::OpenAPI::fromJsonValue(m_input_process, json[QString("input_process")]);
    m_input_process_isSet = !json[QString("input_process")].isNull() && m_input_process_isValid;

    m_platform_isValid = ::OpenAPI::fromJsonValue(m_platform, json[QString("platform")]);
    m_platform_isSet = !json[QString("platform")].isNull() && m_platform_isValid;

    m_status_code_isValid = ::OpenAPI::fromJsonValue(m_status_code, json[QString("status_code")]);
    m_status_code_isSet = !json[QString("status_code")].isNull() && m_status_code_isValid;

    m_timestamp_isValid = ::OpenAPI::fromJsonValue(m_timestamp, json[QString("timestamp")]);
    m_timestamp_isSet = !json[QString("timestamp")].isNull() && m_timestamp_isValid;
}

QString OAIAudioAnalysisObject_meta::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAudioAnalysisObject_meta::asJsonObject() const {
    QJsonObject obj;
    if (m_analysis_time_isSet) {
        obj.insert(QString("analysis_time"), ::OpenAPI::toJsonValue(m_analysis_time));
    }
    if (m_analyzer_version_isSet) {
        obj.insert(QString("analyzer_version"), ::OpenAPI::toJsonValue(m_analyzer_version));
    }
    if (m_detailed_status_isSet) {
        obj.insert(QString("detailed_status"), ::OpenAPI::toJsonValue(m_detailed_status));
    }
    if (m_input_process_isSet) {
        obj.insert(QString("input_process"), ::OpenAPI::toJsonValue(m_input_process));
    }
    if (m_platform_isSet) {
        obj.insert(QString("platform"), ::OpenAPI::toJsonValue(m_platform));
    }
    if (m_status_code_isSet) {
        obj.insert(QString("status_code"), ::OpenAPI::toJsonValue(m_status_code));
    }
    if (m_timestamp_isSet) {
        obj.insert(QString("timestamp"), ::OpenAPI::toJsonValue(m_timestamp));
    }
    return obj;
}

double OAIAudioAnalysisObject_meta::getAnalysisTime() const {
    return m_analysis_time;
}
void OAIAudioAnalysisObject_meta::setAnalysisTime(const double &analysis_time) {
    m_analysis_time = analysis_time;
    m_analysis_time_isSet = true;
}

bool OAIAudioAnalysisObject_meta::is_analysis_time_Set() const{
    return m_analysis_time_isSet;
}

bool OAIAudioAnalysisObject_meta::is_analysis_time_Valid() const{
    return m_analysis_time_isValid;
}

QString OAIAudioAnalysisObject_meta::getAnalyzerVersion() const {
    return m_analyzer_version;
}
void OAIAudioAnalysisObject_meta::setAnalyzerVersion(const QString &analyzer_version) {
    m_analyzer_version = analyzer_version;
    m_analyzer_version_isSet = true;
}

bool OAIAudioAnalysisObject_meta::is_analyzer_version_Set() const{
    return m_analyzer_version_isSet;
}

bool OAIAudioAnalysisObject_meta::is_analyzer_version_Valid() const{
    return m_analyzer_version_isValid;
}

QString OAIAudioAnalysisObject_meta::getDetailedStatus() const {
    return m_detailed_status;
}
void OAIAudioAnalysisObject_meta::setDetailedStatus(const QString &detailed_status) {
    m_detailed_status = detailed_status;
    m_detailed_status_isSet = true;
}

bool OAIAudioAnalysisObject_meta::is_detailed_status_Set() const{
    return m_detailed_status_isSet;
}

bool OAIAudioAnalysisObject_meta::is_detailed_status_Valid() const{
    return m_detailed_status_isValid;
}

QString OAIAudioAnalysisObject_meta::getInputProcess() const {
    return m_input_process;
}
void OAIAudioAnalysisObject_meta::setInputProcess(const QString &input_process) {
    m_input_process = input_process;
    m_input_process_isSet = true;
}

bool OAIAudioAnalysisObject_meta::is_input_process_Set() const{
    return m_input_process_isSet;
}

bool OAIAudioAnalysisObject_meta::is_input_process_Valid() const{
    return m_input_process_isValid;
}

QString OAIAudioAnalysisObject_meta::getPlatform() const {
    return m_platform;
}
void OAIAudioAnalysisObject_meta::setPlatform(const QString &platform) {
    m_platform = platform;
    m_platform_isSet = true;
}

bool OAIAudioAnalysisObject_meta::is_platform_Set() const{
    return m_platform_isSet;
}

bool OAIAudioAnalysisObject_meta::is_platform_Valid() const{
    return m_platform_isValid;
}

qint32 OAIAudioAnalysisObject_meta::getStatusCode() const {
    return m_status_code;
}
void OAIAudioAnalysisObject_meta::setStatusCode(const qint32 &status_code) {
    m_status_code = status_code;
    m_status_code_isSet = true;
}

bool OAIAudioAnalysisObject_meta::is_status_code_Set() const{
    return m_status_code_isSet;
}

bool OAIAudioAnalysisObject_meta::is_status_code_Valid() const{
    return m_status_code_isValid;
}

qint32 OAIAudioAnalysisObject_meta::getTimestamp() const {
    return m_timestamp;
}
void OAIAudioAnalysisObject_meta::setTimestamp(const qint32 &timestamp) {
    m_timestamp = timestamp;
    m_timestamp_isSet = true;
}

bool OAIAudioAnalysisObject_meta::is_timestamp_Set() const{
    return m_timestamp_isSet;
}

bool OAIAudioAnalysisObject_meta::is_timestamp_Valid() const{
    return m_timestamp_isValid;
}

bool OAIAudioAnalysisObject_meta::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_analysis_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_analyzer_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_detailed_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_input_process_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_platform_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_code_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAudioAnalysisObject_meta::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
