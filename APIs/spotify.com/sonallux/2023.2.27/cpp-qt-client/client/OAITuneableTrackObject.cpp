/**
 * Spotify Web API with fixes and improvements from sonallux
 * You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 
 *
 * The version of the OpenAPI document: 2023.2.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITuneableTrackObject.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITuneableTrackObject::OAITuneableTrackObject(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITuneableTrackObject::OAITuneableTrackObject() {
    this->initializeModel();
}

OAITuneableTrackObject::~OAITuneableTrackObject() {}

void OAITuneableTrackObject::initializeModel() {

    m_acousticness_isSet = false;
    m_acousticness_isValid = false;

    m_danceability_isSet = false;
    m_danceability_isValid = false;

    m_duration_ms_isSet = false;
    m_duration_ms_isValid = false;

    m_energy_isSet = false;
    m_energy_isValid = false;

    m_instrumentalness_isSet = false;
    m_instrumentalness_isValid = false;

    m_key_isSet = false;
    m_key_isValid = false;

    m_liveness_isSet = false;
    m_liveness_isValid = false;

    m_loudness_isSet = false;
    m_loudness_isValid = false;

    m_mode_isSet = false;
    m_mode_isValid = false;

    m_popularity_isSet = false;
    m_popularity_isValid = false;

    m_speechiness_isSet = false;
    m_speechiness_isValid = false;

    m_tempo_isSet = false;
    m_tempo_isValid = false;

    m_time_signature_isSet = false;
    m_time_signature_isValid = false;

    m_valence_isSet = false;
    m_valence_isValid = false;
}

void OAITuneableTrackObject::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITuneableTrackObject::fromJsonObject(QJsonObject json) {

    m_acousticness_isValid = ::OpenAPI::fromJsonValue(m_acousticness, json[QString("acousticness")]);
    m_acousticness_isSet = !json[QString("acousticness")].isNull() && m_acousticness_isValid;

    m_danceability_isValid = ::OpenAPI::fromJsonValue(m_danceability, json[QString("danceability")]);
    m_danceability_isSet = !json[QString("danceability")].isNull() && m_danceability_isValid;

    m_duration_ms_isValid = ::OpenAPI::fromJsonValue(m_duration_ms, json[QString("duration_ms")]);
    m_duration_ms_isSet = !json[QString("duration_ms")].isNull() && m_duration_ms_isValid;

    m_energy_isValid = ::OpenAPI::fromJsonValue(m_energy, json[QString("energy")]);
    m_energy_isSet = !json[QString("energy")].isNull() && m_energy_isValid;

    m_instrumentalness_isValid = ::OpenAPI::fromJsonValue(m_instrumentalness, json[QString("instrumentalness")]);
    m_instrumentalness_isSet = !json[QString("instrumentalness")].isNull() && m_instrumentalness_isValid;

    m_key_isValid = ::OpenAPI::fromJsonValue(m_key, json[QString("key")]);
    m_key_isSet = !json[QString("key")].isNull() && m_key_isValid;

    m_liveness_isValid = ::OpenAPI::fromJsonValue(m_liveness, json[QString("liveness")]);
    m_liveness_isSet = !json[QString("liveness")].isNull() && m_liveness_isValid;

    m_loudness_isValid = ::OpenAPI::fromJsonValue(m_loudness, json[QString("loudness")]);
    m_loudness_isSet = !json[QString("loudness")].isNull() && m_loudness_isValid;

    m_mode_isValid = ::OpenAPI::fromJsonValue(m_mode, json[QString("mode")]);
    m_mode_isSet = !json[QString("mode")].isNull() && m_mode_isValid;

    m_popularity_isValid = ::OpenAPI::fromJsonValue(m_popularity, json[QString("popularity")]);
    m_popularity_isSet = !json[QString("popularity")].isNull() && m_popularity_isValid;

    m_speechiness_isValid = ::OpenAPI::fromJsonValue(m_speechiness, json[QString("speechiness")]);
    m_speechiness_isSet = !json[QString("speechiness")].isNull() && m_speechiness_isValid;

    m_tempo_isValid = ::OpenAPI::fromJsonValue(m_tempo, json[QString("tempo")]);
    m_tempo_isSet = !json[QString("tempo")].isNull() && m_tempo_isValid;

    m_time_signature_isValid = ::OpenAPI::fromJsonValue(m_time_signature, json[QString("time_signature")]);
    m_time_signature_isSet = !json[QString("time_signature")].isNull() && m_time_signature_isValid;

    m_valence_isValid = ::OpenAPI::fromJsonValue(m_valence, json[QString("valence")]);
    m_valence_isSet = !json[QString("valence")].isNull() && m_valence_isValid;
}

QString OAITuneableTrackObject::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITuneableTrackObject::asJsonObject() const {
    QJsonObject obj;
    if (m_acousticness_isSet) {
        obj.insert(QString("acousticness"), ::OpenAPI::toJsonValue(m_acousticness));
    }
    if (m_danceability_isSet) {
        obj.insert(QString("danceability"), ::OpenAPI::toJsonValue(m_danceability));
    }
    if (m_duration_ms_isSet) {
        obj.insert(QString("duration_ms"), ::OpenAPI::toJsonValue(m_duration_ms));
    }
    if (m_energy_isSet) {
        obj.insert(QString("energy"), ::OpenAPI::toJsonValue(m_energy));
    }
    if (m_instrumentalness_isSet) {
        obj.insert(QString("instrumentalness"), ::OpenAPI::toJsonValue(m_instrumentalness));
    }
    if (m_key_isSet) {
        obj.insert(QString("key"), ::OpenAPI::toJsonValue(m_key));
    }
    if (m_liveness_isSet) {
        obj.insert(QString("liveness"), ::OpenAPI::toJsonValue(m_liveness));
    }
    if (m_loudness_isSet) {
        obj.insert(QString("loudness"), ::OpenAPI::toJsonValue(m_loudness));
    }
    if (m_mode_isSet) {
        obj.insert(QString("mode"), ::OpenAPI::toJsonValue(m_mode));
    }
    if (m_popularity_isSet) {
        obj.insert(QString("popularity"), ::OpenAPI::toJsonValue(m_popularity));
    }
    if (m_speechiness_isSet) {
        obj.insert(QString("speechiness"), ::OpenAPI::toJsonValue(m_speechiness));
    }
    if (m_tempo_isSet) {
        obj.insert(QString("tempo"), ::OpenAPI::toJsonValue(m_tempo));
    }
    if (m_time_signature_isSet) {
        obj.insert(QString("time_signature"), ::OpenAPI::toJsonValue(m_time_signature));
    }
    if (m_valence_isSet) {
        obj.insert(QString("valence"), ::OpenAPI::toJsonValue(m_valence));
    }
    return obj;
}

float OAITuneableTrackObject::getAcousticness() const {
    return m_acousticness;
}
void OAITuneableTrackObject::setAcousticness(const float &acousticness) {
    m_acousticness = acousticness;
    m_acousticness_isSet = true;
}

bool OAITuneableTrackObject::is_acousticness_Set() const{
    return m_acousticness_isSet;
}

bool OAITuneableTrackObject::is_acousticness_Valid() const{
    return m_acousticness_isValid;
}

float OAITuneableTrackObject::getDanceability() const {
    return m_danceability;
}
void OAITuneableTrackObject::setDanceability(const float &danceability) {
    m_danceability = danceability;
    m_danceability_isSet = true;
}

bool OAITuneableTrackObject::is_danceability_Set() const{
    return m_danceability_isSet;
}

bool OAITuneableTrackObject::is_danceability_Valid() const{
    return m_danceability_isValid;
}

qint32 OAITuneableTrackObject::getDurationMs() const {
    return m_duration_ms;
}
void OAITuneableTrackObject::setDurationMs(const qint32 &duration_ms) {
    m_duration_ms = duration_ms;
    m_duration_ms_isSet = true;
}

bool OAITuneableTrackObject::is_duration_ms_Set() const{
    return m_duration_ms_isSet;
}

bool OAITuneableTrackObject::is_duration_ms_Valid() const{
    return m_duration_ms_isValid;
}

float OAITuneableTrackObject::getEnergy() const {
    return m_energy;
}
void OAITuneableTrackObject::setEnergy(const float &energy) {
    m_energy = energy;
    m_energy_isSet = true;
}

bool OAITuneableTrackObject::is_energy_Set() const{
    return m_energy_isSet;
}

bool OAITuneableTrackObject::is_energy_Valid() const{
    return m_energy_isValid;
}

float OAITuneableTrackObject::getInstrumentalness() const {
    return m_instrumentalness;
}
void OAITuneableTrackObject::setInstrumentalness(const float &instrumentalness) {
    m_instrumentalness = instrumentalness;
    m_instrumentalness_isSet = true;
}

bool OAITuneableTrackObject::is_instrumentalness_Set() const{
    return m_instrumentalness_isSet;
}

bool OAITuneableTrackObject::is_instrumentalness_Valid() const{
    return m_instrumentalness_isValid;
}

qint32 OAITuneableTrackObject::getKey() const {
    return m_key;
}
void OAITuneableTrackObject::setKey(const qint32 &key) {
    m_key = key;
    m_key_isSet = true;
}

bool OAITuneableTrackObject::is_key_Set() const{
    return m_key_isSet;
}

bool OAITuneableTrackObject::is_key_Valid() const{
    return m_key_isValid;
}

float OAITuneableTrackObject::getLiveness() const {
    return m_liveness;
}
void OAITuneableTrackObject::setLiveness(const float &liveness) {
    m_liveness = liveness;
    m_liveness_isSet = true;
}

bool OAITuneableTrackObject::is_liveness_Set() const{
    return m_liveness_isSet;
}

bool OAITuneableTrackObject::is_liveness_Valid() const{
    return m_liveness_isValid;
}

float OAITuneableTrackObject::getLoudness() const {
    return m_loudness;
}
void OAITuneableTrackObject::setLoudness(const float &loudness) {
    m_loudness = loudness;
    m_loudness_isSet = true;
}

bool OAITuneableTrackObject::is_loudness_Set() const{
    return m_loudness_isSet;
}

bool OAITuneableTrackObject::is_loudness_Valid() const{
    return m_loudness_isValid;
}

qint32 OAITuneableTrackObject::getMode() const {
    return m_mode;
}
void OAITuneableTrackObject::setMode(const qint32 &mode) {
    m_mode = mode;
    m_mode_isSet = true;
}

bool OAITuneableTrackObject::is_mode_Set() const{
    return m_mode_isSet;
}

bool OAITuneableTrackObject::is_mode_Valid() const{
    return m_mode_isValid;
}

float OAITuneableTrackObject::getPopularity() const {
    return m_popularity;
}
void OAITuneableTrackObject::setPopularity(const float &popularity) {
    m_popularity = popularity;
    m_popularity_isSet = true;
}

bool OAITuneableTrackObject::is_popularity_Set() const{
    return m_popularity_isSet;
}

bool OAITuneableTrackObject::is_popularity_Valid() const{
    return m_popularity_isValid;
}

float OAITuneableTrackObject::getSpeechiness() const {
    return m_speechiness;
}
void OAITuneableTrackObject::setSpeechiness(const float &speechiness) {
    m_speechiness = speechiness;
    m_speechiness_isSet = true;
}

bool OAITuneableTrackObject::is_speechiness_Set() const{
    return m_speechiness_isSet;
}

bool OAITuneableTrackObject::is_speechiness_Valid() const{
    return m_speechiness_isValid;
}

float OAITuneableTrackObject::getTempo() const {
    return m_tempo;
}
void OAITuneableTrackObject::setTempo(const float &tempo) {
    m_tempo = tempo;
    m_tempo_isSet = true;
}

bool OAITuneableTrackObject::is_tempo_Set() const{
    return m_tempo_isSet;
}

bool OAITuneableTrackObject::is_tempo_Valid() const{
    return m_tempo_isValid;
}

qint32 OAITuneableTrackObject::getTimeSignature() const {
    return m_time_signature;
}
void OAITuneableTrackObject::setTimeSignature(const qint32 &time_signature) {
    m_time_signature = time_signature;
    m_time_signature_isSet = true;
}

bool OAITuneableTrackObject::is_time_signature_Set() const{
    return m_time_signature_isSet;
}

bool OAITuneableTrackObject::is_time_signature_Valid() const{
    return m_time_signature_isValid;
}

float OAITuneableTrackObject::getValence() const {
    return m_valence;
}
void OAITuneableTrackObject::setValence(const float &valence) {
    m_valence = valence;
    m_valence_isSet = true;
}

bool OAITuneableTrackObject::is_valence_Set() const{
    return m_valence_isSet;
}

bool OAITuneableTrackObject::is_valence_Valid() const{
    return m_valence_isValid;
}

bool OAITuneableTrackObject::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_acousticness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_danceability_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_duration_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_energy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instrumentalness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_liveness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_loudness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_popularity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_speechiness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tempo_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_signature_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_valence_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITuneableTrackObject::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
