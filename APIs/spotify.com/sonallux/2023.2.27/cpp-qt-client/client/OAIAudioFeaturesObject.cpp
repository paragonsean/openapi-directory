/**
 * Spotify Web API with fixes and improvements from sonallux
 * You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 
 *
 * The version of the OpenAPI document: 2023.2.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAudioFeaturesObject.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAudioFeaturesObject::OAIAudioFeaturesObject(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAudioFeaturesObject::OAIAudioFeaturesObject() {
    this->initializeModel();
}

OAIAudioFeaturesObject::~OAIAudioFeaturesObject() {}

void OAIAudioFeaturesObject::initializeModel() {

    m_acousticness_isSet = false;
    m_acousticness_isValid = false;

    m_analysis_url_isSet = false;
    m_analysis_url_isValid = false;

    m_danceability_isSet = false;
    m_danceability_isValid = false;

    m_duration_ms_isSet = false;
    m_duration_ms_isValid = false;

    m_energy_isSet = false;
    m_energy_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_instrumentalness_isSet = false;
    m_instrumentalness_isValid = false;

    m_key_isSet = false;
    m_key_isValid = false;

    m_liveness_isSet = false;
    m_liveness_isValid = false;

    m_loudness_isSet = false;
    m_loudness_isValid = false;

    m_mode_isSet = false;
    m_mode_isValid = false;

    m_speechiness_isSet = false;
    m_speechiness_isValid = false;

    m_tempo_isSet = false;
    m_tempo_isValid = false;

    m_time_signature_isSet = false;
    m_time_signature_isValid = false;

    m_track_href_isSet = false;
    m_track_href_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_uri_isSet = false;
    m_uri_isValid = false;

    m_valence_isSet = false;
    m_valence_isValid = false;
}

void OAIAudioFeaturesObject::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAudioFeaturesObject::fromJsonObject(QJsonObject json) {

    m_acousticness_isValid = ::OpenAPI::fromJsonValue(m_acousticness, json[QString("acousticness")]);
    m_acousticness_isSet = !json[QString("acousticness")].isNull() && m_acousticness_isValid;

    m_analysis_url_isValid = ::OpenAPI::fromJsonValue(m_analysis_url, json[QString("analysis_url")]);
    m_analysis_url_isSet = !json[QString("analysis_url")].isNull() && m_analysis_url_isValid;

    m_danceability_isValid = ::OpenAPI::fromJsonValue(m_danceability, json[QString("danceability")]);
    m_danceability_isSet = !json[QString("danceability")].isNull() && m_danceability_isValid;

    m_duration_ms_isValid = ::OpenAPI::fromJsonValue(m_duration_ms, json[QString("duration_ms")]);
    m_duration_ms_isSet = !json[QString("duration_ms")].isNull() && m_duration_ms_isValid;

    m_energy_isValid = ::OpenAPI::fromJsonValue(m_energy, json[QString("energy")]);
    m_energy_isSet = !json[QString("energy")].isNull() && m_energy_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_instrumentalness_isValid = ::OpenAPI::fromJsonValue(m_instrumentalness, json[QString("instrumentalness")]);
    m_instrumentalness_isSet = !json[QString("instrumentalness")].isNull() && m_instrumentalness_isValid;

    m_key_isValid = ::OpenAPI::fromJsonValue(m_key, json[QString("key")]);
    m_key_isSet = !json[QString("key")].isNull() && m_key_isValid;

    m_liveness_isValid = ::OpenAPI::fromJsonValue(m_liveness, json[QString("liveness")]);
    m_liveness_isSet = !json[QString("liveness")].isNull() && m_liveness_isValid;

    m_loudness_isValid = ::OpenAPI::fromJsonValue(m_loudness, json[QString("loudness")]);
    m_loudness_isSet = !json[QString("loudness")].isNull() && m_loudness_isValid;

    m_mode_isValid = ::OpenAPI::fromJsonValue(m_mode, json[QString("mode")]);
    m_mode_isSet = !json[QString("mode")].isNull() && m_mode_isValid;

    m_speechiness_isValid = ::OpenAPI::fromJsonValue(m_speechiness, json[QString("speechiness")]);
    m_speechiness_isSet = !json[QString("speechiness")].isNull() && m_speechiness_isValid;

    m_tempo_isValid = ::OpenAPI::fromJsonValue(m_tempo, json[QString("tempo")]);
    m_tempo_isSet = !json[QString("tempo")].isNull() && m_tempo_isValid;

    m_time_signature_isValid = ::OpenAPI::fromJsonValue(m_time_signature, json[QString("time_signature")]);
    m_time_signature_isSet = !json[QString("time_signature")].isNull() && m_time_signature_isValid;

    m_track_href_isValid = ::OpenAPI::fromJsonValue(m_track_href, json[QString("track_href")]);
    m_track_href_isSet = !json[QString("track_href")].isNull() && m_track_href_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_uri_isValid = ::OpenAPI::fromJsonValue(m_uri, json[QString("uri")]);
    m_uri_isSet = !json[QString("uri")].isNull() && m_uri_isValid;

    m_valence_isValid = ::OpenAPI::fromJsonValue(m_valence, json[QString("valence")]);
    m_valence_isSet = !json[QString("valence")].isNull() && m_valence_isValid;
}

QString OAIAudioFeaturesObject::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAudioFeaturesObject::asJsonObject() const {
    QJsonObject obj;
    if (m_acousticness_isSet) {
        obj.insert(QString("acousticness"), ::OpenAPI::toJsonValue(m_acousticness));
    }
    if (m_analysis_url_isSet) {
        obj.insert(QString("analysis_url"), ::OpenAPI::toJsonValue(m_analysis_url));
    }
    if (m_danceability_isSet) {
        obj.insert(QString("danceability"), ::OpenAPI::toJsonValue(m_danceability));
    }
    if (m_duration_ms_isSet) {
        obj.insert(QString("duration_ms"), ::OpenAPI::toJsonValue(m_duration_ms));
    }
    if (m_energy_isSet) {
        obj.insert(QString("energy"), ::OpenAPI::toJsonValue(m_energy));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_instrumentalness_isSet) {
        obj.insert(QString("instrumentalness"), ::OpenAPI::toJsonValue(m_instrumentalness));
    }
    if (m_key_isSet) {
        obj.insert(QString("key"), ::OpenAPI::toJsonValue(m_key));
    }
    if (m_liveness_isSet) {
        obj.insert(QString("liveness"), ::OpenAPI::toJsonValue(m_liveness));
    }
    if (m_loudness_isSet) {
        obj.insert(QString("loudness"), ::OpenAPI::toJsonValue(m_loudness));
    }
    if (m_mode_isSet) {
        obj.insert(QString("mode"), ::OpenAPI::toJsonValue(m_mode));
    }
    if (m_speechiness_isSet) {
        obj.insert(QString("speechiness"), ::OpenAPI::toJsonValue(m_speechiness));
    }
    if (m_tempo_isSet) {
        obj.insert(QString("tempo"), ::OpenAPI::toJsonValue(m_tempo));
    }
    if (m_time_signature_isSet) {
        obj.insert(QString("time_signature"), ::OpenAPI::toJsonValue(m_time_signature));
    }
    if (m_track_href_isSet) {
        obj.insert(QString("track_href"), ::OpenAPI::toJsonValue(m_track_href));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_uri_isSet) {
        obj.insert(QString("uri"), ::OpenAPI::toJsonValue(m_uri));
    }
    if (m_valence_isSet) {
        obj.insert(QString("valence"), ::OpenAPI::toJsonValue(m_valence));
    }
    return obj;
}

float OAIAudioFeaturesObject::getAcousticness() const {
    return m_acousticness;
}
void OAIAudioFeaturesObject::setAcousticness(const float &acousticness) {
    m_acousticness = acousticness;
    m_acousticness_isSet = true;
}

bool OAIAudioFeaturesObject::is_acousticness_Set() const{
    return m_acousticness_isSet;
}

bool OAIAudioFeaturesObject::is_acousticness_Valid() const{
    return m_acousticness_isValid;
}

QString OAIAudioFeaturesObject::getAnalysisUrl() const {
    return m_analysis_url;
}
void OAIAudioFeaturesObject::setAnalysisUrl(const QString &analysis_url) {
    m_analysis_url = analysis_url;
    m_analysis_url_isSet = true;
}

bool OAIAudioFeaturesObject::is_analysis_url_Set() const{
    return m_analysis_url_isSet;
}

bool OAIAudioFeaturesObject::is_analysis_url_Valid() const{
    return m_analysis_url_isValid;
}

float OAIAudioFeaturesObject::getDanceability() const {
    return m_danceability;
}
void OAIAudioFeaturesObject::setDanceability(const float &danceability) {
    m_danceability = danceability;
    m_danceability_isSet = true;
}

bool OAIAudioFeaturesObject::is_danceability_Set() const{
    return m_danceability_isSet;
}

bool OAIAudioFeaturesObject::is_danceability_Valid() const{
    return m_danceability_isValid;
}

qint32 OAIAudioFeaturesObject::getDurationMs() const {
    return m_duration_ms;
}
void OAIAudioFeaturesObject::setDurationMs(const qint32 &duration_ms) {
    m_duration_ms = duration_ms;
    m_duration_ms_isSet = true;
}

bool OAIAudioFeaturesObject::is_duration_ms_Set() const{
    return m_duration_ms_isSet;
}

bool OAIAudioFeaturesObject::is_duration_ms_Valid() const{
    return m_duration_ms_isValid;
}

float OAIAudioFeaturesObject::getEnergy() const {
    return m_energy;
}
void OAIAudioFeaturesObject::setEnergy(const float &energy) {
    m_energy = energy;
    m_energy_isSet = true;
}

bool OAIAudioFeaturesObject::is_energy_Set() const{
    return m_energy_isSet;
}

bool OAIAudioFeaturesObject::is_energy_Valid() const{
    return m_energy_isValid;
}

QString OAIAudioFeaturesObject::getId() const {
    return m_id;
}
void OAIAudioFeaturesObject::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIAudioFeaturesObject::is_id_Set() const{
    return m_id_isSet;
}

bool OAIAudioFeaturesObject::is_id_Valid() const{
    return m_id_isValid;
}

float OAIAudioFeaturesObject::getInstrumentalness() const {
    return m_instrumentalness;
}
void OAIAudioFeaturesObject::setInstrumentalness(const float &instrumentalness) {
    m_instrumentalness = instrumentalness;
    m_instrumentalness_isSet = true;
}

bool OAIAudioFeaturesObject::is_instrumentalness_Set() const{
    return m_instrumentalness_isSet;
}

bool OAIAudioFeaturesObject::is_instrumentalness_Valid() const{
    return m_instrumentalness_isValid;
}

qint32 OAIAudioFeaturesObject::getKey() const {
    return m_key;
}
void OAIAudioFeaturesObject::setKey(const qint32 &key) {
    m_key = key;
    m_key_isSet = true;
}

bool OAIAudioFeaturesObject::is_key_Set() const{
    return m_key_isSet;
}

bool OAIAudioFeaturesObject::is_key_Valid() const{
    return m_key_isValid;
}

float OAIAudioFeaturesObject::getLiveness() const {
    return m_liveness;
}
void OAIAudioFeaturesObject::setLiveness(const float &liveness) {
    m_liveness = liveness;
    m_liveness_isSet = true;
}

bool OAIAudioFeaturesObject::is_liveness_Set() const{
    return m_liveness_isSet;
}

bool OAIAudioFeaturesObject::is_liveness_Valid() const{
    return m_liveness_isValid;
}

float OAIAudioFeaturesObject::getLoudness() const {
    return m_loudness;
}
void OAIAudioFeaturesObject::setLoudness(const float &loudness) {
    m_loudness = loudness;
    m_loudness_isSet = true;
}

bool OAIAudioFeaturesObject::is_loudness_Set() const{
    return m_loudness_isSet;
}

bool OAIAudioFeaturesObject::is_loudness_Valid() const{
    return m_loudness_isValid;
}

qint32 OAIAudioFeaturesObject::getMode() const {
    return m_mode;
}
void OAIAudioFeaturesObject::setMode(const qint32 &mode) {
    m_mode = mode;
    m_mode_isSet = true;
}

bool OAIAudioFeaturesObject::is_mode_Set() const{
    return m_mode_isSet;
}

bool OAIAudioFeaturesObject::is_mode_Valid() const{
    return m_mode_isValid;
}

float OAIAudioFeaturesObject::getSpeechiness() const {
    return m_speechiness;
}
void OAIAudioFeaturesObject::setSpeechiness(const float &speechiness) {
    m_speechiness = speechiness;
    m_speechiness_isSet = true;
}

bool OAIAudioFeaturesObject::is_speechiness_Set() const{
    return m_speechiness_isSet;
}

bool OAIAudioFeaturesObject::is_speechiness_Valid() const{
    return m_speechiness_isValid;
}

float OAIAudioFeaturesObject::getTempo() const {
    return m_tempo;
}
void OAIAudioFeaturesObject::setTempo(const float &tempo) {
    m_tempo = tempo;
    m_tempo_isSet = true;
}

bool OAIAudioFeaturesObject::is_tempo_Set() const{
    return m_tempo_isSet;
}

bool OAIAudioFeaturesObject::is_tempo_Valid() const{
    return m_tempo_isValid;
}

qint32 OAIAudioFeaturesObject::getTimeSignature() const {
    return m_time_signature;
}
void OAIAudioFeaturesObject::setTimeSignature(const qint32 &time_signature) {
    m_time_signature = time_signature;
    m_time_signature_isSet = true;
}

bool OAIAudioFeaturesObject::is_time_signature_Set() const{
    return m_time_signature_isSet;
}

bool OAIAudioFeaturesObject::is_time_signature_Valid() const{
    return m_time_signature_isValid;
}

QString OAIAudioFeaturesObject::getTrackHref() const {
    return m_track_href;
}
void OAIAudioFeaturesObject::setTrackHref(const QString &track_href) {
    m_track_href = track_href;
    m_track_href_isSet = true;
}

bool OAIAudioFeaturesObject::is_track_href_Set() const{
    return m_track_href_isSet;
}

bool OAIAudioFeaturesObject::is_track_href_Valid() const{
    return m_track_href_isValid;
}

QString OAIAudioFeaturesObject::getType() const {
    return m_type;
}
void OAIAudioFeaturesObject::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIAudioFeaturesObject::is_type_Set() const{
    return m_type_isSet;
}

bool OAIAudioFeaturesObject::is_type_Valid() const{
    return m_type_isValid;
}

QString OAIAudioFeaturesObject::getUri() const {
    return m_uri;
}
void OAIAudioFeaturesObject::setUri(const QString &uri) {
    m_uri = uri;
    m_uri_isSet = true;
}

bool OAIAudioFeaturesObject::is_uri_Set() const{
    return m_uri_isSet;
}

bool OAIAudioFeaturesObject::is_uri_Valid() const{
    return m_uri_isValid;
}

float OAIAudioFeaturesObject::getValence() const {
    return m_valence;
}
void OAIAudioFeaturesObject::setValence(const float &valence) {
    m_valence = valence;
    m_valence_isSet = true;
}

bool OAIAudioFeaturesObject::is_valence_Set() const{
    return m_valence_isSet;
}

bool OAIAudioFeaturesObject::is_valence_Valid() const{
    return m_valence_isValid;
}

bool OAIAudioFeaturesObject::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_acousticness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_analysis_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_danceability_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_duration_ms_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_energy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instrumentalness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_liveness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_loudness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_speechiness_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_tempo_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_signature_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_track_href_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uri_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_valence_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAudioFeaturesObject::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
