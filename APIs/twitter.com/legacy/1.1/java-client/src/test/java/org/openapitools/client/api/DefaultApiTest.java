/*
 * Twitter API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1
 * Contact: support@twitter.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for DefaultApi
 */
@Disabled
public class DefaultApiTest {

    private final DefaultApi api = new DefaultApi();

    /**
     * Returns settings (including current trend, geo and sleep time information) for the authenticating user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountSettingsGetTest() throws ApiException {
        String trendLocationWoeid = null;
        String sleepTimeEnabled = null;
        String startSleepTime = null;
        String endSleepTime = null;
        String timeZone = null;
        String lang = null;
        api.accountSettingsGet(trendLocationWoeid, sleepTimeEnabled, startSleepTime, endSleepTime, timeZone, lang);
        // TODO: test validations
    }

    /**
     * Updates the authenticating user&#39;s settings.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountSettingsPostTest() throws ApiException {
        String trendLocationWoeid = null;
        String sleepTimeEnabled = null;
        String startSleepTime = null;
        String endSleepTime = null;
        String timeZone = null;
        String lang = null;
        api.accountSettingsPost(trendLocationWoeid, sleepTimeEnabled, startSleepTime, endSleepTime, timeZone, lang);
        // TODO: test validations
    }

    /**
     * Sets which device Twitter delivers updates to for the authenticating user. Sending none as the device parameter will disable SMS updates.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountUpdateDeliveryDeviceTest() throws ApiException {
        String device = null;
        String includeEntities = null;
        api.accountUpdateDeliveryDevice(device, includeEntities);
        // TODO: test validations
    }

    /**
     * Sets values that users are able to set under the Account tab of their settings page. Only the parameters specified will be updated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountUpdateProfileTest() throws ApiException {
        String name = null;
        String url = null;
        String location = null;
        String description = null;
        String includeEntities = null;
        String skipStatus = null;
        api.accountUpdateProfile(name, url, location, description, includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Updates the authenticating user&#39;s profile background image. This method can also be used to enable or disable the profile background image. Although each parameter is marked as optional, at least one of image, tile or use must be provided when making this request.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountsUpdateProfileBackgroundImageTest() throws ApiException {
        String contentType = null;
        String tile = null;
        String use = null;
        String includeEntities = null;
        String skipStatus = null;
        api.accountsUpdateProfileBackgroundImage(contentType, tile, use, includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Sets one or more hex values that control the color scheme of the authenticating user&#39;s profile page on twitter.com. Each parameter&#39;s value must be a valid hexidecimal value, and may be either three or six characters (ex: #fff or #ffffff).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountsUpdateProfileColorsTest() throws ApiException {
        String profileBackgroundColor = null;
        String profileLinkColor = null;
        String profileSidebarBorderColor = null;
        String profileSidebarFillColor = null;
        String profileTextColor = null;
        String includeEntities = null;
        String skipStatus = null;
        api.accountsUpdateProfileColors(profileBackgroundColor, profileLinkColor, profileSidebarBorderColor, profileSidebarFillColor, profileTextColor, includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Updates the authenticating user&#39;s profile image. Note that this method expects raw multipart data, not a URL to an image. This method asynchronously processes the uploaded file before updating the user&#39;s profile image URL. You can either update your local cache the next time you request the user&#39;s information, or, at least 5 seconds after uploading the image, ask for the updated URL using GET users/profile_image/:screen_name (https://dev.twitter.com/docs/api/1/get/users/profile_image/:screen_name).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountsUpdateProfileImageTest() throws ApiException {
        String contentType = null;
        String skipStatus = null;
        api.accountsUpdateProfileImage(contentType, skipStatus);
        // TODO: test validations
    }

    /**
     * Returns the current rate limits for methods belonging to the specified resource families.  Each 1.1 API resource belongs to a \&quot;resource family\&quot; which is indicated in its method documentation. You can typically determine a method&#39;s resource family from the first component of the path after the resource version.  This method responds with a map of methods belonging to the families specified by the resources parameter, the current remaining uses for each of those resources within the current rate limiting window, and its expiration time in epoch time. It also includes a rate_limit_context field that indicates the current access token context.  You may also issue requests to this method without any parameters to receive a map of all rate limited GET methods. If your application only uses a few of methods, please explicitly provide a resources parameter with the specified resource families you work with.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void applicationRateLimitStatusTest() throws ApiException {
        String resources = null;
        api.applicationRateLimitStatus(resources);
        // TODO: test validations
    }

    /**
     * Blocks the specified user from following the authenticating user. In addition the blocked user will not show in the authenticating users mentions or timeline (unless retweeted by another user). If a follow or friend relationship exists it is destroyed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void blocksCreateTest() throws ApiException {
        String includeEntities = null;
        String skipStatus = null;
        api.blocksCreate(includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Un-blocks the user specified in the ID parameter for the authenticating user. Returns the un-blocked user in the requested format when successful. If relationships existed before the block was instated, they will not be restored.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void blocksDestroyTest() throws ApiException {
        String includeEntities = null;
        String skipStatus = null;
        api.blocksDestroy(includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Returns an array of numeric user ids the authenticating user is blocking.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void blocksIdsTest() throws ApiException {
        String stringifyIds = null;
        String cursor = null;
        api.blocksIds(stringifyIds, cursor);
        // TODO: test validations
    }

    /**
     * Allows one to enable or disable retweets and device notifications from the specified user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void blocksListTest() throws ApiException {
        String includeEntities = null;
        String skipStatus = null;
        String cursor = null;
        api.blocksList(includeEntities, skipStatus, cursor);
        // TODO: test validations
    }

    /**
     * Returns the 20 most recent direct messages sent to the authenticating user. Includes detailed information about the sender and recipient user. You can request up to 200 direct messages per call, up to a maximum of 800 incoming DMs.  Important: This method requires an access token with RWD (read, write and direct message) permissions. Consult The Application Permission Model for more information.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void directMessagesTest() throws ApiException {
        String count = null;
        String sinceId = null;
        String maxId = null;
        String includeEntities = null;
        String page = null;
        String skipStatus = null;
        api.directMessages(count, sinceId, maxId, includeEntities, page, skipStatus);
        // TODO: test validations
    }

    /**
     * Destroys the direct message specified in the required ID parameter. The authenticating user must be the recipient of the specified direct message.  Important: This method requires an access token with RWD (read, write and direct message) permissions. Consult The Application Permission Model for more information.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void directMessagesDestroyTest() throws ApiException {
        String id = null;
        String includeEntities = null;
        api.directMessagesDestroy(id, includeEntities);
        // TODO: test validations
    }

    /**
     * Sends a new direct message to the specified user from the authenticating user. Requires both the user and text parameters and must be a POST. Returns the sent message in the requested format if successful.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void directMessagesNewTest() throws ApiException {
        String text = null;
        api.directMessagesNew(text);
        // TODO: test validations
    }

    /**
     * Returns the 20 most recent direct messages sent by the authenticating user. Includes detailed information about the sender and recipient user. You can request up to 200 direct messages per call, up to a maximum of 800 outgoing DMs.  Important: This method requires an access token with RWD (read, write and direct message) permissions. Consult The Application Permission Model for more information.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void directMessagesSentTest() throws ApiException {
        String count = null;
        String sinceId = null;
        String maxId = null;
        String includeEntities = null;
        String page = null;
        api.directMessagesSent(count, sinceId, maxId, includeEntities, page);
        // TODO: test validations
    }

    /**
     * Returns a single direct message, specified by an id parameter. Like the /1.1/direct_messages.format request, this method will include the user objects of the sender and recipient.  Important: This method requires an access token with RWD (read, write and direct message) permissions. Consult The Application Permission Model for more information.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void directMessagesShowTest() throws ApiException {
        String id = null;
        api.directMessagesShow(id);
        // TODO: test validations
    }

    /**
     * Favorites the status specified in the ID parameter as the authenticating user. Returns the favorite status when successful.  This process invoked by this method is asynchronous. The immediately returned status may not indicate the resultant favorited status of the tweet. A 200 OK response from this method will indicate whether the intended action was successful or not.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void favoritesCreateTest() throws ApiException {
        String id = null;
        String includeEntities = null;
        api.favoritesCreate(id, includeEntities);
        // TODO: test validations
    }

    /**
     * Un-favorites the status specified in the ID parameter as the authenticating user. Returns the un-favorited status in the requested format when successful.  This process invoked by this method is asynchronous. The immediately returned status may not indicate the resultant favorited status of the tweet. A 200 OK response from this method will indicate whether the intended action was successful or not.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void favoritesDestroyTest() throws ApiException {
        String id = null;
        String includeEntities = null;
        api.favoritesDestroy(id, includeEntities);
        // TODO: test validations
    }

    /**
     * Returns the 20 most recent Tweets favorited by the authenticating or specified user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void favoritesListTest() throws ApiException {
        String count = null;
        String sinceId = null;
        String maxId = null;
        String includeEntities = null;
        api.favoritesList(count, sinceId, maxId, includeEntities);
        // TODO: test validations
    }

    /**
     * Returns a cursored collection of user IDs for every user following the specified user.  At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. Results are given in groups of 5,000 user IDs and multiple \&quot;pages\&quot; of results can be navigated through using the next_cursor value in subsequent requests. See Using cursors to navigate collections for more information.  This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void followersIdsTest() throws ApiException {
        String stringifyIds = null;
        String cursor = null;
        api.followersIds(stringifyIds, cursor);
        // TODO: test validations
    }

    /**
     * Returns a cursored collection of user IDs for every user the specified user is following (otherwise known as their \&quot;friends\&quot;).  At this time, results are ordered with the most recent following first — however, this ordering is subject to unannounced change and eventual consistency issues. Results are given in groups of 5,000 user IDs and multiple \&quot;pages\&quot; of results can be navigated through using the next_cursor value in subsequent requests. See Using cursors to navigate collections for more information.  This method is especially powerful when used in conjunction with GET users/lookup, a method that allows you to convert user IDs into full user objects in bulk.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendsIdsTest() throws ApiException {
        String stringifyIds = null;
        String cursor = null;
        api.friendsIds(stringifyIds, cursor);
        // TODO: test validations
    }

    /**
     * Allows the authenticating users to follow the user specified in the ID parameter.  Returns the befriended user in the requested format when successful. Returns a string describing the failure condition when unsuccessful. If you are already friends with the user a HTTP 403 may be returned, though for performance reasons you may get a 200 OK message even if the friendship already exists.  Actions taken in this method are asynchronous and changes will be eventually consistent.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendshipsCreateTest() throws ApiException {
        String follow = null;
        api.friendshipsCreate(follow);
        // TODO: test validations
    }

    /**
     * Allows the authenticating user to unfollow the user specified in the ID parameter.  Returns the unfollowed user in the requested format when successful. Returns a string describing the failure condition when unsuccessful.  Actions taken in this method are asynchronous and changes will be eventually consistent.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendshipsDestroyTest() throws ApiException {
        api.friendshipsDestroy();
        // TODO: test validations
    }

    /**
     * Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided. Values for connections can be: following, following_requested, followed_by, none.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendshipsIncomingTest() throws ApiException {
        String stringifyIds = null;
        String cursor = null;
        api.friendshipsIncoming(stringifyIds, cursor);
        // TODO: test validations
    }

    /**
     * Returns the relationships of the authenticating user to the comma-separated list of up to 100 screen_names or user_ids provided. Values for connections can be: following, following_requested, followed_by, none.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendshipsLookupTest() throws ApiException {
        api.friendshipsLookup();
        // TODO: test validations
    }

    /**
     * Returns a collection of numeric IDs for every protected user for whom the authenticating user has a pending follow request.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendshipsOutgoingTest() throws ApiException {
        String stringifyIds = null;
        String cursor = null;
        api.friendshipsOutgoing(stringifyIds, cursor);
        // TODO: test validations
    }

    /**
     * Returns detailed information about the relationship between two arbitrary users.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendshipsShowTest() throws ApiException {
        String targetId = null;
        String targetScreenName = null;
        String sourceId = null;
        String sourceScreenName = null;
        api.friendshipsShow(targetId, targetScreenName, sourceId, sourceScreenName);
        // TODO: test validations
    }

    /**
     * Allows one to enable or disable retweets and device notifications from the specified user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void friendshipsUpdateTest() throws ApiException {
        String device = null;
        String retweets = null;
        api.friendshipsUpdate(device, retweets);
        // TODO: test validations
    }

    /**
     * Returns all the information about a known place.Example Values: df51dec6f4ee2b2c
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void geoPlaceIdTest() throws ApiException {
        String placeId = null;
        api.geoPlaceId(placeId);
        // TODO: test validations
    }

    /**
     * Creates a new place object at the given latitude and longitude.  Before creating a place you need to query GET geo/similar_places with the latitude, longitude and name of the place you wish to create. The query will return an array of places which are similar to the one you wish to create, and a token. If the place you wish to create isn&#39;t in the returned array you can use the token with this method to create a new one.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void geoPlacesTest() throws ApiException {
        String attributeColonStreetAddress = null;
        String paramCallback = null;
        api.geoPlaces(attributeColonStreetAddress, paramCallback);
        // TODO: test validations
    }

    /**
     * Given a latitude and a longitude, searches for up to 20 places that can be used as a place_id when updating a status.  This request is an informative call and will deliver generalized results about geography
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void geoReverseGeocodeTest() throws ApiException {
        String lat = null;
        String _long = null;
        String accuracy = null;
        String granularity = null;
        String maxResults = null;
        String paramCallback = null;
        api.geoReverseGeocode(lat, _long, accuracy, granularity, maxResults, paramCallback);
        // TODO: test validations
    }

    /**
     * Search for places that can be attached to a statuses/update. Given a latitude and a longitude pair, an IP address, or a name, this request will return a list of all the valid places that can be used as the place_id when updating a status.  Conceptually, a query can be made from the user&#39;s location, retrieve a list of places, have the user validate the location he or she is at, and then send the ID of this location with a call to POST statuses/update.  This is the recommended method to use find places that can be attached to statuses/update. Unlike GET geo/reverse_geocode which provides raw data access, this endpoint can potentially re-order places with regards to the user who is authenticated. This approach is also preferred for interactive place matching with the user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void geoSearchTest() throws ApiException {
        String accuracy = null;
        String granularity = null;
        String containedWithin = null;
        String attributeColonStreetAddress = null;
        String paramCallback = null;
        api.geoSearch(accuracy, granularity, containedWithin, attributeColonStreetAddress, paramCallback);
        // TODO: test validations
    }

    /**
     * Locates places near the given coordinates which are similar in name.  Conceptually you would use this method to get a list of known places to choose from first. Then, if the desired place doesn&#39;t exist, make a request to POST geo/place to create a new one.  The token contained in the response is the token needed to be able to create a new place.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void geoSimilarPlacesTest() throws ApiException {
        String containedWithin = null;
        String attributeColonStreetAddress = null;
        String paramCallback = null;
        api.geoSimilarPlaces(containedWithin, attributeColonStreetAddress, paramCallback);
        // TODO: test validations
    }

    /**
     * Returns the current configuration used by Twitter including twitter.com slugs which are not usernames, maximum photo resolutions, and t.co URL lengths.  It is recommended applications request this endpoint when they are loaded, but no more than once a day.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void helpConfigurationsTest() throws ApiException {
        api.helpConfigurations();
        // TODO: test validations
    }

    /**
     * Returns the list of languages supported by Twitter along with their ISO 639-1 code. The ISO 639-1 code is the two letter value to use if you include lang with any of your requests.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void helpLanguagesTest() throws ApiException {
        api.helpLanguages();
        // TODO: test validations
    }

    /**
     * Returns Twitter&#39;s Privacy Policy
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void helpPrivacyTest() throws ApiException {
        api.helpPrivacy();
        // TODO: test validations
    }

    /**
     * Returns the Twitter Terms of Service in the requested format. These are not the same as the Developer Rules of the Road.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void helpTosTest() throws ApiException {
        api.helpTos();
        // TODO: test validations
    }

    /**
     * Creates a new list for the authenticated user. Note that you can&#39;t create more than 20 lists per account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsCreateTest() throws ApiException {
        String name = null;
        String mode = null;
        String description = null;
        api.listsCreate(name, mode, description);
        // TODO: test validations
    }

    /**
     * Deletes the specified list. The authenticated user must own the list to be able to destroy it.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsDestroyTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        api.listsDestroy(ownerScreenName, ownerId);
        // TODO: test validations
    }

    /**
     * Returns all lists the authenticating or specified user subscribes to, including their own. The user is specified using the user_id or screen_name parameters. If no user is given, the authenticating user is used.  This method used to be GET lists in version 1.0 of the API and has been renamed for consistency with other call.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsListTest() throws ApiException {
        String screenName = null;
        String userId = null;
        api.listsList(screenName, userId);
        // TODO: test validations
    }

    /**
     * Returns the members of the specified list. Private list members will only be shown if the authenticated user owns the specified list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsMembersTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        String includeEntities = null;
        String skipStatus = null;
        String cursor = null;
        api.listsMembers(ownerScreenName, ownerId, includeEntities, skipStatus, cursor);
        // TODO: test validations
    }

    /**
     * Add a member to a list. The authenticated user must own the list to be able to add members to it. Note that lists can&#39;t have more than 500 members.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsMembersCreateTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        api.listsMembersCreate(ownerScreenName, ownerId);
        // TODO: test validations
    }

    /**
     * Adds multiple members to a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to add members to it. Note that lists can&#39;t have more than 500 members, and you are limited to adding up to 100 members to a list at a time with this method.  Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsMembersCreateAllTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        String userId = null;
        String screenName = null;
        api.listsMembersCreateAll(ownerScreenName, ownerId, userId, screenName);
        // TODO: test validations
    }

    /**
     * Removes the specified member from the list. The authenticated user must be the list&#39;s owner to remove members from the list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsMembersDestroyTest() throws ApiException {
        String listId = null;
        String slug = null;
        String ownerScreenName = null;
        String ownerId = null;
        String userId = null;
        String screenName = null;
        api.listsMembersDestroy(listId, slug, ownerScreenName, ownerId, userId, screenName);
        // TODO: test validations
    }

    /**
     * Removes multiple members from a list, by specifying a comma-separated list of member ids or screen names. The authenticated user must own the list to be able to remove members from it. Note that lists can&#39;t have more than 500 members, and you are limited to removing up to 100 members to a list at a time with this method.  Please note that there can be issues with lists that rapidly remove and add memberships. Take care when using these methods such that you are not too rapidly switching between removals and adds on the same list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsMembersDestroyAllTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        String screenName = null;
        String userId = null;
        api.listsMembersDestroyAll(ownerScreenName, ownerId, screenName, userId);
        // TODO: test validations
    }

    /**
     * Check if the specified user is a member of the specified list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsMembersShowTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        String includeEntities = null;
        String skipStatus = null;
        api.listsMembersShow(ownerScreenName, ownerId, includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Returns the lists the specified user has been added to. If user_id or screen_name are not provided the memberships for the authenticating user are returned.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsMembershipsTest() throws ApiException {
        String userId = null;
        String screenName = null;
        String cursor = null;
        String filterToOwnedLists = null;
        api.listsMemberships(userId, screenName, cursor, filterToOwnedLists);
        // TODO: test validations
    }

    /**
     * Returns the specified list. Private lists will only be shown if the authenticated user owns the specified list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsShowTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        api.listsShow(ownerScreenName, ownerId);
        // TODO: test validations
    }

    /**
     * Returns tweet timeline for members of the specified list. Retweets are included by default. You can use the include_rts&#x3D;false parameter to omit retweet objects.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsStatusesTest() throws ApiException {
        String includeRts = null;
        String ownerScreenName = null;
        String ownerId = null;
        String sinceId = null;
        String maxId = null;
        String count = null;
        String includeEntities = null;
        api.listsStatuses(includeRts, ownerScreenName, ownerId, sinceId, maxId, count, includeEntities);
        // TODO: test validations
    }

    /**
     * Returns the subscribers of the specified list. Private list subscribers will only be shown if the authenticated user owns the specified list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsSubscribersTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        String cursor = null;
        String includeEntities = null;
        String skipStatus = null;
        api.listsSubscribers(ownerScreenName, ownerId, cursor, includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Subscribes the authenticated user to the specified list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsSubscribersCreateTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        api.listsSubscribersCreate(ownerScreenName, ownerId);
        // TODO: test validations
    }

    /**
     * Unsubscribes the authenticated user from the specified list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsSubscribersDestroyTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        api.listsSubscribersDestroy(ownerScreenName, ownerId);
        // TODO: test validations
    }

    /**
     * Check if the specified user is a subscriber of the specified list. Returns the user if they are subscriber.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsSubscribersShowTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        String includeEntities = null;
        String skipStatus = null;
        api.listsSubscribersShow(ownerScreenName, ownerId, includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Obtain a collection of the lists the specified user is subscribed to, 20 lists per page by default. Does not include the user&#39;s own lists.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsSubscriptionsTest() throws ApiException {
        String count = null;
        String cursor = null;
        api.listsSubscriptions(count, cursor);
        // TODO: test validations
    }

    /**
     * Updates the specified list. The authenticated user must own the list to be able to update it.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listsUpdateTest() throws ApiException {
        String ownerScreenName = null;
        String ownerId = null;
        String name = null;
        String mode = null;
        String description = null;
        api.listsUpdate(ownerScreenName, ownerId, name, mode, description);
        // TODO: test validations
    }

    /**
     * Create a new saved search for the authenticated user. A user may only have 25 saved searches.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void savedSearchesCreateTest() throws ApiException {
        String query = null;
        api.savedSearchesCreate(query);
        // TODO: test validations
    }

    /**
     * Destroys a saved search for the authenticating user. The authenticating user must be the owner of saved search id being destroyed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void savedSearchesDestroyTest() throws ApiException {
        String id = null;
        api.savedSearchesDestroy(id);
        // TODO: test validations
    }

    /**
     * Returns the authenticated user&#39;s saved search queries.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void savedSearchesListTest() throws ApiException {
        api.savedSearchesList();
        // TODO: test validations
    }

    /**
     * Returns the authenticated user&#39;s saved search queries.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void savedsearchesidTest() throws ApiException {
        String id = null;
        api.savedsearchesid(id);
        // TODO: test validations
    }

    /**
     * Returns a collection of relevant Tweets matching a specified query.  Please note that Twitter&#39;s search service and, by extension, the Search API is not meant to be an exhaustive source of Tweets. Not all Tweets will be indexed or made available via the search interface.  In API v1.1, the response format of the Search API has been improved to return Tweet objects more similar to the objects you&#39;ll find across the REST API and platform. You may need to tolerate some inconsistencies and variance in perspectival values (fields that pertain to the perspective of the authenticating user) and embedded user objects.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void searchTweetsTest() throws ApiException {
        String q = null;
        String geocode = null;
        String lang = null;
        String locale = null;
        String resultType = null;
        String count = null;
        String until = null;
        String sinceId = null;
        String maxId = null;
        String includeEntities = null;
        String paramCallback = null;
        api.searchTweets(q, geocode, lang, locale, resultType, count, until, sinceId, maxId, includeEntities, paramCallback);
        // TODO: test validations
    }

    /**
     * Destroys the status specified by the required ID parameter. The authenticating user must be the author of the specified status. Returns the destroyed status if successful.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesDestroyTest() throws ApiException {
        String id = null;
        String trimUser = null;
        api.statusesDestroy(id, trimUser);
        // TODO: test validations
    }

    /**
     * Returns a collection of the most recent Tweets and retweets posted by the authenticating user and the users they follow. The home timeline is central to how most users interact with the Twitter service.  Up to 800 Tweets are obtainable on the home timeline. It is more volatile for users that follow many users or follow users who tweet frequently.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesHomeTimelineTest() throws ApiException {
        Integer count = null;
        Long maxId = null;
        Long sinceId = null;
        String trimUser = null;
        String excludeReplies = null;
        String contributorDetails = null;
        api.statusesHomeTimeline(count, maxId, sinceId, trimUser, excludeReplies, contributorDetails);
        // TODO: test validations
    }

    /**
     * Returns the 20 most recent mentions (tweets containing a users&#39;s @screen_name) for the authenticating user.The timeline returned is the equivalent of the one seen when you view your mentions on twitter.com.This method can only return up to 800 statuses.This method will include retweets in the JSON response regardless of whether the include_rts parameter is set.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesMentionsTimelineTest() throws ApiException {
        Integer count = null;
        Long sinceId = null;
        Long maxId = null;
        String trimUser = null;
        String contributorDetails = null;
        Boolean includeEntities = null;
        api.statusesMentionsTimeline(count, sinceId, maxId, trimUser, contributorDetails, includeEntities);
        // TODO: test validations
    }

    /**
     * Returns information allowing the creation of an embedded representation of a Tweet on third party sites. See the oEmbed specification (http://oembed.com) for information about the response format. Either the id or url parameters must be specified in a request, it is not necessary to include both. While this endpoint allows a bit of customization for the final appearance of the embedded Tweet, be aware that the appearance of the rendered Tweet may change over time to be consistent with Twitter&#39;s Display Guidelines (https://dev.twitter.com/terms/display-guidelines). Do not rely on any class or id parameters to stay constant in the returned markup.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesOembedTest() throws ApiException {
        Integer maxwidth = null;
        String hideMedia = null;
        String hideThread = null;
        String omitScript = null;
        String align = null;
        String related = null;
        String lang = null;
        api.statusesOembed(maxwidth, hideMedia, hideThread, omitScript, align, related, lang);
        // TODO: test validations
    }

    /**
     * Returns up to 100 of the first retweets of a given tweet.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesRetweetsTest() throws ApiException {
        String id = null;
        String count = null;
        String trimUser = null;
        api.statusesRetweets(id, count, trimUser);
        // TODO: test validations
    }

    /**
     * Returns a single status, specified by the id parameter below. The status&#39;s author will be returned inline.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesShowTest() throws ApiException {
        String id = null;
        String trimUser = null;
        String includeMyRetweet = null;
        String includeEntities = null;
        api.statusesShow(id, trimUser, includeMyRetweet, includeEntities);
        // TODO: test validations
    }

    /**
     * Updates the authenticating user&#39;s status, also known as tweeting. To upload an image to accompany the tweet, use POST statuses/update_with_media (https://dev.twitter.com/docs/api/1/post/statuses/update_with_media). For each update attempt, the update text is compared with the authenticating user&#39;s recent tweets. Any attempt that would result in duplication will be blocked, resulting in a 403 error. Therefore, a user cannot submit the same status twice in a row. While not rate limited by the API a user is limited in the number of tweets they can create at a time. If the number of updates posted by the user reaches the current allowed limit this method will return an HTTP 403 error.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesUpdateTest() throws ApiException {
        String status = null;
        String inReplyToStatusId = null;
        String lat = null;
        String _long = null;
        String placeId = null;
        String displayCoordinates = null;
        String trimUser = null;
        api.statusesUpdate(status, inReplyToStatusId, lat, _long, placeId, displayCoordinates, trimUser);
        // TODO: test validations
    }

    /**
     * Updates the authenticating user&#39;s status and attaches media for upload. Unlike POST statuses/update (https://dev.twitter.com/docs/api/1.1/post/statuses/update), this method expects raw multipart data. Your POST request&#39;s Content-Type should be set to multipart/form-data with the media[] parameter. The Tweet text will be rewritten to include the media URL(s), which will reduce the number of characters allowed in the Tweet text. If the URL(s) cannot be appended without text truncation, the tweet will be rejected and this method will return an HTTP 403 error. Important: Make sure that you&#39;re using upload.twitter.com as your host while posting statuses with media. It is strongly recommended to use SSL with this method.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesUpdateWithMediaTest() throws ApiException {
        String status = null;
        String media = null;
        String contentType = null;
        String possiblySensitive = null;
        String inReplyToStatusId = null;
        String lat = null;
        String _long = null;
        String placeId = null;
        String displayCoordinates = null;
        api.statusesUpdateWithMedia(status, media, contentType, possiblySensitive, inReplyToStatusId, lat, _long, placeId, displayCoordinates);
        // TODO: test validations
    }

    /**
     * Returns the 20 most recent statuses posted by the authenticating user. It is also possible to request another user&#39;s timeline by using the screen_name or user_id parameter. The other users timeline will only be visible if they are not protected, or if the authenticating user&#39;s follow request was accepted by the protected user. The timeline returned is the equivalent of the one seen when you view a user&#39;s profile on twitter.com. This method can only return up to 3,200 of a user&#39;s most recent statuses. Native retweets of other statuses by the user is included in this total, regardless of whether include_rts is specified when requesting this resource. This method will not include retweets in the XML and JSON responses unless the include_rts parameter is set. The RSS and Atom responses will always include retweets as statuses prefixed with RT, regardless of provided parameters. Always specify either an user_id or screen_name when requesting a user timeline.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesUserTimelineTest() throws ApiException {
        Integer count = null;
        Long sinceId = null;
        Long maxId = null;
        String trimUser = null;
        Boolean excludeReplies = null;
        Boolean contributorDetails = null;
        Boolean includeRts = null;
        api.statusesUserTimeline(count, sinceId, maxId, trimUser, excludeReplies, contributorDetails, includeRts);
        // TODO: test validations
    }

    /**
     * Retweets a tweet. Returns the original tweet with retweet details embedded.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void statusesretweetidTest() throws ApiException {
        String id = null;
        String trimUser = null;
        api.statusesretweetid(id, trimUser);
        // TODO: test validations
    }

    /**
     * Returns the locations that Twitter has trending topic information for.  The response is an array of \&quot;locations\&quot; that encode the location&#39;s WOEID and some other human-readable information such as a canonical name and country the location belongs in.  A WOEID is a Yahoo! Where On Earth ID.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void trendsAvailableTest() throws ApiException {
        api.trendsAvailable();
        // TODO: test validations
    }

    /**
     * Returns the locations that Twitter has trending topic information for, closest to a specified location.  The response is an array of \&quot;locations\&quot; that encode the location&#39;s WOEID and some other human-readable information such as a canonical name and country the location belongs in.  A WOEID is a Yahoo! Where On Earth ID.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void trendsClosestTest() throws ApiException {
        String lat = null;
        String _long = null;
        api.trendsClosest(lat, _long);
        // TODO: test validations
    }

    /**
     * Returns the top 10 trending topics for a specific WOEID, if trending information is available for it.  The response is an array of \&quot;trend\&quot; objects that encode the name of the trending topic, the query parameter that can be used to search for the topic on Twitter Search, and the Twitter Search URL.  This information is cached for 5 minutes. Requesting more frequently than that will not return any more data, and will count against your rate limit usage.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void trendsPlaceTest() throws ApiException {
        String id = null;
        String exclude = null;
        api.trendsPlace(id, exclude);
        // TODO: test validations
    }

    /**
     * Returns a collection of users that the specified user can contribute to.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersContributeesTest() throws ApiException {
        String includeEntities = null;
        String skipStatus = null;
        api.usersContributees(includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Returns a collection of users who can contribute to the specified account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersContributorsTest() throws ApiException {
        String includeEntities = null;
        String skipStatus = null;
        api.usersContributors(includeEntities, skipStatus);
        // TODO: test validations
    }

    /**
     * Returns fully-hydrated user objects for up to 100 users per request, as specified by comma-separated values passed to the user_id and/or screen_name parameters.  This method is especially useful when used in conjunction with collections of user IDs returned from GET friends/ids and GET followers/ids.  GET users/show is used to retrieve a single user object.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersLookupTest() throws ApiException {
        String screenName = null;
        String userId = null;
        String includeEntities = null;
        api.usersLookup(screenName, userId, includeEntities);
        // TODO: test validations
    }

    /**
     * The user specified in the id is blocked by the authenticated user and reported as a spammer.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersReportSpamTest() throws ApiException {
        api.usersReportSpam();
        // TODO: test validations
    }

    /**
     * Provides a simple, relevance-based search interface to public user accounts on Twitter. Try querying by topical interest, full name, company name, location, or other criteria. Exact match searches are not supported.  Only the first 1,000 matching results are available.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersSearchTest() throws ApiException {
        String q = null;
        String page = null;
        String count = null;
        String includeEntities = null;
        api.usersSearch(q, page, count, includeEntities);
        // TODO: test validations
    }

    /**
     * Returns a variety of information about the user specified by the required user_id or screen_name parameter. The author&#39;s most recent Tweet will be returned inline when possible.  GET users/lookup is used to retrieve a bulk collection of user objects.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersShowTest() throws ApiException {
        String screenName = null;
        String userId = null;
        String includeEntities = null;
        api.usersShow(screenName, userId, includeEntities);
        // TODO: test validations
    }

    /**
     * Access to Twitter&#39;s suggested user list. This returns the list of suggested user categories. The category can be used in GET users/suggestions/:slug to get the users in that category.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersSuggestionsTest() throws ApiException {
        String lang = null;
        api.usersSuggestions(lang);
        // TODO: test validations
    }

    /**
     * Access the users in a given category of the Twitter suggested user list. It is recommended that applications cache this data for no more than one hour.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersSuggestionsSlugTest() throws ApiException {
        String slug = null;
        String lang = null;
        api.usersSuggestionsSlug(slug, lang);
        // TODO: test validations
    }

    /**
     * Access the users in a given category of the Twitter suggested user list and return their most recent status if they are not a protected user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersSuggestionsslugmembersTest() throws ApiException {
        String slug = null;
        api.usersSuggestionsslugmembers(slug);
        // TODO: test validations
    }

}
