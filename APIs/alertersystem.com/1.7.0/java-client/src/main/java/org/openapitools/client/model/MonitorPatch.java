/*
 * Alerter System API
 * <p>This is the <a href=\"/\">Alerter System</a> API playground. More documentation is available at the <a href=\"/help/developers/\">API Help Center</a>.</p><p>The \"Available Authorizations\" in the Authorize popup only applies to this playground web interface. Other <a href=\"/help/developers/authorization/\">authorizations</a> are available for the actual API.</p>
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The Monitor resource is a collection of services that monitor the presence and/or absence of pings, and follow sets of rules to dispatch or not dispatch alerts.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:22:03.392245-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MonitorPatch {
  public static final String SERIALIZED_NAME_ALERT_PAYLOAD_EXTENDED = "alertPayloadExtended";
  @SerializedName(SERIALIZED_NAME_ALERT_PAYLOAD_EXTENDED)
  private String alertPayloadExtended;

  public static final String SERIALIZED_NAME_ALERT_PAYLOAD_SHORT = "alertPayloadShort";
  @SerializedName(SERIALIZED_NAME_ALERT_PAYLOAD_SHORT)
  private String alertPayloadShort;

  public static final String SERIALIZED_NAME_ALERT_SERVICES = "alertServices";
  @SerializedName(SERIALIZED_NAME_ALERT_SERVICES)
  private List<String> alertServices = new ArrayList<>();

  public static final String SERIALIZED_NAME_ALLOW_UNAUTHENTICATED_PINGS = "allowUnauthenticatedPings";
  @SerializedName(SERIALIZED_NAME_ALLOW_UNAUTHENTICATED_PINGS)
  private Boolean allowUnauthenticatedPings;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_MUST_NOT_EXIST = "contentCheckMustNotExist";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_MUST_NOT_EXIST)
  private Boolean contentCheckMustNotExist;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_TEXT = "contentCheckText";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_TEXT)
  private String contentCheckText;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_URL = "contentCheckUrl";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_URL)
  private URI contentCheckUrl;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_XPATH_FILTER = "contentCheckXpathFilter";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_XPATH_FILTER)
  private String contentCheckXpathFilter;

  public static final String SERIALIZED_NAME_DATA_SEGMENT_CODE = "dataSegmentCode";
  @SerializedName(SERIALIZED_NAME_DATA_SEGMENT_CODE)
  private String dataSegmentCode;

  public static final String SERIALIZED_NAME_GRACE_SECONDS = "graceSeconds";
  @SerializedName(SERIALIZED_NAME_GRACE_SECONDS)
  private Integer graceSeconds;

  public static final String SERIALIZED_NAME_INTERVAL_DAYS = "intervalDays";
  @SerializedName(SERIALIZED_NAME_INTERVAL_DAYS)
  private Integer intervalDays;

  public static final String SERIALIZED_NAME_INTERVAL_HOURS = "intervalHours";
  @SerializedName(SERIALIZED_NAME_INTERVAL_HOURS)
  private Integer intervalHours;

  public static final String SERIALIZED_NAME_INTERVAL_MINUTES = "intervalMinutes";
  @SerializedName(SERIALIZED_NAME_INTERVAL_MINUTES)
  private Integer intervalMinutes;

  public static final String SERIALIZED_NAME_INTERVAL_MONTHS = "intervalMonths";
  @SerializedName(SERIALIZED_NAME_INTERVAL_MONTHS)
  private Integer intervalMonths;

  public static final String SERIALIZED_NAME_INTERVAL_SECONDS = "intervalSeconds";
  @SerializedName(SERIALIZED_NAME_INTERVAL_SECONDS)
  private Integer intervalSeconds;

  public static final String SERIALIZED_NAME_INTERVAL_YEARS = "intervalYears";
  @SerializedName(SERIALIZED_NAME_INTERVAL_YEARS)
  private Integer intervalYears;

  public static final String SERIALIZED_NAME_IS_MONITOR_PAUSED = "isMonitorPaused";
  @SerializedName(SERIALIZED_NAME_IS_MONITOR_PAUSED)
  private Boolean isMonitorPaused;

  public static final String SERIALIZED_NAME_MONITOR_NAME = "monitorName";
  @SerializedName(SERIALIZED_NAME_MONITOR_NAME)
  private String monitorName;

  public static final String SERIALIZED_NAME_MONITOR_NOTES = "monitorNotes";
  @SerializedName(SERIALIZED_NAME_MONITOR_NOTES)
  private String monitorNotes;

  public static final String SERIALIZED_NAME_PUBLIC_DESCRIPTION = "publicDescription";
  @SerializedName(SERIALIZED_NAME_PUBLIC_DESCRIPTION)
  private String publicDescription;

  public static final String SERIALIZED_NAME_START_MONITOR_AT = "startMonitorAt";
  @SerializedName(SERIALIZED_NAME_START_MONITOR_AT)
  private OffsetDateTime startMonitorAt;

  public static final String SERIALIZED_NAME_TIMEZONE_CODE = "timezoneCode";
  @SerializedName(SERIALIZED_NAME_TIMEZONE_CODE)
  private String timezoneCode;

  public static final String SERIALIZED_NAME_WEB_RESPONSE_SECONDS_LIMIT = "webResponseSecondsLimit";
  @SerializedName(SERIALIZED_NAME_WEB_RESPONSE_SECONDS_LIMIT)
  private Integer webResponseSecondsLimit;

  public static final String SERIALIZED_NAME_WEB_RESPONSE_URL = "webResponseUrl";
  @SerializedName(SERIALIZED_NAME_WEB_RESPONSE_URL)
  private URI webResponseUrl;

  public MonitorPatch() {
  }

  public MonitorPatch alertPayloadExtended(String alertPayloadExtended) {
    this.alertPayloadExtended = alertPayloadExtended;
    return this;
  }

  /**
   * Payload that must be sent in the body of each alert when you use your own email or webhook alert services. This is the body for email alerts and the request body for webhook alerts. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 2 MB characters.
   * @return alertPayloadExtended
   */
  @javax.annotation.Nullable
  public String getAlertPayloadExtended() {
    return alertPayloadExtended;
  }

  public void setAlertPayloadExtended(String alertPayloadExtended) {
    this.alertPayloadExtended = alertPayloadExtended;
  }


  public MonitorPatch alertPayloadShort(String alertPayloadShort) {
    this.alertPayloadShort = alertPayloadShort;
    return this;
  }

  /**
   * Payload that must be sent in the body of each alert when you use your own short message alert services. This also serves as the subject for email alerts. Not used for webhooks. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 100 characters.
   * @return alertPayloadShort
   */
  @javax.annotation.Nullable
  public String getAlertPayloadShort() {
    return alertPayloadShort;
  }

  public void setAlertPayloadShort(String alertPayloadShort) {
    this.alertPayloadShort = alertPayloadShort;
  }


  public MonitorPatch alertServices(List<String> alertServices) {
    this.alertServices = alertServices;
    return this;
  }

  public MonitorPatch addAlertServicesItem(String alertServicesItem) {
    if (this.alertServices == null) {
      this.alertServices = new ArrayList<>();
    }
    this.alertServices.add(alertServicesItem);
    return this;
  }

  /**
   * The alert services that are related to this resource.
   * @return alertServices
   */
  @javax.annotation.Nullable
  public List<String> getAlertServices() {
    return alertServices;
  }

  public void setAlertServices(List<String> alertServices) {
    this.alertServices = alertServices;
  }


  public MonitorPatch allowUnauthenticatedPings(Boolean allowUnauthenticatedPings) {
    this.allowUnauthenticatedPings = allowUnauthenticatedPings;
    return this;
  }

  /**
   * Indicates that the monitor will accept pings that are not OAuth authenticated.
   * @return allowUnauthenticatedPings
   */
  @javax.annotation.Nullable
  public Boolean getAllowUnauthenticatedPings() {
    return allowUnauthenticatedPings;
  }

  public void setAllowUnauthenticatedPings(Boolean allowUnauthenticatedPings) {
    this.allowUnauthenticatedPings = allowUnauthenticatedPings;
  }


  public MonitorPatch contentCheckMustNotExist(Boolean contentCheckMustNotExist) {
    this.contentCheckMustNotExist = contentCheckMustNotExist;
    return this;
  }

  /**
   * Indicates that the Web Content monitor must verify the absence of the text or the Xpath node, and dispatch an alert if it is present. The default behavior is to verify the presence of the text or the Xpath node, and dispatch an alert if it is absent.
   * @return contentCheckMustNotExist
   */
  @javax.annotation.Nullable
  public Boolean getContentCheckMustNotExist() {
    return contentCheckMustNotExist;
  }

  public void setContentCheckMustNotExist(Boolean contentCheckMustNotExist) {
    this.contentCheckMustNotExist = contentCheckMustNotExist;
  }


  public MonitorPatch contentCheckText(String contentCheckText) {
    this.contentCheckText = contentCheckText;
    return this;
  }

  /**
   * The text (case-insensitive) that must or must not be present at the contentCheckUrl. If contentCheckXpathFilter is supplied, then the only the text within that nodes is evaluated, otherwise text on the entire web page is evaluated.
   * @return contentCheckText
   */
  @javax.annotation.Nullable
  public String getContentCheckText() {
    return contentCheckText;
  }

  public void setContentCheckText(String contentCheckText) {
    this.contentCheckText = contentCheckText;
  }


  public MonitorPatch contentCheckUrl(URI contentCheckUrl) {
    this.contentCheckUrl = contentCheckUrl;
    return this;
  }

  /**
   * The URL that the Web Content monitor type must evaluate for the specified conditions.
   * @return contentCheckUrl
   */
  @javax.annotation.Nullable
  public URI getContentCheckUrl() {
    return contentCheckUrl;
  }

  public void setContentCheckUrl(URI contentCheckUrl) {
    this.contentCheckUrl = contentCheckUrl;
  }


  public MonitorPatch contentCheckXpathFilter(String contentCheckXpathFilter) {
    this.contentCheckXpathFilter = contentCheckXpathFilter;
    return this;
  }

  /**
   * The Xpath filter (&lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/XPath\&quot;&gt;Xpath&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://devhints.io/xpath\&quot;&gt;Xpath Cheatsheet&lt;/a&gt;) that selects a specific node in the HTML of the target web page. If contentCheckText is supplied, then only the text within the selected node is evaluated. If contentCheckText is left empty, then the presence or the absence of the selected node is evaluated.
   * @return contentCheckXpathFilter
   */
  @javax.annotation.Nullable
  public String getContentCheckXpathFilter() {
    return contentCheckXpathFilter;
  }

  public void setContentCheckXpathFilter(String contentCheckXpathFilter) {
    this.contentCheckXpathFilter = contentCheckXpathFilter;
  }


  public MonitorPatch dataSegmentCode(String dataSegmentCode) {
    this.dataSegmentCode = dataSegmentCode;
    return this;
  }

  /**
   * User-provided string on which to segment and filter data. Max 50 characters.
   * @return dataSegmentCode
   */
  @javax.annotation.Nullable
  public String getDataSegmentCode() {
    return dataSegmentCode;
  }

  public void setDataSegmentCode(String dataSegmentCode) {
    this.dataSegmentCode = dataSegmentCode;
  }


  public MonitorPatch graceSeconds(Integer graceSeconds) {
    this.graceSeconds = graceSeconds;
    return this;
  }

  /**
   * The number of grace seconds after expiry of the time when the next ping was expected, before raising an alert. The number of grace seconds to allow before classifying a Measured Monitor task duration as an anomaly.
   * @return graceSeconds
   */
  @javax.annotation.Nullable
  public Integer getGraceSeconds() {
    return graceSeconds;
  }

  public void setGraceSeconds(Integer graceSeconds) {
    this.graceSeconds = graceSeconds;
  }


  public MonitorPatch intervalDays(Integer intervalDays) {
    this.intervalDays = intervalDays;
    return this;
  }

  /**
   * The number of days in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalDays
   */
  @javax.annotation.Nullable
  public Integer getIntervalDays() {
    return intervalDays;
  }

  public void setIntervalDays(Integer intervalDays) {
    this.intervalDays = intervalDays;
  }


  public MonitorPatch intervalHours(Integer intervalHours) {
    this.intervalHours = intervalHours;
    return this;
  }

  /**
   * The number of hours in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalHours
   */
  @javax.annotation.Nullable
  public Integer getIntervalHours() {
    return intervalHours;
  }

  public void setIntervalHours(Integer intervalHours) {
    this.intervalHours = intervalHours;
  }


  public MonitorPatch intervalMinutes(Integer intervalMinutes) {
    this.intervalMinutes = intervalMinutes;
    return this;
  }

  /**
   * The number of minutes in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalMinutes
   */
  @javax.annotation.Nullable
  public Integer getIntervalMinutes() {
    return intervalMinutes;
  }

  public void setIntervalMinutes(Integer intervalMinutes) {
    this.intervalMinutes = intervalMinutes;
  }


  public MonitorPatch intervalMonths(Integer intervalMonths) {
    this.intervalMonths = intervalMonths;
    return this;
  }

  /**
   * The number of months in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalMonths
   */
  @javax.annotation.Nullable
  public Integer getIntervalMonths() {
    return intervalMonths;
  }

  public void setIntervalMonths(Integer intervalMonths) {
    this.intervalMonths = intervalMonths;
  }


  public MonitorPatch intervalSeconds(Integer intervalSeconds) {
    this.intervalSeconds = intervalSeconds;
    return this;
  }

  /**
   * The number of seconds in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalSeconds
   */
  @javax.annotation.Nullable
  public Integer getIntervalSeconds() {
    return intervalSeconds;
  }

  public void setIntervalSeconds(Integer intervalSeconds) {
    this.intervalSeconds = intervalSeconds;
  }


  public MonitorPatch intervalYears(Integer intervalYears) {
    this.intervalYears = intervalYears;
    return this;
  }

  /**
   * The number of years in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalYears
   */
  @javax.annotation.Nullable
  public Integer getIntervalYears() {
    return intervalYears;
  }

  public void setIntervalYears(Integer intervalYears) {
    this.intervalYears = intervalYears;
  }


  public MonitorPatch isMonitorPaused(Boolean isMonitorPaused) {
    this.isMonitorPaused = isMonitorPaused;
    return this;
  }

  /**
   * Indicates that the monitor is paused and will not send alerts.
   * @return isMonitorPaused
   */
  @javax.annotation.Nullable
  public Boolean getIsMonitorPaused() {
    return isMonitorPaused;
  }

  public void setIsMonitorPaused(Boolean isMonitorPaused) {
    this.isMonitorPaused = isMonitorPaused;
  }


  public MonitorPatch monitorName(String monitorName) {
    this.monitorName = monitorName;
    return this;
  }

  /**
   * The name of the monitor. Max 255 characters.
   * @return monitorName
   */
  @javax.annotation.Nullable
  public String getMonitorName() {
    return monitorName;
  }

  public void setMonitorName(String monitorName) {
    this.monitorName = monitorName;
  }


  public MonitorPatch monitorNotes(String monitorNotes) {
    this.monitorNotes = monitorNotes;
    return this;
  }

  /**
   * Notes about the monitor. Max 10,000 characters. Formatting using Markdown is allowed. HTML will be removed.
   * @return monitorNotes
   */
  @javax.annotation.Nullable
  public String getMonitorNotes() {
    return monitorNotes;
  }

  public void setMonitorNotes(String monitorNotes) {
    this.monitorNotes = monitorNotes;
  }


  public MonitorPatch publicDescription(String publicDescription) {
    this.publicDescription = publicDescription;
    return this;
  }

  /**
   * A text description of the monitor that is accessible to unauthenticated users that receive an alert from the monitor. Formatting using Markdown is allowed. HTML will be removed.
   * @return publicDescription
   */
  @javax.annotation.Nullable
  public String getPublicDescription() {
    return publicDescription;
  }

  public void setPublicDescription(String publicDescription) {
    this.publicDescription = publicDescription;
  }


  public MonitorPatch startMonitorAt(OffsetDateTime startMonitorAt) {
    this.startMonitorAt = startMonitorAt;
    return this;
  }

  /**
   * When to start the Regular Interval type monitor or Heartbeat type monitor, or when to send the first alert of the Scheduled Repeatable Alert monitor. Cannot be blank for a Regular Interval, Heartbeat, or Scheduled Repeatable Alert type monitor, must be blank for other monitors types. This date-time is always interpreted to be in the timezone of the monitor. Any UTC offset is ignored.
   * @return startMonitorAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartMonitorAt() {
    return startMonitorAt;
  }

  public void setStartMonitorAt(OffsetDateTime startMonitorAt) {
    this.startMonitorAt = startMonitorAt;
  }


  public MonitorPatch timezoneCode(String timezoneCode) {
    this.timezoneCode = timezoneCode;
    return this;
  }

  /**
   * The timezone of the monitor. Dates and times in alerts and reports will be in this time zone.
   * @return timezoneCode
   */
  @javax.annotation.Nonnull
  public String getTimezoneCode() {
    return timezoneCode;
  }

  public void setTimezoneCode(String timezoneCode) {
    this.timezoneCode = timezoneCode;
  }


  public MonitorPatch webResponseSecondsLimit(Integer webResponseSecondsLimit) {
    this.webResponseSecondsLimit = webResponseSecondsLimit;
    return this;
  }

  /**
   * The time in seconds that the Web Response monitor type must allow for the web page to respond.
   * minimum: 0
   * @return webResponseSecondsLimit
   */
  @javax.annotation.Nullable
  public Integer getWebResponseSecondsLimit() {
    return webResponseSecondsLimit;
  }

  public void setWebResponseSecondsLimit(Integer webResponseSecondsLimit) {
    this.webResponseSecondsLimit = webResponseSecondsLimit;
  }


  public MonitorPatch webResponseUrl(URI webResponseUrl) {
    this.webResponseUrl = webResponseUrl;
    return this;
  }

  /**
   * The URL that the Web Response monitor type must evaluate for the specified conditions.
   * @return webResponseUrl
   */
  @javax.annotation.Nullable
  public URI getWebResponseUrl() {
    return webResponseUrl;
  }

  public void setWebResponseUrl(URI webResponseUrl) {
    this.webResponseUrl = webResponseUrl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MonitorPatch monitorPatch = (MonitorPatch) o;
    return Objects.equals(this.alertPayloadExtended, monitorPatch.alertPayloadExtended) &&
        Objects.equals(this.alertPayloadShort, monitorPatch.alertPayloadShort) &&
        Objects.equals(this.alertServices, monitorPatch.alertServices) &&
        Objects.equals(this.allowUnauthenticatedPings, monitorPatch.allowUnauthenticatedPings) &&
        Objects.equals(this.contentCheckMustNotExist, monitorPatch.contentCheckMustNotExist) &&
        Objects.equals(this.contentCheckText, monitorPatch.contentCheckText) &&
        Objects.equals(this.contentCheckUrl, monitorPatch.contentCheckUrl) &&
        Objects.equals(this.contentCheckXpathFilter, monitorPatch.contentCheckXpathFilter) &&
        Objects.equals(this.dataSegmentCode, monitorPatch.dataSegmentCode) &&
        Objects.equals(this.graceSeconds, monitorPatch.graceSeconds) &&
        Objects.equals(this.intervalDays, monitorPatch.intervalDays) &&
        Objects.equals(this.intervalHours, monitorPatch.intervalHours) &&
        Objects.equals(this.intervalMinutes, monitorPatch.intervalMinutes) &&
        Objects.equals(this.intervalMonths, monitorPatch.intervalMonths) &&
        Objects.equals(this.intervalSeconds, monitorPatch.intervalSeconds) &&
        Objects.equals(this.intervalYears, monitorPatch.intervalYears) &&
        Objects.equals(this.isMonitorPaused, monitorPatch.isMonitorPaused) &&
        Objects.equals(this.monitorName, monitorPatch.monitorName) &&
        Objects.equals(this.monitorNotes, monitorPatch.monitorNotes) &&
        Objects.equals(this.publicDescription, monitorPatch.publicDescription) &&
        Objects.equals(this.startMonitorAt, monitorPatch.startMonitorAt) &&
        Objects.equals(this.timezoneCode, monitorPatch.timezoneCode) &&
        Objects.equals(this.webResponseSecondsLimit, monitorPatch.webResponseSecondsLimit) &&
        Objects.equals(this.webResponseUrl, monitorPatch.webResponseUrl);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(alertPayloadExtended, alertPayloadShort, alertServices, allowUnauthenticatedPings, contentCheckMustNotExist, contentCheckText, contentCheckUrl, contentCheckXpathFilter, dataSegmentCode, graceSeconds, intervalDays, intervalHours, intervalMinutes, intervalMonths, intervalSeconds, intervalYears, isMonitorPaused, monitorName, monitorNotes, publicDescription, startMonitorAt, timezoneCode, webResponseSecondsLimit, webResponseUrl);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MonitorPatch {\n");
    sb.append("    alertPayloadExtended: ").append(toIndentedString(alertPayloadExtended)).append("\n");
    sb.append("    alertPayloadShort: ").append(toIndentedString(alertPayloadShort)).append("\n");
    sb.append("    alertServices: ").append(toIndentedString(alertServices)).append("\n");
    sb.append("    allowUnauthenticatedPings: ").append(toIndentedString(allowUnauthenticatedPings)).append("\n");
    sb.append("    contentCheckMustNotExist: ").append(toIndentedString(contentCheckMustNotExist)).append("\n");
    sb.append("    contentCheckText: ").append(toIndentedString(contentCheckText)).append("\n");
    sb.append("    contentCheckUrl: ").append(toIndentedString(contentCheckUrl)).append("\n");
    sb.append("    contentCheckXpathFilter: ").append(toIndentedString(contentCheckXpathFilter)).append("\n");
    sb.append("    dataSegmentCode: ").append(toIndentedString(dataSegmentCode)).append("\n");
    sb.append("    graceSeconds: ").append(toIndentedString(graceSeconds)).append("\n");
    sb.append("    intervalDays: ").append(toIndentedString(intervalDays)).append("\n");
    sb.append("    intervalHours: ").append(toIndentedString(intervalHours)).append("\n");
    sb.append("    intervalMinutes: ").append(toIndentedString(intervalMinutes)).append("\n");
    sb.append("    intervalMonths: ").append(toIndentedString(intervalMonths)).append("\n");
    sb.append("    intervalSeconds: ").append(toIndentedString(intervalSeconds)).append("\n");
    sb.append("    intervalYears: ").append(toIndentedString(intervalYears)).append("\n");
    sb.append("    isMonitorPaused: ").append(toIndentedString(isMonitorPaused)).append("\n");
    sb.append("    monitorName: ").append(toIndentedString(monitorName)).append("\n");
    sb.append("    monitorNotes: ").append(toIndentedString(monitorNotes)).append("\n");
    sb.append("    publicDescription: ").append(toIndentedString(publicDescription)).append("\n");
    sb.append("    startMonitorAt: ").append(toIndentedString(startMonitorAt)).append("\n");
    sb.append("    timezoneCode: ").append(toIndentedString(timezoneCode)).append("\n");
    sb.append("    webResponseSecondsLimit: ").append(toIndentedString(webResponseSecondsLimit)).append("\n");
    sb.append("    webResponseUrl: ").append(toIndentedString(webResponseUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alertPayloadExtended");
    openapiFields.add("alertPayloadShort");
    openapiFields.add("alertServices");
    openapiFields.add("allowUnauthenticatedPings");
    openapiFields.add("contentCheckMustNotExist");
    openapiFields.add("contentCheckText");
    openapiFields.add("contentCheckUrl");
    openapiFields.add("contentCheckXpathFilter");
    openapiFields.add("dataSegmentCode");
    openapiFields.add("graceSeconds");
    openapiFields.add("intervalDays");
    openapiFields.add("intervalHours");
    openapiFields.add("intervalMinutes");
    openapiFields.add("intervalMonths");
    openapiFields.add("intervalSeconds");
    openapiFields.add("intervalYears");
    openapiFields.add("isMonitorPaused");
    openapiFields.add("monitorName");
    openapiFields.add("monitorNotes");
    openapiFields.add("publicDescription");
    openapiFields.add("startMonitorAt");
    openapiFields.add("timezoneCode");
    openapiFields.add("webResponseSecondsLimit");
    openapiFields.add("webResponseUrl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("monitorName");
    openapiRequiredFields.add("timezoneCode");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MonitorPatch
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MonitorPatch.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MonitorPatch is not found in the empty JSON string", MonitorPatch.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MonitorPatch.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MonitorPatch` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MonitorPatch.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("alertPayloadExtended") != null && !jsonObj.get("alertPayloadExtended").isJsonNull()) && !jsonObj.get("alertPayloadExtended").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertPayloadExtended` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alertPayloadExtended").toString()));
      }
      if ((jsonObj.get("alertPayloadShort") != null && !jsonObj.get("alertPayloadShort").isJsonNull()) && !jsonObj.get("alertPayloadShort").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertPayloadShort` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alertPayloadShort").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("alertServices") != null && !jsonObj.get("alertServices").isJsonNull() && !jsonObj.get("alertServices").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertServices` to be an array in the JSON string but got `%s`", jsonObj.get("alertServices").toString()));
      }
      if ((jsonObj.get("contentCheckText") != null && !jsonObj.get("contentCheckText").isJsonNull()) && !jsonObj.get("contentCheckText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentCheckText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentCheckText").toString()));
      }
      if ((jsonObj.get("contentCheckUrl") != null && !jsonObj.get("contentCheckUrl").isJsonNull()) && !jsonObj.get("contentCheckUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentCheckUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentCheckUrl").toString()));
      }
      if ((jsonObj.get("contentCheckXpathFilter") != null && !jsonObj.get("contentCheckXpathFilter").isJsonNull()) && !jsonObj.get("contentCheckXpathFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentCheckXpathFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentCheckXpathFilter").toString()));
      }
      if ((jsonObj.get("dataSegmentCode") != null && !jsonObj.get("dataSegmentCode").isJsonNull()) && !jsonObj.get("dataSegmentCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataSegmentCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataSegmentCode").toString()));
      }
      if ((jsonObj.get("monitorName") != null && !jsonObj.get("monitorName").isJsonNull()) && !jsonObj.get("monitorName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `monitorName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("monitorName").toString()));
      }
      if ((jsonObj.get("monitorNotes") != null && !jsonObj.get("monitorNotes").isJsonNull()) && !jsonObj.get("monitorNotes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `monitorNotes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("monitorNotes").toString()));
      }
      if ((jsonObj.get("publicDescription") != null && !jsonObj.get("publicDescription").isJsonNull()) && !jsonObj.get("publicDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publicDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publicDescription").toString()));
      }
      if (!jsonObj.get("timezoneCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezoneCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezoneCode").toString()));
      }
      if ((jsonObj.get("webResponseUrl") != null && !jsonObj.get("webResponseUrl").isJsonNull()) && !jsonObj.get("webResponseUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webResponseUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webResponseUrl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MonitorPatch.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MonitorPatch' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MonitorPatch> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MonitorPatch.class));

       return (TypeAdapter<T>) new TypeAdapter<MonitorPatch>() {
           @Override
           public void write(JsonWriter out, MonitorPatch value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MonitorPatch read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MonitorPatch given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MonitorPatch
   * @throws IOException if the JSON string is invalid with respect to MonitorPatch
   */
  public static MonitorPatch fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MonitorPatch.class);
  }

  /**
   * Convert an instance of MonitorPatch to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

