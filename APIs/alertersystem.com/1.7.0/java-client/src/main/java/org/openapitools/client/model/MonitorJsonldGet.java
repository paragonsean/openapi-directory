/*
 * Alerter System API
 * <p>This is the <a href=\"/\">Alerter System</a> API playground. More documentation is available at the <a href=\"/help/developers/\">API Help Center</a>.</p><p>The \"Available Authorizations\" in the Authorize popup only applies to this playground web interface. Other <a href=\"/help/developers/authorization/\">authorizations</a> are available for the actual API.</p>
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import org.openapitools.client.model.AlertLogJsonldGetContext;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The Monitor resource is a collection of services that monitor the presence and/or absence of pings, and follow sets of rules to dispatch or not dispatch alerts.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:22:03.392245-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MonitorJsonldGet {
  public static final String SERIALIZED_NAME_AT_CONTEXT = "@context";
  @SerializedName(SERIALIZED_NAME_AT_CONTEXT)
  private AlertLogJsonldGetContext atContext;

  public static final String SERIALIZED_NAME_AT_ID = "@id";
  @SerializedName(SERIALIZED_NAME_AT_ID)
  private String atId;

  public static final String SERIALIZED_NAME_AT_TYPE = "@type";
  @SerializedName(SERIALIZED_NAME_AT_TYPE)
  private String atType;

  public static final String SERIALIZED_NAME_ALERT_PAYLOAD_EXTENDED = "alertPayloadExtended";
  @SerializedName(SERIALIZED_NAME_ALERT_PAYLOAD_EXTENDED)
  private String alertPayloadExtended;

  public static final String SERIALIZED_NAME_ALERT_PAYLOAD_SHORT = "alertPayloadShort";
  @SerializedName(SERIALIZED_NAME_ALERT_PAYLOAD_SHORT)
  private String alertPayloadShort;

  public static final String SERIALIZED_NAME_ALERT_SERVICES = "alertServices";
  @SerializedName(SERIALIZED_NAME_ALERT_SERVICES)
  private List<String> alertServices = new ArrayList<>();

  public static final String SERIALIZED_NAME_ALLOW_UNAUTHENTICATED_PINGS = "allowUnauthenticatedPings";
  @SerializedName(SERIALIZED_NAME_ALLOW_UNAUTHENTICATED_PINGS)
  private Boolean allowUnauthenticatedPings;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_MUST_NOT_EXIST = "contentCheckMustNotExist";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_MUST_NOT_EXIST)
  private Boolean contentCheckMustNotExist;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_TEXT = "contentCheckText";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_TEXT)
  private String contentCheckText;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_URL = "contentCheckUrl";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_URL)
  private URI contentCheckUrl;

  public static final String SERIALIZED_NAME_CONTENT_CHECK_XPATH_FILTER = "contentCheckXpathFilter";
  @SerializedName(SERIALIZED_NAME_CONTENT_CHECK_XPATH_FILTER)
  private String contentCheckXpathFilter;

  public static final String SERIALIZED_NAME_CREATED_AT = "createdAt";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DATA_SEGMENT_CODE = "dataSegmentCode";
  @SerializedName(SERIALIZED_NAME_DATA_SEGMENT_CODE)
  private String dataSegmentCode;

  public static final String SERIALIZED_NAME_GRACE_SECONDS = "graceSeconds";
  @SerializedName(SERIALIZED_NAME_GRACE_SECONDS)
  private Integer graceSeconds;

  public static final String SERIALIZED_NAME_HUMANIZED_INTERVAL = "humanizedInterval";
  @SerializedName(SERIALIZED_NAME_HUMANIZED_INTERVAL)
  private String humanizedInterval;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public static final String SERIALIZED_NAME_INTERNAL_MONITOR_NAME = "internalMonitorName";
  @SerializedName(SERIALIZED_NAME_INTERNAL_MONITOR_NAME)
  private String internalMonitorName;

  public static final String SERIALIZED_NAME_INTERVAL_DAYS = "intervalDays";
  @SerializedName(SERIALIZED_NAME_INTERVAL_DAYS)
  private Integer intervalDays;

  public static final String SERIALIZED_NAME_INTERVAL_HOURS = "intervalHours";
  @SerializedName(SERIALIZED_NAME_INTERVAL_HOURS)
  private Integer intervalHours;

  public static final String SERIALIZED_NAME_INTERVAL_MINUTES = "intervalMinutes";
  @SerializedName(SERIALIZED_NAME_INTERVAL_MINUTES)
  private Integer intervalMinutes;

  public static final String SERIALIZED_NAME_INTERVAL_MONTHS = "intervalMonths";
  @SerializedName(SERIALIZED_NAME_INTERVAL_MONTHS)
  private Integer intervalMonths;

  public static final String SERIALIZED_NAME_INTERVAL_SECONDS = "intervalSeconds";
  @SerializedName(SERIALIZED_NAME_INTERVAL_SECONDS)
  private Integer intervalSeconds;

  public static final String SERIALIZED_NAME_INTERVAL_YEARS = "intervalYears";
  @SerializedName(SERIALIZED_NAME_INTERVAL_YEARS)
  private Integer intervalYears;

  public static final String SERIALIZED_NAME_IS_MONITOR_PAUSED = "isMonitorPaused";
  @SerializedName(SERIALIZED_NAME_IS_MONITOR_PAUSED)
  private Boolean isMonitorPaused;

  public static final String SERIALIZED_NAME_LAST_PING_AT = "lastPingAt";
  @SerializedName(SERIALIZED_NAME_LAST_PING_AT)
  private OffsetDateTime lastPingAt;

  public static final String SERIALIZED_NAME_MONITOR_NAME = "monitorName";
  @SerializedName(SERIALIZED_NAME_MONITOR_NAME)
  private String monitorName;

  public static final String SERIALIZED_NAME_MONITOR_NOTES = "monitorNotes";
  @SerializedName(SERIALIZED_NAME_MONITOR_NOTES)
  private String monitorNotes;

  public static final String SERIALIZED_NAME_MONITOR_STATUS_CODE = "monitorStatusCode";
  @SerializedName(SERIALIZED_NAME_MONITOR_STATUS_CODE)
  private String monitorStatusCode;

  public static final String SERIALIZED_NAME_MONITOR_TYPE_CODE = "monitorTypeCode";
  @SerializedName(SERIALIZED_NAME_MONITOR_TYPE_CODE)
  private String monitorTypeCode;

  public static final String SERIALIZED_NAME_NEXT_PING_AT = "nextPingAt";
  @SerializedName(SERIALIZED_NAME_NEXT_PING_AT)
  private OffsetDateTime nextPingAt;

  public static final String SERIALIZED_NAME_PARTITION = "partition";
  @SerializedName(SERIALIZED_NAME_PARTITION)
  private String partition;

  public static final String SERIALIZED_NAME_PING_SECRET = "pingSecret";
  @SerializedName(SERIALIZED_NAME_PING_SECRET)
  private String pingSecret;

  public static final String SERIALIZED_NAME_PUBLIC_DESCRIPTION = "publicDescription";
  @SerializedName(SERIALIZED_NAME_PUBLIC_DESCRIPTION)
  private String publicDescription;

  public static final String SERIALIZED_NAME_RESOURCE_OWNER = "resourceOwner";
  @SerializedName(SERIALIZED_NAME_RESOURCE_OWNER)
  private String resourceOwner;

  public static final String SERIALIZED_NAME_START_MONITOR_AT = "startMonitorAt";
  @SerializedName(SERIALIZED_NAME_START_MONITOR_AT)
  private OffsetDateTime startMonitorAt;

  public static final String SERIALIZED_NAME_START_MONITOR_AT_UTC = "startMonitorAtUtc";
  @SerializedName(SERIALIZED_NAME_START_MONITOR_AT_UTC)
  private OffsetDateTime startMonitorAtUtc;

  public static final String SERIALIZED_NAME_SYSTEM_MESSAGES = "systemMessages";
  @SerializedName(SERIALIZED_NAME_SYSTEM_MESSAGES)
  private List<String> systemMessages = new ArrayList<>();

  public static final String SERIALIZED_NAME_TIMEZONE_CODE = "timezoneCode";
  @SerializedName(SERIALIZED_NAME_TIMEZONE_CODE)
  private String timezoneCode;

  public static final String SERIALIZED_NAME_WEB_RESPONSE_SECONDS_LIMIT = "webResponseSecondsLimit";
  @SerializedName(SERIALIZED_NAME_WEB_RESPONSE_SECONDS_LIMIT)
  private Integer webResponseSecondsLimit;

  public static final String SERIALIZED_NAME_WEB_RESPONSE_URL = "webResponseUrl";
  @SerializedName(SERIALIZED_NAME_WEB_RESPONSE_URL)
  private URI webResponseUrl;

  public MonitorJsonldGet() {
  }

  public MonitorJsonldGet(
     String atId, 
     String atType, 
     OffsetDateTime createdAt, 
     String humanizedInterval, 
     UUID id
  ) {
    this();
    this.atId = atId;
    this.atType = atType;
    this.createdAt = createdAt;
    this.humanizedInterval = humanizedInterval;
    this.id = id;
  }

  public MonitorJsonldGet atContext(AlertLogJsonldGetContext atContext) {
    this.atContext = atContext;
    return this;
  }

  /**
   * Get atContext
   * @return atContext
   */
  @javax.annotation.Nullable
  public AlertLogJsonldGetContext getAtContext() {
    return atContext;
  }

  public void setAtContext(AlertLogJsonldGetContext atContext) {
    this.atContext = atContext;
  }


  /**
   * Get atId
   * @return atId
   */
  @javax.annotation.Nullable
  public String getAtId() {
    return atId;
  }



  /**
   * Get atType
   * @return atType
   */
  @javax.annotation.Nullable
  public String getAtType() {
    return atType;
  }



  public MonitorJsonldGet alertPayloadExtended(String alertPayloadExtended) {
    this.alertPayloadExtended = alertPayloadExtended;
    return this;
  }

  /**
   * Payload that must be sent in the body of each alert when you use your own email or webhook alert services. This is the body for email alerts and the request body for webhook alerts. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 2 MB characters.
   * @return alertPayloadExtended
   */
  @javax.annotation.Nullable
  public String getAlertPayloadExtended() {
    return alertPayloadExtended;
  }

  public void setAlertPayloadExtended(String alertPayloadExtended) {
    this.alertPayloadExtended = alertPayloadExtended;
  }


  public MonitorJsonldGet alertPayloadShort(String alertPayloadShort) {
    this.alertPayloadShort = alertPayloadShort;
    return this;
  }

  /**
   * Payload that must be sent in the body of each alert when you use your own short message alert services. This also serves as the subject for email alerts. Not used for webhooks. This text is not sent when using the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. Max 100 characters.
   * @return alertPayloadShort
   */
  @javax.annotation.Nullable
  public String getAlertPayloadShort() {
    return alertPayloadShort;
  }

  public void setAlertPayloadShort(String alertPayloadShort) {
    this.alertPayloadShort = alertPayloadShort;
  }


  public MonitorJsonldGet alertServices(List<String> alertServices) {
    this.alertServices = alertServices;
    return this;
  }

  public MonitorJsonldGet addAlertServicesItem(String alertServicesItem) {
    if (this.alertServices == null) {
      this.alertServices = new ArrayList<>();
    }
    this.alertServices.add(alertServicesItem);
    return this;
  }

  /**
   * The alert services that are related to this resource.
   * @return alertServices
   */
  @javax.annotation.Nullable
  public List<String> getAlertServices() {
    return alertServices;
  }

  public void setAlertServices(List<String> alertServices) {
    this.alertServices = alertServices;
  }


  public MonitorJsonldGet allowUnauthenticatedPings(Boolean allowUnauthenticatedPings) {
    this.allowUnauthenticatedPings = allowUnauthenticatedPings;
    return this;
  }

  /**
   * Indicates that the monitor will accept pings that are not OAuth authenticated.
   * @return allowUnauthenticatedPings
   */
  @javax.annotation.Nullable
  public Boolean getAllowUnauthenticatedPings() {
    return allowUnauthenticatedPings;
  }

  public void setAllowUnauthenticatedPings(Boolean allowUnauthenticatedPings) {
    this.allowUnauthenticatedPings = allowUnauthenticatedPings;
  }


  public MonitorJsonldGet contentCheckMustNotExist(Boolean contentCheckMustNotExist) {
    this.contentCheckMustNotExist = contentCheckMustNotExist;
    return this;
  }

  /**
   * Indicates that the Web Content monitor must verify the absence of the text or the Xpath node, and dispatch an alert if it is present. The default behavior is to verify the presence of the text or the Xpath node, and dispatch an alert if it is absent.
   * @return contentCheckMustNotExist
   */
  @javax.annotation.Nullable
  public Boolean getContentCheckMustNotExist() {
    return contentCheckMustNotExist;
  }

  public void setContentCheckMustNotExist(Boolean contentCheckMustNotExist) {
    this.contentCheckMustNotExist = contentCheckMustNotExist;
  }


  public MonitorJsonldGet contentCheckText(String contentCheckText) {
    this.contentCheckText = contentCheckText;
    return this;
  }

  /**
   * The text (case-insensitive) that must or must not be present at the contentCheckUrl. If contentCheckXpathFilter is supplied, then the only the text within that nodes is evaluated, otherwise text on the entire web page is evaluated.
   * @return contentCheckText
   */
  @javax.annotation.Nullable
  public String getContentCheckText() {
    return contentCheckText;
  }

  public void setContentCheckText(String contentCheckText) {
    this.contentCheckText = contentCheckText;
  }


  public MonitorJsonldGet contentCheckUrl(URI contentCheckUrl) {
    this.contentCheckUrl = contentCheckUrl;
    return this;
  }

  /**
   * The URL that the Web Content monitor type must evaluate for the specified conditions.
   * @return contentCheckUrl
   */
  @javax.annotation.Nullable
  public URI getContentCheckUrl() {
    return contentCheckUrl;
  }

  public void setContentCheckUrl(URI contentCheckUrl) {
    this.contentCheckUrl = contentCheckUrl;
  }


  public MonitorJsonldGet contentCheckXpathFilter(String contentCheckXpathFilter) {
    this.contentCheckXpathFilter = contentCheckXpathFilter;
    return this;
  }

  /**
   * The Xpath filter (&lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/XPath\&quot;&gt;Xpath&lt;/a&gt;, &lt;a href&#x3D;\&quot;https://devhints.io/xpath\&quot;&gt;Xpath Cheatsheet&lt;/a&gt;) that selects a specific node in the HTML of the target web page. If contentCheckText is supplied, then only the text within the selected node is evaluated. If contentCheckText is left empty, then the presence or the absence of the selected node is evaluated.
   * @return contentCheckXpathFilter
   */
  @javax.annotation.Nullable
  public String getContentCheckXpathFilter() {
    return contentCheckXpathFilter;
  }

  public void setContentCheckXpathFilter(String contentCheckXpathFilter) {
    this.contentCheckXpathFilter = contentCheckXpathFilter;
  }


  /**
   * When the resource instance was created. This date-time is in the UTC timezone.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public MonitorJsonldGet dataSegmentCode(String dataSegmentCode) {
    this.dataSegmentCode = dataSegmentCode;
    return this;
  }

  /**
   * User-provided string on which to segment and filter data. Max 50 characters.
   * @return dataSegmentCode
   */
  @javax.annotation.Nullable
  public String getDataSegmentCode() {
    return dataSegmentCode;
  }

  public void setDataSegmentCode(String dataSegmentCode) {
    this.dataSegmentCode = dataSegmentCode;
  }


  public MonitorJsonldGet graceSeconds(Integer graceSeconds) {
    this.graceSeconds = graceSeconds;
    return this;
  }

  /**
   * The number of grace seconds after expiry of the time when the next ping was expected, before raising an alert. The number of grace seconds to allow before classifying a Measured Monitor task duration as an anomaly.
   * @return graceSeconds
   */
  @javax.annotation.Nullable
  public Integer getGraceSeconds() {
    return graceSeconds;
  }

  public void setGraceSeconds(Integer graceSeconds) {
    this.graceSeconds = graceSeconds;
  }


  /**
   * The expected ping / run interval of this monitor in human readable form.
   * @return humanizedInterval
   */
  @javax.annotation.Nullable
  public String getHumanizedInterval() {
    return humanizedInterval;
  }



  /**
   * The unique identifier of the resource instance.
   * @return id
   */
  @javax.annotation.Nullable
  public UUID getId() {
    return id;
  }



  public MonitorJsonldGet internalMonitorName(String internalMonitorName) {
    this.internalMonitorName = internalMonitorName;
    return this;
  }

  /**
   * The internal name of the monitor. This name is used in alerts when you use the built-in alert services. Sending user-supplied text via our own email server is too big a risk to our email reputation. The monitorName field is used when you use your own alert services.
   * @return internalMonitorName
   */
  @javax.annotation.Nullable
  public String getInternalMonitorName() {
    return internalMonitorName;
  }

  public void setInternalMonitorName(String internalMonitorName) {
    this.internalMonitorName = internalMonitorName;
  }


  public MonitorJsonldGet intervalDays(Integer intervalDays) {
    this.intervalDays = intervalDays;
    return this;
  }

  /**
   * The number of days in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalDays
   */
  @javax.annotation.Nullable
  public Integer getIntervalDays() {
    return intervalDays;
  }

  public void setIntervalDays(Integer intervalDays) {
    this.intervalDays = intervalDays;
  }


  public MonitorJsonldGet intervalHours(Integer intervalHours) {
    this.intervalHours = intervalHours;
    return this;
  }

  /**
   * The number of hours in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalHours
   */
  @javax.annotation.Nullable
  public Integer getIntervalHours() {
    return intervalHours;
  }

  public void setIntervalHours(Integer intervalHours) {
    this.intervalHours = intervalHours;
  }


  public MonitorJsonldGet intervalMinutes(Integer intervalMinutes) {
    this.intervalMinutes = intervalMinutes;
    return this;
  }

  /**
   * The number of minutes in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalMinutes
   */
  @javax.annotation.Nullable
  public Integer getIntervalMinutes() {
    return intervalMinutes;
  }

  public void setIntervalMinutes(Integer intervalMinutes) {
    this.intervalMinutes = intervalMinutes;
  }


  public MonitorJsonldGet intervalMonths(Integer intervalMonths) {
    this.intervalMonths = intervalMonths;
    return this;
  }

  /**
   * The number of months in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalMonths
   */
  @javax.annotation.Nullable
  public Integer getIntervalMonths() {
    return intervalMonths;
  }

  public void setIntervalMonths(Integer intervalMonths) {
    this.intervalMonths = intervalMonths;
  }


  public MonitorJsonldGet intervalSeconds(Integer intervalSeconds) {
    this.intervalSeconds = intervalSeconds;
    return this;
  }

  /**
   * The number of seconds in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalSeconds
   */
  @javax.annotation.Nullable
  public Integer getIntervalSeconds() {
    return intervalSeconds;
  }

  public void setIntervalSeconds(Integer intervalSeconds) {
    this.intervalSeconds = intervalSeconds;
  }


  public MonitorJsonldGet intervalYears(Integer intervalYears) {
    this.intervalYears = intervalYears;
    return this;
  }

  /**
   * The number of years in the expected ping / run / measured / scheduled interval. Can be left blank. Can be specified together with any combination of the other interval fields.
   * minimum: 0
   * @return intervalYears
   */
  @javax.annotation.Nullable
  public Integer getIntervalYears() {
    return intervalYears;
  }

  public void setIntervalYears(Integer intervalYears) {
    this.intervalYears = intervalYears;
  }


  public MonitorJsonldGet isMonitorPaused(Boolean isMonitorPaused) {
    this.isMonitorPaused = isMonitorPaused;
    return this;
  }

  /**
   * Indicates that the monitor is paused and will not send alerts.
   * @return isMonitorPaused
   */
  @javax.annotation.Nullable
  public Boolean getIsMonitorPaused() {
    return isMonitorPaused;
  }

  public void setIsMonitorPaused(Boolean isMonitorPaused) {
    this.isMonitorPaused = isMonitorPaused;
  }


  public MonitorJsonldGet lastPingAt(OffsetDateTime lastPingAt) {
    this.lastPingAt = lastPingAt;
    return this;
  }

  /**
   * When the last ping was received. This date-time is in the UTC timezone.
   * @return lastPingAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastPingAt() {
    return lastPingAt;
  }

  public void setLastPingAt(OffsetDateTime lastPingAt) {
    this.lastPingAt = lastPingAt;
  }


  public MonitorJsonldGet monitorName(String monitorName) {
    this.monitorName = monitorName;
    return this;
  }

  /**
   * The name of the monitor. Max 255 characters.
   * @return monitorName
   */
  @javax.annotation.Nullable
  public String getMonitorName() {
    return monitorName;
  }

  public void setMonitorName(String monitorName) {
    this.monitorName = monitorName;
  }


  public MonitorJsonldGet monitorNotes(String monitorNotes) {
    this.monitorNotes = monitorNotes;
    return this;
  }

  /**
   * Notes about the monitor. Max 10,000 characters. Formatting using Markdown is allowed. HTML will be removed.
   * @return monitorNotes
   */
  @javax.annotation.Nullable
  public String getMonitorNotes() {
    return monitorNotes;
  }

  public void setMonitorNotes(String monitorNotes) {
    this.monitorNotes = monitorNotes;
  }


  public MonitorJsonldGet monitorStatusCode(String monitorStatusCode) {
    this.monitorStatusCode = monitorStatusCode;
    return this;
  }

  /**
   * The status of the monitor.
   * @return monitorStatusCode
   */
  @javax.annotation.Nullable
  public String getMonitorStatusCode() {
    return monitorStatusCode;
  }

  public void setMonitorStatusCode(String monitorStatusCode) {
    this.monitorStatusCode = monitorStatusCode;
  }


  public MonitorJsonldGet monitorTypeCode(String monitorTypeCode) {
    this.monitorTypeCode = monitorTypeCode;
    return this;
  }

  /**
   * The type of the monitor.
   * @return monitorTypeCode
   */
  @javax.annotation.Nullable
  public String getMonitorTypeCode() {
    return monitorTypeCode;
  }

  public void setMonitorTypeCode(String monitorTypeCode) {
    this.monitorTypeCode = monitorTypeCode;
  }


  public MonitorJsonldGet nextPingAt(OffsetDateTime nextPingAt) {
    this.nextPingAt = nextPingAt;
    return this;
  }

  /**
   * When the next ping is expected. This date-time is in the UTC timezone.
   * @return nextPingAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getNextPingAt() {
    return nextPingAt;
  }

  public void setNextPingAt(OffsetDateTime nextPingAt) {
    this.nextPingAt = nextPingAt;
  }


  public MonitorJsonldGet partition(String partition) {
    this.partition = partition;
    return this;
  }

  /**
   * The partition that contains this resource instance. The resource cannot be moved to another partition.
   * @return partition
   */
  @javax.annotation.Nonnull
  public String getPartition() {
    return partition;
  }

  public void setPartition(String partition) {
    this.partition = partition;
  }


  public MonitorJsonldGet pingSecret(String pingSecret) {
    this.pingSecret = pingSecret;
    return this;
  }

  /**
   * A secret key that can be sent in the X_PING_SECRET HTTP request header of a ping for additional security. Sending the secret is recommended for unauthenticated ping requests. It is redundant for OAuth authenticated ping requests that have the \&quot;Authorization: Bearer\&quot; header.
   * @return pingSecret
   */
  @javax.annotation.Nullable
  public String getPingSecret() {
    return pingSecret;
  }

  public void setPingSecret(String pingSecret) {
    this.pingSecret = pingSecret;
  }


  public MonitorJsonldGet publicDescription(String publicDescription) {
    this.publicDescription = publicDescription;
    return this;
  }

  /**
   * A text description of the monitor that is accessible to unauthenticated users that receive an alert from the monitor. Formatting using Markdown is allowed. HTML will be removed.
   * @return publicDescription
   */
  @javax.annotation.Nullable
  public String getPublicDescription() {
    return publicDescription;
  }

  public void setPublicDescription(String publicDescription) {
    this.publicDescription = publicDescription;
  }


  public MonitorJsonldGet resourceOwner(String resourceOwner) {
    this.resourceOwner = resourceOwner;
    return this;
  }

  /**
   * The name of the person who owns this resource.
   * @return resourceOwner
   */
  @javax.annotation.Nullable
  public String getResourceOwner() {
    return resourceOwner;
  }

  public void setResourceOwner(String resourceOwner) {
    this.resourceOwner = resourceOwner;
  }


  public MonitorJsonldGet startMonitorAt(OffsetDateTime startMonitorAt) {
    this.startMonitorAt = startMonitorAt;
    return this;
  }

  /**
   * When to start the Regular Interval type monitor or Heartbeat type monitor, or when to send the first alert of the Scheduled Repeatable Alert monitor. Cannot be blank for a Regular Interval, Heartbeat, or Scheduled Repeatable Alert type monitor, must be blank for other monitors types. This date-time is always interpreted to be in the timezone of the monitor. Any UTC offset is ignored.
   * @return startMonitorAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartMonitorAt() {
    return startMonitorAt;
  }

  public void setStartMonitorAt(OffsetDateTime startMonitorAt) {
    this.startMonitorAt = startMonitorAt;
  }


  public MonitorJsonldGet startMonitorAtUtc(OffsetDateTime startMonitorAtUtc) {
    this.startMonitorAtUtc = startMonitorAtUtc;
    return this;
  }

  /**
   * The startMonitorAt date-time in the UTC timezone.
   * @return startMonitorAtUtc
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartMonitorAtUtc() {
    return startMonitorAtUtc;
  }

  public void setStartMonitorAtUtc(OffsetDateTime startMonitorAtUtc) {
    this.startMonitorAtUtc = startMonitorAtUtc;
  }


  public MonitorJsonldGet systemMessages(List<String> systemMessages) {
    this.systemMessages = systemMessages;
    return this;
  }

  public MonitorJsonldGet addSystemMessagesItem(String systemMessagesItem) {
    if (this.systemMessages == null) {
      this.systemMessages = new ArrayList<>();
    }
    this.systemMessages.add(systemMessagesItem);
    return this;
  }

  /**
   * Service notes regarding the resource.
   * @return systemMessages
   */
  @javax.annotation.Nullable
  public List<String> getSystemMessages() {
    return systemMessages;
  }

  public void setSystemMessages(List<String> systemMessages) {
    this.systemMessages = systemMessages;
  }


  public MonitorJsonldGet timezoneCode(String timezoneCode) {
    this.timezoneCode = timezoneCode;
    return this;
  }

  /**
   * The timezone of the monitor. Dates and times in alerts and reports will be in this time zone.
   * @return timezoneCode
   */
  @javax.annotation.Nonnull
  public String getTimezoneCode() {
    return timezoneCode;
  }

  public void setTimezoneCode(String timezoneCode) {
    this.timezoneCode = timezoneCode;
  }


  public MonitorJsonldGet webResponseSecondsLimit(Integer webResponseSecondsLimit) {
    this.webResponseSecondsLimit = webResponseSecondsLimit;
    return this;
  }

  /**
   * The time in seconds that the Web Response monitor type must allow for the web page to respond.
   * minimum: 0
   * @return webResponseSecondsLimit
   */
  @javax.annotation.Nullable
  public Integer getWebResponseSecondsLimit() {
    return webResponseSecondsLimit;
  }

  public void setWebResponseSecondsLimit(Integer webResponseSecondsLimit) {
    this.webResponseSecondsLimit = webResponseSecondsLimit;
  }


  public MonitorJsonldGet webResponseUrl(URI webResponseUrl) {
    this.webResponseUrl = webResponseUrl;
    return this;
  }

  /**
   * The URL that the Web Response monitor type must evaluate for the specified conditions.
   * @return webResponseUrl
   */
  @javax.annotation.Nullable
  public URI getWebResponseUrl() {
    return webResponseUrl;
  }

  public void setWebResponseUrl(URI webResponseUrl) {
    this.webResponseUrl = webResponseUrl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MonitorJsonldGet monitorJsonldGet = (MonitorJsonldGet) o;
    return Objects.equals(this.atContext, monitorJsonldGet.atContext) &&
        Objects.equals(this.atId, monitorJsonldGet.atId) &&
        Objects.equals(this.atType, monitorJsonldGet.atType) &&
        Objects.equals(this.alertPayloadExtended, monitorJsonldGet.alertPayloadExtended) &&
        Objects.equals(this.alertPayloadShort, monitorJsonldGet.alertPayloadShort) &&
        Objects.equals(this.alertServices, monitorJsonldGet.alertServices) &&
        Objects.equals(this.allowUnauthenticatedPings, monitorJsonldGet.allowUnauthenticatedPings) &&
        Objects.equals(this.contentCheckMustNotExist, monitorJsonldGet.contentCheckMustNotExist) &&
        Objects.equals(this.contentCheckText, monitorJsonldGet.contentCheckText) &&
        Objects.equals(this.contentCheckUrl, monitorJsonldGet.contentCheckUrl) &&
        Objects.equals(this.contentCheckXpathFilter, monitorJsonldGet.contentCheckXpathFilter) &&
        Objects.equals(this.createdAt, monitorJsonldGet.createdAt) &&
        Objects.equals(this.dataSegmentCode, monitorJsonldGet.dataSegmentCode) &&
        Objects.equals(this.graceSeconds, monitorJsonldGet.graceSeconds) &&
        Objects.equals(this.humanizedInterval, monitorJsonldGet.humanizedInterval) &&
        Objects.equals(this.id, monitorJsonldGet.id) &&
        Objects.equals(this.internalMonitorName, monitorJsonldGet.internalMonitorName) &&
        Objects.equals(this.intervalDays, monitorJsonldGet.intervalDays) &&
        Objects.equals(this.intervalHours, monitorJsonldGet.intervalHours) &&
        Objects.equals(this.intervalMinutes, monitorJsonldGet.intervalMinutes) &&
        Objects.equals(this.intervalMonths, monitorJsonldGet.intervalMonths) &&
        Objects.equals(this.intervalSeconds, monitorJsonldGet.intervalSeconds) &&
        Objects.equals(this.intervalYears, monitorJsonldGet.intervalYears) &&
        Objects.equals(this.isMonitorPaused, monitorJsonldGet.isMonitorPaused) &&
        Objects.equals(this.lastPingAt, monitorJsonldGet.lastPingAt) &&
        Objects.equals(this.monitorName, monitorJsonldGet.monitorName) &&
        Objects.equals(this.monitorNotes, monitorJsonldGet.monitorNotes) &&
        Objects.equals(this.monitorStatusCode, monitorJsonldGet.monitorStatusCode) &&
        Objects.equals(this.monitorTypeCode, monitorJsonldGet.monitorTypeCode) &&
        Objects.equals(this.nextPingAt, monitorJsonldGet.nextPingAt) &&
        Objects.equals(this.partition, monitorJsonldGet.partition) &&
        Objects.equals(this.pingSecret, monitorJsonldGet.pingSecret) &&
        Objects.equals(this.publicDescription, monitorJsonldGet.publicDescription) &&
        Objects.equals(this.resourceOwner, monitorJsonldGet.resourceOwner) &&
        Objects.equals(this.startMonitorAt, monitorJsonldGet.startMonitorAt) &&
        Objects.equals(this.startMonitorAtUtc, monitorJsonldGet.startMonitorAtUtc) &&
        Objects.equals(this.systemMessages, monitorJsonldGet.systemMessages) &&
        Objects.equals(this.timezoneCode, monitorJsonldGet.timezoneCode) &&
        Objects.equals(this.webResponseSecondsLimit, monitorJsonldGet.webResponseSecondsLimit) &&
        Objects.equals(this.webResponseUrl, monitorJsonldGet.webResponseUrl);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(atContext, atId, atType, alertPayloadExtended, alertPayloadShort, alertServices, allowUnauthenticatedPings, contentCheckMustNotExist, contentCheckText, contentCheckUrl, contentCheckXpathFilter, createdAt, dataSegmentCode, graceSeconds, humanizedInterval, id, internalMonitorName, intervalDays, intervalHours, intervalMinutes, intervalMonths, intervalSeconds, intervalYears, isMonitorPaused, lastPingAt, monitorName, monitorNotes, monitorStatusCode, monitorTypeCode, nextPingAt, partition, pingSecret, publicDescription, resourceOwner, startMonitorAt, startMonitorAtUtc, systemMessages, timezoneCode, webResponseSecondsLimit, webResponseUrl);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MonitorJsonldGet {\n");
    sb.append("    atContext: ").append(toIndentedString(atContext)).append("\n");
    sb.append("    atId: ").append(toIndentedString(atId)).append("\n");
    sb.append("    atType: ").append(toIndentedString(atType)).append("\n");
    sb.append("    alertPayloadExtended: ").append(toIndentedString(alertPayloadExtended)).append("\n");
    sb.append("    alertPayloadShort: ").append(toIndentedString(alertPayloadShort)).append("\n");
    sb.append("    alertServices: ").append(toIndentedString(alertServices)).append("\n");
    sb.append("    allowUnauthenticatedPings: ").append(toIndentedString(allowUnauthenticatedPings)).append("\n");
    sb.append("    contentCheckMustNotExist: ").append(toIndentedString(contentCheckMustNotExist)).append("\n");
    sb.append("    contentCheckText: ").append(toIndentedString(contentCheckText)).append("\n");
    sb.append("    contentCheckUrl: ").append(toIndentedString(contentCheckUrl)).append("\n");
    sb.append("    contentCheckXpathFilter: ").append(toIndentedString(contentCheckXpathFilter)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    dataSegmentCode: ").append(toIndentedString(dataSegmentCode)).append("\n");
    sb.append("    graceSeconds: ").append(toIndentedString(graceSeconds)).append("\n");
    sb.append("    humanizedInterval: ").append(toIndentedString(humanizedInterval)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    internalMonitorName: ").append(toIndentedString(internalMonitorName)).append("\n");
    sb.append("    intervalDays: ").append(toIndentedString(intervalDays)).append("\n");
    sb.append("    intervalHours: ").append(toIndentedString(intervalHours)).append("\n");
    sb.append("    intervalMinutes: ").append(toIndentedString(intervalMinutes)).append("\n");
    sb.append("    intervalMonths: ").append(toIndentedString(intervalMonths)).append("\n");
    sb.append("    intervalSeconds: ").append(toIndentedString(intervalSeconds)).append("\n");
    sb.append("    intervalYears: ").append(toIndentedString(intervalYears)).append("\n");
    sb.append("    isMonitorPaused: ").append(toIndentedString(isMonitorPaused)).append("\n");
    sb.append("    lastPingAt: ").append(toIndentedString(lastPingAt)).append("\n");
    sb.append("    monitorName: ").append(toIndentedString(monitorName)).append("\n");
    sb.append("    monitorNotes: ").append(toIndentedString(monitorNotes)).append("\n");
    sb.append("    monitorStatusCode: ").append(toIndentedString(monitorStatusCode)).append("\n");
    sb.append("    monitorTypeCode: ").append(toIndentedString(monitorTypeCode)).append("\n");
    sb.append("    nextPingAt: ").append(toIndentedString(nextPingAt)).append("\n");
    sb.append("    partition: ").append(toIndentedString(partition)).append("\n");
    sb.append("    pingSecret: ").append(toIndentedString(pingSecret)).append("\n");
    sb.append("    publicDescription: ").append(toIndentedString(publicDescription)).append("\n");
    sb.append("    resourceOwner: ").append(toIndentedString(resourceOwner)).append("\n");
    sb.append("    startMonitorAt: ").append(toIndentedString(startMonitorAt)).append("\n");
    sb.append("    startMonitorAtUtc: ").append(toIndentedString(startMonitorAtUtc)).append("\n");
    sb.append("    systemMessages: ").append(toIndentedString(systemMessages)).append("\n");
    sb.append("    timezoneCode: ").append(toIndentedString(timezoneCode)).append("\n");
    sb.append("    webResponseSecondsLimit: ").append(toIndentedString(webResponseSecondsLimit)).append("\n");
    sb.append("    webResponseUrl: ").append(toIndentedString(webResponseUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("@context");
    openapiFields.add("@id");
    openapiFields.add("@type");
    openapiFields.add("alertPayloadExtended");
    openapiFields.add("alertPayloadShort");
    openapiFields.add("alertServices");
    openapiFields.add("allowUnauthenticatedPings");
    openapiFields.add("contentCheckMustNotExist");
    openapiFields.add("contentCheckText");
    openapiFields.add("contentCheckUrl");
    openapiFields.add("contentCheckXpathFilter");
    openapiFields.add("createdAt");
    openapiFields.add("dataSegmentCode");
    openapiFields.add("graceSeconds");
    openapiFields.add("humanizedInterval");
    openapiFields.add("id");
    openapiFields.add("internalMonitorName");
    openapiFields.add("intervalDays");
    openapiFields.add("intervalHours");
    openapiFields.add("intervalMinutes");
    openapiFields.add("intervalMonths");
    openapiFields.add("intervalSeconds");
    openapiFields.add("intervalYears");
    openapiFields.add("isMonitorPaused");
    openapiFields.add("lastPingAt");
    openapiFields.add("monitorName");
    openapiFields.add("monitorNotes");
    openapiFields.add("monitorStatusCode");
    openapiFields.add("monitorTypeCode");
    openapiFields.add("nextPingAt");
    openapiFields.add("partition");
    openapiFields.add("pingSecret");
    openapiFields.add("publicDescription");
    openapiFields.add("resourceOwner");
    openapiFields.add("startMonitorAt");
    openapiFields.add("startMonitorAtUtc");
    openapiFields.add("systemMessages");
    openapiFields.add("timezoneCode");
    openapiFields.add("webResponseSecondsLimit");
    openapiFields.add("webResponseUrl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("monitorName");
    openapiRequiredFields.add("monitorTypeCode");
    openapiRequiredFields.add("partition");
    openapiRequiredFields.add("timezoneCode");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MonitorJsonldGet
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MonitorJsonldGet.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MonitorJsonldGet is not found in the empty JSON string", MonitorJsonldGet.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MonitorJsonldGet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MonitorJsonldGet` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MonitorJsonldGet.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `@context`
      if (jsonObj.get("@context") != null && !jsonObj.get("@context").isJsonNull()) {
        AlertLogJsonldGetContext.validateJsonElement(jsonObj.get("@context"));
      }
      if ((jsonObj.get("@id") != null && !jsonObj.get("@id").isJsonNull()) && !jsonObj.get("@id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `@id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("@id").toString()));
      }
      if ((jsonObj.get("@type") != null && !jsonObj.get("@type").isJsonNull()) && !jsonObj.get("@type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `@type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("@type").toString()));
      }
      if ((jsonObj.get("alertPayloadExtended") != null && !jsonObj.get("alertPayloadExtended").isJsonNull()) && !jsonObj.get("alertPayloadExtended").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertPayloadExtended` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alertPayloadExtended").toString()));
      }
      if ((jsonObj.get("alertPayloadShort") != null && !jsonObj.get("alertPayloadShort").isJsonNull()) && !jsonObj.get("alertPayloadShort").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertPayloadShort` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alertPayloadShort").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("alertServices") != null && !jsonObj.get("alertServices").isJsonNull() && !jsonObj.get("alertServices").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertServices` to be an array in the JSON string but got `%s`", jsonObj.get("alertServices").toString()));
      }
      if ((jsonObj.get("contentCheckText") != null && !jsonObj.get("contentCheckText").isJsonNull()) && !jsonObj.get("contentCheckText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentCheckText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentCheckText").toString()));
      }
      if ((jsonObj.get("contentCheckUrl") != null && !jsonObj.get("contentCheckUrl").isJsonNull()) && !jsonObj.get("contentCheckUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentCheckUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentCheckUrl").toString()));
      }
      if ((jsonObj.get("contentCheckXpathFilter") != null && !jsonObj.get("contentCheckXpathFilter").isJsonNull()) && !jsonObj.get("contentCheckXpathFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentCheckXpathFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentCheckXpathFilter").toString()));
      }
      if ((jsonObj.get("dataSegmentCode") != null && !jsonObj.get("dataSegmentCode").isJsonNull()) && !jsonObj.get("dataSegmentCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataSegmentCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataSegmentCode").toString()));
      }
      if ((jsonObj.get("humanizedInterval") != null && !jsonObj.get("humanizedInterval").isJsonNull()) && !jsonObj.get("humanizedInterval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `humanizedInterval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("humanizedInterval").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("internalMonitorName") != null && !jsonObj.get("internalMonitorName").isJsonNull()) && !jsonObj.get("internalMonitorName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `internalMonitorName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("internalMonitorName").toString()));
      }
      if ((jsonObj.get("monitorName") != null && !jsonObj.get("monitorName").isJsonNull()) && !jsonObj.get("monitorName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `monitorName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("monitorName").toString()));
      }
      if ((jsonObj.get("monitorNotes") != null && !jsonObj.get("monitorNotes").isJsonNull()) && !jsonObj.get("monitorNotes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `monitorNotes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("monitorNotes").toString()));
      }
      if ((jsonObj.get("monitorStatusCode") != null && !jsonObj.get("monitorStatusCode").isJsonNull()) && !jsonObj.get("monitorStatusCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `monitorStatusCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("monitorStatusCode").toString()));
      }
      if ((jsonObj.get("monitorTypeCode") != null && !jsonObj.get("monitorTypeCode").isJsonNull()) && !jsonObj.get("monitorTypeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `monitorTypeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("monitorTypeCode").toString()));
      }
      if (!jsonObj.get("partition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partition").toString()));
      }
      if ((jsonObj.get("pingSecret") != null && !jsonObj.get("pingSecret").isJsonNull()) && !jsonObj.get("pingSecret").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pingSecret` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pingSecret").toString()));
      }
      if ((jsonObj.get("publicDescription") != null && !jsonObj.get("publicDescription").isJsonNull()) && !jsonObj.get("publicDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publicDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publicDescription").toString()));
      }
      if ((jsonObj.get("resourceOwner") != null && !jsonObj.get("resourceOwner").isJsonNull()) && !jsonObj.get("resourceOwner").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resourceOwner` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resourceOwner").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("systemMessages") != null && !jsonObj.get("systemMessages").isJsonNull() && !jsonObj.get("systemMessages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `systemMessages` to be an array in the JSON string but got `%s`", jsonObj.get("systemMessages").toString()));
      }
      if (!jsonObj.get("timezoneCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezoneCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezoneCode").toString()));
      }
      if ((jsonObj.get("webResponseUrl") != null && !jsonObj.get("webResponseUrl").isJsonNull()) && !jsonObj.get("webResponseUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webResponseUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webResponseUrl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MonitorJsonldGet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MonitorJsonldGet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MonitorJsonldGet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MonitorJsonldGet.class));

       return (TypeAdapter<T>) new TypeAdapter<MonitorJsonldGet>() {
           @Override
           public void write(JsonWriter out, MonitorJsonldGet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MonitorJsonldGet read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MonitorJsonldGet given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MonitorJsonldGet
   * @throws IOException if the JSON string is invalid with respect to MonitorJsonldGet
   */
  public static MonitorJsonldGet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MonitorJsonldGet.class);
  }

  /**
   * Convert an instance of MonitorJsonldGet to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

