/**
 * MLB v3 Scores
 * MLB scores API.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDefaultApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIDefaultApi::OAIDefaultApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIDefaultApi::~OAIDefaultApi() {
}

void OAIDefaultApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("http://azure-api.sportsdata.io/v3/mlb/scores"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://azure-api.sportsdata.io/v3/mlb/scores"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("areGamesInProgress", defaultConf);
    _serverIndices.insert("areGamesInProgress", 0);
    _serverConfigs.insert("currentSeason", defaultConf);
    _serverIndices.insert("currentSeason", 0);
    _serverConfigs.insert("gamesByDate", defaultConf);
    _serverIndices.insert("gamesByDate", 0);
    _serverConfigs.insert("gamesByDateBasic", defaultConf);
    _serverIndices.insert("gamesByDateBasic", 0);
    _serverConfigs.insert("news", defaultConf);
    _serverIndices.insert("news", 0);
    _serverConfigs.insert("newsByDate", defaultConf);
    _serverIndices.insert("newsByDate", 0);
    _serverConfigs.insert("newsByPlayer", defaultConf);
    _serverIndices.insert("newsByPlayer", 0);
    _serverConfigs.insert("playerDetailsByActive", defaultConf);
    _serverIndices.insert("playerDetailsByActive", 0);
    _serverConfigs.insert("playerDetailsByFreeAgents", defaultConf);
    _serverIndices.insert("playerDetailsByFreeAgents", 0);
    _serverConfigs.insert("playerDetailsByPlayer", defaultConf);
    _serverIndices.insert("playerDetailsByPlayer", 0);
    _serverConfigs.insert("playersByTeam", defaultConf);
    _serverIndices.insert("playersByTeam", 0);
    _serverConfigs.insert("playersByTeamBasic", defaultConf);
    _serverIndices.insert("playersByTeamBasic", 0);
    _serverConfigs.insert("schedules", defaultConf);
    _serverIndices.insert("schedules", 0);
    _serverConfigs.insert("schedulesBasic", defaultConf);
    _serverIndices.insert("schedulesBasic", 0);
    _serverConfigs.insert("stadiums", defaultConf);
    _serverIndices.insert("stadiums", 0);
    _serverConfigs.insert("standings", defaultConf);
    _serverIndices.insert("standings", 0);
    _serverConfigs.insert("teamGameLogsBySeason", defaultConf);
    _serverIndices.insert("teamGameLogsBySeason", 0);
    _serverConfigs.insert("teamGameStatsByDate", defaultConf);
    _serverIndices.insert("teamGameStatsByDate", 0);
    _serverConfigs.insert("teamSeasonStats", defaultConf);
    _serverIndices.insert("teamSeasonStats", 0);
    _serverConfigs.insert("teamsActive", defaultConf);
    _serverIndices.insert("teamsActive", 0);
    _serverConfigs.insert("teamsAll", defaultConf);
    _serverIndices.insert("teamsAll", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIDefaultApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIDefaultApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIDefaultApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIDefaultApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIDefaultApi::setUsername(const QString &username) {
    _username = username;
}

void OAIDefaultApi::setPassword(const QString &password) {
    _password = password;
}


void OAIDefaultApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIDefaultApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIDefaultApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIDefaultApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDefaultApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDefaultApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIDefaultApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIDefaultApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIDefaultApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIDefaultApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIDefaultApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIDefaultApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIDefaultApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIDefaultApi::areGamesInProgress(const QString &format) {
    QString fullPath = QString(_serverConfigs["areGamesInProgress"][_serverIndices.value("areGamesInProgress")].URL()+"/{format}/AreAnyGamesInProgress");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::areGamesInProgressCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::areGamesInProgressCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    bool output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT areGamesInProgressSignal(output);
        Q_EMIT areGamesInProgressSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT areGamesInProgressSignalE(output, error_type, error_str);
        Q_EMIT areGamesInProgressSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT areGamesInProgressSignalError(output, error_type, error_str);
        Q_EMIT areGamesInProgressSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::currentSeason(const QString &format) {
    QString fullPath = QString(_serverConfigs["currentSeason"][_serverIndices.value("currentSeason")].URL()+"/{format}/CurrentSeason");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::currentSeasonCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::currentSeasonCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISeason output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT currentSeasonSignal(output);
        Q_EMIT currentSeasonSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT currentSeasonSignalE(output, error_type, error_str);
        Q_EMIT currentSeasonSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT currentSeasonSignalError(output, error_type, error_str);
        Q_EMIT currentSeasonSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::gamesByDate(const QString &format, const QString &date) {
    QString fullPath = QString(_serverConfigs["gamesByDate"][_serverIndices.value("gamesByDate")].URL()+"/{format}/GamesByDate/{date}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString datePathParam("{");
        datePathParam.append("date").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "date", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"date"+pathSuffix : pathPrefix;
        fullPath.replace(datePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(date)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::gamesByDateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::gamesByDateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGame> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGame val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT gamesByDateSignal(output);
        Q_EMIT gamesByDateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT gamesByDateSignalE(output, error_type, error_str);
        Q_EMIT gamesByDateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT gamesByDateSignalError(output, error_type, error_str);
        Q_EMIT gamesByDateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::gamesByDateBasic(const QString &format, const QString &date) {
    QString fullPath = QString(_serverConfigs["gamesByDateBasic"][_serverIndices.value("gamesByDateBasic")].URL()+"/{format}/ScoresBasic/{date}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString datePathParam("{");
        datePathParam.append("date").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "date", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"date"+pathSuffix : pathPrefix;
        fullPath.replace(datePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(date)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::gamesByDateBasicCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::gamesByDateBasicCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIScoreBasic> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIScoreBasic val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT gamesByDateBasicSignal(output);
        Q_EMIT gamesByDateBasicSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT gamesByDateBasicSignalE(output, error_type, error_str);
        Q_EMIT gamesByDateBasicSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT gamesByDateBasicSignalError(output, error_type, error_str);
        Q_EMIT gamesByDateBasicSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::news(const QString &format) {
    QString fullPath = QString(_serverConfigs["news"][_serverIndices.value("news")].URL()+"/{format}/News");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::newsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::newsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINews> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAINews val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT newsSignal(output);
        Q_EMIT newsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT newsSignalE(output, error_type, error_str);
        Q_EMIT newsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT newsSignalError(output, error_type, error_str);
        Q_EMIT newsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::newsByDate(const QString &format, const QString &date) {
    QString fullPath = QString(_serverConfigs["newsByDate"][_serverIndices.value("newsByDate")].URL()+"/{format}/NewsByDate/{date}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString datePathParam("{");
        datePathParam.append("date").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "date", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"date"+pathSuffix : pathPrefix;
        fullPath.replace(datePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(date)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::newsByDateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::newsByDateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINews> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAINews val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT newsByDateSignal(output);
        Q_EMIT newsByDateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT newsByDateSignalE(output, error_type, error_str);
        Q_EMIT newsByDateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT newsByDateSignalError(output, error_type, error_str);
        Q_EMIT newsByDateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::newsByPlayer(const QString &format, const QString &playerid) {
    QString fullPath = QString(_serverConfigs["newsByPlayer"][_serverIndices.value("newsByPlayer")].URL()+"/{format}/NewsByPlayerID/{playerid}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString playeridPathParam("{");
        playeridPathParam.append("playerid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "playerid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"playerid"+pathSuffix : pathPrefix;
        fullPath.replace(playeridPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(playerid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::newsByPlayerCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::newsByPlayerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAINews> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAINews val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT newsByPlayerSignal(output);
        Q_EMIT newsByPlayerSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT newsByPlayerSignalE(output, error_type, error_str);
        Q_EMIT newsByPlayerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT newsByPlayerSignalError(output, error_type, error_str);
        Q_EMIT newsByPlayerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::playerDetailsByActive(const QString &format) {
    QString fullPath = QString(_serverConfigs["playerDetailsByActive"][_serverIndices.value("playerDetailsByActive")].URL()+"/{format}/Players");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::playerDetailsByActiveCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::playerDetailsByActiveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIPlayer> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIPlayer val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT playerDetailsByActiveSignal(output);
        Q_EMIT playerDetailsByActiveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT playerDetailsByActiveSignalE(output, error_type, error_str);
        Q_EMIT playerDetailsByActiveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT playerDetailsByActiveSignalError(output, error_type, error_str);
        Q_EMIT playerDetailsByActiveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::playerDetailsByFreeAgents(const QString &format) {
    QString fullPath = QString(_serverConfigs["playerDetailsByFreeAgents"][_serverIndices.value("playerDetailsByFreeAgents")].URL()+"/{format}/FreeAgents");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::playerDetailsByFreeAgentsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::playerDetailsByFreeAgentsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIPlayer> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIPlayer val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT playerDetailsByFreeAgentsSignal(output);
        Q_EMIT playerDetailsByFreeAgentsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT playerDetailsByFreeAgentsSignalE(output, error_type, error_str);
        Q_EMIT playerDetailsByFreeAgentsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT playerDetailsByFreeAgentsSignalError(output, error_type, error_str);
        Q_EMIT playerDetailsByFreeAgentsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::playerDetailsByPlayer(const QString &format, const QString &playerid) {
    QString fullPath = QString(_serverConfigs["playerDetailsByPlayer"][_serverIndices.value("playerDetailsByPlayer")].URL()+"/{format}/Player/{playerid}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString playeridPathParam("{");
        playeridPathParam.append("playerid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "playerid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"playerid"+pathSuffix : pathPrefix;
        fullPath.replace(playeridPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(playerid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::playerDetailsByPlayerCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::playerDetailsByPlayerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPlayer output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT playerDetailsByPlayerSignal(output);
        Q_EMIT playerDetailsByPlayerSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT playerDetailsByPlayerSignalE(output, error_type, error_str);
        Q_EMIT playerDetailsByPlayerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT playerDetailsByPlayerSignalError(output, error_type, error_str);
        Q_EMIT playerDetailsByPlayerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::playersByTeam(const QString &format, const QString &team) {
    QString fullPath = QString(_serverConfigs["playersByTeam"][_serverIndices.value("playersByTeam")].URL()+"/{format}/Players/{team}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString teamPathParam("{");
        teamPathParam.append("team").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "team", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"team"+pathSuffix : pathPrefix;
        fullPath.replace(teamPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(team)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::playersByTeamCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::playersByTeamCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIPlayer> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIPlayer val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT playersByTeamSignal(output);
        Q_EMIT playersByTeamSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT playersByTeamSignalE(output, error_type, error_str);
        Q_EMIT playersByTeamSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT playersByTeamSignalError(output, error_type, error_str);
        Q_EMIT playersByTeamSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::playersByTeamBasic(const QString &format, const QString &team) {
    QString fullPath = QString(_serverConfigs["playersByTeamBasic"][_serverIndices.value("playersByTeamBasic")].URL()+"/{format}/PlayersBasic/{team}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString teamPathParam("{");
        teamPathParam.append("team").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "team", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"team"+pathSuffix : pathPrefix;
        fullPath.replace(teamPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(team)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::playersByTeamBasicCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::playersByTeamBasicCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIPlayerBasic> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIPlayerBasic val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT playersByTeamBasicSignal(output);
        Q_EMIT playersByTeamBasicSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT playersByTeamBasicSignalE(output, error_type, error_str);
        Q_EMIT playersByTeamBasicSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT playersByTeamBasicSignalError(output, error_type, error_str);
        Q_EMIT playersByTeamBasicSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::schedules(const QString &format, const QString &season) {
    QString fullPath = QString(_serverConfigs["schedules"][_serverIndices.value("schedules")].URL()+"/{format}/Games/{season}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString seasonPathParam("{");
        seasonPathParam.append("season").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "season", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"season"+pathSuffix : pathPrefix;
        fullPath.replace(seasonPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(season)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::schedulesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::schedulesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGame> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGame val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT schedulesSignal(output);
        Q_EMIT schedulesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT schedulesSignalE(output, error_type, error_str);
        Q_EMIT schedulesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT schedulesSignalError(output, error_type, error_str);
        Q_EMIT schedulesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::schedulesBasic(const QString &format, const QString &season) {
    QString fullPath = QString(_serverConfigs["schedulesBasic"][_serverIndices.value("schedulesBasic")].URL()+"/{format}/SchedulesBasic/{season}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString seasonPathParam("{");
        seasonPathParam.append("season").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "season", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"season"+pathSuffix : pathPrefix;
        fullPath.replace(seasonPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(season)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::schedulesBasicCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::schedulesBasicCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIScheduleBasic> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIScheduleBasic val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT schedulesBasicSignal(output);
        Q_EMIT schedulesBasicSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT schedulesBasicSignalE(output, error_type, error_str);
        Q_EMIT schedulesBasicSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT schedulesBasicSignalError(output, error_type, error_str);
        Q_EMIT schedulesBasicSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::stadiums(const QString &format) {
    QString fullPath = QString(_serverConfigs["stadiums"][_serverIndices.value("stadiums")].URL()+"/{format}/Stadiums");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::stadiumsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::stadiumsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIStadium> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIStadium val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT stadiumsSignal(output);
        Q_EMIT stadiumsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT stadiumsSignalE(output, error_type, error_str);
        Q_EMIT stadiumsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT stadiumsSignalError(output, error_type, error_str);
        Q_EMIT stadiumsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::standings(const QString &format, const QString &season) {
    QString fullPath = QString(_serverConfigs["standings"][_serverIndices.value("standings")].URL()+"/{format}/Standings/{season}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString seasonPathParam("{");
        seasonPathParam.append("season").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "season", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"season"+pathSuffix : pathPrefix;
        fullPath.replace(seasonPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(season)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::standingsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::standingsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIStanding> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIStanding val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT standingsSignal(output);
        Q_EMIT standingsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT standingsSignalE(output, error_type, error_str);
        Q_EMIT standingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT standingsSignalError(output, error_type, error_str);
        Q_EMIT standingsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::teamGameLogsBySeason(const QString &format, const QString &season, const QString &teamid, const QString &numberofgames) {
    QString fullPath = QString(_serverConfigs["teamGameLogsBySeason"][_serverIndices.value("teamGameLogsBySeason")].URL()+"/{format}/TeamGameStatsBySeason/{season}/{teamid}/{numberofgames}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString seasonPathParam("{");
        seasonPathParam.append("season").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "season", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"season"+pathSuffix : pathPrefix;
        fullPath.replace(seasonPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(season)));
    }
    
    {
        QString teamidPathParam("{");
        teamidPathParam.append("teamid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "teamid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"teamid"+pathSuffix : pathPrefix;
        fullPath.replace(teamidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(teamid)));
    }
    
    {
        QString numberofgamesPathParam("{");
        numberofgamesPathParam.append("numberofgames").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "numberofgames", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"numberofgames"+pathSuffix : pathPrefix;
        fullPath.replace(numberofgamesPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(numberofgames)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::teamGameLogsBySeasonCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::teamGameLogsBySeasonCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAITeamGame> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAITeamGame val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT teamGameLogsBySeasonSignal(output);
        Q_EMIT teamGameLogsBySeasonSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT teamGameLogsBySeasonSignalE(output, error_type, error_str);
        Q_EMIT teamGameLogsBySeasonSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT teamGameLogsBySeasonSignalError(output, error_type, error_str);
        Q_EMIT teamGameLogsBySeasonSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::teamGameStatsByDate(const QString &format, const QString &date) {
    QString fullPath = QString(_serverConfigs["teamGameStatsByDate"][_serverIndices.value("teamGameStatsByDate")].URL()+"/{format}/TeamGameStatsByDate/{date}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString datePathParam("{");
        datePathParam.append("date").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "date", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"date"+pathSuffix : pathPrefix;
        fullPath.replace(datePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(date)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::teamGameStatsByDateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::teamGameStatsByDateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAITeamGame> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAITeamGame val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT teamGameStatsByDateSignal(output);
        Q_EMIT teamGameStatsByDateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT teamGameStatsByDateSignalE(output, error_type, error_str);
        Q_EMIT teamGameStatsByDateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT teamGameStatsByDateSignalError(output, error_type, error_str);
        Q_EMIT teamGameStatsByDateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::teamSeasonStats(const QString &format, const QString &season) {
    QString fullPath = QString(_serverConfigs["teamSeasonStats"][_serverIndices.value("teamSeasonStats")].URL()+"/{format}/TeamSeasonStats/{season}");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    
    {
        QString seasonPathParam("{");
        seasonPathParam.append("season").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "season", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"season"+pathSuffix : pathPrefix;
        fullPath.replace(seasonPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(season)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::teamSeasonStatsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::teamSeasonStatsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAITeamSeason> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAITeamSeason val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT teamSeasonStatsSignal(output);
        Q_EMIT teamSeasonStatsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT teamSeasonStatsSignalE(output, error_type, error_str);
        Q_EMIT teamSeasonStatsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT teamSeasonStatsSignalError(output, error_type, error_str);
        Q_EMIT teamSeasonStatsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::teamsActive(const QString &format) {
    QString fullPath = QString(_serverConfigs["teamsActive"][_serverIndices.value("teamsActive")].URL()+"/{format}/teams");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::teamsActiveCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::teamsActiveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAITeam> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAITeam val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT teamsActiveSignal(output);
        Q_EMIT teamsActiveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT teamsActiveSignalE(output, error_type, error_str);
        Q_EMIT teamsActiveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT teamsActiveSignalError(output, error_type, error_str);
        Q_EMIT teamsActiveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::teamsAll(const QString &format) {
    QString fullPath = QString(_serverConfigs["teamsAll"][_serverIndices.value("teamsAll")].URL()+"/{format}/AllTeams");
    
    if (_apiKeys.contains("apiKeyQuery")) {
        if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
        else
            fullPath.append("?");
        fullPath.append("apiKeyQuery=").append(_apiKeys.find("apiKeyQuery").value());
    }
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    
    {
        QString formatPathParam("{");
        formatPathParam.append("format").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "format", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"format"+pathSuffix : pathPrefix;
        fullPath.replace(formatPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(format)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::teamsAllCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::teamsAllCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAITeam> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAITeam val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT teamsAllSignal(output);
        Q_EMIT teamsAllSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT teamsAllSignalE(output, error_type, error_str);
        Q_EMIT teamsAllSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT teamsAllSignalError(output, error_type, error_str);
        Q_EMIT teamsAllSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
