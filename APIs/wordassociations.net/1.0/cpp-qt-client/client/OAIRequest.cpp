/**
 * Word Associations API
 * The Word Associations Network API allows developers to embed the ability to find associations for a word or phrase into their mobile apps or web services. Words are grouped by semantics, meaning, and psychological perception. The Word Associations Network API currently supports English, French, Spanish, German, Italian, Portuguese, and Russian vocabulary. Please [register and subscribe](https://api.wordassociations.net/subscriptions/) to one of available tariff plans to get a valid API key.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@wordassociations.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRequest::OAIRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRequest::OAIRequest() {
    this->initializeModel();
}

OAIRequest::~OAIRequest() {}

void OAIRequest::initializeModel() {

    m_indent_isSet = false;
    m_indent_isValid = false;

    m_lang_isSet = false;
    m_lang_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_pos_isSet = false;
    m_pos_isValid = false;

    m_text_isSet = false;
    m_text_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRequest::fromJsonObject(QJsonObject json) {

    m_indent_isValid = ::OpenAPI::fromJsonValue(m_indent, json[QString("indent")]);
    m_indent_isSet = !json[QString("indent")].isNull() && m_indent_isValid;

    m_lang_isValid = ::OpenAPI::fromJsonValue(m_lang, json[QString("lang")]);
    m_lang_isSet = !json[QString("lang")].isNull() && m_lang_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_pos_isValid = ::OpenAPI::fromJsonValue(m_pos, json[QString("pos")]);
    m_pos_isSet = !json[QString("pos")].isNull() && m_pos_isValid;

    m_text_isValid = ::OpenAPI::fromJsonValue(m_text, json[QString("text")]);
    m_text_isSet = !json[QString("text")].isNull() && m_text_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_indent_isSet) {
        obj.insert(QString("indent"), ::OpenAPI::toJsonValue(m_indent));
    }
    if (m_lang_isSet) {
        obj.insert(QString("lang"), ::OpenAPI::toJsonValue(m_lang));
    }
    if (m_limit_isSet) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_pos_isSet) {
        obj.insert(QString("pos"), ::OpenAPI::toJsonValue(m_pos));
    }
    if (m_text.size() > 0) {
        obj.insert(QString("text"), ::OpenAPI::toJsonValue(m_text));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QString OAIRequest::getIndent() const {
    return m_indent;
}
void OAIRequest::setIndent(const QString &indent) {
    m_indent = indent;
    m_indent_isSet = true;
}

bool OAIRequest::is_indent_Set() const{
    return m_indent_isSet;
}

bool OAIRequest::is_indent_Valid() const{
    return m_indent_isValid;
}

QString OAIRequest::getLang() const {
    return m_lang;
}
void OAIRequest::setLang(const QString &lang) {
    m_lang = lang;
    m_lang_isSet = true;
}

bool OAIRequest::is_lang_Set() const{
    return m_lang_isSet;
}

bool OAIRequest::is_lang_Valid() const{
    return m_lang_isValid;
}

qint32 OAIRequest::getLimit() const {
    return m_limit;
}
void OAIRequest::setLimit(const qint32 &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIRequest::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIRequest::is_limit_Valid() const{
    return m_limit_isValid;
}

QString OAIRequest::getPos() const {
    return m_pos;
}
void OAIRequest::setPos(const QString &pos) {
    m_pos = pos;
    m_pos_isSet = true;
}

bool OAIRequest::is_pos_Set() const{
    return m_pos_isSet;
}

bool OAIRequest::is_pos_Valid() const{
    return m_pos_isValid;
}

QList<QString> OAIRequest::getText() const {
    return m_text;
}
void OAIRequest::setText(const QList<QString> &text) {
    m_text = text;
    m_text_isSet = true;
}

bool OAIRequest::is_text_Set() const{
    return m_text_isSet;
}

bool OAIRequest::is_text_Valid() const{
    return m_text_isValid;
}

QString OAIRequest::getType() const {
    return m_type;
}
void OAIRequest::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIRequest::is_type_Set() const{
    return m_type_isSet;
}

bool OAIRequest::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_indent_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lang_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pos_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_text.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
