/**
 * NamSor API v2
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it! 
 *
 * The version of the OpenAPI document: 2.0.24
 * Contact: contact@namsor.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIJapaneseApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIJapaneseApi::OAIJapaneseApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIJapaneseApi::~OAIJapaneseApi() {
}

void OAIJapaneseApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://v2.namsor.com/NamSorAPIv2"),
    "namsor_v2",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("genderJapaneseNameFull", defaultConf);
    _serverIndices.insert("genderJapaneseNameFull", 0);
    _serverConfigs.insert("genderJapaneseNameFullBatch", defaultConf);
    _serverIndices.insert("genderJapaneseNameFullBatch", 0);
    _serverConfigs.insert("genderJapaneseNamePinyin", defaultConf);
    _serverIndices.insert("genderJapaneseNamePinyin", 0);
    _serverConfigs.insert("genderJapaneseNamePinyinBatch", defaultConf);
    _serverIndices.insert("genderJapaneseNamePinyinBatch", 0);
    _serverConfigs.insert("japaneseNameGenderKanjiCandidatesBatch", defaultConf);
    _serverIndices.insert("japaneseNameGenderKanjiCandidatesBatch", 0);
    _serverConfigs.insert("japaneseNameKanjiCandidates", defaultConf);
    _serverIndices.insert("japaneseNameKanjiCandidates", 0);
    _serverConfigs.insert("japaneseNameKanjiCandidates1", defaultConf);
    _serverIndices.insert("japaneseNameKanjiCandidates1", 0);
    _serverConfigs.insert("japaneseNameKanjiCandidatesBatch", defaultConf);
    _serverIndices.insert("japaneseNameKanjiCandidatesBatch", 0);
    _serverConfigs.insert("japaneseNameLatinCandidates", defaultConf);
    _serverIndices.insert("japaneseNameLatinCandidates", 0);
    _serverConfigs.insert("japaneseNameLatinCandidatesBatch", defaultConf);
    _serverIndices.insert("japaneseNameLatinCandidatesBatch", 0);
    _serverConfigs.insert("japaneseNameMatch", defaultConf);
    _serverIndices.insert("japaneseNameMatch", 0);
    _serverConfigs.insert("japaneseNameMatchBatch", defaultConf);
    _serverIndices.insert("japaneseNameMatchBatch", 0);
    _serverConfigs.insert("japaneseNameMatchFeedbackLoop", defaultConf);
    _serverIndices.insert("japaneseNameMatchFeedbackLoop", 0);
    _serverConfigs.insert("parseJapaneseName", defaultConf);
    _serverIndices.insert("parseJapaneseName", 0);
    _serverConfigs.insert("parseJapaneseNameBatch", defaultConf);
    _serverIndices.insert("parseJapaneseNameBatch", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIJapaneseApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIJapaneseApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIJapaneseApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIJapaneseApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIJapaneseApi::setUsername(const QString &username) {
    _username = username;
}

void OAIJapaneseApi::setPassword(const QString &password) {
    _password = password;
}


void OAIJapaneseApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIJapaneseApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIJapaneseApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIJapaneseApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIJapaneseApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIJapaneseApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIJapaneseApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIJapaneseApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIJapaneseApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIJapaneseApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIJapaneseApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIJapaneseApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIJapaneseApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIJapaneseApi::genderJapaneseNameFull(const QString &japanese_name) {
    QString fullPath = QString(_serverConfigs["genderJapaneseNameFull"][_serverIndices.value("genderJapaneseNameFull")].URL()+"/api2/json/genderJapaneseNameFull/{japaneseName}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_namePathParam("{");
        japanese_namePathParam.append("japaneseName").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseName", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseName"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::genderJapaneseNameFullCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::genderJapaneseNameFullCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPersonalNameGenderedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT genderJapaneseNameFullSignal(output);
        Q_EMIT genderJapaneseNameFullSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT genderJapaneseNameFullSignalE(output, error_type, error_str);
        Q_EMIT genderJapaneseNameFullSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT genderJapaneseNameFullSignalError(output, error_type, error_str);
        Q_EMIT genderJapaneseNameFullSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::genderJapaneseNameFullBatch(const ::OpenAPI::OptionalParam<OAIBatchPersonalNameIn> &oai_batch_personal_name_in) {
    QString fullPath = QString(_serverConfigs["genderJapaneseNameFullBatch"][_serverIndices.value("genderJapaneseNameFullBatch")].URL()+"/api2/json/genderJapaneseNameFullBatch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_batch_personal_name_in.hasValue()){

        
        QByteArray output = oai_batch_personal_name_in.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::genderJapaneseNameFullBatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::genderJapaneseNameFullBatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBatchPersonalNameGenderedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT genderJapaneseNameFullBatchSignal(output);
        Q_EMIT genderJapaneseNameFullBatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT genderJapaneseNameFullBatchSignalE(output, error_type, error_str);
        Q_EMIT genderJapaneseNameFullBatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT genderJapaneseNameFullBatchSignalError(output, error_type, error_str);
        Q_EMIT genderJapaneseNameFullBatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::genderJapaneseNamePinyin(const QString &japanese_surname, const QString &japanese_given_name) {
    QString fullPath = QString(_serverConfigs["genderJapaneseNamePinyin"][_serverIndices.value("genderJapaneseNamePinyin")].URL()+"/api2/json/genderJapaneseName/{japaneseSurname}/{japaneseGivenName}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_surnamePathParam("{");
        japanese_surnamePathParam.append("japaneseSurname").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseSurname", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseSurname"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_surnamePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_surname)));
    }
    
    {
        QString japanese_given_namePathParam("{");
        japanese_given_namePathParam.append("japaneseGivenName").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseGivenName", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseGivenName"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_given_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_given_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::genderJapaneseNamePinyinCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::genderJapaneseNamePinyinCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIFirstLastNameGenderedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT genderJapaneseNamePinyinSignal(output);
        Q_EMIT genderJapaneseNamePinyinSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT genderJapaneseNamePinyinSignalE(output, error_type, error_str);
        Q_EMIT genderJapaneseNamePinyinSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT genderJapaneseNamePinyinSignalError(output, error_type, error_str);
        Q_EMIT genderJapaneseNamePinyinSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::genderJapaneseNamePinyinBatch(const ::OpenAPI::OptionalParam<OAIBatchFirstLastNameIn> &oai_batch_first_last_name_in) {
    QString fullPath = QString(_serverConfigs["genderJapaneseNamePinyinBatch"][_serverIndices.value("genderJapaneseNamePinyinBatch")].URL()+"/api2/json/genderJapaneseNameBatch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_batch_first_last_name_in.hasValue()){

        
        QByteArray output = oai_batch_first_last_name_in.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::genderJapaneseNamePinyinBatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::genderJapaneseNamePinyinBatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBatchFirstLastNameGenderedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT genderJapaneseNamePinyinBatchSignal(output);
        Q_EMIT genderJapaneseNamePinyinBatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT genderJapaneseNamePinyinBatchSignalE(output, error_type, error_str);
        Q_EMIT genderJapaneseNamePinyinBatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT genderJapaneseNamePinyinBatchSignalError(output, error_type, error_str);
        Q_EMIT genderJapaneseNamePinyinBatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameGenderKanjiCandidatesBatch(const ::OpenAPI::OptionalParam<OAIBatchFirstLastNameGenderIn> &oai_batch_first_last_name_gender_in) {
    QString fullPath = QString(_serverConfigs["japaneseNameGenderKanjiCandidatesBatch"][_serverIndices.value("japaneseNameGenderKanjiCandidatesBatch")].URL()+"/api2/json/japaneseNameGenderKanjiCandidatesBatch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_batch_first_last_name_gender_in.hasValue()){

        
        QByteArray output = oai_batch_first_last_name_gender_in.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameGenderKanjiCandidatesBatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameGenderKanjiCandidatesBatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBatchNameMatchCandidatesOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameGenderKanjiCandidatesBatchSignal(output);
        Q_EMIT japaneseNameGenderKanjiCandidatesBatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameGenderKanjiCandidatesBatchSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameGenderKanjiCandidatesBatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameGenderKanjiCandidatesBatchSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameGenderKanjiCandidatesBatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameKanjiCandidates(const QString &japanese_surname_latin, const QString &japanese_given_name_latin, const QString &known_gender) {
    QString fullPath = QString(_serverConfigs["japaneseNameKanjiCandidates"][_serverIndices.value("japaneseNameKanjiCandidates")].URL()+"/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{knownGender}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_surname_latinPathParam("{");
        japanese_surname_latinPathParam.append("japaneseSurnameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseSurnameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseSurnameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_surname_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_surname_latin)));
    }
    
    {
        QString japanese_given_name_latinPathParam("{");
        japanese_given_name_latinPathParam.append("japaneseGivenNameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseGivenNameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseGivenNameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_given_name_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_given_name_latin)));
    }
    
    {
        QString known_genderPathParam("{");
        known_genderPathParam.append("knownGender").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "knownGender", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"knownGender"+pathSuffix : pathPrefix;
        fullPath.replace(known_genderPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(known_gender)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameKanjiCandidatesCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameKanjiCandidatesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINameMatchCandidatesOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameKanjiCandidatesSignal(output);
        Q_EMIT japaneseNameKanjiCandidatesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameKanjiCandidatesSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameKanjiCandidatesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameKanjiCandidatesSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameKanjiCandidatesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameKanjiCandidates1(const QString &japanese_surname_latin, const QString &japanese_given_name_latin) {
    QString fullPath = QString(_serverConfigs["japaneseNameKanjiCandidates1"][_serverIndices.value("japaneseNameKanjiCandidates1")].URL()+"/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_surname_latinPathParam("{");
        japanese_surname_latinPathParam.append("japaneseSurnameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseSurnameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseSurnameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_surname_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_surname_latin)));
    }
    
    {
        QString japanese_given_name_latinPathParam("{");
        japanese_given_name_latinPathParam.append("japaneseGivenNameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseGivenNameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseGivenNameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_given_name_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_given_name_latin)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameKanjiCandidates1Callback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameKanjiCandidates1Callback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINameMatchCandidatesOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameKanjiCandidates1Signal(output);
        Q_EMIT japaneseNameKanjiCandidates1SignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameKanjiCandidates1SignalE(output, error_type, error_str);
        Q_EMIT japaneseNameKanjiCandidates1SignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameKanjiCandidates1SignalError(output, error_type, error_str);
        Q_EMIT japaneseNameKanjiCandidates1SignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameKanjiCandidatesBatch(const ::OpenAPI::OptionalParam<OAIBatchFirstLastNameIn> &oai_batch_first_last_name_in) {
    QString fullPath = QString(_serverConfigs["japaneseNameKanjiCandidatesBatch"][_serverIndices.value("japaneseNameKanjiCandidatesBatch")].URL()+"/api2/json/japaneseNameKanjiCandidatesBatch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_batch_first_last_name_in.hasValue()){

        
        QByteArray output = oai_batch_first_last_name_in.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameKanjiCandidatesBatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameKanjiCandidatesBatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBatchNameMatchCandidatesOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameKanjiCandidatesBatchSignal(output);
        Q_EMIT japaneseNameKanjiCandidatesBatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameKanjiCandidatesBatchSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameKanjiCandidatesBatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameKanjiCandidatesBatchSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameKanjiCandidatesBatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameLatinCandidates(const QString &japanese_surname_kanji, const QString &japanese_given_name_kanji) {
    QString fullPath = QString(_serverConfigs["japaneseNameLatinCandidates"][_serverIndices.value("japaneseNameLatinCandidates")].URL()+"/api2/json/japaneseNameLatinCandidates/{japaneseSurnameKanji}/{japaneseGivenNameKanji}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_surname_kanjiPathParam("{");
        japanese_surname_kanjiPathParam.append("japaneseSurnameKanji").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseSurnameKanji", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseSurnameKanji"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_surname_kanjiPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_surname_kanji)));
    }
    
    {
        QString japanese_given_name_kanjiPathParam("{");
        japanese_given_name_kanjiPathParam.append("japaneseGivenNameKanji").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseGivenNameKanji", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseGivenNameKanji"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_given_name_kanjiPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_given_name_kanji)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameLatinCandidatesCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameLatinCandidatesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINameMatchCandidatesOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameLatinCandidatesSignal(output);
        Q_EMIT japaneseNameLatinCandidatesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameLatinCandidatesSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameLatinCandidatesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameLatinCandidatesSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameLatinCandidatesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameLatinCandidatesBatch(const ::OpenAPI::OptionalParam<OAIBatchFirstLastNameIn> &oai_batch_first_last_name_in) {
    QString fullPath = QString(_serverConfigs["japaneseNameLatinCandidatesBatch"][_serverIndices.value("japaneseNameLatinCandidatesBatch")].URL()+"/api2/json/japaneseNameLatinCandidatesBatch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_batch_first_last_name_in.hasValue()){

        
        QByteArray output = oai_batch_first_last_name_in.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameLatinCandidatesBatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameLatinCandidatesBatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBatchNameMatchCandidatesOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameLatinCandidatesBatchSignal(output);
        Q_EMIT japaneseNameLatinCandidatesBatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameLatinCandidatesBatchSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameLatinCandidatesBatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameLatinCandidatesBatchSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameLatinCandidatesBatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameMatch(const QString &japanese_surname_latin, const QString &japanese_given_name_latin, const QString &japanese_name) {
    QString fullPath = QString(_serverConfigs["japaneseNameMatch"][_serverIndices.value("japaneseNameMatch")].URL()+"/api2/json/japaneseNameMatch/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_surname_latinPathParam("{");
        japanese_surname_latinPathParam.append("japaneseSurnameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseSurnameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseSurnameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_surname_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_surname_latin)));
    }
    
    {
        QString japanese_given_name_latinPathParam("{");
        japanese_given_name_latinPathParam.append("japaneseGivenNameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseGivenNameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseGivenNameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_given_name_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_given_name_latin)));
    }
    
    {
        QString japanese_namePathParam("{");
        japanese_namePathParam.append("japaneseName").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseName", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseName"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameMatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameMatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAINameMatchedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameMatchSignal(output);
        Q_EMIT japaneseNameMatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameMatchSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameMatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameMatchSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameMatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameMatchBatch(const ::OpenAPI::OptionalParam<OAIBatchMatchPersonalFirstLastNameIn> &oai_batch_match_personal_first_last_name_in) {
    QString fullPath = QString(_serverConfigs["japaneseNameMatchBatch"][_serverIndices.value("japaneseNameMatchBatch")].URL()+"/api2/json/japaneseNameMatchBatch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_batch_match_personal_first_last_name_in.hasValue()){

        
        QByteArray output = oai_batch_match_personal_first_last_name_in.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameMatchBatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameMatchBatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBatchNameMatchedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameMatchBatchSignal(output);
        Q_EMIT japaneseNameMatchBatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameMatchBatchSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameMatchBatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameMatchBatchSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameMatchBatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::japaneseNameMatchFeedbackLoop(const QString &japanese_surname_latin, const QString &japanese_given_name_latin, const QString &japanese_name) {
    QString fullPath = QString(_serverConfigs["japaneseNameMatchFeedbackLoop"][_serverIndices.value("japaneseNameMatchFeedbackLoop")].URL()+"/api2/json/japaneseNameMatchFeedbackLoop/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_surname_latinPathParam("{");
        japanese_surname_latinPathParam.append("japaneseSurnameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseSurnameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseSurnameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_surname_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_surname_latin)));
    }
    
    {
        QString japanese_given_name_latinPathParam("{");
        japanese_given_name_latinPathParam.append("japaneseGivenNameLatin").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseGivenNameLatin", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseGivenNameLatin"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_given_name_latinPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_given_name_latin)));
    }
    
    {
        QString japanese_namePathParam("{");
        japanese_namePathParam.append("japaneseName").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseName", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseName"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::japaneseNameMatchFeedbackLoopCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::japaneseNameMatchFeedbackLoopCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIFeedbackLoopOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT japaneseNameMatchFeedbackLoopSignal(output);
        Q_EMIT japaneseNameMatchFeedbackLoopSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT japaneseNameMatchFeedbackLoopSignalE(output, error_type, error_str);
        Q_EMIT japaneseNameMatchFeedbackLoopSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT japaneseNameMatchFeedbackLoopSignalError(output, error_type, error_str);
        Q_EMIT japaneseNameMatchFeedbackLoopSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::parseJapaneseName(const QString &japanese_name) {
    QString fullPath = QString(_serverConfigs["parseJapaneseName"][_serverIndices.value("parseJapaneseName")].URL()+"/api2/json/parseJapaneseName/{japaneseName}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    
    {
        QString japanese_namePathParam("{");
        japanese_namePathParam.append("japaneseName").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "japaneseName", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"japaneseName"+pathSuffix : pathPrefix;
        fullPath.replace(japanese_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(japanese_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::parseJapaneseNameCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::parseJapaneseNameCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPersonalNameParsedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT parseJapaneseNameSignal(output);
        Q_EMIT parseJapaneseNameSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT parseJapaneseNameSignalE(output, error_type, error_str);
        Q_EMIT parseJapaneseNameSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT parseJapaneseNameSignalError(output, error_type, error_str);
        Q_EMIT parseJapaneseNameSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::parseJapaneseNameBatch(const ::OpenAPI::OptionalParam<OAIBatchPersonalNameIn> &oai_batch_personal_name_in) {
    QString fullPath = QString(_serverConfigs["parseJapaneseNameBatch"][_serverIndices.value("parseJapaneseNameBatch")].URL()+"/api2/json/parseJapaneseNameBatch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_batch_personal_name_in.hasValue()){

        
        QByteArray output = oai_batch_personal_name_in.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIJapaneseApi::parseJapaneseNameBatchCallback);
    connect(this, &OAIJapaneseApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIJapaneseApi::parseJapaneseNameBatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBatchPersonalNameParsedOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT parseJapaneseNameBatchSignal(output);
        Q_EMIT parseJapaneseNameBatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT parseJapaneseNameBatchSignalE(output, error_type, error_str);
        Q_EMIT parseJapaneseNameBatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT parseJapaneseNameBatchSignalError(output, error_type, error_str);
        Q_EMIT parseJapaneseNameBatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIJapaneseApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
