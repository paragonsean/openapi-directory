/**
 * NamSor API v2
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it! 
 *
 * The version of the OpenAPI document: 2.0.24
 * Contact: contact@namsor.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAPICounterV2Out.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAPICounterV2Out::OAIAPICounterV2Out(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAPICounterV2Out::OAIAPICounterV2Out() {
    this->initializeModel();
}

OAIAPICounterV2Out::~OAIAPICounterV2Out() {}

void OAIAPICounterV2Out::initializeModel() {

    m_api_key_isSet = false;
    m_api_key_isValid = false;

    m_api_service_isSet = false;
    m_api_service_isValid = false;

    m_created_date_time_isSet = false;
    m_created_date_time_isValid = false;

    m_host_address_isSet = false;
    m_host_address_isValid = false;

    m_last_flushed_date_time_isSet = false;
    m_last_flushed_date_time_isValid = false;

    m_last_used_date_time_isSet = false;
    m_last_used_date_time_isValid = false;

    m_service_features_usage_isSet = false;
    m_service_features_usage_isValid = false;

    m_total_usage_isSet = false;
    m_total_usage_isValid = false;
}

void OAIAPICounterV2Out::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAPICounterV2Out::fromJsonObject(QJsonObject json) {

    m_api_key_isValid = ::OpenAPI::fromJsonValue(m_api_key, json[QString("apiKey")]);
    m_api_key_isSet = !json[QString("apiKey")].isNull() && m_api_key_isValid;

    m_api_service_isValid = ::OpenAPI::fromJsonValue(m_api_service, json[QString("apiService")]);
    m_api_service_isSet = !json[QString("apiService")].isNull() && m_api_service_isValid;

    m_created_date_time_isValid = ::OpenAPI::fromJsonValue(m_created_date_time, json[QString("createdDateTime")]);
    m_created_date_time_isSet = !json[QString("createdDateTime")].isNull() && m_created_date_time_isValid;

    m_host_address_isValid = ::OpenAPI::fromJsonValue(m_host_address, json[QString("hostAddress")]);
    m_host_address_isSet = !json[QString("hostAddress")].isNull() && m_host_address_isValid;

    m_last_flushed_date_time_isValid = ::OpenAPI::fromJsonValue(m_last_flushed_date_time, json[QString("lastFlushedDateTime")]);
    m_last_flushed_date_time_isSet = !json[QString("lastFlushedDateTime")].isNull() && m_last_flushed_date_time_isValid;

    m_last_used_date_time_isValid = ::OpenAPI::fromJsonValue(m_last_used_date_time, json[QString("lastUsedDateTime")]);
    m_last_used_date_time_isSet = !json[QString("lastUsedDateTime")].isNull() && m_last_used_date_time_isValid;

    m_service_features_usage_isValid = ::OpenAPI::fromJsonValue(m_service_features_usage, json[QString("serviceFeaturesUsage")]);
    m_service_features_usage_isSet = !json[QString("serviceFeaturesUsage")].isNull() && m_service_features_usage_isValid;

    m_total_usage_isValid = ::OpenAPI::fromJsonValue(m_total_usage, json[QString("totalUsage")]);
    m_total_usage_isSet = !json[QString("totalUsage")].isNull() && m_total_usage_isValid;
}

QString OAIAPICounterV2Out::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAPICounterV2Out::asJsonObject() const {
    QJsonObject obj;
    if (m_api_key.isSet()) {
        obj.insert(QString("apiKey"), ::OpenAPI::toJsonValue(m_api_key));
    }
    if (m_api_service_isSet) {
        obj.insert(QString("apiService"), ::OpenAPI::toJsonValue(m_api_service));
    }
    if (m_created_date_time_isSet) {
        obj.insert(QString("createdDateTime"), ::OpenAPI::toJsonValue(m_created_date_time));
    }
    if (m_host_address_isSet) {
        obj.insert(QString("hostAddress"), ::OpenAPI::toJsonValue(m_host_address));
    }
    if (m_last_flushed_date_time_isSet) {
        obj.insert(QString("lastFlushedDateTime"), ::OpenAPI::toJsonValue(m_last_flushed_date_time));
    }
    if (m_last_used_date_time_isSet) {
        obj.insert(QString("lastUsedDateTime"), ::OpenAPI::toJsonValue(m_last_used_date_time));
    }
    if (m_service_features_usage.size() > 0) {
        obj.insert(QString("serviceFeaturesUsage"), ::OpenAPI::toJsonValue(m_service_features_usage));
    }
    if (m_total_usage_isSet) {
        obj.insert(QString("totalUsage"), ::OpenAPI::toJsonValue(m_total_usage));
    }
    return obj;
}

OAIAPIKeyOut OAIAPICounterV2Out::getApiKey() const {
    return m_api_key;
}
void OAIAPICounterV2Out::setApiKey(const OAIAPIKeyOut &api_key) {
    m_api_key = api_key;
    m_api_key_isSet = true;
}

bool OAIAPICounterV2Out::is_api_key_Set() const{
    return m_api_key_isSet;
}

bool OAIAPICounterV2Out::is_api_key_Valid() const{
    return m_api_key_isValid;
}

QString OAIAPICounterV2Out::getApiService() const {
    return m_api_service;
}
void OAIAPICounterV2Out::setApiService(const QString &api_service) {
    m_api_service = api_service;
    m_api_service_isSet = true;
}

bool OAIAPICounterV2Out::is_api_service_Set() const{
    return m_api_service_isSet;
}

bool OAIAPICounterV2Out::is_api_service_Valid() const{
    return m_api_service_isValid;
}

qint64 OAIAPICounterV2Out::getCreatedDateTime() const {
    return m_created_date_time;
}
void OAIAPICounterV2Out::setCreatedDateTime(const qint64 &created_date_time) {
    m_created_date_time = created_date_time;
    m_created_date_time_isSet = true;
}

bool OAIAPICounterV2Out::is_created_date_time_Set() const{
    return m_created_date_time_isSet;
}

bool OAIAPICounterV2Out::is_created_date_time_Valid() const{
    return m_created_date_time_isValid;
}

QString OAIAPICounterV2Out::getHostAddress() const {
    return m_host_address;
}
void OAIAPICounterV2Out::setHostAddress(const QString &host_address) {
    m_host_address = host_address;
    m_host_address_isSet = true;
}

bool OAIAPICounterV2Out::is_host_address_Set() const{
    return m_host_address_isSet;
}

bool OAIAPICounterV2Out::is_host_address_Valid() const{
    return m_host_address_isValid;
}

qint64 OAIAPICounterV2Out::getLastFlushedDateTime() const {
    return m_last_flushed_date_time;
}
void OAIAPICounterV2Out::setLastFlushedDateTime(const qint64 &last_flushed_date_time) {
    m_last_flushed_date_time = last_flushed_date_time;
    m_last_flushed_date_time_isSet = true;
}

bool OAIAPICounterV2Out::is_last_flushed_date_time_Set() const{
    return m_last_flushed_date_time_isSet;
}

bool OAIAPICounterV2Out::is_last_flushed_date_time_Valid() const{
    return m_last_flushed_date_time_isValid;
}

qint64 OAIAPICounterV2Out::getLastUsedDateTime() const {
    return m_last_used_date_time;
}
void OAIAPICounterV2Out::setLastUsedDateTime(const qint64 &last_used_date_time) {
    m_last_used_date_time = last_used_date_time;
    m_last_used_date_time_isSet = true;
}

bool OAIAPICounterV2Out::is_last_used_date_time_Set() const{
    return m_last_used_date_time_isSet;
}

bool OAIAPICounterV2Out::is_last_used_date_time_Valid() const{
    return m_last_used_date_time_isValid;
}

QMap<QString, qint64> OAIAPICounterV2Out::getServiceFeaturesUsage() const {
    return m_service_features_usage;
}
void OAIAPICounterV2Out::setServiceFeaturesUsage(const QMap<QString, qint64> &service_features_usage) {
    m_service_features_usage = service_features_usage;
    m_service_features_usage_isSet = true;
}

bool OAIAPICounterV2Out::is_service_features_usage_Set() const{
    return m_service_features_usage_isSet;
}

bool OAIAPICounterV2Out::is_service_features_usage_Valid() const{
    return m_service_features_usage_isValid;
}

qint64 OAIAPICounterV2Out::getTotalUsage() const {
    return m_total_usage;
}
void OAIAPICounterV2Out::setTotalUsage(const qint64 &total_usage) {
    m_total_usage = total_usage;
    m_total_usage_isSet = true;
}

bool OAIAPICounterV2Out::is_total_usage_Set() const{
    return m_total_usage_isSet;
}

bool OAIAPICounterV2Out::is_total_usage_Valid() const{
    return m_total_usage_isValid;
}

bool OAIAPICounterV2Out::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_api_key.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_api_service_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_date_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_host_address_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_flushed_date_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_used_date_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_features_usage.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_usage_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAPICounterV2Out::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
