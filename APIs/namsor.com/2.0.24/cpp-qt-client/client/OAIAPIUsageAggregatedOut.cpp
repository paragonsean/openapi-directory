/**
 * NamSor API v2
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it! 
 *
 * The version of the OpenAPI document: 2.0.24
 * Contact: contact@namsor.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAPIUsageAggregatedOut.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAPIUsageAggregatedOut::OAIAPIUsageAggregatedOut(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAPIUsageAggregatedOut::OAIAPIUsageAggregatedOut() {
    this->initializeModel();
}

OAIAPIUsageAggregatedOut::~OAIAPIUsageAggregatedOut() {}

void OAIAPIUsageAggregatedOut::initializeModel() {

    m_col_headers_isSet = false;
    m_col_headers_isValid = false;

    m_data_isSet = false;
    m_data_isValid = false;

    m_history_truncated_isSet = false;
    m_history_truncated_isValid = false;

    m_period_end_isSet = false;
    m_period_end_isValid = false;

    m_period_start_isSet = false;
    m_period_start_isValid = false;

    m_row_headers_isSet = false;
    m_row_headers_isValid = false;

    m_time_unit_isSet = false;
    m_time_unit_isValid = false;

    m_total_usage_isSet = false;
    m_total_usage_isValid = false;
}

void OAIAPIUsageAggregatedOut::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAPIUsageAggregatedOut::fromJsonObject(QJsonObject json) {

    m_col_headers_isValid = ::OpenAPI::fromJsonValue(m_col_headers, json[QString("colHeaders")]);
    m_col_headers_isSet = !json[QString("colHeaders")].isNull() && m_col_headers_isValid;

    if(json["data"].isArray()){
        auto arr = json["data"].toArray();
        m_data_isValid = true;
        if(arr.count() > 0) {
            for (const QJsonValue jval : arr) {
                QList<qint32> item;
                m_data_isValid &= ::OpenAPI::fromJsonValue(item, jval);
                m_data_isSet = !jval.isNull() && m_data_isValid;
                m_data.push_back(item);
            }
        }
    }

    m_history_truncated_isValid = ::OpenAPI::fromJsonValue(m_history_truncated, json[QString("historyTruncated")]);
    m_history_truncated_isSet = !json[QString("historyTruncated")].isNull() && m_history_truncated_isValid;

    m_period_end_isValid = ::OpenAPI::fromJsonValue(m_period_end, json[QString("periodEnd")]);
    m_period_end_isSet = !json[QString("periodEnd")].isNull() && m_period_end_isValid;

    m_period_start_isValid = ::OpenAPI::fromJsonValue(m_period_start, json[QString("periodStart")]);
    m_period_start_isSet = !json[QString("periodStart")].isNull() && m_period_start_isValid;

    m_row_headers_isValid = ::OpenAPI::fromJsonValue(m_row_headers, json[QString("rowHeaders")]);
    m_row_headers_isSet = !json[QString("rowHeaders")].isNull() && m_row_headers_isValid;

    m_time_unit_isValid = ::OpenAPI::fromJsonValue(m_time_unit, json[QString("timeUnit")]);
    m_time_unit_isSet = !json[QString("timeUnit")].isNull() && m_time_unit_isValid;

    m_total_usage_isValid = ::OpenAPI::fromJsonValue(m_total_usage, json[QString("totalUsage")]);
    m_total_usage_isSet = !json[QString("totalUsage")].isNull() && m_total_usage_isValid;
}

QString OAIAPIUsageAggregatedOut::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAPIUsageAggregatedOut::asJsonObject() const {
    QJsonObject obj;
    if (m_col_headers.size() > 0) {
        obj.insert(QString("colHeaders"), ::OpenAPI::toJsonValue(m_col_headers));
    }
    if (m_data.size() > 0) {
        
        obj.insert(QString("data"), toJsonValue(m_data));
    }
    if (m_history_truncated_isSet) {
        obj.insert(QString("historyTruncated"), ::OpenAPI::toJsonValue(m_history_truncated));
    }
    if (m_period_end_isSet) {
        obj.insert(QString("periodEnd"), ::OpenAPI::toJsonValue(m_period_end));
    }
    if (m_period_start_isSet) {
        obj.insert(QString("periodStart"), ::OpenAPI::toJsonValue(m_period_start));
    }
    if (m_row_headers.size() > 0) {
        obj.insert(QString("rowHeaders"), ::OpenAPI::toJsonValue(m_row_headers));
    }
    if (m_time_unit_isSet) {
        obj.insert(QString("timeUnit"), ::OpenAPI::toJsonValue(m_time_unit));
    }
    if (m_total_usage_isSet) {
        obj.insert(QString("totalUsage"), ::OpenAPI::toJsonValue(m_total_usage));
    }
    return obj;
}

QList<QString> OAIAPIUsageAggregatedOut::getColHeaders() const {
    return m_col_headers;
}
void OAIAPIUsageAggregatedOut::setColHeaders(const QList<QString> &col_headers) {
    m_col_headers = col_headers;
    m_col_headers_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_col_headers_Set() const{
    return m_col_headers_isSet;
}

bool OAIAPIUsageAggregatedOut::is_col_headers_Valid() const{
    return m_col_headers_isValid;
}

QList<QList<qint32>> OAIAPIUsageAggregatedOut::getData() const {
    return m_data;
}
void OAIAPIUsageAggregatedOut::setData(const QList<QList<qint32>> &data) {
    m_data = data;
    m_data_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_data_Set() const{
    return m_data_isSet;
}

bool OAIAPIUsageAggregatedOut::is_data_Valid() const{
    return m_data_isValid;
}

bool OAIAPIUsageAggregatedOut::isHistoryTruncated() const {
    return m_history_truncated;
}
void OAIAPIUsageAggregatedOut::setHistoryTruncated(const bool &history_truncated) {
    m_history_truncated = history_truncated;
    m_history_truncated_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_history_truncated_Set() const{
    return m_history_truncated_isSet;
}

bool OAIAPIUsageAggregatedOut::is_history_truncated_Valid() const{
    return m_history_truncated_isValid;
}

qint64 OAIAPIUsageAggregatedOut::getPeriodEnd() const {
    return m_period_end;
}
void OAIAPIUsageAggregatedOut::setPeriodEnd(const qint64 &period_end) {
    m_period_end = period_end;
    m_period_end_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_period_end_Set() const{
    return m_period_end_isSet;
}

bool OAIAPIUsageAggregatedOut::is_period_end_Valid() const{
    return m_period_end_isValid;
}

qint64 OAIAPIUsageAggregatedOut::getPeriodStart() const {
    return m_period_start;
}
void OAIAPIUsageAggregatedOut::setPeriodStart(const qint64 &period_start) {
    m_period_start = period_start;
    m_period_start_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_period_start_Set() const{
    return m_period_start_isSet;
}

bool OAIAPIUsageAggregatedOut::is_period_start_Valid() const{
    return m_period_start_isValid;
}

QList<QString> OAIAPIUsageAggregatedOut::getRowHeaders() const {
    return m_row_headers;
}
void OAIAPIUsageAggregatedOut::setRowHeaders(const QList<QString> &row_headers) {
    m_row_headers = row_headers;
    m_row_headers_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_row_headers_Set() const{
    return m_row_headers_isSet;
}

bool OAIAPIUsageAggregatedOut::is_row_headers_Valid() const{
    return m_row_headers_isValid;
}

QString OAIAPIUsageAggregatedOut::getTimeUnit() const {
    return m_time_unit;
}
void OAIAPIUsageAggregatedOut::setTimeUnit(const QString &time_unit) {
    m_time_unit = time_unit;
    m_time_unit_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_time_unit_Set() const{
    return m_time_unit_isSet;
}

bool OAIAPIUsageAggregatedOut::is_time_unit_Valid() const{
    return m_time_unit_isValid;
}

qint64 OAIAPIUsageAggregatedOut::getTotalUsage() const {
    return m_total_usage;
}
void OAIAPIUsageAggregatedOut::setTotalUsage(const qint64 &total_usage) {
    m_total_usage = total_usage;
    m_total_usage_isSet = true;
}

bool OAIAPIUsageAggregatedOut::is_total_usage_Set() const{
    return m_total_usage_isSet;
}

bool OAIAPIUsageAggregatedOut::is_total_usage_Valid() const{
    return m_total_usage_isValid;
}

bool OAIAPIUsageAggregatedOut::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_col_headers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_data.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_history_truncated_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_end_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_start_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_row_headers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_unit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_usage_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAPIUsageAggregatedOut::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
