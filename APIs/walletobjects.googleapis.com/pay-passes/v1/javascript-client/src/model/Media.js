/**
 * Google Pay Passes API
 * API for issuers to save and manage Google Wallet Objects.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Blobstore2Info from './Blobstore2Info';
import CompositeMedia from './CompositeMedia';
import ContentTypeInfo from './ContentTypeInfo';
import DiffChecksumsResponse from './DiffChecksumsResponse';
import DiffDownloadResponse from './DiffDownloadResponse';
import DiffUploadRequest from './DiffUploadRequest';
import DiffUploadResponse from './DiffUploadResponse';
import DiffVersionResponse from './DiffVersionResponse';
import DownloadParameters from './DownloadParameters';
import ObjectId from './ObjectId';

/**
 * The Media model module.
 * @module model/Media
 * @version v1
 */
class Media {
    /**
     * Constructs a new <code>Media</code>.
     * A reference to data stored on the filesystem, on GFS or in blobstore.
     * @alias module:model/Media
     */
    constructor() { 
        
        Media.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Media</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Media} obj Optional instance to populate.
     * @return {module:model/Media} The populated <code>Media</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Media();

            if (data.hasOwnProperty('algorithm')) {
                obj['algorithm'] = ApiClient.convertToType(data['algorithm'], 'String');
            }
            if (data.hasOwnProperty('bigstoreObjectRef')) {
                obj['bigstoreObjectRef'] = ApiClient.convertToType(data['bigstoreObjectRef'], 'Blob');
            }
            if (data.hasOwnProperty('blobRef')) {
                obj['blobRef'] = ApiClient.convertToType(data['blobRef'], 'Blob');
            }
            if (data.hasOwnProperty('blobstore2Info')) {
                obj['blobstore2Info'] = Blobstore2Info.constructFromObject(data['blobstore2Info']);
            }
            if (data.hasOwnProperty('compositeMedia')) {
                obj['compositeMedia'] = ApiClient.convertToType(data['compositeMedia'], [CompositeMedia]);
            }
            if (data.hasOwnProperty('contentType')) {
                obj['contentType'] = ApiClient.convertToType(data['contentType'], 'String');
            }
            if (data.hasOwnProperty('contentTypeInfo')) {
                obj['contentTypeInfo'] = ContentTypeInfo.constructFromObject(data['contentTypeInfo']);
            }
            if (data.hasOwnProperty('cosmoBinaryReference')) {
                obj['cosmoBinaryReference'] = ApiClient.convertToType(data['cosmoBinaryReference'], 'Blob');
            }
            if (data.hasOwnProperty('crc32cHash')) {
                obj['crc32cHash'] = ApiClient.convertToType(data['crc32cHash'], 'Number');
            }
            if (data.hasOwnProperty('diffChecksumsResponse')) {
                obj['diffChecksumsResponse'] = DiffChecksumsResponse.constructFromObject(data['diffChecksumsResponse']);
            }
            if (data.hasOwnProperty('diffDownloadResponse')) {
                obj['diffDownloadResponse'] = DiffDownloadResponse.constructFromObject(data['diffDownloadResponse']);
            }
            if (data.hasOwnProperty('diffUploadRequest')) {
                obj['diffUploadRequest'] = DiffUploadRequest.constructFromObject(data['diffUploadRequest']);
            }
            if (data.hasOwnProperty('diffUploadResponse')) {
                obj['diffUploadResponse'] = DiffUploadResponse.constructFromObject(data['diffUploadResponse']);
            }
            if (data.hasOwnProperty('diffVersionResponse')) {
                obj['diffVersionResponse'] = DiffVersionResponse.constructFromObject(data['diffVersionResponse']);
            }
            if (data.hasOwnProperty('downloadParameters')) {
                obj['downloadParameters'] = DownloadParameters.constructFromObject(data['downloadParameters']);
            }
            if (data.hasOwnProperty('filename')) {
                obj['filename'] = ApiClient.convertToType(data['filename'], 'String');
            }
            if (data.hasOwnProperty('hash')) {
                obj['hash'] = ApiClient.convertToType(data['hash'], 'String');
            }
            if (data.hasOwnProperty('hashVerified')) {
                obj['hashVerified'] = ApiClient.convertToType(data['hashVerified'], 'Boolean');
            }
            if (data.hasOwnProperty('inline')) {
                obj['inline'] = ApiClient.convertToType(data['inline'], 'Blob');
            }
            if (data.hasOwnProperty('isPotentialRetry')) {
                obj['isPotentialRetry'] = ApiClient.convertToType(data['isPotentialRetry'], 'Boolean');
            }
            if (data.hasOwnProperty('length')) {
                obj['length'] = ApiClient.convertToType(data['length'], 'String');
            }
            if (data.hasOwnProperty('md5Hash')) {
                obj['md5Hash'] = ApiClient.convertToType(data['md5Hash'], 'Blob');
            }
            if (data.hasOwnProperty('mediaId')) {
                obj['mediaId'] = ApiClient.convertToType(data['mediaId'], 'Blob');
            }
            if (data.hasOwnProperty('objectId')) {
                obj['objectId'] = ObjectId.constructFromObject(data['objectId']);
            }
            if (data.hasOwnProperty('path')) {
                obj['path'] = ApiClient.convertToType(data['path'], 'String');
            }
            if (data.hasOwnProperty('referenceType')) {
                obj['referenceType'] = ApiClient.convertToType(data['referenceType'], 'String');
            }
            if (data.hasOwnProperty('sha1Hash')) {
                obj['sha1Hash'] = ApiClient.convertToType(data['sha1Hash'], 'Blob');
            }
            if (data.hasOwnProperty('sha256Hash')) {
                obj['sha256Hash'] = ApiClient.convertToType(data['sha256Hash'], 'Blob');
            }
            if (data.hasOwnProperty('timestamp')) {
                obj['timestamp'] = ApiClient.convertToType(data['timestamp'], 'String');
            }
            if (data.hasOwnProperty('token')) {
                obj['token'] = ApiClient.convertToType(data['token'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Media</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Media</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['algorithm'] && !(typeof data['algorithm'] === 'string' || data['algorithm'] instanceof String)) {
            throw new Error("Expected the field `algorithm` to be a primitive type in the JSON string but got " + data['algorithm']);
        }
        // validate the optional field `blobstore2Info`
        if (data['blobstore2Info']) { // data not null
          Blobstore2Info.validateJSON(data['blobstore2Info']);
        }
        if (data['compositeMedia']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['compositeMedia'])) {
                throw new Error("Expected the field `compositeMedia` to be an array in the JSON data but got " + data['compositeMedia']);
            }
            // validate the optional field `compositeMedia` (array)
            for (const item of data['compositeMedia']) {
                CompositeMedia.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['contentType'] && !(typeof data['contentType'] === 'string' || data['contentType'] instanceof String)) {
            throw new Error("Expected the field `contentType` to be a primitive type in the JSON string but got " + data['contentType']);
        }
        // validate the optional field `contentTypeInfo`
        if (data['contentTypeInfo']) { // data not null
          ContentTypeInfo.validateJSON(data['contentTypeInfo']);
        }
        // validate the optional field `diffChecksumsResponse`
        if (data['diffChecksumsResponse']) { // data not null
          DiffChecksumsResponse.validateJSON(data['diffChecksumsResponse']);
        }
        // validate the optional field `diffDownloadResponse`
        if (data['diffDownloadResponse']) { // data not null
          DiffDownloadResponse.validateJSON(data['diffDownloadResponse']);
        }
        // validate the optional field `diffUploadRequest`
        if (data['diffUploadRequest']) { // data not null
          DiffUploadRequest.validateJSON(data['diffUploadRequest']);
        }
        // validate the optional field `diffUploadResponse`
        if (data['diffUploadResponse']) { // data not null
          DiffUploadResponse.validateJSON(data['diffUploadResponse']);
        }
        // validate the optional field `diffVersionResponse`
        if (data['diffVersionResponse']) { // data not null
          DiffVersionResponse.validateJSON(data['diffVersionResponse']);
        }
        // validate the optional field `downloadParameters`
        if (data['downloadParameters']) { // data not null
          DownloadParameters.validateJSON(data['downloadParameters']);
        }
        // ensure the json data is a string
        if (data['filename'] && !(typeof data['filename'] === 'string' || data['filename'] instanceof String)) {
            throw new Error("Expected the field `filename` to be a primitive type in the JSON string but got " + data['filename']);
        }
        // ensure the json data is a string
        if (data['hash'] && !(typeof data['hash'] === 'string' || data['hash'] instanceof String)) {
            throw new Error("Expected the field `hash` to be a primitive type in the JSON string but got " + data['hash']);
        }
        // ensure the json data is a string
        if (data['length'] && !(typeof data['length'] === 'string' || data['length'] instanceof String)) {
            throw new Error("Expected the field `length` to be a primitive type in the JSON string but got " + data['length']);
        }
        // validate the optional field `objectId`
        if (data['objectId']) { // data not null
          ObjectId.validateJSON(data['objectId']);
        }
        // ensure the json data is a string
        if (data['path'] && !(typeof data['path'] === 'string' || data['path'] instanceof String)) {
            throw new Error("Expected the field `path` to be a primitive type in the JSON string but got " + data['path']);
        }
        // ensure the json data is a string
        if (data['referenceType'] && !(typeof data['referenceType'] === 'string' || data['referenceType'] instanceof String)) {
            throw new Error("Expected the field `referenceType` to be a primitive type in the JSON string but got " + data['referenceType']);
        }
        // ensure the json data is a string
        if (data['timestamp'] && !(typeof data['timestamp'] === 'string' || data['timestamp'] instanceof String)) {
            throw new Error("Expected the field `timestamp` to be a primitive type in the JSON string but got " + data['timestamp']);
        }
        // ensure the json data is a string
        if (data['token'] && !(typeof data['token'] === 'string' || data['token'] instanceof String)) {
            throw new Error("Expected the field `token` to be a primitive type in the JSON string but got " + data['token']);
        }

        return true;
    }


}



/**
 * Deprecated, use one of explicit hash type fields instead. Algorithm used for calculating the hash. As of 2011/01/21, \"MD5\" is the only possible value for this field. New values may be added at any time.
 * @member {String} algorithm
 */
Media.prototype['algorithm'] = undefined;

/**
 * Use object_id instead.
 * @member {Blob} bigstoreObjectRef
 */
Media.prototype['bigstoreObjectRef'] = undefined;

/**
 * Blobstore v1 reference, set if reference_type is BLOBSTORE_REF This should be the byte representation of a blobstore.BlobRef. Since Blobstore is deprecating v1, use blobstore2_info instead. For now, any v2 blob will also be represented in this field as v1 BlobRef.
 * @member {Blob} blobRef
 */
Media.prototype['blobRef'] = undefined;

/**
 * @member {module:model/Blobstore2Info} blobstore2Info
 */
Media.prototype['blobstore2Info'] = undefined;

/**
 * A composite media composed of one or more media objects, set if reference_type is COMPOSITE_MEDIA. The media length field must be set to the sum of the lengths of all composite media objects. Note: All composite media must have length specified.
 * @member {Array.<module:model/CompositeMedia>} compositeMedia
 */
Media.prototype['compositeMedia'] = undefined;

/**
 * MIME type of the data
 * @member {String} contentType
 */
Media.prototype['contentType'] = undefined;

/**
 * @member {module:model/ContentTypeInfo} contentTypeInfo
 */
Media.prototype['contentTypeInfo'] = undefined;

/**
 * A binary data reference for a media download. Serves as a technology-agnostic binary reference in some Google infrastructure. This value is a serialized storage_cosmo.BinaryReference proto. Storing it as bytes is a hack to get around the fact that the cosmo proto (as well as others it includes) doesn't support JavaScript. This prevents us from including the actual type of this field.
 * @member {Blob} cosmoBinaryReference
 */
Media.prototype['cosmoBinaryReference'] = undefined;

/**
 * For Scotty Uploads: Scotty-provided hashes for uploads For Scotty Downloads: (WARNING: DO NOT USE WITHOUT PERMISSION FROM THE SCOTTY TEAM.) A Hash provided by the agent to be used to verify the data being downloaded. Currently only supported for inline payloads. Further, only crc32c_hash is currently supported.
 * @member {Number} crc32cHash
 */
Media.prototype['crc32cHash'] = undefined;

/**
 * @member {module:model/DiffChecksumsResponse} diffChecksumsResponse
 */
Media.prototype['diffChecksumsResponse'] = undefined;

/**
 * @member {module:model/DiffDownloadResponse} diffDownloadResponse
 */
Media.prototype['diffDownloadResponse'] = undefined;

/**
 * @member {module:model/DiffUploadRequest} diffUploadRequest
 */
Media.prototype['diffUploadRequest'] = undefined;

/**
 * @member {module:model/DiffUploadResponse} diffUploadResponse
 */
Media.prototype['diffUploadResponse'] = undefined;

/**
 * @member {module:model/DiffVersionResponse} diffVersionResponse
 */
Media.prototype['diffVersionResponse'] = undefined;

/**
 * @member {module:model/DownloadParameters} downloadParameters
 */
Media.prototype['downloadParameters'] = undefined;

/**
 * Original file name
 * @member {String} filename
 */
Media.prototype['filename'] = undefined;

/**
 * Deprecated, use one of explicit hash type fields instead. These two hash related fields will only be populated on Scotty based media uploads and will contain the content of the hash group in the NotificationRequest: http://cs/#google3/uploader/service/proto/upload_listener.proto&q=class:Hash Hex encoded hash value of the uploaded media.
 * @member {String} hash
 */
Media.prototype['hash'] = undefined;

/**
 * For Scotty uploads only. If a user sends a hash code and the backend has requested that Scotty verify the upload against the client hash, Scotty will perform the check on behalf of the backend and will reject it if the hashes don't match. This is set to true if Scotty performed this verification.
 * @member {Boolean} hashVerified
 */
Media.prototype['hashVerified'] = undefined;

/**
 * Media data, set if reference_type is INLINE
 * @member {Blob} inline
 */
Media.prototype['inline'] = undefined;

/**
 * |is_potential_retry| is set false only when Scotty is certain that it has not sent the request before. When a client resumes an upload, this field must be set true in agent calls, because Scotty cannot be certain that it has never sent the request before due to potential failure in the session state persistence.
 * @member {Boolean} isPotentialRetry
 */
Media.prototype['isPotentialRetry'] = undefined;

/**
 * Size of the data, in bytes
 * @member {String} length
 */
Media.prototype['length'] = undefined;

/**
 * Scotty-provided MD5 hash for an upload.
 * @member {Blob} md5Hash
 */
Media.prototype['md5Hash'] = undefined;

/**
 * Media id to forward to the operation GetMedia. Can be set if reference_type is GET_MEDIA.
 * @member {Blob} mediaId
 */
Media.prototype['mediaId'] = undefined;

/**
 * @member {module:model/ObjectId} objectId
 */
Media.prototype['objectId'] = undefined;

/**
 * Path to the data, set if reference_type is PATH
 * @member {String} path
 */
Media.prototype['path'] = undefined;

/**
 * Describes what the field reference contains.
 * @member {module:model/Media.ReferenceTypeEnum} referenceType
 */
Media.prototype['referenceType'] = undefined;

/**
 * Scotty-provided SHA1 hash for an upload.
 * @member {Blob} sha1Hash
 */
Media.prototype['sha1Hash'] = undefined;

/**
 * Scotty-provided SHA256 hash for an upload.
 * @member {Blob} sha256Hash
 */
Media.prototype['sha256Hash'] = undefined;

/**
 * Time at which the media data was last updated, in milliseconds since UNIX epoch
 * @member {String} timestamp
 */
Media.prototype['timestamp'] = undefined;

/**
 * A unique fingerprint/version id for the media data
 * @member {String} token
 */
Media.prototype['token'] = undefined;





/**
 * Allowed values for the <code>referenceType</code> property.
 * @enum {String}
 * @readonly
 */
Media['ReferenceTypeEnum'] = {

    /**
     * value: "PATH"
     * @const
     */
    "PATH": "PATH",

    /**
     * value: "BLOB_REF"
     * @const
     */
    "BLOB_REF": "BLOB_REF",

    /**
     * value: "INLINE"
     * @const
     */
    "INLINE": "INLINE",

    /**
     * value: "GET_MEDIA"
     * @const
     */
    "GET_MEDIA": "GET_MEDIA",

    /**
     * value: "COMPOSITE_MEDIA"
     * @const
     */
    "COMPOSITE_MEDIA": "COMPOSITE_MEDIA",

    /**
     * value: "BIGSTORE_REF"
     * @const
     */
    "BIGSTORE_REF": "BIGSTORE_REF",

    /**
     * value: "DIFF_VERSION_RESPONSE"
     * @const
     */
    "DIFF_VERSION_RESPONSE": "DIFF_VERSION_RESPONSE",

    /**
     * value: "DIFF_CHECKSUMS_RESPONSE"
     * @const
     */
    "DIFF_CHECKSUMS_RESPONSE": "DIFF_CHECKSUMS_RESPONSE",

    /**
     * value: "DIFF_DOWNLOAD_RESPONSE"
     * @const
     */
    "DIFF_DOWNLOAD_RESPONSE": "DIFF_DOWNLOAD_RESPONSE",

    /**
     * value: "DIFF_UPLOAD_REQUEST"
     * @const
     */
    "DIFF_UPLOAD_REQUEST": "DIFF_UPLOAD_REQUEST",

    /**
     * value: "DIFF_UPLOAD_RESPONSE"
     * @const
     */
    "DIFF_UPLOAD_RESPONSE": "DIFF_UPLOAD_RESPONSE",

    /**
     * value: "COSMO_BINARY_REFERENCE"
     * @const
     */
    "COSMO_BINARY_REFERENCE": "COSMO_BINARY_REFERENCE",

    /**
     * value: "ARBITRARY_BYTES"
     * @const
     */
    "ARBITRARY_BYTES": "ARBITRARY_BYTES"
};



export default Media;

