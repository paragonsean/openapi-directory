/**
 * The Plaid API
 * The Plaid REST API. Please see https://plaid.com/docs/api for more details.
 *
 * The version of the OpenAPI document: 2020-09-14_1.345.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPlaidApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIPlaidApi::OAIPlaidApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIPlaidApi::~OAIPlaidApi() {
}

void OAIPlaidApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://production.plaid.com"),
    "Production",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://development.plaid.com"),
    "Development",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://sandbox.plaid.com"),
    "Sandbox",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("accountsBalanceGet", defaultConf);
    _serverIndices.insert("accountsBalanceGet", 0);
    _serverConfigs.insert("accountsGet", defaultConf);
    _serverIndices.insert("accountsGet", 0);
    _serverConfigs.insert("applicationGet", defaultConf);
    _serverIndices.insert("applicationGet", 0);
    _serverConfigs.insert("assetReportAuditCopyCreate", defaultConf);
    _serverIndices.insert("assetReportAuditCopyCreate", 0);
    _serverConfigs.insert("assetReportAuditCopyGet", defaultConf);
    _serverIndices.insert("assetReportAuditCopyGet", 0);
    _serverConfigs.insert("assetReportAuditCopyRemove", defaultConf);
    _serverIndices.insert("assetReportAuditCopyRemove", 0);
    _serverConfigs.insert("assetReportCreate", defaultConf);
    _serverIndices.insert("assetReportCreate", 0);
    _serverConfigs.insert("assetReportFilter", defaultConf);
    _serverIndices.insert("assetReportFilter", 0);
    _serverConfigs.insert("assetReportGet", defaultConf);
    _serverIndices.insert("assetReportGet", 0);
    _serverConfigs.insert("assetReportPdfGet", defaultConf);
    _serverIndices.insert("assetReportPdfGet", 0);
    _serverConfigs.insert("assetReportRefresh", defaultConf);
    _serverIndices.insert("assetReportRefresh", 0);
    _serverConfigs.insert("assetReportRemove", defaultConf);
    _serverIndices.insert("assetReportRemove", 0);
    _serverConfigs.insert("authGet", defaultConf);
    _serverIndices.insert("authGet", 0);
    _serverConfigs.insert("bankTransferBalanceGet", defaultConf);
    _serverIndices.insert("bankTransferBalanceGet", 0);
    _serverConfigs.insert("bankTransferCancel", defaultConf);
    _serverIndices.insert("bankTransferCancel", 0);
    _serverConfigs.insert("bankTransferCreate", defaultConf);
    _serverIndices.insert("bankTransferCreate", 0);
    _serverConfigs.insert("bankTransferEventList", defaultConf);
    _serverIndices.insert("bankTransferEventList", 0);
    _serverConfigs.insert("bankTransferEventSync", defaultConf);
    _serverIndices.insert("bankTransferEventSync", 0);
    _serverConfigs.insert("bankTransferGet", defaultConf);
    _serverIndices.insert("bankTransferGet", 0);
    _serverConfigs.insert("bankTransferList", defaultConf);
    _serverIndices.insert("bankTransferList", 0);
    _serverConfigs.insert("bankTransferMigrateAccount", defaultConf);
    _serverIndices.insert("bankTransferMigrateAccount", 0);
    _serverConfigs.insert("bankTransferSweepGet", defaultConf);
    _serverIndices.insert("bankTransferSweepGet", 0);
    _serverConfigs.insert("bankTransferSweepList", defaultConf);
    _serverIndices.insert("bankTransferSweepList", 0);
    _serverConfigs.insert("categoriesGet", defaultConf);
    _serverIndices.insert("categoriesGet", 0);
    _serverConfigs.insert("createPaymentToken", defaultConf);
    _serverIndices.insert("createPaymentToken", 0);
    _serverConfigs.insert("creditAssetReportFreddieMacGet", defaultConf);
    _serverIndices.insert("creditAssetReportFreddieMacGet", 0);
    _serverConfigs.insert("creditAuditCopyTokenCreate", defaultConf);
    _serverIndices.insert("creditAuditCopyTokenCreate", 0);
    _serverConfigs.insert("creditAuditCopyTokenUpdate", defaultConf);
    _serverIndices.insert("creditAuditCopyTokenUpdate", 0);
    _serverConfigs.insert("creditBankEmploymentGet", defaultConf);
    _serverIndices.insert("creditBankEmploymentGet", 0);
    _serverConfigs.insert("creditBankIncomeGet", defaultConf);
    _serverIndices.insert("creditBankIncomeGet", 0);
    _serverConfigs.insert("creditBankIncomePdfGet", defaultConf);
    _serverIndices.insert("creditBankIncomePdfGet", 0);
    _serverConfigs.insert("creditBankIncomeRefresh", defaultConf);
    _serverIndices.insert("creditBankIncomeRefresh", 0);
    _serverConfigs.insert("creditEmploymentGet", defaultConf);
    _serverIndices.insert("creditEmploymentGet", 0);
    _serverConfigs.insert("creditFreddieMacReportsGet", defaultConf);
    _serverIndices.insert("creditFreddieMacReportsGet", 0);
    _serverConfigs.insert("creditPayrollIncomeGet", defaultConf);
    _serverIndices.insert("creditPayrollIncomeGet", 0);
    _serverConfigs.insert("creditPayrollIncomePrecheck", defaultConf);
    _serverIndices.insert("creditPayrollIncomePrecheck", 0);
    _serverConfigs.insert("creditPayrollIncomeRefresh", defaultConf);
    _serverIndices.insert("creditPayrollIncomeRefresh", 0);
    _serverConfigs.insert("creditRelayCreate", defaultConf);
    _serverIndices.insert("creditRelayCreate", 0);
    _serverConfigs.insert("creditRelayGet", defaultConf);
    _serverIndices.insert("creditRelayGet", 0);
    _serverConfigs.insert("creditRelayRefresh", defaultConf);
    _serverIndices.insert("creditRelayRefresh", 0);
    _serverConfigs.insert("creditRelayRemove", defaultConf);
    _serverIndices.insert("creditRelayRemove", 0);
    _serverConfigs.insert("creditReportAuditCopyRemove", defaultConf);
    _serverIndices.insert("creditReportAuditCopyRemove", 0);
    _serverConfigs.insert("creditSessionsGet", defaultConf);
    _serverIndices.insert("creditSessionsGet", 0);
    _serverConfigs.insert("dashboardUserGet", defaultConf);
    _serverIndices.insert("dashboardUserGet", 0);
    _serverConfigs.insert("dashboardUserList", defaultConf);
    _serverIndices.insert("dashboardUserList", 0);
    _serverConfigs.insert("depositSwitchAltCreate", defaultConf);
    _serverIndices.insert("depositSwitchAltCreate", 0);
    _serverConfigs.insert("depositSwitchCreate", defaultConf);
    _serverIndices.insert("depositSwitchCreate", 0);
    _serverConfigs.insert("depositSwitchGet", defaultConf);
    _serverIndices.insert("depositSwitchGet", 0);
    _serverConfigs.insert("depositSwitchTokenCreate", defaultConf);
    _serverIndices.insert("depositSwitchTokenCreate", 0);
    _serverConfigs.insert("employersSearch", defaultConf);
    _serverIndices.insert("employersSearch", 0);
    _serverConfigs.insert("employmentVerificationGet", defaultConf);
    _serverIndices.insert("employmentVerificationGet", 0);
    _serverConfigs.insert("fdxNotifications", defaultConf);
    _serverIndices.insert("fdxNotifications", 0);
    _serverConfigs.insert("identityGet", defaultConf);
    _serverIndices.insert("identityGet", 0);
    _serverConfigs.insert("identityMatch", defaultConf);
    _serverIndices.insert("identityMatch", 0);
    _serverConfigs.insert("identityVerificationCreate", defaultConf);
    _serverIndices.insert("identityVerificationCreate", 0);
    _serverConfigs.insert("identityVerificationGet", defaultConf);
    _serverIndices.insert("identityVerificationGet", 0);
    _serverConfigs.insert("identityVerificationList", defaultConf);
    _serverIndices.insert("identityVerificationList", 0);
    _serverConfigs.insert("identityVerificationRetry", defaultConf);
    _serverIndices.insert("identityVerificationRetry", 0);
    _serverConfigs.insert("incomeVerificationCreate", defaultConf);
    _serverIndices.insert("incomeVerificationCreate", 0);
    _serverConfigs.insert("incomeVerificationDocumentsDownload", defaultConf);
    _serverIndices.insert("incomeVerificationDocumentsDownload", 0);
    _serverConfigs.insert("incomeVerificationPaystubsGet", defaultConf);
    _serverIndices.insert("incomeVerificationPaystubsGet", 0);
    _serverConfigs.insert("incomeVerificationPrecheck", defaultConf);
    _serverIndices.insert("incomeVerificationPrecheck", 0);
    _serverConfigs.insert("incomeVerificationTaxformsGet", defaultConf);
    _serverIndices.insert("incomeVerificationTaxformsGet", 0);
    _serverConfigs.insert("institutionsGet", defaultConf);
    _serverIndices.insert("institutionsGet", 0);
    _serverConfigs.insert("institutionsGetById", defaultConf);
    _serverIndices.insert("institutionsGetById", 0);
    _serverConfigs.insert("institutionsSearch", defaultConf);
    _serverIndices.insert("institutionsSearch", 0);
    _serverConfigs.insert("investmentsHoldingsGet", defaultConf);
    _serverIndices.insert("investmentsHoldingsGet", 0);
    _serverConfigs.insert("investmentsTransactionsGet", defaultConf);
    _serverIndices.insert("investmentsTransactionsGet", 0);
    _serverConfigs.insert("itemAccessTokenInvalidate", defaultConf);
    _serverIndices.insert("itemAccessTokenInvalidate", 0);
    _serverConfigs.insert("itemActivityList", defaultConf);
    _serverIndices.insert("itemActivityList", 0);
    _serverConfigs.insert("itemApplicationList", defaultConf);
    _serverIndices.insert("itemApplicationList", 0);
    _serverConfigs.insert("itemApplicationScopesUpdate", defaultConf);
    _serverIndices.insert("itemApplicationScopesUpdate", 0);
    _serverConfigs.insert("itemCreatePublicToken", defaultConf);
    _serverIndices.insert("itemCreatePublicToken", 0);
    _serverConfigs.insert("itemGet", defaultConf);
    _serverIndices.insert("itemGet", 0);
    _serverConfigs.insert("itemImport", defaultConf);
    _serverIndices.insert("itemImport", 0);
    _serverConfigs.insert("itemPublicTokenExchange", defaultConf);
    _serverIndices.insert("itemPublicTokenExchange", 0);
    _serverConfigs.insert("itemRemove", defaultConf);
    _serverIndices.insert("itemRemove", 0);
    _serverConfigs.insert("itemWebhookUpdate", defaultConf);
    _serverIndices.insert("itemWebhookUpdate", 0);
    _serverConfigs.insert("liabilitiesGet", defaultConf);
    _serverIndices.insert("liabilitiesGet", 0);
    _serverConfigs.insert("linkDeliveryCreate", defaultConf);
    _serverIndices.insert("linkDeliveryCreate", 0);
    _serverConfigs.insert("linkDeliveryGet", defaultConf);
    _serverIndices.insert("linkDeliveryGet", 0);
    _serverConfigs.insert("linkOauthCorrelationIdExchange", defaultConf);
    _serverIndices.insert("linkOauthCorrelationIdExchange", 0);
    _serverConfigs.insert("linkTokenCreate", defaultConf);
    _serverIndices.insert("linkTokenCreate", 0);
    _serverConfigs.insert("linkTokenGet", defaultConf);
    _serverIndices.insert("linkTokenGet", 0);
    _serverConfigs.insert("partnerCustomerCreate", defaultConf);
    _serverIndices.insert("partnerCustomerCreate", 0);
    _serverConfigs.insert("partnerCustomerEnable", defaultConf);
    _serverIndices.insert("partnerCustomerEnable", 0);
    _serverConfigs.insert("partnerCustomerGet", defaultConf);
    _serverIndices.insert("partnerCustomerGet", 0);
    _serverConfigs.insert("partnerCustomerOauthInstitutionsGet", defaultConf);
    _serverIndices.insert("partnerCustomerOauthInstitutionsGet", 0);
    _serverConfigs.insert("partnerCustomerRemove", defaultConf);
    _serverIndices.insert("partnerCustomerRemove", 0);
    _serverConfigs.insert("paymentInitiationConsentCreate", defaultConf);
    _serverIndices.insert("paymentInitiationConsentCreate", 0);
    _serverConfigs.insert("paymentInitiationConsentGet", defaultConf);
    _serverIndices.insert("paymentInitiationConsentGet", 0);
    _serverConfigs.insert("paymentInitiationConsentPaymentExecute", defaultConf);
    _serverIndices.insert("paymentInitiationConsentPaymentExecute", 0);
    _serverConfigs.insert("paymentInitiationConsentRevoke", defaultConf);
    _serverIndices.insert("paymentInitiationConsentRevoke", 0);
    _serverConfigs.insert("paymentInitiationPaymentCreate", defaultConf);
    _serverIndices.insert("paymentInitiationPaymentCreate", 0);
    _serverConfigs.insert("paymentInitiationPaymentGet", defaultConf);
    _serverIndices.insert("paymentInitiationPaymentGet", 0);
    _serverConfigs.insert("paymentInitiationPaymentList", defaultConf);
    _serverIndices.insert("paymentInitiationPaymentList", 0);
    _serverConfigs.insert("paymentInitiationPaymentReverse", defaultConf);
    _serverIndices.insert("paymentInitiationPaymentReverse", 0);
    _serverConfigs.insert("paymentInitiationRecipientCreate", defaultConf);
    _serverIndices.insert("paymentInitiationRecipientCreate", 0);
    _serverConfigs.insert("paymentInitiationRecipientGet", defaultConf);
    _serverIndices.insert("paymentInitiationRecipientGet", 0);
    _serverConfigs.insert("paymentInitiationRecipientList", defaultConf);
    _serverIndices.insert("paymentInitiationRecipientList", 0);
    _serverConfigs.insert("paymentProfileCreate", defaultConf);
    _serverIndices.insert("paymentProfileCreate", 0);
    _serverConfigs.insert("paymentProfileGet", defaultConf);
    _serverIndices.insert("paymentProfileGet", 0);
    _serverConfigs.insert("paymentProfileRemove", defaultConf);
    _serverIndices.insert("paymentProfileRemove", 0);
    _serverConfigs.insert("processorApexProcessorTokenCreate", defaultConf);
    _serverIndices.insert("processorApexProcessorTokenCreate", 0);
    _serverConfigs.insert("processorAuthGet", defaultConf);
    _serverIndices.insert("processorAuthGet", 0);
    _serverConfigs.insert("processorBalanceGet", defaultConf);
    _serverIndices.insert("processorBalanceGet", 0);
    _serverConfigs.insert("processorBankTransferCreate", defaultConf);
    _serverIndices.insert("processorBankTransferCreate", 0);
    _serverConfigs.insert("processorIdentityGet", defaultConf);
    _serverIndices.insert("processorIdentityGet", 0);
    _serverConfigs.insert("processorSignalDecisionReport", defaultConf);
    _serverIndices.insert("processorSignalDecisionReport", 0);
    _serverConfigs.insert("processorSignalEvaluate", defaultConf);
    _serverIndices.insert("processorSignalEvaluate", 0);
    _serverConfigs.insert("processorSignalReturnReport", defaultConf);
    _serverIndices.insert("processorSignalReturnReport", 0);
    _serverConfigs.insert("processorStripeBankAccountTokenCreate", defaultConf);
    _serverIndices.insert("processorStripeBankAccountTokenCreate", 0);
    _serverConfigs.insert("processorTokenCreate", defaultConf);
    _serverIndices.insert("processorTokenCreate", 0);
    _serverConfigs.insert("sandboxBankTransferFireWebhook", defaultConf);
    _serverIndices.insert("sandboxBankTransferFireWebhook", 0);
    _serverConfigs.insert("sandboxBankTransferSimulate", defaultConf);
    _serverIndices.insert("sandboxBankTransferSimulate", 0);
    _serverConfigs.insert("sandboxIncomeFireWebhook", defaultConf);
    _serverIndices.insert("sandboxIncomeFireWebhook", 0);
    _serverConfigs.insert("sandboxItemFireWebhook", defaultConf);
    _serverIndices.insert("sandboxItemFireWebhook", 0);
    _serverConfigs.insert("sandboxItemResetLogin", defaultConf);
    _serverIndices.insert("sandboxItemResetLogin", 0);
    _serverConfigs.insert("sandboxItemSetVerificationStatus", defaultConf);
    _serverIndices.insert("sandboxItemSetVerificationStatus", 0);
    _serverConfigs.insert("sandboxOauthSelectAccounts", defaultConf);
    _serverIndices.insert("sandboxOauthSelectAccounts", 0);
    _serverConfigs.insert("sandboxPaymentProfileResetLogin", defaultConf);
    _serverIndices.insert("sandboxPaymentProfileResetLogin", 0);
    _serverConfigs.insert("sandboxProcessorTokenCreate", defaultConf);
    _serverIndices.insert("sandboxProcessorTokenCreate", 0);
    _serverConfigs.insert("sandboxPublicTokenCreate", defaultConf);
    _serverIndices.insert("sandboxPublicTokenCreate", 0);
    _serverConfigs.insert("sandboxTransferFireWebhook", defaultConf);
    _serverIndices.insert("sandboxTransferFireWebhook", 0);
    _serverConfigs.insert("sandboxTransferRepaymentSimulate", defaultConf);
    _serverIndices.insert("sandboxTransferRepaymentSimulate", 0);
    _serverConfigs.insert("sandboxTransferSimulate", defaultConf);
    _serverIndices.insert("sandboxTransferSimulate", 0);
    _serverConfigs.insert("sandboxTransferSweepSimulate", defaultConf);
    _serverIndices.insert("sandboxTransferSweepSimulate", 0);
    _serverConfigs.insert("sandboxTransferTestClockAdvance", defaultConf);
    _serverIndices.insert("sandboxTransferTestClockAdvance", 0);
    _serverConfigs.insert("sandboxTransferTestClockCreate", defaultConf);
    _serverIndices.insert("sandboxTransferTestClockCreate", 0);
    _serverConfigs.insert("sandboxTransferTestClockGet", defaultConf);
    _serverIndices.insert("sandboxTransferTestClockGet", 0);
    _serverConfigs.insert("sandboxTransferTestClockList", defaultConf);
    _serverIndices.insert("sandboxTransferTestClockList", 0);
    _serverConfigs.insert("signalDecisionReport", defaultConf);
    _serverIndices.insert("signalDecisionReport", 0);
    _serverConfigs.insert("signalEvaluate", defaultConf);
    _serverIndices.insert("signalEvaluate", 0);
    _serverConfigs.insert("signalPrepare", defaultConf);
    _serverIndices.insert("signalPrepare", 0);
    _serverConfigs.insert("signalReturnReport", defaultConf);
    _serverIndices.insert("signalReturnReport", 0);
    _serverConfigs.insert("transactionsEnhance", defaultConf);
    _serverIndices.insert("transactionsEnhance", 0);
    _serverConfigs.insert("transactionsEnrich", defaultConf);
    _serverIndices.insert("transactionsEnrich", 0);
    _serverConfigs.insert("transactionsGet", defaultConf);
    _serverIndices.insert("transactionsGet", 0);
    _serverConfigs.insert("transactionsRecurringGet", defaultConf);
    _serverIndices.insert("transactionsRecurringGet", 0);
    _serverConfigs.insert("transactionsRefresh", defaultConf);
    _serverIndices.insert("transactionsRefresh", 0);
    _serverConfigs.insert("transactionsRulesCreate", defaultConf);
    _serverIndices.insert("transactionsRulesCreate", 0);
    _serverConfigs.insert("transactionsRulesList", defaultConf);
    _serverIndices.insert("transactionsRulesList", 0);
    _serverConfigs.insert("transactionsRulesRemove", defaultConf);
    _serverIndices.insert("transactionsRulesRemove", 0);
    _serverConfigs.insert("transactionsSync", defaultConf);
    _serverIndices.insert("transactionsSync", 0);
    _serverConfigs.insert("transferAuthorizationCreate", defaultConf);
    _serverIndices.insert("transferAuthorizationCreate", 0);
    _serverConfigs.insert("transferCancel", defaultConf);
    _serverIndices.insert("transferCancel", 0);
    _serverConfigs.insert("transferCapabilitiesGet", defaultConf);
    _serverIndices.insert("transferCapabilitiesGet", 0);
    _serverConfigs.insert("transferConfigurationGet", defaultConf);
    _serverIndices.insert("transferConfigurationGet", 0);
    _serverConfigs.insert("transferCreate", defaultConf);
    _serverIndices.insert("transferCreate", 0);
    _serverConfigs.insert("transferEventList", defaultConf);
    _serverIndices.insert("transferEventList", 0);
    _serverConfigs.insert("transferEventSync", defaultConf);
    _serverIndices.insert("transferEventSync", 0);
    _serverConfigs.insert("transferGet", defaultConf);
    _serverIndices.insert("transferGet", 0);
    _serverConfigs.insert("transferIntentCreate", defaultConf);
    _serverIndices.insert("transferIntentCreate", 0);
    _serverConfigs.insert("transferIntentGet", defaultConf);
    _serverIndices.insert("transferIntentGet", 0);
    _serverConfigs.insert("transferList", defaultConf);
    _serverIndices.insert("transferList", 0);
    _serverConfigs.insert("transferMetricsGet", defaultConf);
    _serverIndices.insert("transferMetricsGet", 0);
    _serverConfigs.insert("transferMigrateAccount", defaultConf);
    _serverIndices.insert("transferMigrateAccount", 0);
    _serverConfigs.insert("transferOriginatorCreate", defaultConf);
    _serverIndices.insert("transferOriginatorCreate", 0);
    _serverConfigs.insert("transferOriginatorGet", defaultConf);
    _serverIndices.insert("transferOriginatorGet", 0);
    _serverConfigs.insert("transferOriginatorList", defaultConf);
    _serverIndices.insert("transferOriginatorList", 0);
    _serverConfigs.insert("transferQuestionnaireCreate", defaultConf);
    _serverIndices.insert("transferQuestionnaireCreate", 0);
    _serverConfigs.insert("transferRecurringCancel", defaultConf);
    _serverIndices.insert("transferRecurringCancel", 0);
    _serverConfigs.insert("transferRecurringCreate", defaultConf);
    _serverIndices.insert("transferRecurringCreate", 0);
    _serverConfigs.insert("transferRecurringGet", defaultConf);
    _serverIndices.insert("transferRecurringGet", 0);
    _serverConfigs.insert("transferRecurringList", defaultConf);
    _serverIndices.insert("transferRecurringList", 0);
    _serverConfigs.insert("transferRefundCancel", defaultConf);
    _serverIndices.insert("transferRefundCancel", 0);
    _serverConfigs.insert("transferRefundCreate", defaultConf);
    _serverIndices.insert("transferRefundCreate", 0);
    _serverConfigs.insert("transferRefundGet", defaultConf);
    _serverIndices.insert("transferRefundGet", 0);
    _serverConfigs.insert("transferRepaymentList", defaultConf);
    _serverIndices.insert("transferRepaymentList", 0);
    _serverConfigs.insert("transferRepaymentReturnList", defaultConf);
    _serverIndices.insert("transferRepaymentReturnList", 0);
    _serverConfigs.insert("transferSweepGet", defaultConf);
    _serverIndices.insert("transferSweepGet", 0);
    _serverConfigs.insert("transferSweepList", defaultConf);
    _serverIndices.insert("transferSweepList", 0);
    _serverConfigs.insert("userCreate", defaultConf);
    _serverIndices.insert("userCreate", 0);
    _serverConfigs.insert("walletCreate", defaultConf);
    _serverIndices.insert("walletCreate", 0);
    _serverConfigs.insert("walletGet", defaultConf);
    _serverIndices.insert("walletGet", 0);
    _serverConfigs.insert("walletList", defaultConf);
    _serverIndices.insert("walletList", 0);
    _serverConfigs.insert("walletTransactionExecute", defaultConf);
    _serverIndices.insert("walletTransactionExecute", 0);
    _serverConfigs.insert("walletTransactionGet", defaultConf);
    _serverIndices.insert("walletTransactionGet", 0);
    _serverConfigs.insert("walletTransactionList", defaultConf);
    _serverIndices.insert("walletTransactionList", 0);
    _serverConfigs.insert("watchlistScreeningEntityCreate", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityCreate", 0);
    _serverConfigs.insert("watchlistScreeningEntityGet", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityGet", 0);
    _serverConfigs.insert("watchlistScreeningEntityHistoryList", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityHistoryList", 0);
    _serverConfigs.insert("watchlistScreeningEntityHitList", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityHitList", 0);
    _serverConfigs.insert("watchlistScreeningEntityList", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityList", 0);
    _serverConfigs.insert("watchlistScreeningEntityProgramGet", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityProgramGet", 0);
    _serverConfigs.insert("watchlistScreeningEntityProgramList", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityProgramList", 0);
    _serverConfigs.insert("watchlistScreeningEntityReviewCreate", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityReviewCreate", 0);
    _serverConfigs.insert("watchlistScreeningEntityReviewList", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityReviewList", 0);
    _serverConfigs.insert("watchlistScreeningEntityUpdate", defaultConf);
    _serverIndices.insert("watchlistScreeningEntityUpdate", 0);
    _serverConfigs.insert("watchlistScreeningIndividualCreate", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualCreate", 0);
    _serverConfigs.insert("watchlistScreeningIndividualGet", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualGet", 0);
    _serverConfigs.insert("watchlistScreeningIndividualHistoryList", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualHistoryList", 0);
    _serverConfigs.insert("watchlistScreeningIndividualHitList", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualHitList", 0);
    _serverConfigs.insert("watchlistScreeningIndividualList", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualList", 0);
    _serverConfigs.insert("watchlistScreeningIndividualProgramGet", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualProgramGet", 0);
    _serverConfigs.insert("watchlistScreeningIndividualProgramList", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualProgramList", 0);
    _serverConfigs.insert("watchlistScreeningIndividualReviewCreate", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualReviewCreate", 0);
    _serverConfigs.insert("watchlistScreeningIndividualReviewList", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualReviewList", 0);
    _serverConfigs.insert("watchlistScreeningIndividualUpdate", defaultConf);
    _serverIndices.insert("watchlistScreeningIndividualUpdate", 0);
    _serverConfigs.insert("webhookVerificationKeyGet", defaultConf);
    _serverIndices.insert("webhookVerificationKeyGet", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIPlaidApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIPlaidApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIPlaidApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIPlaidApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIPlaidApi::setUsername(const QString &username) {
    _username = username;
}

void OAIPlaidApi::setPassword(const QString &password) {
    _password = password;
}


void OAIPlaidApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIPlaidApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIPlaidApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIPlaidApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIPlaidApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIPlaidApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIPlaidApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIPlaidApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIPlaidApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIPlaidApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIPlaidApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIPlaidApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIPlaidApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIPlaidApi::accountsBalanceGet(const OAIAccountsBalanceGetRequest &oai_accounts_balance_get_request) {
    QString fullPath = QString(_serverConfigs["accountsBalanceGet"][_serverIndices.value("accountsBalanceGet")].URL()+"/accounts/balance/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_accounts_balance_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::accountsBalanceGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::accountsBalanceGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAccountsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT accountsBalanceGetSignal(output);
        Q_EMIT accountsBalanceGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT accountsBalanceGetSignalE(output, error_type, error_str);
        Q_EMIT accountsBalanceGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT accountsBalanceGetSignalError(output, error_type, error_str);
        Q_EMIT accountsBalanceGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::accountsGet(const OAIAccountsGetRequest &oai_accounts_get_request) {
    QString fullPath = QString(_serverConfigs["accountsGet"][_serverIndices.value("accountsGet")].URL()+"/accounts/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_accounts_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::accountsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::accountsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAccountsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT accountsGetSignal(output);
        Q_EMIT accountsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT accountsGetSignalE(output, error_type, error_str);
        Q_EMIT accountsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT accountsGetSignalError(output, error_type, error_str);
        Q_EMIT accountsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::applicationGet(const OAIApplicationGetRequest &oai_application_get_request) {
    QString fullPath = QString(_serverConfigs["applicationGet"][_serverIndices.value("applicationGet")].URL()+"/application/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_application_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::applicationGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::applicationGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT applicationGetSignal(output);
        Q_EMIT applicationGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT applicationGetSignalE(output, error_type, error_str);
        Q_EMIT applicationGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT applicationGetSignalError(output, error_type, error_str);
        Q_EMIT applicationGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportAuditCopyCreate(const OAIAssetReportAuditCopyCreateRequest &oai_asset_report_audit_copy_create_request) {
    QString fullPath = QString(_serverConfigs["assetReportAuditCopyCreate"][_serverIndices.value("assetReportAuditCopyCreate")].URL()+"/asset_report/audit_copy/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_audit_copy_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportAuditCopyCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportAuditCopyCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportAuditCopyCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportAuditCopyCreateSignal(output);
        Q_EMIT assetReportAuditCopyCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportAuditCopyCreateSignalE(output, error_type, error_str);
        Q_EMIT assetReportAuditCopyCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportAuditCopyCreateSignalError(output, error_type, error_str);
        Q_EMIT assetReportAuditCopyCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportAuditCopyGet(const OAIAssetReportAuditCopyGetRequest &oai_asset_report_audit_copy_get_request) {
    QString fullPath = QString(_serverConfigs["assetReportAuditCopyGet"][_serverIndices.value("assetReportAuditCopyGet")].URL()+"/asset_report/audit_copy/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_audit_copy_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportAuditCopyGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportAuditCopyGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportAuditCopyGetSignal(output);
        Q_EMIT assetReportAuditCopyGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportAuditCopyGetSignalE(output, error_type, error_str);
        Q_EMIT assetReportAuditCopyGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportAuditCopyGetSignalError(output, error_type, error_str);
        Q_EMIT assetReportAuditCopyGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportAuditCopyRemove(const OAIAssetReportAuditCopyRemoveRequest &oai_asset_report_audit_copy_remove_request) {
    QString fullPath = QString(_serverConfigs["assetReportAuditCopyRemove"][_serverIndices.value("assetReportAuditCopyRemove")].URL()+"/asset_report/audit_copy/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_audit_copy_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportAuditCopyRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportAuditCopyRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportAuditCopyRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportAuditCopyRemoveSignal(output);
        Q_EMIT assetReportAuditCopyRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportAuditCopyRemoveSignalE(output, error_type, error_str);
        Q_EMIT assetReportAuditCopyRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportAuditCopyRemoveSignalError(output, error_type, error_str);
        Q_EMIT assetReportAuditCopyRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportCreate(const OAIAssetReportCreateRequest &oai_asset_report_create_request) {
    QString fullPath = QString(_serverConfigs["assetReportCreate"][_serverIndices.value("assetReportCreate")].URL()+"/asset_report/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportCreateSignal(output);
        Q_EMIT assetReportCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportCreateSignalE(output, error_type, error_str);
        Q_EMIT assetReportCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportCreateSignalError(output, error_type, error_str);
        Q_EMIT assetReportCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportFilter(const OAIAssetReportFilterRequest &oai_asset_report_filter_request) {
    QString fullPath = QString(_serverConfigs["assetReportFilter"][_serverIndices.value("assetReportFilter")].URL()+"/asset_report/filter");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_filter_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportFilterCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportFilterCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportFilterResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportFilterSignal(output);
        Q_EMIT assetReportFilterSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportFilterSignalE(output, error_type, error_str);
        Q_EMIT assetReportFilterSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportFilterSignalError(output, error_type, error_str);
        Q_EMIT assetReportFilterSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportGet(const OAIAssetReportGetRequest &oai_asset_report_get_request) {
    QString fullPath = QString(_serverConfigs["assetReportGet"][_serverIndices.value("assetReportGet")].URL()+"/asset_report/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportGetSignal(output);
        Q_EMIT assetReportGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportGetSignalE(output, error_type, error_str);
        Q_EMIT assetReportGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportGetSignalError(output, error_type, error_str);
        Q_EMIT assetReportGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportPdfGet(const OAIAssetReportPDFGetRequest &oai_asset_report_pdf_get_request) {
    QString fullPath = QString(_serverConfigs["assetReportPdfGet"][_serverIndices.value("assetReportPdfGet")].URL()+"/asset_report/pdf/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_pdf_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportPdfGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportPdfGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportPdfGetSignal(output);
        Q_EMIT assetReportPdfGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportPdfGetSignalE(output, error_type, error_str);
        Q_EMIT assetReportPdfGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportPdfGetSignalError(output, error_type, error_str);
        Q_EMIT assetReportPdfGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportRefresh(const OAIAssetReportRefreshRequest &oai_asset_report_refresh_request) {
    QString fullPath = QString(_serverConfigs["assetReportRefresh"][_serverIndices.value("assetReportRefresh")].URL()+"/asset_report/refresh");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_refresh_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportRefreshCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportRefreshCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportRefreshResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportRefreshSignal(output);
        Q_EMIT assetReportRefreshSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportRefreshSignalE(output, error_type, error_str);
        Q_EMIT assetReportRefreshSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportRefreshSignalError(output, error_type, error_str);
        Q_EMIT assetReportRefreshSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::assetReportRemove(const OAIAssetReportRemoveRequest &oai_asset_report_remove_request) {
    QString fullPath = QString(_serverConfigs["assetReportRemove"][_serverIndices.value("assetReportRemove")].URL()+"/asset_report/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::assetReportRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::assetReportRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT assetReportRemoveSignal(output);
        Q_EMIT assetReportRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT assetReportRemoveSignalE(output, error_type, error_str);
        Q_EMIT assetReportRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT assetReportRemoveSignalError(output, error_type, error_str);
        Q_EMIT assetReportRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::authGet(const OAIAuthGetRequest &oai_auth_get_request) {
    QString fullPath = QString(_serverConfigs["authGet"][_serverIndices.value("authGet")].URL()+"/auth/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_auth_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::authGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::authGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAuthGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT authGetSignal(output);
        Q_EMIT authGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT authGetSignalE(output, error_type, error_str);
        Q_EMIT authGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT authGetSignalError(output, error_type, error_str);
        Q_EMIT authGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferBalanceGet(const OAIBankTransferBalanceGetRequest &oai_bank_transfer_balance_get_request) {
    QString fullPath = QString(_serverConfigs["bankTransferBalanceGet"][_serverIndices.value("bankTransferBalanceGet")].URL()+"/bank_transfer/balance/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_balance_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferBalanceGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferBalanceGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferBalanceGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferBalanceGetSignal(output);
        Q_EMIT bankTransferBalanceGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferBalanceGetSignalE(output, error_type, error_str);
        Q_EMIT bankTransferBalanceGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferBalanceGetSignalError(output, error_type, error_str);
        Q_EMIT bankTransferBalanceGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferCancel(const OAIBankTransferCancelRequest &oai_bank_transfer_cancel_request) {
    QString fullPath = QString(_serverConfigs["bankTransferCancel"][_serverIndices.value("bankTransferCancel")].URL()+"/bank_transfer/cancel");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_cancel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferCancelCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferCancelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferCancelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferCancelSignal(output);
        Q_EMIT bankTransferCancelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferCancelSignalE(output, error_type, error_str);
        Q_EMIT bankTransferCancelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferCancelSignalError(output, error_type, error_str);
        Q_EMIT bankTransferCancelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferCreate(const OAIBankTransferCreateRequest &oai_bank_transfer_create_request) {
    QString fullPath = QString(_serverConfigs["bankTransferCreate"][_serverIndices.value("bankTransferCreate")].URL()+"/bank_transfer/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferCreateSignal(output);
        Q_EMIT bankTransferCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferCreateSignalE(output, error_type, error_str);
        Q_EMIT bankTransferCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferCreateSignalError(output, error_type, error_str);
        Q_EMIT bankTransferCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferEventList(const OAIBankTransferEventListRequest &oai_bank_transfer_event_list_request) {
    QString fullPath = QString(_serverConfigs["bankTransferEventList"][_serverIndices.value("bankTransferEventList")].URL()+"/bank_transfer/event/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_event_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferEventListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferEventListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferEventListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferEventListSignal(output);
        Q_EMIT bankTransferEventListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferEventListSignalE(output, error_type, error_str);
        Q_EMIT bankTransferEventListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferEventListSignalError(output, error_type, error_str);
        Q_EMIT bankTransferEventListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferEventSync(const OAIBankTransferEventSyncRequest &oai_bank_transfer_event_sync_request) {
    QString fullPath = QString(_serverConfigs["bankTransferEventSync"][_serverIndices.value("bankTransferEventSync")].URL()+"/bank_transfer/event/sync");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_event_sync_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferEventSyncCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferEventSyncCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferEventSyncResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferEventSyncSignal(output);
        Q_EMIT bankTransferEventSyncSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferEventSyncSignalE(output, error_type, error_str);
        Q_EMIT bankTransferEventSyncSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferEventSyncSignalError(output, error_type, error_str);
        Q_EMIT bankTransferEventSyncSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferGet(const OAIBankTransferGetRequest &oai_bank_transfer_get_request) {
    QString fullPath = QString(_serverConfigs["bankTransferGet"][_serverIndices.value("bankTransferGet")].URL()+"/bank_transfer/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferGetSignal(output);
        Q_EMIT bankTransferGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferGetSignalE(output, error_type, error_str);
        Q_EMIT bankTransferGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferGetSignalError(output, error_type, error_str);
        Q_EMIT bankTransferGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferList(const OAIBankTransferListRequest &oai_bank_transfer_list_request) {
    QString fullPath = QString(_serverConfigs["bankTransferList"][_serverIndices.value("bankTransferList")].URL()+"/bank_transfer/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferListSignal(output);
        Q_EMIT bankTransferListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferListSignalE(output, error_type, error_str);
        Q_EMIT bankTransferListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferListSignalError(output, error_type, error_str);
        Q_EMIT bankTransferListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferMigrateAccount(const OAIBankTransferMigrateAccountRequest &oai_bank_transfer_migrate_account_request) {
    QString fullPath = QString(_serverConfigs["bankTransferMigrateAccount"][_serverIndices.value("bankTransferMigrateAccount")].URL()+"/bank_transfer/migrate_account");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_migrate_account_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferMigrateAccountCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferMigrateAccountCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferMigrateAccountResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferMigrateAccountSignal(output);
        Q_EMIT bankTransferMigrateAccountSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferMigrateAccountSignalE(output, error_type, error_str);
        Q_EMIT bankTransferMigrateAccountSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferMigrateAccountSignalError(output, error_type, error_str);
        Q_EMIT bankTransferMigrateAccountSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferSweepGet(const OAIBankTransferSweepGetRequest &oai_bank_transfer_sweep_get_request) {
    QString fullPath = QString(_serverConfigs["bankTransferSweepGet"][_serverIndices.value("bankTransferSweepGet")].URL()+"/bank_transfer/sweep/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_sweep_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferSweepGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferSweepGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferSweepGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferSweepGetSignal(output);
        Q_EMIT bankTransferSweepGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferSweepGetSignalE(output, error_type, error_str);
        Q_EMIT bankTransferSweepGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferSweepGetSignalError(output, error_type, error_str);
        Q_EMIT bankTransferSweepGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::bankTransferSweepList(const OAIBankTransferSweepListRequest &oai_bank_transfer_sweep_list_request) {
    QString fullPath = QString(_serverConfigs["bankTransferSweepList"][_serverIndices.value("bankTransferSweepList")].URL()+"/bank_transfer/sweep/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bank_transfer_sweep_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::bankTransferSweepListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::bankTransferSweepListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBankTransferSweepListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bankTransferSweepListSignal(output);
        Q_EMIT bankTransferSweepListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bankTransferSweepListSignalE(output, error_type, error_str);
        Q_EMIT bankTransferSweepListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bankTransferSweepListSignalError(output, error_type, error_str);
        Q_EMIT bankTransferSweepListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::categoriesGet(const OAIObject &body) {
    QString fullPath = QString(_serverConfigs["categoriesGet"][_serverIndices.value("categoriesGet")].URL()+"/categories/get");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::categoriesGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::categoriesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICategoriesGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT categoriesGetSignal(output);
        Q_EMIT categoriesGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT categoriesGetSignalE(output, error_type, error_str);
        Q_EMIT categoriesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT categoriesGetSignalError(output, error_type, error_str);
        Q_EMIT categoriesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::createPaymentToken(const OAIPaymentInitiationPaymentTokenCreateRequest &oai_payment_initiation_payment_token_create_request) {
    QString fullPath = QString(_serverConfigs["createPaymentToken"][_serverIndices.value("createPaymentToken")].URL()+"/payment_initiation/payment/token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_payment_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::createPaymentTokenCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::createPaymentTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationPaymentTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createPaymentTokenSignal(output);
        Q_EMIT createPaymentTokenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createPaymentTokenSignalE(output, error_type, error_str);
        Q_EMIT createPaymentTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createPaymentTokenSignalError(output, error_type, error_str);
        Q_EMIT createPaymentTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditAssetReportFreddieMacGet(const OAIAssetReportFreddieGetRequest &oai_asset_report_freddie_get_request) {
    QString fullPath = QString(_serverConfigs["creditAssetReportFreddieMacGet"][_serverIndices.value("creditAssetReportFreddieMacGet")].URL()+"/credit/asset_report/freddie_mac/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_asset_report_freddie_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditAssetReportFreddieMacGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditAssetReportFreddieMacGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportFreddieGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditAssetReportFreddieMacGetSignal(output);
        Q_EMIT creditAssetReportFreddieMacGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditAssetReportFreddieMacGetSignalE(output, error_type, error_str);
        Q_EMIT creditAssetReportFreddieMacGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditAssetReportFreddieMacGetSignalError(output, error_type, error_str);
        Q_EMIT creditAssetReportFreddieMacGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditAuditCopyTokenCreate(const OAICreditAuditCopyTokenCreateRequest &oai_credit_audit_copy_token_create_request) {
    QString fullPath = QString(_serverConfigs["creditAuditCopyTokenCreate"][_serverIndices.value("creditAuditCopyTokenCreate")].URL()+"/credit/audit_copy_token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_audit_copy_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditAuditCopyTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditAuditCopyTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditAuditCopyTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditAuditCopyTokenCreateSignal(output);
        Q_EMIT creditAuditCopyTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditAuditCopyTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT creditAuditCopyTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditAuditCopyTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT creditAuditCopyTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditAuditCopyTokenUpdate(const OAICreditAuditCopyTokenUpdateRequest &oai_credit_audit_copy_token_update_request) {
    QString fullPath = QString(_serverConfigs["creditAuditCopyTokenUpdate"][_serverIndices.value("creditAuditCopyTokenUpdate")].URL()+"/credit/audit_copy_token/update");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_audit_copy_token_update_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditAuditCopyTokenUpdateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditAuditCopyTokenUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditAuditCopyTokenUpdateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditAuditCopyTokenUpdateSignal(output);
        Q_EMIT creditAuditCopyTokenUpdateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditAuditCopyTokenUpdateSignalE(output, error_type, error_str);
        Q_EMIT creditAuditCopyTokenUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditAuditCopyTokenUpdateSignalError(output, error_type, error_str);
        Q_EMIT creditAuditCopyTokenUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditBankEmploymentGet(const OAICreditBankEmploymentGetRequest &oai_credit_bank_employment_get_request) {
    QString fullPath = QString(_serverConfigs["creditBankEmploymentGet"][_serverIndices.value("creditBankEmploymentGet")].URL()+"/beta/credit/v1/bank_employment/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_bank_employment_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditBankEmploymentGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditBankEmploymentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditBankEmploymentGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditBankEmploymentGetSignal(output);
        Q_EMIT creditBankEmploymentGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditBankEmploymentGetSignalE(output, error_type, error_str);
        Q_EMIT creditBankEmploymentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditBankEmploymentGetSignalError(output, error_type, error_str);
        Q_EMIT creditBankEmploymentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditBankIncomeGet(const OAICreditBankIncomeGetRequest &oai_credit_bank_income_get_request) {
    QString fullPath = QString(_serverConfigs["creditBankIncomeGet"][_serverIndices.value("creditBankIncomeGet")].URL()+"/credit/bank_income/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_bank_income_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditBankIncomeGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditBankIncomeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditBankIncomeGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditBankIncomeGetSignal(output);
        Q_EMIT creditBankIncomeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditBankIncomeGetSignalE(output, error_type, error_str);
        Q_EMIT creditBankIncomeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditBankIncomeGetSignalError(output, error_type, error_str);
        Q_EMIT creditBankIncomeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditBankIncomePdfGet(const OAICreditBankIncomePDFGetRequest &oai_credit_bank_income_pdf_get_request) {
    QString fullPath = QString(_serverConfigs["creditBankIncomePdfGet"][_serverIndices.value("creditBankIncomePdfGet")].URL()+"/credit/bank_income/pdf/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_bank_income_pdf_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditBankIncomePdfGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditBankIncomePdfGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditBankIncomePdfGetSignal(output);
        Q_EMIT creditBankIncomePdfGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditBankIncomePdfGetSignalE(output, error_type, error_str);
        Q_EMIT creditBankIncomePdfGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditBankIncomePdfGetSignalError(output, error_type, error_str);
        Q_EMIT creditBankIncomePdfGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditBankIncomeRefresh(const OAICreditBankIncomeRefreshRequest &oai_credit_bank_income_refresh_request) {
    QString fullPath = QString(_serverConfigs["creditBankIncomeRefresh"][_serverIndices.value("creditBankIncomeRefresh")].URL()+"/credit/bank_income/refresh");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_bank_income_refresh_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditBankIncomeRefreshCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditBankIncomeRefreshCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditBankIncomeRefreshResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditBankIncomeRefreshSignal(output);
        Q_EMIT creditBankIncomeRefreshSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditBankIncomeRefreshSignalE(output, error_type, error_str);
        Q_EMIT creditBankIncomeRefreshSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditBankIncomeRefreshSignalError(output, error_type, error_str);
        Q_EMIT creditBankIncomeRefreshSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditEmploymentGet(const OAICreditEmploymentGetRequest &oai_credit_employment_get_request) {
    QString fullPath = QString(_serverConfigs["creditEmploymentGet"][_serverIndices.value("creditEmploymentGet")].URL()+"/credit/employment/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_employment_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditEmploymentGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditEmploymentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditEmploymentGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditEmploymentGetSignal(output);
        Q_EMIT creditEmploymentGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditEmploymentGetSignalE(output, error_type, error_str);
        Q_EMIT creditEmploymentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditEmploymentGetSignalError(output, error_type, error_str);
        Q_EMIT creditEmploymentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditFreddieMacReportsGet(const OAICreditFreddieMacReportsGetRequest &oai_credit_freddie_mac_reports_get_request) {
    QString fullPath = QString(_serverConfigs["creditFreddieMacReportsGet"][_serverIndices.value("creditFreddieMacReportsGet")].URL()+"/credit/freddie_mac/reports/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_freddie_mac_reports_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditFreddieMacReportsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditFreddieMacReportsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditFreddieMacReportsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditFreddieMacReportsGetSignal(output);
        Q_EMIT creditFreddieMacReportsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditFreddieMacReportsGetSignalE(output, error_type, error_str);
        Q_EMIT creditFreddieMacReportsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditFreddieMacReportsGetSignalError(output, error_type, error_str);
        Q_EMIT creditFreddieMacReportsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditPayrollIncomeGet(const OAICreditPayrollIncomeGetRequest &oai_credit_payroll_income_get_request) {
    QString fullPath = QString(_serverConfigs["creditPayrollIncomeGet"][_serverIndices.value("creditPayrollIncomeGet")].URL()+"/credit/payroll_income/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_payroll_income_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditPayrollIncomeGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditPayrollIncomeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditPayrollIncomeGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditPayrollIncomeGetSignal(output);
        Q_EMIT creditPayrollIncomeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditPayrollIncomeGetSignalE(output, error_type, error_str);
        Q_EMIT creditPayrollIncomeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditPayrollIncomeGetSignalError(output, error_type, error_str);
        Q_EMIT creditPayrollIncomeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditPayrollIncomePrecheck(const OAICreditPayrollIncomePrecheckRequest &oai_credit_payroll_income_precheck_request) {
    QString fullPath = QString(_serverConfigs["creditPayrollIncomePrecheck"][_serverIndices.value("creditPayrollIncomePrecheck")].URL()+"/credit/payroll_income/precheck");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_payroll_income_precheck_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditPayrollIncomePrecheckCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditPayrollIncomePrecheckCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditPayrollIncomePrecheckResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditPayrollIncomePrecheckSignal(output);
        Q_EMIT creditPayrollIncomePrecheckSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditPayrollIncomePrecheckSignalE(output, error_type, error_str);
        Q_EMIT creditPayrollIncomePrecheckSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditPayrollIncomePrecheckSignalError(output, error_type, error_str);
        Q_EMIT creditPayrollIncomePrecheckSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditPayrollIncomeRefresh(const OAICreditPayrollIncomeRefreshRequest &oai_credit_payroll_income_refresh_request) {
    QString fullPath = QString(_serverConfigs["creditPayrollIncomeRefresh"][_serverIndices.value("creditPayrollIncomeRefresh")].URL()+"/credit/payroll_income/refresh");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_payroll_income_refresh_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditPayrollIncomeRefreshCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditPayrollIncomeRefreshCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditPayrollIncomeRefreshResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditPayrollIncomeRefreshSignal(output);
        Q_EMIT creditPayrollIncomeRefreshSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditPayrollIncomeRefreshSignalE(output, error_type, error_str);
        Q_EMIT creditPayrollIncomeRefreshSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditPayrollIncomeRefreshSignalError(output, error_type, error_str);
        Q_EMIT creditPayrollIncomeRefreshSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditRelayCreate(const OAICreditRelayCreateRequest &oai_credit_relay_create_request) {
    QString fullPath = QString(_serverConfigs["creditRelayCreate"][_serverIndices.value("creditRelayCreate")].URL()+"/credit/relay/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_relay_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditRelayCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditRelayCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditRelayCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditRelayCreateSignal(output);
        Q_EMIT creditRelayCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditRelayCreateSignalE(output, error_type, error_str);
        Q_EMIT creditRelayCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditRelayCreateSignalError(output, error_type, error_str);
        Q_EMIT creditRelayCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditRelayGet(const OAICreditRelayGetRequest &oai_credit_relay_get_request) {
    QString fullPath = QString(_serverConfigs["creditRelayGet"][_serverIndices.value("creditRelayGet")].URL()+"/credit/relay/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_relay_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditRelayGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditRelayGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAssetReportGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditRelayGetSignal(output);
        Q_EMIT creditRelayGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditRelayGetSignalE(output, error_type, error_str);
        Q_EMIT creditRelayGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditRelayGetSignalError(output, error_type, error_str);
        Q_EMIT creditRelayGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditRelayRefresh(const OAICreditRelayRefreshRequest &oai_credit_relay_refresh_request) {
    QString fullPath = QString(_serverConfigs["creditRelayRefresh"][_serverIndices.value("creditRelayRefresh")].URL()+"/credit/relay/refresh");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_relay_refresh_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditRelayRefreshCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditRelayRefreshCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditRelayRefreshResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditRelayRefreshSignal(output);
        Q_EMIT creditRelayRefreshSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditRelayRefreshSignalE(output, error_type, error_str);
        Q_EMIT creditRelayRefreshSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditRelayRefreshSignalError(output, error_type, error_str);
        Q_EMIT creditRelayRefreshSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditRelayRemove(const OAICreditRelayRemoveRequest &oai_credit_relay_remove_request) {
    QString fullPath = QString(_serverConfigs["creditRelayRemove"][_serverIndices.value("creditRelayRemove")].URL()+"/credit/relay/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_relay_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditRelayRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditRelayRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditRelayRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditRelayRemoveSignal(output);
        Q_EMIT creditRelayRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditRelayRemoveSignalE(output, error_type, error_str);
        Q_EMIT creditRelayRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditRelayRemoveSignalError(output, error_type, error_str);
        Q_EMIT creditRelayRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditReportAuditCopyRemove(const OAICreditAuditCopyTokenRemoveRequest &oai_credit_audit_copy_token_remove_request) {
    QString fullPath = QString(_serverConfigs["creditReportAuditCopyRemove"][_serverIndices.value("creditReportAuditCopyRemove")].URL()+"/credit/audit_copy_token/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_audit_copy_token_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditReportAuditCopyRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditReportAuditCopyRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditAuditCopyTokenRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditReportAuditCopyRemoveSignal(output);
        Q_EMIT creditReportAuditCopyRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditReportAuditCopyRemoveSignalE(output, error_type, error_str);
        Q_EMIT creditReportAuditCopyRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditReportAuditCopyRemoveSignalError(output, error_type, error_str);
        Q_EMIT creditReportAuditCopyRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::creditSessionsGet(const OAICreditSessionsGetRequest &oai_credit_sessions_get_request) {
    QString fullPath = QString(_serverConfigs["creditSessionsGet"][_serverIndices.value("creditSessionsGet")].URL()+"/credit/sessions/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_credit_sessions_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::creditSessionsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::creditSessionsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreditSessionsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT creditSessionsGetSignal(output);
        Q_EMIT creditSessionsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT creditSessionsGetSignalE(output, error_type, error_str);
        Q_EMIT creditSessionsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT creditSessionsGetSignalError(output, error_type, error_str);
        Q_EMIT creditSessionsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::dashboardUserGet(const OAIDashboardUserGetRequest &oai_dashboard_user_get_request) {
    QString fullPath = QString(_serverConfigs["dashboardUserGet"][_serverIndices.value("dashboardUserGet")].URL()+"/dashboard_user/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dashboard_user_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::dashboardUserGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::dashboardUserGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDashboardUserGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dashboardUserGetSignal(output);
        Q_EMIT dashboardUserGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dashboardUserGetSignalE(output, error_type, error_str);
        Q_EMIT dashboardUserGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dashboardUserGetSignalError(output, error_type, error_str);
        Q_EMIT dashboardUserGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::dashboardUserList(const OAIDashboardUserListRequest &oai_dashboard_user_list_request) {
    QString fullPath = QString(_serverConfigs["dashboardUserList"][_serverIndices.value("dashboardUserList")].URL()+"/dashboard_user/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_dashboard_user_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::dashboardUserListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::dashboardUserListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDashboardUserListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dashboardUserListSignal(output);
        Q_EMIT dashboardUserListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dashboardUserListSignalE(output, error_type, error_str);
        Q_EMIT dashboardUserListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dashboardUserListSignalError(output, error_type, error_str);
        Q_EMIT dashboardUserListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::depositSwitchAltCreate(const OAIDepositSwitchAltCreateRequest &oai_deposit_switch_alt_create_request) {
    QString fullPath = QString(_serverConfigs["depositSwitchAltCreate"][_serverIndices.value("depositSwitchAltCreate")].URL()+"/deposit_switch/alt/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_deposit_switch_alt_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::depositSwitchAltCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::depositSwitchAltCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDepositSwitchAltCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT depositSwitchAltCreateSignal(output);
        Q_EMIT depositSwitchAltCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT depositSwitchAltCreateSignalE(output, error_type, error_str);
        Q_EMIT depositSwitchAltCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT depositSwitchAltCreateSignalError(output, error_type, error_str);
        Q_EMIT depositSwitchAltCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::depositSwitchCreate(const OAIDepositSwitchCreateRequest &oai_deposit_switch_create_request) {
    QString fullPath = QString(_serverConfigs["depositSwitchCreate"][_serverIndices.value("depositSwitchCreate")].URL()+"/deposit_switch/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_deposit_switch_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::depositSwitchCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::depositSwitchCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDepositSwitchCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT depositSwitchCreateSignal(output);
        Q_EMIT depositSwitchCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT depositSwitchCreateSignalE(output, error_type, error_str);
        Q_EMIT depositSwitchCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT depositSwitchCreateSignalError(output, error_type, error_str);
        Q_EMIT depositSwitchCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::depositSwitchGet(const OAIDepositSwitchGetRequest &oai_deposit_switch_get_request) {
    QString fullPath = QString(_serverConfigs["depositSwitchGet"][_serverIndices.value("depositSwitchGet")].URL()+"/deposit_switch/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_deposit_switch_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::depositSwitchGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::depositSwitchGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDepositSwitchGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT depositSwitchGetSignal(output);
        Q_EMIT depositSwitchGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT depositSwitchGetSignalE(output, error_type, error_str);
        Q_EMIT depositSwitchGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT depositSwitchGetSignalError(output, error_type, error_str);
        Q_EMIT depositSwitchGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::depositSwitchTokenCreate(const OAIDepositSwitchTokenCreateRequest &oai_deposit_switch_token_create_request) {
    QString fullPath = QString(_serverConfigs["depositSwitchTokenCreate"][_serverIndices.value("depositSwitchTokenCreate")].URL()+"/deposit_switch/token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_deposit_switch_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::depositSwitchTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::depositSwitchTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDepositSwitchTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT depositSwitchTokenCreateSignal(output);
        Q_EMIT depositSwitchTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT depositSwitchTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT depositSwitchTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT depositSwitchTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT depositSwitchTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::employersSearch(const OAIEmployersSearchRequest &oai_employers_search_request) {
    QString fullPath = QString(_serverConfigs["employersSearch"][_serverIndices.value("employersSearch")].URL()+"/employers/search");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_employers_search_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::employersSearchCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::employersSearchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmployersSearchResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT employersSearchSignal(output);
        Q_EMIT employersSearchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT employersSearchSignalE(output, error_type, error_str);
        Q_EMIT employersSearchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT employersSearchSignalError(output, error_type, error_str);
        Q_EMIT employersSearchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::employmentVerificationGet(const OAIEmploymentVerificationGetRequest &oai_employment_verification_get_request) {
    QString fullPath = QString(_serverConfigs["employmentVerificationGet"][_serverIndices.value("employmentVerificationGet")].URL()+"/employment/verification/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_employment_verification_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::employmentVerificationGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::employmentVerificationGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmploymentVerificationGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT employmentVerificationGetSignal(output);
        Q_EMIT employmentVerificationGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT employmentVerificationGetSignalE(output, error_type, error_str);
        Q_EMIT employmentVerificationGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT employmentVerificationGetSignalError(output, error_type, error_str);
        Q_EMIT employmentVerificationGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::fdxNotifications(const OAIFDXNotification &oaifdx_notification) {
    QString fullPath = QString(_serverConfigs["fdxNotifications"][_serverIndices.value("fdxNotifications")].URL()+"/fdx/notifications");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oaifdx_notification.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::fdxNotificationsCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::fdxNotificationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT fdxNotificationsSignal();
        Q_EMIT fdxNotificationsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT fdxNotificationsSignalE(error_type, error_str);
        Q_EMIT fdxNotificationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT fdxNotificationsSignalError(error_type, error_str);
        Q_EMIT fdxNotificationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::identityGet(const OAIIdentityGetRequest &oai_identity_get_request) {
    QString fullPath = QString(_serverConfigs["identityGet"][_serverIndices.value("identityGet")].URL()+"/identity/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_identity_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::identityGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::identityGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentityGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT identityGetSignal(output);
        Q_EMIT identityGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT identityGetSignalE(output, error_type, error_str);
        Q_EMIT identityGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT identityGetSignalError(output, error_type, error_str);
        Q_EMIT identityGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::identityMatch(const OAIIdentityMatchRequest &oai_identity_match_request) {
    QString fullPath = QString(_serverConfigs["identityMatch"][_serverIndices.value("identityMatch")].URL()+"/identity/match");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_identity_match_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::identityMatchCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::identityMatchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentityMatchResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT identityMatchSignal(output);
        Q_EMIT identityMatchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT identityMatchSignalE(output, error_type, error_str);
        Q_EMIT identityMatchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT identityMatchSignalError(output, error_type, error_str);
        Q_EMIT identityMatchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::identityVerificationCreate(const OAIIdentityVerificationCreateRequest &oai_identity_verification_create_request) {
    QString fullPath = QString(_serverConfigs["identityVerificationCreate"][_serverIndices.value("identityVerificationCreate")].URL()+"/identity_verification/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_identity_verification_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::identityVerificationCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::identityVerificationCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentityVerificationCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT identityVerificationCreateSignal(output);
        Q_EMIT identityVerificationCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT identityVerificationCreateSignalE(output, error_type, error_str);
        Q_EMIT identityVerificationCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT identityVerificationCreateSignalError(output, error_type, error_str);
        Q_EMIT identityVerificationCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::identityVerificationGet(const OAIIdentityVerificationGetRequest &oai_identity_verification_get_request) {
    QString fullPath = QString(_serverConfigs["identityVerificationGet"][_serverIndices.value("identityVerificationGet")].URL()+"/identity_verification/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_identity_verification_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::identityVerificationGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::identityVerificationGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentityVerificationGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT identityVerificationGetSignal(output);
        Q_EMIT identityVerificationGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT identityVerificationGetSignalE(output, error_type, error_str);
        Q_EMIT identityVerificationGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT identityVerificationGetSignalError(output, error_type, error_str);
        Q_EMIT identityVerificationGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::identityVerificationList(const OAIIdentityVerificationListRequest &oai_identity_verification_list_request) {
    QString fullPath = QString(_serverConfigs["identityVerificationList"][_serverIndices.value("identityVerificationList")].URL()+"/identity_verification/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_identity_verification_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::identityVerificationListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::identityVerificationListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentityVerificationListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT identityVerificationListSignal(output);
        Q_EMIT identityVerificationListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT identityVerificationListSignalE(output, error_type, error_str);
        Q_EMIT identityVerificationListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT identityVerificationListSignalError(output, error_type, error_str);
        Q_EMIT identityVerificationListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::identityVerificationRetry(const OAIIdentityVerificationRetryRequest &oai_identity_verification_retry_request) {
    QString fullPath = QString(_serverConfigs["identityVerificationRetry"][_serverIndices.value("identityVerificationRetry")].URL()+"/identity_verification/retry");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_identity_verification_retry_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::identityVerificationRetryCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::identityVerificationRetryCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIdentityVerificationRetryResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT identityVerificationRetrySignal(output);
        Q_EMIT identityVerificationRetrySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT identityVerificationRetrySignalE(output, error_type, error_str);
        Q_EMIT identityVerificationRetrySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT identityVerificationRetrySignalError(output, error_type, error_str);
        Q_EMIT identityVerificationRetrySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::incomeVerificationCreate(const OAIIncomeVerificationCreateRequest &oai_income_verification_create_request) {
    QString fullPath = QString(_serverConfigs["incomeVerificationCreate"][_serverIndices.value("incomeVerificationCreate")].URL()+"/income/verification/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_income_verification_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::incomeVerificationCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::incomeVerificationCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIncomeVerificationCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT incomeVerificationCreateSignal(output);
        Q_EMIT incomeVerificationCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT incomeVerificationCreateSignalE(output, error_type, error_str);
        Q_EMIT incomeVerificationCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT incomeVerificationCreateSignalError(output, error_type, error_str);
        Q_EMIT incomeVerificationCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::incomeVerificationDocumentsDownload(const OAIIncomeVerificationDocumentsDownloadRequest &oai_income_verification_documents_download_request) {
    QString fullPath = QString(_serverConfigs["incomeVerificationDocumentsDownload"][_serverIndices.value("incomeVerificationDocumentsDownload")].URL()+"/income/verification/documents/download");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_income_verification_documents_download_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::incomeVerificationDocumentsDownloadCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::incomeVerificationDocumentsDownloadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT incomeVerificationDocumentsDownloadSignal(output);
        Q_EMIT incomeVerificationDocumentsDownloadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT incomeVerificationDocumentsDownloadSignalE(output, error_type, error_str);
        Q_EMIT incomeVerificationDocumentsDownloadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT incomeVerificationDocumentsDownloadSignalError(output, error_type, error_str);
        Q_EMIT incomeVerificationDocumentsDownloadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::incomeVerificationPaystubsGet(const OAIIncomeVerificationPaystubsGetRequest &oai_income_verification_paystubs_get_request) {
    QString fullPath = QString(_serverConfigs["incomeVerificationPaystubsGet"][_serverIndices.value("incomeVerificationPaystubsGet")].URL()+"/income/verification/paystubs/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_income_verification_paystubs_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::incomeVerificationPaystubsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::incomeVerificationPaystubsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIncomeVerificationPaystubsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT incomeVerificationPaystubsGetSignal(output);
        Q_EMIT incomeVerificationPaystubsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT incomeVerificationPaystubsGetSignalE(output, error_type, error_str);
        Q_EMIT incomeVerificationPaystubsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT incomeVerificationPaystubsGetSignalError(output, error_type, error_str);
        Q_EMIT incomeVerificationPaystubsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::incomeVerificationPrecheck(const OAIIncomeVerificationPrecheckRequest &oai_income_verification_precheck_request) {
    QString fullPath = QString(_serverConfigs["incomeVerificationPrecheck"][_serverIndices.value("incomeVerificationPrecheck")].URL()+"/income/verification/precheck");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_income_verification_precheck_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::incomeVerificationPrecheckCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::incomeVerificationPrecheckCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIncomeVerificationPrecheckResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT incomeVerificationPrecheckSignal(output);
        Q_EMIT incomeVerificationPrecheckSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT incomeVerificationPrecheckSignalE(output, error_type, error_str);
        Q_EMIT incomeVerificationPrecheckSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT incomeVerificationPrecheckSignalError(output, error_type, error_str);
        Q_EMIT incomeVerificationPrecheckSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::incomeVerificationTaxformsGet(const OAIIncomeVerificationTaxformsGetRequest &oai_income_verification_taxforms_get_request) {
    QString fullPath = QString(_serverConfigs["incomeVerificationTaxformsGet"][_serverIndices.value("incomeVerificationTaxformsGet")].URL()+"/income/verification/taxforms/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_income_verification_taxforms_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::incomeVerificationTaxformsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::incomeVerificationTaxformsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIncomeVerificationTaxformsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT incomeVerificationTaxformsGetSignal(output);
        Q_EMIT incomeVerificationTaxformsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT incomeVerificationTaxformsGetSignalE(output, error_type, error_str);
        Q_EMIT incomeVerificationTaxformsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT incomeVerificationTaxformsGetSignalError(output, error_type, error_str);
        Q_EMIT incomeVerificationTaxformsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::institutionsGet(const OAIInstitutionsGetRequest &oai_institutions_get_request) {
    QString fullPath = QString(_serverConfigs["institutionsGet"][_serverIndices.value("institutionsGet")].URL()+"/institutions/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_institutions_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::institutionsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::institutionsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIInstitutionsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT institutionsGetSignal(output);
        Q_EMIT institutionsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT institutionsGetSignalE(output, error_type, error_str);
        Q_EMIT institutionsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT institutionsGetSignalError(output, error_type, error_str);
        Q_EMIT institutionsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::institutionsGetById(const OAIInstitutionsGetByIdRequest &oai_institutions_get_by_id_request) {
    QString fullPath = QString(_serverConfigs["institutionsGetById"][_serverIndices.value("institutionsGetById")].URL()+"/institutions/get_by_id");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_institutions_get_by_id_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::institutionsGetByIdCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::institutionsGetByIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIInstitutionsGetByIdResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT institutionsGetByIdSignal(output);
        Q_EMIT institutionsGetByIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT institutionsGetByIdSignalE(output, error_type, error_str);
        Q_EMIT institutionsGetByIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT institutionsGetByIdSignalError(output, error_type, error_str);
        Q_EMIT institutionsGetByIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::institutionsSearch(const OAIInstitutionsSearchRequest &oai_institutions_search_request) {
    QString fullPath = QString(_serverConfigs["institutionsSearch"][_serverIndices.value("institutionsSearch")].URL()+"/institutions/search");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_institutions_search_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::institutionsSearchCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::institutionsSearchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIInstitutionsSearchResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT institutionsSearchSignal(output);
        Q_EMIT institutionsSearchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT institutionsSearchSignalE(output, error_type, error_str);
        Q_EMIT institutionsSearchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT institutionsSearchSignalError(output, error_type, error_str);
        Q_EMIT institutionsSearchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::investmentsHoldingsGet(const OAIInvestmentsHoldingsGetRequest &oai_investments_holdings_get_request) {
    QString fullPath = QString(_serverConfigs["investmentsHoldingsGet"][_serverIndices.value("investmentsHoldingsGet")].URL()+"/investments/holdings/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_investments_holdings_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::investmentsHoldingsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::investmentsHoldingsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIInvestmentsHoldingsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT investmentsHoldingsGetSignal(output);
        Q_EMIT investmentsHoldingsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT investmentsHoldingsGetSignalE(output, error_type, error_str);
        Q_EMIT investmentsHoldingsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT investmentsHoldingsGetSignalError(output, error_type, error_str);
        Q_EMIT investmentsHoldingsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::investmentsTransactionsGet(const OAIInvestmentsTransactionsGetRequest &oai_investments_transactions_get_request) {
    QString fullPath = QString(_serverConfigs["investmentsTransactionsGet"][_serverIndices.value("investmentsTransactionsGet")].URL()+"/investments/transactions/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_investments_transactions_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::investmentsTransactionsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::investmentsTransactionsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIInvestmentsTransactionsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT investmentsTransactionsGetSignal(output);
        Q_EMIT investmentsTransactionsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT investmentsTransactionsGetSignalE(output, error_type, error_str);
        Q_EMIT investmentsTransactionsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT investmentsTransactionsGetSignalError(output, error_type, error_str);
        Q_EMIT investmentsTransactionsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemAccessTokenInvalidate(const OAIItemAccessTokenInvalidateRequest &oai_item_access_token_invalidate_request) {
    QString fullPath = QString(_serverConfigs["itemAccessTokenInvalidate"][_serverIndices.value("itemAccessTokenInvalidate")].URL()+"/item/access_token/invalidate");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_access_token_invalidate_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemAccessTokenInvalidateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemAccessTokenInvalidateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemAccessTokenInvalidateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemAccessTokenInvalidateSignal(output);
        Q_EMIT itemAccessTokenInvalidateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemAccessTokenInvalidateSignalE(output, error_type, error_str);
        Q_EMIT itemAccessTokenInvalidateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemAccessTokenInvalidateSignalError(output, error_type, error_str);
        Q_EMIT itemAccessTokenInvalidateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemActivityList(const OAIItemActivityListRequest &oai_item_activity_list_request) {
    QString fullPath = QString(_serverConfigs["itemActivityList"][_serverIndices.value("itemActivityList")].URL()+"/item/activity/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_activity_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemActivityListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemActivityListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemActivityListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemActivityListSignal(output);
        Q_EMIT itemActivityListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemActivityListSignalE(output, error_type, error_str);
        Q_EMIT itemActivityListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemActivityListSignalError(output, error_type, error_str);
        Q_EMIT itemActivityListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemApplicationList(const OAIItemApplicationListRequest &oai_item_application_list_request) {
    QString fullPath = QString(_serverConfigs["itemApplicationList"][_serverIndices.value("itemApplicationList")].URL()+"/item/application/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_application_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemApplicationListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemApplicationListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemApplicationListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemApplicationListSignal(output);
        Q_EMIT itemApplicationListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemApplicationListSignalE(output, error_type, error_str);
        Q_EMIT itemApplicationListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemApplicationListSignalError(output, error_type, error_str);
        Q_EMIT itemApplicationListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemApplicationScopesUpdate(const OAIItemApplicationScopesUpdateRequest &oai_item_application_scopes_update_request) {
    QString fullPath = QString(_serverConfigs["itemApplicationScopesUpdate"][_serverIndices.value("itemApplicationScopesUpdate")].URL()+"/item/application/scopes/update");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_application_scopes_update_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemApplicationScopesUpdateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemApplicationScopesUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemApplicationScopesUpdateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemApplicationScopesUpdateSignal(output);
        Q_EMIT itemApplicationScopesUpdateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemApplicationScopesUpdateSignalE(output, error_type, error_str);
        Q_EMIT itemApplicationScopesUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemApplicationScopesUpdateSignalError(output, error_type, error_str);
        Q_EMIT itemApplicationScopesUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemCreatePublicToken(const OAIItemPublicTokenCreateRequest &oai_item_public_token_create_request) {
    QString fullPath = QString(_serverConfigs["itemCreatePublicToken"][_serverIndices.value("itemCreatePublicToken")].URL()+"/item/public_token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_public_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemCreatePublicTokenCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemCreatePublicTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemPublicTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemCreatePublicTokenSignal(output);
        Q_EMIT itemCreatePublicTokenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemCreatePublicTokenSignalE(output, error_type, error_str);
        Q_EMIT itemCreatePublicTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemCreatePublicTokenSignalError(output, error_type, error_str);
        Q_EMIT itemCreatePublicTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemGet(const OAIItemGetRequest &oai_item_get_request) {
    QString fullPath = QString(_serverConfigs["itemGet"][_serverIndices.value("itemGet")].URL()+"/item/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemGetSignal(output);
        Q_EMIT itemGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemGetSignalE(output, error_type, error_str);
        Q_EMIT itemGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemGetSignalError(output, error_type, error_str);
        Q_EMIT itemGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemImport(const OAIItemImportRequest &oai_item_import_request) {
    QString fullPath = QString(_serverConfigs["itemImport"][_serverIndices.value("itemImport")].URL()+"/item/import");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_import_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemImportCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemImportCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemImportResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemImportSignal(output);
        Q_EMIT itemImportSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemImportSignalE(output, error_type, error_str);
        Q_EMIT itemImportSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemImportSignalError(output, error_type, error_str);
        Q_EMIT itemImportSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemPublicTokenExchange(const OAIItemPublicTokenExchangeRequest &oai_item_public_token_exchange_request) {
    QString fullPath = QString(_serverConfigs["itemPublicTokenExchange"][_serverIndices.value("itemPublicTokenExchange")].URL()+"/item/public_token/exchange");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_public_token_exchange_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemPublicTokenExchangeCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemPublicTokenExchangeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemPublicTokenExchangeResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemPublicTokenExchangeSignal(output);
        Q_EMIT itemPublicTokenExchangeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemPublicTokenExchangeSignalE(output, error_type, error_str);
        Q_EMIT itemPublicTokenExchangeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemPublicTokenExchangeSignalError(output, error_type, error_str);
        Q_EMIT itemPublicTokenExchangeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemRemove(const OAIItemRemoveRequest &oai_item_remove_request) {
    QString fullPath = QString(_serverConfigs["itemRemove"][_serverIndices.value("itemRemove")].URL()+"/item/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemRemoveSignal(output);
        Q_EMIT itemRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemRemoveSignalE(output, error_type, error_str);
        Q_EMIT itemRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemRemoveSignalError(output, error_type, error_str);
        Q_EMIT itemRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::itemWebhookUpdate(const OAIItemWebhookUpdateRequest &oai_item_webhook_update_request) {
    QString fullPath = QString(_serverConfigs["itemWebhookUpdate"][_serverIndices.value("itemWebhookUpdate")].URL()+"/item/webhook/update");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_item_webhook_update_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::itemWebhookUpdateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::itemWebhookUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIItemWebhookUpdateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT itemWebhookUpdateSignal(output);
        Q_EMIT itemWebhookUpdateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT itemWebhookUpdateSignalE(output, error_type, error_str);
        Q_EMIT itemWebhookUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT itemWebhookUpdateSignalError(output, error_type, error_str);
        Q_EMIT itemWebhookUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::liabilitiesGet(const OAILiabilitiesGetRequest &oai_liabilities_get_request) {
    QString fullPath = QString(_serverConfigs["liabilitiesGet"][_serverIndices.value("liabilitiesGet")].URL()+"/liabilities/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_liabilities_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::liabilitiesGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::liabilitiesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILiabilitiesGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT liabilitiesGetSignal(output);
        Q_EMIT liabilitiesGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT liabilitiesGetSignalE(output, error_type, error_str);
        Q_EMIT liabilitiesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT liabilitiesGetSignalError(output, error_type, error_str);
        Q_EMIT liabilitiesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::linkDeliveryCreate(const OAILinkDeliveryCreateRequest &oai_link_delivery_create_request) {
    QString fullPath = QString(_serverConfigs["linkDeliveryCreate"][_serverIndices.value("linkDeliveryCreate")].URL()+"/link_delivery/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_link_delivery_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::linkDeliveryCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::linkDeliveryCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILinkDeliveryCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT linkDeliveryCreateSignal(output);
        Q_EMIT linkDeliveryCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT linkDeliveryCreateSignalE(output, error_type, error_str);
        Q_EMIT linkDeliveryCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT linkDeliveryCreateSignalError(output, error_type, error_str);
        Q_EMIT linkDeliveryCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::linkDeliveryGet(const OAILinkDeliveryGetRequest &oai_link_delivery_get_request) {
    QString fullPath = QString(_serverConfigs["linkDeliveryGet"][_serverIndices.value("linkDeliveryGet")].URL()+"/link_delivery/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_link_delivery_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::linkDeliveryGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::linkDeliveryGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILinkDeliveryGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT linkDeliveryGetSignal(output);
        Q_EMIT linkDeliveryGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT linkDeliveryGetSignalE(output, error_type, error_str);
        Q_EMIT linkDeliveryGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT linkDeliveryGetSignalError(output, error_type, error_str);
        Q_EMIT linkDeliveryGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::linkOauthCorrelationIdExchange(const OAILinkOAuthCorrelationIdExchangeRequest &oai_link_o_auth_correlation_id_exchange_request) {
    QString fullPath = QString(_serverConfigs["linkOauthCorrelationIdExchange"][_serverIndices.value("linkOauthCorrelationIdExchange")].URL()+"/link/oauth/correlation_id/exchange");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_link_o_auth_correlation_id_exchange_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::linkOauthCorrelationIdExchangeCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::linkOauthCorrelationIdExchangeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILinkOAuthCorrelationIdExchangeResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT linkOauthCorrelationIdExchangeSignal(output);
        Q_EMIT linkOauthCorrelationIdExchangeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT linkOauthCorrelationIdExchangeSignalE(output, error_type, error_str);
        Q_EMIT linkOauthCorrelationIdExchangeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT linkOauthCorrelationIdExchangeSignalError(output, error_type, error_str);
        Q_EMIT linkOauthCorrelationIdExchangeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::linkTokenCreate(const OAILinkTokenCreateRequest &oai_link_token_create_request) {
    QString fullPath = QString(_serverConfigs["linkTokenCreate"][_serverIndices.value("linkTokenCreate")].URL()+"/link/token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_link_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::linkTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::linkTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILinkTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT linkTokenCreateSignal(output);
        Q_EMIT linkTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT linkTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT linkTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT linkTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT linkTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::linkTokenGet(const OAILinkTokenGetRequest &oai_link_token_get_request) {
    QString fullPath = QString(_serverConfigs["linkTokenGet"][_serverIndices.value("linkTokenGet")].URL()+"/link/token/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_link_token_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::linkTokenGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::linkTokenGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILinkTokenGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT linkTokenGetSignal(output);
        Q_EMIT linkTokenGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT linkTokenGetSignalE(output, error_type, error_str);
        Q_EMIT linkTokenGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT linkTokenGetSignalError(output, error_type, error_str);
        Q_EMIT linkTokenGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::partnerCustomerCreate(const OAIPartnerCustomerCreateRequest &oai_partner_customer_create_request) {
    QString fullPath = QString(_serverConfigs["partnerCustomerCreate"][_serverIndices.value("partnerCustomerCreate")].URL()+"/partner/customer/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partner_customer_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::partnerCustomerCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::partnerCustomerCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPartnerCustomerCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT partnerCustomerCreateSignal(output);
        Q_EMIT partnerCustomerCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT partnerCustomerCreateSignalE(output, error_type, error_str);
        Q_EMIT partnerCustomerCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT partnerCustomerCreateSignalError(output, error_type, error_str);
        Q_EMIT partnerCustomerCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::partnerCustomerEnable(const OAIPartnerCustomerEnableRequest &oai_partner_customer_enable_request) {
    QString fullPath = QString(_serverConfigs["partnerCustomerEnable"][_serverIndices.value("partnerCustomerEnable")].URL()+"/partner/customer/enable");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partner_customer_enable_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::partnerCustomerEnableCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::partnerCustomerEnableCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPartnerCustomerEnableResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT partnerCustomerEnableSignal(output);
        Q_EMIT partnerCustomerEnableSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT partnerCustomerEnableSignalE(output, error_type, error_str);
        Q_EMIT partnerCustomerEnableSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT partnerCustomerEnableSignalError(output, error_type, error_str);
        Q_EMIT partnerCustomerEnableSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::partnerCustomerGet(const OAIPartnerCustomerGetRequest &oai_partner_customer_get_request) {
    QString fullPath = QString(_serverConfigs["partnerCustomerGet"][_serverIndices.value("partnerCustomerGet")].URL()+"/partner/customer/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partner_customer_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::partnerCustomerGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::partnerCustomerGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPartnerCustomerGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT partnerCustomerGetSignal(output);
        Q_EMIT partnerCustomerGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT partnerCustomerGetSignalE(output, error_type, error_str);
        Q_EMIT partnerCustomerGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT partnerCustomerGetSignalError(output, error_type, error_str);
        Q_EMIT partnerCustomerGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::partnerCustomerOauthInstitutionsGet(const OAIPartnerCustomerOAuthInstitutionsGetRequest &oai_partner_customer_o_auth_institutions_get_request) {
    QString fullPath = QString(_serverConfigs["partnerCustomerOauthInstitutionsGet"][_serverIndices.value("partnerCustomerOauthInstitutionsGet")].URL()+"/partner/customer/oauth_institutions/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partner_customer_o_auth_institutions_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::partnerCustomerOauthInstitutionsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::partnerCustomerOauthInstitutionsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPartnerCustomerOAuthInstitutionsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT partnerCustomerOauthInstitutionsGetSignal(output);
        Q_EMIT partnerCustomerOauthInstitutionsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT partnerCustomerOauthInstitutionsGetSignalE(output, error_type, error_str);
        Q_EMIT partnerCustomerOauthInstitutionsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT partnerCustomerOauthInstitutionsGetSignalError(output, error_type, error_str);
        Q_EMIT partnerCustomerOauthInstitutionsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::partnerCustomerRemove(const OAIPartnerCustomerRemoveRequest &oai_partner_customer_remove_request) {
    QString fullPath = QString(_serverConfigs["partnerCustomerRemove"][_serverIndices.value("partnerCustomerRemove")].URL()+"/partner/customer/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partner_customer_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::partnerCustomerRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::partnerCustomerRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPartnerCustomerRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT partnerCustomerRemoveSignal(output);
        Q_EMIT partnerCustomerRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT partnerCustomerRemoveSignalE(output, error_type, error_str);
        Q_EMIT partnerCustomerRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT partnerCustomerRemoveSignalError(output, error_type, error_str);
        Q_EMIT partnerCustomerRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationConsentCreate(const OAIPaymentInitiationConsentCreateRequest &oai_payment_initiation_consent_create_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationConsentCreate"][_serverIndices.value("paymentInitiationConsentCreate")].URL()+"/payment_initiation/consent/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_consent_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationConsentCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationConsentCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationConsentCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationConsentCreateSignal(output);
        Q_EMIT paymentInitiationConsentCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationConsentCreateSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationConsentCreateSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationConsentGet(const OAIPaymentInitiationConsentGetRequest &oai_payment_initiation_consent_get_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationConsentGet"][_serverIndices.value("paymentInitiationConsentGet")].URL()+"/payment_initiation/consent/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_consent_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationConsentGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationConsentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationConsentGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationConsentGetSignal(output);
        Q_EMIT paymentInitiationConsentGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationConsentGetSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationConsentGetSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationConsentPaymentExecute(const OAIPaymentInitiationConsentPaymentExecuteRequest &oai_payment_initiation_consent_payment_execute_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationConsentPaymentExecute"][_serverIndices.value("paymentInitiationConsentPaymentExecute")].URL()+"/payment_initiation/consent/payment/execute");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_consent_payment_execute_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationConsentPaymentExecuteCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationConsentPaymentExecuteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationConsentPaymentExecuteResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationConsentPaymentExecuteSignal(output);
        Q_EMIT paymentInitiationConsentPaymentExecuteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationConsentPaymentExecuteSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentPaymentExecuteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationConsentPaymentExecuteSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentPaymentExecuteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationConsentRevoke(const OAIPaymentInitiationConsentRevokeRequest &oai_payment_initiation_consent_revoke_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationConsentRevoke"][_serverIndices.value("paymentInitiationConsentRevoke")].URL()+"/payment_initiation/consent/revoke");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_consent_revoke_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationConsentRevokeCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationConsentRevokeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationConsentRevokeResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationConsentRevokeSignal(output);
        Q_EMIT paymentInitiationConsentRevokeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationConsentRevokeSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentRevokeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationConsentRevokeSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationConsentRevokeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationPaymentCreate(const OAIPaymentInitiationPaymentCreateRequest &oai_payment_initiation_payment_create_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationPaymentCreate"][_serverIndices.value("paymentInitiationPaymentCreate")].URL()+"/payment_initiation/payment/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_payment_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationPaymentCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationPaymentCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationPaymentCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationPaymentCreateSignal(output);
        Q_EMIT paymentInitiationPaymentCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationPaymentCreateSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationPaymentCreateSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationPaymentGet(const OAIPaymentInitiationPaymentGetRequest &oai_payment_initiation_payment_get_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationPaymentGet"][_serverIndices.value("paymentInitiationPaymentGet")].URL()+"/payment_initiation/payment/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_payment_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationPaymentGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationPaymentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationPaymentGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationPaymentGetSignal(output);
        Q_EMIT paymentInitiationPaymentGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationPaymentGetSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationPaymentGetSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationPaymentList(const OAIPaymentInitiationPaymentListRequest &oai_payment_initiation_payment_list_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationPaymentList"][_serverIndices.value("paymentInitiationPaymentList")].URL()+"/payment_initiation/payment/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_payment_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationPaymentListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationPaymentListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationPaymentListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationPaymentListSignal(output);
        Q_EMIT paymentInitiationPaymentListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationPaymentListSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationPaymentListSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationPaymentReverse(const OAIPaymentInitiationPaymentReverseRequest &oai_payment_initiation_payment_reverse_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationPaymentReverse"][_serverIndices.value("paymentInitiationPaymentReverse")].URL()+"/payment_initiation/payment/reverse");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_payment_reverse_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationPaymentReverseCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationPaymentReverseCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationPaymentReverseResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationPaymentReverseSignal(output);
        Q_EMIT paymentInitiationPaymentReverseSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationPaymentReverseSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentReverseSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationPaymentReverseSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationPaymentReverseSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationRecipientCreate(const OAIPaymentInitiationRecipientCreateRequest &oai_payment_initiation_recipient_create_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationRecipientCreate"][_serverIndices.value("paymentInitiationRecipientCreate")].URL()+"/payment_initiation/recipient/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_recipient_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationRecipientCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationRecipientCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationRecipientCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationRecipientCreateSignal(output);
        Q_EMIT paymentInitiationRecipientCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationRecipientCreateSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationRecipientCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationRecipientCreateSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationRecipientCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationRecipientGet(const OAIPaymentInitiationRecipientGetRequest &oai_payment_initiation_recipient_get_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationRecipientGet"][_serverIndices.value("paymentInitiationRecipientGet")].URL()+"/payment_initiation/recipient/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_recipient_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationRecipientGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationRecipientGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationRecipientGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationRecipientGetSignal(output);
        Q_EMIT paymentInitiationRecipientGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationRecipientGetSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationRecipientGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationRecipientGetSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationRecipientGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentInitiationRecipientList(const OAIPaymentInitiationRecipientListRequest &oai_payment_initiation_recipient_list_request) {
    QString fullPath = QString(_serverConfigs["paymentInitiationRecipientList"][_serverIndices.value("paymentInitiationRecipientList")].URL()+"/payment_initiation/recipient/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_initiation_recipient_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentInitiationRecipientListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentInitiationRecipientListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentInitiationRecipientListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentInitiationRecipientListSignal(output);
        Q_EMIT paymentInitiationRecipientListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentInitiationRecipientListSignalE(output, error_type, error_str);
        Q_EMIT paymentInitiationRecipientListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentInitiationRecipientListSignalError(output, error_type, error_str);
        Q_EMIT paymentInitiationRecipientListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentProfileCreate(const OAIPaymentProfileCreateRequest &oai_payment_profile_create_request) {
    QString fullPath = QString(_serverConfigs["paymentProfileCreate"][_serverIndices.value("paymentProfileCreate")].URL()+"/payment_profile/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_profile_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentProfileCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentProfileCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentProfileCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentProfileCreateSignal(output);
        Q_EMIT paymentProfileCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentProfileCreateSignalE(output, error_type, error_str);
        Q_EMIT paymentProfileCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentProfileCreateSignalError(output, error_type, error_str);
        Q_EMIT paymentProfileCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentProfileGet(const OAIPaymentProfileGetRequest &oai_payment_profile_get_request) {
    QString fullPath = QString(_serverConfigs["paymentProfileGet"][_serverIndices.value("paymentProfileGet")].URL()+"/payment_profile/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_profile_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentProfileGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentProfileGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentProfileGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentProfileGetSignal(output);
        Q_EMIT paymentProfileGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentProfileGetSignalE(output, error_type, error_str);
        Q_EMIT paymentProfileGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentProfileGetSignalError(output, error_type, error_str);
        Q_EMIT paymentProfileGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::paymentProfileRemove(const OAIPaymentProfileRemoveRequest &oai_payment_profile_remove_request) {
    QString fullPath = QString(_serverConfigs["paymentProfileRemove"][_serverIndices.value("paymentProfileRemove")].URL()+"/payment_profile/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_payment_profile_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::paymentProfileRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::paymentProfileRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentProfileRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentProfileRemoveSignal(output);
        Q_EMIT paymentProfileRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentProfileRemoveSignalE(output, error_type, error_str);
        Q_EMIT paymentProfileRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentProfileRemoveSignalError(output, error_type, error_str);
        Q_EMIT paymentProfileRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorApexProcessorTokenCreate(const OAIProcessorApexProcessorTokenCreateRequest &oai_processor_apex_processor_token_create_request) {
    QString fullPath = QString(_serverConfigs["processorApexProcessorTokenCreate"][_serverIndices.value("processorApexProcessorTokenCreate")].URL()+"/processor/apex/processor_token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_apex_processor_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorApexProcessorTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorApexProcessorTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorApexProcessorTokenCreateSignal(output);
        Q_EMIT processorApexProcessorTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorApexProcessorTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT processorApexProcessorTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorApexProcessorTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT processorApexProcessorTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorAuthGet(const OAIProcessorAuthGetRequest &oai_processor_auth_get_request) {
    QString fullPath = QString(_serverConfigs["processorAuthGet"][_serverIndices.value("processorAuthGet")].URL()+"/processor/auth/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_auth_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorAuthGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorAuthGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorAuthGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorAuthGetSignal(output);
        Q_EMIT processorAuthGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorAuthGetSignalE(output, error_type, error_str);
        Q_EMIT processorAuthGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorAuthGetSignalError(output, error_type, error_str);
        Q_EMIT processorAuthGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorBalanceGet(const OAIProcessorBalanceGetRequest &oai_processor_balance_get_request) {
    QString fullPath = QString(_serverConfigs["processorBalanceGet"][_serverIndices.value("processorBalanceGet")].URL()+"/processor/balance/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_balance_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorBalanceGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorBalanceGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorBalanceGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorBalanceGetSignal(output);
        Q_EMIT processorBalanceGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorBalanceGetSignalE(output, error_type, error_str);
        Q_EMIT processorBalanceGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorBalanceGetSignalError(output, error_type, error_str);
        Q_EMIT processorBalanceGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorBankTransferCreate(const OAIProcessorBankTransferCreateRequest &oai_processor_bank_transfer_create_request) {
    QString fullPath = QString(_serverConfigs["processorBankTransferCreate"][_serverIndices.value("processorBankTransferCreate")].URL()+"/processor/bank_transfer/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_bank_transfer_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorBankTransferCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorBankTransferCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorBankTransferCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorBankTransferCreateSignal(output);
        Q_EMIT processorBankTransferCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorBankTransferCreateSignalE(output, error_type, error_str);
        Q_EMIT processorBankTransferCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorBankTransferCreateSignalError(output, error_type, error_str);
        Q_EMIT processorBankTransferCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorIdentityGet(const OAIProcessorIdentityGetRequest &oai_processor_identity_get_request) {
    QString fullPath = QString(_serverConfigs["processorIdentityGet"][_serverIndices.value("processorIdentityGet")].URL()+"/processor/identity/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_identity_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorIdentityGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorIdentityGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorIdentityGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorIdentityGetSignal(output);
        Q_EMIT processorIdentityGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorIdentityGetSignalE(output, error_type, error_str);
        Q_EMIT processorIdentityGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorIdentityGetSignalError(output, error_type, error_str);
        Q_EMIT processorIdentityGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorSignalDecisionReport(const OAIProcessorSignalDecisionReportRequest &oai_processor_signal_decision_report_request) {
    QString fullPath = QString(_serverConfigs["processorSignalDecisionReport"][_serverIndices.value("processorSignalDecisionReport")].URL()+"/processor/signal/decision/report");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_signal_decision_report_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorSignalDecisionReportCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorSignalDecisionReportCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorSignalDecisionReportResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorSignalDecisionReportSignal(output);
        Q_EMIT processorSignalDecisionReportSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorSignalDecisionReportSignalE(output, error_type, error_str);
        Q_EMIT processorSignalDecisionReportSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorSignalDecisionReportSignalError(output, error_type, error_str);
        Q_EMIT processorSignalDecisionReportSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorSignalEvaluate(const OAIProcessorSignalEvaluateRequest &oai_processor_signal_evaluate_request) {
    QString fullPath = QString(_serverConfigs["processorSignalEvaluate"][_serverIndices.value("processorSignalEvaluate")].URL()+"/processor/signal/evaluate");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_signal_evaluate_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorSignalEvaluateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorSignalEvaluateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorSignalEvaluateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorSignalEvaluateSignal(output);
        Q_EMIT processorSignalEvaluateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorSignalEvaluateSignalE(output, error_type, error_str);
        Q_EMIT processorSignalEvaluateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorSignalEvaluateSignalError(output, error_type, error_str);
        Q_EMIT processorSignalEvaluateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorSignalReturnReport(const OAIProcessorSignalReturnReportRequest &oai_processor_signal_return_report_request) {
    QString fullPath = QString(_serverConfigs["processorSignalReturnReport"][_serverIndices.value("processorSignalReturnReport")].URL()+"/processor/signal/return/report");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_signal_return_report_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorSignalReturnReportCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorSignalReturnReportCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorSignalReturnReportResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorSignalReturnReportSignal(output);
        Q_EMIT processorSignalReturnReportSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorSignalReturnReportSignalE(output, error_type, error_str);
        Q_EMIT processorSignalReturnReportSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorSignalReturnReportSignalError(output, error_type, error_str);
        Q_EMIT processorSignalReturnReportSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorStripeBankAccountTokenCreate(const OAIProcessorStripeBankAccountTokenCreateRequest &oai_processor_stripe_bank_account_token_create_request) {
    QString fullPath = QString(_serverConfigs["processorStripeBankAccountTokenCreate"][_serverIndices.value("processorStripeBankAccountTokenCreate")].URL()+"/processor/stripe/bank_account_token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_stripe_bank_account_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorStripeBankAccountTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorStripeBankAccountTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorStripeBankAccountTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorStripeBankAccountTokenCreateSignal(output);
        Q_EMIT processorStripeBankAccountTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorStripeBankAccountTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT processorStripeBankAccountTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorStripeBankAccountTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT processorStripeBankAccountTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::processorTokenCreate(const OAIProcessorTokenCreateRequest &oai_processor_token_create_request) {
    QString fullPath = QString(_serverConfigs["processorTokenCreate"][_serverIndices.value("processorTokenCreate")].URL()+"/processor/token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_processor_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::processorTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::processorTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProcessorTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT processorTokenCreateSignal(output);
        Q_EMIT processorTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT processorTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT processorTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT processorTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT processorTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxBankTransferFireWebhook(const OAISandboxBankTransferFireWebhookRequest &oai_sandbox_bank_transfer_fire_webhook_request) {
    QString fullPath = QString(_serverConfigs["sandboxBankTransferFireWebhook"][_serverIndices.value("sandboxBankTransferFireWebhook")].URL()+"/sandbox/bank_transfer/fire_webhook");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_bank_transfer_fire_webhook_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxBankTransferFireWebhookCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxBankTransferFireWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxBankTransferFireWebhookResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxBankTransferFireWebhookSignal(output);
        Q_EMIT sandboxBankTransferFireWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxBankTransferFireWebhookSignalE(output, error_type, error_str);
        Q_EMIT sandboxBankTransferFireWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxBankTransferFireWebhookSignalError(output, error_type, error_str);
        Q_EMIT sandboxBankTransferFireWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxBankTransferSimulate(const OAISandboxBankTransferSimulateRequest &oai_sandbox_bank_transfer_simulate_request) {
    QString fullPath = QString(_serverConfigs["sandboxBankTransferSimulate"][_serverIndices.value("sandboxBankTransferSimulate")].URL()+"/sandbox/bank_transfer/simulate");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_bank_transfer_simulate_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxBankTransferSimulateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxBankTransferSimulateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxBankTransferSimulateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxBankTransferSimulateSignal(output);
        Q_EMIT sandboxBankTransferSimulateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxBankTransferSimulateSignalE(output, error_type, error_str);
        Q_EMIT sandboxBankTransferSimulateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxBankTransferSimulateSignalError(output, error_type, error_str);
        Q_EMIT sandboxBankTransferSimulateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxIncomeFireWebhook(const OAISandboxIncomeFireWebhookRequest &oai_sandbox_income_fire_webhook_request) {
    QString fullPath = QString(_serverConfigs["sandboxIncomeFireWebhook"][_serverIndices.value("sandboxIncomeFireWebhook")].URL()+"/sandbox/income/fire_webhook");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_income_fire_webhook_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxIncomeFireWebhookCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxIncomeFireWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxIncomeFireWebhookResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxIncomeFireWebhookSignal(output);
        Q_EMIT sandboxIncomeFireWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxIncomeFireWebhookSignalE(output, error_type, error_str);
        Q_EMIT sandboxIncomeFireWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxIncomeFireWebhookSignalError(output, error_type, error_str);
        Q_EMIT sandboxIncomeFireWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxItemFireWebhook(const OAISandboxItemFireWebhookRequest &oai_sandbox_item_fire_webhook_request) {
    QString fullPath = QString(_serverConfigs["sandboxItemFireWebhook"][_serverIndices.value("sandboxItemFireWebhook")].URL()+"/sandbox/item/fire_webhook");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_item_fire_webhook_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxItemFireWebhookCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxItemFireWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxItemFireWebhookResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxItemFireWebhookSignal(output);
        Q_EMIT sandboxItemFireWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxItemFireWebhookSignalE(output, error_type, error_str);
        Q_EMIT sandboxItemFireWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxItemFireWebhookSignalError(output, error_type, error_str);
        Q_EMIT sandboxItemFireWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxItemResetLogin(const OAISandboxItemResetLoginRequest &oai_sandbox_item_reset_login_request) {
    QString fullPath = QString(_serverConfigs["sandboxItemResetLogin"][_serverIndices.value("sandboxItemResetLogin")].URL()+"/sandbox/item/reset_login");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_item_reset_login_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxItemResetLoginCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxItemResetLoginCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxItemResetLoginResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxItemResetLoginSignal(output);
        Q_EMIT sandboxItemResetLoginSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxItemResetLoginSignalE(output, error_type, error_str);
        Q_EMIT sandboxItemResetLoginSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxItemResetLoginSignalError(output, error_type, error_str);
        Q_EMIT sandboxItemResetLoginSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxItemSetVerificationStatus(const OAISandboxItemSetVerificationStatusRequest &oai_sandbox_item_set_verification_status_request) {
    QString fullPath = QString(_serverConfigs["sandboxItemSetVerificationStatus"][_serverIndices.value("sandboxItemSetVerificationStatus")].URL()+"/sandbox/item/set_verification_status");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_item_set_verification_status_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxItemSetVerificationStatusCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxItemSetVerificationStatusCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxItemSetVerificationStatusResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxItemSetVerificationStatusSignal(output);
        Q_EMIT sandboxItemSetVerificationStatusSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxItemSetVerificationStatusSignalE(output, error_type, error_str);
        Q_EMIT sandboxItemSetVerificationStatusSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxItemSetVerificationStatusSignalError(output, error_type, error_str);
        Q_EMIT sandboxItemSetVerificationStatusSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxOauthSelectAccounts(const OAISandboxOauthSelectAccountsRequest &oai_sandbox_oauth_select_accounts_request) {
    QString fullPath = QString(_serverConfigs["sandboxOauthSelectAccounts"][_serverIndices.value("sandboxOauthSelectAccounts")].URL()+"/sandbox/oauth/select_accounts");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_oauth_select_accounts_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxOauthSelectAccountsCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxOauthSelectAccountsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QJsonValue> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QJsonValue val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxOauthSelectAccountsSignal(output);
        Q_EMIT sandboxOauthSelectAccountsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxOauthSelectAccountsSignalE(output, error_type, error_str);
        Q_EMIT sandboxOauthSelectAccountsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxOauthSelectAccountsSignalError(output, error_type, error_str);
        Q_EMIT sandboxOauthSelectAccountsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxPaymentProfileResetLogin(const OAISandboxPaymentProfileResetLoginRequest &oai_sandbox_payment_profile_reset_login_request) {
    QString fullPath = QString(_serverConfigs["sandboxPaymentProfileResetLogin"][_serverIndices.value("sandboxPaymentProfileResetLogin")].URL()+"/sandbox/payment_profile/reset_login");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_payment_profile_reset_login_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxPaymentProfileResetLoginCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxPaymentProfileResetLoginCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxPaymentProfileResetLoginResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxPaymentProfileResetLoginSignal(output);
        Q_EMIT sandboxPaymentProfileResetLoginSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxPaymentProfileResetLoginSignalE(output, error_type, error_str);
        Q_EMIT sandboxPaymentProfileResetLoginSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxPaymentProfileResetLoginSignalError(output, error_type, error_str);
        Q_EMIT sandboxPaymentProfileResetLoginSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxProcessorTokenCreate(const OAISandboxProcessorTokenCreateRequest &oai_sandbox_processor_token_create_request) {
    QString fullPath = QString(_serverConfigs["sandboxProcessorTokenCreate"][_serverIndices.value("sandboxProcessorTokenCreate")].URL()+"/sandbox/processor_token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_processor_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxProcessorTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxProcessorTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxProcessorTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxProcessorTokenCreateSignal(output);
        Q_EMIT sandboxProcessorTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxProcessorTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT sandboxProcessorTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxProcessorTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT sandboxProcessorTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxPublicTokenCreate(const OAISandboxPublicTokenCreateRequest &oai_sandbox_public_token_create_request) {
    QString fullPath = QString(_serverConfigs["sandboxPublicTokenCreate"][_serverIndices.value("sandboxPublicTokenCreate")].URL()+"/sandbox/public_token/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_public_token_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxPublicTokenCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxPublicTokenCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxPublicTokenCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxPublicTokenCreateSignal(output);
        Q_EMIT sandboxPublicTokenCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxPublicTokenCreateSignalE(output, error_type, error_str);
        Q_EMIT sandboxPublicTokenCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxPublicTokenCreateSignalError(output, error_type, error_str);
        Q_EMIT sandboxPublicTokenCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferFireWebhook(const OAISandboxTransferFireWebhookRequest &oai_sandbox_transfer_fire_webhook_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferFireWebhook"][_serverIndices.value("sandboxTransferFireWebhook")].URL()+"/sandbox/transfer/fire_webhook");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_fire_webhook_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferFireWebhookCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferFireWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferFireWebhookResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferFireWebhookSignal(output);
        Q_EMIT sandboxTransferFireWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferFireWebhookSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferFireWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferFireWebhookSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferFireWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferRepaymentSimulate(const OAISandboxTransferRepaymentSimulateRequest &oai_sandbox_transfer_repayment_simulate_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferRepaymentSimulate"][_serverIndices.value("sandboxTransferRepaymentSimulate")].URL()+"/sandbox/transfer/repayment/simulate");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_repayment_simulate_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferRepaymentSimulateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferRepaymentSimulateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferRepaymentSimulateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferRepaymentSimulateSignal(output);
        Q_EMIT sandboxTransferRepaymentSimulateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferRepaymentSimulateSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferRepaymentSimulateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferRepaymentSimulateSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferRepaymentSimulateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferSimulate(const OAISandboxTransferSimulateRequest &oai_sandbox_transfer_simulate_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferSimulate"][_serverIndices.value("sandboxTransferSimulate")].URL()+"/sandbox/transfer/simulate");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_simulate_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferSimulateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferSimulateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferSimulateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferSimulateSignal(output);
        Q_EMIT sandboxTransferSimulateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferSimulateSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferSimulateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferSimulateSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferSimulateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferSweepSimulate(const OAISandboxTransferSweepSimulateRequest &oai_sandbox_transfer_sweep_simulate_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferSweepSimulate"][_serverIndices.value("sandboxTransferSweepSimulate")].URL()+"/sandbox/transfer/sweep/simulate");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_sweep_simulate_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferSweepSimulateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferSweepSimulateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferSweepSimulateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferSweepSimulateSignal(output);
        Q_EMIT sandboxTransferSweepSimulateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferSweepSimulateSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferSweepSimulateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferSweepSimulateSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferSweepSimulateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferTestClockAdvance(const OAISandboxTransferTestClockAdvanceRequest &oai_sandbox_transfer_test_clock_advance_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferTestClockAdvance"][_serverIndices.value("sandboxTransferTestClockAdvance")].URL()+"/sandbox/transfer/test_clock/advance");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_test_clock_advance_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferTestClockAdvanceCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferTestClockAdvanceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferTestClockAdvanceResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferTestClockAdvanceSignal(output);
        Q_EMIT sandboxTransferTestClockAdvanceSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferTestClockAdvanceSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockAdvanceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferTestClockAdvanceSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockAdvanceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferTestClockCreate(const OAISandboxTransferTestClockCreateRequest &oai_sandbox_transfer_test_clock_create_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferTestClockCreate"][_serverIndices.value("sandboxTransferTestClockCreate")].URL()+"/sandbox/transfer/test_clock/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_test_clock_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferTestClockCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferTestClockCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferTestClockCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferTestClockCreateSignal(output);
        Q_EMIT sandboxTransferTestClockCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferTestClockCreateSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferTestClockCreateSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferTestClockGet(const OAISandboxTransferTestClockGetRequest &oai_sandbox_transfer_test_clock_get_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferTestClockGet"][_serverIndices.value("sandboxTransferTestClockGet")].URL()+"/sandbox/transfer/test_clock/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_test_clock_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferTestClockGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferTestClockGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferTestClockGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferTestClockGetSignal(output);
        Q_EMIT sandboxTransferTestClockGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferTestClockGetSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferTestClockGetSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::sandboxTransferTestClockList(const OAISandboxTransferTestClockListRequest &oai_sandbox_transfer_test_clock_list_request) {
    QString fullPath = QString(_serverConfigs["sandboxTransferTestClockList"][_serverIndices.value("sandboxTransferTestClockList")].URL()+"/sandbox/transfer/test_clock/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_sandbox_transfer_test_clock_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::sandboxTransferTestClockListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::sandboxTransferTestClockListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISandboxTransferTestClockListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sandboxTransferTestClockListSignal(output);
        Q_EMIT sandboxTransferTestClockListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sandboxTransferTestClockListSignalE(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sandboxTransferTestClockListSignalError(output, error_type, error_str);
        Q_EMIT sandboxTransferTestClockListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::signalDecisionReport(const OAISignalDecisionReportRequest &oai_signal_decision_report_request) {
    QString fullPath = QString(_serverConfigs["signalDecisionReport"][_serverIndices.value("signalDecisionReport")].URL()+"/signal/decision/report");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_signal_decision_report_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::signalDecisionReportCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::signalDecisionReportCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISignalDecisionReportResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT signalDecisionReportSignal(output);
        Q_EMIT signalDecisionReportSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT signalDecisionReportSignalE(output, error_type, error_str);
        Q_EMIT signalDecisionReportSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT signalDecisionReportSignalError(output, error_type, error_str);
        Q_EMIT signalDecisionReportSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::signalEvaluate(const OAISignalEvaluateRequest &oai_signal_evaluate_request) {
    QString fullPath = QString(_serverConfigs["signalEvaluate"][_serverIndices.value("signalEvaluate")].URL()+"/signal/evaluate");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_signal_evaluate_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::signalEvaluateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::signalEvaluateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISignalEvaluateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT signalEvaluateSignal(output);
        Q_EMIT signalEvaluateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT signalEvaluateSignalE(output, error_type, error_str);
        Q_EMIT signalEvaluateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT signalEvaluateSignalError(output, error_type, error_str);
        Q_EMIT signalEvaluateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::signalPrepare(const OAISignalPrepareRequest &oai_signal_prepare_request) {
    QString fullPath = QString(_serverConfigs["signalPrepare"][_serverIndices.value("signalPrepare")].URL()+"/signal/prepare");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_signal_prepare_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::signalPrepareCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::signalPrepareCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISignalPrepareResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT signalPrepareSignal(output);
        Q_EMIT signalPrepareSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT signalPrepareSignalE(output, error_type, error_str);
        Q_EMIT signalPrepareSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT signalPrepareSignalError(output, error_type, error_str);
        Q_EMIT signalPrepareSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::signalReturnReport(const OAISignalReturnReportRequest &oai_signal_return_report_request) {
    QString fullPath = QString(_serverConfigs["signalReturnReport"][_serverIndices.value("signalReturnReport")].URL()+"/signal/return/report");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_signal_return_report_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::signalReturnReportCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::signalReturnReportCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISignalReturnReportResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT signalReturnReportSignal(output);
        Q_EMIT signalReturnReportSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT signalReturnReportSignalE(output, error_type, error_str);
        Q_EMIT signalReturnReportSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT signalReturnReportSignalError(output, error_type, error_str);
        Q_EMIT signalReturnReportSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsEnhance(const OAITransactionsEnhanceGetRequest &oai_transactions_enhance_get_request) {
    QString fullPath = QString(_serverConfigs["transactionsEnhance"][_serverIndices.value("transactionsEnhance")].URL()+"/beta/transactions/v1/enhance");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_enhance_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsEnhanceCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsEnhanceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsEnhanceGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsEnhanceSignal(output);
        Q_EMIT transactionsEnhanceSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsEnhanceSignalE(output, error_type, error_str);
        Q_EMIT transactionsEnhanceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsEnhanceSignalError(output, error_type, error_str);
        Q_EMIT transactionsEnhanceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsEnrich(const OAITransactionsEnrichGetRequest &oai_transactions_enrich_get_request) {
    QString fullPath = QString(_serverConfigs["transactionsEnrich"][_serverIndices.value("transactionsEnrich")].URL()+"/transactions/enrich");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_enrich_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsEnrichCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsEnrichCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsEnrichGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsEnrichSignal(output);
        Q_EMIT transactionsEnrichSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsEnrichSignalE(output, error_type, error_str);
        Q_EMIT transactionsEnrichSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsEnrichSignalError(output, error_type, error_str);
        Q_EMIT transactionsEnrichSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsGet(const OAITransactionsGetRequest &oai_transactions_get_request) {
    QString fullPath = QString(_serverConfigs["transactionsGet"][_serverIndices.value("transactionsGet")].URL()+"/transactions/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsGetSignal(output);
        Q_EMIT transactionsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsGetSignalE(output, error_type, error_str);
        Q_EMIT transactionsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsGetSignalError(output, error_type, error_str);
        Q_EMIT transactionsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsRecurringGet(const OAITransactionsRecurringGetRequest &oai_transactions_recurring_get_request) {
    QString fullPath = QString(_serverConfigs["transactionsRecurringGet"][_serverIndices.value("transactionsRecurringGet")].URL()+"/transactions/recurring/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_recurring_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsRecurringGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsRecurringGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsRecurringGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsRecurringGetSignal(output);
        Q_EMIT transactionsRecurringGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsRecurringGetSignalE(output, error_type, error_str);
        Q_EMIT transactionsRecurringGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsRecurringGetSignalError(output, error_type, error_str);
        Q_EMIT transactionsRecurringGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsRefresh(const OAITransactionsRefreshRequest &oai_transactions_refresh_request) {
    QString fullPath = QString(_serverConfigs["transactionsRefresh"][_serverIndices.value("transactionsRefresh")].URL()+"/transactions/refresh");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_refresh_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsRefreshCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsRefreshCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsRefreshResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsRefreshSignal(output);
        Q_EMIT transactionsRefreshSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsRefreshSignalE(output, error_type, error_str);
        Q_EMIT transactionsRefreshSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsRefreshSignalError(output, error_type, error_str);
        Q_EMIT transactionsRefreshSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsRulesCreate(const OAITransactionsRulesCreateRequest &oai_transactions_rules_create_request) {
    QString fullPath = QString(_serverConfigs["transactionsRulesCreate"][_serverIndices.value("transactionsRulesCreate")].URL()+"/beta/transactions/rules/v1/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_rules_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsRulesCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsRulesCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsRulesCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsRulesCreateSignal(output);
        Q_EMIT transactionsRulesCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsRulesCreateSignalE(output, error_type, error_str);
        Q_EMIT transactionsRulesCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsRulesCreateSignalError(output, error_type, error_str);
        Q_EMIT transactionsRulesCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsRulesList(const OAITransactionsRulesListRequest &oai_transactions_rules_list_request) {
    QString fullPath = QString(_serverConfigs["transactionsRulesList"][_serverIndices.value("transactionsRulesList")].URL()+"/beta/transactions/rules/v1/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_rules_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsRulesListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsRulesListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsRulesListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsRulesListSignal(output);
        Q_EMIT transactionsRulesListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsRulesListSignalE(output, error_type, error_str);
        Q_EMIT transactionsRulesListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsRulesListSignalError(output, error_type, error_str);
        Q_EMIT transactionsRulesListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsRulesRemove(const OAITransactionsRulesRemoveRequest &oai_transactions_rules_remove_request) {
    QString fullPath = QString(_serverConfigs["transactionsRulesRemove"][_serverIndices.value("transactionsRulesRemove")].URL()+"/beta/transactions/rules/v1/remove");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_rules_remove_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsRulesRemoveCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsRulesRemoveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsRulesRemoveResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsRulesRemoveSignal(output);
        Q_EMIT transactionsRulesRemoveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsRulesRemoveSignalE(output, error_type, error_str);
        Q_EMIT transactionsRulesRemoveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsRulesRemoveSignalError(output, error_type, error_str);
        Q_EMIT transactionsRulesRemoveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transactionsSync(const OAITransactionsSyncRequest &oai_transactions_sync_request) {
    QString fullPath = QString(_serverConfigs["transactionsSync"][_serverIndices.value("transactionsSync")].URL()+"/transactions/sync");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transactions_sync_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transactionsSyncCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transactionsSyncCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionsSyncResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionsSyncSignal(output);
        Q_EMIT transactionsSyncSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionsSyncSignalE(output, error_type, error_str);
        Q_EMIT transactionsSyncSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionsSyncSignalError(output, error_type, error_str);
        Q_EMIT transactionsSyncSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferAuthorizationCreate(const OAITransferAuthorizationCreateRequest &oai_transfer_authorization_create_request) {
    QString fullPath = QString(_serverConfigs["transferAuthorizationCreate"][_serverIndices.value("transferAuthorizationCreate")].URL()+"/transfer/authorization/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_authorization_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferAuthorizationCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferAuthorizationCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferAuthorizationCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferAuthorizationCreateSignal(output);
        Q_EMIT transferAuthorizationCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferAuthorizationCreateSignalE(output, error_type, error_str);
        Q_EMIT transferAuthorizationCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferAuthorizationCreateSignalError(output, error_type, error_str);
        Q_EMIT transferAuthorizationCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferCancel(const OAITransferCancelRequest &oai_transfer_cancel_request) {
    QString fullPath = QString(_serverConfigs["transferCancel"][_serverIndices.value("transferCancel")].URL()+"/transfer/cancel");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_cancel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferCancelCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferCancelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferCancelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferCancelSignal(output);
        Q_EMIT transferCancelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferCancelSignalE(output, error_type, error_str);
        Q_EMIT transferCancelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferCancelSignalError(output, error_type, error_str);
        Q_EMIT transferCancelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferCapabilitiesGet(const OAITransferCapabilitiesGetRequest &oai_transfer_capabilities_get_request) {
    QString fullPath = QString(_serverConfigs["transferCapabilitiesGet"][_serverIndices.value("transferCapabilitiesGet")].URL()+"/transfer/capabilities/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_capabilities_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferCapabilitiesGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferCapabilitiesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferCapabilitiesGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferCapabilitiesGetSignal(output);
        Q_EMIT transferCapabilitiesGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferCapabilitiesGetSignalE(output, error_type, error_str);
        Q_EMIT transferCapabilitiesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferCapabilitiesGetSignalError(output, error_type, error_str);
        Q_EMIT transferCapabilitiesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferConfigurationGet(const OAITransferConfigurationGetRequest &oai_transfer_configuration_get_request) {
    QString fullPath = QString(_serverConfigs["transferConfigurationGet"][_serverIndices.value("transferConfigurationGet")].URL()+"/transfer/configuration/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_configuration_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferConfigurationGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferConfigurationGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferConfigurationGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferConfigurationGetSignal(output);
        Q_EMIT transferConfigurationGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferConfigurationGetSignalE(output, error_type, error_str);
        Q_EMIT transferConfigurationGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferConfigurationGetSignalError(output, error_type, error_str);
        Q_EMIT transferConfigurationGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferCreate(const OAITransferCreateRequest &oai_transfer_create_request) {
    QString fullPath = QString(_serverConfigs["transferCreate"][_serverIndices.value("transferCreate")].URL()+"/transfer/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferCreateSignal(output);
        Q_EMIT transferCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferCreateSignalE(output, error_type, error_str);
        Q_EMIT transferCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferCreateSignalError(output, error_type, error_str);
        Q_EMIT transferCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferEventList(const OAITransferEventListRequest &oai_transfer_event_list_request) {
    QString fullPath = QString(_serverConfigs["transferEventList"][_serverIndices.value("transferEventList")].URL()+"/transfer/event/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_event_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferEventListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferEventListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferEventListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferEventListSignal(output);
        Q_EMIT transferEventListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferEventListSignalE(output, error_type, error_str);
        Q_EMIT transferEventListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferEventListSignalError(output, error_type, error_str);
        Q_EMIT transferEventListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferEventSync(const OAITransferEventSyncRequest &oai_transfer_event_sync_request) {
    QString fullPath = QString(_serverConfigs["transferEventSync"][_serverIndices.value("transferEventSync")].URL()+"/transfer/event/sync");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_event_sync_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferEventSyncCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferEventSyncCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferEventSyncResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferEventSyncSignal(output);
        Q_EMIT transferEventSyncSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferEventSyncSignalE(output, error_type, error_str);
        Q_EMIT transferEventSyncSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferEventSyncSignalError(output, error_type, error_str);
        Q_EMIT transferEventSyncSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferGet(const OAITransferGetRequest &oai_transfer_get_request) {
    QString fullPath = QString(_serverConfigs["transferGet"][_serverIndices.value("transferGet")].URL()+"/transfer/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferGetSignal(output);
        Q_EMIT transferGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferGetSignalE(output, error_type, error_str);
        Q_EMIT transferGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferGetSignalError(output, error_type, error_str);
        Q_EMIT transferGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferIntentCreate(const OAITransferIntentCreateRequest &oai_transfer_intent_create_request) {
    QString fullPath = QString(_serverConfigs["transferIntentCreate"][_serverIndices.value("transferIntentCreate")].URL()+"/transfer/intent/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_intent_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferIntentCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferIntentCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferIntentCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferIntentCreateSignal(output);
        Q_EMIT transferIntentCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferIntentCreateSignalE(output, error_type, error_str);
        Q_EMIT transferIntentCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferIntentCreateSignalError(output, error_type, error_str);
        Q_EMIT transferIntentCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferIntentGet(const OAITransferIntentGetRequest &oai_transfer_intent_get_request) {
    QString fullPath = QString(_serverConfigs["transferIntentGet"][_serverIndices.value("transferIntentGet")].URL()+"/transfer/intent/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_intent_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferIntentGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferIntentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferIntentGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferIntentGetSignal(output);
        Q_EMIT transferIntentGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferIntentGetSignalE(output, error_type, error_str);
        Q_EMIT transferIntentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferIntentGetSignalError(output, error_type, error_str);
        Q_EMIT transferIntentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferList(const OAITransferListRequest &oai_transfer_list_request) {
    QString fullPath = QString(_serverConfigs["transferList"][_serverIndices.value("transferList")].URL()+"/transfer/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferListSignal(output);
        Q_EMIT transferListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferListSignalE(output, error_type, error_str);
        Q_EMIT transferListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferListSignalError(output, error_type, error_str);
        Q_EMIT transferListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferMetricsGet(const OAITransferMetricsGetRequest &oai_transfer_metrics_get_request) {
    QString fullPath = QString(_serverConfigs["transferMetricsGet"][_serverIndices.value("transferMetricsGet")].URL()+"/transfer/metrics/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_metrics_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferMetricsGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferMetricsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferMetricsGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferMetricsGetSignal(output);
        Q_EMIT transferMetricsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferMetricsGetSignalE(output, error_type, error_str);
        Q_EMIT transferMetricsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferMetricsGetSignalError(output, error_type, error_str);
        Q_EMIT transferMetricsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferMigrateAccount(const OAITransferMigrateAccountRequest &oai_transfer_migrate_account_request) {
    QString fullPath = QString(_serverConfigs["transferMigrateAccount"][_serverIndices.value("transferMigrateAccount")].URL()+"/transfer/migrate_account");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_migrate_account_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferMigrateAccountCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferMigrateAccountCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferMigrateAccountResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferMigrateAccountSignal(output);
        Q_EMIT transferMigrateAccountSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferMigrateAccountSignalE(output, error_type, error_str);
        Q_EMIT transferMigrateAccountSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferMigrateAccountSignalError(output, error_type, error_str);
        Q_EMIT transferMigrateAccountSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferOriginatorCreate(const OAITransferOriginatorCreateRequest &oai_transfer_originator_create_request) {
    QString fullPath = QString(_serverConfigs["transferOriginatorCreate"][_serverIndices.value("transferOriginatorCreate")].URL()+"/transfer/originator/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_originator_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferOriginatorCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferOriginatorCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferOriginatorCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferOriginatorCreateSignal(output);
        Q_EMIT transferOriginatorCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferOriginatorCreateSignalE(output, error_type, error_str);
        Q_EMIT transferOriginatorCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferOriginatorCreateSignalError(output, error_type, error_str);
        Q_EMIT transferOriginatorCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferOriginatorGet(const OAITransferOriginatorGetRequest &oai_transfer_originator_get_request) {
    QString fullPath = QString(_serverConfigs["transferOriginatorGet"][_serverIndices.value("transferOriginatorGet")].URL()+"/transfer/originator/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_originator_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferOriginatorGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferOriginatorGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferOriginatorGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferOriginatorGetSignal(output);
        Q_EMIT transferOriginatorGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferOriginatorGetSignalE(output, error_type, error_str);
        Q_EMIT transferOriginatorGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferOriginatorGetSignalError(output, error_type, error_str);
        Q_EMIT transferOriginatorGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferOriginatorList(const OAITransferOriginatorListRequest &oai_transfer_originator_list_request) {
    QString fullPath = QString(_serverConfigs["transferOriginatorList"][_serverIndices.value("transferOriginatorList")].URL()+"/transfer/originator/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_originator_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferOriginatorListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferOriginatorListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferOriginatorListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferOriginatorListSignal(output);
        Q_EMIT transferOriginatorListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferOriginatorListSignalE(output, error_type, error_str);
        Q_EMIT transferOriginatorListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferOriginatorListSignalError(output, error_type, error_str);
        Q_EMIT transferOriginatorListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferQuestionnaireCreate(const OAITransferQuestionnaireCreateRequest &oai_transfer_questionnaire_create_request) {
    QString fullPath = QString(_serverConfigs["transferQuestionnaireCreate"][_serverIndices.value("transferQuestionnaireCreate")].URL()+"/transfer/questionnaire/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_questionnaire_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferQuestionnaireCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferQuestionnaireCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferQuestionnaireCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferQuestionnaireCreateSignal(output);
        Q_EMIT transferQuestionnaireCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferQuestionnaireCreateSignalE(output, error_type, error_str);
        Q_EMIT transferQuestionnaireCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferQuestionnaireCreateSignalError(output, error_type, error_str);
        Q_EMIT transferQuestionnaireCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRecurringCancel(const OAITransferRecurringCancelRequest &oai_transfer_recurring_cancel_request) {
    QString fullPath = QString(_serverConfigs["transferRecurringCancel"][_serverIndices.value("transferRecurringCancel")].URL()+"/transfer/recurring/cancel");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_recurring_cancel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRecurringCancelCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRecurringCancelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRecurringCancelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRecurringCancelSignal(output);
        Q_EMIT transferRecurringCancelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRecurringCancelSignalE(output, error_type, error_str);
        Q_EMIT transferRecurringCancelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRecurringCancelSignalError(output, error_type, error_str);
        Q_EMIT transferRecurringCancelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRecurringCreate(const OAITransferRecurringCreateRequest &oai_transfer_recurring_create_request) {
    QString fullPath = QString(_serverConfigs["transferRecurringCreate"][_serverIndices.value("transferRecurringCreate")].URL()+"/transfer/recurring/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_recurring_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRecurringCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRecurringCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRecurringCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRecurringCreateSignal(output);
        Q_EMIT transferRecurringCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRecurringCreateSignalE(output, error_type, error_str);
        Q_EMIT transferRecurringCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRecurringCreateSignalError(output, error_type, error_str);
        Q_EMIT transferRecurringCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRecurringGet(const OAITransferRecurringGetRequest &oai_transfer_recurring_get_request) {
    QString fullPath = QString(_serverConfigs["transferRecurringGet"][_serverIndices.value("transferRecurringGet")].URL()+"/transfer/recurring/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_recurring_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRecurringGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRecurringGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRecurringGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRecurringGetSignal(output);
        Q_EMIT transferRecurringGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRecurringGetSignalE(output, error_type, error_str);
        Q_EMIT transferRecurringGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRecurringGetSignalError(output, error_type, error_str);
        Q_EMIT transferRecurringGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRecurringList(const OAITransferRecurringListRequest &oai_transfer_recurring_list_request) {
    QString fullPath = QString(_serverConfigs["transferRecurringList"][_serverIndices.value("transferRecurringList")].URL()+"/transfer/recurring/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_recurring_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRecurringListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRecurringListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRecurringListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRecurringListSignal(output);
        Q_EMIT transferRecurringListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRecurringListSignalE(output, error_type, error_str);
        Q_EMIT transferRecurringListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRecurringListSignalError(output, error_type, error_str);
        Q_EMIT transferRecurringListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRefundCancel(const OAITransferRefundCancelRequest &oai_transfer_refund_cancel_request) {
    QString fullPath = QString(_serverConfigs["transferRefundCancel"][_serverIndices.value("transferRefundCancel")].URL()+"/transfer/refund/cancel");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_refund_cancel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRefundCancelCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRefundCancelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRefundCancelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRefundCancelSignal(output);
        Q_EMIT transferRefundCancelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRefundCancelSignalE(output, error_type, error_str);
        Q_EMIT transferRefundCancelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRefundCancelSignalError(output, error_type, error_str);
        Q_EMIT transferRefundCancelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRefundCreate(const OAITransferRefundCreateRequest &oai_transfer_refund_create_request) {
    QString fullPath = QString(_serverConfigs["transferRefundCreate"][_serverIndices.value("transferRefundCreate")].URL()+"/transfer/refund/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_refund_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRefundCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRefundCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRefundCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRefundCreateSignal(output);
        Q_EMIT transferRefundCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRefundCreateSignalE(output, error_type, error_str);
        Q_EMIT transferRefundCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRefundCreateSignalError(output, error_type, error_str);
        Q_EMIT transferRefundCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRefundGet(const OAITransferRefundGetRequest &oai_transfer_refund_get_request) {
    QString fullPath = QString(_serverConfigs["transferRefundGet"][_serverIndices.value("transferRefundGet")].URL()+"/transfer/refund/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_refund_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRefundGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRefundGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRefundGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRefundGetSignal(output);
        Q_EMIT transferRefundGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRefundGetSignalE(output, error_type, error_str);
        Q_EMIT transferRefundGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRefundGetSignalError(output, error_type, error_str);
        Q_EMIT transferRefundGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRepaymentList(const OAITransferRepaymentListRequest &oai_transfer_repayment_list_request) {
    QString fullPath = QString(_serverConfigs["transferRepaymentList"][_serverIndices.value("transferRepaymentList")].URL()+"/transfer/repayment/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_repayment_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRepaymentListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRepaymentListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRepaymentListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRepaymentListSignal(output);
        Q_EMIT transferRepaymentListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRepaymentListSignalE(output, error_type, error_str);
        Q_EMIT transferRepaymentListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRepaymentListSignalError(output, error_type, error_str);
        Q_EMIT transferRepaymentListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferRepaymentReturnList(const OAITransferRepaymentReturnListRequest &oai_transfer_repayment_return_list_request) {
    QString fullPath = QString(_serverConfigs["transferRepaymentReturnList"][_serverIndices.value("transferRepaymentReturnList")].URL()+"/transfer/repayment/return/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_repayment_return_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferRepaymentReturnListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferRepaymentReturnListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferRepaymentReturnListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferRepaymentReturnListSignal(output);
        Q_EMIT transferRepaymentReturnListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferRepaymentReturnListSignalE(output, error_type, error_str);
        Q_EMIT transferRepaymentReturnListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferRepaymentReturnListSignalError(output, error_type, error_str);
        Q_EMIT transferRepaymentReturnListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferSweepGet(const OAITransferSweepGetRequest &oai_transfer_sweep_get_request) {
    QString fullPath = QString(_serverConfigs["transferSweepGet"][_serverIndices.value("transferSweepGet")].URL()+"/transfer/sweep/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_sweep_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferSweepGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferSweepGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferSweepGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferSweepGetSignal(output);
        Q_EMIT transferSweepGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferSweepGetSignalE(output, error_type, error_str);
        Q_EMIT transferSweepGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferSweepGetSignalError(output, error_type, error_str);
        Q_EMIT transferSweepGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::transferSweepList(const OAITransferSweepListRequest &oai_transfer_sweep_list_request) {
    QString fullPath = QString(_serverConfigs["transferSweepList"][_serverIndices.value("transferSweepList")].URL()+"/transfer/sweep/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_transfer_sweep_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::transferSweepListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::transferSweepListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferSweepListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transferSweepListSignal(output);
        Q_EMIT transferSweepListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transferSweepListSignalE(output, error_type, error_str);
        Q_EMIT transferSweepListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transferSweepListSignalError(output, error_type, error_str);
        Q_EMIT transferSweepListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::userCreate(const OAIUserCreateRequest &oai_user_create_request) {
    QString fullPath = QString(_serverConfigs["userCreate"][_serverIndices.value("userCreate")].URL()+"/user/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_user_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::userCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::userCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUserCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT userCreateSignal(output);
        Q_EMIT userCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT userCreateSignalE(output, error_type, error_str);
        Q_EMIT userCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT userCreateSignalError(output, error_type, error_str);
        Q_EMIT userCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::walletCreate(const OAIWalletCreateRequest &oai_wallet_create_request) {
    QString fullPath = QString(_serverConfigs["walletCreate"][_serverIndices.value("walletCreate")].URL()+"/wallet/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wallet_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::walletCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::walletCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWalletCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT walletCreateSignal(output);
        Q_EMIT walletCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT walletCreateSignalE(output, error_type, error_str);
        Q_EMIT walletCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT walletCreateSignalError(output, error_type, error_str);
        Q_EMIT walletCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::walletGet(const OAIWalletGetRequest &oai_wallet_get_request) {
    QString fullPath = QString(_serverConfigs["walletGet"][_serverIndices.value("walletGet")].URL()+"/wallet/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wallet_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::walletGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::walletGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWalletGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT walletGetSignal(output);
        Q_EMIT walletGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT walletGetSignalE(output, error_type, error_str);
        Q_EMIT walletGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT walletGetSignalError(output, error_type, error_str);
        Q_EMIT walletGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::walletList(const OAIWalletListRequest &oai_wallet_list_request) {
    QString fullPath = QString(_serverConfigs["walletList"][_serverIndices.value("walletList")].URL()+"/wallet/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wallet_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::walletListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::walletListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWalletListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT walletListSignal(output);
        Q_EMIT walletListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT walletListSignalE(output, error_type, error_str);
        Q_EMIT walletListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT walletListSignalError(output, error_type, error_str);
        Q_EMIT walletListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::walletTransactionExecute(const OAIWalletTransactionExecuteRequest &oai_wallet_transaction_execute_request) {
    QString fullPath = QString(_serverConfigs["walletTransactionExecute"][_serverIndices.value("walletTransactionExecute")].URL()+"/wallet/transaction/execute");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wallet_transaction_execute_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::walletTransactionExecuteCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::walletTransactionExecuteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWalletTransactionExecuteResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT walletTransactionExecuteSignal(output);
        Q_EMIT walletTransactionExecuteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT walletTransactionExecuteSignalE(output, error_type, error_str);
        Q_EMIT walletTransactionExecuteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT walletTransactionExecuteSignalError(output, error_type, error_str);
        Q_EMIT walletTransactionExecuteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::walletTransactionGet(const OAIWalletTransactionGetRequest &oai_wallet_transaction_get_request) {
    QString fullPath = QString(_serverConfigs["walletTransactionGet"][_serverIndices.value("walletTransactionGet")].URL()+"/wallet/transaction/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wallet_transaction_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::walletTransactionGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::walletTransactionGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWalletTransactionGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT walletTransactionGetSignal(output);
        Q_EMIT walletTransactionGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT walletTransactionGetSignalE(output, error_type, error_str);
        Q_EMIT walletTransactionGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT walletTransactionGetSignalError(output, error_type, error_str);
        Q_EMIT walletTransactionGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::walletTransactionList(const OAIWalletTransactionListRequest &oai_wallet_transaction_list_request) {
    QString fullPath = QString(_serverConfigs["walletTransactionList"][_serverIndices.value("walletTransactionList")].URL()+"/wallet/transaction/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wallet_transaction_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::walletTransactionListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::walletTransactionListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWalletTransactionListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT walletTransactionListSignal(output);
        Q_EMIT walletTransactionListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT walletTransactionListSignalE(output, error_type, error_str);
        Q_EMIT walletTransactionListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT walletTransactionListSignalError(output, error_type, error_str);
        Q_EMIT walletTransactionListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityCreate(const OAIWatchlistScreeningEntityCreateRequest &oai_watchlist_screening_entity_create_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityCreate"][_serverIndices.value("watchlistScreeningEntityCreate")].URL()+"/watchlist_screening/entity/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityCreateSignal(output);
        Q_EMIT watchlistScreeningEntityCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityCreateSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityCreateSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityGet(const OAIWatchlistScreeningEntityGetRequest &oai_watchlist_screening_entity_get_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityGet"][_serverIndices.value("watchlistScreeningEntityGet")].URL()+"/watchlist_screening/entity/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityGetSignal(output);
        Q_EMIT watchlistScreeningEntityGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityGetSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityGetSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityHistoryList(const OAIWatchlistScreeningEntityHistoryListRequest &oai_watchlist_screening_entity_history_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityHistoryList"][_serverIndices.value("watchlistScreeningEntityHistoryList")].URL()+"/watchlist_screening/entity/history/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_history_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityHistoryListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityHistoryListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityHistoryListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityHistoryListSignal(output);
        Q_EMIT watchlistScreeningEntityHistoryListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityHistoryListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityHistoryListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityHistoryListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityHistoryListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityHitList(const OAIWatchlistScreeningEntityHitListRequest &oai_watchlist_screening_entity_hit_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityHitList"][_serverIndices.value("watchlistScreeningEntityHitList")].URL()+"/watchlist_screening/entity/hit/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_hit_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityHitListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityHitListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityHitListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityHitListSignal(output);
        Q_EMIT watchlistScreeningEntityHitListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityHitListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityHitListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityHitListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityHitListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityList(const OAIWatchlistScreeningEntityListRequest &oai_watchlist_screening_entity_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityList"][_serverIndices.value("watchlistScreeningEntityList")].URL()+"/watchlist_screening/entity/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityListSignal(output);
        Q_EMIT watchlistScreeningEntityListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityProgramGet(const OAIWatchlistScreeningEntityProgramGetRequest &oai_watchlist_screening_entity_program_get_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityProgramGet"][_serverIndices.value("watchlistScreeningEntityProgramGet")].URL()+"/watchlist_screening/entity/program/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_program_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityProgramGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityProgramGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityProgramGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityProgramGetSignal(output);
        Q_EMIT watchlistScreeningEntityProgramGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityProgramGetSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityProgramGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityProgramGetSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityProgramGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityProgramList(const OAIWatchlistScreeningEntityProgramListRequest &oai_watchlist_screening_entity_program_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityProgramList"][_serverIndices.value("watchlistScreeningEntityProgramList")].URL()+"/watchlist_screening/entity/program/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_program_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityProgramListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityProgramListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityProgramListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityProgramListSignal(output);
        Q_EMIT watchlistScreeningEntityProgramListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityProgramListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityProgramListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityProgramListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityProgramListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityReviewCreate(const OAIWatchlistScreeningEntityReviewCreateRequest &oai_watchlist_screening_entity_review_create_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityReviewCreate"][_serverIndices.value("watchlistScreeningEntityReviewCreate")].URL()+"/watchlist_screening/entity/review/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_review_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityReviewCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityReviewCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityReviewCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityReviewCreateSignal(output);
        Q_EMIT watchlistScreeningEntityReviewCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityReviewCreateSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityReviewCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityReviewCreateSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityReviewCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityReviewList(const OAIWatchlistScreeningEntityReviewListRequest &oai_watchlist_screening_entity_review_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityReviewList"][_serverIndices.value("watchlistScreeningEntityReviewList")].URL()+"/watchlist_screening/entity/review/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_review_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityReviewListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityReviewListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityReviewListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityReviewListSignal(output);
        Q_EMIT watchlistScreeningEntityReviewListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityReviewListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityReviewListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityReviewListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityReviewListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningEntityUpdate(const OAIWatchlistScreeningEntityUpdateRequest &oai_watchlist_screening_entity_update_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningEntityUpdate"][_serverIndices.value("watchlistScreeningEntityUpdate")].URL()+"/watchlist_screening/entity/update");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_entity_update_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningEntityUpdateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningEntityUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningEntityUpdateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningEntityUpdateSignal(output);
        Q_EMIT watchlistScreeningEntityUpdateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningEntityUpdateSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningEntityUpdateSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningEntityUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualCreate(const OAIWatchlistScreeningIndividualCreateRequest &oai_watchlist_screening_individual_create_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualCreate"][_serverIndices.value("watchlistScreeningIndividualCreate")].URL()+"/watchlist_screening/individual/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualCreateSignal(output);
        Q_EMIT watchlistScreeningIndividualCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualCreateSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualCreateSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualGet(const OAIWatchlistScreeningIndividualGetRequest &oai_watchlist_screening_individual_get_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualGet"][_serverIndices.value("watchlistScreeningIndividualGet")].URL()+"/watchlist_screening/individual/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualGetSignal(output);
        Q_EMIT watchlistScreeningIndividualGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualGetSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualGetSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualHistoryList(const OAIWatchlistScreeningIndividualHistoryListRequest &oai_watchlist_screening_individual_history_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualHistoryList"][_serverIndices.value("watchlistScreeningIndividualHistoryList")].URL()+"/watchlist_screening/individual/history/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_history_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualHistoryListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualHistoryListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualHistoryListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualHistoryListSignal(output);
        Q_EMIT watchlistScreeningIndividualHistoryListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualHistoryListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualHistoryListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualHistoryListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualHistoryListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualHitList(const OAIWatchlistScreeningIndividualHitListRequest &oai_watchlist_screening_individual_hit_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualHitList"][_serverIndices.value("watchlistScreeningIndividualHitList")].URL()+"/watchlist_screening/individual/hit/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_hit_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualHitListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualHitListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualHitListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualHitListSignal(output);
        Q_EMIT watchlistScreeningIndividualHitListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualHitListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualHitListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualHitListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualHitListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualList(const OAIWatchlistScreeningIndividualListRequest &oai_watchlist_screening_individual_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualList"][_serverIndices.value("watchlistScreeningIndividualList")].URL()+"/watchlist_screening/individual/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualListSignal(output);
        Q_EMIT watchlistScreeningIndividualListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualProgramGet(const OAIWatchlistScreeningIndividualProgramGetRequest &oai_watchlist_screening_individual_program_get_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualProgramGet"][_serverIndices.value("watchlistScreeningIndividualProgramGet")].URL()+"/watchlist_screening/individual/program/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_program_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualProgramGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualProgramGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualProgramGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualProgramGetSignal(output);
        Q_EMIT watchlistScreeningIndividualProgramGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualProgramGetSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualProgramGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualProgramGetSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualProgramGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualProgramList(const OAIWatchlistScreeningIndividualProgramListRequest &oai_watchlist_screening_individual_program_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualProgramList"][_serverIndices.value("watchlistScreeningIndividualProgramList")].URL()+"/watchlist_screening/individual/program/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_program_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualProgramListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualProgramListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualProgramListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualProgramListSignal(output);
        Q_EMIT watchlistScreeningIndividualProgramListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualProgramListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualProgramListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualProgramListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualProgramListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualReviewCreate(const OAIWatchlistScreeningIndividualReviewCreateRequest &oai_watchlist_screening_individual_review_create_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualReviewCreate"][_serverIndices.value("watchlistScreeningIndividualReviewCreate")].URL()+"/watchlist_screening/individual/review/create");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_review_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualReviewCreateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualReviewCreateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualReviewCreateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualReviewCreateSignal(output);
        Q_EMIT watchlistScreeningIndividualReviewCreateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualReviewCreateSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualReviewCreateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualReviewCreateSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualReviewCreateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualReviewList(const OAIWatchlistScreeningIndividualReviewListRequest &oai_watchlist_screening_individual_review_list_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualReviewList"][_serverIndices.value("watchlistScreeningIndividualReviewList")].URL()+"/watchlist_screening/individual/review/list");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_review_list_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualReviewListCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualReviewListCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualReviewListResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualReviewListSignal(output);
        Q_EMIT watchlistScreeningIndividualReviewListSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualReviewListSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualReviewListSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualReviewListSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualReviewListSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::watchlistScreeningIndividualUpdate(const OAIWatchlistScreeningIndividualUpdateRequest &oai_watchlist_screening_individual_update_request) {
    QString fullPath = QString(_serverConfigs["watchlistScreeningIndividualUpdate"][_serverIndices.value("watchlistScreeningIndividualUpdate")].URL()+"/watchlist_screening/individual/update");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_watchlist_screening_individual_update_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::watchlistScreeningIndividualUpdateCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::watchlistScreeningIndividualUpdateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWatchlistScreeningIndividualUpdateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT watchlistScreeningIndividualUpdateSignal(output);
        Q_EMIT watchlistScreeningIndividualUpdateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT watchlistScreeningIndividualUpdateSignalE(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualUpdateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT watchlistScreeningIndividualUpdateSignalError(output, error_type, error_str);
        Q_EMIT watchlistScreeningIndividualUpdateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::webhookVerificationKeyGet(const OAIWebhookVerificationKeyGetRequest &oai_webhook_verification_key_get_request) {
    QString fullPath = QString(_serverConfigs["webhookVerificationKeyGet"][_serverIndices.value("webhookVerificationKeyGet")].URL()+"/webhook_verification_key/get");
    
    if (_apiKeys.contains("clientId")) {
        addHeaders("clientId",_apiKeys.find("clientId").value());
    }
    
    if (_apiKeys.contains("plaidVersion")) {
        addHeaders("plaidVersion",_apiKeys.find("plaidVersion").value());
    }
    
    if (_apiKeys.contains("secret")) {
        addHeaders("secret",_apiKeys.find("secret").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_webhook_verification_key_get_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPlaidApi::webhookVerificationKeyGetCallback);
    connect(this, &OAIPlaidApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPlaidApi::webhookVerificationKeyGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWebhookVerificationKeyGetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT webhookVerificationKeyGetSignal(output);
        Q_EMIT webhookVerificationKeyGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT webhookVerificationKeyGetSignalE(output, error_type, error_str);
        Q_EMIT webhookVerificationKeyGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT webhookVerificationKeyGetSignalError(output, error_type, error_str);
        Q_EMIT webhookVerificationKeyGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPlaidApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
