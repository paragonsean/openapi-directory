/**
 * reverb
 * reverb
 *
 * The version of the OpenAPI document: 3.0
 * Contact: integrations@reverb.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMyApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIMyApi::OAIMyApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIMyApi::~OAIMyApi() {
}

void OAIMyApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.reverb.com/api"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("myAccountGet", defaultConf);
    _serverIndices.insert("myAccountGet", 0);
    _serverConfigs.insert("myAccountPut", defaultConf);
    _serverIndices.insert("myAccountPut", 0);
    _serverConfigs.insert("myAddressesAddressIdDelete", defaultConf);
    _serverIndices.insert("myAddressesAddressIdDelete", 0);
    _serverConfigs.insert("myAddressesAddressIdPut", defaultConf);
    _serverIndices.insert("myAddressesAddressIdPut", 0);
    _serverConfigs.insert("myAddressesGet", defaultConf);
    _serverIndices.insert("myAddressesGet", 0);
    _serverConfigs.insert("myAddressesPost", defaultConf);
    _serverIndices.insert("myAddressesPost", 0);
    _serverConfigs.insert("myConversationsConversationIdMessagesPost", defaultConf);
    _serverIndices.insert("myConversationsConversationIdMessagesPost", 0);
    _serverConfigs.insert("myConversationsGet", defaultConf);
    _serverIndices.insert("myConversationsGet", 0);
    _serverConfigs.insert("myConversationsIdGet", defaultConf);
    _serverIndices.insert("myConversationsIdGet", 0);
    _serverConfigs.insert("myConversationsIdPut", defaultConf);
    _serverIndices.insert("myConversationsIdPut", 0);
    _serverConfigs.insert("myConversationsPost", defaultConf);
    _serverIndices.insert("myConversationsPost", 0);
    _serverConfigs.insert("myCountsGet", defaultConf);
    _serverIndices.insert("myCountsGet", 0);
    _serverConfigs.insert("myCuratedSetProductProductIdDelete", defaultConf);
    _serverIndices.insert("myCuratedSetProductProductIdDelete", 0);
    _serverConfigs.insert("myCuratedSetProductProductIdPost", defaultConf);
    _serverIndices.insert("myCuratedSetProductProductIdPost", 0);
    _serverConfigs.insert("myFeedCustomizeGet", defaultConf);
    _serverIndices.insert("myFeedCustomizeGet", 0);
    _serverConfigs.insert("myFeedGet", defaultConf);
    _serverIndices.insert("myFeedGet", 0);
    _serverConfigs.insert("myFeedGridGet", defaultConf);
    _serverIndices.insert("myFeedGridGet", 0);
    _serverConfigs.insert("myFeedbackReceivedGet", defaultConf);
    _serverIndices.insert("myFeedbackReceivedGet", 0);
    _serverConfigs.insert("myFeedbackSentGet", defaultConf);
    _serverIndices.insert("myFeedbackSentGet", 0);
    _serverConfigs.insert("myFollowsArticlesGet", defaultConf);
    _serverIndices.insert("myFollowsArticlesGet", 0);
    _serverConfigs.insert("myFollowsArticlesPost", defaultConf);
    _serverIndices.insert("myFollowsArticlesPost", 0);
    _serverConfigs.insert("myFollowsBrandsSlugDelete", defaultConf);
    _serverIndices.insert("myFollowsBrandsSlugDelete", 0);
    _serverConfigs.insert("myFollowsBrandsSlugGet", defaultConf);
    _serverIndices.insert("myFollowsBrandsSlugGet", 0);
    _serverConfigs.insert("myFollowsBrandsSlugPost", defaultConf);
    _serverIndices.insert("myFollowsBrandsSlugPost", 0);
    _serverConfigs.insert("myFollowsCategoriesCategorySubcategoryDelete", defaultConf);
    _serverIndices.insert("myFollowsCategoriesCategorySubcategoryDelete", 0);
    _serverConfigs.insert("myFollowsCategoriesCategorySubcategoryGet", defaultConf);
    _serverIndices.insert("myFollowsCategoriesCategorySubcategoryGet", 0);
    _serverConfigs.insert("myFollowsCategoriesCategorySubcategoryPost", defaultConf);
    _serverIndices.insert("myFollowsCategoriesCategorySubcategoryPost", 0);
    _serverConfigs.insert("myFollowsCategoriesIdentifierDelete", defaultConf);
    _serverIndices.insert("myFollowsCategoriesIdentifierDelete", 0);
    _serverConfigs.insert("myFollowsCategoriesIdentifierGet", defaultConf);
    _serverIndices.insert("myFollowsCategoriesIdentifierGet", 0);
    _serverConfigs.insert("myFollowsCategoriesIdentifierPost", defaultConf);
    _serverIndices.insert("myFollowsCategoriesIdentifierPost", 0);
    _serverConfigs.insert("myFollowsCategoriesUuidPost", defaultConf);
    _serverIndices.insert("myFollowsCategoriesUuidPost", 0);
    _serverConfigs.insert("myFollowsCollectionsSlugDelete", defaultConf);
    _serverIndices.insert("myFollowsCollectionsSlugDelete", 0);
    _serverConfigs.insert("myFollowsCollectionsSlugGet", defaultConf);
    _serverIndices.insert("myFollowsCollectionsSlugGet", 0);
    _serverConfigs.insert("myFollowsCollectionsSlugPost", defaultConf);
    _serverIndices.insert("myFollowsCollectionsSlugPost", 0);
    _serverConfigs.insert("myFollowsFollowIdAlertDelete", defaultConf);
    _serverIndices.insert("myFollowsFollowIdAlertDelete", 0);
    _serverConfigs.insert("myFollowsFollowIdAlertPost", defaultConf);
    _serverIndices.insert("myFollowsFollowIdAlertPost", 0);
    _serverConfigs.insert("myFollowsFollowIdDelete", defaultConf);
    _serverIndices.insert("myFollowsFollowIdDelete", 0);
    _serverConfigs.insert("myFollowsGet", defaultConf);
    _serverIndices.insert("myFollowsGet", 0);
    _serverConfigs.insert("myFollowsHandpickedSlugDelete", defaultConf);
    _serverIndices.insert("myFollowsHandpickedSlugDelete", 0);
    _serverConfigs.insert("myFollowsHandpickedSlugGet", defaultConf);
    _serverIndices.insert("myFollowsHandpickedSlugGet", 0);
    _serverConfigs.insert("myFollowsHandpickedSlugPost", defaultConf);
    _serverIndices.insert("myFollowsHandpickedSlugPost", 0);
    _serverConfigs.insert("myFollowsSearchGet", defaultConf);
    _serverIndices.insert("myFollowsSearchGet", 0);
    _serverConfigs.insert("myFollowsSearchPost", defaultConf);
    _serverIndices.insert("myFollowsSearchPost", 0);
    _serverConfigs.insert("myFollowsShopsSlugDelete", defaultConf);
    _serverIndices.insert("myFollowsShopsSlugDelete", 0);
    _serverConfigs.insert("myFollowsShopsSlugGet", defaultConf);
    _serverIndices.insert("myFollowsShopsSlugGet", 0);
    _serverConfigs.insert("myFollowsShopsSlugPost", defaultConf);
    _serverIndices.insert("myFollowsShopsSlugPost", 0);
    _serverConfigs.insert("myListingsDraftsGet", defaultConf);
    _serverIndices.insert("myListingsDraftsGet", 0);
    _serverConfigs.insert("myListingsGet", defaultConf);
    _serverIndices.insert("myListingsGet", 0);
    _serverConfigs.insert("myListingsNegotiationsGet", defaultConf);
    _serverIndices.insert("myListingsNegotiationsGet", 0);
    _serverConfigs.insert("myListingsSlugStateEndPut", defaultConf);
    _serverIndices.insert("myListingsSlugStateEndPut", 0);
    _serverConfigs.insert("myListsGet", defaultConf);
    _serverIndices.insert("myListsGet", 0);
    _serverConfigs.insert("myNegotiationsBuyingGet", defaultConf);
    _serverIndices.insert("myNegotiationsBuyingGet", 0);
    _serverConfigs.insert("myNegotiationsIdAcceptPost", defaultConf);
    _serverIndices.insert("myNegotiationsIdAcceptPost", 0);
    _serverConfigs.insert("myNegotiationsIdCounterPost", defaultConf);
    _serverIndices.insert("myNegotiationsIdCounterPost", 0);
    _serverConfigs.insert("myNegotiationsIdDeclinePost", defaultConf);
    _serverIndices.insert("myNegotiationsIdDeclinePost", 0);
    _serverConfigs.insert("myNegotiationsIdGet", defaultConf);
    _serverIndices.insert("myNegotiationsIdGet", 0);
    _serverConfigs.insert("myOrdersAwaitingFeedbackGet", defaultConf);
    _serverIndices.insert("myOrdersAwaitingFeedbackGet", 0);
    _serverConfigs.insert("myOrdersBuyingAllGet", defaultConf);
    _serverIndices.insert("myOrdersBuyingAllGet", 0);
    _serverConfigs.insert("myOrdersBuyingByUuidUuidGet", defaultConf);
    _serverIndices.insert("myOrdersBuyingByUuidUuidGet", 0);
    _serverConfigs.insert("myOrdersBuyingIdGet", defaultConf);
    _serverIndices.insert("myOrdersBuyingIdGet", 0);
    _serverConfigs.insert("myOrdersBuyingIdMarkReceivedPost", defaultConf);
    _serverIndices.insert("myOrdersBuyingIdMarkReceivedPost", 0);
    _serverConfigs.insert("myOrdersBuyingUnpaidGet", defaultConf);
    _serverIndices.insert("myOrdersBuyingUnpaidGet", 0);
    _serverConfigs.insert("myOrdersSellingAllGet", defaultConf);
    _serverIndices.insert("myOrdersSellingAllGet", 0);
    _serverConfigs.insert("myOrdersSellingAwaitingShipmentGet", defaultConf);
    _serverIndices.insert("myOrdersSellingAwaitingShipmentGet", 0);
    _serverConfigs.insert("myOrdersSellingBuyerHistoryBuyerIdGet", defaultConf);
    _serverIndices.insert("myOrdersSellingBuyerHistoryBuyerIdGet", 0);
    _serverConfigs.insert("myOrdersSellingByUuidUuidGet", defaultConf);
    _serverIndices.insert("myOrdersSellingByUuidUuidGet", 0);
    _serverConfigs.insert("myOrdersSellingIdGet", defaultConf);
    _serverIndices.insert("myOrdersSellingIdGet", 0);
    _serverConfigs.insert("myOrdersSellingIdMarkPickedUpPost", defaultConf);
    _serverIndices.insert("myOrdersSellingIdMarkPickedUpPost", 0);
    _serverConfigs.insert("myOrdersSellingIdShipPost", defaultConf);
    _serverIndices.insert("myOrdersSellingIdShipPost", 0);
    _serverConfigs.insert("myOrdersSellingOrderIdRefundRequestsPost", defaultConf);
    _serverIndices.insert("myOrdersSellingOrderIdRefundRequestsPost", 0);
    _serverConfigs.insert("myOrdersSellingUnpaidGet", defaultConf);
    _serverIndices.insert("myOrdersSellingUnpaidGet", 0);
    _serverConfigs.insert("myPaymentsSellingGet", defaultConf);
    _serverIndices.insert("myPaymentsSellingGet", 0);
    _serverConfigs.insert("myPaymentsSellingIdGet", defaultConf);
    _serverIndices.insert("myPaymentsSellingIdGet", 0);
    _serverConfigs.insert("myPayoutsGet", defaultConf);
    _serverIndices.insert("myPayoutsGet", 0);
    _serverConfigs.insert("myPayoutsIdLineItemsGet", defaultConf);
    _serverIndices.insert("myPayoutsIdLineItemsGet", 0);
    _serverConfigs.insert("myRefundRequestsSellingGet", defaultConf);
    _serverIndices.insert("myRefundRequestsSellingGet", 0);
    _serverConfigs.insert("myRefundRequestsSellingIdPut", defaultConf);
    _serverIndices.insert("myRefundRequestsSellingIdPut", 0);
    _serverConfigs.insert("myViewedListingsGet", defaultConf);
    _serverIndices.insert("myViewedListingsGet", 0);
    _serverConfigs.insert("myWishlistGet", defaultConf);
    _serverIndices.insert("myWishlistGet", 0);
    _serverConfigs.insert("myWishlistIdDelete", defaultConf);
    _serverIndices.insert("myWishlistIdDelete", 0);
    _serverConfigs.insert("myWishlistIdPut", defaultConf);
    _serverIndices.insert("myWishlistIdPut", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIMyApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIMyApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIMyApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIMyApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIMyApi::setUsername(const QString &username) {
    _username = username;
}

void OAIMyApi::setPassword(const QString &password) {
    _password = password;
}


void OAIMyApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIMyApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIMyApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIMyApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIMyApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIMyApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIMyApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIMyApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIMyApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIMyApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIMyApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIMyApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIMyApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIMyApi::myAccountGet() {
    QString fullPath = QString(_serverConfigs["myAccountGet"][_serverIndices.value("myAccountGet")].URL()+"/my/account");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAccountGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_profile");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAccountGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myAccountGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myAccountGetSignal();
        Q_EMIT myAccountGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_profile");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myAccountGetSignalE(error_type, error_str);
        Q_EMIT myAccountGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myAccountGetSignalError(error_type, error_str);
        Q_EMIT myAccountGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myAccountPut(const ::OpenAPI::OptionalParam<OAI_my_account_put_request> &oai_my_account_put_request) {
    QString fullPath = QString(_serverConfigs["myAccountPut"][_serverIndices.value("myAccountPut")].URL()+"/my/account");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_my_account_put_request.hasValue()){

        
        QByteArray output = oai_my_account_put_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAccountPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_profile");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAccountPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myAccountPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myAccountPutSignal();
        Q_EMIT myAccountPutSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_profile");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myAccountPutSignalE(error_type, error_str);
        Q_EMIT myAccountPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myAccountPutSignalError(error_type, error_str);
        Q_EMIT myAccountPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myAddressesAddressIdDelete(const QString &address_id) {
    QString fullPath = QString(_serverConfigs["myAddressesAddressIdDelete"][_serverIndices.value("myAddressesAddressIdDelete")].URL()+"/my/addresses/{address_id}");
    
    
    {
        QString address_idPathParam("{");
        address_idPathParam.append("address_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "address_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"address_id"+pathSuffix : pathPrefix;
        fullPath.replace(address_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(address_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesAddressIdDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_profile");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesAddressIdDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myAddressesAddressIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myAddressesAddressIdDeleteSignal();
        Q_EMIT myAddressesAddressIdDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_profile");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myAddressesAddressIdDeleteSignalE(error_type, error_str);
        Q_EMIT myAddressesAddressIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myAddressesAddressIdDeleteSignalError(error_type, error_str);
        Q_EMIT myAddressesAddressIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myAddressesAddressIdPut(const QString &address_id) {
    QString fullPath = QString(_serverConfigs["myAddressesAddressIdPut"][_serverIndices.value("myAddressesAddressIdPut")].URL()+"/my/addresses/{address_id}");
    
    
    {
        QString address_idPathParam("{");
        address_idPathParam.append("address_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "address_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"address_id"+pathSuffix : pathPrefix;
        fullPath.replace(address_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(address_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesAddressIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_profile");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesAddressIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myAddressesAddressIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myAddressesAddressIdPutSignal();
        Q_EMIT myAddressesAddressIdPutSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_profile");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myAddressesAddressIdPutSignalE(error_type, error_str);
        Q_EMIT myAddressesAddressIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myAddressesAddressIdPutSignalError(error_type, error_str);
        Q_EMIT myAddressesAddressIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myAddressesGet() {
    QString fullPath = QString(_serverConfigs["myAddressesGet"][_serverIndices.value("myAddressesGet")].URL()+"/my/addresses");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_profile");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myAddressesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myAddressesGetSignal();
        Q_EMIT myAddressesGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_profile");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myAddressesGetSignalE(error_type, error_str);
        Q_EMIT myAddressesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myAddressesGetSignalError(error_type, error_str);
        Q_EMIT myAddressesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myAddressesPost() {
    QString fullPath = QString(_serverConfigs["myAddressesPost"][_serverIndices.value("myAddressesPost")].URL()+"/my/addresses");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_profile");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myAddressesPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myAddressesPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myAddressesPostSignal();
        Q_EMIT myAddressesPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_profile");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myAddressesPostSignalE(error_type, error_str);
        Q_EMIT myAddressesPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myAddressesPostSignalError(error_type, error_str);
        Q_EMIT myAddressesPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myConversationsConversationIdMessagesPost(const QString &conversation_id, const ::OpenAPI::OptionalParam<OAI_listings__listing_id__conversations_post_request> &oai_listings__listing_id__conversations_post_request) {
    QString fullPath = QString(_serverConfigs["myConversationsConversationIdMessagesPost"][_serverIndices.value("myConversationsConversationIdMessagesPost")].URL()+"/my/conversations/{conversation_id}/messages");
    
    
    {
        QString conversation_idPathParam("{");
        conversation_idPathParam.append("conversation_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "conversation_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"conversation_id"+pathSuffix : pathPrefix;
        fullPath.replace(conversation_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(conversation_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_listings__listing_id__conversations_post_request.hasValue()){

        
        QByteArray output = oai_listings__listing_id__conversations_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsConversationIdMessagesPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_messages");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsConversationIdMessagesPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myConversationsConversationIdMessagesPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myConversationsConversationIdMessagesPostSignal();
        Q_EMIT myConversationsConversationIdMessagesPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_messages");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myConversationsConversationIdMessagesPostSignalE(error_type, error_str);
        Q_EMIT myConversationsConversationIdMessagesPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myConversationsConversationIdMessagesPostSignalError(error_type, error_str);
        Q_EMIT myConversationsConversationIdMessagesPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myConversationsGet(const ::OpenAPI::OptionalParam<QString> &search, const ::OpenAPI::OptionalParam<bool> &unread_only, const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &per_page, const ::OpenAPI::OptionalParam<qint32> &offset) {
    QString fullPath = QString(_serverConfigs["myConversationsGet"][_serverIndices.value("myConversationsGet")].URL()+"/my/conversations");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (search.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "search", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("search")).append(querySuffix).append(QUrl::toPercentEncoding(search.stringValue()));
    }
    if (unread_only.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "unread_only", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("unread_only")).append(querySuffix).append(QUrl::toPercentEncoding(unread_only.stringValue()));
    }
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_messages");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myConversationsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myConversationsGetSignal();
        Q_EMIT myConversationsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_messages");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myConversationsGetSignalE(error_type, error_str);
        Q_EMIT myConversationsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myConversationsGetSignalError(error_type, error_str);
        Q_EMIT myConversationsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myConversationsIdGet(const QString &id) {
    QString fullPath = QString(_serverConfigs["myConversationsIdGet"][_serverIndices.value("myConversationsIdGet")].URL()+"/my/conversations/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_messages");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myConversationsIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myConversationsIdGetSignal();
        Q_EMIT myConversationsIdGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_messages");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myConversationsIdGetSignalE(error_type, error_str);
        Q_EMIT myConversationsIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myConversationsIdGetSignalError(error_type, error_str);
        Q_EMIT myConversationsIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myConversationsIdPut(const QString &id, const ::OpenAPI::OptionalParam<OAI_my_conversations__id__put_request> &oai_my_conversations__id__put_request) {
    QString fullPath = QString(_serverConfigs["myConversationsIdPut"][_serverIndices.value("myConversationsIdPut")].URL()+"/my/conversations/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_my_conversations__id__put_request.hasValue()){

        
        QByteArray output = oai_my_conversations__id__put_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_messages");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myConversationsIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myConversationsIdPutSignal();
        Q_EMIT myConversationsIdPutSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_messages");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myConversationsIdPutSignalE(error_type, error_str);
        Q_EMIT myConversationsIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myConversationsIdPutSignalError(error_type, error_str);
        Q_EMIT myConversationsIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myConversationsPost(const ::OpenAPI::OptionalParam<OAI_my_conversations_post_request> &oai_my_conversations_post_request) {
    QString fullPath = QString(_serverConfigs["myConversationsPost"][_serverIndices.value("myConversationsPost")].URL()+"/my/conversations");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_my_conversations_post_request.hasValue()){

        
        QByteArray output = oai_my_conversations_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_messages");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myConversationsPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myConversationsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myConversationsPostSignal();
        Q_EMIT myConversationsPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_messages");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myConversationsPostSignalE(error_type, error_str);
        Q_EMIT myConversationsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myConversationsPostSignalError(error_type, error_str);
        Q_EMIT myConversationsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myCountsGet() {
    QString fullPath = QString(_serverConfigs["myCountsGet"][_serverIndices.value("myCountsGet")].URL()+"/my/counts");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myCountsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_profile");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myCountsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myCountsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myCountsGetSignal();
        Q_EMIT myCountsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_profile");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myCountsGetSignalE(error_type, error_str);
        Q_EMIT myCountsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myCountsGetSignalError(error_type, error_str);
        Q_EMIT myCountsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myCuratedSetProductProductIdDelete(const QString &product_id) {
    QString fullPath = QString(_serverConfigs["myCuratedSetProductProductIdDelete"][_serverIndices.value("myCuratedSetProductProductIdDelete")].URL()+"/my/curated_set/product/{product_id}");
    
    
    {
        QString product_idPathParam("{");
        product_idPathParam.append("product_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "product_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"product_id"+pathSuffix : pathPrefix;
        fullPath.replace(product_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(product_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myCuratedSetProductProductIdDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIMyApi::myCuratedSetProductProductIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myCuratedSetProductProductIdDeleteSignal();
        Q_EMIT myCuratedSetProductProductIdDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myCuratedSetProductProductIdDeleteSignalE(error_type, error_str);
        Q_EMIT myCuratedSetProductProductIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myCuratedSetProductProductIdDeleteSignalError(error_type, error_str);
        Q_EMIT myCuratedSetProductProductIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myCuratedSetProductProductIdPost(const QString &product_id) {
    QString fullPath = QString(_serverConfigs["myCuratedSetProductProductIdPost"][_serverIndices.value("myCuratedSetProductProductIdPost")].URL()+"/my/curated_set/product/{product_id}");
    
    
    {
        QString product_idPathParam("{");
        product_idPathParam.append("product_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "product_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"product_id"+pathSuffix : pathPrefix;
        fullPath.replace(product_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(product_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myCuratedSetProductProductIdPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIMyApi::myCuratedSetProductProductIdPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myCuratedSetProductProductIdPostSignal();
        Q_EMIT myCuratedSetProductProductIdPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myCuratedSetProductProductIdPostSignalE(error_type, error_str);
        Q_EMIT myCuratedSetProductProductIdPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myCuratedSetProductProductIdPostSignalError(error_type, error_str);
        Q_EMIT myCuratedSetProductProductIdPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFeedCustomizeGet() {
    QString fullPath = QString(_serverConfigs["myFeedCustomizeGet"][_serverIndices.value("myFeedCustomizeGet")].URL()+"/my/feed/customize");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedCustomizeGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedCustomizeGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFeedCustomizeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFeedCustomizeGetSignal();
        Q_EMIT myFeedCustomizeGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFeedCustomizeGetSignalE(error_type, error_str);
        Q_EMIT myFeedCustomizeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFeedCustomizeGetSignalError(error_type, error_str);
        Q_EMIT myFeedCustomizeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFeedGet() {
    QString fullPath = QString(_serverConfigs["myFeedGet"][_serverIndices.value("myFeedGet")].URL()+"/my/feed");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFeedGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFeedGetSignal();
        Q_EMIT myFeedGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFeedGetSignalE(error_type, error_str);
        Q_EMIT myFeedGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFeedGetSignalError(error_type, error_str);
        Q_EMIT myFeedGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFeedGridGet() {
    QString fullPath = QString(_serverConfigs["myFeedGridGet"][_serverIndices.value("myFeedGridGet")].URL()+"/my/feed/grid");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedGridGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedGridGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFeedGridGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFeedGridGetSignal();
        Q_EMIT myFeedGridGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFeedGridGetSignalE(error_type, error_str);
        Q_EMIT myFeedGridGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFeedGridGetSignalError(error_type, error_str);
        Q_EMIT myFeedGridGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFeedbackReceivedGet() {
    QString fullPath = QString(_serverConfigs["myFeedbackReceivedGet"][_serverIndices.value("myFeedbackReceivedGet")].URL()+"/my/feedback/received");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedbackReceivedGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_feedback");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedbackReceivedGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFeedbackReceivedGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFeedbackReceivedGetSignal();
        Q_EMIT myFeedbackReceivedGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_feedback");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFeedbackReceivedGetSignalE(error_type, error_str);
        Q_EMIT myFeedbackReceivedGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFeedbackReceivedGetSignalError(error_type, error_str);
        Q_EMIT myFeedbackReceivedGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFeedbackSentGet() {
    QString fullPath = QString(_serverConfigs["myFeedbackSentGet"][_serverIndices.value("myFeedbackSentGet")].URL()+"/my/feedback/sent");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedbackSentGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_feedback");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFeedbackSentGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFeedbackSentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFeedbackSentGetSignal();
        Q_EMIT myFeedbackSentGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_feedback");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFeedbackSentGetSignalE(error_type, error_str);
        Q_EMIT myFeedbackSentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFeedbackSentGetSignalError(error_type, error_str);
        Q_EMIT myFeedbackSentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsArticlesGet() {
    QString fullPath = QString(_serverConfigs["myFollowsArticlesGet"][_serverIndices.value("myFollowsArticlesGet")].URL()+"/my/follows/articles");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsArticlesGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsArticlesGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsArticlesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsArticlesGetSignal();
        Q_EMIT myFollowsArticlesGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsArticlesGetSignalE(error_type, error_str);
        Q_EMIT myFollowsArticlesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsArticlesGetSignalError(error_type, error_str);
        Q_EMIT myFollowsArticlesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsArticlesPost(const ::OpenAPI::OptionalParam<OAI_my_follows_articles_post_request> &oai_my_follows_articles_post_request) {
    QString fullPath = QString(_serverConfigs["myFollowsArticlesPost"][_serverIndices.value("myFollowsArticlesPost")].URL()+"/my/follows/articles");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_my_follows_articles_post_request.hasValue()){

        
        QByteArray output = oai_my_follows_articles_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsArticlesPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsArticlesPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsArticlesPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsArticlesPostSignal();
        Q_EMIT myFollowsArticlesPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsArticlesPostSignalE(error_type, error_str);
        Q_EMIT myFollowsArticlesPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsArticlesPostSignalError(error_type, error_str);
        Q_EMIT myFollowsArticlesPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsBrandsSlugDelete(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsBrandsSlugDelete"][_serverIndices.value("myFollowsBrandsSlugDelete")].URL()+"/my/follows/brands/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsBrandsSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsBrandsSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsBrandsSlugDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsBrandsSlugDeleteSignal();
        Q_EMIT myFollowsBrandsSlugDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsBrandsSlugDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsBrandsSlugDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsBrandsSlugDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsBrandsSlugDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsBrandsSlugGet(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsBrandsSlugGet"][_serverIndices.value("myFollowsBrandsSlugGet")].URL()+"/my/follows/brands/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsBrandsSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsBrandsSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsBrandsSlugGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsBrandsSlugGetSignal();
        Q_EMIT myFollowsBrandsSlugGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsBrandsSlugGetSignalE(error_type, error_str);
        Q_EMIT myFollowsBrandsSlugGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsBrandsSlugGetSignalError(error_type, error_str);
        Q_EMIT myFollowsBrandsSlugGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsBrandsSlugPost(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsBrandsSlugPost"][_serverIndices.value("myFollowsBrandsSlugPost")].URL()+"/my/follows/brands/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsBrandsSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsBrandsSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsBrandsSlugPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsBrandsSlugPostSignal();
        Q_EMIT myFollowsBrandsSlugPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsBrandsSlugPostSignalE(error_type, error_str);
        Q_EMIT myFollowsBrandsSlugPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsBrandsSlugPostSignalError(error_type, error_str);
        Q_EMIT myFollowsBrandsSlugPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCategoriesCategorySubcategoryDelete(const QString &category, const QString &subcategory) {
    QString fullPath = QString(_serverConfigs["myFollowsCategoriesCategorySubcategoryDelete"][_serverIndices.value("myFollowsCategoriesCategorySubcategoryDelete")].URL()+"/my/follows/categories/{category}/{subcategory}");
    
    
    {
        QString categoryPathParam("{");
        categoryPathParam.append("category").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "category", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"category"+pathSuffix : pathPrefix;
        fullPath.replace(categoryPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(category)));
    }
    
    {
        QString subcategoryPathParam("{");
        subcategoryPathParam.append("subcategory").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "subcategory", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"subcategory"+pathSuffix : pathPrefix;
        fullPath.replace(subcategoryPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(subcategory)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesCategorySubcategoryDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesCategorySubcategoryDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCategoriesCategorySubcategoryDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCategoriesCategorySubcategoryDeleteSignal();
        Q_EMIT myFollowsCategoriesCategorySubcategoryDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCategoriesCategorySubcategoryDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsCategoriesCategorySubcategoryDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCategoriesCategorySubcategoryDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsCategoriesCategorySubcategoryDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCategoriesCategorySubcategoryGet(const QString &category, const QString &subcategory) {
    QString fullPath = QString(_serverConfigs["myFollowsCategoriesCategorySubcategoryGet"][_serverIndices.value("myFollowsCategoriesCategorySubcategoryGet")].URL()+"/my/follows/categories/{category}/{subcategory}");
    
    
    {
        QString categoryPathParam("{");
        categoryPathParam.append("category").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "category", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"category"+pathSuffix : pathPrefix;
        fullPath.replace(categoryPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(category)));
    }
    
    {
        QString subcategoryPathParam("{");
        subcategoryPathParam.append("subcategory").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "subcategory", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"subcategory"+pathSuffix : pathPrefix;
        fullPath.replace(subcategoryPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(subcategory)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesCategorySubcategoryGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesCategorySubcategoryGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCategoriesCategorySubcategoryGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCategoriesCategorySubcategoryGetSignal();
        Q_EMIT myFollowsCategoriesCategorySubcategoryGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCategoriesCategorySubcategoryGetSignalE(error_type, error_str);
        Q_EMIT myFollowsCategoriesCategorySubcategoryGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCategoriesCategorySubcategoryGetSignalError(error_type, error_str);
        Q_EMIT myFollowsCategoriesCategorySubcategoryGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCategoriesCategorySubcategoryPost(const QString &category, const QString &subcategory) {
    QString fullPath = QString(_serverConfigs["myFollowsCategoriesCategorySubcategoryPost"][_serverIndices.value("myFollowsCategoriesCategorySubcategoryPost")].URL()+"/my/follows/categories/{category}/{subcategory}");
    
    
    {
        QString categoryPathParam("{");
        categoryPathParam.append("category").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "category", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"category"+pathSuffix : pathPrefix;
        fullPath.replace(categoryPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(category)));
    }
    
    {
        QString subcategoryPathParam("{");
        subcategoryPathParam.append("subcategory").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "subcategory", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"subcategory"+pathSuffix : pathPrefix;
        fullPath.replace(subcategoryPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(subcategory)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesCategorySubcategoryPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesCategorySubcategoryPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCategoriesCategorySubcategoryPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCategoriesCategorySubcategoryPostSignal();
        Q_EMIT myFollowsCategoriesCategorySubcategoryPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCategoriesCategorySubcategoryPostSignalE(error_type, error_str);
        Q_EMIT myFollowsCategoriesCategorySubcategoryPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCategoriesCategorySubcategoryPostSignalError(error_type, error_str);
        Q_EMIT myFollowsCategoriesCategorySubcategoryPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCategoriesIdentifierDelete(const QString &identifier) {
    QString fullPath = QString(_serverConfigs["myFollowsCategoriesIdentifierDelete"][_serverIndices.value("myFollowsCategoriesIdentifierDelete")].URL()+"/my/follows/categories/{identifier}");
    
    
    {
        QString identifierPathParam("{");
        identifierPathParam.append("identifier").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "identifier", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"identifier"+pathSuffix : pathPrefix;
        fullPath.replace(identifierPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(identifier)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesIdentifierDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesIdentifierDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCategoriesIdentifierDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCategoriesIdentifierDeleteSignal();
        Q_EMIT myFollowsCategoriesIdentifierDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCategoriesIdentifierDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsCategoriesIdentifierDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCategoriesIdentifierDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsCategoriesIdentifierDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCategoriesIdentifierGet(const QString &identifier) {
    QString fullPath = QString(_serverConfigs["myFollowsCategoriesIdentifierGet"][_serverIndices.value("myFollowsCategoriesIdentifierGet")].URL()+"/my/follows/categories/{identifier}");
    
    
    {
        QString identifierPathParam("{");
        identifierPathParam.append("identifier").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "identifier", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"identifier"+pathSuffix : pathPrefix;
        fullPath.replace(identifierPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(identifier)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesIdentifierGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesIdentifierGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCategoriesIdentifierGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCategoriesIdentifierGetSignal();
        Q_EMIT myFollowsCategoriesIdentifierGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCategoriesIdentifierGetSignalE(error_type, error_str);
        Q_EMIT myFollowsCategoriesIdentifierGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCategoriesIdentifierGetSignalError(error_type, error_str);
        Q_EMIT myFollowsCategoriesIdentifierGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCategoriesIdentifierPost(const QString &identifier) {
    QString fullPath = QString(_serverConfigs["myFollowsCategoriesIdentifierPost"][_serverIndices.value("myFollowsCategoriesIdentifierPost")].URL()+"/my/follows/categories/{identifier}");
    
    
    {
        QString identifierPathParam("{");
        identifierPathParam.append("identifier").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "identifier", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"identifier"+pathSuffix : pathPrefix;
        fullPath.replace(identifierPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(identifier)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesIdentifierPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesIdentifierPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCategoriesIdentifierPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCategoriesIdentifierPostSignal();
        Q_EMIT myFollowsCategoriesIdentifierPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCategoriesIdentifierPostSignalE(error_type, error_str);
        Q_EMIT myFollowsCategoriesIdentifierPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCategoriesIdentifierPostSignalError(error_type, error_str);
        Q_EMIT myFollowsCategoriesIdentifierPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCategoriesUuidPost(const QString &uuid) {
    QString fullPath = QString(_serverConfigs["myFollowsCategoriesUuidPost"][_serverIndices.value("myFollowsCategoriesUuidPost")].URL()+"/my/follows/categories/{uuid}");
    
    
    {
        QString uuidPathParam("{");
        uuidPathParam.append("uuid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "uuid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"uuid"+pathSuffix : pathPrefix;
        fullPath.replace(uuidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(uuid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesUuidPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCategoriesUuidPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCategoriesUuidPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCategoriesUuidPostSignal();
        Q_EMIT myFollowsCategoriesUuidPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCategoriesUuidPostSignalE(error_type, error_str);
        Q_EMIT myFollowsCategoriesUuidPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCategoriesUuidPostSignalError(error_type, error_str);
        Q_EMIT myFollowsCategoriesUuidPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCollectionsSlugDelete(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsCollectionsSlugDelete"][_serverIndices.value("myFollowsCollectionsSlugDelete")].URL()+"/my/follows/collections/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCollectionsSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCollectionsSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCollectionsSlugDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCollectionsSlugDeleteSignal();
        Q_EMIT myFollowsCollectionsSlugDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCollectionsSlugDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsCollectionsSlugDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCollectionsSlugDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsCollectionsSlugDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCollectionsSlugGet(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsCollectionsSlugGet"][_serverIndices.value("myFollowsCollectionsSlugGet")].URL()+"/my/follows/collections/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCollectionsSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCollectionsSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCollectionsSlugGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCollectionsSlugGetSignal();
        Q_EMIT myFollowsCollectionsSlugGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCollectionsSlugGetSignalE(error_type, error_str);
        Q_EMIT myFollowsCollectionsSlugGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCollectionsSlugGetSignalError(error_type, error_str);
        Q_EMIT myFollowsCollectionsSlugGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsCollectionsSlugPost(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsCollectionsSlugPost"][_serverIndices.value("myFollowsCollectionsSlugPost")].URL()+"/my/follows/collections/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCollectionsSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsCollectionsSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsCollectionsSlugPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsCollectionsSlugPostSignal();
        Q_EMIT myFollowsCollectionsSlugPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsCollectionsSlugPostSignalE(error_type, error_str);
        Q_EMIT myFollowsCollectionsSlugPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsCollectionsSlugPostSignalError(error_type, error_str);
        Q_EMIT myFollowsCollectionsSlugPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsFollowIdAlertDelete(const QString &follow_id) {
    QString fullPath = QString(_serverConfigs["myFollowsFollowIdAlertDelete"][_serverIndices.value("myFollowsFollowIdAlertDelete")].URL()+"/my/follows/{follow_id}/alert");
    
    
    {
        QString follow_idPathParam("{");
        follow_idPathParam.append("follow_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "follow_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"follow_id"+pathSuffix : pathPrefix;
        fullPath.replace(follow_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(follow_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsFollowIdAlertDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIMyApi::myFollowsFollowIdAlertDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsFollowIdAlertDeleteSignal();
        Q_EMIT myFollowsFollowIdAlertDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsFollowIdAlertDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsFollowIdAlertDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsFollowIdAlertDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsFollowIdAlertDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsFollowIdAlertPost(const QString &follow_id) {
    QString fullPath = QString(_serverConfigs["myFollowsFollowIdAlertPost"][_serverIndices.value("myFollowsFollowIdAlertPost")].URL()+"/my/follows/{follow_id}/alert");
    
    
    {
        QString follow_idPathParam("{");
        follow_idPathParam.append("follow_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "follow_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"follow_id"+pathSuffix : pathPrefix;
        fullPath.replace(follow_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(follow_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsFollowIdAlertPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIMyApi::myFollowsFollowIdAlertPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsFollowIdAlertPostSignal();
        Q_EMIT myFollowsFollowIdAlertPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsFollowIdAlertPostSignalE(error_type, error_str);
        Q_EMIT myFollowsFollowIdAlertPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsFollowIdAlertPostSignalError(error_type, error_str);
        Q_EMIT myFollowsFollowIdAlertPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsFollowIdDelete(const QString &follow_id) {
    QString fullPath = QString(_serverConfigs["myFollowsFollowIdDelete"][_serverIndices.value("myFollowsFollowIdDelete")].URL()+"/my/follows/{follow_id}");
    
    
    {
        QString follow_idPathParam("{");
        follow_idPathParam.append("follow_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "follow_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"follow_id"+pathSuffix : pathPrefix;
        fullPath.replace(follow_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(follow_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsFollowIdDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsFollowIdDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsFollowIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsFollowIdDeleteSignal();
        Q_EMIT myFollowsFollowIdDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsFollowIdDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsFollowIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsFollowIdDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsFollowIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsGet() {
    QString fullPath = QString(_serverConfigs["myFollowsGet"][_serverIndices.value("myFollowsGet")].URL()+"/my/follows");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsGetSignal();
        Q_EMIT myFollowsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsGetSignalE(error_type, error_str);
        Q_EMIT myFollowsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsGetSignalError(error_type, error_str);
        Q_EMIT myFollowsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsHandpickedSlugDelete(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsHandpickedSlugDelete"][_serverIndices.value("myFollowsHandpickedSlugDelete")].URL()+"/my/follows/handpicked/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsHandpickedSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsHandpickedSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsHandpickedSlugDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsHandpickedSlugDeleteSignal();
        Q_EMIT myFollowsHandpickedSlugDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsHandpickedSlugDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsHandpickedSlugDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsHandpickedSlugDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsHandpickedSlugDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsHandpickedSlugGet(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsHandpickedSlugGet"][_serverIndices.value("myFollowsHandpickedSlugGet")].URL()+"/my/follows/handpicked/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsHandpickedSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsHandpickedSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsHandpickedSlugGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsHandpickedSlugGetSignal();
        Q_EMIT myFollowsHandpickedSlugGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsHandpickedSlugGetSignalE(error_type, error_str);
        Q_EMIT myFollowsHandpickedSlugGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsHandpickedSlugGetSignalError(error_type, error_str);
        Q_EMIT myFollowsHandpickedSlugGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsHandpickedSlugPost(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsHandpickedSlugPost"][_serverIndices.value("myFollowsHandpickedSlugPost")].URL()+"/my/follows/handpicked/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsHandpickedSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsHandpickedSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsHandpickedSlugPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsHandpickedSlugPostSignal();
        Q_EMIT myFollowsHandpickedSlugPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsHandpickedSlugPostSignalE(error_type, error_str);
        Q_EMIT myFollowsHandpickedSlugPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsHandpickedSlugPostSignalError(error_type, error_str);
        Q_EMIT myFollowsHandpickedSlugPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsSearchGet() {
    QString fullPath = QString(_serverConfigs["myFollowsSearchGet"][_serverIndices.value("myFollowsSearchGet")].URL()+"/my/follows/search");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsSearchGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsSearchGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsSearchGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsSearchGetSignal();
        Q_EMIT myFollowsSearchGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsSearchGetSignalE(error_type, error_str);
        Q_EMIT myFollowsSearchGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsSearchGetSignalError(error_type, error_str);
        Q_EMIT myFollowsSearchGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsSearchPost(const ::OpenAPI::OptionalParam<OAI_my_follows_search_post_request> &oai_my_follows_search_post_request) {
    QString fullPath = QString(_serverConfigs["myFollowsSearchPost"][_serverIndices.value("myFollowsSearchPost")].URL()+"/my/follows/search");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_my_follows_search_post_request.hasValue()){

        
        QByteArray output = oai_my_follows_search_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsSearchPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsSearchPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsSearchPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsSearchPostSignal();
        Q_EMIT myFollowsSearchPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsSearchPostSignalE(error_type, error_str);
        Q_EMIT myFollowsSearchPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsSearchPostSignalError(error_type, error_str);
        Q_EMIT myFollowsSearchPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsShopsSlugDelete(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsShopsSlugDelete"][_serverIndices.value("myFollowsShopsSlugDelete")].URL()+"/my/follows/shops/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsShopsSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsShopsSlugDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsShopsSlugDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsShopsSlugDeleteSignal();
        Q_EMIT myFollowsShopsSlugDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsShopsSlugDeleteSignalE(error_type, error_str);
        Q_EMIT myFollowsShopsSlugDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsShopsSlugDeleteSignalError(error_type, error_str);
        Q_EMIT myFollowsShopsSlugDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsShopsSlugGet(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsShopsSlugGet"][_serverIndices.value("myFollowsShopsSlugGet")].URL()+"/my/follows/shops/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsShopsSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsShopsSlugGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsShopsSlugGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsShopsSlugGetSignal();
        Q_EMIT myFollowsShopsSlugGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsShopsSlugGetSignalE(error_type, error_str);
        Q_EMIT myFollowsShopsSlugGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsShopsSlugGetSignalError(error_type, error_str);
        Q_EMIT myFollowsShopsSlugGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myFollowsShopsSlugPost(const QString &slug) {
    QString fullPath = QString(_serverConfigs["myFollowsShopsSlugPost"][_serverIndices.value("myFollowsShopsSlugPost")].URL()+"/my/follows/shops/{slug}");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsShopsSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myFollowsShopsSlugPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myFollowsShopsSlugPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myFollowsShopsSlugPostSignal();
        Q_EMIT myFollowsShopsSlugPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myFollowsShopsSlugPostSignalE(error_type, error_str);
        Q_EMIT myFollowsShopsSlugPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myFollowsShopsSlugPostSignalError(error_type, error_str);
        Q_EMIT myFollowsShopsSlugPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myListingsDraftsGet(const ::OpenAPI::OptionalParam<QString> &query, const ::OpenAPI::OptionalParam<float> &auction_price_max, const ::OpenAPI::OptionalParam<QString> &category, const ::OpenAPI::OptionalParam<QString> &product_type, const ::OpenAPI::OptionalParam<QList<QString>> &conditions, const ::OpenAPI::OptionalParam<QString> &decade, const ::OpenAPI::OptionalParam<QString> &finish, const ::OpenAPI::OptionalParam<bool> &handmade, const ::OpenAPI::OptionalParam<QString> &item_city, const ::OpenAPI::OptionalParam<QString> &item_country, const ::OpenAPI::OptionalParam<QString> &item_region, const ::OpenAPI::OptionalParam<QString> &item_state, const ::OpenAPI::OptionalParam<QList<QString>> &make, const ::OpenAPI::OptionalParam<QString> &model, const ::OpenAPI::OptionalParam<QString> &must_not, const ::OpenAPI::OptionalParam<float> &price_max, const ::OpenAPI::OptionalParam<float> &price_min, const ::OpenAPI::OptionalParam<QString> &currency, const ::OpenAPI::OptionalParam<qint32> &year_max, const ::OpenAPI::OptionalParam<qint32> &year_min, const ::OpenAPI::OptionalParam<bool> &accepts_gift_cards, const ::OpenAPI::OptionalParam<bool> &preferred_seller, const ::OpenAPI::OptionalParam<QString> &shop, const ::OpenAPI::OptionalParam<QString> &shop_id, const ::OpenAPI::OptionalParam<QString> &listing_type, const ::OpenAPI::OptionalParam<QString> &ships_to, const ::OpenAPI::OptionalParam<bool> &exclude_auctions, const ::OpenAPI::OptionalParam<bool> &accepts_payment_plans, const ::OpenAPI::OptionalParam<qint32> &watchers_count_min, const ::OpenAPI::OptionalParam<QList<QString>> &not_ids, const ::OpenAPI::OptionalParam<bool> &local_pickup) {
    QString fullPath = QString(_serverConfigs["myListingsDraftsGet"][_serverIndices.value("myListingsDraftsGet")].URL()+"/my/listings/drafts");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (query.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "query", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("query")).append(querySuffix).append(QUrl::toPercentEncoding(query.stringValue()));
    }
    if (auction_price_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "auction_price_max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("auction_price_max")).append(querySuffix).append(QUrl::toPercentEncoding(auction_price_max.stringValue()));
    }
    if (category.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "category", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("category")).append(querySuffix).append(QUrl::toPercentEncoding(category.stringValue()));
    }
    if (product_type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "product_type", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("product_type")).append(querySuffix).append(QUrl::toPercentEncoding(product_type.stringValue()));
    }
    if (conditions.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "conditions", false);
        if (conditions.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (QString t : conditions.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("conditions=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (decade.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "decade", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("decade")).append(querySuffix).append(QUrl::toPercentEncoding(decade.stringValue()));
    }
    if (finish.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "finish", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("finish")).append(querySuffix).append(QUrl::toPercentEncoding(finish.stringValue()));
    }
    if (handmade.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "handmade", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("handmade")).append(querySuffix).append(QUrl::toPercentEncoding(handmade.stringValue()));
    }
    if (item_city.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_city", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_city")).append(querySuffix).append(QUrl::toPercentEncoding(item_city.stringValue()));
    }
    if (item_country.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_country", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_country")).append(querySuffix).append(QUrl::toPercentEncoding(item_country.stringValue()));
    }
    if (item_region.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_region", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_region")).append(querySuffix).append(QUrl::toPercentEncoding(item_region.stringValue()));
    }
    if (item_state.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_state", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_state")).append(querySuffix).append(QUrl::toPercentEncoding(item_state.stringValue()));
    }
    if (make.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "make", false);
        if (make.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (QString t : make.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("make=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (model.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "model", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("model")).append(querySuffix).append(QUrl::toPercentEncoding(model.stringValue()));
    }
    if (must_not.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "must_not", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("must_not")).append(querySuffix).append(QUrl::toPercentEncoding(must_not.stringValue()));
    }
    if (price_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "price_max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("price_max")).append(querySuffix).append(QUrl::toPercentEncoding(price_max.stringValue()));
    }
    if (price_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "price_min", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("price_min")).append(querySuffix).append(QUrl::toPercentEncoding(price_min.stringValue()));
    }
    if (currency.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "currency", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("currency")).append(querySuffix).append(QUrl::toPercentEncoding(currency.stringValue()));
    }
    if (year_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "year_max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("year_max")).append(querySuffix).append(QUrl::toPercentEncoding(year_max.stringValue()));
    }
    if (year_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "year_min", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("year_min")).append(querySuffix).append(QUrl::toPercentEncoding(year_min.stringValue()));
    }
    if (accepts_gift_cards.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "accepts_gift_cards", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("accepts_gift_cards")).append(querySuffix).append(QUrl::toPercentEncoding(accepts_gift_cards.stringValue()));
    }
    if (preferred_seller.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "preferred_seller", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("preferred_seller")).append(querySuffix).append(QUrl::toPercentEncoding(preferred_seller.stringValue()));
    }
    if (shop.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "shop", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("shop")).append(querySuffix).append(QUrl::toPercentEncoding(shop.stringValue()));
    }
    if (shop_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "shop_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("shop_id")).append(querySuffix).append(QUrl::toPercentEncoding(shop_id.stringValue()));
    }
    if (listing_type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "listing_type", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("listing_type")).append(querySuffix).append(QUrl::toPercentEncoding(listing_type.stringValue()));
    }
    if (ships_to.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "ships_to", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("ships_to")).append(querySuffix).append(QUrl::toPercentEncoding(ships_to.stringValue()));
    }
    if (exclude_auctions.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "exclude_auctions", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("exclude_auctions")).append(querySuffix).append(QUrl::toPercentEncoding(exclude_auctions.stringValue()));
    }
    if (accepts_payment_plans.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "accepts_payment_plans", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("accepts_payment_plans")).append(querySuffix).append(QUrl::toPercentEncoding(accepts_payment_plans.stringValue()));
    }
    if (watchers_count_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "watchers_count_min", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("watchers_count_min")).append(querySuffix).append(QUrl::toPercentEncoding(watchers_count_min.stringValue()));
    }
    if (not_ids.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "not_ids", false);
        if (not_ids.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (QString t : not_ids.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("not_ids=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (local_pickup.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "local_pickup", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("local_pickup")).append(querySuffix).append(QUrl::toPercentEncoding(local_pickup.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsDraftsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_listings");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsDraftsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myListingsDraftsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myListingsDraftsGetSignal();
        Q_EMIT myListingsDraftsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_listings");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myListingsDraftsGetSignalE(error_type, error_str);
        Q_EMIT myListingsDraftsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myListingsDraftsGetSignalError(error_type, error_str);
        Q_EMIT myListingsDraftsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myListingsGet(const ::OpenAPI::OptionalParam<QString> &query, const ::OpenAPI::OptionalParam<float> &auction_price_max, const ::OpenAPI::OptionalParam<QString> &category, const ::OpenAPI::OptionalParam<QString> &product_type, const ::OpenAPI::OptionalParam<QList<QString>> &conditions, const ::OpenAPI::OptionalParam<QString> &decade, const ::OpenAPI::OptionalParam<QString> &finish, const ::OpenAPI::OptionalParam<bool> &handmade, const ::OpenAPI::OptionalParam<QString> &item_city, const ::OpenAPI::OptionalParam<QString> &item_country, const ::OpenAPI::OptionalParam<QString> &item_region, const ::OpenAPI::OptionalParam<QString> &item_state, const ::OpenAPI::OptionalParam<QList<QString>> &make, const ::OpenAPI::OptionalParam<QString> &model, const ::OpenAPI::OptionalParam<QString> &must_not, const ::OpenAPI::OptionalParam<float> &price_max, const ::OpenAPI::OptionalParam<float> &price_min, const ::OpenAPI::OptionalParam<QString> &currency, const ::OpenAPI::OptionalParam<qint32> &year_max, const ::OpenAPI::OptionalParam<qint32> &year_min, const ::OpenAPI::OptionalParam<bool> &accepts_gift_cards, const ::OpenAPI::OptionalParam<bool> &preferred_seller, const ::OpenAPI::OptionalParam<QString> &shop, const ::OpenAPI::OptionalParam<QString> &shop_id, const ::OpenAPI::OptionalParam<QString> &listing_type, const ::OpenAPI::OptionalParam<QString> &ships_to, const ::OpenAPI::OptionalParam<bool> &exclude_auctions, const ::OpenAPI::OptionalParam<bool> &accepts_payment_plans, const ::OpenAPI::OptionalParam<qint32> &watchers_count_min, const ::OpenAPI::OptionalParam<QList<QString>> &not_ids, const ::OpenAPI::OptionalParam<bool> &local_pickup, const ::OpenAPI::OptionalParam<QString> &state, const ::OpenAPI::OptionalParam<QString> &sku) {
    QString fullPath = QString(_serverConfigs["myListingsGet"][_serverIndices.value("myListingsGet")].URL()+"/my/listings");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (query.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "query", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("query")).append(querySuffix).append(QUrl::toPercentEncoding(query.stringValue()));
    }
    if (auction_price_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "auction_price_max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("auction_price_max")).append(querySuffix).append(QUrl::toPercentEncoding(auction_price_max.stringValue()));
    }
    if (category.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "category", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("category")).append(querySuffix).append(QUrl::toPercentEncoding(category.stringValue()));
    }
    if (product_type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "product_type", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("product_type")).append(querySuffix).append(QUrl::toPercentEncoding(product_type.stringValue()));
    }
    if (conditions.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "conditions", false);
        if (conditions.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (QString t : conditions.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("conditions=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("conditions").append(querySuffix);
                qint32 count = 0;
                for (QString t : conditions.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (decade.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "decade", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("decade")).append(querySuffix).append(QUrl::toPercentEncoding(decade.stringValue()));
    }
    if (finish.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "finish", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("finish")).append(querySuffix).append(QUrl::toPercentEncoding(finish.stringValue()));
    }
    if (handmade.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "handmade", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("handmade")).append(querySuffix).append(QUrl::toPercentEncoding(handmade.stringValue()));
    }
    if (item_city.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_city", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_city")).append(querySuffix).append(QUrl::toPercentEncoding(item_city.stringValue()));
    }
    if (item_country.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_country", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_country")).append(querySuffix).append(QUrl::toPercentEncoding(item_country.stringValue()));
    }
    if (item_region.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_region", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_region")).append(querySuffix).append(QUrl::toPercentEncoding(item_region.stringValue()));
    }
    if (item_state.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "item_state", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("item_state")).append(querySuffix).append(QUrl::toPercentEncoding(item_state.stringValue()));
    }
    if (make.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "make", false);
        if (make.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (QString t : make.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("make=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("make").append(querySuffix);
                qint32 count = 0;
                for (QString t : make.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (model.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "model", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("model")).append(querySuffix).append(QUrl::toPercentEncoding(model.stringValue()));
    }
    if (must_not.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "must_not", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("must_not")).append(querySuffix).append(QUrl::toPercentEncoding(must_not.stringValue()));
    }
    if (price_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "price_max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("price_max")).append(querySuffix).append(QUrl::toPercentEncoding(price_max.stringValue()));
    }
    if (price_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "price_min", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("price_min")).append(querySuffix).append(QUrl::toPercentEncoding(price_min.stringValue()));
    }
    if (currency.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "currency", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("currency")).append(querySuffix).append(QUrl::toPercentEncoding(currency.stringValue()));
    }
    if (year_max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "year_max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("year_max")).append(querySuffix).append(QUrl::toPercentEncoding(year_max.stringValue()));
    }
    if (year_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "year_min", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("year_min")).append(querySuffix).append(QUrl::toPercentEncoding(year_min.stringValue()));
    }
    if (accepts_gift_cards.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "accepts_gift_cards", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("accepts_gift_cards")).append(querySuffix).append(QUrl::toPercentEncoding(accepts_gift_cards.stringValue()));
    }
    if (preferred_seller.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "preferred_seller", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("preferred_seller")).append(querySuffix).append(QUrl::toPercentEncoding(preferred_seller.stringValue()));
    }
    if (shop.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "shop", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("shop")).append(querySuffix).append(QUrl::toPercentEncoding(shop.stringValue()));
    }
    if (shop_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "shop_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("shop_id")).append(querySuffix).append(QUrl::toPercentEncoding(shop_id.stringValue()));
    }
    if (listing_type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "listing_type", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("listing_type")).append(querySuffix).append(QUrl::toPercentEncoding(listing_type.stringValue()));
    }
    if (ships_to.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "ships_to", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("ships_to")).append(querySuffix).append(QUrl::toPercentEncoding(ships_to.stringValue()));
    }
    if (exclude_auctions.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "exclude_auctions", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("exclude_auctions")).append(querySuffix).append(QUrl::toPercentEncoding(exclude_auctions.stringValue()));
    }
    if (accepts_payment_plans.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "accepts_payment_plans", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("accepts_payment_plans")).append(querySuffix).append(QUrl::toPercentEncoding(accepts_payment_plans.stringValue()));
    }
    if (watchers_count_min.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "watchers_count_min", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("watchers_count_min")).append(querySuffix).append(QUrl::toPercentEncoding(watchers_count_min.stringValue()));
    }
    if (not_ids.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "not_ids", false);
        if (not_ids.value().size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (QString t : not_ids.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("not_ids=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("not_ids").append(querySuffix);
                qint32 count = 0;
                for (QString t : not_ids.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (local_pickup.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "local_pickup", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("local_pickup")).append(querySuffix).append(QUrl::toPercentEncoding(local_pickup.stringValue()));
    }
    if (state.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "state", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("state")).append(querySuffix).append(QUrl::toPercentEncoding(state.stringValue()));
    }
    if (sku.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "sku", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("sku")).append(querySuffix).append(QUrl::toPercentEncoding(sku.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_listings");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myListingsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myListingsGetSignal();
        Q_EMIT myListingsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_listings");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myListingsGetSignalE(error_type, error_str);
        Q_EMIT myListingsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myListingsGetSignalError(error_type, error_str);
        Q_EMIT myListingsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myListingsNegotiationsGet(const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &per_page, const ::OpenAPI::OptionalParam<qint32> &offset) {
    QString fullPath = QString(_serverConfigs["myListingsNegotiationsGet"][_serverIndices.value("myListingsNegotiationsGet")].URL()+"/my/listings/negotiations");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsNegotiationsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_offers");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsNegotiationsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myListingsNegotiationsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myListingsNegotiationsGetSignal();
        Q_EMIT myListingsNegotiationsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_offers");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myListingsNegotiationsGetSignalE(error_type, error_str);
        Q_EMIT myListingsNegotiationsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myListingsNegotiationsGetSignalError(error_type, error_str);
        Q_EMIT myListingsNegotiationsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myListingsSlugStateEndPut(const QString &slug, const ::OpenAPI::OptionalParam<OAI_my_listings__slug__state_end_put_request> &oai_my_listings__slug__state_end_put_request) {
    QString fullPath = QString(_serverConfigs["myListingsSlugStateEndPut"][_serverIndices.value("myListingsSlugStateEndPut")].URL()+"/my/listings/{slug}/state/end");
    
    
    {
        QString slugPathParam("{");
        slugPathParam.append("slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"slug"+pathSuffix : pathPrefix;
        fullPath.replace(slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(slug)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (oai_my_listings__slug__state_end_put_request.hasValue()){

        
        QByteArray output = oai_my_listings__slug__state_end_put_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsSlugStateEndPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_listings");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListingsSlugStateEndPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myListingsSlugStateEndPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myListingsSlugStateEndPutSignal();
        Q_EMIT myListingsSlugStateEndPutSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_listings");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myListingsSlugStateEndPutSignalE(error_type, error_str);
        Q_EMIT myListingsSlugStateEndPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myListingsSlugStateEndPutSignalError(error_type, error_str);
        Q_EMIT myListingsSlugStateEndPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myListsGet() {
    QString fullPath = QString(_serverConfigs["myListsGet"][_serverIndices.value("myListsGet")].URL()+"/my/lists");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myListsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myListsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myListsGetSignal();
        Q_EMIT myListsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myListsGetSignalE(error_type, error_str);
        Q_EMIT myListsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myListsGetSignalError(error_type, error_str);
        Q_EMIT myListsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myNegotiationsBuyingGet(const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &per_page, const ::OpenAPI::OptionalParam<qint32> &offset) {
    QString fullPath = QString(_serverConfigs["myNegotiationsBuyingGet"][_serverIndices.value("myNegotiationsBuyingGet")].URL()+"/my/negotiations/buying");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsBuyingGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_offers");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsBuyingGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myNegotiationsBuyingGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myNegotiationsBuyingGetSignal();
        Q_EMIT myNegotiationsBuyingGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_offers");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myNegotiationsBuyingGetSignalE(error_type, error_str);
        Q_EMIT myNegotiationsBuyingGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myNegotiationsBuyingGetSignalError(error_type, error_str);
        Q_EMIT myNegotiationsBuyingGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myNegotiationsIdAcceptPost(const QString &id, const ::OpenAPI::OptionalParam<OAI_my_negotiations__id__accept_post_request> &oai_my_negotiations__id__accept_post_request) {
    QString fullPath = QString(_serverConfigs["myNegotiationsIdAcceptPost"][_serverIndices.value("myNegotiationsIdAcceptPost")].URL()+"/my/negotiations/{id}/accept");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_my_negotiations__id__accept_post_request.hasValue()){

        
        QByteArray output = oai_my_negotiations__id__accept_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdAcceptPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_offers");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdAcceptPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myNegotiationsIdAcceptPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myNegotiationsIdAcceptPostSignal();
        Q_EMIT myNegotiationsIdAcceptPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_offers");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myNegotiationsIdAcceptPostSignalE(error_type, error_str);
        Q_EMIT myNegotiationsIdAcceptPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myNegotiationsIdAcceptPostSignalError(error_type, error_str);
        Q_EMIT myNegotiationsIdAcceptPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myNegotiationsIdCounterPost(const QString &id, const ::OpenAPI::OptionalParam<OAI_conversations__conversation_id__offer_post_request> &oai_conversations__conversation_id__offer_post_request) {
    QString fullPath = QString(_serverConfigs["myNegotiationsIdCounterPost"][_serverIndices.value("myNegotiationsIdCounterPost")].URL()+"/my/negotiations/{id}/counter");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_conversations__conversation_id__offer_post_request.hasValue()){

        
        QByteArray output = oai_conversations__conversation_id__offer_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdCounterPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_offers");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdCounterPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myNegotiationsIdCounterPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myNegotiationsIdCounterPostSignal();
        Q_EMIT myNegotiationsIdCounterPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_offers");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myNegotiationsIdCounterPostSignalE(error_type, error_str);
        Q_EMIT myNegotiationsIdCounterPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myNegotiationsIdCounterPostSignalError(error_type, error_str);
        Q_EMIT myNegotiationsIdCounterPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myNegotiationsIdDeclinePost(const QString &id) {
    QString fullPath = QString(_serverConfigs["myNegotiationsIdDeclinePost"][_serverIndices.value("myNegotiationsIdDeclinePost")].URL()+"/my/negotiations/{id}/decline");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdDeclinePostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_offers");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdDeclinePostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myNegotiationsIdDeclinePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myNegotiationsIdDeclinePostSignal();
        Q_EMIT myNegotiationsIdDeclinePostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_offers");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myNegotiationsIdDeclinePostSignalE(error_type, error_str);
        Q_EMIT myNegotiationsIdDeclinePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myNegotiationsIdDeclinePostSignalError(error_type, error_str);
        Q_EMIT myNegotiationsIdDeclinePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myNegotiationsIdGet(const QString &id) {
    QString fullPath = QString(_serverConfigs["myNegotiationsIdGet"][_serverIndices.value("myNegotiationsIdGet")].URL()+"/my/negotiations/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_offers");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myNegotiationsIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myNegotiationsIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myNegotiationsIdGetSignal();
        Q_EMIT myNegotiationsIdGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_offers");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myNegotiationsIdGetSignalE(error_type, error_str);
        Q_EMIT myNegotiationsIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myNegotiationsIdGetSignalError(error_type, error_str);
        Q_EMIT myNegotiationsIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersAwaitingFeedbackGet() {
    QString fullPath = QString(_serverConfigs["myOrdersAwaitingFeedbackGet"][_serverIndices.value("myOrdersAwaitingFeedbackGet")].URL()+"/my/orders/awaiting_feedback");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersAwaitingFeedbackGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_feedback");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersAwaitingFeedbackGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersAwaitingFeedbackGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersAwaitingFeedbackGetSignal();
        Q_EMIT myOrdersAwaitingFeedbackGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_feedback");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersAwaitingFeedbackGetSignalE(error_type, error_str);
        Q_EMIT myOrdersAwaitingFeedbackGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersAwaitingFeedbackGetSignalError(error_type, error_str);
        Q_EMIT myOrdersAwaitingFeedbackGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersBuyingAllGet() {
    QString fullPath = QString(_serverConfigs["myOrdersBuyingAllGet"][_serverIndices.value("myOrdersBuyingAllGet")].URL()+"/my/orders/buying/all");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingAllGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingAllGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersBuyingAllGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersBuyingAllGetSignal();
        Q_EMIT myOrdersBuyingAllGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersBuyingAllGetSignalE(error_type, error_str);
        Q_EMIT myOrdersBuyingAllGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersBuyingAllGetSignalError(error_type, error_str);
        Q_EMIT myOrdersBuyingAllGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersBuyingByUuidUuidGet(const QString &uuid) {
    QString fullPath = QString(_serverConfigs["myOrdersBuyingByUuidUuidGet"][_serverIndices.value("myOrdersBuyingByUuidUuidGet")].URL()+"/my/orders/buying/by_uuid/{uuid}");
    
    
    {
        QString uuidPathParam("{");
        uuidPathParam.append("uuid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "uuid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"uuid"+pathSuffix : pathPrefix;
        fullPath.replace(uuidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(uuid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingByUuidUuidGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIMyApi::myOrdersBuyingByUuidUuidGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersBuyingByUuidUuidGetSignal();
        Q_EMIT myOrdersBuyingByUuidUuidGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersBuyingByUuidUuidGetSignalE(error_type, error_str);
        Q_EMIT myOrdersBuyingByUuidUuidGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersBuyingByUuidUuidGetSignalError(error_type, error_str);
        Q_EMIT myOrdersBuyingByUuidUuidGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersBuyingIdGet(const QString &id) {
    QString fullPath = QString(_serverConfigs["myOrdersBuyingIdGet"][_serverIndices.value("myOrdersBuyingIdGet")].URL()+"/my/orders/buying/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersBuyingIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersBuyingIdGetSignal();
        Q_EMIT myOrdersBuyingIdGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersBuyingIdGetSignalE(error_type, error_str);
        Q_EMIT myOrdersBuyingIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersBuyingIdGetSignalError(error_type, error_str);
        Q_EMIT myOrdersBuyingIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersBuyingIdMarkReceivedPost(const QString &id) {
    QString fullPath = QString(_serverConfigs["myOrdersBuyingIdMarkReceivedPost"][_serverIndices.value("myOrdersBuyingIdMarkReceivedPost")].URL()+"/my/orders/buying/{id}/mark_received");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingIdMarkReceivedPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingIdMarkReceivedPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersBuyingIdMarkReceivedPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersBuyingIdMarkReceivedPostSignal();
        Q_EMIT myOrdersBuyingIdMarkReceivedPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersBuyingIdMarkReceivedPostSignalE(error_type, error_str);
        Q_EMIT myOrdersBuyingIdMarkReceivedPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersBuyingIdMarkReceivedPostSignalError(error_type, error_str);
        Q_EMIT myOrdersBuyingIdMarkReceivedPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersBuyingUnpaidGet() {
    QString fullPath = QString(_serverConfigs["myOrdersBuyingUnpaidGet"][_serverIndices.value("myOrdersBuyingUnpaidGet")].URL()+"/my/orders/buying/unpaid");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingUnpaidGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersBuyingUnpaidGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersBuyingUnpaidGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersBuyingUnpaidGetSignal();
        Q_EMIT myOrdersBuyingUnpaidGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersBuyingUnpaidGetSignalE(error_type, error_str);
        Q_EMIT myOrdersBuyingUnpaidGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersBuyingUnpaidGetSignalError(error_type, error_str);
        Q_EMIT myOrdersBuyingUnpaidGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingAllGet() {
    QString fullPath = QString(_serverConfigs["myOrdersSellingAllGet"][_serverIndices.value("myOrdersSellingAllGet")].URL()+"/my/orders/selling/all");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingAllGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingAllGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingAllGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingAllGetSignal();
        Q_EMIT myOrdersSellingAllGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingAllGetSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingAllGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingAllGetSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingAllGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingAwaitingShipmentGet() {
    QString fullPath = QString(_serverConfigs["myOrdersSellingAwaitingShipmentGet"][_serverIndices.value("myOrdersSellingAwaitingShipmentGet")].URL()+"/my/orders/selling/awaiting_shipment");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingAwaitingShipmentGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingAwaitingShipmentGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingAwaitingShipmentGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingAwaitingShipmentGetSignal();
        Q_EMIT myOrdersSellingAwaitingShipmentGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingAwaitingShipmentGetSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingAwaitingShipmentGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingAwaitingShipmentGetSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingAwaitingShipmentGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingBuyerHistoryBuyerIdGet(const QString &buyer_id) {
    QString fullPath = QString(_serverConfigs["myOrdersSellingBuyerHistoryBuyerIdGet"][_serverIndices.value("myOrdersSellingBuyerHistoryBuyerIdGet")].URL()+"/my/orders/selling/buyer_history/{buyer_id}");
    
    
    {
        QString buyer_idPathParam("{");
        buyer_idPathParam.append("buyer_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "buyer_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"buyer_id"+pathSuffix : pathPrefix;
        fullPath.replace(buyer_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(buyer_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingBuyerHistoryBuyerIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingBuyerHistoryBuyerIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingBuyerHistoryBuyerIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingBuyerHistoryBuyerIdGetSignal();
        Q_EMIT myOrdersSellingBuyerHistoryBuyerIdGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingBuyerHistoryBuyerIdGetSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingBuyerHistoryBuyerIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingBuyerHistoryBuyerIdGetSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingBuyerHistoryBuyerIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingByUuidUuidGet(const QString &uuid) {
    QString fullPath = QString(_serverConfigs["myOrdersSellingByUuidUuidGet"][_serverIndices.value("myOrdersSellingByUuidUuidGet")].URL()+"/my/orders/selling/by_uuid/{uuid}");
    
    
    {
        QString uuidPathParam("{");
        uuidPathParam.append("uuid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "uuid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"uuid"+pathSuffix : pathPrefix;
        fullPath.replace(uuidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(uuid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingByUuidUuidGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingByUuidUuidGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingByUuidUuidGetSignal();
        Q_EMIT myOrdersSellingByUuidUuidGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingByUuidUuidGetSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingByUuidUuidGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingByUuidUuidGetSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingByUuidUuidGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingIdGet(const QString &id) {
    QString fullPath = QString(_serverConfigs["myOrdersSellingIdGet"][_serverIndices.value("myOrdersSellingIdGet")].URL()+"/my/orders/selling/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingIdGetSignal();
        Q_EMIT myOrdersSellingIdGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingIdGetSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingIdGetSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingIdMarkPickedUpPost(const QString &id, const ::OpenAPI::OptionalParam<OAI_my_orders_selling__id__mark_picked_up_post_request> &oai_my_orders_selling__id__mark_picked_up_post_request) {
    QString fullPath = QString(_serverConfigs["myOrdersSellingIdMarkPickedUpPost"][_serverIndices.value("myOrdersSellingIdMarkPickedUpPost")].URL()+"/my/orders/selling/{id}/mark_picked_up");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_my_orders_selling__id__mark_picked_up_post_request.hasValue()){

        
        QByteArray output = oai_my_orders_selling__id__mark_picked_up_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingIdMarkPickedUpPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingIdMarkPickedUpPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingIdMarkPickedUpPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingIdMarkPickedUpPostSignal();
        Q_EMIT myOrdersSellingIdMarkPickedUpPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingIdMarkPickedUpPostSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingIdMarkPickedUpPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingIdMarkPickedUpPostSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingIdMarkPickedUpPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingIdShipPost(const QString &id, const ::OpenAPI::OptionalParam<OAI_my_orders_selling__id__ship_post_request> &oai_my_orders_selling__id__ship_post_request) {
    QString fullPath = QString(_serverConfigs["myOrdersSellingIdShipPost"][_serverIndices.value("myOrdersSellingIdShipPost")].URL()+"/my/orders/selling/{id}/ship");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_my_orders_selling__id__ship_post_request.hasValue()){

        
        QByteArray output = oai_my_orders_selling__id__ship_post_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingIdShipPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingIdShipPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingIdShipPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingIdShipPostSignal();
        Q_EMIT myOrdersSellingIdShipPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingIdShipPostSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingIdShipPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingIdShipPostSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingIdShipPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingOrderIdRefundRequestsPost(const QString &order_id) {
    QString fullPath = QString(_serverConfigs["myOrdersSellingOrderIdRefundRequestsPost"][_serverIndices.value("myOrdersSellingOrderIdRefundRequestsPost")].URL()+"/my/orders/selling/{order_id}/refund_requests");
    
    
    {
        QString order_idPathParam("{");
        order_idPathParam.append("order_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "order_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"order_id"+pathSuffix : pathPrefix;
        fullPath.replace(order_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(order_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingOrderIdRefundRequestsPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingOrderIdRefundRequestsPostCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingOrderIdRefundRequestsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingOrderIdRefundRequestsPostSignal();
        Q_EMIT myOrdersSellingOrderIdRefundRequestsPostSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingOrderIdRefundRequestsPostSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingOrderIdRefundRequestsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingOrderIdRefundRequestsPostSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingOrderIdRefundRequestsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myOrdersSellingUnpaidGet() {
    QString fullPath = QString(_serverConfigs["myOrdersSellingUnpaidGet"][_serverIndices.value("myOrdersSellingUnpaidGet")].URL()+"/my/orders/selling/unpaid");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingUnpaidGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myOrdersSellingUnpaidGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myOrdersSellingUnpaidGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myOrdersSellingUnpaidGetSignal();
        Q_EMIT myOrdersSellingUnpaidGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myOrdersSellingUnpaidGetSignalE(error_type, error_str);
        Q_EMIT myOrdersSellingUnpaidGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myOrdersSellingUnpaidGetSignalError(error_type, error_str);
        Q_EMIT myOrdersSellingUnpaidGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myPaymentsSellingGet(const ::OpenAPI::OptionalParam<qint32> &page, const ::OpenAPI::OptionalParam<qint32> &per_page, const ::OpenAPI::OptionalParam<qint32> &offset, const ::OpenAPI::OptionalParam<QString> &created_start_date, const ::OpenAPI::OptionalParam<QString> &created_end_date, const ::OpenAPI::OptionalParam<QString> &updated_start_date, const ::OpenAPI::OptionalParam<QString> &updated_end_date, const ::OpenAPI::OptionalParam<QString> &order_id) {
    QString fullPath = QString(_serverConfigs["myPaymentsSellingGet"][_serverIndices.value("myPaymentsSellingGet")].URL()+"/my/payments/selling");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    if (created_start_date.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "created_start_date", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("created_start_date")).append(querySuffix).append(QUrl::toPercentEncoding(created_start_date.stringValue()));
    }
    if (created_end_date.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "created_end_date", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("created_end_date")).append(querySuffix).append(QUrl::toPercentEncoding(created_end_date.stringValue()));
    }
    if (updated_start_date.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "updated_start_date", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("updated_start_date")).append(querySuffix).append(QUrl::toPercentEncoding(updated_start_date.stringValue()));
    }
    if (updated_end_date.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "updated_end_date", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("updated_end_date")).append(querySuffix).append(QUrl::toPercentEncoding(updated_end_date.stringValue()));
    }
    if (order_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "order_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("order_id")).append(querySuffix).append(QUrl::toPercentEncoding(order_id.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPaymentsSellingGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPaymentsSellingGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myPaymentsSellingGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myPaymentsSellingGetSignal();
        Q_EMIT myPaymentsSellingGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myPaymentsSellingGetSignalE(error_type, error_str);
        Q_EMIT myPaymentsSellingGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myPaymentsSellingGetSignalError(error_type, error_str);
        Q_EMIT myPaymentsSellingGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myPaymentsSellingIdGet(const QString &id) {
    QString fullPath = QString(_serverConfigs["myPaymentsSellingIdGet"][_serverIndices.value("myPaymentsSellingIdGet")].URL()+"/my/payments/selling/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPaymentsSellingIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPaymentsSellingIdGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myPaymentsSellingIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myPaymentsSellingIdGetSignal();
        Q_EMIT myPaymentsSellingIdGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myPaymentsSellingIdGetSignalE(error_type, error_str);
        Q_EMIT myPaymentsSellingIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myPaymentsSellingIdGetSignalError(error_type, error_str);
        Q_EMIT myPaymentsSellingIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myPayoutsGet() {
    QString fullPath = QString(_serverConfigs["myPayoutsGet"][_serverIndices.value("myPayoutsGet")].URL()+"/my/payouts");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPayoutsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_payouts");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPayoutsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myPayoutsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myPayoutsGetSignal();
        Q_EMIT myPayoutsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_payouts");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myPayoutsGetSignalE(error_type, error_str);
        Q_EMIT myPayoutsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myPayoutsGetSignalError(error_type, error_str);
        Q_EMIT myPayoutsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myPayoutsIdLineItemsGet(const QString &id) {
    QString fullPath = QString(_serverConfigs["myPayoutsIdLineItemsGet"][_serverIndices.value("myPayoutsIdLineItemsGet")].URL()+"/my/payouts/{id}/line_items");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPayoutsIdLineItemsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_payouts");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myPayoutsIdLineItemsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myPayoutsIdLineItemsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myPayoutsIdLineItemsGetSignal();
        Q_EMIT myPayoutsIdLineItemsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_payouts");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myPayoutsIdLineItemsGetSignalE(error_type, error_str);
        Q_EMIT myPayoutsIdLineItemsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myPayoutsIdLineItemsGetSignalError(error_type, error_str);
        Q_EMIT myPayoutsIdLineItemsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myRefundRequestsSellingGet() {
    QString fullPath = QString(_serverConfigs["myRefundRequestsSellingGet"][_serverIndices.value("myRefundRequestsSellingGet")].URL()+"/my/refund_requests/selling");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myRefundRequestsSellingGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myRefundRequestsSellingGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myRefundRequestsSellingGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myRefundRequestsSellingGetSignal();
        Q_EMIT myRefundRequestsSellingGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myRefundRequestsSellingGetSignalE(error_type, error_str);
        Q_EMIT myRefundRequestsSellingGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myRefundRequestsSellingGetSignalError(error_type, error_str);
        Q_EMIT myRefundRequestsSellingGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myRefundRequestsSellingIdPut(const QString &id) {
    QString fullPath = QString(_serverConfigs["myRefundRequestsSellingIdPut"][_serverIndices.value("myRefundRequestsSellingIdPut")].URL()+"/my/refund_requests/selling/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myRefundRequestsSellingIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_orders");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myRefundRequestsSellingIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myRefundRequestsSellingIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myRefundRequestsSellingIdPutSignal();
        Q_EMIT myRefundRequestsSellingIdPutSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_orders");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myRefundRequestsSellingIdPutSignalE(error_type, error_str);
        Q_EMIT myRefundRequestsSellingIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myRefundRequestsSellingIdPutSignalError(error_type, error_str);
        Q_EMIT myRefundRequestsSellingIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myViewedListingsGet() {
    QString fullPath = QString(_serverConfigs["myViewedListingsGet"][_serverIndices.value("myViewedListingsGet")].URL()+"/my/viewed_listings");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myViewedListingsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myViewedListingsGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myViewedListingsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myViewedListingsGetSignal();
        Q_EMIT myViewedListingsGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myViewedListingsGetSignalE(error_type, error_str);
        Q_EMIT myViewedListingsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myViewedListingsGetSignalError(error_type, error_str);
        Q_EMIT myViewedListingsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myWishlistGet() {
    QString fullPath = QString(_serverConfigs["myWishlistGet"][_serverIndices.value("myWishlistGet")].URL()+"/my/wishlist");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myWishlistGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("read_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myWishlistGetCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myWishlistGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myWishlistGetSignal();
        Q_EMIT myWishlistGetSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("read_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myWishlistGetSignalE(error_type, error_str);
        Q_EMIT myWishlistGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myWishlistGetSignalError(error_type, error_str);
        Q_EMIT myWishlistGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myWishlistIdDelete(const QString &id) {
    QString fullPath = QString(_serverConfigs["myWishlistIdDelete"][_serverIndices.value("myWishlistIdDelete")].URL()+"/my/wishlist/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myWishlistIdDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myWishlistIdDeleteCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myWishlistIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myWishlistIdDeleteSignal();
        Q_EMIT myWishlistIdDeleteSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myWishlistIdDeleteSignalE(error_type, error_str);
        Q_EMIT myWishlistIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myWishlistIdDeleteSignalError(error_type, error_str);
        Q_EMIT myWishlistIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::myWishlistIdPut(const QString &id) {
    QString fullPath = QString(_serverConfigs["myWishlistIdPut"][_serverIndices.value("myWishlistIdPut")].URL()+"/my/wishlist/{id}");
    
    
    {
        QString idPathParam("{");
        idPathParam.append("id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"id"+pathSuffix : pathPrefix;
        fullPath.replace(idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myWishlistIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("write_lists");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIMyApi::myWishlistIdPutCallback);
    connect(this, &OAIMyApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;


    worker->execute(&input);
}

void OAIMyApi::myWishlistIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT myWishlistIdPutSignal();
        Q_EMIT myWishlistIdPutSignalFull(worker);

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("write_lists");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://reverb.com/oauth/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT myWishlistIdPutSignalE(error_type, error_str);
        Q_EMIT myWishlistIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT myWishlistIdPutSignalError(error_type, error_str);
        Q_EMIT myWishlistIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIMyApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
