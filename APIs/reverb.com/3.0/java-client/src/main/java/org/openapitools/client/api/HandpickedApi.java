/*
 * reverb
 * reverb
 *
 * The version of the OpenAPI document: 3.0
 * Contact: integrations@reverb.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;



import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HandpickedApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public HandpickedApi() {
        this(Configuration.getDefaultApiClient());
    }

    public HandpickedApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for handpickedSlugGet
     * @param slug  (required)
     * @param query Search query. (optional)
     * @param auctionPriceMax Maximum current auction price (optional)
     * @param category Category slug from /api/categories (optional)
     * @param productType Product type slug from /api/categories (optional)
     * @param conditions Condition: all,new,b-stock,used,non-functioning,all-but-new,poor,fair,good,very-good,excellent,mint (optional)
     * @param decade Decade: e.g. 1970s, early 70s (optional)
     * @param finish Visual finish of the item, common for guitars (optional)
     * @param handmade Handmade items only (optional)
     * @param itemCity City where item is located (optional)
     * @param itemCountry DEPRECATED - Country code where item is located (optional)
     * @param itemRegion Country code where item is located (optional)
     * @param itemState State or region code where item is located (optional)
     * @param make Make(s)/brand of item (e.g. Fender). Can take a single value or an array. (optional)
     * @param model Model of item (e.g. Stratocaster) (optional)
     * @param mustNot Search term negation. If you want to exclude a term, add it here (optional)
     * @param priceMax Maximum price of search results (USD) (optional)
     * @param priceMin Minimum price of search results (USD) (optional)
     * @param currency The currency to be used for the price filters (optional)
     * @param yearMax Maximum year of manufacture (optional)
     * @param yearMin Minumum year of manufacture (optional)
     * @param acceptsGiftCards If true, include only items that accept gift cards (optional)
     * @param preferredSeller If true, include only items by Reverb Preferred Sellers (optional)
     * @param shop Slug of shop to search (optional)
     * @param shopId ID of shop to search (optional)
     * @param listingType Type of listing: auctions,offers (optional)
     * @param shipsTo Limit search to items that ship to this country code (optional)
     * @param excludeAuctions If true, exclude auctions (optional)
     * @param acceptsPaymentPlans If true, only show items that can be purchased with a payment plan (optional)
     * @param watchersCountMin Minimum number of watchers (used to find popular items) (optional)
     * @param notIds Listing ID negation. If you want to exclude a listing, add it here. (optional)
     * @param localPickup Only items that offer local pickup (optional)
     * @param page  (optional, default to 1)
     * @param perPage  (optional, default to 24)
     * @param offset  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call handpickedSlugGetCall(String slug, String query, Float auctionPriceMax, String category, String productType, List<String> conditions, String decade, String finish, Boolean handmade, String itemCity, String itemCountry, String itemRegion, String itemState, List<String> make, String model, String mustNot, Float priceMax, Float priceMin, String currency, Integer yearMax, Integer yearMin, Boolean acceptsGiftCards, Boolean preferredSeller, String shop, String shopId, String listingType, String shipsTo, Boolean excludeAuctions, Boolean acceptsPaymentPlans, Integer watchersCountMin, List<String> notIds, Boolean localPickup, Integer page, Integer perPage, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/handpicked/{slug}"
            .replace("{" + "slug" + "}", localVarApiClient.escapeString(slug.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (auctionPriceMax != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("auction_price_max", auctionPriceMax));
        }

        if (category != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("category", category));
        }

        if (productType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("product_type", productType));
        }

        if (conditions != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "conditions", conditions));
        }

        if (decade != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("decade", decade));
        }

        if (finish != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("finish", finish));
        }

        if (handmade != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("handmade", handmade));
        }

        if (itemCity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("item_city", itemCity));
        }

        if (itemCountry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("item_country", itemCountry));
        }

        if (itemRegion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("item_region", itemRegion));
        }

        if (itemState != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("item_state", itemState));
        }

        if (make != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "make", make));
        }

        if (model != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("model", model));
        }

        if (mustNot != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("must_not", mustNot));
        }

        if (priceMax != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("price_max", priceMax));
        }

        if (priceMin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("price_min", priceMin));
        }

        if (currency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currency", currency));
        }

        if (yearMax != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("year_max", yearMax));
        }

        if (yearMin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("year_min", yearMin));
        }

        if (acceptsGiftCards != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accepts_gift_cards", acceptsGiftCards));
        }

        if (preferredSeller != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preferred_seller", preferredSeller));
        }

        if (shop != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("shop", shop));
        }

        if (shopId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("shop_id", shopId));
        }

        if (listingType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("listing_type", listingType));
        }

        if (shipsTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ships_to", shipsTo));
        }

        if (excludeAuctions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_auctions", excludeAuctions));
        }

        if (acceptsPaymentPlans != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accepts_payment_plans", acceptsPaymentPlans));
        }

        if (watchersCountMin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("watchers_count_min", watchersCountMin));
        }

        if (notIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "not_ids", notIds));
        }

        if (localPickup != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("local_pickup", localPickup));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call handpickedSlugGetValidateBeforeCall(String slug, String query, Float auctionPriceMax, String category, String productType, List<String> conditions, String decade, String finish, Boolean handmade, String itemCity, String itemCountry, String itemRegion, String itemState, List<String> make, String model, String mustNot, Float priceMax, Float priceMin, String currency, Integer yearMax, Integer yearMin, Boolean acceptsGiftCards, Boolean preferredSeller, String shop, String shopId, String listingType, String shipsTo, Boolean excludeAuctions, Boolean acceptsPaymentPlans, Integer watchersCountMin, List<String> notIds, Boolean localPickup, Integer page, Integer perPage, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'slug' is set
        if (slug == null) {
            throw new ApiException("Missing the required parameter 'slug' when calling handpickedSlugGet(Async)");
        }

        return handpickedSlugGetCall(slug, query, auctionPriceMax, category, productType, conditions, decade, finish, handmade, itemCity, itemCountry, itemRegion, itemState, make, model, mustNot, priceMax, priceMin, currency, yearMax, yearMin, acceptsGiftCards, preferredSeller, shop, shopId, listingType, shipsTo, excludeAuctions, acceptsPaymentPlans, watchersCountMin, notIds, localPickup, page, perPage, offset, _callback);

    }

    /**
     * Get results from a handpicked collection
     * Get results from a handpicked collection
     * @param slug  (required)
     * @param query Search query. (optional)
     * @param auctionPriceMax Maximum current auction price (optional)
     * @param category Category slug from /api/categories (optional)
     * @param productType Product type slug from /api/categories (optional)
     * @param conditions Condition: all,new,b-stock,used,non-functioning,all-but-new,poor,fair,good,very-good,excellent,mint (optional)
     * @param decade Decade: e.g. 1970s, early 70s (optional)
     * @param finish Visual finish of the item, common for guitars (optional)
     * @param handmade Handmade items only (optional)
     * @param itemCity City where item is located (optional)
     * @param itemCountry DEPRECATED - Country code where item is located (optional)
     * @param itemRegion Country code where item is located (optional)
     * @param itemState State or region code where item is located (optional)
     * @param make Make(s)/brand of item (e.g. Fender). Can take a single value or an array. (optional)
     * @param model Model of item (e.g. Stratocaster) (optional)
     * @param mustNot Search term negation. If you want to exclude a term, add it here (optional)
     * @param priceMax Maximum price of search results (USD) (optional)
     * @param priceMin Minimum price of search results (USD) (optional)
     * @param currency The currency to be used for the price filters (optional)
     * @param yearMax Maximum year of manufacture (optional)
     * @param yearMin Minumum year of manufacture (optional)
     * @param acceptsGiftCards If true, include only items that accept gift cards (optional)
     * @param preferredSeller If true, include only items by Reverb Preferred Sellers (optional)
     * @param shop Slug of shop to search (optional)
     * @param shopId ID of shop to search (optional)
     * @param listingType Type of listing: auctions,offers (optional)
     * @param shipsTo Limit search to items that ship to this country code (optional)
     * @param excludeAuctions If true, exclude auctions (optional)
     * @param acceptsPaymentPlans If true, only show items that can be purchased with a payment plan (optional)
     * @param watchersCountMin Minimum number of watchers (used to find popular items) (optional)
     * @param notIds Listing ID negation. If you want to exclude a listing, add it here. (optional)
     * @param localPickup Only items that offer local pickup (optional)
     * @param page  (optional, default to 1)
     * @param perPage  (optional, default to 24)
     * @param offset  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public void handpickedSlugGet(String slug, String query, Float auctionPriceMax, String category, String productType, List<String> conditions, String decade, String finish, Boolean handmade, String itemCity, String itemCountry, String itemRegion, String itemState, List<String> make, String model, String mustNot, Float priceMax, Float priceMin, String currency, Integer yearMax, Integer yearMin, Boolean acceptsGiftCards, Boolean preferredSeller, String shop, String shopId, String listingType, String shipsTo, Boolean excludeAuctions, Boolean acceptsPaymentPlans, Integer watchersCountMin, List<String> notIds, Boolean localPickup, Integer page, Integer perPage, Integer offset) throws ApiException {
        handpickedSlugGetWithHttpInfo(slug, query, auctionPriceMax, category, productType, conditions, decade, finish, handmade, itemCity, itemCountry, itemRegion, itemState, make, model, mustNot, priceMax, priceMin, currency, yearMax, yearMin, acceptsGiftCards, preferredSeller, shop, shopId, listingType, shipsTo, excludeAuctions, acceptsPaymentPlans, watchersCountMin, notIds, localPickup, page, perPage, offset);
    }

    /**
     * Get results from a handpicked collection
     * Get results from a handpicked collection
     * @param slug  (required)
     * @param query Search query. (optional)
     * @param auctionPriceMax Maximum current auction price (optional)
     * @param category Category slug from /api/categories (optional)
     * @param productType Product type slug from /api/categories (optional)
     * @param conditions Condition: all,new,b-stock,used,non-functioning,all-but-new,poor,fair,good,very-good,excellent,mint (optional)
     * @param decade Decade: e.g. 1970s, early 70s (optional)
     * @param finish Visual finish of the item, common for guitars (optional)
     * @param handmade Handmade items only (optional)
     * @param itemCity City where item is located (optional)
     * @param itemCountry DEPRECATED - Country code where item is located (optional)
     * @param itemRegion Country code where item is located (optional)
     * @param itemState State or region code where item is located (optional)
     * @param make Make(s)/brand of item (e.g. Fender). Can take a single value or an array. (optional)
     * @param model Model of item (e.g. Stratocaster) (optional)
     * @param mustNot Search term negation. If you want to exclude a term, add it here (optional)
     * @param priceMax Maximum price of search results (USD) (optional)
     * @param priceMin Minimum price of search results (USD) (optional)
     * @param currency The currency to be used for the price filters (optional)
     * @param yearMax Maximum year of manufacture (optional)
     * @param yearMin Minumum year of manufacture (optional)
     * @param acceptsGiftCards If true, include only items that accept gift cards (optional)
     * @param preferredSeller If true, include only items by Reverb Preferred Sellers (optional)
     * @param shop Slug of shop to search (optional)
     * @param shopId ID of shop to search (optional)
     * @param listingType Type of listing: auctions,offers (optional)
     * @param shipsTo Limit search to items that ship to this country code (optional)
     * @param excludeAuctions If true, exclude auctions (optional)
     * @param acceptsPaymentPlans If true, only show items that can be purchased with a payment plan (optional)
     * @param watchersCountMin Minimum number of watchers (used to find popular items) (optional)
     * @param notIds Listing ID negation. If you want to exclude a listing, add it here. (optional)
     * @param localPickup Only items that offer local pickup (optional)
     * @param page  (optional, default to 1)
     * @param perPage  (optional, default to 24)
     * @param offset  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> handpickedSlugGetWithHttpInfo(String slug, String query, Float auctionPriceMax, String category, String productType, List<String> conditions, String decade, String finish, Boolean handmade, String itemCity, String itemCountry, String itemRegion, String itemState, List<String> make, String model, String mustNot, Float priceMax, Float priceMin, String currency, Integer yearMax, Integer yearMin, Boolean acceptsGiftCards, Boolean preferredSeller, String shop, String shopId, String listingType, String shipsTo, Boolean excludeAuctions, Boolean acceptsPaymentPlans, Integer watchersCountMin, List<String> notIds, Boolean localPickup, Integer page, Integer perPage, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = handpickedSlugGetValidateBeforeCall(slug, query, auctionPriceMax, category, productType, conditions, decade, finish, handmade, itemCity, itemCountry, itemRegion, itemState, make, model, mustNot, priceMax, priceMin, currency, yearMax, yearMin, acceptsGiftCards, preferredSeller, shop, shopId, listingType, shipsTo, excludeAuctions, acceptsPaymentPlans, watchersCountMin, notIds, localPickup, page, perPage, offset, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Get results from a handpicked collection (asynchronously)
     * Get results from a handpicked collection
     * @param slug  (required)
     * @param query Search query. (optional)
     * @param auctionPriceMax Maximum current auction price (optional)
     * @param category Category slug from /api/categories (optional)
     * @param productType Product type slug from /api/categories (optional)
     * @param conditions Condition: all,new,b-stock,used,non-functioning,all-but-new,poor,fair,good,very-good,excellent,mint (optional)
     * @param decade Decade: e.g. 1970s, early 70s (optional)
     * @param finish Visual finish of the item, common for guitars (optional)
     * @param handmade Handmade items only (optional)
     * @param itemCity City where item is located (optional)
     * @param itemCountry DEPRECATED - Country code where item is located (optional)
     * @param itemRegion Country code where item is located (optional)
     * @param itemState State or region code where item is located (optional)
     * @param make Make(s)/brand of item (e.g. Fender). Can take a single value or an array. (optional)
     * @param model Model of item (e.g. Stratocaster) (optional)
     * @param mustNot Search term negation. If you want to exclude a term, add it here (optional)
     * @param priceMax Maximum price of search results (USD) (optional)
     * @param priceMin Minimum price of search results (USD) (optional)
     * @param currency The currency to be used for the price filters (optional)
     * @param yearMax Maximum year of manufacture (optional)
     * @param yearMin Minumum year of manufacture (optional)
     * @param acceptsGiftCards If true, include only items that accept gift cards (optional)
     * @param preferredSeller If true, include only items by Reverb Preferred Sellers (optional)
     * @param shop Slug of shop to search (optional)
     * @param shopId ID of shop to search (optional)
     * @param listingType Type of listing: auctions,offers (optional)
     * @param shipsTo Limit search to items that ship to this country code (optional)
     * @param excludeAuctions If true, exclude auctions (optional)
     * @param acceptsPaymentPlans If true, only show items that can be purchased with a payment plan (optional)
     * @param watchersCountMin Minimum number of watchers (used to find popular items) (optional)
     * @param notIds Listing ID negation. If you want to exclude a listing, add it here. (optional)
     * @param localPickup Only items that offer local pickup (optional)
     * @param page  (optional, default to 1)
     * @param perPage  (optional, default to 24)
     * @param offset  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call handpickedSlugGetAsync(String slug, String query, Float auctionPriceMax, String category, String productType, List<String> conditions, String decade, String finish, Boolean handmade, String itemCity, String itemCountry, String itemRegion, String itemState, List<String> make, String model, String mustNot, Float priceMax, Float priceMin, String currency, Integer yearMax, Integer yearMin, Boolean acceptsGiftCards, Boolean preferredSeller, String shop, String shopId, String listingType, String shipsTo, Boolean excludeAuctions, Boolean acceptsPaymentPlans, Integer watchersCountMin, List<String> notIds, Boolean localPickup, Integer page, Integer perPage, Integer offset, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = handpickedSlugGetValidateBeforeCall(slug, query, auctionPriceMax, category, productType, conditions, decade, finish, handmade, itemCity, itemCountry, itemRegion, itemState, make, model, mustNot, priceMax, priceMin, currency, yearMax, yearMin, acceptsGiftCards, preferredSeller, shop, shopId, listingType, shipsTo, excludeAuctions, acceptsPaymentPlans, watchersCountMin, notIds, localPickup, page, perPage, offset, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
