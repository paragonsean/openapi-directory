/*
 * reverb
 * reverb
 *
 * The version of the OpenAPI document: 3.0
 * Contact: integrations@reverb.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * MyFollowsSearchPostRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:02:29.182990-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MyFollowsSearchPostRequest {
  public static final String SERIALIZED_NAME_ACCEPTS_GIFT_CARDS = "accepts_gift_cards";
  @SerializedName(SERIALIZED_NAME_ACCEPTS_GIFT_CARDS)
  private Boolean acceptsGiftCards;

  public static final String SERIALIZED_NAME_ACCEPTS_PAYMENT_PLANS = "accepts_payment_plans";
  @SerializedName(SERIALIZED_NAME_ACCEPTS_PAYMENT_PLANS)
  private Boolean acceptsPaymentPlans;

  public static final String SERIALIZED_NAME_AUCTION_PRICE_MAX = "auction_price_max";
  @SerializedName(SERIALIZED_NAME_AUCTION_PRICE_MAX)
  private Float auctionPriceMax;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private String category;

  /**
   * Gets or Sets conditions
   */
  @JsonAdapter(String.Adapter.class)
  public enum String {

    private String value;

    String(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static String fromValue(String value) {
      for (String b : String.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<String> {
      @Override
      public void write(final JsonWriter jsonWriter, final String enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public String read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return String.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      String.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private ConditionsEnum conditions = new ArrayList<>();

  /**
   * The currency to be used for the price filters
   */
  @JsonAdapter(CurrencyEnum.Adapter.class)
  public enum CurrencyEnum {
    USD("USD"),
    
    CAD("CAD"),
    
    EUR("EUR"),
    
    GBP("GBP"),
    
    AUD("AUD"),
    
    JPY("JPY"),
    
    NZD("NZD"),
    
    MXN("MXN"),
    
    DKK("DKK"),
    
    SEK("SEK"),
    
    CHF("CHF"),
    
    ARS("ARS"),
    
    BRL("BRL"),
    
    HKD("HKD"),
    
    NOK("NOK"),
    
    PHP("PHP"),
    
    PLN("PLN"),
    
    RUB("RUB");

    private String value;

    CurrencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CurrencyEnum fromValue(String value) {
      for (CurrencyEnum b : CurrencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CurrencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CurrencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CurrencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CurrencyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CurrencyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private CurrencyEnum currency;

  public static final String SERIALIZED_NAME_DECADE = "decade";
  @SerializedName(SERIALIZED_NAME_DECADE)
  private String decade;

  public static final String SERIALIZED_NAME_EXCLUDE_AUCTIONS = "exclude_auctions";
  @SerializedName(SERIALIZED_NAME_EXCLUDE_AUCTIONS)
  private Boolean excludeAuctions;

  public static final String SERIALIZED_NAME_FINISH = "finish";
  @SerializedName(SERIALIZED_NAME_FINISH)
  private String finish;

  public static final String SERIALIZED_NAME_HANDMADE = "handmade";
  @SerializedName(SERIALIZED_NAME_HANDMADE)
  private Boolean handmade;

  public static final String SERIALIZED_NAME_ITEM_CITY = "item_city";
  @SerializedName(SERIALIZED_NAME_ITEM_CITY)
  private String itemCity;

  public static final String SERIALIZED_NAME_ITEM_COUNTRY = "item_country";
  @SerializedName(SERIALIZED_NAME_ITEM_COUNTRY)
  private String itemCountry;

  public static final String SERIALIZED_NAME_ITEM_REGION = "item_region";
  @SerializedName(SERIALIZED_NAME_ITEM_REGION)
  private String itemRegion;

  public static final String SERIALIZED_NAME_ITEM_STATE = "item_state";
  @SerializedName(SERIALIZED_NAME_ITEM_STATE)
  private String itemState;

  /**
   * Type of listing: auctions,offers
   */
  @JsonAdapter(ListingTypeEnum.Adapter.class)
  public enum ListingTypeEnum {
    AUCTIONS("auctions"),
    
    OFFERS("offers");

    private String value;

    ListingTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ListingTypeEnum fromValue(String value) {
      for (ListingTypeEnum b : ListingTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ListingTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ListingTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ListingTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ListingTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ListingTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LISTING_TYPE = "listing_type";
  @SerializedName(SERIALIZED_NAME_LISTING_TYPE)
  private ListingTypeEnum listingType;

  public static final String SERIALIZED_NAME_LOCAL_PICKUP = "local_pickup";
  @SerializedName(SERIALIZED_NAME_LOCAL_PICKUP)
  private Boolean localPickup;

  public static final String SERIALIZED_NAME_MAKE = "make";
  @SerializedName(SERIALIZED_NAME_MAKE)
  private List<String> make = new ArrayList<>();

  public static final String SERIALIZED_NAME_MODEL = "model";
  @SerializedName(SERIALIZED_NAME_MODEL)
  private String model;

  public static final String SERIALIZED_NAME_MUST_NOT = "must_not";
  @SerializedName(SERIALIZED_NAME_MUST_NOT)
  private String mustNot;

  public static final String SERIALIZED_NAME_NOT_IDS = "not_ids";
  @SerializedName(SERIALIZED_NAME_NOT_IDS)
  private List<Integer> notIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_PREFERRED_SELLER = "preferred_seller";
  @SerializedName(SERIALIZED_NAME_PREFERRED_SELLER)
  private Boolean preferredSeller;

  public static final String SERIALIZED_NAME_PRICE_MAX = "price_max";
  @SerializedName(SERIALIZED_NAME_PRICE_MAX)
  private Float priceMax;

  public static final String SERIALIZED_NAME_PRICE_MIN = "price_min";
  @SerializedName(SERIALIZED_NAME_PRICE_MIN)
  private Float priceMin;

  public static final String SERIALIZED_NAME_PRODUCT_TYPE = "product_type";
  @SerializedName(SERIALIZED_NAME_PRODUCT_TYPE)
  private String productType;

  public static final String SERIALIZED_NAME_QUERY = "query";
  @SerializedName(SERIALIZED_NAME_QUERY)
  private String query;

  public static final String SERIALIZED_NAME_SHIPS_TO = "ships_to";
  @SerializedName(SERIALIZED_NAME_SHIPS_TO)
  private String shipsTo;

  public static final String SERIALIZED_NAME_SHOP = "shop";
  @SerializedName(SERIALIZED_NAME_SHOP)
  private String shop;

  public static final String SERIALIZED_NAME_SHOP_ID = "shop_id";
  @SerializedName(SERIALIZED_NAME_SHOP_ID)
  private String shopId;

  public static final String SERIALIZED_NAME_WATCHERS_COUNT_MIN = "watchers_count_min";
  @SerializedName(SERIALIZED_NAME_WATCHERS_COUNT_MIN)
  private Integer watchersCountMin;

  public static final String SERIALIZED_NAME_YEAR_MAX = "year_max";
  @SerializedName(SERIALIZED_NAME_YEAR_MAX)
  private Integer yearMax;

  public static final String SERIALIZED_NAME_YEAR_MIN = "year_min";
  @SerializedName(SERIALIZED_NAME_YEAR_MIN)
  private Integer yearMin;

  public MyFollowsSearchPostRequest() {
  }

  public MyFollowsSearchPostRequest acceptsGiftCards(Boolean acceptsGiftCards) {
    this.acceptsGiftCards = acceptsGiftCards;
    return this;
  }

  /**
   * If true, include only items that accept gift cards
   * @return acceptsGiftCards
   */
  @javax.annotation.Nullable
  public Boolean getAcceptsGiftCards() {
    return acceptsGiftCards;
  }

  public void setAcceptsGiftCards(Boolean acceptsGiftCards) {
    this.acceptsGiftCards = acceptsGiftCards;
  }


  public MyFollowsSearchPostRequest acceptsPaymentPlans(Boolean acceptsPaymentPlans) {
    this.acceptsPaymentPlans = acceptsPaymentPlans;
    return this;
  }

  /**
   * If true, only show items that can be purchased with a payment plan
   * @return acceptsPaymentPlans
   */
  @javax.annotation.Nullable
  public Boolean getAcceptsPaymentPlans() {
    return acceptsPaymentPlans;
  }

  public void setAcceptsPaymentPlans(Boolean acceptsPaymentPlans) {
    this.acceptsPaymentPlans = acceptsPaymentPlans;
  }


  public MyFollowsSearchPostRequest auctionPriceMax(Float auctionPriceMax) {
    this.auctionPriceMax = auctionPriceMax;
    return this;
  }

  /**
   * Maximum current auction price
   * @return auctionPriceMax
   */
  @javax.annotation.Nullable
  public Float getAuctionPriceMax() {
    return auctionPriceMax;
  }

  public void setAuctionPriceMax(Float auctionPriceMax) {
    this.auctionPriceMax = auctionPriceMax;
  }


  public MyFollowsSearchPostRequest category(String category) {
    this.category = category;
    return this;
  }

  /**
   * Category slug from /api/categories
   * @return category
   */
  @javax.annotation.Nullable
  public String getCategory() {
    return category;
  }

  public void setCategory(String category) {
    this.category = category;
  }


  public MyFollowsSearchPostRequest conditions(ConditionsEnum conditions) {
    this.conditions = conditions;
    return this;
  }

  public MyFollowsSearchPostRequest addConditionsItem(String conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

  /**
   * Condition: all,new,b-stock,used,non-functioning,all-but-new,poor,fair,good,very-good,excellent,mint
   * @return conditions
   */
  @javax.annotation.Nullable
  public ConditionsEnum getConditions() {
    return conditions;
  }

  public void setConditions(ConditionsEnum conditions) {
    this.conditions = conditions;
  }


  public MyFollowsSearchPostRequest currency(CurrencyEnum currency) {
    this.currency = currency;
    return this;
  }

  /**
   * The currency to be used for the price filters
   * @return currency
   */
  @javax.annotation.Nullable
  public CurrencyEnum getCurrency() {
    return currency;
  }

  public void setCurrency(CurrencyEnum currency) {
    this.currency = currency;
  }


  public MyFollowsSearchPostRequest decade(String decade) {
    this.decade = decade;
    return this;
  }

  /**
   * Decade: e.g. 1970s, early 70s
   * @return decade
   */
  @javax.annotation.Nullable
  public String getDecade() {
    return decade;
  }

  public void setDecade(String decade) {
    this.decade = decade;
  }


  public MyFollowsSearchPostRequest excludeAuctions(Boolean excludeAuctions) {
    this.excludeAuctions = excludeAuctions;
    return this;
  }

  /**
   * If true, exclude auctions
   * @return excludeAuctions
   */
  @javax.annotation.Nullable
  public Boolean getExcludeAuctions() {
    return excludeAuctions;
  }

  public void setExcludeAuctions(Boolean excludeAuctions) {
    this.excludeAuctions = excludeAuctions;
  }


  public MyFollowsSearchPostRequest finish(String finish) {
    this.finish = finish;
    return this;
  }

  /**
   * Visual finish of the item, common for guitars
   * @return finish
   */
  @javax.annotation.Nullable
  public String getFinish() {
    return finish;
  }

  public void setFinish(String finish) {
    this.finish = finish;
  }


  public MyFollowsSearchPostRequest handmade(Boolean handmade) {
    this.handmade = handmade;
    return this;
  }

  /**
   * Handmade items only
   * @return handmade
   */
  @javax.annotation.Nullable
  public Boolean getHandmade() {
    return handmade;
  }

  public void setHandmade(Boolean handmade) {
    this.handmade = handmade;
  }


  public MyFollowsSearchPostRequest itemCity(String itemCity) {
    this.itemCity = itemCity;
    return this;
  }

  /**
   * City where item is located
   * @return itemCity
   */
  @javax.annotation.Nullable
  public String getItemCity() {
    return itemCity;
  }

  public void setItemCity(String itemCity) {
    this.itemCity = itemCity;
  }


  public MyFollowsSearchPostRequest itemCountry(String itemCountry) {
    this.itemCountry = itemCountry;
    return this;
  }

  /**
   * DEPRECATED - Country code where item is located
   * @return itemCountry
   */
  @javax.annotation.Nullable
  public String getItemCountry() {
    return itemCountry;
  }

  public void setItemCountry(String itemCountry) {
    this.itemCountry = itemCountry;
  }


  public MyFollowsSearchPostRequest itemRegion(String itemRegion) {
    this.itemRegion = itemRegion;
    return this;
  }

  /**
   * Country code where item is located
   * @return itemRegion
   */
  @javax.annotation.Nullable
  public String getItemRegion() {
    return itemRegion;
  }

  public void setItemRegion(String itemRegion) {
    this.itemRegion = itemRegion;
  }


  public MyFollowsSearchPostRequest itemState(String itemState) {
    this.itemState = itemState;
    return this;
  }

  /**
   * State or region code where item is located
   * @return itemState
   */
  @javax.annotation.Nullable
  public String getItemState() {
    return itemState;
  }

  public void setItemState(String itemState) {
    this.itemState = itemState;
  }


  public MyFollowsSearchPostRequest listingType(ListingTypeEnum listingType) {
    this.listingType = listingType;
    return this;
  }

  /**
   * Type of listing: auctions,offers
   * @return listingType
   */
  @javax.annotation.Nullable
  public ListingTypeEnum getListingType() {
    return listingType;
  }

  public void setListingType(ListingTypeEnum listingType) {
    this.listingType = listingType;
  }


  public MyFollowsSearchPostRequest localPickup(Boolean localPickup) {
    this.localPickup = localPickup;
    return this;
  }

  /**
   * Only items that offer local pickup
   * @return localPickup
   */
  @javax.annotation.Nullable
  public Boolean getLocalPickup() {
    return localPickup;
  }

  public void setLocalPickup(Boolean localPickup) {
    this.localPickup = localPickup;
  }


  public MyFollowsSearchPostRequest make(List<String> make) {
    this.make = make;
    return this;
  }

  public MyFollowsSearchPostRequest addMakeItem(String makeItem) {
    if (this.make == null) {
      this.make = new ArrayList<>();
    }
    this.make.add(makeItem);
    return this;
  }

  /**
   * Make(s)/brand of item (e.g. Fender). Can take a single value or an array.
   * @return make
   */
  @javax.annotation.Nullable
  public List<String> getMake() {
    return make;
  }

  public void setMake(List<String> make) {
    this.make = make;
  }


  public MyFollowsSearchPostRequest model(String model) {
    this.model = model;
    return this;
  }

  /**
   * Model of item (e.g. Stratocaster)
   * @return model
   */
  @javax.annotation.Nullable
  public String getModel() {
    return model;
  }

  public void setModel(String model) {
    this.model = model;
  }


  public MyFollowsSearchPostRequest mustNot(String mustNot) {
    this.mustNot = mustNot;
    return this;
  }

  /**
   * Search term negation. If you want to exclude a term, add it here
   * @return mustNot
   */
  @javax.annotation.Nullable
  public String getMustNot() {
    return mustNot;
  }

  public void setMustNot(String mustNot) {
    this.mustNot = mustNot;
  }


  public MyFollowsSearchPostRequest notIds(List<Integer> notIds) {
    this.notIds = notIds;
    return this;
  }

  public MyFollowsSearchPostRequest addNotIdsItem(Integer notIdsItem) {
    if (this.notIds == null) {
      this.notIds = new ArrayList<>();
    }
    this.notIds.add(notIdsItem);
    return this;
  }

  /**
   * Listing ID negation. If you want to exclude a listing, add it here.
   * @return notIds
   */
  @javax.annotation.Nullable
  public List<Integer> getNotIds() {
    return notIds;
  }

  public void setNotIds(List<Integer> notIds) {
    this.notIds = notIds;
  }


  public MyFollowsSearchPostRequest preferredSeller(Boolean preferredSeller) {
    this.preferredSeller = preferredSeller;
    return this;
  }

  /**
   * If true, include only items by Reverb Preferred Sellers
   * @return preferredSeller
   */
  @javax.annotation.Nullable
  public Boolean getPreferredSeller() {
    return preferredSeller;
  }

  public void setPreferredSeller(Boolean preferredSeller) {
    this.preferredSeller = preferredSeller;
  }


  public MyFollowsSearchPostRequest priceMax(Float priceMax) {
    this.priceMax = priceMax;
    return this;
  }

  /**
   * Maximum price of search results (USD)
   * @return priceMax
   */
  @javax.annotation.Nullable
  public Float getPriceMax() {
    return priceMax;
  }

  public void setPriceMax(Float priceMax) {
    this.priceMax = priceMax;
  }


  public MyFollowsSearchPostRequest priceMin(Float priceMin) {
    this.priceMin = priceMin;
    return this;
  }

  /**
   * Minimum price of search results (USD)
   * @return priceMin
   */
  @javax.annotation.Nullable
  public Float getPriceMin() {
    return priceMin;
  }

  public void setPriceMin(Float priceMin) {
    this.priceMin = priceMin;
  }


  public MyFollowsSearchPostRequest productType(String productType) {
    this.productType = productType;
    return this;
  }

  /**
   * Product type slug from /api/categories
   * @return productType
   */
  @javax.annotation.Nullable
  public String getProductType() {
    return productType;
  }

  public void setProductType(String productType) {
    this.productType = productType;
  }


  public MyFollowsSearchPostRequest query(String query) {
    this.query = query;
    return this;
  }

  /**
   * Search query.
   * @return query
   */
  @javax.annotation.Nullable
  public String getQuery() {
    return query;
  }

  public void setQuery(String query) {
    this.query = query;
  }


  public MyFollowsSearchPostRequest shipsTo(String shipsTo) {
    this.shipsTo = shipsTo;
    return this;
  }

  /**
   * Limit search to items that ship to this country code
   * @return shipsTo
   */
  @javax.annotation.Nullable
  public String getShipsTo() {
    return shipsTo;
  }

  public void setShipsTo(String shipsTo) {
    this.shipsTo = shipsTo;
  }


  public MyFollowsSearchPostRequest shop(String shop) {
    this.shop = shop;
    return this;
  }

  /**
   * Slug of shop to search
   * @return shop
   */
  @javax.annotation.Nullable
  public String getShop() {
    return shop;
  }

  public void setShop(String shop) {
    this.shop = shop;
  }


  public MyFollowsSearchPostRequest shopId(String shopId) {
    this.shopId = shopId;
    return this;
  }

  /**
   * ID of shop to search
   * @return shopId
   */
  @javax.annotation.Nullable
  public String getShopId() {
    return shopId;
  }

  public void setShopId(String shopId) {
    this.shopId = shopId;
  }


  public MyFollowsSearchPostRequest watchersCountMin(Integer watchersCountMin) {
    this.watchersCountMin = watchersCountMin;
    return this;
  }

  /**
   * Minimum number of watchers (used to find popular items)
   * @return watchersCountMin
   */
  @javax.annotation.Nullable
  public Integer getWatchersCountMin() {
    return watchersCountMin;
  }

  public void setWatchersCountMin(Integer watchersCountMin) {
    this.watchersCountMin = watchersCountMin;
  }


  public MyFollowsSearchPostRequest yearMax(Integer yearMax) {
    this.yearMax = yearMax;
    return this;
  }

  /**
   * Maximum year of manufacture
   * @return yearMax
   */
  @javax.annotation.Nullable
  public Integer getYearMax() {
    return yearMax;
  }

  public void setYearMax(Integer yearMax) {
    this.yearMax = yearMax;
  }


  public MyFollowsSearchPostRequest yearMin(Integer yearMin) {
    this.yearMin = yearMin;
    return this;
  }

  /**
   * Minumum year of manufacture
   * @return yearMin
   */
  @javax.annotation.Nullable
  public Integer getYearMin() {
    return yearMin;
  }

  public void setYearMin(Integer yearMin) {
    this.yearMin = yearMin;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MyFollowsSearchPostRequest myFollowsSearchPostRequest = (MyFollowsSearchPostRequest) o;
    return Objects.equals(this.acceptsGiftCards, myFollowsSearchPostRequest.acceptsGiftCards) &&
        Objects.equals(this.acceptsPaymentPlans, myFollowsSearchPostRequest.acceptsPaymentPlans) &&
        Objects.equals(this.auctionPriceMax, myFollowsSearchPostRequest.auctionPriceMax) &&
        Objects.equals(this.category, myFollowsSearchPostRequest.category) &&
        Objects.equals(this.conditions, myFollowsSearchPostRequest.conditions) &&
        Objects.equals(this.currency, myFollowsSearchPostRequest.currency) &&
        Objects.equals(this.decade, myFollowsSearchPostRequest.decade) &&
        Objects.equals(this.excludeAuctions, myFollowsSearchPostRequest.excludeAuctions) &&
        Objects.equals(this.finish, myFollowsSearchPostRequest.finish) &&
        Objects.equals(this.handmade, myFollowsSearchPostRequest.handmade) &&
        Objects.equals(this.itemCity, myFollowsSearchPostRequest.itemCity) &&
        Objects.equals(this.itemCountry, myFollowsSearchPostRequest.itemCountry) &&
        Objects.equals(this.itemRegion, myFollowsSearchPostRequest.itemRegion) &&
        Objects.equals(this.itemState, myFollowsSearchPostRequest.itemState) &&
        Objects.equals(this.listingType, myFollowsSearchPostRequest.listingType) &&
        Objects.equals(this.localPickup, myFollowsSearchPostRequest.localPickup) &&
        Objects.equals(this.make, myFollowsSearchPostRequest.make) &&
        Objects.equals(this.model, myFollowsSearchPostRequest.model) &&
        Objects.equals(this.mustNot, myFollowsSearchPostRequest.mustNot) &&
        Objects.equals(this.notIds, myFollowsSearchPostRequest.notIds) &&
        Objects.equals(this.preferredSeller, myFollowsSearchPostRequest.preferredSeller) &&
        Objects.equals(this.priceMax, myFollowsSearchPostRequest.priceMax) &&
        Objects.equals(this.priceMin, myFollowsSearchPostRequest.priceMin) &&
        Objects.equals(this.productType, myFollowsSearchPostRequest.productType) &&
        Objects.equals(this.query, myFollowsSearchPostRequest.query) &&
        Objects.equals(this.shipsTo, myFollowsSearchPostRequest.shipsTo) &&
        Objects.equals(this.shop, myFollowsSearchPostRequest.shop) &&
        Objects.equals(this.shopId, myFollowsSearchPostRequest.shopId) &&
        Objects.equals(this.watchersCountMin, myFollowsSearchPostRequest.watchersCountMin) &&
        Objects.equals(this.yearMax, myFollowsSearchPostRequest.yearMax) &&
        Objects.equals(this.yearMin, myFollowsSearchPostRequest.yearMin);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptsGiftCards, acceptsPaymentPlans, auctionPriceMax, category, conditions, currency, decade, excludeAuctions, finish, handmade, itemCity, itemCountry, itemRegion, itemState, listingType, localPickup, make, model, mustNot, notIds, preferredSeller, priceMax, priceMin, productType, query, shipsTo, shop, shopId, watchersCountMin, yearMax, yearMin);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MyFollowsSearchPostRequest {\n");
    sb.append("    acceptsGiftCards: ").append(toIndentedString(acceptsGiftCards)).append("\n");
    sb.append("    acceptsPaymentPlans: ").append(toIndentedString(acceptsPaymentPlans)).append("\n");
    sb.append("    auctionPriceMax: ").append(toIndentedString(auctionPriceMax)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    decade: ").append(toIndentedString(decade)).append("\n");
    sb.append("    excludeAuctions: ").append(toIndentedString(excludeAuctions)).append("\n");
    sb.append("    finish: ").append(toIndentedString(finish)).append("\n");
    sb.append("    handmade: ").append(toIndentedString(handmade)).append("\n");
    sb.append("    itemCity: ").append(toIndentedString(itemCity)).append("\n");
    sb.append("    itemCountry: ").append(toIndentedString(itemCountry)).append("\n");
    sb.append("    itemRegion: ").append(toIndentedString(itemRegion)).append("\n");
    sb.append("    itemState: ").append(toIndentedString(itemState)).append("\n");
    sb.append("    listingType: ").append(toIndentedString(listingType)).append("\n");
    sb.append("    localPickup: ").append(toIndentedString(localPickup)).append("\n");
    sb.append("    make: ").append(toIndentedString(make)).append("\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    mustNot: ").append(toIndentedString(mustNot)).append("\n");
    sb.append("    notIds: ").append(toIndentedString(notIds)).append("\n");
    sb.append("    preferredSeller: ").append(toIndentedString(preferredSeller)).append("\n");
    sb.append("    priceMax: ").append(toIndentedString(priceMax)).append("\n");
    sb.append("    priceMin: ").append(toIndentedString(priceMin)).append("\n");
    sb.append("    productType: ").append(toIndentedString(productType)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    shipsTo: ").append(toIndentedString(shipsTo)).append("\n");
    sb.append("    shop: ").append(toIndentedString(shop)).append("\n");
    sb.append("    shopId: ").append(toIndentedString(shopId)).append("\n");
    sb.append("    watchersCountMin: ").append(toIndentedString(watchersCountMin)).append("\n");
    sb.append("    yearMax: ").append(toIndentedString(yearMax)).append("\n");
    sb.append("    yearMin: ").append(toIndentedString(yearMin)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accepts_gift_cards");
    openapiFields.add("accepts_payment_plans");
    openapiFields.add("auction_price_max");
    openapiFields.add("category");
    openapiFields.add("conditions");
    openapiFields.add("currency");
    openapiFields.add("decade");
    openapiFields.add("exclude_auctions");
    openapiFields.add("finish");
    openapiFields.add("handmade");
    openapiFields.add("item_city");
    openapiFields.add("item_country");
    openapiFields.add("item_region");
    openapiFields.add("item_state");
    openapiFields.add("listing_type");
    openapiFields.add("local_pickup");
    openapiFields.add("make");
    openapiFields.add("model");
    openapiFields.add("must_not");
    openapiFields.add("not_ids");
    openapiFields.add("preferred_seller");
    openapiFields.add("price_max");
    openapiFields.add("price_min");
    openapiFields.add("product_type");
    openapiFields.add("query");
    openapiFields.add("ships_to");
    openapiFields.add("shop");
    openapiFields.add("shop_id");
    openapiFields.add("watchers_count_min");
    openapiFields.add("year_max");
    openapiFields.add("year_min");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MyFollowsSearchPostRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MyFollowsSearchPostRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MyFollowsSearchPostRequest is not found in the empty JSON string", MyFollowsSearchPostRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MyFollowsSearchPostRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MyFollowsSearchPostRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull()) && !jsonObj.get("category").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be a primitive type in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("conditions") != null && !jsonObj.get("conditions").isJsonNull() && !jsonObj.get("conditions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `conditions` to be an array in the JSON string but got `%s`", jsonObj.get("conditions").toString()));
      }
      if ((jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) && !jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      // validate the optional field `currency`
      if (jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) {
        CurrencyEnum.validateJsonElement(jsonObj.get("currency"));
      }
      if ((jsonObj.get("decade") != null && !jsonObj.get("decade").isJsonNull()) && !jsonObj.get("decade").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `decade` to be a primitive type in the JSON string but got `%s`", jsonObj.get("decade").toString()));
      }
      if ((jsonObj.get("finish") != null && !jsonObj.get("finish").isJsonNull()) && !jsonObj.get("finish").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `finish` to be a primitive type in the JSON string but got `%s`", jsonObj.get("finish").toString()));
      }
      if ((jsonObj.get("item_city") != null && !jsonObj.get("item_city").isJsonNull()) && !jsonObj.get("item_city").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `item_city` to be a primitive type in the JSON string but got `%s`", jsonObj.get("item_city").toString()));
      }
      if ((jsonObj.get("item_country") != null && !jsonObj.get("item_country").isJsonNull()) && !jsonObj.get("item_country").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `item_country` to be a primitive type in the JSON string but got `%s`", jsonObj.get("item_country").toString()));
      }
      if ((jsonObj.get("item_region") != null && !jsonObj.get("item_region").isJsonNull()) && !jsonObj.get("item_region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `item_region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("item_region").toString()));
      }
      if ((jsonObj.get("item_state") != null && !jsonObj.get("item_state").isJsonNull()) && !jsonObj.get("item_state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `item_state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("item_state").toString()));
      }
      if ((jsonObj.get("listing_type") != null && !jsonObj.get("listing_type").isJsonNull()) && !jsonObj.get("listing_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `listing_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("listing_type").toString()));
      }
      // validate the optional field `listing_type`
      if (jsonObj.get("listing_type") != null && !jsonObj.get("listing_type").isJsonNull()) {
        ListingTypeEnum.validateJsonElement(jsonObj.get("listing_type"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("make") != null && !jsonObj.get("make").isJsonNull() && !jsonObj.get("make").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `make` to be an array in the JSON string but got `%s`", jsonObj.get("make").toString()));
      }
      if ((jsonObj.get("model") != null && !jsonObj.get("model").isJsonNull()) && !jsonObj.get("model").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `model` to be a primitive type in the JSON string but got `%s`", jsonObj.get("model").toString()));
      }
      if ((jsonObj.get("must_not") != null && !jsonObj.get("must_not").isJsonNull()) && !jsonObj.get("must_not").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `must_not` to be a primitive type in the JSON string but got `%s`", jsonObj.get("must_not").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("not_ids") != null && !jsonObj.get("not_ids").isJsonNull() && !jsonObj.get("not_ids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `not_ids` to be an array in the JSON string but got `%s`", jsonObj.get("not_ids").toString()));
      }
      if ((jsonObj.get("product_type") != null && !jsonObj.get("product_type").isJsonNull()) && !jsonObj.get("product_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `product_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("product_type").toString()));
      }
      if ((jsonObj.get("query") != null && !jsonObj.get("query").isJsonNull()) && !jsonObj.get("query").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `query` to be a primitive type in the JSON string but got `%s`", jsonObj.get("query").toString()));
      }
      if ((jsonObj.get("ships_to") != null && !jsonObj.get("ships_to").isJsonNull()) && !jsonObj.get("ships_to").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ships_to` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ships_to").toString()));
      }
      if ((jsonObj.get("shop") != null && !jsonObj.get("shop").isJsonNull()) && !jsonObj.get("shop").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `shop` to be a primitive type in the JSON string but got `%s`", jsonObj.get("shop").toString()));
      }
      if ((jsonObj.get("shop_id") != null && !jsonObj.get("shop_id").isJsonNull()) && !jsonObj.get("shop_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `shop_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("shop_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MyFollowsSearchPostRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MyFollowsSearchPostRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MyFollowsSearchPostRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MyFollowsSearchPostRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<MyFollowsSearchPostRequest>() {
           @Override
           public void write(JsonWriter out, MyFollowsSearchPostRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MyFollowsSearchPostRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MyFollowsSearchPostRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MyFollowsSearchPostRequest
   * @throws IOException if the JSON string is invalid with respect to MyFollowsSearchPostRequest
   */
  public static MyFollowsSearchPostRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MyFollowsSearchPostRequest.class);
  }

  /**
   * Convert an instance of MyFollowsSearchPostRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

