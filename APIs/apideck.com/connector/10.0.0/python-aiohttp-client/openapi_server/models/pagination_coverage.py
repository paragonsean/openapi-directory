# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class PaginationCoverage(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, limit_support: bool=None, mode: str=None, paging_support: bool=None):
        """PaginationCoverage - a model defined in OpenAPI

        :param limit_support: The limit_support of this PaginationCoverage.
        :param mode: The mode of this PaginationCoverage.
        :param paging_support: The paging_support of this PaginationCoverage.
        """
        self.openapi_types = {
            'limit_support': bool,
            'mode': str,
            'paging_support': bool
        }

        self.attribute_map = {
            'limit_support': 'limit_support',
            'mode': 'mode',
            'paging_support': 'paging_support'
        }

        self._limit_support = limit_support
        self._mode = mode
        self._paging_support = paging_support

    @classmethod
    def from_dict(cls, dikt: dict) -> 'PaginationCoverage':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The PaginationCoverage of this PaginationCoverage.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def limit_support(self):
        """Gets the limit_support of this PaginationCoverage.

        Indicates whether the connector supports changing the page size by using the limit parameter.

        :return: The limit_support of this PaginationCoverage.
        :rtype: bool
        """
        return self._limit_support

    @limit_support.setter
    def limit_support(self, limit_support):
        """Sets the limit_support of this PaginationCoverage.

        Indicates whether the connector supports changing the page size by using the limit parameter.

        :param limit_support: The limit_support of this PaginationCoverage.
        :type limit_support: bool
        """

        self._limit_support = limit_support

    @property
    def mode(self):
        """Gets the mode of this PaginationCoverage.

        How pagination is implemented on this connector. Native mode means Apideck is using the pagination parameters of the connector. With virtual pagination, the connector does not support pagination, but Apideck emulates it.

        :return: The mode of this PaginationCoverage.
        :rtype: str
        """
        return self._mode

    @mode.setter
    def mode(self, mode):
        """Sets the mode of this PaginationCoverage.

        How pagination is implemented on this connector. Native mode means Apideck is using the pagination parameters of the connector. With virtual pagination, the connector does not support pagination, but Apideck emulates it.

        :param mode: The mode of this PaginationCoverage.
        :type mode: str
        """
        allowed_values = ["native", "virtual"]  # noqa: E501
        if mode not in allowed_values:
            raise ValueError(
                "Invalid value for `mode` ({0}), must be one of {1}"
                .format(mode, allowed_values)
            )

        self._mode = mode

    @property
    def paging_support(self):
        """Gets the paging_support of this PaginationCoverage.

        Indicates whether the connector supports paging through results using the cursor parameter.

        :return: The paging_support of this PaginationCoverage.
        :rtype: bool
        """
        return self._paging_support

    @paging_support.setter
    def paging_support(self, paging_support):
        """Sets the paging_support of this PaginationCoverage.

        Indicates whether the connector supports paging through results using the cursor parameter.

        :param paging_support: The paging_support of this PaginationCoverage.
        :type paging_support: bool
        """

        self._paging_support = paging_support
