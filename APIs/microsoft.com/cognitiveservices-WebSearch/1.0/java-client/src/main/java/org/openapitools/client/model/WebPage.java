/*
 * Web Search Client
 * The Web Search API lets you send a search query to Bing and get back search results that include links to webpages, images, and more.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CreativeWork;
import org.openapitools.client.model.ImageObject;
import org.openapitools.client.model.Thing;
import org.openapitools.client.model.WebMetaTag;
import org.openapitools.client.model.WebPage;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines a webpage that is relevant to the query.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:10:34.600618-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class WebPage extends CreativeWork {
  public static final String SERIALIZED_NAME_DATE_LAST_CRAWLED = "dateLastCrawled";
  @SerializedName(SERIALIZED_NAME_DATE_LAST_CRAWLED)
  private String dateLastCrawled;

  public static final String SERIALIZED_NAME_DEEP_LINKS = "deepLinks";
  @SerializedName(SERIALIZED_NAME_DEEP_LINKS)
  private List<WebPage> deepLinks = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISPLAY_URL = "displayUrl";
  @SerializedName(SERIALIZED_NAME_DISPLAY_URL)
  private String displayUrl;

  public static final String SERIALIZED_NAME_PRIMARY_IMAGE_OF_PAGE = "primaryImageOfPage";
  @SerializedName(SERIALIZED_NAME_PRIMARY_IMAGE_OF_PAGE)
  private ImageObject primaryImageOfPage;

  public static final String SERIALIZED_NAME_SEARCH_TAGS = "searchTags";
  @SerializedName(SERIALIZED_NAME_SEARCH_TAGS)
  private List<WebMetaTag> searchTags = new ArrayList<>();

  public static final String SERIALIZED_NAME_SNIPPET = "snippet";
  @SerializedName(SERIALIZED_NAME_SNIPPET)
  private String snippet;

  public WebPage() {
    this.type = this.getClass().getSimpleName();
  }

  public WebPage(
     String dateLastCrawled, 
     List<WebPage> deepLinks, 
     String displayUrl, 
     List<WebMetaTag> searchTags, 
     String snippet, 
     List<Thing> provider, 
     String text, 
     String thumbnailUrl, 
     String bingId, 
     String description, 
     String name, 
     String url, 
     String webSearchUrl, 
     String id
  ) {
    this();
    this.dateLastCrawled = dateLastCrawled;
    this.deepLinks = deepLinks;
    this.displayUrl = displayUrl;
    this.searchTags = searchTags;
    this.snippet = snippet;
    this.provider = provider;
    this.text = text;
    this.thumbnailUrl = thumbnailUrl;
    this.bingId = bingId;
    this.description = description;
    this.name = name;
    this.url = url;
    this.webSearchUrl = webSearchUrl;
    this.id = id;
  }

  /**
   * The last time that Bing crawled the webpage. The date is in the form, YYYY-MM-DDTHH:MM:SS. For example, 2015-04-13T05:23:39.
   * @return dateLastCrawled
   */
  @javax.annotation.Nullable
  public String getDateLastCrawled() {
    return dateLastCrawled;
  }



  /**
   * A list of links to related content that Bing found in the website that contains this webpage. The Webpage object in this context includes only the name, url, urlPingSuffix, and snippet fields.
   * @return deepLinks
   */
  @javax.annotation.Nullable
  public List<WebPage> getDeepLinks() {
    return deepLinks;
  }



  /**
   * The display URL of the webpage. The URL is meant for display purposes only and is not well formed.
   * @return displayUrl
   */
  @javax.annotation.Nullable
  public String getDisplayUrl() {
    return displayUrl;
  }



  public WebPage primaryImageOfPage(ImageObject primaryImageOfPage) {
    this.primaryImageOfPage = primaryImageOfPage;
    return this;
  }

  /**
   * Get primaryImageOfPage
   * @return primaryImageOfPage
   */
  @javax.annotation.Nullable
  public ImageObject getPrimaryImageOfPage() {
    return primaryImageOfPage;
  }

  public void setPrimaryImageOfPage(ImageObject primaryImageOfPage) {
    this.primaryImageOfPage = primaryImageOfPage;
  }


  /**
   * A list of search tags that the webpage owner specified on the webpage. The API returns only indexed search tags. The name field of the MetaTag object contains the indexed search tag. Search tags begin with search.* (for example, search.assetId). The content field contains the tag&#39;s value.
   * @return searchTags
   */
  @javax.annotation.Nullable
  public List<WebMetaTag> getSearchTags() {
    return searchTags;
  }



  /**
   * A snippet of text from the webpage that describes its contents.
   * @return snippet
   */
  @javax.annotation.Nullable
  public String getSnippet() {
    return snippet;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WebPage webPage = (WebPage) o;
    return Objects.equals(this.dateLastCrawled, webPage.dateLastCrawled) &&
        Objects.equals(this.deepLinks, webPage.deepLinks) &&
        Objects.equals(this.displayUrl, webPage.displayUrl) &&
        Objects.equals(this.primaryImageOfPage, webPage.primaryImageOfPage) &&
        Objects.equals(this.searchTags, webPage.searchTags) &&
        Objects.equals(this.snippet, webPage.snippet) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dateLastCrawled, deepLinks, displayUrl, primaryImageOfPage, searchTags, snippet, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WebPage {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    dateLastCrawled: ").append(toIndentedString(dateLastCrawled)).append("\n");
    sb.append("    deepLinks: ").append(toIndentedString(deepLinks)).append("\n");
    sb.append("    displayUrl: ").append(toIndentedString(displayUrl)).append("\n");
    sb.append("    primaryImageOfPage: ").append(toIndentedString(primaryImageOfPage)).append("\n");
    sb.append("    searchTags: ").append(toIndentedString(searchTags)).append("\n");
    sb.append("    snippet: ").append(toIndentedString(snippet)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("provider");
    openapiFields.add("text");
    openapiFields.add("thumbnailUrl");
    openapiFields.add("bingId");
    openapiFields.add("description");
    openapiFields.add("image");
    openapiFields.add("name");
    openapiFields.add("url");
    openapiFields.add("webSearchUrl");
    openapiFields.add("id");
    openapiFields.add("_type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("_type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to WebPage
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WebPage.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WebPage is not found in the empty JSON string", WebPage.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WebPage.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WebPage` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : WebPage.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WebPage.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WebPage' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WebPage> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WebPage.class));

       return (TypeAdapter<T>) new TypeAdapter<WebPage>() {
           @Override
           public void write(JsonWriter out, WebPage value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WebPage read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of WebPage given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of WebPage
   * @throws IOException if the JSON string is invalid with respect to WebPage
   */
  public static WebPage fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WebPage.class);
  }

  /**
   * Convert an instance of WebPage to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

