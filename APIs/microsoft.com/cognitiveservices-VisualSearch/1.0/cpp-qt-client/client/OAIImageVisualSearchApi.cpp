/**
 * Visual Search Client
 * Visual Search API lets you discover insights about an image such as visually similar images, shopping sources, and related searches. The API can also perform text recognition, identify entities (people, places, things), return other topical content for the user to explore, and more. For more information, see [Visual Search Overview](https://docs.microsoft.com/azure/cognitive-services/bing-visual-search/overview).  **NOTE:** To comply with the new EU Copyright Directive in France, the Bing Visual Search API must omit some content from certain EU News sources for French users. The removed content may include thumbnail images and videos, video previews, and snippets which accompany search results from these sources. As a consequence, the Bing APIs may serve fewer results with thumbnail images and videos, video previews, and snippets to French users.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIImageVisualSearchApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIImageVisualSearchApi::OAIImageVisualSearchApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIImageVisualSearchApi::~OAIImageVisualSearchApi() {
}

void OAIImageVisualSearchApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.cognitive.microsoft.com/bing/v7.0"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("imagesVisualSearch", defaultConf);
    _serverIndices.insert("imagesVisualSearch", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIImageVisualSearchApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIImageVisualSearchApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIImageVisualSearchApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIImageVisualSearchApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIImageVisualSearchApi::setUsername(const QString &username) {
    _username = username;
}

void OAIImageVisualSearchApi::setPassword(const QString &password) {
    _password = password;
}


void OAIImageVisualSearchApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIImageVisualSearchApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIImageVisualSearchApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIImageVisualSearchApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIImageVisualSearchApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIImageVisualSearchApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIImageVisualSearchApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIImageVisualSearchApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIImageVisualSearchApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIImageVisualSearchApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIImageVisualSearchApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIImageVisualSearchApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIImageVisualSearchApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIImageVisualSearchApi::imagesVisualSearch(const QString &x_bing_apis_sdk, const ::OpenAPI::OptionalParam<QString> &accept, const ::OpenAPI::OptionalParam<QString> &accept_language, const ::OpenAPI::OptionalParam<QString> &content_type, const ::OpenAPI::OptionalParam<QString> &user_agent, const ::OpenAPI::OptionalParam<QString> &x_ms_edge_client_id, const ::OpenAPI::OptionalParam<QString> &x_ms_edge_client_ip, const ::OpenAPI::OptionalParam<QString> &x_search_location, const ::OpenAPI::OptionalParam<QString> &mkt, const ::OpenAPI::OptionalParam<QString> &safe_search, const ::OpenAPI::OptionalParam<QString> &set_lang, const ::OpenAPI::OptionalParam<QString> &knowledge_request, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &image) {
    QString fullPath = QString(_serverConfigs["imagesVisualSearch"][_serverIndices.value("imagesVisualSearch")].URL()+"/images/visualsearch");
    
    if (_apiKeys.contains("apiKeyHeader")) {
        addHeaders("apiKeyHeader",_apiKeys.find("apiKeyHeader").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (mkt.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "mkt", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("mkt")).append(querySuffix).append(QUrl::toPercentEncoding(mkt.stringValue()));
    }
    if (safe_search.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "safeSearch", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("safeSearch")).append(querySuffix).append(QUrl::toPercentEncoding(safe_search.stringValue()));
    }
    if (set_lang.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "setLang", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("setLang")).append(querySuffix).append(QUrl::toPercentEncoding(set_lang.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (knowledge_request.hasValue())
    {
        input.add_var("knowledgeRequest", ::OpenAPI::toStringValue(knowledge_request.value()));
    }
    if (image.hasValue())
    {
        input.add_file("image", image.value().local_filename, image.value().request_filename, image.value().mime_type);
    }

    
    {
        if (!::OpenAPI::toStringValue(x_bing_apis_sdk).isEmpty()) {
            input.headers.insert("X-BingApis-SDK", ::OpenAPI::toStringValue(x_bing_apis_sdk));
        }
        }
    if (accept.hasValue())
    {
        if (!::OpenAPI::toStringValue(accept.value()).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept.value()));
        }
        }
    if (accept_language.hasValue())
    {
        if (!::OpenAPI::toStringValue(accept_language.value()).isEmpty()) {
            input.headers.insert("Accept-Language", ::OpenAPI::toStringValue(accept_language.value()));
        }
        }
    if (content_type.hasValue())
    {
        if (!::OpenAPI::toStringValue(content_type.value()).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type.value()));
        }
        }
    if (user_agent.hasValue())
    {
        if (!::OpenAPI::toStringValue(user_agent.value()).isEmpty()) {
            input.headers.insert("User-Agent", ::OpenAPI::toStringValue(user_agent.value()));
        }
        }
    if (x_ms_edge_client_id.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_ms_edge_client_id.value()).isEmpty()) {
            input.headers.insert("X-MSEdge-ClientID", ::OpenAPI::toStringValue(x_ms_edge_client_id.value()));
        }
        }
    if (x_ms_edge_client_ip.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_ms_edge_client_ip.value()).isEmpty()) {
            input.headers.insert("X-MSEdge-ClientIP", ::OpenAPI::toStringValue(x_ms_edge_client_ip.value()));
        }
        }
    if (x_search_location.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_search_location.value()).isEmpty()) {
            input.headers.insert("X-Search-Location", ::OpenAPI::toStringValue(x_search_location.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImageVisualSearchApi::imagesVisualSearchCallback);
    connect(this, &OAIImageVisualSearchApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImageVisualSearchApi::imagesVisualSearchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIImageKnowledge output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT imagesVisualSearchSignal(output);
        Q_EMIT imagesVisualSearchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT imagesVisualSearchSignalE(output, error_type, error_str);
        Q_EMIT imagesVisualSearchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT imagesVisualSearchSignalError(output, error_type, error_str);
        Q_EMIT imagesVisualSearchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImageVisualSearchApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
