# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.contractual_rules_attribution import ContractualRulesAttribution
from openapi_server import util


class ContractualRulesTextAttribution(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, optional_for_list_display: bool=None, text: str=None, must_be_close_to_content: bool=None, type: str=None, target_property_name: str=None):
        """ContractualRulesTextAttribution - a model defined in OpenAPI

        :param optional_for_list_display: The optional_for_list_display of this ContractualRulesTextAttribution.
        :param text: The text of this ContractualRulesTextAttribution.
        :param must_be_close_to_content: The must_be_close_to_content of this ContractualRulesTextAttribution.
        :param type: The type of this ContractualRulesTextAttribution.
        :param target_property_name: The target_property_name of this ContractualRulesTextAttribution.
        """
        self.openapi_types = {
            'optional_for_list_display': bool,
            'text': str,
            'must_be_close_to_content': bool,
            'type': str,
            'target_property_name': str
        }

        self.attribute_map = {
            'optional_for_list_display': 'optionalForListDisplay',
            'text': 'text',
            'must_be_close_to_content': 'mustBeCloseToContent',
            'type': '_type',
            'target_property_name': 'targetPropertyName'
        }

        self._optional_for_list_display = optional_for_list_display
        self._text = text
        self._must_be_close_to_content = must_be_close_to_content
        self._type = type
        self._target_property_name = target_property_name

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ContractualRulesTextAttribution':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ContractualRulesTextAttribution of this ContractualRulesTextAttribution.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def optional_for_list_display(self):
        """Gets the optional_for_list_display of this ContractualRulesTextAttribution.

        Indicates whether this provider's attribution is optional.

        :return: The optional_for_list_display of this ContractualRulesTextAttribution.
        :rtype: bool
        """
        return self._optional_for_list_display

    @optional_for_list_display.setter
    def optional_for_list_display(self, optional_for_list_display):
        """Sets the optional_for_list_display of this ContractualRulesTextAttribution.

        Indicates whether this provider's attribution is optional.

        :param optional_for_list_display: The optional_for_list_display of this ContractualRulesTextAttribution.
        :type optional_for_list_display: bool
        """

        self._optional_for_list_display = optional_for_list_display

    @property
    def text(self):
        """Gets the text of this ContractualRulesTextAttribution.

        The attribution text. Text attribution applies to the entity as a whole and should be displayed immediately following the entity presentation. If there are multiple text or link attribution rules that do not specify a target, you should concatenate them and display them using a \"Data from:\" label.

        :return: The text of this ContractualRulesTextAttribution.
        :rtype: str
        """
        return self._text

    @text.setter
    def text(self, text):
        """Sets the text of this ContractualRulesTextAttribution.

        The attribution text. Text attribution applies to the entity as a whole and should be displayed immediately following the entity presentation. If there are multiple text or link attribution rules that do not specify a target, you should concatenate them and display them using a \"Data from:\" label.

        :param text: The text of this ContractualRulesTextAttribution.
        :type text: str
        """
        if text is None:
            raise ValueError("Invalid value for `text`, must not be `None`")

        self._text = text

    @property
    def must_be_close_to_content(self):
        """Gets the must_be_close_to_content of this ContractualRulesTextAttribution.

        A Boolean value that determines whether the contents of the rule must be placed in close proximity to the field that the rule applies to. If true, the contents must be placed in close proximity. If false, or this field does not exist, the contents may be placed at the caller's discretion.

        :return: The must_be_close_to_content of this ContractualRulesTextAttribution.
        :rtype: bool
        """
        return self._must_be_close_to_content

    @must_be_close_to_content.setter
    def must_be_close_to_content(self, must_be_close_to_content):
        """Sets the must_be_close_to_content of this ContractualRulesTextAttribution.

        A Boolean value that determines whether the contents of the rule must be placed in close proximity to the field that the rule applies to. If true, the contents must be placed in close proximity. If false, or this field does not exist, the contents may be placed at the caller's discretion.

        :param must_be_close_to_content: The must_be_close_to_content of this ContractualRulesTextAttribution.
        :type must_be_close_to_content: bool
        """

        self._must_be_close_to_content = must_be_close_to_content

    @property
    def type(self):
        """Gets the type of this ContractualRulesTextAttribution.


        :return: The type of this ContractualRulesTextAttribution.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this ContractualRulesTextAttribution.


        :param type: The type of this ContractualRulesTextAttribution.
        :type type: str
        """
        if type is None:
            raise ValueError("Invalid value for `type`, must not be `None`")

        self._type = type

    @property
    def target_property_name(self):
        """Gets the target_property_name of this ContractualRulesTextAttribution.

        The name of the field that the rule applies to.

        :return: The target_property_name of this ContractualRulesTextAttribution.
        :rtype: str
        """
        return self._target_property_name

    @target_property_name.setter
    def target_property_name(self, target_property_name):
        """Sets the target_property_name of this ContractualRulesTextAttribution.

        The name of the field that the rule applies to.

        :param target_property_name: The target_property_name of this ContractualRulesTextAttribution.
        :type target_property_name: str
        """

        self._target_property_name = target_property_name
