/*
 * Video Search Client
 * The Video Search API lets you search on Bing for video that are relevant to the user's search query, for insights about a video or for videos that are trending based on search requests made by others. This section provides technical details about the query parameters and headers that you use to request videos and the JSON response objects that contain them. For examples that show how to make requests, see [Searching the Web for Videos](https://docs.microsoft.com/azure/cognitive-services/bing-video-search/search-the-web).
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines the query context that Bing used for the request.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:10:48.256609-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class QueryContext {
  public static final String SERIALIZED_NAME_ADULT_INTENT = "adultIntent";
  @SerializedName(SERIALIZED_NAME_ADULT_INTENT)
  private Boolean adultIntent;

  public static final String SERIALIZED_NAME_ALTERATION_OVERRIDE_QUERY = "alterationOverrideQuery";
  @SerializedName(SERIALIZED_NAME_ALTERATION_OVERRIDE_QUERY)
  private String alterationOverrideQuery;

  public static final String SERIALIZED_NAME_ALTERED_QUERY = "alteredQuery";
  @SerializedName(SERIALIZED_NAME_ALTERED_QUERY)
  private String alteredQuery;

  public static final String SERIALIZED_NAME_ASK_USER_FOR_LOCATION = "askUserForLocation";
  @SerializedName(SERIALIZED_NAME_ASK_USER_FOR_LOCATION)
  private Boolean askUserForLocation;

  public static final String SERIALIZED_NAME_IS_TRANSACTIONAL = "isTransactional";
  @SerializedName(SERIALIZED_NAME_IS_TRANSACTIONAL)
  private Boolean isTransactional;

  public static final String SERIALIZED_NAME_ORIGINAL_QUERY = "originalQuery";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_QUERY)
  private String originalQuery;

  public QueryContext() {
  }

  public QueryContext(
     Boolean adultIntent, 
     String alterationOverrideQuery, 
     String alteredQuery, 
     Boolean askUserForLocation, 
     Boolean isTransactional
  ) {
    this();
    this.adultIntent = adultIntent;
    this.alterationOverrideQuery = alterationOverrideQuery;
    this.alteredQuery = alteredQuery;
    this.askUserForLocation = askUserForLocation;
    this.isTransactional = isTransactional;
  }

  /**
   * A Boolean value that indicates whether the specified query has adult intent. The value is true if the query has adult intent; otherwise, false.
   * @return adultIntent
   */
  @javax.annotation.Nullable
  public Boolean getAdultIntent() {
    return adultIntent;
  }



  /**
   * The query string to use to force Bing to use the original string. For example, if the query string is \&quot;saling downwind\&quot;, the override query string will be \&quot;+saling downwind\&quot;. Remember to encode the query string which results in \&quot;%2Bsaling+downwind\&quot;. This field is included only if the original query string contains a spelling mistake.
   * @return alterationOverrideQuery
   */
  @javax.annotation.Nullable
  public String getAlterationOverrideQuery() {
    return alterationOverrideQuery;
  }



  /**
   * The query string used by Bing to perform the query. Bing uses the altered query string if the original query string contained spelling mistakes. For example, if the query string is \&quot;saling downwind\&quot;, the altered query string will be \&quot;sailing downwind\&quot;. This field is included only if the original query string contains a spelling mistake.
   * @return alteredQuery
   */
  @javax.annotation.Nullable
  public String getAlteredQuery() {
    return alteredQuery;
  }



  /**
   * A Boolean value that indicates whether Bing requires the user&#39;s location to provide accurate results. If you specified the user&#39;s location by using the X-MSEdge-ClientIP and X-Search-Location headers, you can ignore this field. For location aware queries, such as \&quot;today&#39;s weather\&quot; or \&quot;restaurants near me\&quot; that need the user&#39;s location to provide accurate results, this field is set to true. For location aware queries that include the location (for example, \&quot;Seattle weather\&quot;), this field is set to false. This field is also set to false for queries that are not location aware, such as \&quot;best sellers\&quot;.
   * @return askUserForLocation
   */
  @javax.annotation.Nullable
  public Boolean getAskUserForLocation() {
    return askUserForLocation;
  }



  /**
   * Get isTransactional
   * @return isTransactional
   */
  @javax.annotation.Nullable
  public Boolean getIsTransactional() {
    return isTransactional;
  }



  public QueryContext originalQuery(String originalQuery) {
    this.originalQuery = originalQuery;
    return this;
  }

  /**
   * The query string as specified in the request.
   * @return originalQuery
   */
  @javax.annotation.Nonnull
  public String getOriginalQuery() {
    return originalQuery;
  }

  public void setOriginalQuery(String originalQuery) {
    this.originalQuery = originalQuery;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    QueryContext queryContext = (QueryContext) o;
    return Objects.equals(this.adultIntent, queryContext.adultIntent) &&
        Objects.equals(this.alterationOverrideQuery, queryContext.alterationOverrideQuery) &&
        Objects.equals(this.alteredQuery, queryContext.alteredQuery) &&
        Objects.equals(this.askUserForLocation, queryContext.askUserForLocation) &&
        Objects.equals(this.isTransactional, queryContext.isTransactional) &&
        Objects.equals(this.originalQuery, queryContext.originalQuery);
  }

  @Override
  public int hashCode() {
    return Objects.hash(adultIntent, alterationOverrideQuery, alteredQuery, askUserForLocation, isTransactional, originalQuery);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class QueryContext {\n");
    sb.append("    adultIntent: ").append(toIndentedString(adultIntent)).append("\n");
    sb.append("    alterationOverrideQuery: ").append(toIndentedString(alterationOverrideQuery)).append("\n");
    sb.append("    alteredQuery: ").append(toIndentedString(alteredQuery)).append("\n");
    sb.append("    askUserForLocation: ").append(toIndentedString(askUserForLocation)).append("\n");
    sb.append("    isTransactional: ").append(toIndentedString(isTransactional)).append("\n");
    sb.append("    originalQuery: ").append(toIndentedString(originalQuery)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("adultIntent");
    openapiFields.add("alterationOverrideQuery");
    openapiFields.add("alteredQuery");
    openapiFields.add("askUserForLocation");
    openapiFields.add("isTransactional");
    openapiFields.add("originalQuery");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("originalQuery");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to QueryContext
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!QueryContext.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in QueryContext is not found in the empty JSON string", QueryContext.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!QueryContext.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `QueryContext` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : QueryContext.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("alterationOverrideQuery") != null && !jsonObj.get("alterationOverrideQuery").isJsonNull()) && !jsonObj.get("alterationOverrideQuery").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alterationOverrideQuery` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alterationOverrideQuery").toString()));
      }
      if ((jsonObj.get("alteredQuery") != null && !jsonObj.get("alteredQuery").isJsonNull()) && !jsonObj.get("alteredQuery").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alteredQuery` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alteredQuery").toString()));
      }
      if (!jsonObj.get("originalQuery").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originalQuery` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originalQuery").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!QueryContext.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'QueryContext' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<QueryContext> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(QueryContext.class));

       return (TypeAdapter<T>) new TypeAdapter<QueryContext>() {
           @Override
           public void write(JsonWriter out, QueryContext value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public QueryContext read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of QueryContext given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of QueryContext
   * @throws IOException if the JSON string is invalid with respect to QueryContext
   */
  public static QueryContext fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, QueryContext.class);
  }

  /**
   * Convert an instance of QueryContext to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

