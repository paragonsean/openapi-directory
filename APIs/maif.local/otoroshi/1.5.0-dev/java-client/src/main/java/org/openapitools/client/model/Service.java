/*
 * Otoroshi Admin API
 * Admin API of the Otoroshi reverse proxy
 *
 * The version of the OpenAPI document: 1.5.0-dev
 * Contact: oss@maif.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.openapitools.client.model.Canary;
import org.openapitools.client.model.ChaosConfig;
import org.openapitools.client.model.ClientConfig;
import org.openapitools.client.model.CorsSettings;
import org.openapitools.client.model.ExposedApi;
import org.openapitools.client.model.GlobalJwtVerifierAlgoSettings;
import org.openapitools.client.model.Gzip;
import org.openapitools.client.model.HealthCheck;
import org.openapitools.client.model.ImportExportServiceDescriptorsInnerJwtVerifier;
import org.openapitools.client.model.IpFiltering;
import org.openapitools.client.model.RedirectionSettings;
import org.openapitools.client.model.StatsdConfig;
import org.openapitools.client.model.Target;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:11:27.562730-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Service {
  public static final String SERIALIZED_NAME_CANARY = "Canary";
  @SerializedName(SERIALIZED_NAME_CANARY)
  private Canary canary;

  public static final String SERIALIZED_NAME_ADDITIONAL_HEADERS = "additionalHeaders";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_HEADERS)
  private Map<String, String> additionalHeaders = new HashMap<>();

  public static final String SERIALIZED_NAME_API = "api";
  @SerializedName(SERIALIZED_NAME_API)
  private ExposedApi api;

  public static final String SERIALIZED_NAME_AUTH_CONFIG_REF = "authConfigRef";
  @SerializedName(SERIALIZED_NAME_AUTH_CONFIG_REF)
  private String authConfigRef;

  public static final String SERIALIZED_NAME_BUILD_MODE = "buildMode";
  @SerializedName(SERIALIZED_NAME_BUILD_MODE)
  private Boolean buildMode;

  public static final String SERIALIZED_NAME_CHAOS_CONFIG = "chaosConfig";
  @SerializedName(SERIALIZED_NAME_CHAOS_CONFIG)
  private ChaosConfig chaosConfig;

  public static final String SERIALIZED_NAME_CLIENT_CONFIG = "clientConfig";
  @SerializedName(SERIALIZED_NAME_CLIENT_CONFIG)
  private ClientConfig clientConfig;

  public static final String SERIALIZED_NAME_CLIENT_VALIDATOR_REF = "clientValidatorRef";
  @SerializedName(SERIALIZED_NAME_CLIENT_VALIDATOR_REF)
  private String clientValidatorRef;

  public static final String SERIALIZED_NAME_CORS = "cors";
  @SerializedName(SERIALIZED_NAME_CORS)
  private CorsSettings cors;

  public static final String SERIALIZED_NAME_DOMAIN = "domain";
  @SerializedName(SERIALIZED_NAME_DOMAIN)
  private String domain;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_ENFORCE_SECURE_COMMUNICATION = "enforceSecureCommunication";
  @SerializedName(SERIALIZED_NAME_ENFORCE_SECURE_COMMUNICATION)
  private Boolean enforceSecureCommunication;

  public static final String SERIALIZED_NAME_ENV = "env";
  @SerializedName(SERIALIZED_NAME_ENV)
  private String env;

  public static final String SERIALIZED_NAME_FORCE_HTTPS = "forceHttps";
  @SerializedName(SERIALIZED_NAME_FORCE_HTTPS)
  private Boolean forceHttps;

  public static final String SERIALIZED_NAME_GROUPS = "groups";
  @SerializedName(SERIALIZED_NAME_GROUPS)
  private List<String> groups = new ArrayList<>();

  public static final String SERIALIZED_NAME_GZIP = "gzip";
  @SerializedName(SERIALIZED_NAME_GZIP)
  private Gzip gzip;

  public static final String SERIALIZED_NAME_HEADERS_VERIFICATION = "headersVerification";
  @SerializedName(SERIALIZED_NAME_HEADERS_VERIFICATION)
  private Map<String, String> headersVerification = new HashMap<>();

  public static final String SERIALIZED_NAME_HEALTH_CHECK = "healthCheck";
  @SerializedName(SERIALIZED_NAME_HEALTH_CHECK)
  private HealthCheck healthCheck;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public static final String SERIALIZED_NAME_IP_FILTERING = "ipFiltering";
  @SerializedName(SERIALIZED_NAME_IP_FILTERING)
  private IpFiltering ipFiltering;

  public static final String SERIALIZED_NAME_JWT_VERIFIER = "jwtVerifier";
  @SerializedName(SERIALIZED_NAME_JWT_VERIFIER)
  private ImportExportServiceDescriptorsInnerJwtVerifier jwtVerifier;

  public static final String SERIALIZED_NAME_LOCAL_HOST = "localHost";
  @SerializedName(SERIALIZED_NAME_LOCAL_HOST)
  private String localHost;

  public static final String SERIALIZED_NAME_LOCAL_SCHEME = "localScheme";
  @SerializedName(SERIALIZED_NAME_LOCAL_SCHEME)
  private String localScheme;

  public static final String SERIALIZED_NAME_MAINTENANCE_MODE = "maintenanceMode";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_MODE)
  private Boolean maintenanceMode;

  public static final String SERIALIZED_NAME_MATCHING_HEADERS = "matchingHeaders";
  @SerializedName(SERIALIZED_NAME_MATCHING_HEADERS)
  private Map<String, String> matchingHeaders = new HashMap<>();

  public static final String SERIALIZED_NAME_MATCHING_ROOT = "matchingRoot";
  @SerializedName(SERIALIZED_NAME_MATCHING_ROOT)
  private String matchingRoot;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OVERRIDE_HOST = "overrideHost";
  @SerializedName(SERIALIZED_NAME_OVERRIDE_HOST)
  private Boolean overrideHost;

  public static final String SERIALIZED_NAME_PRIVATE_APP = "privateApp";
  @SerializedName(SERIALIZED_NAME_PRIVATE_APP)
  private Boolean privateApp;

  public static final String SERIALIZED_NAME_PRIVATE_PATTERNS = "privatePatterns";
  @SerializedName(SERIALIZED_NAME_PRIVATE_PATTERNS)
  private List<String> privatePatterns = new ArrayList<>();

  public static final String SERIALIZED_NAME_PUBLIC_PATTERNS = "publicPatterns";
  @SerializedName(SERIALIZED_NAME_PUBLIC_PATTERNS)
  private List<String> publicPatterns = new ArrayList<>();

  public static final String SERIALIZED_NAME_REDIRECT_TO_LOCAL = "redirectToLocal";
  @SerializedName(SERIALIZED_NAME_REDIRECT_TO_LOCAL)
  private Boolean redirectToLocal;

  public static final String SERIALIZED_NAME_REDIRECTION = "redirection";
  @SerializedName(SERIALIZED_NAME_REDIRECTION)
  private RedirectionSettings redirection;

  public static final String SERIALIZED_NAME_ROOT = "root";
  @SerializedName(SERIALIZED_NAME_ROOT)
  private String root;

  public static final String SERIALIZED_NAME_SEC_COM_EXCLUDED_PATTERNS = "secComExcludedPatterns";
  @SerializedName(SERIALIZED_NAME_SEC_COM_EXCLUDED_PATTERNS)
  private List<String> secComExcludedPatterns = new ArrayList<>();

  public static final String SERIALIZED_NAME_SEC_COM_SETTINGS = "secComSettings";
  @SerializedName(SERIALIZED_NAME_SEC_COM_SETTINGS)
  private GlobalJwtVerifierAlgoSettings secComSettings;

  public static final String SERIALIZED_NAME_SEND_OTOROSHI_HEADERS_BACK = "sendOtoroshiHeadersBack";
  @SerializedName(SERIALIZED_NAME_SEND_OTOROSHI_HEADERS_BACK)
  private Boolean sendOtoroshiHeadersBack;

  public static final String SERIALIZED_NAME_STATSD_CONFIG = "statsdConfig";
  @SerializedName(SERIALIZED_NAME_STATSD_CONFIG)
  private StatsdConfig statsdConfig;

  public static final String SERIALIZED_NAME_SUBDOMAIN = "subdomain";
  @SerializedName(SERIALIZED_NAME_SUBDOMAIN)
  private String subdomain;

  public static final String SERIALIZED_NAME_TARGETS = "targets";
  @SerializedName(SERIALIZED_NAME_TARGETS)
  private List<Target> targets = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRANSFORMER_REF = "transformerRef";
  @SerializedName(SERIALIZED_NAME_TRANSFORMER_REF)
  private String transformerRef;

  public static final String SERIALIZED_NAME_USER_FACING = "userFacing";
  @SerializedName(SERIALIZED_NAME_USER_FACING)
  private Boolean userFacing;

  public static final String SERIALIZED_NAME_X_FORWARDED_HEADERS = "xForwardedHeaders";
  @SerializedName(SERIALIZED_NAME_X_FORWARDED_HEADERS)
  private Boolean xForwardedHeaders;

  public Service() {
  }

  public Service canary(Canary canary) {
    this.canary = canary;
    return this;
  }

  /**
   * Get canary
   * @return canary
   */
  @javax.annotation.Nullable
  public Canary getCanary() {
    return canary;
  }

  public void setCanary(Canary canary) {
    this.canary = canary;
  }


  public Service additionalHeaders(Map<String, String> additionalHeaders) {
    this.additionalHeaders = additionalHeaders;
    return this;
  }

  public Service putAdditionalHeadersItem(String key, String additionalHeadersItem) {
    if (this.additionalHeaders == null) {
      this.additionalHeaders = new HashMap<>();
    }
    this.additionalHeaders.put(key, additionalHeadersItem);
    return this;
  }

  /**
   * Specify headers that will be added to each client request. Useful to add authentication
   * @return additionalHeaders
   */
  @javax.annotation.Nullable
  public Map<String, String> getAdditionalHeaders() {
    return additionalHeaders;
  }

  public void setAdditionalHeaders(Map<String, String> additionalHeaders) {
    this.additionalHeaders = additionalHeaders;
  }


  public Service api(ExposedApi api) {
    this.api = api;
    return this;
  }

  /**
   * Get api
   * @return api
   */
  @javax.annotation.Nullable
  public ExposedApi getApi() {
    return api;
  }

  public void setApi(ExposedApi api) {
    this.api = api;
  }


  public Service authConfigRef(String authConfigRef) {
    this.authConfigRef = authConfigRef;
    return this;
  }

  /**
   * A reference to a global auth module config
   * @return authConfigRef
   */
  @javax.annotation.Nullable
  public String getAuthConfigRef() {
    return authConfigRef;
  }

  public void setAuthConfigRef(String authConfigRef) {
    this.authConfigRef = authConfigRef;
  }


  public Service buildMode(Boolean buildMode) {
    this.buildMode = buildMode;
    return this;
  }

  /**
   * Display a construction page when a user try to use the service
   * @return buildMode
   */
  @javax.annotation.Nonnull
  public Boolean getBuildMode() {
    return buildMode;
  }

  public void setBuildMode(Boolean buildMode) {
    this.buildMode = buildMode;
  }


  public Service chaosConfig(ChaosConfig chaosConfig) {
    this.chaosConfig = chaosConfig;
    return this;
  }

  /**
   * Get chaosConfig
   * @return chaosConfig
   */
  @javax.annotation.Nullable
  public ChaosConfig getChaosConfig() {
    return chaosConfig;
  }

  public void setChaosConfig(ChaosConfig chaosConfig) {
    this.chaosConfig = chaosConfig;
  }


  public Service clientConfig(ClientConfig clientConfig) {
    this.clientConfig = clientConfig;
    return this;
  }

  /**
   * Get clientConfig
   * @return clientConfig
   */
  @javax.annotation.Nullable
  public ClientConfig getClientConfig() {
    return clientConfig;
  }

  public void setClientConfig(ClientConfig clientConfig) {
    this.clientConfig = clientConfig;
  }


  public Service clientValidatorRef(String clientValidatorRef) {
    this.clientValidatorRef = clientValidatorRef;
    return this;
  }

  /**
   * A reference to validation authority
   * @return clientValidatorRef
   */
  @javax.annotation.Nullable
  public String getClientValidatorRef() {
    return clientValidatorRef;
  }

  public void setClientValidatorRef(String clientValidatorRef) {
    this.clientValidatorRef = clientValidatorRef;
  }


  public Service cors(CorsSettings cors) {
    this.cors = cors;
    return this;
  }

  /**
   * Get cors
   * @return cors
   */
  @javax.annotation.Nullable
  public CorsSettings getCors() {
    return cors;
  }

  public void setCors(CorsSettings cors) {
    this.cors = cors;
  }


  public Service domain(String domain) {
    this.domain = domain;
    return this;
  }

  /**
   * The domain on which the service is available.
   * @return domain
   */
  @javax.annotation.Nonnull
  public String getDomain() {
    return domain;
  }

  public void setDomain(String domain) {
    this.domain = domain;
  }


  public Service enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist
   * @return enabled
   */
  @javax.annotation.Nonnull
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public Service enforceSecureCommunication(Boolean enforceSecureCommunication) {
    this.enforceSecureCommunication = enforceSecureCommunication;
    return this;
  }

  /**
   * When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside
   * @return enforceSecureCommunication
   */
  @javax.annotation.Nonnull
  public Boolean getEnforceSecureCommunication() {
    return enforceSecureCommunication;
  }

  public void setEnforceSecureCommunication(Boolean enforceSecureCommunication) {
    this.enforceSecureCommunication = enforceSecureCommunication;
  }


  public Service env(String env) {
    this.env = env;
    return this;
  }

  /**
   * The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is &#39;foo&#39; and line is &#39;preprod&#39;, then the exposed service will be available at &#39;foo.preprod.mydomain&#39;
   * @return env
   */
  @javax.annotation.Nonnull
  public String getEnv() {
    return env;
  }

  public void setEnv(String env) {
    this.env = env;
  }


  public Service forceHttps(Boolean forceHttps) {
    this.forceHttps = forceHttps;
    return this;
  }

  /**
   * Will force redirection to https:// if not present
   * @return forceHttps
   */
  @javax.annotation.Nonnull
  public Boolean getForceHttps() {
    return forceHttps;
  }

  public void setForceHttps(Boolean forceHttps) {
    this.forceHttps = forceHttps;
  }


  public Service groups(List<String> groups) {
    this.groups = groups;
    return this;
  }

  public Service addGroupsItem(String groupsItem) {
    if (this.groups == null) {
      this.groups = new ArrayList<>();
    }
    this.groups.add(groupsItem);
    return this;
  }

  /**
   * Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group
   * @return groups
   */
  @javax.annotation.Nonnull
  public List<String> getGroups() {
    return groups;
  }

  public void setGroups(List<String> groups) {
    this.groups = groups;
  }


  public Service gzip(Gzip gzip) {
    this.gzip = gzip;
    return this;
  }

  /**
   * Get gzip
   * @return gzip
   */
  @javax.annotation.Nullable
  public Gzip getGzip() {
    return gzip;
  }

  public void setGzip(Gzip gzip) {
    this.gzip = gzip;
  }


  public Service headersVerification(Map<String, String> headersVerification) {
    this.headersVerification = headersVerification;
    return this;
  }

  public Service putHeadersVerificationItem(String key, String headersVerificationItem) {
    if (this.headersVerification == null) {
      this.headersVerification = new HashMap<>();
    }
    this.headersVerification.put(key, headersVerificationItem);
    return this;
  }

  /**
   * Specify headers that will be verified after routing.
   * @return headersVerification
   */
  @javax.annotation.Nullable
  public Map<String, String> getHeadersVerification() {
    return headersVerification;
  }

  public void setHeadersVerification(Map<String, String> headersVerification) {
    this.headersVerification = headersVerification;
  }


  public Service healthCheck(HealthCheck healthCheck) {
    this.healthCheck = healthCheck;
    return this;
  }

  /**
   * Get healthCheck
   * @return healthCheck
   */
  @javax.annotation.Nullable
  public HealthCheck getHealthCheck() {
    return healthCheck;
  }

  public void setHealthCheck(HealthCheck healthCheck) {
    this.healthCheck = healthCheck;
  }


  public Service id(UUID id) {
    this.id = id;
    return this;
  }

  /**
   * A unique random string to identify your service
   * @return id
   */
  @javax.annotation.Nonnull
  public UUID getId() {
    return id;
  }

  public void setId(UUID id) {
    this.id = id;
  }


  public Service ipFiltering(IpFiltering ipFiltering) {
    this.ipFiltering = ipFiltering;
    return this;
  }

  /**
   * Get ipFiltering
   * @return ipFiltering
   */
  @javax.annotation.Nullable
  public IpFiltering getIpFiltering() {
    return ipFiltering;
  }

  public void setIpFiltering(IpFiltering ipFiltering) {
    this.ipFiltering = ipFiltering;
  }


  public Service jwtVerifier(ImportExportServiceDescriptorsInnerJwtVerifier jwtVerifier) {
    this.jwtVerifier = jwtVerifier;
    return this;
  }

  /**
   * Get jwtVerifier
   * @return jwtVerifier
   */
  @javax.annotation.Nullable
  public ImportExportServiceDescriptorsInnerJwtVerifier getJwtVerifier() {
    return jwtVerifier;
  }

  public void setJwtVerifier(ImportExportServiceDescriptorsInnerJwtVerifier jwtVerifier) {
    this.jwtVerifier = jwtVerifier;
  }


  public Service localHost(String localHost) {
    this.localHost = localHost;
    return this;
  }

  /**
   * The host used localy, mainly localhost:xxxx
   * @return localHost
   */
  @javax.annotation.Nullable
  public String getLocalHost() {
    return localHost;
  }

  public void setLocalHost(String localHost) {
    this.localHost = localHost;
  }


  public Service localScheme(String localScheme) {
    this.localScheme = localScheme;
    return this;
  }

  /**
   * The scheme used localy, mainly http
   * @return localScheme
   */
  @javax.annotation.Nullable
  public String getLocalScheme() {
    return localScheme;
  }

  public void setLocalScheme(String localScheme) {
    this.localScheme = localScheme;
  }


  public Service maintenanceMode(Boolean maintenanceMode) {
    this.maintenanceMode = maintenanceMode;
    return this;
  }

  /**
   * Display a maintainance page when a user try to use the service
   * @return maintenanceMode
   */
  @javax.annotation.Nonnull
  public Boolean getMaintenanceMode() {
    return maintenanceMode;
  }

  public void setMaintenanceMode(Boolean maintenanceMode) {
    this.maintenanceMode = maintenanceMode;
  }


  public Service matchingHeaders(Map<String, String> matchingHeaders) {
    this.matchingHeaders = matchingHeaders;
    return this;
  }

  public Service putMatchingHeadersItem(String key, String matchingHeadersItem) {
    if (this.matchingHeaders == null) {
      this.matchingHeaders = new HashMap<>();
    }
    this.matchingHeaders.put(key, matchingHeadersItem);
    return this;
  }

  /**
   * Specify headers that MUST be present on client request to route it. Useful to implement versioning
   * @return matchingHeaders
   */
  @javax.annotation.Nullable
  public Map<String, String> getMatchingHeaders() {
    return matchingHeaders;
  }

  public void setMatchingHeaders(Map<String, String> matchingHeaders) {
    this.matchingHeaders = matchingHeaders;
  }


  public Service matchingRoot(String matchingRoot) {
    this.matchingRoot = matchingRoot;
    return this;
  }

  /**
   * The root path on which the service is available
   * @return matchingRoot
   */
  @javax.annotation.Nullable
  public String getMatchingRoot() {
    return matchingRoot;
  }

  public void setMatchingRoot(String matchingRoot) {
    this.matchingRoot = matchingRoot;
  }


  public Service metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public Service putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * Just a bunch of random properties
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public Service name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of your service. Only for debug and human readability purposes
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Service overrideHost(Boolean overrideHost) {
    this.overrideHost = overrideHost;
    return this;
  }

  /**
   * Host header will be overriden with Host of the target
   * @return overrideHost
   */
  @javax.annotation.Nullable
  public Boolean getOverrideHost() {
    return overrideHost;
  }

  public void setOverrideHost(Boolean overrideHost) {
    this.overrideHost = overrideHost;
  }


  public Service privateApp(Boolean privateApp) {
    this.privateApp = privateApp;
    return this;
  }

  /**
   * When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain
   * @return privateApp
   */
  @javax.annotation.Nonnull
  public Boolean getPrivateApp() {
    return privateApp;
  }

  public void setPrivateApp(Boolean privateApp) {
    this.privateApp = privateApp;
  }


  public Service privatePatterns(List<String> privatePatterns) {
    this.privatePatterns = privatePatterns;
    return this;
  }

  public Service addPrivatePatternsItem(String privatePatternsItem) {
    if (this.privatePatterns == null) {
      this.privatePatterns = new ArrayList<>();
    }
    this.privatePatterns.add(privatePatternsItem);
    return this;
  }

  /**
   * If you define a public pattern that is a little bit too much, you can make some of public URL private again
   * @return privatePatterns
   */
  @javax.annotation.Nullable
  public List<String> getPrivatePatterns() {
    return privatePatterns;
  }

  public void setPrivatePatterns(List<String> privatePatterns) {
    this.privatePatterns = privatePatterns;
  }


  public Service publicPatterns(List<String> publicPatterns) {
    this.publicPatterns = publicPatterns;
    return this;
  }

  public Service addPublicPatternsItem(String publicPatternsItem) {
    if (this.publicPatterns == null) {
      this.publicPatterns = new ArrayList<>();
    }
    this.publicPatterns.add(publicPatternsItem);
    return this;
  }

  /**
   * By default, every services are private only and you&#39;ll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use &#39;/.*&#39;
   * @return publicPatterns
   */
  @javax.annotation.Nullable
  public List<String> getPublicPatterns() {
    return publicPatterns;
  }

  public void setPublicPatterns(List<String> publicPatterns) {
    this.publicPatterns = publicPatterns;
  }


  public Service redirectToLocal(Boolean redirectToLocal) {
    this.redirectToLocal = redirectToLocal;
    return this;
  }

  /**
   * If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests
   * @return redirectToLocal
   */
  @javax.annotation.Nullable
  public Boolean getRedirectToLocal() {
    return redirectToLocal;
  }

  public void setRedirectToLocal(Boolean redirectToLocal) {
    this.redirectToLocal = redirectToLocal;
  }


  public Service redirection(RedirectionSettings redirection) {
    this.redirection = redirection;
    return this;
  }

  /**
   * Get redirection
   * @return redirection
   */
  @javax.annotation.Nullable
  public RedirectionSettings getRedirection() {
    return redirection;
  }

  public void setRedirection(RedirectionSettings redirection) {
    this.redirection = redirection;
  }


  public Service root(String root) {
    this.root = root;
    return this;
  }

  /**
   * Otoroshi will append this root to any target choosen. If the specified root is &#39;/api/foo&#39;, then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
   * @return root
   */
  @javax.annotation.Nonnull
  public String getRoot() {
    return root;
  }

  public void setRoot(String root) {
    this.root = root;
  }


  public Service secComExcludedPatterns(List<String> secComExcludedPatterns) {
    this.secComExcludedPatterns = secComExcludedPatterns;
    return this;
  }

  public Service addSecComExcludedPatternsItem(String secComExcludedPatternsItem) {
    if (this.secComExcludedPatterns == null) {
      this.secComExcludedPatterns = new ArrayList<>();
    }
    this.secComExcludedPatterns.add(secComExcludedPatternsItem);
    return this;
  }

  /**
   * URI patterns excluded from secured communications
   * @return secComExcludedPatterns
   */
  @javax.annotation.Nullable
  public List<String> getSecComExcludedPatterns() {
    return secComExcludedPatterns;
  }

  public void setSecComExcludedPatterns(List<String> secComExcludedPatterns) {
    this.secComExcludedPatterns = secComExcludedPatterns;
  }


  public Service secComSettings(GlobalJwtVerifierAlgoSettings secComSettings) {
    this.secComSettings = secComSettings;
    return this;
  }

  /**
   * Get secComSettings
   * @return secComSettings
   */
  @javax.annotation.Nullable
  public GlobalJwtVerifierAlgoSettings getSecComSettings() {
    return secComSettings;
  }

  public void setSecComSettings(GlobalJwtVerifierAlgoSettings secComSettings) {
    this.secComSettings = secComSettings;
  }


  public Service sendOtoroshiHeadersBack(Boolean sendOtoroshiHeadersBack) {
    this.sendOtoroshiHeadersBack = sendOtoroshiHeadersBack;
    return this;
  }

  /**
   * When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...
   * @return sendOtoroshiHeadersBack
   */
  @javax.annotation.Nullable
  public Boolean getSendOtoroshiHeadersBack() {
    return sendOtoroshiHeadersBack;
  }

  public void setSendOtoroshiHeadersBack(Boolean sendOtoroshiHeadersBack) {
    this.sendOtoroshiHeadersBack = sendOtoroshiHeadersBack;
  }


  public Service statsdConfig(StatsdConfig statsdConfig) {
    this.statsdConfig = statsdConfig;
    return this;
  }

  /**
   * Get statsdConfig
   * @return statsdConfig
   */
  @javax.annotation.Nullable
  public StatsdConfig getStatsdConfig() {
    return statsdConfig;
  }

  public void setStatsdConfig(StatsdConfig statsdConfig) {
    this.statsdConfig = statsdConfig;
  }


  public Service subdomain(String subdomain) {
    this.subdomain = subdomain;
    return this;
  }

  /**
   * The subdomain on which the service is available
   * @return subdomain
   */
  @javax.annotation.Nonnull
  public String getSubdomain() {
    return subdomain;
  }

  public void setSubdomain(String subdomain) {
    this.subdomain = subdomain;
  }


  public Service targets(List<Target> targets) {
    this.targets = targets;
    return this;
  }

  public Service addTargetsItem(Target targetsItem) {
    if (this.targets == null) {
      this.targets = new ArrayList<>();
    }
    this.targets.add(targetsItem);
    return this;
  }

  /**
   * The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
   * @return targets
   */
  @javax.annotation.Nonnull
  public List<Target> getTargets() {
    return targets;
  }

  public void setTargets(List<Target> targets) {
    this.targets = targets;
  }


  public Service transformerRef(String transformerRef) {
    this.transformerRef = transformerRef;
    return this;
  }

  /**
   * A reference to a request transformer
   * @return transformerRef
   */
  @javax.annotation.Nullable
  public String getTransformerRef() {
    return transformerRef;
  }

  public void setTransformerRef(String transformerRef) {
    this.transformerRef = transformerRef;
  }


  public Service userFacing(Boolean userFacing) {
    this.userFacing = userFacing;
    return this;
  }

  /**
   * The fact that this service will be seen by users and cannot be impacted by the Snow Monkey
   * @return userFacing
   */
  @javax.annotation.Nullable
  public Boolean getUserFacing() {
    return userFacing;
  }

  public void setUserFacing(Boolean userFacing) {
    this.userFacing = userFacing;
  }


  public Service xForwardedHeaders(Boolean xForwardedHeaders) {
    this.xForwardedHeaders = xForwardedHeaders;
    return this;
  }

  /**
   * Send X-Forwarded-* headers
   * @return xForwardedHeaders
   */
  @javax.annotation.Nullable
  public Boolean getxForwardedHeaders() {
    return xForwardedHeaders;
  }

  public void setxForwardedHeaders(Boolean xForwardedHeaders) {
    this.xForwardedHeaders = xForwardedHeaders;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Service service = (Service) o;
    return Objects.equals(this.canary, service.canary) &&
        Objects.equals(this.additionalHeaders, service.additionalHeaders) &&
        Objects.equals(this.api, service.api) &&
        Objects.equals(this.authConfigRef, service.authConfigRef) &&
        Objects.equals(this.buildMode, service.buildMode) &&
        Objects.equals(this.chaosConfig, service.chaosConfig) &&
        Objects.equals(this.clientConfig, service.clientConfig) &&
        Objects.equals(this.clientValidatorRef, service.clientValidatorRef) &&
        Objects.equals(this.cors, service.cors) &&
        Objects.equals(this.domain, service.domain) &&
        Objects.equals(this.enabled, service.enabled) &&
        Objects.equals(this.enforceSecureCommunication, service.enforceSecureCommunication) &&
        Objects.equals(this.env, service.env) &&
        Objects.equals(this.forceHttps, service.forceHttps) &&
        Objects.equals(this.groups, service.groups) &&
        Objects.equals(this.gzip, service.gzip) &&
        Objects.equals(this.headersVerification, service.headersVerification) &&
        Objects.equals(this.healthCheck, service.healthCheck) &&
        Objects.equals(this.id, service.id) &&
        Objects.equals(this.ipFiltering, service.ipFiltering) &&
        Objects.equals(this.jwtVerifier, service.jwtVerifier) &&
        Objects.equals(this.localHost, service.localHost) &&
        Objects.equals(this.localScheme, service.localScheme) &&
        Objects.equals(this.maintenanceMode, service.maintenanceMode) &&
        Objects.equals(this.matchingHeaders, service.matchingHeaders) &&
        Objects.equals(this.matchingRoot, service.matchingRoot) &&
        Objects.equals(this.metadata, service.metadata) &&
        Objects.equals(this.name, service.name) &&
        Objects.equals(this.overrideHost, service.overrideHost) &&
        Objects.equals(this.privateApp, service.privateApp) &&
        Objects.equals(this.privatePatterns, service.privatePatterns) &&
        Objects.equals(this.publicPatterns, service.publicPatterns) &&
        Objects.equals(this.redirectToLocal, service.redirectToLocal) &&
        Objects.equals(this.redirection, service.redirection) &&
        Objects.equals(this.root, service.root) &&
        Objects.equals(this.secComExcludedPatterns, service.secComExcludedPatterns) &&
        Objects.equals(this.secComSettings, service.secComSettings) &&
        Objects.equals(this.sendOtoroshiHeadersBack, service.sendOtoroshiHeadersBack) &&
        Objects.equals(this.statsdConfig, service.statsdConfig) &&
        Objects.equals(this.subdomain, service.subdomain) &&
        Objects.equals(this.targets, service.targets) &&
        Objects.equals(this.transformerRef, service.transformerRef) &&
        Objects.equals(this.userFacing, service.userFacing) &&
        Objects.equals(this.xForwardedHeaders, service.xForwardedHeaders);
  }

  @Override
  public int hashCode() {
    return Objects.hash(canary, additionalHeaders, api, authConfigRef, buildMode, chaosConfig, clientConfig, clientValidatorRef, cors, domain, enabled, enforceSecureCommunication, env, forceHttps, groups, gzip, headersVerification, healthCheck, id, ipFiltering, jwtVerifier, localHost, localScheme, maintenanceMode, matchingHeaders, matchingRoot, metadata, name, overrideHost, privateApp, privatePatterns, publicPatterns, redirectToLocal, redirection, root, secComExcludedPatterns, secComSettings, sendOtoroshiHeadersBack, statsdConfig, subdomain, targets, transformerRef, userFacing, xForwardedHeaders);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Service {\n");
    sb.append("    canary: ").append(toIndentedString(canary)).append("\n");
    sb.append("    additionalHeaders: ").append(toIndentedString(additionalHeaders)).append("\n");
    sb.append("    api: ").append(toIndentedString(api)).append("\n");
    sb.append("    authConfigRef: ").append(toIndentedString(authConfigRef)).append("\n");
    sb.append("    buildMode: ").append(toIndentedString(buildMode)).append("\n");
    sb.append("    chaosConfig: ").append(toIndentedString(chaosConfig)).append("\n");
    sb.append("    clientConfig: ").append(toIndentedString(clientConfig)).append("\n");
    sb.append("    clientValidatorRef: ").append(toIndentedString(clientValidatorRef)).append("\n");
    sb.append("    cors: ").append(toIndentedString(cors)).append("\n");
    sb.append("    domain: ").append(toIndentedString(domain)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    enforceSecureCommunication: ").append(toIndentedString(enforceSecureCommunication)).append("\n");
    sb.append("    env: ").append(toIndentedString(env)).append("\n");
    sb.append("    forceHttps: ").append(toIndentedString(forceHttps)).append("\n");
    sb.append("    groups: ").append(toIndentedString(groups)).append("\n");
    sb.append("    gzip: ").append(toIndentedString(gzip)).append("\n");
    sb.append("    headersVerification: ").append(toIndentedString(headersVerification)).append("\n");
    sb.append("    healthCheck: ").append(toIndentedString(healthCheck)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    ipFiltering: ").append(toIndentedString(ipFiltering)).append("\n");
    sb.append("    jwtVerifier: ").append(toIndentedString(jwtVerifier)).append("\n");
    sb.append("    localHost: ").append(toIndentedString(localHost)).append("\n");
    sb.append("    localScheme: ").append(toIndentedString(localScheme)).append("\n");
    sb.append("    maintenanceMode: ").append(toIndentedString(maintenanceMode)).append("\n");
    sb.append("    matchingHeaders: ").append(toIndentedString(matchingHeaders)).append("\n");
    sb.append("    matchingRoot: ").append(toIndentedString(matchingRoot)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    overrideHost: ").append(toIndentedString(overrideHost)).append("\n");
    sb.append("    privateApp: ").append(toIndentedString(privateApp)).append("\n");
    sb.append("    privatePatterns: ").append(toIndentedString(privatePatterns)).append("\n");
    sb.append("    publicPatterns: ").append(toIndentedString(publicPatterns)).append("\n");
    sb.append("    redirectToLocal: ").append(toIndentedString(redirectToLocal)).append("\n");
    sb.append("    redirection: ").append(toIndentedString(redirection)).append("\n");
    sb.append("    root: ").append(toIndentedString(root)).append("\n");
    sb.append("    secComExcludedPatterns: ").append(toIndentedString(secComExcludedPatterns)).append("\n");
    sb.append("    secComSettings: ").append(toIndentedString(secComSettings)).append("\n");
    sb.append("    sendOtoroshiHeadersBack: ").append(toIndentedString(sendOtoroshiHeadersBack)).append("\n");
    sb.append("    statsdConfig: ").append(toIndentedString(statsdConfig)).append("\n");
    sb.append("    subdomain: ").append(toIndentedString(subdomain)).append("\n");
    sb.append("    targets: ").append(toIndentedString(targets)).append("\n");
    sb.append("    transformerRef: ").append(toIndentedString(transformerRef)).append("\n");
    sb.append("    userFacing: ").append(toIndentedString(userFacing)).append("\n");
    sb.append("    xForwardedHeaders: ").append(toIndentedString(xForwardedHeaders)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Canary");
    openapiFields.add("additionalHeaders");
    openapiFields.add("api");
    openapiFields.add("authConfigRef");
    openapiFields.add("buildMode");
    openapiFields.add("chaosConfig");
    openapiFields.add("clientConfig");
    openapiFields.add("clientValidatorRef");
    openapiFields.add("cors");
    openapiFields.add("domain");
    openapiFields.add("enabled");
    openapiFields.add("enforceSecureCommunication");
    openapiFields.add("env");
    openapiFields.add("forceHttps");
    openapiFields.add("groups");
    openapiFields.add("gzip");
    openapiFields.add("headersVerification");
    openapiFields.add("healthCheck");
    openapiFields.add("id");
    openapiFields.add("ipFiltering");
    openapiFields.add("jwtVerifier");
    openapiFields.add("localHost");
    openapiFields.add("localScheme");
    openapiFields.add("maintenanceMode");
    openapiFields.add("matchingHeaders");
    openapiFields.add("matchingRoot");
    openapiFields.add("metadata");
    openapiFields.add("name");
    openapiFields.add("overrideHost");
    openapiFields.add("privateApp");
    openapiFields.add("privatePatterns");
    openapiFields.add("publicPatterns");
    openapiFields.add("redirectToLocal");
    openapiFields.add("redirection");
    openapiFields.add("root");
    openapiFields.add("secComExcludedPatterns");
    openapiFields.add("secComSettings");
    openapiFields.add("sendOtoroshiHeadersBack");
    openapiFields.add("statsdConfig");
    openapiFields.add("subdomain");
    openapiFields.add("targets");
    openapiFields.add("transformerRef");
    openapiFields.add("userFacing");
    openapiFields.add("xForwardedHeaders");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("buildMode");
    openapiRequiredFields.add("domain");
    openapiRequiredFields.add("enabled");
    openapiRequiredFields.add("enforceSecureCommunication");
    openapiRequiredFields.add("env");
    openapiRequiredFields.add("forceHttps");
    openapiRequiredFields.add("groups");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("maintenanceMode");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("privateApp");
    openapiRequiredFields.add("root");
    openapiRequiredFields.add("subdomain");
    openapiRequiredFields.add("targets");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Service
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Service.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Service is not found in the empty JSON string", Service.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Service.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Service` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Service.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Canary`
      if (jsonObj.get("Canary") != null && !jsonObj.get("Canary").isJsonNull()) {
        Canary.validateJsonElement(jsonObj.get("Canary"));
      }
      // validate the optional field `api`
      if (jsonObj.get("api") != null && !jsonObj.get("api").isJsonNull()) {
        ExposedApi.validateJsonElement(jsonObj.get("api"));
      }
      if ((jsonObj.get("authConfigRef") != null && !jsonObj.get("authConfigRef").isJsonNull()) && !jsonObj.get("authConfigRef").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authConfigRef` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authConfigRef").toString()));
      }
      // validate the optional field `chaosConfig`
      if (jsonObj.get("chaosConfig") != null && !jsonObj.get("chaosConfig").isJsonNull()) {
        ChaosConfig.validateJsonElement(jsonObj.get("chaosConfig"));
      }
      // validate the optional field `clientConfig`
      if (jsonObj.get("clientConfig") != null && !jsonObj.get("clientConfig").isJsonNull()) {
        ClientConfig.validateJsonElement(jsonObj.get("clientConfig"));
      }
      if ((jsonObj.get("clientValidatorRef") != null && !jsonObj.get("clientValidatorRef").isJsonNull()) && !jsonObj.get("clientValidatorRef").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clientValidatorRef` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clientValidatorRef").toString()));
      }
      // validate the optional field `cors`
      if (jsonObj.get("cors") != null && !jsonObj.get("cors").isJsonNull()) {
        CorsSettings.validateJsonElement(jsonObj.get("cors"));
      }
      if (!jsonObj.get("domain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `domain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("domain").toString()));
      }
      if (!jsonObj.get("env").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `env` to be a primitive type in the JSON string but got `%s`", jsonObj.get("env").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("groups") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("groups").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `groups` to be an array in the JSON string but got `%s`", jsonObj.get("groups").toString()));
      }
      // validate the optional field `gzip`
      if (jsonObj.get("gzip") != null && !jsonObj.get("gzip").isJsonNull()) {
        Gzip.validateJsonElement(jsonObj.get("gzip"));
      }
      // validate the optional field `healthCheck`
      if (jsonObj.get("healthCheck") != null && !jsonObj.get("healthCheck").isJsonNull()) {
        HealthCheck.validateJsonElement(jsonObj.get("healthCheck"));
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `ipFiltering`
      if (jsonObj.get("ipFiltering") != null && !jsonObj.get("ipFiltering").isJsonNull()) {
        IpFiltering.validateJsonElement(jsonObj.get("ipFiltering"));
      }
      // validate the optional field `jwtVerifier`
      if (jsonObj.get("jwtVerifier") != null && !jsonObj.get("jwtVerifier").isJsonNull()) {
        ImportExportServiceDescriptorsInnerJwtVerifier.validateJsonElement(jsonObj.get("jwtVerifier"));
      }
      if ((jsonObj.get("localHost") != null && !jsonObj.get("localHost").isJsonNull()) && !jsonObj.get("localHost").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `localHost` to be a primitive type in the JSON string but got `%s`", jsonObj.get("localHost").toString()));
      }
      if ((jsonObj.get("localScheme") != null && !jsonObj.get("localScheme").isJsonNull()) && !jsonObj.get("localScheme").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `localScheme` to be a primitive type in the JSON string but got `%s`", jsonObj.get("localScheme").toString()));
      }
      if ((jsonObj.get("matchingRoot") != null && !jsonObj.get("matchingRoot").isJsonNull()) && !jsonObj.get("matchingRoot").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchingRoot` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchingRoot").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("privatePatterns") != null && !jsonObj.get("privatePatterns").isJsonNull() && !jsonObj.get("privatePatterns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `privatePatterns` to be an array in the JSON string but got `%s`", jsonObj.get("privatePatterns").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("publicPatterns") != null && !jsonObj.get("publicPatterns").isJsonNull() && !jsonObj.get("publicPatterns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `publicPatterns` to be an array in the JSON string but got `%s`", jsonObj.get("publicPatterns").toString()));
      }
      // validate the optional field `redirection`
      if (jsonObj.get("redirection") != null && !jsonObj.get("redirection").isJsonNull()) {
        RedirectionSettings.validateJsonElement(jsonObj.get("redirection"));
      }
      if (!jsonObj.get("root").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `root` to be a primitive type in the JSON string but got `%s`", jsonObj.get("root").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("secComExcludedPatterns") != null && !jsonObj.get("secComExcludedPatterns").isJsonNull() && !jsonObj.get("secComExcludedPatterns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `secComExcludedPatterns` to be an array in the JSON string but got `%s`", jsonObj.get("secComExcludedPatterns").toString()));
      }
      // validate the optional field `secComSettings`
      if (jsonObj.get("secComSettings") != null && !jsonObj.get("secComSettings").isJsonNull()) {
        GlobalJwtVerifierAlgoSettings.validateJsonElement(jsonObj.get("secComSettings"));
      }
      // validate the optional field `statsdConfig`
      if (jsonObj.get("statsdConfig") != null && !jsonObj.get("statsdConfig").isJsonNull()) {
        StatsdConfig.validateJsonElement(jsonObj.get("statsdConfig"));
      }
      if (!jsonObj.get("subdomain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subdomain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subdomain").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("targets").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `targets` to be an array in the JSON string but got `%s`", jsonObj.get("targets").toString()));
      }

      JsonArray jsonArraytargets = jsonObj.getAsJsonArray("targets");
      // validate the required field `targets` (array)
      for (int i = 0; i < jsonArraytargets.size(); i++) {
        Target.validateJsonElement(jsonArraytargets.get(i));
      };
      if ((jsonObj.get("transformerRef") != null && !jsonObj.get("transformerRef").isJsonNull()) && !jsonObj.get("transformerRef").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transformerRef` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transformerRef").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Service.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Service' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Service> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Service.class));

       return (TypeAdapter<T>) new TypeAdapter<Service>() {
           @Override
           public void write(JsonWriter out, Service value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Service read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Service given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Service
   * @throws IOException if the JSON string is invalid with respect to Service
   */
  public static Service fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Service.class);
  }

  /**
   * Convert an instance of Service to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

