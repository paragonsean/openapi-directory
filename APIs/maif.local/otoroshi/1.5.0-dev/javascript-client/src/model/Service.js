/**
 * Otoroshi Admin API
 * Admin API of the Otoroshi reverse proxy
 *
 * The version of the OpenAPI document: 1.5.0-dev
 * Contact: oss@maif.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Canary from './Canary';
import ChaosConfig from './ChaosConfig';
import ClientConfig from './ClientConfig';
import CorsSettings from './CorsSettings';
import ExposedApi from './ExposedApi';
import GlobalJwtVerifierAlgoSettings from './GlobalJwtVerifierAlgoSettings';
import Gzip from './Gzip';
import HealthCheck from './HealthCheck';
import ImportExportServiceDescriptorsInnerJwtVerifier from './ImportExportServiceDescriptorsInnerJwtVerifier';
import IpFiltering from './IpFiltering';
import RedirectionSettings from './RedirectionSettings';
import StatsdConfig from './StatsdConfig';
import Target from './Target';

/**
 * The Service model module.
 * @module model/Service
 * @version 1.5.0-dev
 */
class Service {
    /**
     * Constructs a new <code>Service</code>.
     * An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism
     * @alias module:model/Service
     * @param buildMode {Boolean} Display a construction page when a user try to use the service
     * @param domain {String} The domain on which the service is available.
     * @param enabled {Boolean} Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist
     * @param enforceSecureCommunication {Boolean} When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside
     * @param env {String} The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'
     * @param forceHttps {Boolean} Will force redirection to https:// if not present
     * @param groups {Array.<String>} Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group
     * @param id {String} A unique random string to identify your service
     * @param maintenanceMode {Boolean} Display a maintainance page when a user try to use the service
     * @param name {String} The name of your service. Only for debug and human readability purposes
     * @param privateApp {Boolean} When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain
     * @param root {String} Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
     * @param subdomain {String} The subdomain on which the service is available
     * @param targets {Array.<module:model/Target>} The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
     */
    constructor(buildMode, domain, enabled, enforceSecureCommunication, env, forceHttps, groups, id, maintenanceMode, name, privateApp, root, subdomain, targets) { 
        
        Service.initialize(this, buildMode, domain, enabled, enforceSecureCommunication, env, forceHttps, groups, id, maintenanceMode, name, privateApp, root, subdomain, targets);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, buildMode, domain, enabled, enforceSecureCommunication, env, forceHttps, groups, id, maintenanceMode, name, privateApp, root, subdomain, targets) { 
        obj['buildMode'] = buildMode;
        obj['domain'] = domain;
        obj['enabled'] = enabled;
        obj['enforceSecureCommunication'] = enforceSecureCommunication;
        obj['env'] = env;
        obj['forceHttps'] = forceHttps;
        obj['groups'] = groups;
        obj['id'] = id;
        obj['maintenanceMode'] = maintenanceMode;
        obj['name'] = name;
        obj['privateApp'] = privateApp;
        obj['root'] = root;
        obj['subdomain'] = subdomain;
        obj['targets'] = targets;
    }

    /**
     * Constructs a <code>Service</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Service} obj Optional instance to populate.
     * @return {module:model/Service} The populated <code>Service</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Service();

            if (data.hasOwnProperty('Canary')) {
                obj['Canary'] = Canary.constructFromObject(data['Canary']);
            }
            if (data.hasOwnProperty('additionalHeaders')) {
                obj['additionalHeaders'] = ApiClient.convertToType(data['additionalHeaders'], {'String': 'String'});
            }
            if (data.hasOwnProperty('api')) {
                obj['api'] = ExposedApi.constructFromObject(data['api']);
            }
            if (data.hasOwnProperty('authConfigRef')) {
                obj['authConfigRef'] = ApiClient.convertToType(data['authConfigRef'], 'String');
            }
            if (data.hasOwnProperty('buildMode')) {
                obj['buildMode'] = ApiClient.convertToType(data['buildMode'], 'Boolean');
            }
            if (data.hasOwnProperty('chaosConfig')) {
                obj['chaosConfig'] = ChaosConfig.constructFromObject(data['chaosConfig']);
            }
            if (data.hasOwnProperty('clientConfig')) {
                obj['clientConfig'] = ClientConfig.constructFromObject(data['clientConfig']);
            }
            if (data.hasOwnProperty('clientValidatorRef')) {
                obj['clientValidatorRef'] = ApiClient.convertToType(data['clientValidatorRef'], 'String');
            }
            if (data.hasOwnProperty('cors')) {
                obj['cors'] = CorsSettings.constructFromObject(data['cors']);
            }
            if (data.hasOwnProperty('domain')) {
                obj['domain'] = ApiClient.convertToType(data['domain'], 'String');
            }
            if (data.hasOwnProperty('enabled')) {
                obj['enabled'] = ApiClient.convertToType(data['enabled'], 'Boolean');
            }
            if (data.hasOwnProperty('enforceSecureCommunication')) {
                obj['enforceSecureCommunication'] = ApiClient.convertToType(data['enforceSecureCommunication'], 'Boolean');
            }
            if (data.hasOwnProperty('env')) {
                obj['env'] = ApiClient.convertToType(data['env'], 'String');
            }
            if (data.hasOwnProperty('forceHttps')) {
                obj['forceHttps'] = ApiClient.convertToType(data['forceHttps'], 'Boolean');
            }
            if (data.hasOwnProperty('groups')) {
                obj['groups'] = ApiClient.convertToType(data['groups'], ['String']);
            }
            if (data.hasOwnProperty('gzip')) {
                obj['gzip'] = Gzip.constructFromObject(data['gzip']);
            }
            if (data.hasOwnProperty('headersVerification')) {
                obj['headersVerification'] = ApiClient.convertToType(data['headersVerification'], {'String': 'String'});
            }
            if (data.hasOwnProperty('healthCheck')) {
                obj['healthCheck'] = HealthCheck.constructFromObject(data['healthCheck']);
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('ipFiltering')) {
                obj['ipFiltering'] = IpFiltering.constructFromObject(data['ipFiltering']);
            }
            if (data.hasOwnProperty('jwtVerifier')) {
                obj['jwtVerifier'] = ImportExportServiceDescriptorsInnerJwtVerifier.constructFromObject(data['jwtVerifier']);
            }
            if (data.hasOwnProperty('localHost')) {
                obj['localHost'] = ApiClient.convertToType(data['localHost'], 'String');
            }
            if (data.hasOwnProperty('localScheme')) {
                obj['localScheme'] = ApiClient.convertToType(data['localScheme'], 'String');
            }
            if (data.hasOwnProperty('maintenanceMode')) {
                obj['maintenanceMode'] = ApiClient.convertToType(data['maintenanceMode'], 'Boolean');
            }
            if (data.hasOwnProperty('matchingHeaders')) {
                obj['matchingHeaders'] = ApiClient.convertToType(data['matchingHeaders'], {'String': 'String'});
            }
            if (data.hasOwnProperty('matchingRoot')) {
                obj['matchingRoot'] = ApiClient.convertToType(data['matchingRoot'], 'String');
            }
            if (data.hasOwnProperty('metadata')) {
                obj['metadata'] = ApiClient.convertToType(data['metadata'], {'String': 'String'});
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('overrideHost')) {
                obj['overrideHost'] = ApiClient.convertToType(data['overrideHost'], 'Boolean');
            }
            if (data.hasOwnProperty('privateApp')) {
                obj['privateApp'] = ApiClient.convertToType(data['privateApp'], 'Boolean');
            }
            if (data.hasOwnProperty('privatePatterns')) {
                obj['privatePatterns'] = ApiClient.convertToType(data['privatePatterns'], ['String']);
            }
            if (data.hasOwnProperty('publicPatterns')) {
                obj['publicPatterns'] = ApiClient.convertToType(data['publicPatterns'], ['String']);
            }
            if (data.hasOwnProperty('redirectToLocal')) {
                obj['redirectToLocal'] = ApiClient.convertToType(data['redirectToLocal'], 'Boolean');
            }
            if (data.hasOwnProperty('redirection')) {
                obj['redirection'] = RedirectionSettings.constructFromObject(data['redirection']);
            }
            if (data.hasOwnProperty('root')) {
                obj['root'] = ApiClient.convertToType(data['root'], 'String');
            }
            if (data.hasOwnProperty('secComExcludedPatterns')) {
                obj['secComExcludedPatterns'] = ApiClient.convertToType(data['secComExcludedPatterns'], ['String']);
            }
            if (data.hasOwnProperty('secComSettings')) {
                obj['secComSettings'] = GlobalJwtVerifierAlgoSettings.constructFromObject(data['secComSettings']);
            }
            if (data.hasOwnProperty('sendOtoroshiHeadersBack')) {
                obj['sendOtoroshiHeadersBack'] = ApiClient.convertToType(data['sendOtoroshiHeadersBack'], 'Boolean');
            }
            if (data.hasOwnProperty('statsdConfig')) {
                obj['statsdConfig'] = StatsdConfig.constructFromObject(data['statsdConfig']);
            }
            if (data.hasOwnProperty('subdomain')) {
                obj['subdomain'] = ApiClient.convertToType(data['subdomain'], 'String');
            }
            if (data.hasOwnProperty('targets')) {
                obj['targets'] = ApiClient.convertToType(data['targets'], [Target]);
            }
            if (data.hasOwnProperty('transformerRef')) {
                obj['transformerRef'] = ApiClient.convertToType(data['transformerRef'], 'String');
            }
            if (data.hasOwnProperty('userFacing')) {
                obj['userFacing'] = ApiClient.convertToType(data['userFacing'], 'Boolean');
            }
            if (data.hasOwnProperty('xForwardedHeaders')) {
                obj['xForwardedHeaders'] = ApiClient.convertToType(data['xForwardedHeaders'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Service</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Service</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of Service.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // validate the optional field `Canary`
        if (data['Canary']) { // data not null
          Canary.validateJSON(data['Canary']);
        }
        // validate the optional field `api`
        if (data['api']) { // data not null
          ExposedApi.validateJSON(data['api']);
        }
        // ensure the json data is a string
        if (data['authConfigRef'] && !(typeof data['authConfigRef'] === 'string' || data['authConfigRef'] instanceof String)) {
            throw new Error("Expected the field `authConfigRef` to be a primitive type in the JSON string but got " + data['authConfigRef']);
        }
        // validate the optional field `chaosConfig`
        if (data['chaosConfig']) { // data not null
          ChaosConfig.validateJSON(data['chaosConfig']);
        }
        // validate the optional field `clientConfig`
        if (data['clientConfig']) { // data not null
          ClientConfig.validateJSON(data['clientConfig']);
        }
        // ensure the json data is a string
        if (data['clientValidatorRef'] && !(typeof data['clientValidatorRef'] === 'string' || data['clientValidatorRef'] instanceof String)) {
            throw new Error("Expected the field `clientValidatorRef` to be a primitive type in the JSON string but got " + data['clientValidatorRef']);
        }
        // validate the optional field `cors`
        if (data['cors']) { // data not null
          CorsSettings.validateJSON(data['cors']);
        }
        // ensure the json data is a string
        if (data['domain'] && !(typeof data['domain'] === 'string' || data['domain'] instanceof String)) {
            throw new Error("Expected the field `domain` to be a primitive type in the JSON string but got " + data['domain']);
        }
        // ensure the json data is a string
        if (data['env'] && !(typeof data['env'] === 'string' || data['env'] instanceof String)) {
            throw new Error("Expected the field `env` to be a primitive type in the JSON string but got " + data['env']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['groups'])) {
            throw new Error("Expected the field `groups` to be an array in the JSON data but got " + data['groups']);
        }
        // validate the optional field `gzip`
        if (data['gzip']) { // data not null
          Gzip.validateJSON(data['gzip']);
        }
        // validate the optional field `healthCheck`
        if (data['healthCheck']) { // data not null
          HealthCheck.validateJSON(data['healthCheck']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // validate the optional field `ipFiltering`
        if (data['ipFiltering']) { // data not null
          IpFiltering.validateJSON(data['ipFiltering']);
        }
        // validate the optional field `jwtVerifier`
        if (data['jwtVerifier']) { // data not null
          ImportExportServiceDescriptorsInnerJwtVerifier.validateJSON(data['jwtVerifier']);
        }
        // ensure the json data is a string
        if (data['localHost'] && !(typeof data['localHost'] === 'string' || data['localHost'] instanceof String)) {
            throw new Error("Expected the field `localHost` to be a primitive type in the JSON string but got " + data['localHost']);
        }
        // ensure the json data is a string
        if (data['localScheme'] && !(typeof data['localScheme'] === 'string' || data['localScheme'] instanceof String)) {
            throw new Error("Expected the field `localScheme` to be a primitive type in the JSON string but got " + data['localScheme']);
        }
        // ensure the json data is a string
        if (data['matchingRoot'] && !(typeof data['matchingRoot'] === 'string' || data['matchingRoot'] instanceof String)) {
            throw new Error("Expected the field `matchingRoot` to be a primitive type in the JSON string but got " + data['matchingRoot']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['privatePatterns'])) {
            throw new Error("Expected the field `privatePatterns` to be an array in the JSON data but got " + data['privatePatterns']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['publicPatterns'])) {
            throw new Error("Expected the field `publicPatterns` to be an array in the JSON data but got " + data['publicPatterns']);
        }
        // validate the optional field `redirection`
        if (data['redirection']) { // data not null
          RedirectionSettings.validateJSON(data['redirection']);
        }
        // ensure the json data is a string
        if (data['root'] && !(typeof data['root'] === 'string' || data['root'] instanceof String)) {
            throw new Error("Expected the field `root` to be a primitive type in the JSON string but got " + data['root']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['secComExcludedPatterns'])) {
            throw new Error("Expected the field `secComExcludedPatterns` to be an array in the JSON data but got " + data['secComExcludedPatterns']);
        }
        // validate the optional field `secComSettings`
        if (data['secComSettings']) { // data not null
          GlobalJwtVerifierAlgoSettings.validateJSON(data['secComSettings']);
        }
        // validate the optional field `statsdConfig`
        if (data['statsdConfig']) { // data not null
          StatsdConfig.validateJSON(data['statsdConfig']);
        }
        // ensure the json data is a string
        if (data['subdomain'] && !(typeof data['subdomain'] === 'string' || data['subdomain'] instanceof String)) {
            throw new Error("Expected the field `subdomain` to be a primitive type in the JSON string but got " + data['subdomain']);
        }
        if (data['targets']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['targets'])) {
                throw new Error("Expected the field `targets` to be an array in the JSON data but got " + data['targets']);
            }
            // validate the optional field `targets` (array)
            for (const item of data['targets']) {
                Target.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['transformerRef'] && !(typeof data['transformerRef'] === 'string' || data['transformerRef'] instanceof String)) {
            throw new Error("Expected the field `transformerRef` to be a primitive type in the JSON string but got " + data['transformerRef']);
        }

        return true;
    }


}

Service.RequiredProperties = ["buildMode", "domain", "enabled", "enforceSecureCommunication", "env", "forceHttps", "groups", "id", "maintenanceMode", "name", "privateApp", "root", "subdomain", "targets"];

/**
 * @member {module:model/Canary} Canary
 */
Service.prototype['Canary'] = undefined;

/**
 * Specify headers that will be added to each client request. Useful to add authentication
 * @member {Object.<String, String>} additionalHeaders
 */
Service.prototype['additionalHeaders'] = undefined;

/**
 * @member {module:model/ExposedApi} api
 */
Service.prototype['api'] = undefined;

/**
 * A reference to a global auth module config
 * @member {String} authConfigRef
 */
Service.prototype['authConfigRef'] = undefined;

/**
 * Display a construction page when a user try to use the service
 * @member {Boolean} buildMode
 */
Service.prototype['buildMode'] = undefined;

/**
 * @member {module:model/ChaosConfig} chaosConfig
 */
Service.prototype['chaosConfig'] = undefined;

/**
 * @member {module:model/ClientConfig} clientConfig
 */
Service.prototype['clientConfig'] = undefined;

/**
 * A reference to validation authority
 * @member {String} clientValidatorRef
 */
Service.prototype['clientValidatorRef'] = undefined;

/**
 * @member {module:model/CorsSettings} cors
 */
Service.prototype['cors'] = undefined;

/**
 * The domain on which the service is available.
 * @member {String} domain
 */
Service.prototype['domain'] = undefined;

/**
 * Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist
 * @member {Boolean} enabled
 */
Service.prototype['enabled'] = undefined;

/**
 * When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside
 * @member {Boolean} enforceSecureCommunication
 */
Service.prototype['enforceSecureCommunication'] = undefined;

/**
 * The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'
 * @member {String} env
 */
Service.prototype['env'] = undefined;

/**
 * Will force redirection to https:// if not present
 * @member {Boolean} forceHttps
 */
Service.prototype['forceHttps'] = undefined;

/**
 * Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group
 * @member {Array.<String>} groups
 */
Service.prototype['groups'] = undefined;

/**
 * @member {module:model/Gzip} gzip
 */
Service.prototype['gzip'] = undefined;

/**
 * Specify headers that will be verified after routing.
 * @member {Object.<String, String>} headersVerification
 */
Service.prototype['headersVerification'] = undefined;

/**
 * @member {module:model/HealthCheck} healthCheck
 */
Service.prototype['healthCheck'] = undefined;

/**
 * A unique random string to identify your service
 * @member {String} id
 */
Service.prototype['id'] = undefined;

/**
 * @member {module:model/IpFiltering} ipFiltering
 */
Service.prototype['ipFiltering'] = undefined;

/**
 * @member {module:model/ImportExportServiceDescriptorsInnerJwtVerifier} jwtVerifier
 */
Service.prototype['jwtVerifier'] = undefined;

/**
 * The host used localy, mainly localhost:xxxx
 * @member {String} localHost
 */
Service.prototype['localHost'] = undefined;

/**
 * The scheme used localy, mainly http
 * @member {String} localScheme
 */
Service.prototype['localScheme'] = undefined;

/**
 * Display a maintainance page when a user try to use the service
 * @member {Boolean} maintenanceMode
 */
Service.prototype['maintenanceMode'] = undefined;

/**
 * Specify headers that MUST be present on client request to route it. Useful to implement versioning
 * @member {Object.<String, String>} matchingHeaders
 */
Service.prototype['matchingHeaders'] = undefined;

/**
 * The root path on which the service is available
 * @member {String} matchingRoot
 */
Service.prototype['matchingRoot'] = undefined;

/**
 * Just a bunch of random properties
 * @member {Object.<String, String>} metadata
 */
Service.prototype['metadata'] = undefined;

/**
 * The name of your service. Only for debug and human readability purposes
 * @member {String} name
 */
Service.prototype['name'] = undefined;

/**
 * Host header will be overriden with Host of the target
 * @member {Boolean} overrideHost
 */
Service.prototype['overrideHost'] = undefined;

/**
 * When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain
 * @member {Boolean} privateApp
 */
Service.prototype['privateApp'] = undefined;

/**
 * If you define a public pattern that is a little bit too much, you can make some of public URL private again
 * @member {Array.<String>} privatePatterns
 */
Service.prototype['privatePatterns'] = undefined;

/**
 * By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'
 * @member {Array.<String>} publicPatterns
 */
Service.prototype['publicPatterns'] = undefined;

/**
 * If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests
 * @member {Boolean} redirectToLocal
 */
Service.prototype['redirectToLocal'] = undefined;

/**
 * @member {module:model/RedirectionSettings} redirection
 */
Service.prototype['redirection'] = undefined;

/**
 * Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
 * @member {String} root
 */
Service.prototype['root'] = undefined;

/**
 * URI patterns excluded from secured communications
 * @member {Array.<String>} secComExcludedPatterns
 */
Service.prototype['secComExcludedPatterns'] = undefined;

/**
 * @member {module:model/GlobalJwtVerifierAlgoSettings} secComSettings
 */
Service.prototype['secComSettings'] = undefined;

/**
 * When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...
 * @member {Boolean} sendOtoroshiHeadersBack
 */
Service.prototype['sendOtoroshiHeadersBack'] = undefined;

/**
 * @member {module:model/StatsdConfig} statsdConfig
 */
Service.prototype['statsdConfig'] = undefined;

/**
 * The subdomain on which the service is available
 * @member {String} subdomain
 */
Service.prototype['subdomain'] = undefined;

/**
 * The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
 * @member {Array.<module:model/Target>} targets
 */
Service.prototype['targets'] = undefined;

/**
 * A reference to a request transformer
 * @member {String} transformerRef
 */
Service.prototype['transformerRef'] = undefined;

/**
 * The fact that this service will be seen by users and cannot be impacted by the Snow Monkey
 * @member {Boolean} userFacing
 */
Service.prototype['userFacing'] = undefined;

/**
 * Send X-Forwarded-* headers
 * @member {Boolean} xForwardedHeaders
 */
Service.prototype['xForwardedHeaders'] = undefined;






export default Service;

