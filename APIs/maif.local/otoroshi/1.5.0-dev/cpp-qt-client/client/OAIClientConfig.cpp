/**
 * Otoroshi Admin API
 * Admin API of the Otoroshi reverse proxy
 *
 * The version of the OpenAPI document: 1.5.0-dev
 * Contact: oss@maif.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIClientConfig.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIClientConfig::OAIClientConfig(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIClientConfig::OAIClientConfig() {
    this->initializeModel();
}

OAIClientConfig::~OAIClientConfig() {}

void OAIClientConfig::initializeModel() {

    m_backoff_factor_isSet = false;
    m_backoff_factor_isValid = false;

    m_call_timeout_isSet = false;
    m_call_timeout_isValid = false;

    m_global_timeout_isSet = false;
    m_global_timeout_isValid = false;

    m_max_errors_isSet = false;
    m_max_errors_isValid = false;

    m_retries_isSet = false;
    m_retries_isValid = false;

    m_retry_initial_delay_isSet = false;
    m_retry_initial_delay_isValid = false;

    m_sample_interval_isSet = false;
    m_sample_interval_isValid = false;

    m_use_circuit_breaker_isSet = false;
    m_use_circuit_breaker_isValid = false;
}

void OAIClientConfig::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIClientConfig::fromJsonObject(QJsonObject json) {

    m_backoff_factor_isValid = ::OpenAPI::fromJsonValue(m_backoff_factor, json[QString("backoffFactor")]);
    m_backoff_factor_isSet = !json[QString("backoffFactor")].isNull() && m_backoff_factor_isValid;

    m_call_timeout_isValid = ::OpenAPI::fromJsonValue(m_call_timeout, json[QString("callTimeout")]);
    m_call_timeout_isSet = !json[QString("callTimeout")].isNull() && m_call_timeout_isValid;

    m_global_timeout_isValid = ::OpenAPI::fromJsonValue(m_global_timeout, json[QString("globalTimeout")]);
    m_global_timeout_isSet = !json[QString("globalTimeout")].isNull() && m_global_timeout_isValid;

    m_max_errors_isValid = ::OpenAPI::fromJsonValue(m_max_errors, json[QString("maxErrors")]);
    m_max_errors_isSet = !json[QString("maxErrors")].isNull() && m_max_errors_isValid;

    m_retries_isValid = ::OpenAPI::fromJsonValue(m_retries, json[QString("retries")]);
    m_retries_isSet = !json[QString("retries")].isNull() && m_retries_isValid;

    m_retry_initial_delay_isValid = ::OpenAPI::fromJsonValue(m_retry_initial_delay, json[QString("retryInitialDelay")]);
    m_retry_initial_delay_isSet = !json[QString("retryInitialDelay")].isNull() && m_retry_initial_delay_isValid;

    m_sample_interval_isValid = ::OpenAPI::fromJsonValue(m_sample_interval, json[QString("sampleInterval")]);
    m_sample_interval_isSet = !json[QString("sampleInterval")].isNull() && m_sample_interval_isValid;

    m_use_circuit_breaker_isValid = ::OpenAPI::fromJsonValue(m_use_circuit_breaker, json[QString("useCircuitBreaker")]);
    m_use_circuit_breaker_isSet = !json[QString("useCircuitBreaker")].isNull() && m_use_circuit_breaker_isValid;
}

QString OAIClientConfig::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIClientConfig::asJsonObject() const {
    QJsonObject obj;
    if (m_backoff_factor_isSet) {
        obj.insert(QString("backoffFactor"), ::OpenAPI::toJsonValue(m_backoff_factor));
    }
    if (m_call_timeout_isSet) {
        obj.insert(QString("callTimeout"), ::OpenAPI::toJsonValue(m_call_timeout));
    }
    if (m_global_timeout_isSet) {
        obj.insert(QString("globalTimeout"), ::OpenAPI::toJsonValue(m_global_timeout));
    }
    if (m_max_errors_isSet) {
        obj.insert(QString("maxErrors"), ::OpenAPI::toJsonValue(m_max_errors));
    }
    if (m_retries_isSet) {
        obj.insert(QString("retries"), ::OpenAPI::toJsonValue(m_retries));
    }
    if (m_retry_initial_delay_isSet) {
        obj.insert(QString("retryInitialDelay"), ::OpenAPI::toJsonValue(m_retry_initial_delay));
    }
    if (m_sample_interval_isSet) {
        obj.insert(QString("sampleInterval"), ::OpenAPI::toJsonValue(m_sample_interval));
    }
    if (m_use_circuit_breaker_isSet) {
        obj.insert(QString("useCircuitBreaker"), ::OpenAPI::toJsonValue(m_use_circuit_breaker));
    }
    return obj;
}

qint32 OAIClientConfig::getBackoffFactor() const {
    return m_backoff_factor;
}
void OAIClientConfig::setBackoffFactor(const qint32 &backoff_factor) {
    m_backoff_factor = backoff_factor;
    m_backoff_factor_isSet = true;
}

bool OAIClientConfig::is_backoff_factor_Set() const{
    return m_backoff_factor_isSet;
}

bool OAIClientConfig::is_backoff_factor_Valid() const{
    return m_backoff_factor_isValid;
}

qint32 OAIClientConfig::getCallTimeout() const {
    return m_call_timeout;
}
void OAIClientConfig::setCallTimeout(const qint32 &call_timeout) {
    m_call_timeout = call_timeout;
    m_call_timeout_isSet = true;
}

bool OAIClientConfig::is_call_timeout_Set() const{
    return m_call_timeout_isSet;
}

bool OAIClientConfig::is_call_timeout_Valid() const{
    return m_call_timeout_isValid;
}

qint32 OAIClientConfig::getGlobalTimeout() const {
    return m_global_timeout;
}
void OAIClientConfig::setGlobalTimeout(const qint32 &global_timeout) {
    m_global_timeout = global_timeout;
    m_global_timeout_isSet = true;
}

bool OAIClientConfig::is_global_timeout_Set() const{
    return m_global_timeout_isSet;
}

bool OAIClientConfig::is_global_timeout_Valid() const{
    return m_global_timeout_isValid;
}

qint32 OAIClientConfig::getMaxErrors() const {
    return m_max_errors;
}
void OAIClientConfig::setMaxErrors(const qint32 &max_errors) {
    m_max_errors = max_errors;
    m_max_errors_isSet = true;
}

bool OAIClientConfig::is_max_errors_Set() const{
    return m_max_errors_isSet;
}

bool OAIClientConfig::is_max_errors_Valid() const{
    return m_max_errors_isValid;
}

qint32 OAIClientConfig::getRetries() const {
    return m_retries;
}
void OAIClientConfig::setRetries(const qint32 &retries) {
    m_retries = retries;
    m_retries_isSet = true;
}

bool OAIClientConfig::is_retries_Set() const{
    return m_retries_isSet;
}

bool OAIClientConfig::is_retries_Valid() const{
    return m_retries_isValid;
}

qint32 OAIClientConfig::getRetryInitialDelay() const {
    return m_retry_initial_delay;
}
void OAIClientConfig::setRetryInitialDelay(const qint32 &retry_initial_delay) {
    m_retry_initial_delay = retry_initial_delay;
    m_retry_initial_delay_isSet = true;
}

bool OAIClientConfig::is_retry_initial_delay_Set() const{
    return m_retry_initial_delay_isSet;
}

bool OAIClientConfig::is_retry_initial_delay_Valid() const{
    return m_retry_initial_delay_isValid;
}

qint32 OAIClientConfig::getSampleInterval() const {
    return m_sample_interval;
}
void OAIClientConfig::setSampleInterval(const qint32 &sample_interval) {
    m_sample_interval = sample_interval;
    m_sample_interval_isSet = true;
}

bool OAIClientConfig::is_sample_interval_Set() const{
    return m_sample_interval_isSet;
}

bool OAIClientConfig::is_sample_interval_Valid() const{
    return m_sample_interval_isValid;
}

bool OAIClientConfig::isUseCircuitBreaker() const {
    return m_use_circuit_breaker;
}
void OAIClientConfig::setUseCircuitBreaker(const bool &use_circuit_breaker) {
    m_use_circuit_breaker = use_circuit_breaker;
    m_use_circuit_breaker_isSet = true;
}

bool OAIClientConfig::is_use_circuit_breaker_Set() const{
    return m_use_circuit_breaker_isSet;
}

bool OAIClientConfig::is_use_circuit_breaker_Valid() const{
    return m_use_circuit_breaker_isValid;
}

bool OAIClientConfig::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_backoff_factor_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_call_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_global_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_errors_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_retries_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_retry_initial_delay_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sample_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_use_circuit_breaker_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIClientConfig::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_backoff_factor_isValid && m_call_timeout_isValid && m_global_timeout_isValid && m_max_errors_isValid && m_retries_isValid && m_retry_initial_delay_isValid && m_sample_interval_isValid && m_use_circuit_breaker_isValid && true;
}

} // namespace OpenAPI
