/**
 * Otoroshi Admin API
 * Admin API of the Otoroshi reverse proxy
 *
 * The version of the OpenAPI document: 1.5.0-dev
 * Contact: oss@maif.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGzip.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGzip::OAIGzip(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGzip::OAIGzip() {
    this->initializeModel();
}

OAIGzip::~OAIGzip() {}

void OAIGzip::initializeModel() {

    m_black_list_isSet = false;
    m_black_list_isValid = false;

    m_buffer_size_isSet = false;
    m_buffer_size_isValid = false;

    m_chunked_threshold_isSet = false;
    m_chunked_threshold_isValid = false;

    m_compression_level_isSet = false;
    m_compression_level_isValid = false;

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_excluded_patterns_isSet = false;
    m_excluded_patterns_isValid = false;

    m_white_list_isSet = false;
    m_white_list_isValid = false;
}

void OAIGzip::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGzip::fromJsonObject(QJsonObject json) {

    m_black_list_isValid = ::OpenAPI::fromJsonValue(m_black_list, json[QString("blackList")]);
    m_black_list_isSet = !json[QString("blackList")].isNull() && m_black_list_isValid;

    m_buffer_size_isValid = ::OpenAPI::fromJsonValue(m_buffer_size, json[QString("bufferSize")]);
    m_buffer_size_isSet = !json[QString("bufferSize")].isNull() && m_buffer_size_isValid;

    m_chunked_threshold_isValid = ::OpenAPI::fromJsonValue(m_chunked_threshold, json[QString("chunkedThreshold")]);
    m_chunked_threshold_isSet = !json[QString("chunkedThreshold")].isNull() && m_chunked_threshold_isValid;

    m_compression_level_isValid = ::OpenAPI::fromJsonValue(m_compression_level, json[QString("compressionLevel")]);
    m_compression_level_isSet = !json[QString("compressionLevel")].isNull() && m_compression_level_isValid;

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("enabled")]);
    m_enabled_isSet = !json[QString("enabled")].isNull() && m_enabled_isValid;

    m_excluded_patterns_isValid = ::OpenAPI::fromJsonValue(m_excluded_patterns, json[QString("excludedPatterns")]);
    m_excluded_patterns_isSet = !json[QString("excludedPatterns")].isNull() && m_excluded_patterns_isValid;

    m_white_list_isValid = ::OpenAPI::fromJsonValue(m_white_list, json[QString("whiteList")]);
    m_white_list_isSet = !json[QString("whiteList")].isNull() && m_white_list_isValid;
}

QString OAIGzip::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGzip::asJsonObject() const {
    QJsonObject obj;
    if (m_black_list.size() > 0) {
        obj.insert(QString("blackList"), ::OpenAPI::toJsonValue(m_black_list));
    }
    if (m_buffer_size_isSet) {
        obj.insert(QString("bufferSize"), ::OpenAPI::toJsonValue(m_buffer_size));
    }
    if (m_chunked_threshold_isSet) {
        obj.insert(QString("chunkedThreshold"), ::OpenAPI::toJsonValue(m_chunked_threshold));
    }
    if (m_compression_level_isSet) {
        obj.insert(QString("compressionLevel"), ::OpenAPI::toJsonValue(m_compression_level));
    }
    if (m_enabled_isSet) {
        obj.insert(QString("enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_excluded_patterns.size() > 0) {
        obj.insert(QString("excludedPatterns"), ::OpenAPI::toJsonValue(m_excluded_patterns));
    }
    if (m_white_list.size() > 0) {
        obj.insert(QString("whiteList"), ::OpenAPI::toJsonValue(m_white_list));
    }
    return obj;
}

QList<QString> OAIGzip::getBlackList() const {
    return m_black_list;
}
void OAIGzip::setBlackList(const QList<QString> &black_list) {
    m_black_list = black_list;
    m_black_list_isSet = true;
}

bool OAIGzip::is_black_list_Set() const{
    return m_black_list_isSet;
}

bool OAIGzip::is_black_list_Valid() const{
    return m_black_list_isValid;
}

qint64 OAIGzip::getBufferSize() const {
    return m_buffer_size;
}
void OAIGzip::setBufferSize(const qint64 &buffer_size) {
    m_buffer_size = buffer_size;
    m_buffer_size_isSet = true;
}

bool OAIGzip::is_buffer_size_Set() const{
    return m_buffer_size_isSet;
}

bool OAIGzip::is_buffer_size_Valid() const{
    return m_buffer_size_isValid;
}

qint64 OAIGzip::getChunkedThreshold() const {
    return m_chunked_threshold;
}
void OAIGzip::setChunkedThreshold(const qint64 &chunked_threshold) {
    m_chunked_threshold = chunked_threshold;
    m_chunked_threshold_isSet = true;
}

bool OAIGzip::is_chunked_threshold_Set() const{
    return m_chunked_threshold_isSet;
}

bool OAIGzip::is_chunked_threshold_Valid() const{
    return m_chunked_threshold_isValid;
}

qint32 OAIGzip::getCompressionLevel() const {
    return m_compression_level;
}
void OAIGzip::setCompressionLevel(const qint32 &compression_level) {
    m_compression_level = compression_level;
    m_compression_level_isSet = true;
}

bool OAIGzip::is_compression_level_Set() const{
    return m_compression_level_isSet;
}

bool OAIGzip::is_compression_level_Valid() const{
    return m_compression_level_isValid;
}

bool OAIGzip::isEnabled() const {
    return m_enabled;
}
void OAIGzip::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAIGzip::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAIGzip::is_enabled_Valid() const{
    return m_enabled_isValid;
}

QList<QString> OAIGzip::getExcludedPatterns() const {
    return m_excluded_patterns;
}
void OAIGzip::setExcludedPatterns(const QList<QString> &excluded_patterns) {
    m_excluded_patterns = excluded_patterns;
    m_excluded_patterns_isSet = true;
}

bool OAIGzip::is_excluded_patterns_Set() const{
    return m_excluded_patterns_isSet;
}

bool OAIGzip::is_excluded_patterns_Valid() const{
    return m_excluded_patterns_isValid;
}

QList<QString> OAIGzip::getWhiteList() const {
    return m_white_list;
}
void OAIGzip::setWhiteList(const QList<QString> &white_list) {
    m_white_list = white_list;
    m_white_list_isSet = true;
}

bool OAIGzip::is_white_list_Set() const{
    return m_white_list_isSet;
}

bool OAIGzip::is_white_list_Valid() const{
    return m_white_list_isValid;
}

bool OAIGzip::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_black_list.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_buffer_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_chunked_threshold_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_compression_level_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_excluded_patterns.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_white_list.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGzip::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_black_list_isValid && m_buffer_size_isValid && m_chunked_threshold_isValid && m_compression_level_isValid && m_enabled_isValid && m_excluded_patterns_isValid && m_white_list_isValid && true;
}

} // namespace OpenAPI
