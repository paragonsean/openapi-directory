/*
 * DRACOON API
 * REST Web Services for DRACOON<br><br>This page provides an overview of all available and documented DRACOON APIs, which are grouped by tags.<br>Each tag provides a collection of APIs that are intended for a specific area of the DRACOON.<br><br><a title='Developer Information' href='https://developer.dracoon.com'>Developer Information</a>&emsp;&emsp;<a title='Get SDKs on GitHub' href='https://github.com/dracoon'>Get SDKs on GitHub</a><br><br><a title='Terms of service' href='https://www.dracoon.com/terms/general-terms-and-conditions/'>Terms of service</a>
 *
 * The version of the OpenAPI document: 4.42.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.EncryptionInfo;
import org.openapitools.client.model.NodePermissions;
import org.openapitools.client.model.UserInfo;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Node information (Node can be a room, folder or file)
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:04:27.439567-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Node {
  public static final String SERIALIZED_NAME_AUTH_PARENT_ID = "authParentId";
  @SerializedName(SERIALIZED_NAME_AUTH_PARENT_ID)
  private Long authParentId;

  public static final String SERIALIZED_NAME_BRANCH_VERSION = "branchVersion";
  @SerializedName(SERIALIZED_NAME_BRANCH_VERSION)
  private Long branchVersion;

  public static final String SERIALIZED_NAME_CHILDREN = "children";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CHILDREN)
  private List<Node> children = new ArrayList<>();

  /**
   * Classification ID:  * &#x60;1&#x60; - public  * &#x60;2&#x60; - internal  * &#x60;3&#x60; - confidential  * &#x60;4&#x60; - strictly confidential
   */
  @JsonAdapter(ClassificationEnum.Adapter.class)
  public enum ClassificationEnum {
    NUMBER_1(1),
    
    NUMBER_2(2),
    
    NUMBER_3(3),
    
    NUMBER_4(4);

    private Integer value;

    ClassificationEnum(Integer value) {
      this.value = value;
    }

    public Integer getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ClassificationEnum fromValue(Integer value) {
      for (ClassificationEnum b : ClassificationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ClassificationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClassificationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClassificationEnum read(final JsonReader jsonReader) throws IOException {
        Integer value =  jsonReader.nextInt();
        return ClassificationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      Integer value = jsonElement.getAsInt();
      ClassificationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CLASSIFICATION = "classification";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION)
  private ClassificationEnum classification;

  public static final String SERIALIZED_NAME_CNT_CHILDREN = "cntChildren";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CNT_CHILDREN)
  private Integer cntChildren;

  public static final String SERIALIZED_NAME_CNT_COMMENTS = "cntComments";
  @SerializedName(SERIALIZED_NAME_CNT_COMMENTS)
  private Integer cntComments;

  public static final String SERIALIZED_NAME_CNT_DELETED_VERSIONS = "cntDeletedVersions";
  @SerializedName(SERIALIZED_NAME_CNT_DELETED_VERSIONS)
  private Integer cntDeletedVersions;

  public static final String SERIALIZED_NAME_CNT_DOWNLOAD_SHARES = "cntDownloadShares";
  @SerializedName(SERIALIZED_NAME_CNT_DOWNLOAD_SHARES)
  private Integer cntDownloadShares;

  public static final String SERIALIZED_NAME_CNT_FILES = "cntFiles";
  @SerializedName(SERIALIZED_NAME_CNT_FILES)
  private Integer cntFiles;

  public static final String SERIALIZED_NAME_CNT_FOLDERS = "cntFolders";
  @SerializedName(SERIALIZED_NAME_CNT_FOLDERS)
  private Integer cntFolders;

  public static final String SERIALIZED_NAME_CNT_ROOMS = "cntRooms";
  @SerializedName(SERIALIZED_NAME_CNT_ROOMS)
  private Integer cntRooms;

  public static final String SERIALIZED_NAME_CNT_UPLOAD_SHARES = "cntUploadShares";
  @SerializedName(SERIALIZED_NAME_CNT_UPLOAD_SHARES)
  private Integer cntUploadShares;

  public static final String SERIALIZED_NAME_CREATED_AT = "createdAt";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_CREATED_BY = "createdBy";
  @SerializedName(SERIALIZED_NAME_CREATED_BY)
  private UserInfo createdBy;

  public static final String SERIALIZED_NAME_ENCRYPTION_INFO = "encryptionInfo";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_INFO)
  private EncryptionInfo encryptionInfo;

  public static final String SERIALIZED_NAME_EXPIRE_AT = "expireAt";
  @SerializedName(SERIALIZED_NAME_EXPIRE_AT)
  private OffsetDateTime expireAt;

  public static final String SERIALIZED_NAME_FILE_TYPE = "fileType";
  @SerializedName(SERIALIZED_NAME_FILE_TYPE)
  private String fileType;

  public static final String SERIALIZED_NAME_HAS_ACTIVITIES_LOG = "hasActivitiesLog";
  @SerializedName(SERIALIZED_NAME_HAS_ACTIVITIES_LOG)
  private Boolean hasActivitiesLog = true;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private String hash;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_INHERIT_PERMISSIONS = "inheritPermissions";
  @SerializedName(SERIALIZED_NAME_INHERIT_PERMISSIONS)
  private Boolean inheritPermissions;

  public static final String SERIALIZED_NAME_IS_BROWSABLE = "isBrowsable";
  @SerializedName(SERIALIZED_NAME_IS_BROWSABLE)
  private Boolean isBrowsable;

  public static final String SERIALIZED_NAME_IS_ENCRYPTED = "isEncrypted";
  @SerializedName(SERIALIZED_NAME_IS_ENCRYPTED)
  private Boolean isEncrypted;

  public static final String SERIALIZED_NAME_IS_FAVORITE = "isFavorite";
  @SerializedName(SERIALIZED_NAME_IS_FAVORITE)
  private Boolean isFavorite;

  public static final String SERIALIZED_NAME_MEDIA_TOKEN = "mediaToken";
  @SerializedName(SERIALIZED_NAME_MEDIA_TOKEN)
  private String mediaToken;

  public static final String SERIALIZED_NAME_MEDIA_TYPE = "mediaType";
  @SerializedName(SERIALIZED_NAME_MEDIA_TYPE)
  private String mediaType;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NOTES = "notes";
  @SerializedName(SERIALIZED_NAME_NOTES)
  private String notes;

  public static final String SERIALIZED_NAME_PARENT_ID = "parentId";
  @SerializedName(SERIALIZED_NAME_PARENT_ID)
  private Long parentId;

  public static final String SERIALIZED_NAME_PARENT_PATH = "parentPath";
  @SerializedName(SERIALIZED_NAME_PARENT_PATH)
  private String parentPath;

  public static final String SERIALIZED_NAME_PERMISSIONS = "permissions";
  @SerializedName(SERIALIZED_NAME_PERMISSIONS)
  private NodePermissions permissions;

  public static final String SERIALIZED_NAME_QUOTA = "quota";
  @SerializedName(SERIALIZED_NAME_QUOTA)
  private Long quota;

  public static final String SERIALIZED_NAME_RECYCLE_BIN_RETENTION_PERIOD = "recycleBinRetentionPeriod";
  @SerializedName(SERIALIZED_NAME_RECYCLE_BIN_RETENTION_PERIOD)
  private Integer recycleBinRetentionPeriod;

  public static final String SERIALIZED_NAME_REFERENCE_ID = "referenceId";
  @SerializedName(SERIALIZED_NAME_REFERENCE_ID)
  private Long referenceId;

  public static final String SERIALIZED_NAME_SIZE = "size";
  @SerializedName(SERIALIZED_NAME_SIZE)
  private Long size;

  public static final String SERIALIZED_NAME_TIMESTAMP_CREATION = "timestampCreation";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP_CREATION)
  private OffsetDateTime timestampCreation;

  public static final String SERIALIZED_NAME_TIMESTAMP_MODIFICATION = "timestampModification";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP_MODIFICATION)
  private OffsetDateTime timestampModification;

  /**
   * Node type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    ROOM("room"),
    
    FOLDER("folder"),
    
    FILE("file");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updatedAt";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_UPDATED_BY = "updatedBy";
  @SerializedName(SERIALIZED_NAME_UPDATED_BY)
  private UserInfo updatedBy;

  public Node() {
  }

  public Node authParentId(Long authParentId) {
    this.authParentId = authParentId;
    return this;
  }

  /**
   * &amp;#128640; Since v4.15.0  Auth parent room ID
   * @return authParentId
   */
  @javax.annotation.Nullable
  public Long getAuthParentId() {
    return authParentId;
  }

  public void setAuthParentId(Long authParentId) {
    this.authParentId = authParentId;
  }


  public Node branchVersion(Long branchVersion) {
    this.branchVersion = branchVersion;
    return this;
  }

  /**
   * Version of last change in this node or a node further down the tree.
   * @return branchVersion
   */
  @javax.annotation.Nullable
  public Long getBranchVersion() {
    return branchVersion;
  }

  public void setBranchVersion(Long branchVersion) {
    this.branchVersion = branchVersion;
  }


  @Deprecated
  public Node children(List<Node> children) {
    this.children = children;
    return this;
  }

  public Node addChildrenItem(Node childrenItem) {
    if (this.children == null) {
      this.children = new ArrayList<>();
    }
    this.children.add(childrenItem);
    return this;
  }

  /**
   * &amp;#128679; Deprecated since v4.10.0  Child nodes list (if requested)  (for rooms / folders only)
   * @return children
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<Node> getChildren() {
    return children;
  }

  @Deprecated
  public void setChildren(List<Node> children) {
    this.children = children;
  }


  public Node classification(ClassificationEnum classification) {
    this.classification = classification;
    return this;
  }

  /**
   * Classification ID:  * &#x60;1&#x60; - public  * &#x60;2&#x60; - internal  * &#x60;3&#x60; - confidential  * &#x60;4&#x60; - strictly confidential
   * @return classification
   */
  @javax.annotation.Nullable
  public ClassificationEnum getClassification() {
    return classification;
  }

  public void setClassification(ClassificationEnum classification) {
    this.classification = classification;
  }


  @Deprecated
  public Node cntChildren(Integer cntChildren) {
    this.cntChildren = cntChildren;
    return this;
  }

  /**
   * &amp;#128679; Deprecated since v4.11.0  Number of direct children  (no recursion; for rooms / folders only)
   * @return cntChildren
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Integer getCntChildren() {
    return cntChildren;
  }

  @Deprecated
  public void setCntChildren(Integer cntChildren) {
    this.cntChildren = cntChildren;
  }


  public Node cntComments(Integer cntComments) {
    this.cntComments = cntComments;
    return this;
  }

  /**
   * Returns the number of comments of this node.
   * @return cntComments
   */
  @javax.annotation.Nullable
  public Integer getCntComments() {
    return cntComments;
  }

  public void setCntComments(Integer cntComments) {
    this.cntComments = cntComments;
  }


  public Node cntDeletedVersions(Integer cntDeletedVersions) {
    this.cntDeletedVersions = cntDeletedVersions;
    return this;
  }

  /**
   * Number of deleted versions of this file / folder  (for rooms / folders only)
   * @return cntDeletedVersions
   */
  @javax.annotation.Nullable
  public Integer getCntDeletedVersions() {
    return cntDeletedVersions;
  }

  public void setCntDeletedVersions(Integer cntDeletedVersions) {
    this.cntDeletedVersions = cntDeletedVersions;
  }


  public Node cntDownloadShares(Integer cntDownloadShares) {
    this.cntDownloadShares = cntDownloadShares;
    return this;
  }

  /**
   * Returns the number of Download Shares of this node.
   * @return cntDownloadShares
   */
  @javax.annotation.Nullable
  public Integer getCntDownloadShares() {
    return cntDownloadShares;
  }

  public void setCntDownloadShares(Integer cntDownloadShares) {
    this.cntDownloadShares = cntDownloadShares;
  }


  public Node cntFiles(Integer cntFiles) {
    this.cntFiles = cntFiles;
    return this;
  }

  /**
   * &amp;#128640; Since v4.11.0  Amount of direct child files where this node is the parent node  (no recursion; for rooms / folders only)
   * @return cntFiles
   */
  @javax.annotation.Nullable
  public Integer getCntFiles() {
    return cntFiles;
  }

  public void setCntFiles(Integer cntFiles) {
    this.cntFiles = cntFiles;
  }


  public Node cntFolders(Integer cntFolders) {
    this.cntFolders = cntFolders;
    return this;
  }

  /**
   * &amp;#128640; Since v4.11.0  Amount of direct child folders where this node is the parent node  (no recursion; for rooms / folders only)
   * @return cntFolders
   */
  @javax.annotation.Nullable
  public Integer getCntFolders() {
    return cntFolders;
  }

  public void setCntFolders(Integer cntFolders) {
    this.cntFolders = cntFolders;
  }


  public Node cntRooms(Integer cntRooms) {
    this.cntRooms = cntRooms;
    return this;
  }

  /**
   * &amp;#128640; Since v4.11.0  Amount of direct child rooms where this node is the parent node  (no recursion; for rooms only)
   * @return cntRooms
   */
  @javax.annotation.Nullable
  public Integer getCntRooms() {
    return cntRooms;
  }

  public void setCntRooms(Integer cntRooms) {
    this.cntRooms = cntRooms;
  }


  public Node cntUploadShares(Integer cntUploadShares) {
    this.cntUploadShares = cntUploadShares;
    return this;
  }

  /**
   * Returns the number of Upload Shares of this node.
   * @return cntUploadShares
   */
  @javax.annotation.Nullable
  public Integer getCntUploadShares() {
    return cntUploadShares;
  }

  public void setCntUploadShares(Integer cntUploadShares) {
    this.cntUploadShares = cntUploadShares;
  }


  public Node createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

  /**
   * Creation date
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public Node createdBy(UserInfo createdBy) {
    this.createdBy = createdBy;
    return this;
  }

  /**
   * Get createdBy
   * @return createdBy
   */
  @javax.annotation.Nullable
  public UserInfo getCreatedBy() {
    return createdBy;
  }

  public void setCreatedBy(UserInfo createdBy) {
    this.createdBy = createdBy;
  }


  public Node encryptionInfo(EncryptionInfo encryptionInfo) {
    this.encryptionInfo = encryptionInfo;
    return this;
  }

  /**
   * Get encryptionInfo
   * @return encryptionInfo
   */
  @javax.annotation.Nullable
  public EncryptionInfo getEncryptionInfo() {
    return encryptionInfo;
  }

  public void setEncryptionInfo(EncryptionInfo encryptionInfo) {
    this.encryptionInfo = encryptionInfo;
  }


  public Node expireAt(OffsetDateTime expireAt) {
    this.expireAt = expireAt;
    return this;
  }

  /**
   * Expiration date
   * @return expireAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExpireAt() {
    return expireAt;
  }

  public void setExpireAt(OffsetDateTime expireAt) {
    this.expireAt = expireAt;
  }


  public Node fileType(String fileType) {
    this.fileType = fileType;
    return this;
  }

  /**
   * File type / extension (for files only)
   * @return fileType
   */
  @javax.annotation.Nullable
  public String getFileType() {
    return fileType;
  }

  public void setFileType(String fileType) {
    this.fileType = fileType;
  }


  public Node hasActivitiesLog(Boolean hasActivitiesLog) {
    this.hasActivitiesLog = hasActivitiesLog;
    return this;
  }

  /**
   * Is activities log active (for rooms only)
   * @return hasActivitiesLog
   */
  @javax.annotation.Nullable
  public Boolean getHasActivitiesLog() {
    return hasActivitiesLog;
  }

  public void setHasActivitiesLog(Boolean hasActivitiesLog) {
    this.hasActivitiesLog = hasActivitiesLog;
  }


  public Node hash(String hash) {
    this.hash = hash;
    return this;
  }

  /**
   * MD5 hash of file
   * @return hash
   */
  @javax.annotation.Nullable
  public String getHash() {
    return hash;
  }

  public void setHash(String hash) {
    this.hash = hash;
  }


  public Node id(Long id) {
    this.id = id;
    return this;
  }

  /**
   * Node ID
   * @return id
   */
  @javax.annotation.Nonnull
  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }


  public Node inheritPermissions(Boolean inheritPermissions) {
    this.inheritPermissions = inheritPermissions;
    return this;
  }

  /**
   * Inherit permissions from parent room  (default: &#x60;false&#x60; if &#x60;parentId&#x60; is &#x60;0&#x60;; otherwise: &#x60;true&#x60;)
   * @return inheritPermissions
   */
  @javax.annotation.Nullable
  public Boolean getInheritPermissions() {
    return inheritPermissions;
  }

  public void setInheritPermissions(Boolean inheritPermissions) {
    this.inheritPermissions = inheritPermissions;
  }


  public Node isBrowsable(Boolean isBrowsable) {
    this.isBrowsable = isBrowsable;
    return this;
  }

  /**
   * &amp;#128640; Since v4.11.0  Determines whether node is browsable by client (for rooms only)
   * @return isBrowsable
   */
  @javax.annotation.Nullable
  public Boolean getIsBrowsable() {
    return isBrowsable;
  }

  public void setIsBrowsable(Boolean isBrowsable) {
    this.isBrowsable = isBrowsable;
  }


  public Node isEncrypted(Boolean isEncrypted) {
    this.isEncrypted = isEncrypted;
    return this;
  }

  /**
   * Encryption state
   * @return isEncrypted
   */
  @javax.annotation.Nullable
  public Boolean getIsEncrypted() {
    return isEncrypted;
  }

  public void setIsEncrypted(Boolean isEncrypted) {
    this.isEncrypted = isEncrypted;
  }


  public Node isFavorite(Boolean isFavorite) {
    this.isFavorite = isFavorite;
    return this;
  }

  /**
   * Node is marked as favorite (for rooms / folders only)
   * @return isFavorite
   */
  @javax.annotation.Nullable
  public Boolean getIsFavorite() {
    return isFavorite;
  }

  public void setIsFavorite(Boolean isFavorite) {
    this.isFavorite = isFavorite;
  }


  public Node mediaToken(String mediaToken) {
    this.mediaToken = mediaToken;
    return this;
  }

  /**
   * Media server media token
   * @return mediaToken
   */
  @javax.annotation.Nullable
  public String getMediaToken() {
    return mediaToken;
  }

  public void setMediaToken(String mediaToken) {
    this.mediaToken = mediaToken;
  }


  public Node mediaType(String mediaType) {
    this.mediaType = mediaType;
    return this;
  }

  /**
   * File media type (for files only)
   * @return mediaType
   */
  @javax.annotation.Nullable
  public String getMediaType() {
    return mediaType;
  }

  public void setMediaType(String mediaType) {
    this.mediaType = mediaType;
  }


  public Node name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Node notes(String notes) {
    this.notes = notes;
    return this;
  }

  /**
   * User notes
   * @return notes
   */
  @javax.annotation.Nullable
  public String getNotes() {
    return notes;
  }

  public void setNotes(String notes) {
    this.notes = notes;
  }


  public Node parentId(Long parentId) {
    this.parentId = parentId;
    return this;
  }

  /**
   * Parent node ID (room or folder)
   * @return parentId
   */
  @javax.annotation.Nullable
  public Long getParentId() {
    return parentId;
  }

  public void setParentId(Long parentId) {
    this.parentId = parentId;
  }


  public Node parentPath(String parentPath) {
    this.parentPath = parentPath;
    return this;
  }

  /**
   * Parent node path  &#x60;/&#x60; if node is a root node (room)
   * @return parentPath
   */
  @javax.annotation.Nullable
  public String getParentPath() {
    return parentPath;
  }

  public void setParentPath(String parentPath) {
    this.parentPath = parentPath;
  }


  public Node permissions(NodePermissions permissions) {
    this.permissions = permissions;
    return this;
  }

  /**
   * Get permissions
   * @return permissions
   */
  @javax.annotation.Nullable
  public NodePermissions getPermissions() {
    return permissions;
  }

  public void setPermissions(NodePermissions permissions) {
    this.permissions = permissions;
  }


  public Node quota(Long quota) {
    this.quota = quota;
    return this;
  }

  /**
   * Quota in byte
   * @return quota
   */
  @javax.annotation.Nullable
  public Long getQuota() {
    return quota;
  }

  public void setQuota(Long quota) {
    this.quota = quota;
  }


  public Node recycleBinRetentionPeriod(Integer recycleBinRetentionPeriod) {
    this.recycleBinRetentionPeriod = recycleBinRetentionPeriod;
    return this;
  }

  /**
   * Retention period for deleted nodes in days
   * minimum: 0
   * maximum: 9999
   * @return recycleBinRetentionPeriod
   */
  @javax.annotation.Nullable
  public Integer getRecycleBinRetentionPeriod() {
    return recycleBinRetentionPeriod;
  }

  public void setRecycleBinRetentionPeriod(Integer recycleBinRetentionPeriod) {
    this.recycleBinRetentionPeriod = recycleBinRetentionPeriod;
  }


  public Node referenceId(Long referenceId) {
    this.referenceId = referenceId;
    return this;
  }

  /**
   * &amp;#128640; Since v4.37.0  Reference ID. Identical across all versions of a file
   * @return referenceId
   */
  @javax.annotation.Nullable
  public Long getReferenceId() {
    return referenceId;
  }

  public void setReferenceId(Long referenceId) {
    this.referenceId = referenceId;
  }


  public Node size(Long size) {
    this.size = size;
    return this;
  }

  /**
   * Node size in byte
   * @return size
   */
  @javax.annotation.Nullable
  public Long getSize() {
    return size;
  }

  public void setSize(Long size) {
    this.size = size;
  }


  public Node timestampCreation(OffsetDateTime timestampCreation) {
    this.timestampCreation = timestampCreation;
    return this;
  }

  /**
   * &amp;#128640; Since v4.22.0  Time the node was created on external file system
   * @return timestampCreation
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTimestampCreation() {
    return timestampCreation;
  }

  public void setTimestampCreation(OffsetDateTime timestampCreation) {
    this.timestampCreation = timestampCreation;
  }


  public Node timestampModification(OffsetDateTime timestampModification) {
    this.timestampModification = timestampModification;
    return this;
  }

  /**
   * &amp;#128640; Since v4.22.0  Time the content of a node was last modified on external file system
   * @return timestampModification
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTimestampModification() {
    return timestampModification;
  }

  public void setTimestampModification(OffsetDateTime timestampModification) {
    this.timestampModification = timestampModification;
  }


  public Node type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * Node type
   * @return type
   */
  @javax.annotation.Nonnull
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  public Node updatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
    return this;
  }

  /**
   * Modification date
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }

  public void setUpdatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
  }


  public Node updatedBy(UserInfo updatedBy) {
    this.updatedBy = updatedBy;
    return this;
  }

  /**
   * Get updatedBy
   * @return updatedBy
   */
  @javax.annotation.Nullable
  public UserInfo getUpdatedBy() {
    return updatedBy;
  }

  public void setUpdatedBy(UserInfo updatedBy) {
    this.updatedBy = updatedBy;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Node node = (Node) o;
    return Objects.equals(this.authParentId, node.authParentId) &&
        Objects.equals(this.branchVersion, node.branchVersion) &&
        Objects.equals(this.children, node.children) &&
        Objects.equals(this.classification, node.classification) &&
        Objects.equals(this.cntChildren, node.cntChildren) &&
        Objects.equals(this.cntComments, node.cntComments) &&
        Objects.equals(this.cntDeletedVersions, node.cntDeletedVersions) &&
        Objects.equals(this.cntDownloadShares, node.cntDownloadShares) &&
        Objects.equals(this.cntFiles, node.cntFiles) &&
        Objects.equals(this.cntFolders, node.cntFolders) &&
        Objects.equals(this.cntRooms, node.cntRooms) &&
        Objects.equals(this.cntUploadShares, node.cntUploadShares) &&
        Objects.equals(this.createdAt, node.createdAt) &&
        Objects.equals(this.createdBy, node.createdBy) &&
        Objects.equals(this.encryptionInfo, node.encryptionInfo) &&
        Objects.equals(this.expireAt, node.expireAt) &&
        Objects.equals(this.fileType, node.fileType) &&
        Objects.equals(this.hasActivitiesLog, node.hasActivitiesLog) &&
        Objects.equals(this.hash, node.hash) &&
        Objects.equals(this.id, node.id) &&
        Objects.equals(this.inheritPermissions, node.inheritPermissions) &&
        Objects.equals(this.isBrowsable, node.isBrowsable) &&
        Objects.equals(this.isEncrypted, node.isEncrypted) &&
        Objects.equals(this.isFavorite, node.isFavorite) &&
        Objects.equals(this.mediaToken, node.mediaToken) &&
        Objects.equals(this.mediaType, node.mediaType) &&
        Objects.equals(this.name, node.name) &&
        Objects.equals(this.notes, node.notes) &&
        Objects.equals(this.parentId, node.parentId) &&
        Objects.equals(this.parentPath, node.parentPath) &&
        Objects.equals(this.permissions, node.permissions) &&
        Objects.equals(this.quota, node.quota) &&
        Objects.equals(this.recycleBinRetentionPeriod, node.recycleBinRetentionPeriod) &&
        Objects.equals(this.referenceId, node.referenceId) &&
        Objects.equals(this.size, node.size) &&
        Objects.equals(this.timestampCreation, node.timestampCreation) &&
        Objects.equals(this.timestampModification, node.timestampModification) &&
        Objects.equals(this.type, node.type) &&
        Objects.equals(this.updatedAt, node.updatedAt) &&
        Objects.equals(this.updatedBy, node.updatedBy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authParentId, branchVersion, children, classification, cntChildren, cntComments, cntDeletedVersions, cntDownloadShares, cntFiles, cntFolders, cntRooms, cntUploadShares, createdAt, createdBy, encryptionInfo, expireAt, fileType, hasActivitiesLog, hash, id, inheritPermissions, isBrowsable, isEncrypted, isFavorite, mediaToken, mediaType, name, notes, parentId, parentPath, permissions, quota, recycleBinRetentionPeriod, referenceId, size, timestampCreation, timestampModification, type, updatedAt, updatedBy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Node {\n");
    sb.append("    authParentId: ").append(toIndentedString(authParentId)).append("\n");
    sb.append("    branchVersion: ").append(toIndentedString(branchVersion)).append("\n");
    sb.append("    children: ").append(toIndentedString(children)).append("\n");
    sb.append("    classification: ").append(toIndentedString(classification)).append("\n");
    sb.append("    cntChildren: ").append(toIndentedString(cntChildren)).append("\n");
    sb.append("    cntComments: ").append(toIndentedString(cntComments)).append("\n");
    sb.append("    cntDeletedVersions: ").append(toIndentedString(cntDeletedVersions)).append("\n");
    sb.append("    cntDownloadShares: ").append(toIndentedString(cntDownloadShares)).append("\n");
    sb.append("    cntFiles: ").append(toIndentedString(cntFiles)).append("\n");
    sb.append("    cntFolders: ").append(toIndentedString(cntFolders)).append("\n");
    sb.append("    cntRooms: ").append(toIndentedString(cntRooms)).append("\n");
    sb.append("    cntUploadShares: ").append(toIndentedString(cntUploadShares)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    encryptionInfo: ").append(toIndentedString(encryptionInfo)).append("\n");
    sb.append("    expireAt: ").append(toIndentedString(expireAt)).append("\n");
    sb.append("    fileType: ").append(toIndentedString(fileType)).append("\n");
    sb.append("    hasActivitiesLog: ").append(toIndentedString(hasActivitiesLog)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritPermissions: ").append(toIndentedString(inheritPermissions)).append("\n");
    sb.append("    isBrowsable: ").append(toIndentedString(isBrowsable)).append("\n");
    sb.append("    isEncrypted: ").append(toIndentedString(isEncrypted)).append("\n");
    sb.append("    isFavorite: ").append(toIndentedString(isFavorite)).append("\n");
    sb.append("    mediaToken: ").append(toIndentedString(mediaToken)).append("\n");
    sb.append("    mediaType: ").append(toIndentedString(mediaType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    notes: ").append(toIndentedString(notes)).append("\n");
    sb.append("    parentId: ").append(toIndentedString(parentId)).append("\n");
    sb.append("    parentPath: ").append(toIndentedString(parentPath)).append("\n");
    sb.append("    permissions: ").append(toIndentedString(permissions)).append("\n");
    sb.append("    quota: ").append(toIndentedString(quota)).append("\n");
    sb.append("    recycleBinRetentionPeriod: ").append(toIndentedString(recycleBinRetentionPeriod)).append("\n");
    sb.append("    referenceId: ").append(toIndentedString(referenceId)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    timestampCreation: ").append(toIndentedString(timestampCreation)).append("\n");
    sb.append("    timestampModification: ").append(toIndentedString(timestampModification)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    updatedBy: ").append(toIndentedString(updatedBy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("authParentId");
    openapiFields.add("branchVersion");
    openapiFields.add("children");
    openapiFields.add("classification");
    openapiFields.add("cntChildren");
    openapiFields.add("cntComments");
    openapiFields.add("cntDeletedVersions");
    openapiFields.add("cntDownloadShares");
    openapiFields.add("cntFiles");
    openapiFields.add("cntFolders");
    openapiFields.add("cntRooms");
    openapiFields.add("cntUploadShares");
    openapiFields.add("createdAt");
    openapiFields.add("createdBy");
    openapiFields.add("encryptionInfo");
    openapiFields.add("expireAt");
    openapiFields.add("fileType");
    openapiFields.add("hasActivitiesLog");
    openapiFields.add("hash");
    openapiFields.add("id");
    openapiFields.add("inheritPermissions");
    openapiFields.add("isBrowsable");
    openapiFields.add("isEncrypted");
    openapiFields.add("isFavorite");
    openapiFields.add("mediaToken");
    openapiFields.add("mediaType");
    openapiFields.add("name");
    openapiFields.add("notes");
    openapiFields.add("parentId");
    openapiFields.add("parentPath");
    openapiFields.add("permissions");
    openapiFields.add("quota");
    openapiFields.add("recycleBinRetentionPeriod");
    openapiFields.add("referenceId");
    openapiFields.add("size");
    openapiFields.add("timestampCreation");
    openapiFields.add("timestampModification");
    openapiFields.add("type");
    openapiFields.add("updatedAt");
    openapiFields.add("updatedBy");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Node
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Node.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Node is not found in the empty JSON string", Node.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Node.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Node` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Node.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("children") != null && !jsonObj.get("children").isJsonNull()) {
        JsonArray jsonArraychildren = jsonObj.getAsJsonArray("children");
        if (jsonArraychildren != null) {
          // ensure the json data is an array
          if (!jsonObj.get("children").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `children` to be an array in the JSON string but got `%s`", jsonObj.get("children").toString()));
          }

          // validate the optional field `children` (array)
          for (int i = 0; i < jsonArraychildren.size(); i++) {
            Node.validateJsonElement(jsonArraychildren.get(i));
          };
        }
      }
      // validate the optional field `classification`
      if (jsonObj.get("classification") != null && !jsonObj.get("classification").isJsonNull()) {
        ClassificationEnum.validateJsonElement(jsonObj.get("classification"));
      }
      // validate the optional field `createdBy`
      if (jsonObj.get("createdBy") != null && !jsonObj.get("createdBy").isJsonNull()) {
        UserInfo.validateJsonElement(jsonObj.get("createdBy"));
      }
      // validate the optional field `encryptionInfo`
      if (jsonObj.get("encryptionInfo") != null && !jsonObj.get("encryptionInfo").isJsonNull()) {
        EncryptionInfo.validateJsonElement(jsonObj.get("encryptionInfo"));
      }
      if ((jsonObj.get("fileType") != null && !jsonObj.get("fileType").isJsonNull()) && !jsonObj.get("fileType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileType").toString()));
      }
      if ((jsonObj.get("hash") != null && !jsonObj.get("hash").isJsonNull()) && !jsonObj.get("hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hash").toString()));
      }
      if ((jsonObj.get("mediaToken") != null && !jsonObj.get("mediaToken").isJsonNull()) && !jsonObj.get("mediaToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mediaToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mediaToken").toString()));
      }
      if ((jsonObj.get("mediaType") != null && !jsonObj.get("mediaType").isJsonNull()) && !jsonObj.get("mediaType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mediaType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mediaType").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("notes") != null && !jsonObj.get("notes").isJsonNull()) && !jsonObj.get("notes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `notes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("notes").toString()));
      }
      if ((jsonObj.get("parentPath") != null && !jsonObj.get("parentPath").isJsonNull()) && !jsonObj.get("parentPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parentPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parentPath").toString()));
      }
      // validate the optional field `permissions`
      if (jsonObj.get("permissions") != null && !jsonObj.get("permissions").isJsonNull()) {
        NodePermissions.validateJsonElement(jsonObj.get("permissions"));
      }
      if (!jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the required field `type`
      TypeEnum.validateJsonElement(jsonObj.get("type"));
      // validate the optional field `updatedBy`
      if (jsonObj.get("updatedBy") != null && !jsonObj.get("updatedBy").isJsonNull()) {
        UserInfo.validateJsonElement(jsonObj.get("updatedBy"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Node.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Node' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Node> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Node.class));

       return (TypeAdapter<T>) new TypeAdapter<Node>() {
           @Override
           public void write(JsonWriter out, Node value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Node read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Node given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Node
   * @throws IOException if the JSON string is invalid with respect to Node
   */
  public static Node fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Node.class);
  }

  /**
   * Convert an instance of Node to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

