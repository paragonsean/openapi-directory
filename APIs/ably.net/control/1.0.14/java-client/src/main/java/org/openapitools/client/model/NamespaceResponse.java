/*
 * Control API v1
 * Use the Control API to manage your applications, namespaces, keys, queues, rules, and more.  Detailed information on using this API can be found in the Ably <a href=\"https://ably.com/documentation/control-api\">developer documentation</a>.  Control API is currently in Beta. 
 *
 * The version of the OpenAPI document: 1.0.14
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * NamespaceResponse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:29:58.065790-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NamespaceResponse {
  public static final String SERIALIZED_NAME_AUTHENTICATED = "authenticated";
  @SerializedName(SERIALIZED_NAME_AUTHENTICATED)
  private Boolean authenticated = false;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private Integer created;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_MODIFIED = "modified";
  @SerializedName(SERIALIZED_NAME_MODIFIED)
  private Integer modified;

  public static final String SERIALIZED_NAME_PERSIST_LAST = "persistLast";
  @SerializedName(SERIALIZED_NAME_PERSIST_LAST)
  private Boolean persistLast = false;

  public static final String SERIALIZED_NAME_PERSISTED = "persisted";
  @SerializedName(SERIALIZED_NAME_PERSISTED)
  private Boolean persisted = false;

  public static final String SERIALIZED_NAME_PUSH_ENABLED = "pushEnabled";
  @SerializedName(SERIALIZED_NAME_PUSH_ENABLED)
  private Boolean pushEnabled = false;

  public static final String SERIALIZED_NAME_TLS_ONLY = "tlsOnly";
  @SerializedName(SERIALIZED_NAME_TLS_ONLY)
  private Boolean tlsOnly = false;

  public NamespaceResponse() {
  }

  public NamespaceResponse authenticated(Boolean authenticated) {
    this.authenticated = authenticated;
    return this;
  }

  /**
   * If &#x60;true&#x60;, clients will not be permitted to use (including to attach, publish, or subscribe) any channels within this namespace unless they are identified, that is, authenticated using a client ID. See the &lt;a href&#x3D;\&quot;https://knowledge.ably.com/authenticated-and-identified-clients\&quot;&gt;Ably knowledge base&lt;/a&gt; for more details.
   * @return authenticated
   */
  @javax.annotation.Nullable
  public Boolean getAuthenticated() {
    return authenticated;
  }

  public void setAuthenticated(Boolean authenticated) {
    this.authenticated = authenticated;
  }


  public NamespaceResponse created(Integer created) {
    this.created = created;
    return this;
  }

  /**
   * Unix timestamp representing the date and time of creation of the namespace.
   * @return created
   */
  @javax.annotation.Nullable
  public Integer getCreated() {
    return created;
  }

  public void setCreated(Integer created) {
    this.created = created;
  }


  public NamespaceResponse id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The namespace or channel name that the channel rule will apply to. For example, if you specify &#x60;namespace&#x60; the namespace will be set to &#x60;namespace&#x60; and will match with channels &#x60;namespace:*&#x60; and &#x60;namespace&#x60;.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public NamespaceResponse modified(Integer modified) {
    this.modified = modified;
    return this;
  }

  /**
   * Unix timestamp representing the date and time of last modification of the namespace.
   * @return modified
   */
  @javax.annotation.Nullable
  public Integer getModified() {
    return modified;
  }

  public void setModified(Integer modified) {
    this.modified = modified;
  }


  public NamespaceResponse persistLast(Boolean persistLast) {
    this.persistLast = persistLast;
    return this;
  }

  /**
   * If &#x60;true&#x60;, the last message published on a channel will be stored for 365 days. You can access the stored message only by using the channel rewind mechanism and attaching with rewind&#x3D;1. Please note that for each message stored, an additional message is deducted from your monthly allocation.
   * @return persistLast
   */
  @javax.annotation.Nullable
  public Boolean getPersistLast() {
    return persistLast;
  }

  public void setPersistLast(Boolean persistLast) {
    this.persistLast = persistLast;
  }


  public NamespaceResponse persisted(Boolean persisted) {
    this.persisted = persisted;
    return this;
  }

  /**
   * If &#x60;true&#x60;, all messages on a channel will be stored for 24 hours. You can access stored messages via the History API. Please note that for each message stored, an additional message is deducted from your monthly allocation.
   * @return persisted
   */
  @javax.annotation.Nullable
  public Boolean getPersisted() {
    return persisted;
  }

  public void setPersisted(Boolean persisted) {
    this.persisted = persisted;
  }


  public NamespaceResponse pushEnabled(Boolean pushEnabled) {
    this.pushEnabled = pushEnabled;
    return this;
  }

  /**
   * If &#x60;true&#x60;, publishing messages with a push payload in the extras field is permitted and can trigger the delivery of a native push notification to registered devices for the channel.
   * @return pushEnabled
   */
  @javax.annotation.Nullable
  public Boolean getPushEnabled() {
    return pushEnabled;
  }

  public void setPushEnabled(Boolean pushEnabled) {
    this.pushEnabled = pushEnabled;
  }


  public NamespaceResponse tlsOnly(Boolean tlsOnly) {
    this.tlsOnly = tlsOnly;
    return this;
  }

  /**
   * If &#x60;true&#x60;, only clients that are connected using TLS will be permitted to subscribe to any channels within this namespace.
   * @return tlsOnly
   */
  @javax.annotation.Nullable
  public Boolean getTlsOnly() {
    return tlsOnly;
  }

  public void setTlsOnly(Boolean tlsOnly) {
    this.tlsOnly = tlsOnly;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NamespaceResponse namespaceResponse = (NamespaceResponse) o;
    return Objects.equals(this.authenticated, namespaceResponse.authenticated) &&
        Objects.equals(this.created, namespaceResponse.created) &&
        Objects.equals(this.id, namespaceResponse.id) &&
        Objects.equals(this.modified, namespaceResponse.modified) &&
        Objects.equals(this.persistLast, namespaceResponse.persistLast) &&
        Objects.equals(this.persisted, namespaceResponse.persisted) &&
        Objects.equals(this.pushEnabled, namespaceResponse.pushEnabled) &&
        Objects.equals(this.tlsOnly, namespaceResponse.tlsOnly);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authenticated, created, id, modified, persistLast, persisted, pushEnabled, tlsOnly);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NamespaceResponse {\n");
    sb.append("    authenticated: ").append(toIndentedString(authenticated)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    modified: ").append(toIndentedString(modified)).append("\n");
    sb.append("    persistLast: ").append(toIndentedString(persistLast)).append("\n");
    sb.append("    persisted: ").append(toIndentedString(persisted)).append("\n");
    sb.append("    pushEnabled: ").append(toIndentedString(pushEnabled)).append("\n");
    sb.append("    tlsOnly: ").append(toIndentedString(tlsOnly)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("authenticated");
    openapiFields.add("created");
    openapiFields.add("id");
    openapiFields.add("modified");
    openapiFields.add("persistLast");
    openapiFields.add("persisted");
    openapiFields.add("pushEnabled");
    openapiFields.add("tlsOnly");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NamespaceResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NamespaceResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NamespaceResponse is not found in the empty JSON string", NamespaceResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NamespaceResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NamespaceResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NamespaceResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NamespaceResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NamespaceResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NamespaceResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<NamespaceResponse>() {
           @Override
           public void write(JsonWriter out, NamespaceResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NamespaceResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NamespaceResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NamespaceResponse
   * @throws IOException if the JSON string is invalid with respect to NamespaceResponse
   */
  public static NamespaceResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NamespaceResponse.class);
  }

  /**
   * Convert an instance of NamespaceResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

