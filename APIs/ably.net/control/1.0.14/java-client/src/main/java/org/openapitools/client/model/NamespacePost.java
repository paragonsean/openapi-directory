/*
 * Control API v1
 * Use the Control API to manage your applications, namespaces, keys, queues, rules, and more.  Detailed information on using this API can be found in the Ably <a href=\"https://ably.com/documentation/control-api\">developer documentation</a>.  Control API is currently in Beta. 
 *
 * The version of the OpenAPI document: 1.0.14
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * NamespacePost
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:29:58.065790-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NamespacePost {
  public static final String SERIALIZED_NAME_AUTHENTICATED = "authenticated";
  @SerializedName(SERIALIZED_NAME_AUTHENTICATED)
  private Boolean authenticated = false;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_PERSIST_LAST = "persistLast";
  @SerializedName(SERIALIZED_NAME_PERSIST_LAST)
  private Boolean persistLast = false;

  public static final String SERIALIZED_NAME_PERSISTED = "persisted";
  @SerializedName(SERIALIZED_NAME_PERSISTED)
  private Boolean persisted = false;

  public static final String SERIALIZED_NAME_PUSH_ENABLED = "pushEnabled";
  @SerializedName(SERIALIZED_NAME_PUSH_ENABLED)
  private Boolean pushEnabled = false;

  public static final String SERIALIZED_NAME_TLS_ONLY = "tlsOnly";
  @SerializedName(SERIALIZED_NAME_TLS_ONLY)
  private Boolean tlsOnly = false;

  public NamespacePost() {
  }

  public NamespacePost authenticated(Boolean authenticated) {
    this.authenticated = authenticated;
    return this;
  }

  /**
   * If &#x60;true&#x60;, clients will not be permitted to use (including to attach, publish, or subscribe) any channels within this namespace unless they are identified, that is, authenticated using a client ID. See the &lt;a href&#x3D;\&quot;https://knowledge.ably.com/authenticated-and-identified-clients\&quot;&gt;Ably Knowledge base&lt;/a&gt; for more details.
   * @return authenticated
   */
  @javax.annotation.Nullable
  public Boolean getAuthenticated() {
    return authenticated;
  }

  public void setAuthenticated(Boolean authenticated) {
    this.authenticated = authenticated;
  }


  public NamespacePost id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The namespace or channel name that the channel rule will apply to. For example, if you specify &#x60;namespace&#x60; the namespace will be set to &#x60;namespace&#x60; and will match with channels &#x60;namespace:*&#x60; and &#x60;namespace&#x60;.
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public NamespacePost persistLast(Boolean persistLast) {
    this.persistLast = persistLast;
    return this;
  }

  /**
   * If &#x60;true&#x60;, the last message published on a channel will be stored for 365 days. You can access the stored message only by using the channel rewind mechanism and attaching with rewind&#x3D;1. Please note that for each message stored, an additional message is deducted from your monthly allocation.
   * @return persistLast
   */
  @javax.annotation.Nullable
  public Boolean getPersistLast() {
    return persistLast;
  }

  public void setPersistLast(Boolean persistLast) {
    this.persistLast = persistLast;
  }


  public NamespacePost persisted(Boolean persisted) {
    this.persisted = persisted;
    return this;
  }

  /**
   * If &#x60;true&#x60;, all messages on a channel will be stored for 24 hours. You can access stored messages via the History API. Please note that for each message stored, an additional message is deducted from your monthly allocation.
   * @return persisted
   */
  @javax.annotation.Nullable
  public Boolean getPersisted() {
    return persisted;
  }

  public void setPersisted(Boolean persisted) {
    this.persisted = persisted;
  }


  public NamespacePost pushEnabled(Boolean pushEnabled) {
    this.pushEnabled = pushEnabled;
    return this;
  }

  /**
   * If &#x60;true&#x60;, publishing messages with a push payload in the extras field is permitted and can trigger the delivery of a native push notification to registered devices for the channel.
   * @return pushEnabled
   */
  @javax.annotation.Nullable
  public Boolean getPushEnabled() {
    return pushEnabled;
  }

  public void setPushEnabled(Boolean pushEnabled) {
    this.pushEnabled = pushEnabled;
  }


  public NamespacePost tlsOnly(Boolean tlsOnly) {
    this.tlsOnly = tlsOnly;
    return this;
  }

  /**
   * If &#x60;true&#x60;, only clients that are connected using TLS will be permitted to subscribe to any channels within this namespace.
   * @return tlsOnly
   */
  @javax.annotation.Nullable
  public Boolean getTlsOnly() {
    return tlsOnly;
  }

  public void setTlsOnly(Boolean tlsOnly) {
    this.tlsOnly = tlsOnly;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NamespacePost namespacePost = (NamespacePost) o;
    return Objects.equals(this.authenticated, namespacePost.authenticated) &&
        Objects.equals(this.id, namespacePost.id) &&
        Objects.equals(this.persistLast, namespacePost.persistLast) &&
        Objects.equals(this.persisted, namespacePost.persisted) &&
        Objects.equals(this.pushEnabled, namespacePost.pushEnabled) &&
        Objects.equals(this.tlsOnly, namespacePost.tlsOnly);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authenticated, id, persistLast, persisted, pushEnabled, tlsOnly);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NamespacePost {\n");
    sb.append("    authenticated: ").append(toIndentedString(authenticated)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    persistLast: ").append(toIndentedString(persistLast)).append("\n");
    sb.append("    persisted: ").append(toIndentedString(persisted)).append("\n");
    sb.append("    pushEnabled: ").append(toIndentedString(pushEnabled)).append("\n");
    sb.append("    tlsOnly: ").append(toIndentedString(tlsOnly)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("authenticated");
    openapiFields.add("id");
    openapiFields.add("persistLast");
    openapiFields.add("persisted");
    openapiFields.add("pushEnabled");
    openapiFields.add("tlsOnly");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NamespacePost
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NamespacePost.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NamespacePost is not found in the empty JSON string", NamespacePost.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NamespacePost.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NamespacePost` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : NamespacePost.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NamespacePost.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NamespacePost' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NamespacePost> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NamespacePost.class));

       return (TypeAdapter<T>) new TypeAdapter<NamespacePost>() {
           @Override
           public void write(JsonWriter out, NamespacePost value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NamespacePost read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NamespacePost given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NamespacePost
   * @throws IOException if the JSON string is invalid with respect to NamespacePost
   */
  public static NamespacePost fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NamespacePost.class);
  }

  /**
   * Convert an instance of NamespacePost to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

