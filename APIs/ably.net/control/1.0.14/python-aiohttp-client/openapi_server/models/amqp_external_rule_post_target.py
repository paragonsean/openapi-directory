# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.amqp_external_rule_patch_target_headers_inner import AmqpExternalRulePatchTargetHeadersInner
from openapi_server import util


class AmqpExternalRulePostTarget(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, enveloped: bool=None, format: str=None, headers: List[AmqpExternalRulePatchTargetHeadersInner]=None, mandatory_route: bool=None, message_ttl: int=None, persistent_messages: bool=None, routing_key: str=None, url: str=None):
        """AmqpExternalRulePostTarget - a model defined in OpenAPI

        :param enveloped: The enveloped of this AmqpExternalRulePostTarget.
        :param format: The format of this AmqpExternalRulePostTarget.
        :param headers: The headers of this AmqpExternalRulePostTarget.
        :param mandatory_route: The mandatory_route of this AmqpExternalRulePostTarget.
        :param message_ttl: The message_ttl of this AmqpExternalRulePostTarget.
        :param persistent_messages: The persistent_messages of this AmqpExternalRulePostTarget.
        :param routing_key: The routing_key of this AmqpExternalRulePostTarget.
        :param url: The url of this AmqpExternalRulePostTarget.
        """
        self.openapi_types = {
            'enveloped': bool,
            'format': str,
            'headers': List[AmqpExternalRulePatchTargetHeadersInner],
            'mandatory_route': bool,
            'message_ttl': int,
            'persistent_messages': bool,
            'routing_key': str,
            'url': str
        }

        self.attribute_map = {
            'enveloped': 'enveloped',
            'format': 'format',
            'headers': 'headers',
            'mandatory_route': 'mandatoryRoute',
            'message_ttl': 'messageTtl',
            'persistent_messages': 'persistentMessages',
            'routing_key': 'routingKey',
            'url': 'url'
        }

        self._enveloped = enveloped
        self._format = format
        self._headers = headers
        self._mandatory_route = mandatory_route
        self._message_ttl = message_ttl
        self._persistent_messages = persistent_messages
        self._routing_key = routing_key
        self._url = url

    @classmethod
    def from_dict(cls, dikt: dict) -> 'AmqpExternalRulePostTarget':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The amqp_external_rule_post_target of this AmqpExternalRulePostTarget.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def enveloped(self):
        """Gets the enveloped of this AmqpExternalRulePostTarget.

        Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking \"Enveloped\" when setting up the rule.

        :return: The enveloped of this AmqpExternalRulePostTarget.
        :rtype: bool
        """
        return self._enveloped

    @enveloped.setter
    def enveloped(self, enveloped):
        """Sets the enveloped of this AmqpExternalRulePostTarget.

        Messages delivered through Reactor are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking \"Enveloped\" when setting up the rule.

        :param enveloped: The enveloped of this AmqpExternalRulePostTarget.
        :type enveloped: bool
        """

        self._enveloped = enveloped

    @property
    def format(self):
        """Gets the format of this AmqpExternalRulePostTarget.


        :return: The format of this AmqpExternalRulePostTarget.
        :rtype: str
        """
        return self._format

    @format.setter
    def format(self, format):
        """Sets the format of this AmqpExternalRulePostTarget.


        :param format: The format of this AmqpExternalRulePostTarget.
        :type format: str
        """

        self._format = format

    @property
    def headers(self):
        """Gets the headers of this AmqpExternalRulePostTarget.

        If you have additional information to send, you'll need to include the relevant headers.

        :return: The headers of this AmqpExternalRulePostTarget.
        :rtype: List[AmqpExternalRulePatchTargetHeadersInner]
        """
        return self._headers

    @headers.setter
    def headers(self, headers):
        """Sets the headers of this AmqpExternalRulePostTarget.

        If you have additional information to send, you'll need to include the relevant headers.

        :param headers: The headers of this AmqpExternalRulePostTarget.
        :type headers: List[AmqpExternalRulePatchTargetHeadersInner]
        """

        self._headers = headers

    @property
    def mandatory_route(self):
        """Gets the mandatory_route of this AmqpExternalRulePostTarget.

        Reject delivery of the message if the route does not exist, otherwise fail silently.

        :return: The mandatory_route of this AmqpExternalRulePostTarget.
        :rtype: bool
        """
        return self._mandatory_route

    @mandatory_route.setter
    def mandatory_route(self, mandatory_route):
        """Sets the mandatory_route of this AmqpExternalRulePostTarget.

        Reject delivery of the message if the route does not exist, otherwise fail silently.

        :param mandatory_route: The mandatory_route of this AmqpExternalRulePostTarget.
        :type mandatory_route: bool
        """
        if mandatory_route is None:
            raise ValueError("Invalid value for `mandatory_route`, must not be `None`")

        self._mandatory_route = mandatory_route

    @property
    def message_ttl(self):
        """Gets the message_ttl of this AmqpExternalRulePostTarget.

        You can optionally override the default TTL on a queue and specify a TTL in minutes for messages to be persisted. It is unusual to change the default TTL, so if this field is left empty, the default TTL for the queue will be used.

        :return: The message_ttl of this AmqpExternalRulePostTarget.
        :rtype: int
        """
        return self._message_ttl

    @message_ttl.setter
    def message_ttl(self, message_ttl):
        """Sets the message_ttl of this AmqpExternalRulePostTarget.

        You can optionally override the default TTL on a queue and specify a TTL in minutes for messages to be persisted. It is unusual to change the default TTL, so if this field is left empty, the default TTL for the queue will be used.

        :param message_ttl: The message_ttl of this AmqpExternalRulePostTarget.
        :type message_ttl: int
        """

        self._message_ttl = message_ttl

    @property
    def persistent_messages(self):
        """Gets the persistent_messages of this AmqpExternalRulePostTarget.

        Marks the message as persistent, instructing the broker to write it to disk if it is in a durable queue.

        :return: The persistent_messages of this AmqpExternalRulePostTarget.
        :rtype: bool
        """
        return self._persistent_messages

    @persistent_messages.setter
    def persistent_messages(self, persistent_messages):
        """Sets the persistent_messages of this AmqpExternalRulePostTarget.

        Marks the message as persistent, instructing the broker to write it to disk if it is in a durable queue.

        :param persistent_messages: The persistent_messages of this AmqpExternalRulePostTarget.
        :type persistent_messages: bool
        """
        if persistent_messages is None:
            raise ValueError("Invalid value for `persistent_messages`, must not be `None`")

        self._persistent_messages = persistent_messages

    @property
    def routing_key(self):
        """Gets the routing_key of this AmqpExternalRulePostTarget.

        The AMQP routing key. See this <a href=\"https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule\">Ably knowledge base article</a> for details.

        :return: The routing_key of this AmqpExternalRulePostTarget.
        :rtype: str
        """
        return self._routing_key

    @routing_key.setter
    def routing_key(self, routing_key):
        """Sets the routing_key of this AmqpExternalRulePostTarget.

        The AMQP routing key. See this <a href=\"https://knowledge.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule\">Ably knowledge base article</a> for details.

        :param routing_key: The routing_key of this AmqpExternalRulePostTarget.
        :type routing_key: str
        """
        if routing_key is None:
            raise ValueError("Invalid value for `routing_key`, must not be `None`")

        self._routing_key = routing_key

    @property
    def url(self):
        """Gets the url of this AmqpExternalRulePostTarget.


        :return: The url of this AmqpExternalRulePostTarget.
        :rtype: str
        """
        return self._url

    @url.setter
    def url(self, url):
        """Sets the url of this AmqpExternalRulePostTarget.


        :param url: The url of this AmqpExternalRulePostTarget.
        :type url: str
        """
        if url is None:
            raise ValueError("Invalid value for `url`, must not be `None`")

        self._url = url
