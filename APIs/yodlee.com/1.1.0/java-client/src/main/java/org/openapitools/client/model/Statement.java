/*
 * Yodlee Core APIs
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee supports the Java SDK and it is available <a href=\"https://developer.yodlee.com/java-sdk-overview \">here</a>. You can generate a client SDK for Python, Java, JavaScript, PHP or other languages according to your development needs. For more details about the APIs, refer to <a href=\"https://developer.yodlee.com/docs/api/1.1/Overview\">Yodlee API v1.1 - Overview</a>.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developer@yodlee.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Money;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Statement
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.041142-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Statement {
  public static final String SERIALIZED_NAME_ACCOUNT_ID = "accountId";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  private Long accountId;

  public static final String SERIALIZED_NAME_AMOUNT_DUE = "amountDue";
  @SerializedName(SERIALIZED_NAME_AMOUNT_DUE)
  private Money amountDue;

  public static final String SERIALIZED_NAME_APR = "apr";
  @SerializedName(SERIALIZED_NAME_APR)
  private Double apr;

  public static final String SERIALIZED_NAME_BILLING_PERIOD_END = "billingPeriodEnd";
  @SerializedName(SERIALIZED_NAME_BILLING_PERIOD_END)
  private String billingPeriodEnd;

  public static final String SERIALIZED_NAME_BILLING_PERIOD_START = "billingPeriodStart";
  @SerializedName(SERIALIZED_NAME_BILLING_PERIOD_START)
  private String billingPeriodStart;

  public static final String SERIALIZED_NAME_CASH_ADVANCE = "cashAdvance";
  @SerializedName(SERIALIZED_NAME_CASH_ADVANCE)
  private Money cashAdvance;

  public static final String SERIALIZED_NAME_CASH_APR = "cashApr";
  @SerializedName(SERIALIZED_NAME_CASH_APR)
  private Double cashApr;

  public static final String SERIALIZED_NAME_DUE_DATE = "dueDate";
  @SerializedName(SERIALIZED_NAME_DUE_DATE)
  private String dueDate;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_INTEREST_AMOUNT = "interestAmount";
  @SerializedName(SERIALIZED_NAME_INTEREST_AMOUNT)
  private Money interestAmount;

  public static final String SERIALIZED_NAME_IS_LATEST = "isLatest";
  @SerializedName(SERIALIZED_NAME_IS_LATEST)
  private Boolean isLatest;

  public static final String SERIALIZED_NAME_LAST_PAYMENT_AMOUNT = "lastPaymentAmount";
  @SerializedName(SERIALIZED_NAME_LAST_PAYMENT_AMOUNT)
  private Money lastPaymentAmount;

  public static final String SERIALIZED_NAME_LAST_PAYMENT_DATE = "lastPaymentDate";
  @SerializedName(SERIALIZED_NAME_LAST_PAYMENT_DATE)
  private String lastPaymentDate;

  public static final String SERIALIZED_NAME_LAST_UPDATED = "lastUpdated";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED)
  private String lastUpdated;

  public static final String SERIALIZED_NAME_LOAN_BALANCE = "loanBalance";
  @SerializedName(SERIALIZED_NAME_LOAN_BALANCE)
  private Money loanBalance;

  public static final String SERIALIZED_NAME_MINIMUM_PAYMENT = "minimumPayment";
  @SerializedName(SERIALIZED_NAME_MINIMUM_PAYMENT)
  private Money minimumPayment;

  public static final String SERIALIZED_NAME_NEW_CHARGES = "newCharges";
  @SerializedName(SERIALIZED_NAME_NEW_CHARGES)
  private Money newCharges;

  public static final String SERIALIZED_NAME_PRINCIPAL_AMOUNT = "principalAmount";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL_AMOUNT)
  private Money principalAmount;

  public static final String SERIALIZED_NAME_STATEMENT_DATE = "statementDate";
  @SerializedName(SERIALIZED_NAME_STATEMENT_DATE)
  private String statementDate;

  public Statement() {
  }

  public Statement(
     Long accountId, 
     Double apr, 
     String billingPeriodEnd, 
     String billingPeriodStart, 
     Double cashApr, 
     String dueDate, 
     Long id, 
     Boolean isLatest, 
     String lastPaymentDate, 
     String lastUpdated, 
     String statementDate
  ) {
    this();
    this.accountId = accountId;
    this.apr = apr;
    this.billingPeriodEnd = billingPeriodEnd;
    this.billingPeriodStart = billingPeriodStart;
    this.cashApr = cashApr;
    this.dueDate = dueDate;
    this.id = id;
    this.isLatest = isLatest;
    this.lastPaymentDate = lastPaymentDate;
    this.lastUpdated = lastUpdated;
    this.statementDate = statementDate;
  }

  /**
   * Account to which the statement belongs to.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return accountId
   */
  @javax.annotation.Nullable
  public Long getAccountId() {
    return accountId;
  }



  public Statement amountDue(Money amountDue) {
    this.amountDue = amountDue;
    return this;
  }

  /**
   * Get amountDue
   * @return amountDue
   */
  @javax.annotation.Nullable
  public Money getAmountDue() {
    return amountDue;
  }

  public void setAmountDue(Money amountDue) {
    this.amountDue = amountDue;
  }


  /**
   * The APR applied to the balance on the credit card account, as available in the statement.&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; In case of variable APR, the APR available on the statement might differ from the APR available at the account-level.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return apr
   */
  @javax.annotation.Nullable
  public Double getApr() {
    return apr;
  }



  /**
   * The end date of the statement period.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return billingPeriodEnd
   */
  @javax.annotation.Nullable
  public String getBillingPeriodEnd() {
    return billingPeriodEnd;
  }



  /**
   * The start date of the statement period.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return billingPeriodStart
   */
  @javax.annotation.Nullable
  public String getBillingPeriodStart() {
    return billingPeriodStart;
  }



  public Statement cashAdvance(Money cashAdvance) {
    this.cashAdvance = cashAdvance;
    return this;
  }

  /**
   * Get cashAdvance
   * @return cashAdvance
   */
  @javax.annotation.Nullable
  public Money getCashAdvance() {
    return cashAdvance;
  }

  public void setCashAdvance(Money cashAdvance) {
    this.cashAdvance = cashAdvance;
  }


  /**
   * The APR applicable to cash withdrawals on the credit card account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return cashApr
   */
  @javax.annotation.Nullable
  public Double getCashApr() {
    return cashApr;
  }



  /**
   * The date by when the minimum payment is due to be paid.&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; The due date that appears in the statement may differ from the due date at the account-level.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return dueDate
   */
  @javax.annotation.Nullable
  public String getDueDate() {
    return dueDate;
  }



  /**
   * Unique identifier for the statement.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return id
   */
  @javax.annotation.Nullable
  public Long getId() {
    return id;
  }



  public Statement interestAmount(Money interestAmount) {
    this.interestAmount = interestAmount;
    return this;
  }

  /**
   * Get interestAmount
   * @return interestAmount
   */
  @javax.annotation.Nullable
  public Money getInterestAmount() {
    return interestAmount;
  }

  public void setInterestAmount(Money interestAmount) {
    this.interestAmount = interestAmount;
  }


  /**
   * The field is set to true if the statement is the latest generated statement.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return isLatest
   */
  @javax.annotation.Nullable
  public Boolean getIsLatest() {
    return isLatest;
  }



  public Statement lastPaymentAmount(Money lastPaymentAmount) {
    this.lastPaymentAmount = lastPaymentAmount;
    return this;
  }

  /**
   * Get lastPaymentAmount
   * @return lastPaymentAmount
   */
  @javax.annotation.Nullable
  public Money getLastPaymentAmount() {
    return lastPaymentAmount;
  }

  public void setLastPaymentAmount(Money lastPaymentAmount) {
    this.lastPaymentAmount = lastPaymentAmount;
  }


  /**
   * The date on which the last payment was done during the billing cycle.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return lastPaymentDate
   */
  @javax.annotation.Nullable
  public String getLastPaymentDate() {
    return lastPaymentDate;
  }



  /**
   * The date when the account was last updated by Yodlee.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return lastUpdated
   */
  @javax.annotation.Nullable
  public String getLastUpdated() {
    return lastUpdated;
  }



  public Statement loanBalance(Money loanBalance) {
    this.loanBalance = loanBalance;
    return this;
  }

  /**
   * Get loanBalance
   * @return loanBalance
   */
  @javax.annotation.Nullable
  public Money getLoanBalance() {
    return loanBalance;
  }

  public void setLoanBalance(Money loanBalance) {
    this.loanBalance = loanBalance;
  }


  public Statement minimumPayment(Money minimumPayment) {
    this.minimumPayment = minimumPayment;
    return this;
  }

  /**
   * Get minimumPayment
   * @return minimumPayment
   */
  @javax.annotation.Nullable
  public Money getMinimumPayment() {
    return minimumPayment;
  }

  public void setMinimumPayment(Money minimumPayment) {
    this.minimumPayment = minimumPayment;
  }


  public Statement newCharges(Money newCharges) {
    this.newCharges = newCharges;
    return this;
  }

  /**
   * Get newCharges
   * @return newCharges
   */
  @javax.annotation.Nullable
  public Money getNewCharges() {
    return newCharges;
  }

  public void setNewCharges(Money newCharges) {
    this.newCharges = newCharges;
  }


  public Statement principalAmount(Money principalAmount) {
    this.principalAmount = principalAmount;
    return this;
  }

  /**
   * Get principalAmount
   * @return principalAmount
   */
  @javax.annotation.Nullable
  public Money getPrincipalAmount() {
    return principalAmount;
  }

  public void setPrincipalAmount(Money principalAmount) {
    this.principalAmount = principalAmount;
  }


  /**
   * The date on which the statement is generated.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard,  loan, insurance&lt;br&gt;
   * @return statementDate
   */
  @javax.annotation.Nullable
  public String getStatementDate() {
    return statementDate;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Statement statement = (Statement) o;
    return Objects.equals(this.accountId, statement.accountId) &&
        Objects.equals(this.amountDue, statement.amountDue) &&
        Objects.equals(this.apr, statement.apr) &&
        Objects.equals(this.billingPeriodEnd, statement.billingPeriodEnd) &&
        Objects.equals(this.billingPeriodStart, statement.billingPeriodStart) &&
        Objects.equals(this.cashAdvance, statement.cashAdvance) &&
        Objects.equals(this.cashApr, statement.cashApr) &&
        Objects.equals(this.dueDate, statement.dueDate) &&
        Objects.equals(this.id, statement.id) &&
        Objects.equals(this.interestAmount, statement.interestAmount) &&
        Objects.equals(this.isLatest, statement.isLatest) &&
        Objects.equals(this.lastPaymentAmount, statement.lastPaymentAmount) &&
        Objects.equals(this.lastPaymentDate, statement.lastPaymentDate) &&
        Objects.equals(this.lastUpdated, statement.lastUpdated) &&
        Objects.equals(this.loanBalance, statement.loanBalance) &&
        Objects.equals(this.minimumPayment, statement.minimumPayment) &&
        Objects.equals(this.newCharges, statement.newCharges) &&
        Objects.equals(this.principalAmount, statement.principalAmount) &&
        Objects.equals(this.statementDate, statement.statementDate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountId, amountDue, apr, billingPeriodEnd, billingPeriodStart, cashAdvance, cashApr, dueDate, id, interestAmount, isLatest, lastPaymentAmount, lastPaymentDate, lastUpdated, loanBalance, minimumPayment, newCharges, principalAmount, statementDate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Statement {\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    amountDue: ").append(toIndentedString(amountDue)).append("\n");
    sb.append("    apr: ").append(toIndentedString(apr)).append("\n");
    sb.append("    billingPeriodEnd: ").append(toIndentedString(billingPeriodEnd)).append("\n");
    sb.append("    billingPeriodStart: ").append(toIndentedString(billingPeriodStart)).append("\n");
    sb.append("    cashAdvance: ").append(toIndentedString(cashAdvance)).append("\n");
    sb.append("    cashApr: ").append(toIndentedString(cashApr)).append("\n");
    sb.append("    dueDate: ").append(toIndentedString(dueDate)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    interestAmount: ").append(toIndentedString(interestAmount)).append("\n");
    sb.append("    isLatest: ").append(toIndentedString(isLatest)).append("\n");
    sb.append("    lastPaymentAmount: ").append(toIndentedString(lastPaymentAmount)).append("\n");
    sb.append("    lastPaymentDate: ").append(toIndentedString(lastPaymentDate)).append("\n");
    sb.append("    lastUpdated: ").append(toIndentedString(lastUpdated)).append("\n");
    sb.append("    loanBalance: ").append(toIndentedString(loanBalance)).append("\n");
    sb.append("    minimumPayment: ").append(toIndentedString(minimumPayment)).append("\n");
    sb.append("    newCharges: ").append(toIndentedString(newCharges)).append("\n");
    sb.append("    principalAmount: ").append(toIndentedString(principalAmount)).append("\n");
    sb.append("    statementDate: ").append(toIndentedString(statementDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountId");
    openapiFields.add("amountDue");
    openapiFields.add("apr");
    openapiFields.add("billingPeriodEnd");
    openapiFields.add("billingPeriodStart");
    openapiFields.add("cashAdvance");
    openapiFields.add("cashApr");
    openapiFields.add("dueDate");
    openapiFields.add("id");
    openapiFields.add("interestAmount");
    openapiFields.add("isLatest");
    openapiFields.add("lastPaymentAmount");
    openapiFields.add("lastPaymentDate");
    openapiFields.add("lastUpdated");
    openapiFields.add("loanBalance");
    openapiFields.add("minimumPayment");
    openapiFields.add("newCharges");
    openapiFields.add("principalAmount");
    openapiFields.add("statementDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Statement
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Statement.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Statement is not found in the empty JSON string", Statement.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Statement.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Statement` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `amountDue`
      if (jsonObj.get("amountDue") != null && !jsonObj.get("amountDue").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("amountDue"));
      }
      if ((jsonObj.get("billingPeriodEnd") != null && !jsonObj.get("billingPeriodEnd").isJsonNull()) && !jsonObj.get("billingPeriodEnd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `billingPeriodEnd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("billingPeriodEnd").toString()));
      }
      if ((jsonObj.get("billingPeriodStart") != null && !jsonObj.get("billingPeriodStart").isJsonNull()) && !jsonObj.get("billingPeriodStart").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `billingPeriodStart` to be a primitive type in the JSON string but got `%s`", jsonObj.get("billingPeriodStart").toString()));
      }
      // validate the optional field `cashAdvance`
      if (jsonObj.get("cashAdvance") != null && !jsonObj.get("cashAdvance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("cashAdvance"));
      }
      if ((jsonObj.get("dueDate") != null && !jsonObj.get("dueDate").isJsonNull()) && !jsonObj.get("dueDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dueDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dueDate").toString()));
      }
      // validate the optional field `interestAmount`
      if (jsonObj.get("interestAmount") != null && !jsonObj.get("interestAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("interestAmount"));
      }
      // validate the optional field `lastPaymentAmount`
      if (jsonObj.get("lastPaymentAmount") != null && !jsonObj.get("lastPaymentAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("lastPaymentAmount"));
      }
      if ((jsonObj.get("lastPaymentDate") != null && !jsonObj.get("lastPaymentDate").isJsonNull()) && !jsonObj.get("lastPaymentDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastPaymentDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastPaymentDate").toString()));
      }
      if ((jsonObj.get("lastUpdated") != null && !jsonObj.get("lastUpdated").isJsonNull()) && !jsonObj.get("lastUpdated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdated").toString()));
      }
      // validate the optional field `loanBalance`
      if (jsonObj.get("loanBalance") != null && !jsonObj.get("loanBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("loanBalance"));
      }
      // validate the optional field `minimumPayment`
      if (jsonObj.get("minimumPayment") != null && !jsonObj.get("minimumPayment").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("minimumPayment"));
      }
      // validate the optional field `newCharges`
      if (jsonObj.get("newCharges") != null && !jsonObj.get("newCharges").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("newCharges"));
      }
      // validate the optional field `principalAmount`
      if (jsonObj.get("principalAmount") != null && !jsonObj.get("principalAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("principalAmount"));
      }
      if ((jsonObj.get("statementDate") != null && !jsonObj.get("statementDate").isJsonNull()) && !jsonObj.get("statementDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `statementDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("statementDate").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Statement.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Statement' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Statement> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Statement.class));

       return (TypeAdapter<T>) new TypeAdapter<Statement>() {
           @Override
           public void write(JsonWriter out, Statement value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Statement read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Statement given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Statement
   * @throws IOException if the JSON string is invalid with respect to Statement
   */
  public static Statement fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Statement.class);
  }

  /**
   * Convert an instance of Statement to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

