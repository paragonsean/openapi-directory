/*
 * Yodlee Core APIs
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee supports the Java SDK and it is available <a href=\"https://developer.yodlee.com/java-sdk-overview \">here</a>. You can generate a client SDK for Python, Java, JavaScript, PHP or other languages according to your development needs. For more details about the APIs, refer to <a href=\"https://developer.yodlee.com/docs/api/1.1/Overview\">Yodlee API v1.1 - Overview</a>.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developer@yodlee.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AccountAddress;
import org.openapitools.client.model.AccountDataset;
import org.openapitools.client.model.BankTransferCode;
import org.openapitools.client.model.Coverage;
import org.openapitools.client.model.LoanPayoffDetails;
import org.openapitools.client.model.Money;
import org.openapitools.client.model.RewardBalance;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * DataExtractsAccount
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.041142-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DataExtractsAccount {
  public static final String SERIALIZED_NAME_401K_LOAN = "401kLoan";
  @SerializedName(SERIALIZED_NAME_401K_LOAN)
  private Money _401kLoan;

  /**
   * The type of service. E.g., Bank, Credit Card, Investment, Insurance, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(CONTAINEREnum.Adapter.class)
  public enum CONTAINEREnum {
    BANK("bank"),
    
    CREDIT_CARD("creditCard"),
    
    INVESTMENT("investment"),
    
    INSURANCE("insurance"),
    
    LOAN("loan"),
    
    REWARD("reward"),
    
    REAL_ESTATE("realEstate"),
    
    OTHER_ASSETS("otherAssets"),
    
    OTHER_LIABILITIES("otherLiabilities");

    private String value;

    CONTAINEREnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CONTAINEREnum fromValue(String value) {
      for (CONTAINEREnum b : CONTAINEREnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CONTAINEREnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CONTAINEREnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CONTAINEREnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CONTAINEREnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CONTAINEREnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_C_O_N_T_A_I_N_E_R = "CONTAINER";
  @SerializedName(SERIALIZED_NAME_C_O_N_T_A_I_N_E_R)
  private CONTAINEREnum CONTAINER;

  public static final String SERIALIZED_NAME_ACCOUNT_NAME = "accountName";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_NAME)
  private String accountName;

  public static final String SERIALIZED_NAME_ACCOUNT_NUMBER = "accountNumber";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_NUMBER)
  private String accountNumber;

  /**
   * The status of the account that is updated by the consumer through an application or an API. Valid Values: AccountStatus&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt;&lt;br&gt;&lt;b&gt;ACTIVE:&lt;/b&gt; All the added manual and aggregated accounts status will be made \&quot;ACTIVE\&quot; by default. &lt;br&gt;&lt;b&gt;TO_BE_CLOSED:&lt;/b&gt; If the aggregated accounts are not found or closed in the data provider site, Yodlee system marks the status as TO_BE_CLOSED&lt;br&gt;&lt;b&gt;INACTIVE:&lt;/b&gt; Users can update the status as INACTIVE to stop updating and to stop considering the account in other services&lt;br&gt;&lt;b&gt;CLOSED:&lt;/b&gt; Users can update the status as CLOSED, if the account is closed with the provider. &lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(AccountStatusEnum.Adapter.class)
  public enum AccountStatusEnum {
    ACTIVE("ACTIVE"),
    
    INACTIVE("INACTIVE"),
    
    TO_BE_CLOSED("TO_BE_CLOSED"),
    
    CLOSED("CLOSED"),
    
    DELETED("DELETED");

    private String value;

    AccountStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AccountStatusEnum fromValue(String value) {
      for (AccountStatusEnum b : AccountStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AccountStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AccountStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AccountStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AccountStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AccountStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACCOUNT_STATUS = "accountStatus";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_STATUS)
  private AccountStatusEnum accountStatus;

  public static final String SERIALIZED_NAME_ACCOUNT_TYPE = "accountType";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_TYPE)
  private String accountType;

  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  private AccountAddress address;

  /**
   * The source through which the account(s) are added in the system.&lt;br&gt;&lt;b&gt;Valid Values&lt;/b&gt;: SYSTEM, USER&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(AggregationSourceEnum.Adapter.class)
  public enum AggregationSourceEnum {
    SYSTEM("SYSTEM"),
    
    USER("USER");

    private String value;

    AggregationSourceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AggregationSourceEnum fromValue(String value) {
      for (AggregationSourceEnum b : AggregationSourceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AggregationSourceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AggregationSourceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AggregationSourceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AggregationSourceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AggregationSourceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AGGREGATION_SOURCE = "aggregationSource";
  @SerializedName(SERIALIZED_NAME_AGGREGATION_SOURCE)
  private AggregationSourceEnum aggregationSource;

  public static final String SERIALIZED_NAME_AMOUNT_DUE = "amountDue";
  @SerializedName(SERIALIZED_NAME_AMOUNT_DUE)
  private Money amountDue;

  public static final String SERIALIZED_NAME_ANNUAL_PERCENTAGE_YIELD = "annualPercentageYield";
  @SerializedName(SERIALIZED_NAME_ANNUAL_PERCENTAGE_YIELD)
  private Double annualPercentageYield;

  public static final String SERIALIZED_NAME_ANNUITY_BALANCE = "annuityBalance";
  @SerializedName(SERIALIZED_NAME_ANNUITY_BALANCE)
  private Money annuityBalance;

  public static final String SERIALIZED_NAME_APR = "apr";
  @SerializedName(SERIALIZED_NAME_APR)
  private Double apr;

  public static final String SERIALIZED_NAME_ASSOCIATED_PROVIDER_ACCOUNT_ID = "associatedProviderAccountId";
  @SerializedName(SERIALIZED_NAME_ASSOCIATED_PROVIDER_ACCOUNT_ID)
  private List<Long> associatedProviderAccountId = new ArrayList<>();

  public static final String SERIALIZED_NAME_AVAILABLE_BALANCE = "availableBalance";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_BALANCE)
  private Money availableBalance;

  public static final String SERIALIZED_NAME_AVAILABLE_CASH = "availableCash";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_CASH)
  private Money availableCash;

  public static final String SERIALIZED_NAME_AVAILABLE_CREDIT = "availableCredit";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_CREDIT)
  private Money availableCredit;

  public static final String SERIALIZED_NAME_BALANCE = "balance";
  @SerializedName(SERIALIZED_NAME_BALANCE)
  private Money balance;

  public static final String SERIALIZED_NAME_BANK_TRANSFER_CODE = "bankTransferCode";
  @SerializedName(SERIALIZED_NAME_BANK_TRANSFER_CODE)
  private List<BankTransferCode> bankTransferCode = new ArrayList<>();

  public static final String SERIALIZED_NAME_CASH = "cash";
  @SerializedName(SERIALIZED_NAME_CASH)
  private Money cash;

  public static final String SERIALIZED_NAME_CASH_APR = "cashApr";
  @SerializedName(SERIALIZED_NAME_CASH_APR)
  private Double cashApr;

  public static final String SERIALIZED_NAME_CASH_VALUE = "cashValue";
  @SerializedName(SERIALIZED_NAME_CASH_VALUE)
  private Money cashValue;

  /**
   * The classification of the account such as personal, corporate, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, creditCard, investment, reward, loan, insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(ClassificationEnum.Adapter.class)
  public enum ClassificationEnum {
    OTHER("OTHER"),
    
    PERSONAL("PERSONAL"),
    
    CORPORATE("CORPORATE"),
    
    SMALL_BUSINESS("SMALL_BUSINESS"),
    
    TRUST("TRUST"),
    
    ADD_ON_CARD("ADD_ON_CARD"),
    
    VIRTUAL_CARD("VIRTUAL_CARD");

    private String value;

    ClassificationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ClassificationEnum fromValue(String value) {
      for (ClassificationEnum b : ClassificationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ClassificationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClassificationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClassificationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ClassificationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ClassificationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CLASSIFICATION = "classification";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION)
  private ClassificationEnum classification;

  public static final String SERIALIZED_NAME_COLLATERAL = "collateral";
  @SerializedName(SERIALIZED_NAME_COLLATERAL)
  private String collateral;

  public static final String SERIALIZED_NAME_COVERAGE = "coverage";
  @SerializedName(SERIALIZED_NAME_COVERAGE)
  private List<Coverage> coverage = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private String createdDate;

  public static final String SERIALIZED_NAME_CURRENT_BALANCE = "currentBalance";
  @SerializedName(SERIALIZED_NAME_CURRENT_BALANCE)
  private Money currentBalance;

  public static final String SERIALIZED_NAME_CURRENT_LEVEL = "currentLevel";
  @SerializedName(SERIALIZED_NAME_CURRENT_LEVEL)
  private String currentLevel;

  public static final String SERIALIZED_NAME_DATASET = "dataset";
  @SerializedName(SERIALIZED_NAME_DATASET)
  private List<AccountDataset> dataset = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEATH_BENEFIT = "deathBenefit";
  @SerializedName(SERIALIZED_NAME_DEATH_BENEFIT)
  private Money deathBenefit;

  public static final String SERIALIZED_NAME_DERIVED_APR = "derivedApr";
  @SerializedName(SERIALIZED_NAME_DERIVED_APR)
  private Double derivedApr;

  public static final String SERIALIZED_NAME_DISPLAYED_NAME = "displayedName";
  @SerializedName(SERIALIZED_NAME_DISPLAYED_NAME)
  private String displayedName;

  public static final String SERIALIZED_NAME_DUE_DATE = "dueDate";
  @SerializedName(SERIALIZED_NAME_DUE_DATE)
  private String dueDate;

  public static final String SERIALIZED_NAME_ENROLLMENT_DATE = "enrollmentDate";
  @SerializedName(SERIALIZED_NAME_ENROLLMENT_DATE)
  private String enrollmentDate;

  public static final String SERIALIZED_NAME_ESCROW_BALANCE = "escrowBalance";
  @SerializedName(SERIALIZED_NAME_ESCROW_BALANCE)
  private Money escrowBalance;

  public static final String SERIALIZED_NAME_ESTIMATED_DATE = "estimatedDate";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_DATE)
  private String estimatedDate;

  public static final String SERIALIZED_NAME_EXPIRATION_DATE = "expirationDate";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_DATE)
  private String expirationDate;

  public static final String SERIALIZED_NAME_FACE_AMOUNT = "faceAmount";
  @SerializedName(SERIALIZED_NAME_FACE_AMOUNT)
  private Money faceAmount;

  /**
   * The frequency of the billing cycle of the account in case of card. The frequency in which premiums are paid in an insurance policy such as monthly, quarterly, and annually. The frequency in which due amounts are paid in a loan  account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;:  creditCard, insurance, loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(FrequencyEnum.Adapter.class)
  public enum FrequencyEnum {
    DAILY("DAILY"),
    
    ONE_TIME("ONE_TIME"),
    
    WEEKLY("WEEKLY"),
    
    EVERY_2_WEEKS("EVERY_2_WEEKS"),
    
    SEMI_MONTHLY("SEMI_MONTHLY"),
    
    MONTHLY("MONTHLY"),
    
    QUARTERLY("QUARTERLY"),
    
    SEMI_ANNUALLY("SEMI_ANNUALLY"),
    
    ANNUALLY("ANNUALLY"),
    
    EVERY_2_MONTHS("EVERY_2_MONTHS"),
    
    EBILL("EBILL"),
    
    FIRST_DAY_MONTHLY("FIRST_DAY_MONTHLY"),
    
    LAST_DAY_MONTHLY("LAST_DAY_MONTHLY"),
    
    EVERY_4_WEEKS("EVERY_4_WEEKS"),
    
    UNKNOWN("UNKNOWN"),
    
    OTHER("OTHER");

    private String value;

    FrequencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FrequencyEnum fromValue(String value) {
      for (FrequencyEnum b : FrequencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FrequencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FrequencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FrequencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FrequencyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FrequencyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FREQUENCY = "frequency";
  @SerializedName(SERIALIZED_NAME_FREQUENCY)
  private FrequencyEnum frequency;

  public static final String SERIALIZED_NAME_GUARANTOR = "guarantor";
  @SerializedName(SERIALIZED_NAME_GUARANTOR)
  private String guarantor;

  /**
   * Type of home insurance, like -&lt;ul&gt;&lt;li&gt;HOME_OWNER&lt;/li&gt;&lt;li&gt;RENTAL&lt;/li&gt;&lt;li&gt;RENTER&lt;/li&gt;&lt;li&gt;etc..&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(HomeInsuranceTypeEnum.Adapter.class)
  public enum HomeInsuranceTypeEnum {
    HOME_OWNER("HOME_OWNER"),
    
    RENTAL("RENTAL"),
    
    RENTER("RENTER"),
    
    UNKNOWN("UNKNOWN"),
    
    OTHER("OTHER");

    private String value;

    HomeInsuranceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HomeInsuranceTypeEnum fromValue(String value) {
      for (HomeInsuranceTypeEnum b : HomeInsuranceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HomeInsuranceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HomeInsuranceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HomeInsuranceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HomeInsuranceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      HomeInsuranceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_HOME_INSURANCE_TYPE = "homeInsuranceType";
  @SerializedName(SERIALIZED_NAME_HOME_INSURANCE_TYPE)
  private HomeInsuranceTypeEnum homeInsuranceType;

  public static final String SERIALIZED_NAME_HOME_VALUE = "homeValue";
  @SerializedName(SERIALIZED_NAME_HOME_VALUE)
  private Money homeValue;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_INCLUDE_IN_NET_WORTH = "includeInNetWorth";
  @SerializedName(SERIALIZED_NAME_INCLUDE_IN_NET_WORTH)
  private Boolean includeInNetWorth;

  public static final String SERIALIZED_NAME_INTEREST_PAID_LAST_YEAR = "interestPaidLastYear";
  @SerializedName(SERIALIZED_NAME_INTEREST_PAID_LAST_YEAR)
  private Money interestPaidLastYear;

  public static final String SERIALIZED_NAME_INTEREST_PAID_Y_T_D = "interestPaidYTD";
  @SerializedName(SERIALIZED_NAME_INTEREST_PAID_Y_T_D)
  private Money interestPaidYTD;

  public static final String SERIALIZED_NAME_INTEREST_RATE = "interestRate";
  @SerializedName(SERIALIZED_NAME_INTEREST_RATE)
  private Double interestRate;

  /**
   * The type of the interest rate, for example, fixed or variable.&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(InterestRateTypeEnum.Adapter.class)
  public enum InterestRateTypeEnum {
    FIXED("FIXED"),
    
    VARIABLE("VARIABLE"),
    
    UNKNOWN("UNKNOWN"),
    
    OTHER("OTHER");

    private String value;

    InterestRateTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InterestRateTypeEnum fromValue(String value) {
      for (InterestRateTypeEnum b : InterestRateTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InterestRateTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InterestRateTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InterestRateTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InterestRateTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InterestRateTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INTEREST_RATE_TYPE = "interestRateType";
  @SerializedName(SERIALIZED_NAME_INTEREST_RATE_TYPE)
  private InterestRateTypeEnum interestRateType;

  public static final String SERIALIZED_NAME_IS_ASSET = "isAsset";
  @SerializedName(SERIALIZED_NAME_IS_ASSET)
  private Boolean isAsset;

  public static final String SERIALIZED_NAME_IS_DELETED = "isDeleted";
  @SerializedName(SERIALIZED_NAME_IS_DELETED)
  private Boolean isDeleted;

  public static final String SERIALIZED_NAME_IS_MANUAL = "isManual";
  @SerializedName(SERIALIZED_NAME_IS_MANUAL)
  private Boolean isManual;

  public static final String SERIALIZED_NAME_LAST_EMPLOYEE_CONTRIBUTION_AMOUNT = "lastEmployeeContributionAmount";
  @SerializedName(SERIALIZED_NAME_LAST_EMPLOYEE_CONTRIBUTION_AMOUNT)
  private Money lastEmployeeContributionAmount;

  public static final String SERIALIZED_NAME_LAST_EMPLOYEE_CONTRIBUTION_DATE = "lastEmployeeContributionDate";
  @SerializedName(SERIALIZED_NAME_LAST_EMPLOYEE_CONTRIBUTION_DATE)
  private String lastEmployeeContributionDate;

  public static final String SERIALIZED_NAME_LAST_PAYMENT = "lastPayment";
  @SerializedName(SERIALIZED_NAME_LAST_PAYMENT)
  private Money lastPayment;

  public static final String SERIALIZED_NAME_LAST_PAYMENT_AMOUNT = "lastPaymentAmount";
  @SerializedName(SERIALIZED_NAME_LAST_PAYMENT_AMOUNT)
  private Money lastPaymentAmount;

  public static final String SERIALIZED_NAME_LAST_PAYMENT_DATE = "lastPaymentDate";
  @SerializedName(SERIALIZED_NAME_LAST_PAYMENT_DATE)
  private String lastPaymentDate;

  public static final String SERIALIZED_NAME_LAST_UPDATED = "lastUpdated";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED)
  private String lastUpdated;

  public static final String SERIALIZED_NAME_LENDER = "lender";
  @SerializedName(SERIALIZED_NAME_LENDER)
  private String lender;

  /**
   * Type of life insurance.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(LifeInsuranceTypeEnum.Adapter.class)
  public enum LifeInsuranceTypeEnum {
    OTHER("OTHER"),
    
    TERM_LIFE_INSURANCE("TERM_LIFE_INSURANCE"),
    
    UNIVERSAL_LIFE_INSURANCE("UNIVERSAL_LIFE_INSURANCE"),
    
    WHOLE_LIFE_INSURANCE("WHOLE_LIFE_INSURANCE"),
    
    VARIABLE_LIFE_INSURANCE("VARIABLE_LIFE_INSURANCE"),
    
    ULIP("ULIP"),
    
    ENDOWMENT("ENDOWMENT");

    private String value;

    LifeInsuranceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LifeInsuranceTypeEnum fromValue(String value) {
      for (LifeInsuranceTypeEnum b : LifeInsuranceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LifeInsuranceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LifeInsuranceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LifeInsuranceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LifeInsuranceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LifeInsuranceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LIFE_INSURANCE_TYPE = "lifeInsuranceType";
  @SerializedName(SERIALIZED_NAME_LIFE_INSURANCE_TYPE)
  private LifeInsuranceTypeEnum lifeInsuranceType;

  public static final String SERIALIZED_NAME_LOAN_PAY_BY_DATE = "loanPayByDate";
  @SerializedName(SERIALIZED_NAME_LOAN_PAY_BY_DATE)
  private String loanPayByDate;

  public static final String SERIALIZED_NAME_LOAN_PAYOFF_AMOUNT = "loanPayoffAmount";
  @SerializedName(SERIALIZED_NAME_LOAN_PAYOFF_AMOUNT)
  private Money loanPayoffAmount;

  public static final String SERIALIZED_NAME_LOAN_PAYOFF_DETAILS = "loanPayoffDetails";
  @SerializedName(SERIALIZED_NAME_LOAN_PAYOFF_DETAILS)
  private LoanPayoffDetails loanPayoffDetails;

  public static final String SERIALIZED_NAME_MARGIN_BALANCE = "marginBalance";
  @SerializedName(SERIALIZED_NAME_MARGIN_BALANCE)
  private Money marginBalance;

  public static final String SERIALIZED_NAME_MATURITY_AMOUNT = "maturityAmount";
  @SerializedName(SERIALIZED_NAME_MATURITY_AMOUNT)
  private Money maturityAmount;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private String maturityDate;

  public static final String SERIALIZED_NAME_MEMO = "memo";
  @SerializedName(SERIALIZED_NAME_MEMO)
  private String memo;

  public static final String SERIALIZED_NAME_MINIMUM_AMOUNT_DUE = "minimumAmountDue";
  @SerializedName(SERIALIZED_NAME_MINIMUM_AMOUNT_DUE)
  private Money minimumAmountDue;

  public static final String SERIALIZED_NAME_MONEY_MARKET_BALANCE = "moneyMarketBalance";
  @SerializedName(SERIALIZED_NAME_MONEY_MARKET_BALANCE)
  private Money moneyMarketBalance;

  public static final String SERIALIZED_NAME_NEXT_LEVEL = "nextLevel";
  @SerializedName(SERIALIZED_NAME_NEXT_LEVEL)
  private String nextLevel;

  public static final String SERIALIZED_NAME_NICKNAME = "nickname";
  @SerializedName(SERIALIZED_NAME_NICKNAME)
  private String nickname;

  /**
   * Indicates the migration status of the account from screen-scraping provider to the Open Banking provider. &lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   */
  @JsonAdapter(OauthMigrationStatusEnum.Adapter.class)
  public enum OauthMigrationStatusEnum {
    IN_PROGRESS("IN_PROGRESS"),
    
    TO_BE_MIGRATED("TO_BE_MIGRATED"),
    
    COMPLETED("COMPLETED");

    private String value;

    OauthMigrationStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OauthMigrationStatusEnum fromValue(String value) {
      for (OauthMigrationStatusEnum b : OauthMigrationStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OauthMigrationStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OauthMigrationStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OauthMigrationStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OauthMigrationStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OauthMigrationStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OAUTH_MIGRATION_STATUS = "oauthMigrationStatus";
  @SerializedName(SERIALIZED_NAME_OAUTH_MIGRATION_STATUS)
  private OauthMigrationStatusEnum oauthMigrationStatus;

  public static final String SERIALIZED_NAME_ORIGINAL_LOAN_AMOUNT = "originalLoanAmount";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_LOAN_AMOUNT)
  private Money originalLoanAmount;

  public static final String SERIALIZED_NAME_ORIGINATION_DATE = "originationDate";
  @SerializedName(SERIALIZED_NAME_ORIGINATION_DATE)
  private String originationDate;

  public static final String SERIALIZED_NAME_OVER_DRAFT_LIMIT = "overDraftLimit";
  @SerializedName(SERIALIZED_NAME_OVER_DRAFT_LIMIT)
  private Money overDraftLimit;

  public static final String SERIALIZED_NAME_POLICY_EFFECTIVE_DATE = "policyEffectiveDate";
  @SerializedName(SERIALIZED_NAME_POLICY_EFFECTIVE_DATE)
  private String policyEffectiveDate;

  public static final String SERIALIZED_NAME_POLICY_FROM_DATE = "policyFromDate";
  @SerializedName(SERIALIZED_NAME_POLICY_FROM_DATE)
  private String policyFromDate;

  /**
   * The status of the policy.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(PolicyStatusEnum.Adapter.class)
  public enum PolicyStatusEnum {
    ACTIVE("ACTIVE"),
    
    INACTIVE("INACTIVE"),
    
    OTHER("OTHER");

    private String value;

    PolicyStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PolicyStatusEnum fromValue(String value) {
      for (PolicyStatusEnum b : PolicyStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PolicyStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PolicyStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PolicyStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PolicyStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PolicyStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_POLICY_STATUS = "policyStatus";
  @SerializedName(SERIALIZED_NAME_POLICY_STATUS)
  private PolicyStatusEnum policyStatus;

  public static final String SERIALIZED_NAME_POLICY_TERM = "policyTerm";
  @SerializedName(SERIALIZED_NAME_POLICY_TERM)
  private String policyTerm;

  public static final String SERIALIZED_NAME_POLICY_TO_DATE = "policyToDate";
  @SerializedName(SERIALIZED_NAME_POLICY_TO_DATE)
  private String policyToDate;

  public static final String SERIALIZED_NAME_PREMIUM = "premium";
  @SerializedName(SERIALIZED_NAME_PREMIUM)
  private Money premium;

  public static final String SERIALIZED_NAME_PREMIUM_PAYMENT_TERM = "premiumPaymentTerm";
  @SerializedName(SERIALIZED_NAME_PREMIUM_PAYMENT_TERM)
  private String premiumPaymentTerm;

  public static final String SERIALIZED_NAME_PRIMARY_REWARD_UNIT = "primaryRewardUnit";
  @SerializedName(SERIALIZED_NAME_PRIMARY_REWARD_UNIT)
  private String primaryRewardUnit;

  public static final String SERIALIZED_NAME_PRINCIPAL_BALANCE = "principalBalance";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL_BALANCE)
  private Money principalBalance;

  public static final String SERIALIZED_NAME_PROVIDER_ACCOUNT_ID = "providerAccountId";
  @SerializedName(SERIALIZED_NAME_PROVIDER_ACCOUNT_ID)
  private Long providerAccountId;

  public static final String SERIALIZED_NAME_PROVIDER_ID = "providerId";
  @SerializedName(SERIALIZED_NAME_PROVIDER_ID)
  private String providerId;

  public static final String SERIALIZED_NAME_PROVIDER_NAME = "providerName";
  @SerializedName(SERIALIZED_NAME_PROVIDER_NAME)
  private String providerName;

  public static final String SERIALIZED_NAME_RECURRING_PAYMENT = "recurringPayment";
  @SerializedName(SERIALIZED_NAME_RECURRING_PAYMENT)
  private Money recurringPayment;

  public static final String SERIALIZED_NAME_REMAINING_BALANCE = "remainingBalance";
  @SerializedName(SERIALIZED_NAME_REMAINING_BALANCE)
  private Money remainingBalance;

  /**
   * The type of repayment plan that the borrower prefers to repay the loan. &lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values:&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(RepaymentPlanTypeEnum.Adapter.class)
  public enum RepaymentPlanTypeEnum {
    STANDARD("STANDARD"),
    
    GRADUATED("GRADUATED"),
    
    EXTENDED("EXTENDED"),
    
    INCOME_BASED("INCOME_BASED"),
    
    INCOME_CONTINGENT("INCOME_CONTINGENT"),
    
    INCOME_SENSITIVE("INCOME_SENSITIVE"),
    
    PAY_AS_YOU_EARN("PAY_AS_YOU_EARN"),
    
    REVISED_PAY_AS_YOU_EARN("REVISED_PAY_AS_YOU_EARN");

    private String value;

    RepaymentPlanTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RepaymentPlanTypeEnum fromValue(String value) {
      for (RepaymentPlanTypeEnum b : RepaymentPlanTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RepaymentPlanTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RepaymentPlanTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RepaymentPlanTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RepaymentPlanTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RepaymentPlanTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REPAYMENT_PLAN_TYPE = "repaymentPlanType";
  @SerializedName(SERIALIZED_NAME_REPAYMENT_PLAN_TYPE)
  private RepaymentPlanTypeEnum repaymentPlanType;

  public static final String SERIALIZED_NAME_REWARD_BALANCE = "rewardBalance";
  @SerializedName(SERIALIZED_NAME_REWARD_BALANCE)
  private List<RewardBalance> rewardBalance = new ArrayList<>();

  public static final String SERIALIZED_NAME_RUNNING_BALANCE = "runningBalance";
  @SerializedName(SERIALIZED_NAME_RUNNING_BALANCE)
  private Money runningBalance;

  public static final String SERIALIZED_NAME_SHORT_BALANCE = "shortBalance";
  @SerializedName(SERIALIZED_NAME_SHORT_BALANCE)
  private Money shortBalance;

  /**
   * Indicates the status of the loan account. &lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values:&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(SourceAccountStatusEnum.Adapter.class)
  public enum SourceAccountStatusEnum {
    IN_REPAYMENT("IN_REPAYMENT"),
    
    DEFAULTED("DEFAULTED"),
    
    IN_SCHOOL("IN_SCHOOL"),
    
    IN_GRACE_PERIOD("IN_GRACE_PERIOD"),
    
    DELINQUENCY("DELINQUENCY"),
    
    DEFERMENT("DEFERMENT"),
    
    FORBEARANCE("FORBEARANCE");

    private String value;

    SourceAccountStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SourceAccountStatusEnum fromValue(String value) {
      for (SourceAccountStatusEnum b : SourceAccountStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SourceAccountStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SourceAccountStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SourceAccountStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SourceAccountStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SourceAccountStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SOURCE_ACCOUNT_STATUS = "sourceAccountStatus";
  @SerializedName(SERIALIZED_NAME_SOURCE_ACCOUNT_STATUS)
  private SourceAccountStatusEnum sourceAccountStatus;

  public static final String SERIALIZED_NAME_SOURCE_ID = "sourceId";
  @SerializedName(SERIALIZED_NAME_SOURCE_ID)
  private String sourceId;

  public static final String SERIALIZED_NAME_TERM = "term";
  @SerializedName(SERIALIZED_NAME_TERM)
  private String term;

  public static final String SERIALIZED_NAME_TOTAL_CASH_LIMIT = "totalCashLimit";
  @SerializedName(SERIALIZED_NAME_TOTAL_CASH_LIMIT)
  private Money totalCashLimit;

  public static final String SERIALIZED_NAME_TOTAL_CREDIT_LIMIT = "totalCreditLimit";
  @SerializedName(SERIALIZED_NAME_TOTAL_CREDIT_LIMIT)
  private Money totalCreditLimit;

  public static final String SERIALIZED_NAME_TOTAL_CREDIT_LINE = "totalCreditLine";
  @SerializedName(SERIALIZED_NAME_TOTAL_CREDIT_LINE)
  private Money totalCreditLine;

  public static final String SERIALIZED_NAME_TOTAL_UNVESTED_BALANCE = "totalUnvestedBalance";
  @SerializedName(SERIALIZED_NAME_TOTAL_UNVESTED_BALANCE)
  private Money totalUnvestedBalance;

  public static final String SERIALIZED_NAME_TOTAL_VESTED_BALANCE = "totalVestedBalance";
  @SerializedName(SERIALIZED_NAME_TOTAL_VESTED_BALANCE)
  private Money totalVestedBalance;

  /**
   * &lt;b&gt;Applicable containers&lt;/b&gt;: reward, bank, creditCard, investment, loan, insurance, realEstate,  otherLiabilities&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts &lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;POST accounts&lt;/ul&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(UserClassificationEnum.Adapter.class)
  public enum UserClassificationEnum {
    BUSINESS("BUSINESS"),
    
    PERSONAL("PERSONAL");

    private String value;

    UserClassificationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static UserClassificationEnum fromValue(String value) {
      for (UserClassificationEnum b : UserClassificationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<UserClassificationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final UserClassificationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public UserClassificationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return UserClassificationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      UserClassificationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_USER_CLASSIFICATION = "userClassification";
  @SerializedName(SERIALIZED_NAME_USER_CLASSIFICATION)
  private UserClassificationEnum userClassification;

  /**
   * The valuation type indicates whether the home value is calculated either manually or by Yodlee Partners.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Manual&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: realEstate&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(ValuationTypeEnum.Adapter.class)
  public enum ValuationTypeEnum {
    SYSTEM("SYSTEM"),
    
    MANUAL("MANUAL");

    private String value;

    ValuationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValuationTypeEnum fromValue(String value) {
      for (ValuationTypeEnum b : ValuationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ValuationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValuationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValuationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValuationTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ValuationTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALUATION_TYPE = "valuationType";
  @SerializedName(SERIALIZED_NAME_VALUATION_TYPE)
  private ValuationTypeEnum valuationType;

  public DataExtractsAccount() {
  }

  public DataExtractsAccount(
     CONTAINEREnum CONTAINER, 
     String accountName, 
     String accountNumber, 
     AccountStatusEnum accountStatus, 
     String accountType, 
     AggregationSourceEnum aggregationSource, 
     Double annualPercentageYield, 
     Double apr, 
     List<Long> associatedProviderAccountId, 
     List<BankTransferCode> bankTransferCode, 
     ClassificationEnum classification, 
     String collateral, 
     List<Coverage> coverage, 
     String createdDate, 
     String currentLevel, 
     List<AccountDataset> dataset, 
     Double derivedApr, 
     String displayedName, 
     String dueDate, 
     String enrollmentDate, 
     String estimatedDate, 
     String expirationDate, 
     FrequencyEnum frequency, 
     String guarantor, 
     HomeInsuranceTypeEnum homeInsuranceType, 
     Long id, 
     Boolean includeInNetWorth, 
     Double interestRate, 
     InterestRateTypeEnum interestRateType, 
     Boolean isAsset, 
     Boolean isDeleted, 
     Boolean isManual, 
     String lastEmployeeContributionDate, 
     String lastPaymentDate, 
     String lastUpdated, 
     String lender, 
     LifeInsuranceTypeEnum lifeInsuranceType, 
     String loanPayByDate, 
     String maturityDate, 
     String memo, 
     String nextLevel, 
     String nickname, 
     OauthMigrationStatusEnum oauthMigrationStatus, 
     String originationDate, 
     String policyEffectiveDate, 
     String policyFromDate, 
     PolicyStatusEnum policyStatus, 
     String policyTerm, 
     String policyToDate, 
     String premiumPaymentTerm, 
     String primaryRewardUnit, 
     Long providerAccountId, 
     String providerId, 
     String providerName, 
     RepaymentPlanTypeEnum repaymentPlanType, 
     List<RewardBalance> rewardBalance, 
     SourceAccountStatusEnum sourceAccountStatus, 
     String sourceId, 
     String term, 
     UserClassificationEnum userClassification, 
     ValuationTypeEnum valuationType
  ) {
    this();
    this.CONTAINER = CONTAINER;
    this.accountName = accountName;
    this.accountNumber = accountNumber;
    this.accountStatus = accountStatus;
    this.accountType = accountType;
    this.aggregationSource = aggregationSource;
    this.annualPercentageYield = annualPercentageYield;
    this.apr = apr;
    this.associatedProviderAccountId = associatedProviderAccountId;
    this.bankTransferCode = bankTransferCode;
    this.classification = classification;
    this.collateral = collateral;
    this.coverage = coverage;
    this.createdDate = createdDate;
    this.currentLevel = currentLevel;
    this.dataset = dataset;
    this.derivedApr = derivedApr;
    this.displayedName = displayedName;
    this.dueDate = dueDate;
    this.enrollmentDate = enrollmentDate;
    this.estimatedDate = estimatedDate;
    this.expirationDate = expirationDate;
    this.frequency = frequency;
    this.guarantor = guarantor;
    this.homeInsuranceType = homeInsuranceType;
    this.id = id;
    this.includeInNetWorth = includeInNetWorth;
    this.interestRate = interestRate;
    this.interestRateType = interestRateType;
    this.isAsset = isAsset;
    this.isDeleted = isDeleted;
    this.isManual = isManual;
    this.lastEmployeeContributionDate = lastEmployeeContributionDate;
    this.lastPaymentDate = lastPaymentDate;
    this.lastUpdated = lastUpdated;
    this.lender = lender;
    this.lifeInsuranceType = lifeInsuranceType;
    this.loanPayByDate = loanPayByDate;
    this.maturityDate = maturityDate;
    this.memo = memo;
    this.nextLevel = nextLevel;
    this.nickname = nickname;
    this.oauthMigrationStatus = oauthMigrationStatus;
    this.originationDate = originationDate;
    this.policyEffectiveDate = policyEffectiveDate;
    this.policyFromDate = policyFromDate;
    this.policyStatus = policyStatus;
    this.policyTerm = policyTerm;
    this.policyToDate = policyToDate;
    this.premiumPaymentTerm = premiumPaymentTerm;
    this.primaryRewardUnit = primaryRewardUnit;
    this.providerAccountId = providerAccountId;
    this.providerId = providerId;
    this.providerName = providerName;
    this.repaymentPlanType = repaymentPlanType;
    this.rewardBalance = rewardBalance;
    this.sourceAccountStatus = sourceAccountStatus;
    this.sourceId = sourceId;
    this.term = term;
    this.userClassification = userClassification;
    this.valuationType = valuationType;
  }

  public DataExtractsAccount _401kLoan(Money _401kLoan) {
    this._401kLoan = _401kLoan;
    return this;
  }

  /**
   * Get _401kLoan
   * @return _401kLoan
   */
  @javax.annotation.Nullable
  public Money get401kLoan() {
    return _401kLoan;
  }

  public void set401kLoan(Money _401kLoan) {
    this._401kLoan = _401kLoan;
  }


  /**
   * The type of service. E.g., Bank, Credit Card, Investment, Insurance, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return CONTAINER
   */
  @javax.annotation.Nullable
  public CONTAINEREnum getCONTAINER() {
    return CONTAINER;
  }



  /**
   * The account name as it appears at the site.&lt;br&gt;(The POST accounts service response return this field as name)&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return accountName
   */
  @javax.annotation.Nullable
  public String getAccountName() {
    return accountName;
  }



  /**
   * The account number as it appears on the site. (The POST accounts service response return this field as number)&lt;br&gt;&lt;b&gt;Additional Details&lt;/b&gt;:&lt;b&gt; Bank/ Loan/ Insurance/ Investment&lt;/b&gt;:&lt;br&gt; The account number for the bank account as it appears at the site.&lt;br&gt;&lt;b&gt;Credit Card&lt;/b&gt;: The account number of the card account as it appears at the site,&lt;br&gt;i.e., the card number.The account number can be full or partial based on how it is displayed in the account summary page of the site.In most cases, the site does not display the full account number in the account summary page and additional navigation is required to aggregate it.&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;POST accounts&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return accountNumber
   */
  @javax.annotation.Nullable
  public String getAccountNumber() {
    return accountNumber;
  }



  /**
   * The status of the account that is updated by the consumer through an application or an API. Valid Values: AccountStatus&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt;&lt;br&gt;&lt;b&gt;ACTIVE:&lt;/b&gt; All the added manual and aggregated accounts status will be made \&quot;ACTIVE\&quot; by default. &lt;br&gt;&lt;b&gt;TO_BE_CLOSED:&lt;/b&gt; If the aggregated accounts are not found or closed in the data provider site, Yodlee system marks the status as TO_BE_CLOSED&lt;br&gt;&lt;b&gt;INACTIVE:&lt;/b&gt; Users can update the status as INACTIVE to stop updating and to stop considering the account in other services&lt;br&gt;&lt;b&gt;CLOSED:&lt;/b&gt; Users can update the status as CLOSED, if the account is closed with the provider. &lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return accountStatus
   */
  @javax.annotation.Nullable
  public AccountStatusEnum getAccountStatus() {
    return accountStatus;
  }



  /**
   * The type of account that is aggregated, i.e., savings, checking, credit card, charge, HELOC, etc. The account type is derived based on the attributes of the account. &lt;br&gt;&lt;b&gt;Valid Values:&lt;/b&gt;&lt;br&gt;&lt;b&gt;Aggregated Account Type&lt;/b&gt;&lt;br&gt;&lt;b&gt;bank&lt;/b&gt;&lt;ul&gt;&lt;li&gt;CHECKING&lt;/li&gt;&lt;li&gt;SAVINGS&lt;/li&gt;&lt;li&gt;CD&lt;/li&gt;&lt;li&gt;PPF&lt;/li&gt;&lt;li&gt;RECURRING_DEPOSIT&lt;/li&gt;&lt;li&gt;FSA&lt;/li&gt;&lt;li&gt;MONEY_MARKET&lt;/li&gt;&lt;li&gt;IRA&lt;/li&gt;&lt;li&gt;PREPAID&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;creditCard&lt;/b&gt;&lt;ul&gt;&lt;li&gt;OTHER&lt;/li&gt;&lt;li&gt;CREDIT&lt;/li&gt;&lt;li&gt;STORE&lt;/li&gt;&lt;li&gt;CHARGE&lt;/li&gt;&lt;li&gt;OTHER&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;investment (SN 1.0)&lt;/b&gt;&lt;ul&gt;&lt;li&gt;BROKERAGE_MARGIN&lt;/li&gt;&lt;li&gt;HSA&lt;/li&gt;&lt;li&gt;IRA&lt;/li&gt;&lt;li&gt;BROKERAGE_CASH&lt;/li&gt;&lt;li&gt;401K&lt;/li&gt;&lt;li&gt;403B&lt;/li&gt;&lt;li&gt;TRUST&lt;/li&gt;&lt;li&gt;ANNUITY&lt;/li&gt;&lt;li&gt;SIMPLE&lt;/li&gt;&lt;li&gt;CUSTODIAL&lt;/li&gt;&lt;li&gt;BROKERAGE_CASH_OPTION&lt;/li&gt;&lt;li&gt;BROKERAGE_MARGIN_OPTION&lt;/li&gt;&lt;li&gt;INDIVIDUAL&lt;/li&gt;&lt;li&gt;CORPORATE&lt;/li&gt;&lt;li&gt;JTTIC&lt;/li&gt;&lt;li&gt;JTWROS&lt;/li&gt;&lt;li&gt;COMMUNITY_PROPERTY&lt;/li&gt;&lt;li&gt;JOINT_BY_ENTIRETY&lt;/li&gt;&lt;li&gt;CONSERVATORSHIP&lt;/li&gt;&lt;li&gt;ROTH&lt;/li&gt;&lt;li&gt;ROTH_CONVERSION&lt;/li&gt;&lt;li&gt;ROLLOVER&lt;/li&gt;&lt;li&gt;EDUCATIONAL&lt;/li&gt;&lt;li&gt;529_PLAN&lt;/li&gt;&lt;li&gt;457_DEFERRED_COMPENSATION&lt;/li&gt;&lt;li&gt;401A&lt;/li&gt;&lt;li&gt;PSP&lt;/li&gt;&lt;li&gt;MPP&lt;/li&gt;&lt;li&gt;STOCK_BASKET&lt;/li&gt;&lt;li&gt;LIVING_TRUST&lt;/li&gt;&lt;li&gt;REVOCABLE_TRUST&lt;/li&gt;&lt;li&gt;IRREVOCABLE_TRUST&lt;/li&gt;&lt;li&gt;CHARITABLE_REMAINDER&lt;/li&gt;&lt;li&gt;CHARITABLE_LEAD&lt;/li&gt;&lt;li&gt;CHARITABLE_GIFT_ACCOUNT&lt;/li&gt;&lt;li&gt;SEP&lt;/li&gt;&lt;li&gt;UTMA&lt;/li&gt;&lt;li&gt;UGMA&lt;/li&gt;&lt;li&gt;ESOPP&lt;/li&gt;&lt;li&gt;ADMINISTRATOR&lt;/li&gt;&lt;li&gt;EXECUTOR&lt;/li&gt;&lt;li&gt;PARTNERSHIP&lt;/li&gt;&lt;li&gt;SOLE_PROPRIETORSHIP&lt;/li&gt;&lt;li&gt;CHURCH&lt;/li&gt;&lt;li&gt;INVESTMENT_CLUB&lt;/li&gt;&lt;li&gt;RESTRICTED_STOCK_AWARD&lt;/li&gt;&lt;li&gt;CMA&lt;/li&gt;&lt;li&gt;EMPLOYEE_STOCK_PURCHASE_PLAN&lt;/li&gt;&lt;li&gt;PERFORMANCE_PLAN&lt;/li&gt;&lt;li&gt;BROKERAGE_LINK_ACCOUNT&lt;/li&gt;&lt;li&gt;MONEY_MARKET&lt;/li&gt;&lt;li&gt;SUPER_ANNUATION&lt;/li&gt;&lt;li&gt;REGISTERED_RETIREMENT_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;SPOUSAL_RETIREMENT_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;DEFERRED_PROFIT_SHARING_PLAN&lt;/li&gt;&lt;li&gt;NON_REGISTERED_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;REGISTERED_EDUCATION_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;GROUP_RETIREMENT_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;LOCKED_IN_RETIREMENT_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;RESTRICTED_LOCKED_IN_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;LOCKED_IN_RETIREMENT_ACCOUNT&lt;/li&gt;&lt;li&gt;REGISTERED_PENSION_PLAN&lt;/li&gt;&lt;li&gt;TAX_FREE_SAVINGS_ACCOUNT&lt;/li&gt;&lt;li&gt;LIFE_INCOME_FUND&lt;/li&gt;&lt;li&gt;REGISTERED_RETIREMENT_INCOME_FUND&lt;/li&gt;&lt;li&gt;SPOUSAL_RETIREMENT_INCOME_FUND&lt;/li&gt;&lt;li&gt;LOCKED_IN_REGISTERED_INVESTMENT_FUND&lt;/li&gt;&lt;li&gt;PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND&lt;/li&gt;&lt;li&gt;GUARANTEED_INVESTMENT_CERTIFICATES&lt;/li&gt;&lt;li&gt;REGISTERED_DISABILITY_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;OTHER&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;investment (SN 2.0)&lt;/b&gt;&lt;ul&gt;&lt;li&gt;BROKERAGE_CASH&lt;/li&gt;&lt;li&gt;BROKERAGE_MARGIN&lt;/li&gt;&lt;li&gt;INDIVIDUAL_RETIREMENT_ACCOUNT_IRA&lt;/li&gt;&lt;li&gt;EMPLOYEE_RETIREMENT_ACCOUNT_401K&lt;/li&gt;&lt;li&gt;EMPLOYEE_RETIREMENT_SAVINGS_PLAN_403B&lt;/li&gt;&lt;li&gt;TRUST&lt;/li&gt;&lt;li&gt;ANNUITY&lt;/li&gt;&lt;li&gt;SIMPLE_IRA&lt;/li&gt;&lt;li&gt;CUSTODIAL_ACCOUNT&lt;/li&gt;&lt;li&gt;BROKERAGE_CASH_OPTION&lt;/li&gt;&lt;li&gt;BROKERAGE_MARGIN_OPTION&lt;/li&gt;&lt;li&gt;INDIVIDUAL&lt;/li&gt;&lt;li&gt;CORPORATE_INVESTMENT_ACCOUNT&lt;/li&gt;&lt;li&gt;JOINT_TENANTS_TENANCY_IN_COMMON_JTIC&lt;/li&gt;&lt;li&gt;JOINT_TENANTS_WITH_RIGHTS_OF_SURVIVORSHIP_JTWROS&lt;/li&gt;&lt;li&gt;JOINT_TENANTS_COMMUNITY_PROPERTY&lt;/li&gt;&lt;li&gt;JOINT_TENANTS_TENANTS_BY_ENTIRETY&lt;/li&gt;&lt;li&gt;CONSERVATOR&lt;/li&gt;&lt;li&gt;ROTH_IRA&lt;/li&gt;&lt;li&gt;ROTH_CONVERSION&lt;/li&gt;&lt;li&gt;ROLLOVER_IRA&lt;/li&gt;&lt;li&gt;EDUCATIONAL&lt;/li&gt;&lt;li&gt;EDUCATIONAL_SAVINGS_PLAN_529&lt;/li&gt;&lt;li&gt;DEFERRED_COMPENSATION_PLAN_457&lt;/li&gt;&lt;li&gt;MONEY_PURCHASE_RETIREMENT_PLAN_401A&lt;/li&gt;&lt;li&gt;PROFIT_SHARING_PLAN&lt;/li&gt;&lt;li&gt;MONEY_PURCHASE_PLAN&lt;/li&gt;&lt;li&gt;STOCK_BASKET_ACCOUNT&lt;/li&gt;&lt;li&gt;LIVING_TRUST&lt;/li&gt;&lt;li&gt;REVOCABLE_TRUST&lt;/li&gt;&lt;li&gt;IRREVOCABLE_TRUST&lt;/li&gt;&lt;li&gt;CHARITABLE_REMAINDER_TRUST&lt;/li&gt;&lt;li&gt;CHARITABLE_LEAD_TRUST&lt;/li&gt;&lt;li&gt;CHARITABLE_GIFT_ACCOUNT&lt;/li&gt;&lt;li&gt;SEP_IRA&lt;/li&gt;&lt;li&gt;UNIFORM_TRANSFER_TO_MINORS_ACT_UTMA&lt;/li&gt;&lt;li&gt;UNIFORM_GIFT_TO_MINORS_ACT_UGMA&lt;/li&gt;&lt;li&gt;EMPLOYEE_STOCK_OWNERSHIP_PLAN_ESOP&lt;/li&gt;&lt;li&gt;ADMINISTRATOR&lt;/li&gt;&lt;li&gt;EXECUTOR&lt;/li&gt;&lt;li&gt;PARTNERSHIP&lt;/li&gt;&lt;li&gt;PROPRIETORSHIP&lt;/li&gt;&lt;li&gt;CHURCH_ACCOUNT&lt;/li&gt;&lt;li&gt;INVESTMENT_CLUB&lt;/li&gt;&lt;li&gt;RESTRICTED_STOCK_AWARD&lt;/li&gt;&lt;li&gt;CASH_MANAGEMENT_ACCOUNT&lt;/li&gt;&lt;li&gt;EMPLOYEE_STOCK_PURCHASE_PLAN_ESPP&lt;/li&gt;&lt;li&gt;PERFORMANCE_PLAN&lt;/li&gt;&lt;li&gt;BROKERAGE_LINK_ACCOUNT&lt;/li&gt;&lt;li&gt;MONEY_MARKET_ACCOUNT&lt;/li&gt;&lt;li&gt;SUPERANNUATION&lt;/li&gt;&lt;li&gt;REGISTERED_RETIREMENT_SAVINGS_PLAN_RRSP&lt;/li&gt;&lt;li&gt;SPOUSAL_RETIREMENT_SAVINGS_PLAN_SRSP&lt;/li&gt;&lt;li&gt;DEFERRED_PROFIT_SHARING_PLAN_DPSP&lt;/li&gt;&lt;li&gt;NON_REGISTERED_SAVINGS_PLAN_NRSP&lt;/li&gt;&lt;li&gt;REGISTERED_EDUCATION_SAVINGS_PLAN_RESP&lt;/li&gt;&lt;li&gt;GROUP_RETIREMENT_SAVINGS_PLAN_GRSP&lt;/li&gt;&lt;li&gt;LOCKED_IN_RETIREMENT_SAVINGS_PLAN_LRSP&lt;/li&gt;&lt;li&gt;RESTRICTED_LOCKED_IN_SAVINGS_PLAN_RLSP&lt;/li&gt;&lt;li&gt;LOCKED_IN_RETIREMENT_ACCOUNT_LIRA&lt;/li&gt;&lt;li&gt;REGISTERED_PENSION_PLAN_RPP&lt;/li&gt;&lt;li&gt;TAX_FREE_SAVINGS_ACCOUNT_TFSA&lt;/li&gt;&lt;li&gt;LIFE_INCOME_FUND_LIF&lt;/li&gt;&lt;li&gt;REGISTERED_RETIREMENT_INCOME_FUND_RIF&lt;/li&gt;&lt;li&gt;SPOUSAL_RETIREMENT_INCOME_FUND_SRIF&lt;/li&gt;&lt;li&gt;LOCKED_IN_REGISTERED_INVESTMENT_FUND_LRIF&lt;/li&gt;&lt;li&gt;PRESCRIBED_REGISTERED_RETIREMENT_INCOME_FUND_PRIF&lt;/li&gt;&lt;li&gt;GUARANTEED_INVESTMENT_CERTIFICATES_GIC&lt;/li&gt;&lt;li&gt;REGISTERED_DISABILITY_SAVINGS_PLAN_RDSP&lt;/li&gt;&lt;li&gt;DEFINED_CONTRIBUTION_PLAN&lt;/li&gt;&lt;li&gt;DEFINED_BENEFIT_PLAN&lt;/li&gt;&lt;li&gt;EMPLOYEE_STOCK_OPTION_PLAN&lt;/li&gt;&lt;li&gt;NONQUALIFIED_DEFERRED_COMPENSATION_PLAN_409A&lt;/li&gt;&lt;li&gt;KEOGH_PLAN&lt;/li&gt;&lt;li&gt;EMPLOYEE_RETIREMENT_ACCOUNT_ROTH_401K&lt;/li&gt;&lt;li&gt;DEFERRED_CONTINGENT_CAPITAL_PLAN_DCCP&lt;/li&gt;&lt;li&gt;EMPLOYEE_BENEFIT_PLAN&lt;/li&gt;&lt;li&gt;EMPLOYEE_SAVINGS_PLAN&lt;/li&gt;&lt;li&gt;HEALTH_SAVINGS_ACCOUNT_HSA&lt;/li&gt;&lt;li&gt;COVERDELL_EDUCATION_SAVINGS_ACCOUNT_ESA&lt;/li&gt;&lt;li&gt;TESTAMENTARY_TRUST&lt;/li&gt;&lt;li&gt;ESTATE&lt;/li&gt;&lt;li&gt;GRANTOR_RETAINED_ANNUITY_TRUST_GRAT&lt;/li&gt;&lt;li&gt;ADVISORY_ACCOUNT&lt;/li&gt;&lt;li&gt;NON_PROFIT_ORGANIZATION_501C&lt;/li&gt;&lt;li&gt;HEALTH_REIMBURSEMENT_ARRANGEMENT_HRA&lt;/li&gt;&lt;li&gt;INDIVIDUAL_SAVINGS_ACCOUNT_ISA&lt;/li&gt;&lt;li&gt;CASH_ISA&lt;/li&gt;&lt;li&gt;STOCKS_AND_SHARES_ISA&lt;/li&gt;&lt;li&gt;INNOVATIVE_FINANCE_ISA&lt;/li&gt;&lt;li&gt;JUNIOR_ISA&lt;/li&gt;&lt;li&gt;EMPLOYEES_PROVIDENT_FUND_ORGANIZATION_EPFO&lt;/li&gt;&lt;li&gt;PUBLIC_PROVIDENT_FUND_PPF&lt;/li&gt;&lt;li&gt;EMPLOYEES_PENSION_SCHEME_EPS&lt;/li&gt;&lt;li&gt;NATIONAL_PENSION_SYSTEM_NPS&lt;/li&gt;&lt;li&gt;INDEXED_ANNUITY&lt;/li&gt;&lt;li&gt;ANNUITIZED_ANNUITY&lt;/li&gt;&lt;li&gt;VARIABLE_ANNUITY&lt;/li&gt;&lt;li&gt;ROTH_403B&lt;/li&gt;&lt;li&gt;SPOUSAL_IRA&lt;/li&gt;&lt;li&gt;SPOUSAL_ROTH_IRA&lt;/li&gt;&lt;li&gt;SARSEP_IRA&lt;/li&gt;&lt;li&gt;SUBSTANTIALLY_EQUAL_PERIODIC_PAYMENTS_SEPP&lt;/li&gt;&lt;li&gt;OFFSHORE_TRUST&lt;/li&gt;&lt;li&gt;IRREVOCABLE_LIFE_INSURANCE_TRUST&lt;/li&gt;&lt;li&gt;INTERNATIONAL_TRUST&lt;/li&gt;&lt;li&gt;LIFE_INTEREST_TRUST&lt;/li&gt;&lt;li&gt;EMPLOYEE_BENEFIT_TRUST&lt;/li&gt;&lt;li&gt;PRECIOUS_METAL_ACCOUNT&lt;/li&gt;&lt;li&gt;INVESTMENT_LOAN_ACCOUNT&lt;/li&gt;&lt;li&gt;GRANTOR_RETAINED_INCOME_TRUST&lt;/li&gt;&lt;li&gt;PENSION_PLAN&lt;/li&gt;&lt;li&gt;OTHER&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;loan&lt;/b&gt;&lt;ul&gt;&lt;li&gt;MORTGAGE&lt;/li&gt;&lt;li&gt;INSTALLMENT_LOAN&lt;/li&gt;&lt;li&gt;PERSONAL_LOAN&lt;/li&gt;&lt;li&gt;HOME_EQUITY_LINE_OF_CREDIT&lt;/li&gt;&lt;li&gt;LINE_OF_CREDIT&lt;/li&gt;&lt;li&gt;AUTO_LOAN&lt;/li&gt;&lt;li&gt;STUDENT_LOAN&lt;/li&gt;&lt;li&gt;HOME_LOAN&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;insurance&lt;/b&gt;&lt;ul&gt;&lt;li&gt;AUTO_INSURANCE&lt;/li&gt;&lt;li&gt;HEALTH_INSURANCE&lt;/li&gt;&lt;li&gt;HOME_INSURANCE&lt;/li&gt;&lt;li&gt;LIFE_INSURANCE&lt;/li&gt;&lt;li&gt;ANNUITY&lt;/li&gt;&lt;li&gt;TRAVEL_INSURANCE&lt;/li&gt;&lt;li&gt;INSURANCE&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;realEstate&lt;/b&gt;&lt;ul&gt; &lt;li&gt;REAL_ESTATE&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;reward&lt;/b&gt;&lt;ul&gt;&lt;li&gt;REWARD_POINTS&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Manual Account Type&lt;/b&gt;&lt;br&gt;&lt;b&gt;bank&lt;/b&gt;&lt;ul&gt;&lt;li&gt;CHECKING&lt;/li&gt;&lt;li&gt;SAVINGS&lt;/li&gt;&lt;li&gt;CD&lt;/li&gt;&lt;li&gt;PREPAID&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;credit&lt;/b&gt;&lt;ul&gt;  &lt;li&gt;CREDIT&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;loan&lt;/b&gt;&lt;ul&gt;  &lt;li&gt;PERSONAL_LOAN&lt;/li&gt;&lt;li&gt;HOME_LOAN&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;insurance&lt;/b&gt;&lt;ul&gt;&lt;li&gt;INSURANCE&lt;/li&gt;&lt;li&gt;ANNUITY&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;investment&lt;/b&gt;&lt;ul&gt;&lt;li&gt;BROKERAGE_CASH&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return accountType
   */
  @javax.annotation.Nullable
  public String getAccountType() {
    return accountType;
  }



  public DataExtractsAccount address(AccountAddress address) {
    this.address = address;
    return this;
  }

  /**
   * Get address
   * @return address
   */
  @javax.annotation.Nullable
  public AccountAddress getAddress() {
    return address;
  }

  public void setAddress(AccountAddress address) {
    this.address = address;
  }


  /**
   * The source through which the account(s) are added in the system.&lt;br&gt;&lt;b&gt;Valid Values&lt;/b&gt;: SYSTEM, USER&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return aggregationSource
   */
  @javax.annotation.Nullable
  public AggregationSourceEnum getAggregationSource() {
    return aggregationSource;
  }



  public DataExtractsAccount amountDue(Money amountDue) {
    this.amountDue = amountDue;
    return this;
  }

  /**
   * Get amountDue
   * @return amountDue
   */
  @javax.annotation.Nullable
  public Money getAmountDue() {
    return amountDue;
  }

  public void setAmountDue(Money amountDue) {
    this.amountDue = amountDue;
  }


  /**
   * Annual percentage yield (APY) is a normalized representation of an interest rate, based on a compounding period of one year. APY generally refers to the rate paid to a depositor by a financial institution on an account.&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return annualPercentageYield
   */
  @javax.annotation.Nullable
  public Double getAnnualPercentageYield() {
    return annualPercentageYield;
  }



  public DataExtractsAccount annuityBalance(Money annuityBalance) {
    this.annuityBalance = annuityBalance;
    return this;
  }

  /**
   * Get annuityBalance
   * @return annuityBalance
   */
  @javax.annotation.Nullable
  public Money getAnnuityBalance() {
    return annuityBalance;
  }

  public void setAnnuityBalance(Money annuityBalance) {
    this.annuityBalance = annuityBalance;
  }


  /**
   * The annual percentage rate (APR) is the yearly rate of interest on the credit card account.&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt; The yearly percentage rate charged when a balance is held on a credit card. This rate of interest is applied every month on the outstanding credit card balance.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return apr
   */
  @javax.annotation.Nullable
  public Double getApr() {
    return apr;
  }



  /**
   * The providerAccountIds that share the account with the primary providerAccountId that was created when the user had added the account for the first time.&lt;br&gt;&lt;b&gt;Additional Details&lt;/b&gt;: This attribute is returned in the response only if the account deduplication feature is enabled and the same account is mapped to more than one provider account IDs indicating the account is owned by more than one user, for example, joint accounts.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return associatedProviderAccountId
   */
  @javax.annotation.Nullable
  public List<Long> getAssociatedProviderAccountId() {
    return associatedProviderAccountId;
  }



  public DataExtractsAccount availableBalance(Money availableBalance) {
    this.availableBalance = availableBalance;
    return this;
  }

  /**
   * Get availableBalance
   * @return availableBalance
   */
  @javax.annotation.Nullable
  public Money getAvailableBalance() {
    return availableBalance;
  }

  public void setAvailableBalance(Money availableBalance) {
    this.availableBalance = availableBalance;
  }


  public DataExtractsAccount availableCash(Money availableCash) {
    this.availableCash = availableCash;
    return this;
  }

  /**
   * Get availableCash
   * @return availableCash
   */
  @javax.annotation.Nullable
  public Money getAvailableCash() {
    return availableCash;
  }

  public void setAvailableCash(Money availableCash) {
    this.availableCash = availableCash;
  }


  public DataExtractsAccount availableCredit(Money availableCredit) {
    this.availableCredit = availableCredit;
    return this;
  }

  /**
   * Get availableCredit
   * @return availableCredit
   */
  @javax.annotation.Nullable
  public Money getAvailableCredit() {
    return availableCredit;
  }

  public void setAvailableCredit(Money availableCredit) {
    this.availableCredit = availableCredit;
  }


  public DataExtractsAccount balance(Money balance) {
    this.balance = balance;
    return this;
  }

  /**
   * Get balance
   * @return balance
   */
  @javax.annotation.Nullable
  public Money getBalance() {
    return balance;
  }

  public void setBalance(Money balance) {
    this.balance = balance;
  }


  /**
   * Bank and branch identification information.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, investment, loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return bankTransferCode
   */
  @javax.annotation.Nullable
  public List<BankTransferCode> getBankTransferCode() {
    return bankTransferCode;
  }



  public DataExtractsAccount cash(Money cash) {
    this.cash = cash;
    return this;
  }

  /**
   * Get cash
   * @return cash
   */
  @javax.annotation.Nullable
  public Money getCash() {
    return cash;
  }

  public void setCash(Money cash) {
    this.cash = cash;
  }


  public DataExtractsAccount cashApr(Double cashApr) {
    this.cashApr = cashApr;
    return this;
  }

  /**
   * Annual percentage rate applied to cash withdrawals on the card.&lt;br&gt;&lt;br&gt;&lt;b&gt;Account Type&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return cashApr
   */
  @javax.annotation.Nullable
  public Double getCashApr() {
    return cashApr;
  }

  public void setCashApr(Double cashApr) {
    this.cashApr = cashApr;
  }


  public DataExtractsAccount cashValue(Money cashValue) {
    this.cashValue = cashValue;
    return this;
  }

  /**
   * Get cashValue
   * @return cashValue
   */
  @javax.annotation.Nullable
  public Money getCashValue() {
    return cashValue;
  }

  public void setCashValue(Money cashValue) {
    this.cashValue = cashValue;
  }


  /**
   * The classification of the account such as personal, corporate, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, creditCard, investment, reward, loan, insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return classification
   */
  @javax.annotation.Nullable
  public ClassificationEnum getClassification() {
    return classification;
  }



  /**
   * Property or possession offered to support a loan that can be seized on a default.&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return collateral
   */
  @javax.annotation.Nullable
  public String getCollateral() {
    return collateral;
  }



  /**
   * The coverage-related details of the account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance,investment&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return coverage
   */
  @javax.annotation.Nullable
  public List<Coverage> getCoverage() {
    return coverage;
  }



  /**
   * The date on which the account is created in the Yodlee system.&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt; It is the date when the user links or aggregates the account(s) that are held with the provider to the Yodlee system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return createdDate
   */
  @javax.annotation.Nullable
  public String getCreatedDate() {
    return createdDate;
  }



  public DataExtractsAccount currentBalance(Money currentBalance) {
    this.currentBalance = currentBalance;
    return this;
  }

  /**
   * Get currentBalance
   * @return currentBalance
   */
  @javax.annotation.Nullable
  public Money getCurrentBalance() {
    return currentBalance;
  }

  public void setCurrentBalance(Money currentBalance) {
    this.currentBalance = currentBalance;
  }


  /**
   * Current level of the reward program the user is associated with. E.g. Silver, Jade etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: reward&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return currentLevel
   */
  @javax.annotation.Nullable
  public String getCurrentLevel() {
    return currentLevel;
  }



  /**
   * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return dataset
   */
  @javax.annotation.Nullable
  public List<AccountDataset> getDataset() {
    return dataset;
  }



  public DataExtractsAccount deathBenefit(Money deathBenefit) {
    this.deathBenefit = deathBenefit;
    return this;
  }

  /**
   * Get deathBenefit
   * @return deathBenefit
   */
  @javax.annotation.Nullable
  public Money getDeathBenefit() {
    return deathBenefit;
  }

  public void setDeathBenefit(Money deathBenefit) {
    this.deathBenefit = deathBenefit;
  }


  /**
   * Derived APR will be an estimated purchase APR based on consumers credit card transactions and credit card purchase.&lt;br&gt;&lt;b&gt;Aggregated / Manual / Derived&lt;/b&gt;: Derived&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return derivedApr
   */
  @javax.annotation.Nullable
  public Double getDerivedApr() {
    return derivedApr;
  }



  /**
   * The name or identification of the account owner, as it appears at the FI site. &lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; The account holder name can be full or partial based on how it is displayed in the account summary page of the FI site. In most cases, the FI site does not display the full account holder name in the account summary page.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, creditCard, investment, insurance, loan,  reward&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return displayedName
   */
  @javax.annotation.Nullable
  public String getDisplayedName() {
    return displayedName;
  }



  /**
   * The date on which the due amount has to be paid. &lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt;&lt;br&gt;&lt;b&gt;Credit Card:&lt;/b&gt; The monthly date by when the minimum payment is due to be paid on the credit card account. &lt;br&gt;&lt;b&gt;Loan:&lt;/b&gt; The date on or before which the due amount should be paid.&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard, loan, insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return dueDate
   */
  @javax.annotation.Nullable
  public String getDueDate() {
    return dueDate;
  }



  /**
   * Date on which the user is enrolled on the rewards program.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: reward&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return enrollmentDate
   */
  @javax.annotation.Nullable
  public String getEnrollmentDate() {
    return enrollmentDate;
  }



  public DataExtractsAccount escrowBalance(Money escrowBalance) {
    this.escrowBalance = escrowBalance;
    return this;
  }

  /**
   * Get escrowBalance
   * @return escrowBalance
   */
  @javax.annotation.Nullable
  public Money getEscrowBalance() {
    return escrowBalance;
  }

  public void setEscrowBalance(Money escrowBalance) {
    this.escrowBalance = escrowBalance;
  }


  /**
   * The date on which the home value was estimated.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Manual&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: realEstate&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return estimatedDate
   */
  @javax.annotation.Nullable
  public String getEstimatedDate() {
    return estimatedDate;
  }



  /**
   * The date on which the insurance policy expires or matures.&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt; The due date at the account-level can differ from the due date field at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return expirationDate
   */
  @javax.annotation.Nullable
  public String getExpirationDate() {
    return expirationDate;
  }



  public DataExtractsAccount faceAmount(Money faceAmount) {
    this.faceAmount = faceAmount;
    return this;
  }

  /**
   * Get faceAmount
   * @return faceAmount
   */
  @javax.annotation.Nullable
  public Money getFaceAmount() {
    return faceAmount;
  }

  public void setFaceAmount(Money faceAmount) {
    this.faceAmount = faceAmount;
  }


  /**
   * The frequency of the billing cycle of the account in case of card. The frequency in which premiums are paid in an insurance policy such as monthly, quarterly, and annually. The frequency in which due amounts are paid in a loan  account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;:  creditCard, insurance, loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return frequency
   */
  @javax.annotation.Nullable
  public FrequencyEnum getFrequency() {
    return frequency;
  }



  /**
   * A nonprofit or state organization that works with lender, servicer, school, and the Department of Education to help successfully repay Federal Family Education Loan Program (FFELP) loans. If FFELP student loans default, the guarantor takes ownership of them.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return guarantor
   */
  @javax.annotation.Nullable
  public String getGuarantor() {
    return guarantor;
  }



  /**
   * Type of home insurance, like -&lt;ul&gt;&lt;li&gt;HOME_OWNER&lt;/li&gt;&lt;li&gt;RENTAL&lt;/li&gt;&lt;li&gt;RENTER&lt;/li&gt;&lt;li&gt;etc..&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return homeInsuranceType
   */
  @javax.annotation.Nullable
  public HomeInsuranceTypeEnum getHomeInsuranceType() {
    return homeInsuranceType;
  }



  public DataExtractsAccount homeValue(Money homeValue) {
    this.homeValue = homeValue;
    return this;
  }

  /**
   * Get homeValue
   * @return homeValue
   */
  @javax.annotation.Nullable
  public Money getHomeValue() {
    return homeValue;
  }

  public void setHomeValue(Money homeValue) {
    this.homeValue = homeValue;
  }


  /**
   * The primary key of the account resource and the unique identifier for the account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts &lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET investmentOptions&lt;/li&gt;&lt;li&gt;GET accounts/historicalBalances&lt;/li&gt;&lt;li&gt;POST accounts&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return id
   */
  @javax.annotation.Nullable
  public Long getId() {
    return id;
  }



  /**
   * Used to determine  whether an account to be considered in the networth calculation.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,loan,investment,insurance,realEstate,otherAssets,otherLiabilities&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return includeInNetWorth
   */
  @javax.annotation.Nullable
  public Boolean getIncludeInNetWorth() {
    return includeInNetWorth;
  }



  public DataExtractsAccount interestPaidLastYear(Money interestPaidLastYear) {
    this.interestPaidLastYear = interestPaidLastYear;
    return this;
  }

  /**
   * Get interestPaidLastYear
   * @return interestPaidLastYear
   */
  @javax.annotation.Nullable
  public Money getInterestPaidLastYear() {
    return interestPaidLastYear;
  }

  public void setInterestPaidLastYear(Money interestPaidLastYear) {
    this.interestPaidLastYear = interestPaidLastYear;
  }


  public DataExtractsAccount interestPaidYTD(Money interestPaidYTD) {
    this.interestPaidYTD = interestPaidYTD;
    return this;
  }

  /**
   * Get interestPaidYTD
   * @return interestPaidYTD
   */
  @javax.annotation.Nullable
  public Money getInterestPaidYTD() {
    return interestPaidYTD;
  }

  public void setInterestPaidYTD(Money interestPaidYTD) {
    this.interestPaidYTD = interestPaidYTD;
  }


  /**
   * &lt;br&gt;&lt;b&gt;Bank:&lt;/b&gt; The interest rate offered by a FI to its depositors on a bank account.&lt;br&gt;&lt;b&gt;Loan:&lt;/b&gt; Interest rate applied on the loan.&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt;&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; The Interest Rate field is only applicable for the following account types: savings, checking, money market, and certificate of deposit.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return interestRate
   */
  @javax.annotation.Nullable
  public Double getInterestRate() {
    return interestRate;
  }



  /**
   * The type of the interest rate, for example, fixed or variable.&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return interestRateType
   */
  @javax.annotation.Nullable
  public InterestRateTypeEnum getInterestRateType() {
    return interestRateType;
  }



  /**
   * The account to be considered as an asset or liability.&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return isAsset
   */
  @javax.annotation.Nullable
  public Boolean getIsAsset() {
    return isAsset;
  }



  /**
   * Indicates if the account is marked as deleted.&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return isDeleted
   */
  @javax.annotation.Nullable
  public Boolean getIsDeleted() {
    return isDeleted;
  }



  /**
   * Indicates if an account is aggregated from a site or it is a manual account i.e. account information manually provided by the user.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return isManual
   */
  @javax.annotation.Nullable
  public Boolean getIsManual() {
    return isManual;
  }



  public DataExtractsAccount lastEmployeeContributionAmount(Money lastEmployeeContributionAmount) {
    this.lastEmployeeContributionAmount = lastEmployeeContributionAmount;
    return this;
  }

  /**
   * Get lastEmployeeContributionAmount
   * @return lastEmployeeContributionAmount
   */
  @javax.annotation.Nullable
  public Money getLastEmployeeContributionAmount() {
    return lastEmployeeContributionAmount;
  }

  public void setLastEmployeeContributionAmount(Money lastEmployeeContributionAmount) {
    this.lastEmployeeContributionAmount = lastEmployeeContributionAmount;
  }


  /**
   * The date on which the last employee contribution was made to the 401k account.&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; The last employee contribution date field is derived from the transaction data and not aggregated from the FI site. The field is only applicable to the 401k account type.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return lastEmployeeContributionDate
   */
  @javax.annotation.Nullable
  public String getLastEmployeeContributionDate() {
    return lastEmployeeContributionDate;
  }



  public DataExtractsAccount lastPayment(Money lastPayment) {
    this.lastPayment = lastPayment;
    return this;
  }

  /**
   * Get lastPayment
   * @return lastPayment
   */
  @javax.annotation.Nullable
  public Money getLastPayment() {
    return lastPayment;
  }

  public void setLastPayment(Money lastPayment) {
    this.lastPayment = lastPayment;
  }


  public DataExtractsAccount lastPaymentAmount(Money lastPaymentAmount) {
    this.lastPaymentAmount = lastPaymentAmount;
    return this;
  }

  /**
   * Get lastPaymentAmount
   * @return lastPaymentAmount
   */
  @javax.annotation.Nullable
  public Money getLastPaymentAmount() {
    return lastPaymentAmount;
  }

  public void setLastPaymentAmount(Money lastPaymentAmount) {
    this.lastPaymentAmount = lastPaymentAmount;
  }


  /**
   * The date on which the payment for the previous or current billing cycle is done.&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt; If the payment is already done for the current billing cycle, then the field indicates the payment date of the current billing cycle. If payment is yet to be done for the current billing cycle, then the field indicates the date on which the payment was made for any of the previous billing cycles. The last payment date at the account-level can differ from the last payment date at the statement-level, as the information in the aggregated card account data provides an up-to-date information to the consumer.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: creditCard, loan, insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return lastPaymentDate
   */
  @javax.annotation.Nullable
  public String getLastPaymentDate() {
    return lastPaymentDate;
  }



  /**
   * The date time the account information was last retrieved from the provider site and updated in the Yodlee system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return lastUpdated
   */
  @javax.annotation.Nullable
  public String getLastUpdated() {
    return lastUpdated;
  }



  /**
   * The financial institution that provides the loan.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return lender
   */
  @javax.annotation.Nullable
  public String getLender() {
    return lender;
  }



  /**
   * Type of life insurance.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return lifeInsuranceType
   */
  @javax.annotation.Nullable
  public LifeInsuranceTypeEnum getLifeInsuranceType() {
    return lifeInsuranceType;
  }



  /**
   * The date by which the payoff amount should be paid.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return loanPayByDate
   */
  @javax.annotation.Nullable
  public String getLoanPayByDate() {
    return loanPayByDate;
  }



  public DataExtractsAccount loanPayoffAmount(Money loanPayoffAmount) {
    this.loanPayoffAmount = loanPayoffAmount;
    return this;
  }

  /**
   * Get loanPayoffAmount
   * @return loanPayoffAmount
   */
  @javax.annotation.Nullable
  public Money getLoanPayoffAmount() {
    return loanPayoffAmount;
  }

  public void setLoanPayoffAmount(Money loanPayoffAmount) {
    this.loanPayoffAmount = loanPayoffAmount;
  }


  public DataExtractsAccount loanPayoffDetails(LoanPayoffDetails loanPayoffDetails) {
    this.loanPayoffDetails = loanPayoffDetails;
    return this;
  }

  /**
   * Get loanPayoffDetails
   * @return loanPayoffDetails
   */
  @javax.annotation.Nullable
  public LoanPayoffDetails getLoanPayoffDetails() {
    return loanPayoffDetails;
  }

  public void setLoanPayoffDetails(LoanPayoffDetails loanPayoffDetails) {
    this.loanPayoffDetails = loanPayoffDetails;
  }


  public DataExtractsAccount marginBalance(Money marginBalance) {
    this.marginBalance = marginBalance;
    return this;
  }

  /**
   * Get marginBalance
   * @return marginBalance
   */
  @javax.annotation.Nullable
  public Money getMarginBalance() {
    return marginBalance;
  }

  public void setMarginBalance(Money marginBalance) {
    this.marginBalance = marginBalance;
  }


  public DataExtractsAccount maturityAmount(Money maturityAmount) {
    this.maturityAmount = maturityAmount;
    return this;
  }

  /**
   * Get maturityAmount
   * @return maturityAmount
   */
  @javax.annotation.Nullable
  public Money getMaturityAmount() {
    return maturityAmount;
  }

  public void setMaturityAmount(Money maturityAmount) {
    this.maturityAmount = maturityAmount;
  }


  /**
   * The date when a certificate of deposit (CD/FD) matures or the final payment date of a loan at which point the principal amount (including pending interest) is due to be paid.&lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt; The date when a certificate of deposit (CD) matures, i.e., the money in the CD can be withdrawn without paying an early withdrawal penalty.The final payment date of a loan, i.e., the principal amount (including pending interest) is due to be paid.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return maturityDate
   */
  @javax.annotation.Nullable
  public String getMaturityDate() {
    return maturityDate;
  }



  /**
   * The additional description or notes given by the user.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return memo
   */
  @javax.annotation.Nullable
  public String getMemo() {
    return memo;
  }



  public DataExtractsAccount minimumAmountDue(Money minimumAmountDue) {
    this.minimumAmountDue = minimumAmountDue;
    return this;
  }

  /**
   * Get minimumAmountDue
   * @return minimumAmountDue
   */
  @javax.annotation.Nullable
  public Money getMinimumAmountDue() {
    return minimumAmountDue;
  }

  public void setMinimumAmountDue(Money minimumAmountDue) {
    this.minimumAmountDue = minimumAmountDue;
  }


  public DataExtractsAccount moneyMarketBalance(Money moneyMarketBalance) {
    this.moneyMarketBalance = moneyMarketBalance;
    return this;
  }

  /**
   * Get moneyMarketBalance
   * @return moneyMarketBalance
   */
  @javax.annotation.Nullable
  public Money getMoneyMarketBalance() {
    return moneyMarketBalance;
  }

  public void setMoneyMarketBalance(Money moneyMarketBalance) {
    this.moneyMarketBalance = moneyMarketBalance;
  }


  /**
   * The eligible next level of the rewards program.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: reward&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return nextLevel
   */
  @javax.annotation.Nullable
  public String getNextLevel() {
    return nextLevel;
  }



  /**
   * The nickname of the account as provided by the consumer to identify an account. The account nickname can be used instead of the account name.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return nickname
   */
  @javax.annotation.Nullable
  public String getNickname() {
    return nickname;
  }



  /**
   * Indicates the migration status of the account from screen-scraping provider to the Open Banking provider. &lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return oauthMigrationStatus
   */
  @javax.annotation.Nullable
  public OauthMigrationStatusEnum getOauthMigrationStatus() {
    return oauthMigrationStatus;
  }



  public DataExtractsAccount originalLoanAmount(Money originalLoanAmount) {
    this.originalLoanAmount = originalLoanAmount;
    return this;
  }

  /**
   * Get originalLoanAmount
   * @return originalLoanAmount
   */
  @javax.annotation.Nullable
  public Money getOriginalLoanAmount() {
    return originalLoanAmount;
  }

  public void setOriginalLoanAmount(Money originalLoanAmount) {
    this.originalLoanAmount = originalLoanAmount;
  }


  /**
   * The date on which the loan is disbursed.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return originationDate
   */
  @javax.annotation.Nullable
  public String getOriginationDate() {
    return originationDate;
  }



  public DataExtractsAccount overDraftLimit(Money overDraftLimit) {
    this.overDraftLimit = overDraftLimit;
    return this;
  }

  /**
   * Get overDraftLimit
   * @return overDraftLimit
   */
  @javax.annotation.Nullable
  public Money getOverDraftLimit() {
    return overDraftLimit;
  }

  public void setOverDraftLimit(Money overDraftLimit) {
    this.overDraftLimit = overDraftLimit;
  }


  /**
   * The date on which the insurance policy coverage commences.&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return policyEffectiveDate
   */
  @javax.annotation.Nullable
  public String getPolicyEffectiveDate() {
    return policyEffectiveDate;
  }



  /**
   * The date the insurance policy began.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return policyFromDate
   */
  @javax.annotation.Nullable
  public String getPolicyFromDate() {
    return policyFromDate;
  }



  /**
   * The status of the policy.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return policyStatus
   */
  @javax.annotation.Nullable
  public PolicyStatusEnum getPolicyStatus() {
    return policyStatus;
  }



  /**
   * The duration for which the policy is valid or in effect. For example, one year, five years, etc.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return policyTerm
   */
  @javax.annotation.Nullable
  public String getPolicyTerm() {
    return policyTerm;
  }



  /**
   * The date to which the policy exists.&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return policyToDate
   */
  @javax.annotation.Nullable
  public String getPolicyToDate() {
    return policyToDate;
  }



  public DataExtractsAccount premium(Money premium) {
    this.premium = premium;
    return this;
  }

  /**
   * Get premium
   * @return premium
   */
  @javax.annotation.Nullable
  public Money getPremium() {
    return premium;
  }

  public void setPremium(Money premium) {
    this.premium = premium;
  }


  /**
   * The number of years for which premium payments have to be made in a policy.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: insurance&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return premiumPaymentTerm
   */
  @javax.annotation.Nullable
  public String getPremiumPaymentTerm() {
    return premiumPaymentTerm;
  }



  /**
   * Primary reward unit for this reward program. E.g. miles, points, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: reward&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return primaryRewardUnit
   */
  @javax.annotation.Nullable
  public String getPrimaryRewardUnit() {
    return primaryRewardUnit;
  }



  public DataExtractsAccount principalBalance(Money principalBalance) {
    this.principalBalance = principalBalance;
    return this;
  }

  /**
   * Get principalBalance
   * @return principalBalance
   */
  @javax.annotation.Nullable
  public Money getPrincipalBalance() {
    return principalBalance;
  }

  public void setPrincipalBalance(Money principalBalance) {
    this.principalBalance = principalBalance;
  }


  /**
   * The primary key of the provider account resource.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return providerAccountId
   */
  @javax.annotation.Nullable
  public Long getProviderAccountId() {
    return providerAccountId;
  }



  /**
   * Identifier of the provider site. The primary key of provider resource. &lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return providerId
   */
  @javax.annotation.Nullable
  public String getProviderId() {
    return providerId;
  }



  /**
   * Service provider or institution name where the account originates. This belongs to the provider resource.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: All containers&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return providerName
   */
  @javax.annotation.Nullable
  public String getProviderName() {
    return providerName;
  }



  public DataExtractsAccount recurringPayment(Money recurringPayment) {
    this.recurringPayment = recurringPayment;
    return this;
  }

  /**
   * Get recurringPayment
   * @return recurringPayment
   */
  @javax.annotation.Nullable
  public Money getRecurringPayment() {
    return recurringPayment;
  }

  public void setRecurringPayment(Money recurringPayment) {
    this.recurringPayment = recurringPayment;
  }


  public DataExtractsAccount remainingBalance(Money remainingBalance) {
    this.remainingBalance = remainingBalance;
    return this;
  }

  /**
   * Get remainingBalance
   * @return remainingBalance
   */
  @javax.annotation.Nullable
  public Money getRemainingBalance() {
    return remainingBalance;
  }

  public void setRemainingBalance(Money remainingBalance) {
    this.remainingBalance = remainingBalance;
  }


  /**
   * The type of repayment plan that the borrower prefers to repay the loan. &lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values:&lt;/b&gt;&lt;br&gt;
   * @return repaymentPlanType
   */
  @javax.annotation.Nullable
  public RepaymentPlanTypeEnum getRepaymentPlanType() {
    return repaymentPlanType;
  }



  /**
   * Information of different reward balances associated with the account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: reward&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return rewardBalance
   */
  @javax.annotation.Nullable
  public List<RewardBalance> getRewardBalance() {
    return rewardBalance;
  }



  public DataExtractsAccount runningBalance(Money runningBalance) {
    this.runningBalance = runningBalance;
    return this;
  }

  /**
   * Get runningBalance
   * @return runningBalance
   */
  @javax.annotation.Nullable
  public Money getRunningBalance() {
    return runningBalance;
  }

  public void setRunningBalance(Money runningBalance) {
    this.runningBalance = runningBalance;
  }


  public DataExtractsAccount shortBalance(Money shortBalance) {
    this.shortBalance = shortBalance;
    return this;
  }

  /**
   * Get shortBalance
   * @return shortBalance
   */
  @javax.annotation.Nullable
  public Money getShortBalance() {
    return shortBalance;
  }

  public void setShortBalance(Money shortBalance) {
    this.shortBalance = shortBalance;
  }


  /**
   * Indicates the status of the loan account. &lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values:&lt;/b&gt;&lt;br&gt;
   * @return sourceAccountStatus
   */
  @javax.annotation.Nullable
  public SourceAccountStatusEnum getSourceAccountStatus() {
    return sourceAccountStatus;
  }



  /**
   * A unique ID that the provider site has assigned to the account. The source ID is only available for the HELD accounts.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, creditCard, investment, insurance, loan,  reward&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return sourceId
   */
  @javax.annotation.Nullable
  public String getSourceId() {
    return sourceId;
  }



  /**
   * The tenure for which the CD account is valid  or in case of loan, the number of years/months over which the loan amount  has to be repaid. &lt;br&gt;&lt;b&gt;Additional Details:&lt;/b&gt;&lt;br&gt;  Bank: The Term field is only applicable for the account type CD.Loan: The period for which the loan agreement is in force. The period, before or at the end of which, the loan should either be repaid or renegotiated for another term.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank, loan&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return term
   */
  @javax.annotation.Nullable
  public String getTerm() {
    return term;
  }



  public DataExtractsAccount totalCashLimit(Money totalCashLimit) {
    this.totalCashLimit = totalCashLimit;
    return this;
  }

  /**
   * Get totalCashLimit
   * @return totalCashLimit
   */
  @javax.annotation.Nullable
  public Money getTotalCashLimit() {
    return totalCashLimit;
  }

  public void setTotalCashLimit(Money totalCashLimit) {
    this.totalCashLimit = totalCashLimit;
  }


  public DataExtractsAccount totalCreditLimit(Money totalCreditLimit) {
    this.totalCreditLimit = totalCreditLimit;
    return this;
  }

  /**
   * Get totalCreditLimit
   * @return totalCreditLimit
   */
  @javax.annotation.Nullable
  public Money getTotalCreditLimit() {
    return totalCreditLimit;
  }

  public void setTotalCreditLimit(Money totalCreditLimit) {
    this.totalCreditLimit = totalCreditLimit;
  }


  public DataExtractsAccount totalCreditLine(Money totalCreditLine) {
    this.totalCreditLine = totalCreditLine;
    return this;
  }

  /**
   * Get totalCreditLine
   * @return totalCreditLine
   */
  @javax.annotation.Nullable
  public Money getTotalCreditLine() {
    return totalCreditLine;
  }

  public void setTotalCreditLine(Money totalCreditLine) {
    this.totalCreditLine = totalCreditLine;
  }


  public DataExtractsAccount totalUnvestedBalance(Money totalUnvestedBalance) {
    this.totalUnvestedBalance = totalUnvestedBalance;
    return this;
  }

  /**
   * Get totalUnvestedBalance
   * @return totalUnvestedBalance
   */
  @javax.annotation.Nullable
  public Money getTotalUnvestedBalance() {
    return totalUnvestedBalance;
  }

  public void setTotalUnvestedBalance(Money totalUnvestedBalance) {
    this.totalUnvestedBalance = totalUnvestedBalance;
  }


  public DataExtractsAccount totalVestedBalance(Money totalVestedBalance) {
    this.totalVestedBalance = totalVestedBalance;
    return this;
  }

  /**
   * Get totalVestedBalance
   * @return totalVestedBalance
   */
  @javax.annotation.Nullable
  public Money getTotalVestedBalance() {
    return totalVestedBalance;
  }

  public void setTotalVestedBalance(Money totalVestedBalance) {
    this.totalVestedBalance = totalVestedBalance;
  }


  /**
   * &lt;b&gt;Applicable containers&lt;/b&gt;: reward, bank, creditCard, investment, loan, insurance, realEstate,  otherLiabilities&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts &lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;POST accounts&lt;/ul&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return userClassification
   */
  @javax.annotation.Nullable
  public UserClassificationEnum getUserClassification() {
    return userClassification;
  }



  /**
   * The valuation type indicates whether the home value is calculated either manually or by Yodlee Partners.&lt;br&gt;&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Manual&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: realEstate&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET accounts&lt;/li&gt;&lt;li&gt;GET accounts/{accountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return valuationType
   */
  @javax.annotation.Nullable
  public ValuationTypeEnum getValuationType() {
    return valuationType;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataExtractsAccount dataExtractsAccount = (DataExtractsAccount) o;
    return Objects.equals(this._401kLoan, dataExtractsAccount._401kLoan) &&
        Objects.equals(this.CONTAINER, dataExtractsAccount.CONTAINER) &&
        Objects.equals(this.accountName, dataExtractsAccount.accountName) &&
        Objects.equals(this.accountNumber, dataExtractsAccount.accountNumber) &&
        Objects.equals(this.accountStatus, dataExtractsAccount.accountStatus) &&
        Objects.equals(this.accountType, dataExtractsAccount.accountType) &&
        Objects.equals(this.address, dataExtractsAccount.address) &&
        Objects.equals(this.aggregationSource, dataExtractsAccount.aggregationSource) &&
        Objects.equals(this.amountDue, dataExtractsAccount.amountDue) &&
        Objects.equals(this.annualPercentageYield, dataExtractsAccount.annualPercentageYield) &&
        Objects.equals(this.annuityBalance, dataExtractsAccount.annuityBalance) &&
        Objects.equals(this.apr, dataExtractsAccount.apr) &&
        Objects.equals(this.associatedProviderAccountId, dataExtractsAccount.associatedProviderAccountId) &&
        Objects.equals(this.availableBalance, dataExtractsAccount.availableBalance) &&
        Objects.equals(this.availableCash, dataExtractsAccount.availableCash) &&
        Objects.equals(this.availableCredit, dataExtractsAccount.availableCredit) &&
        Objects.equals(this.balance, dataExtractsAccount.balance) &&
        Objects.equals(this.bankTransferCode, dataExtractsAccount.bankTransferCode) &&
        Objects.equals(this.cash, dataExtractsAccount.cash) &&
        Objects.equals(this.cashApr, dataExtractsAccount.cashApr) &&
        Objects.equals(this.cashValue, dataExtractsAccount.cashValue) &&
        Objects.equals(this.classification, dataExtractsAccount.classification) &&
        Objects.equals(this.collateral, dataExtractsAccount.collateral) &&
        Objects.equals(this.coverage, dataExtractsAccount.coverage) &&
        Objects.equals(this.createdDate, dataExtractsAccount.createdDate) &&
        Objects.equals(this.currentBalance, dataExtractsAccount.currentBalance) &&
        Objects.equals(this.currentLevel, dataExtractsAccount.currentLevel) &&
        Objects.equals(this.dataset, dataExtractsAccount.dataset) &&
        Objects.equals(this.deathBenefit, dataExtractsAccount.deathBenefit) &&
        Objects.equals(this.derivedApr, dataExtractsAccount.derivedApr) &&
        Objects.equals(this.displayedName, dataExtractsAccount.displayedName) &&
        Objects.equals(this.dueDate, dataExtractsAccount.dueDate) &&
        Objects.equals(this.enrollmentDate, dataExtractsAccount.enrollmentDate) &&
        Objects.equals(this.escrowBalance, dataExtractsAccount.escrowBalance) &&
        Objects.equals(this.estimatedDate, dataExtractsAccount.estimatedDate) &&
        Objects.equals(this.expirationDate, dataExtractsAccount.expirationDate) &&
        Objects.equals(this.faceAmount, dataExtractsAccount.faceAmount) &&
        Objects.equals(this.frequency, dataExtractsAccount.frequency) &&
        Objects.equals(this.guarantor, dataExtractsAccount.guarantor) &&
        Objects.equals(this.homeInsuranceType, dataExtractsAccount.homeInsuranceType) &&
        Objects.equals(this.homeValue, dataExtractsAccount.homeValue) &&
        Objects.equals(this.id, dataExtractsAccount.id) &&
        Objects.equals(this.includeInNetWorth, dataExtractsAccount.includeInNetWorth) &&
        Objects.equals(this.interestPaidLastYear, dataExtractsAccount.interestPaidLastYear) &&
        Objects.equals(this.interestPaidYTD, dataExtractsAccount.interestPaidYTD) &&
        Objects.equals(this.interestRate, dataExtractsAccount.interestRate) &&
        Objects.equals(this.interestRateType, dataExtractsAccount.interestRateType) &&
        Objects.equals(this.isAsset, dataExtractsAccount.isAsset) &&
        Objects.equals(this.isDeleted, dataExtractsAccount.isDeleted) &&
        Objects.equals(this.isManual, dataExtractsAccount.isManual) &&
        Objects.equals(this.lastEmployeeContributionAmount, dataExtractsAccount.lastEmployeeContributionAmount) &&
        Objects.equals(this.lastEmployeeContributionDate, dataExtractsAccount.lastEmployeeContributionDate) &&
        Objects.equals(this.lastPayment, dataExtractsAccount.lastPayment) &&
        Objects.equals(this.lastPaymentAmount, dataExtractsAccount.lastPaymentAmount) &&
        Objects.equals(this.lastPaymentDate, dataExtractsAccount.lastPaymentDate) &&
        Objects.equals(this.lastUpdated, dataExtractsAccount.lastUpdated) &&
        Objects.equals(this.lender, dataExtractsAccount.lender) &&
        Objects.equals(this.lifeInsuranceType, dataExtractsAccount.lifeInsuranceType) &&
        Objects.equals(this.loanPayByDate, dataExtractsAccount.loanPayByDate) &&
        Objects.equals(this.loanPayoffAmount, dataExtractsAccount.loanPayoffAmount) &&
        Objects.equals(this.loanPayoffDetails, dataExtractsAccount.loanPayoffDetails) &&
        Objects.equals(this.marginBalance, dataExtractsAccount.marginBalance) &&
        Objects.equals(this.maturityAmount, dataExtractsAccount.maturityAmount) &&
        Objects.equals(this.maturityDate, dataExtractsAccount.maturityDate) &&
        Objects.equals(this.memo, dataExtractsAccount.memo) &&
        Objects.equals(this.minimumAmountDue, dataExtractsAccount.minimumAmountDue) &&
        Objects.equals(this.moneyMarketBalance, dataExtractsAccount.moneyMarketBalance) &&
        Objects.equals(this.nextLevel, dataExtractsAccount.nextLevel) &&
        Objects.equals(this.nickname, dataExtractsAccount.nickname) &&
        Objects.equals(this.oauthMigrationStatus, dataExtractsAccount.oauthMigrationStatus) &&
        Objects.equals(this.originalLoanAmount, dataExtractsAccount.originalLoanAmount) &&
        Objects.equals(this.originationDate, dataExtractsAccount.originationDate) &&
        Objects.equals(this.overDraftLimit, dataExtractsAccount.overDraftLimit) &&
        Objects.equals(this.policyEffectiveDate, dataExtractsAccount.policyEffectiveDate) &&
        Objects.equals(this.policyFromDate, dataExtractsAccount.policyFromDate) &&
        Objects.equals(this.policyStatus, dataExtractsAccount.policyStatus) &&
        Objects.equals(this.policyTerm, dataExtractsAccount.policyTerm) &&
        Objects.equals(this.policyToDate, dataExtractsAccount.policyToDate) &&
        Objects.equals(this.premium, dataExtractsAccount.premium) &&
        Objects.equals(this.premiumPaymentTerm, dataExtractsAccount.premiumPaymentTerm) &&
        Objects.equals(this.primaryRewardUnit, dataExtractsAccount.primaryRewardUnit) &&
        Objects.equals(this.principalBalance, dataExtractsAccount.principalBalance) &&
        Objects.equals(this.providerAccountId, dataExtractsAccount.providerAccountId) &&
        Objects.equals(this.providerId, dataExtractsAccount.providerId) &&
        Objects.equals(this.providerName, dataExtractsAccount.providerName) &&
        Objects.equals(this.recurringPayment, dataExtractsAccount.recurringPayment) &&
        Objects.equals(this.remainingBalance, dataExtractsAccount.remainingBalance) &&
        Objects.equals(this.repaymentPlanType, dataExtractsAccount.repaymentPlanType) &&
        Objects.equals(this.rewardBalance, dataExtractsAccount.rewardBalance) &&
        Objects.equals(this.runningBalance, dataExtractsAccount.runningBalance) &&
        Objects.equals(this.shortBalance, dataExtractsAccount.shortBalance) &&
        Objects.equals(this.sourceAccountStatus, dataExtractsAccount.sourceAccountStatus) &&
        Objects.equals(this.sourceId, dataExtractsAccount.sourceId) &&
        Objects.equals(this.term, dataExtractsAccount.term) &&
        Objects.equals(this.totalCashLimit, dataExtractsAccount.totalCashLimit) &&
        Objects.equals(this.totalCreditLimit, dataExtractsAccount.totalCreditLimit) &&
        Objects.equals(this.totalCreditLine, dataExtractsAccount.totalCreditLine) &&
        Objects.equals(this.totalUnvestedBalance, dataExtractsAccount.totalUnvestedBalance) &&
        Objects.equals(this.totalVestedBalance, dataExtractsAccount.totalVestedBalance) &&
        Objects.equals(this.userClassification, dataExtractsAccount.userClassification) &&
        Objects.equals(this.valuationType, dataExtractsAccount.valuationType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(_401kLoan, CONTAINER, accountName, accountNumber, accountStatus, accountType, address, aggregationSource, amountDue, annualPercentageYield, annuityBalance, apr, associatedProviderAccountId, availableBalance, availableCash, availableCredit, balance, bankTransferCode, cash, cashApr, cashValue, classification, collateral, coverage, createdDate, currentBalance, currentLevel, dataset, deathBenefit, derivedApr, displayedName, dueDate, enrollmentDate, escrowBalance, estimatedDate, expirationDate, faceAmount, frequency, guarantor, homeInsuranceType, homeValue, id, includeInNetWorth, interestPaidLastYear, interestPaidYTD, interestRate, interestRateType, isAsset, isDeleted, isManual, lastEmployeeContributionAmount, lastEmployeeContributionDate, lastPayment, lastPaymentAmount, lastPaymentDate, lastUpdated, lender, lifeInsuranceType, loanPayByDate, loanPayoffAmount, loanPayoffDetails, marginBalance, maturityAmount, maturityDate, memo, minimumAmountDue, moneyMarketBalance, nextLevel, nickname, oauthMigrationStatus, originalLoanAmount, originationDate, overDraftLimit, policyEffectiveDate, policyFromDate, policyStatus, policyTerm, policyToDate, premium, premiumPaymentTerm, primaryRewardUnit, principalBalance, providerAccountId, providerId, providerName, recurringPayment, remainingBalance, repaymentPlanType, rewardBalance, runningBalance, shortBalance, sourceAccountStatus, sourceId, term, totalCashLimit, totalCreditLimit, totalCreditLine, totalUnvestedBalance, totalVestedBalance, userClassification, valuationType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataExtractsAccount {\n");
    sb.append("    _401kLoan: ").append(toIndentedString(_401kLoan)).append("\n");
    sb.append("    CONTAINER: ").append(toIndentedString(CONTAINER)).append("\n");
    sb.append("    accountName: ").append(toIndentedString(accountName)).append("\n");
    sb.append("    accountNumber: ").append(toIndentedString(accountNumber)).append("\n");
    sb.append("    accountStatus: ").append(toIndentedString(accountStatus)).append("\n");
    sb.append("    accountType: ").append(toIndentedString(accountType)).append("\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    aggregationSource: ").append(toIndentedString(aggregationSource)).append("\n");
    sb.append("    amountDue: ").append(toIndentedString(amountDue)).append("\n");
    sb.append("    annualPercentageYield: ").append(toIndentedString(annualPercentageYield)).append("\n");
    sb.append("    annuityBalance: ").append(toIndentedString(annuityBalance)).append("\n");
    sb.append("    apr: ").append(toIndentedString(apr)).append("\n");
    sb.append("    associatedProviderAccountId: ").append(toIndentedString(associatedProviderAccountId)).append("\n");
    sb.append("    availableBalance: ").append(toIndentedString(availableBalance)).append("\n");
    sb.append("    availableCash: ").append(toIndentedString(availableCash)).append("\n");
    sb.append("    availableCredit: ").append(toIndentedString(availableCredit)).append("\n");
    sb.append("    balance: ").append(toIndentedString(balance)).append("\n");
    sb.append("    bankTransferCode: ").append(toIndentedString(bankTransferCode)).append("\n");
    sb.append("    cash: ").append(toIndentedString(cash)).append("\n");
    sb.append("    cashApr: ").append(toIndentedString(cashApr)).append("\n");
    sb.append("    cashValue: ").append(toIndentedString(cashValue)).append("\n");
    sb.append("    classification: ").append(toIndentedString(classification)).append("\n");
    sb.append("    collateral: ").append(toIndentedString(collateral)).append("\n");
    sb.append("    coverage: ").append(toIndentedString(coverage)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    currentBalance: ").append(toIndentedString(currentBalance)).append("\n");
    sb.append("    currentLevel: ").append(toIndentedString(currentLevel)).append("\n");
    sb.append("    dataset: ").append(toIndentedString(dataset)).append("\n");
    sb.append("    deathBenefit: ").append(toIndentedString(deathBenefit)).append("\n");
    sb.append("    derivedApr: ").append(toIndentedString(derivedApr)).append("\n");
    sb.append("    displayedName: ").append(toIndentedString(displayedName)).append("\n");
    sb.append("    dueDate: ").append(toIndentedString(dueDate)).append("\n");
    sb.append("    enrollmentDate: ").append(toIndentedString(enrollmentDate)).append("\n");
    sb.append("    escrowBalance: ").append(toIndentedString(escrowBalance)).append("\n");
    sb.append("    estimatedDate: ").append(toIndentedString(estimatedDate)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("    faceAmount: ").append(toIndentedString(faceAmount)).append("\n");
    sb.append("    frequency: ").append(toIndentedString(frequency)).append("\n");
    sb.append("    guarantor: ").append(toIndentedString(guarantor)).append("\n");
    sb.append("    homeInsuranceType: ").append(toIndentedString(homeInsuranceType)).append("\n");
    sb.append("    homeValue: ").append(toIndentedString(homeValue)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    includeInNetWorth: ").append(toIndentedString(includeInNetWorth)).append("\n");
    sb.append("    interestPaidLastYear: ").append(toIndentedString(interestPaidLastYear)).append("\n");
    sb.append("    interestPaidYTD: ").append(toIndentedString(interestPaidYTD)).append("\n");
    sb.append("    interestRate: ").append(toIndentedString(interestRate)).append("\n");
    sb.append("    interestRateType: ").append(toIndentedString(interestRateType)).append("\n");
    sb.append("    isAsset: ").append(toIndentedString(isAsset)).append("\n");
    sb.append("    isDeleted: ").append(toIndentedString(isDeleted)).append("\n");
    sb.append("    isManual: ").append(toIndentedString(isManual)).append("\n");
    sb.append("    lastEmployeeContributionAmount: ").append(toIndentedString(lastEmployeeContributionAmount)).append("\n");
    sb.append("    lastEmployeeContributionDate: ").append(toIndentedString(lastEmployeeContributionDate)).append("\n");
    sb.append("    lastPayment: ").append(toIndentedString(lastPayment)).append("\n");
    sb.append("    lastPaymentAmount: ").append(toIndentedString(lastPaymentAmount)).append("\n");
    sb.append("    lastPaymentDate: ").append(toIndentedString(lastPaymentDate)).append("\n");
    sb.append("    lastUpdated: ").append(toIndentedString(lastUpdated)).append("\n");
    sb.append("    lender: ").append(toIndentedString(lender)).append("\n");
    sb.append("    lifeInsuranceType: ").append(toIndentedString(lifeInsuranceType)).append("\n");
    sb.append("    loanPayByDate: ").append(toIndentedString(loanPayByDate)).append("\n");
    sb.append("    loanPayoffAmount: ").append(toIndentedString(loanPayoffAmount)).append("\n");
    sb.append("    loanPayoffDetails: ").append(toIndentedString(loanPayoffDetails)).append("\n");
    sb.append("    marginBalance: ").append(toIndentedString(marginBalance)).append("\n");
    sb.append("    maturityAmount: ").append(toIndentedString(maturityAmount)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    memo: ").append(toIndentedString(memo)).append("\n");
    sb.append("    minimumAmountDue: ").append(toIndentedString(minimumAmountDue)).append("\n");
    sb.append("    moneyMarketBalance: ").append(toIndentedString(moneyMarketBalance)).append("\n");
    sb.append("    nextLevel: ").append(toIndentedString(nextLevel)).append("\n");
    sb.append("    nickname: ").append(toIndentedString(nickname)).append("\n");
    sb.append("    oauthMigrationStatus: ").append(toIndentedString(oauthMigrationStatus)).append("\n");
    sb.append("    originalLoanAmount: ").append(toIndentedString(originalLoanAmount)).append("\n");
    sb.append("    originationDate: ").append(toIndentedString(originationDate)).append("\n");
    sb.append("    overDraftLimit: ").append(toIndentedString(overDraftLimit)).append("\n");
    sb.append("    policyEffectiveDate: ").append(toIndentedString(policyEffectiveDate)).append("\n");
    sb.append("    policyFromDate: ").append(toIndentedString(policyFromDate)).append("\n");
    sb.append("    policyStatus: ").append(toIndentedString(policyStatus)).append("\n");
    sb.append("    policyTerm: ").append(toIndentedString(policyTerm)).append("\n");
    sb.append("    policyToDate: ").append(toIndentedString(policyToDate)).append("\n");
    sb.append("    premium: ").append(toIndentedString(premium)).append("\n");
    sb.append("    premiumPaymentTerm: ").append(toIndentedString(premiumPaymentTerm)).append("\n");
    sb.append("    primaryRewardUnit: ").append(toIndentedString(primaryRewardUnit)).append("\n");
    sb.append("    principalBalance: ").append(toIndentedString(principalBalance)).append("\n");
    sb.append("    providerAccountId: ").append(toIndentedString(providerAccountId)).append("\n");
    sb.append("    providerId: ").append(toIndentedString(providerId)).append("\n");
    sb.append("    providerName: ").append(toIndentedString(providerName)).append("\n");
    sb.append("    recurringPayment: ").append(toIndentedString(recurringPayment)).append("\n");
    sb.append("    remainingBalance: ").append(toIndentedString(remainingBalance)).append("\n");
    sb.append("    repaymentPlanType: ").append(toIndentedString(repaymentPlanType)).append("\n");
    sb.append("    rewardBalance: ").append(toIndentedString(rewardBalance)).append("\n");
    sb.append("    runningBalance: ").append(toIndentedString(runningBalance)).append("\n");
    sb.append("    shortBalance: ").append(toIndentedString(shortBalance)).append("\n");
    sb.append("    sourceAccountStatus: ").append(toIndentedString(sourceAccountStatus)).append("\n");
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    term: ").append(toIndentedString(term)).append("\n");
    sb.append("    totalCashLimit: ").append(toIndentedString(totalCashLimit)).append("\n");
    sb.append("    totalCreditLimit: ").append(toIndentedString(totalCreditLimit)).append("\n");
    sb.append("    totalCreditLine: ").append(toIndentedString(totalCreditLine)).append("\n");
    sb.append("    totalUnvestedBalance: ").append(toIndentedString(totalUnvestedBalance)).append("\n");
    sb.append("    totalVestedBalance: ").append(toIndentedString(totalVestedBalance)).append("\n");
    sb.append("    userClassification: ").append(toIndentedString(userClassification)).append("\n");
    sb.append("    valuationType: ").append(toIndentedString(valuationType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("401kLoan");
    openapiFields.add("CONTAINER");
    openapiFields.add("accountName");
    openapiFields.add("accountNumber");
    openapiFields.add("accountStatus");
    openapiFields.add("accountType");
    openapiFields.add("address");
    openapiFields.add("aggregationSource");
    openapiFields.add("amountDue");
    openapiFields.add("annualPercentageYield");
    openapiFields.add("annuityBalance");
    openapiFields.add("apr");
    openapiFields.add("associatedProviderAccountId");
    openapiFields.add("availableBalance");
    openapiFields.add("availableCash");
    openapiFields.add("availableCredit");
    openapiFields.add("balance");
    openapiFields.add("bankTransferCode");
    openapiFields.add("cash");
    openapiFields.add("cashApr");
    openapiFields.add("cashValue");
    openapiFields.add("classification");
    openapiFields.add("collateral");
    openapiFields.add("coverage");
    openapiFields.add("createdDate");
    openapiFields.add("currentBalance");
    openapiFields.add("currentLevel");
    openapiFields.add("dataset");
    openapiFields.add("deathBenefit");
    openapiFields.add("derivedApr");
    openapiFields.add("displayedName");
    openapiFields.add("dueDate");
    openapiFields.add("enrollmentDate");
    openapiFields.add("escrowBalance");
    openapiFields.add("estimatedDate");
    openapiFields.add("expirationDate");
    openapiFields.add("faceAmount");
    openapiFields.add("frequency");
    openapiFields.add("guarantor");
    openapiFields.add("homeInsuranceType");
    openapiFields.add("homeValue");
    openapiFields.add("id");
    openapiFields.add("includeInNetWorth");
    openapiFields.add("interestPaidLastYear");
    openapiFields.add("interestPaidYTD");
    openapiFields.add("interestRate");
    openapiFields.add("interestRateType");
    openapiFields.add("isAsset");
    openapiFields.add("isDeleted");
    openapiFields.add("isManual");
    openapiFields.add("lastEmployeeContributionAmount");
    openapiFields.add("lastEmployeeContributionDate");
    openapiFields.add("lastPayment");
    openapiFields.add("lastPaymentAmount");
    openapiFields.add("lastPaymentDate");
    openapiFields.add("lastUpdated");
    openapiFields.add("lender");
    openapiFields.add("lifeInsuranceType");
    openapiFields.add("loanPayByDate");
    openapiFields.add("loanPayoffAmount");
    openapiFields.add("loanPayoffDetails");
    openapiFields.add("marginBalance");
    openapiFields.add("maturityAmount");
    openapiFields.add("maturityDate");
    openapiFields.add("memo");
    openapiFields.add("minimumAmountDue");
    openapiFields.add("moneyMarketBalance");
    openapiFields.add("nextLevel");
    openapiFields.add("nickname");
    openapiFields.add("oauthMigrationStatus");
    openapiFields.add("originalLoanAmount");
    openapiFields.add("originationDate");
    openapiFields.add("overDraftLimit");
    openapiFields.add("policyEffectiveDate");
    openapiFields.add("policyFromDate");
    openapiFields.add("policyStatus");
    openapiFields.add("policyTerm");
    openapiFields.add("policyToDate");
    openapiFields.add("premium");
    openapiFields.add("premiumPaymentTerm");
    openapiFields.add("primaryRewardUnit");
    openapiFields.add("principalBalance");
    openapiFields.add("providerAccountId");
    openapiFields.add("providerId");
    openapiFields.add("providerName");
    openapiFields.add("recurringPayment");
    openapiFields.add("remainingBalance");
    openapiFields.add("repaymentPlanType");
    openapiFields.add("rewardBalance");
    openapiFields.add("runningBalance");
    openapiFields.add("shortBalance");
    openapiFields.add("sourceAccountStatus");
    openapiFields.add("sourceId");
    openapiFields.add("term");
    openapiFields.add("totalCashLimit");
    openapiFields.add("totalCreditLimit");
    openapiFields.add("totalCreditLine");
    openapiFields.add("totalUnvestedBalance");
    openapiFields.add("totalVestedBalance");
    openapiFields.add("userClassification");
    openapiFields.add("valuationType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DataExtractsAccount
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DataExtractsAccount.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataExtractsAccount is not found in the empty JSON string", DataExtractsAccount.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DataExtractsAccount.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DataExtractsAccount` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `401kLoan`
      if (jsonObj.get("401kLoan") != null && !jsonObj.get("401kLoan").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("401kLoan"));
      }
      if ((jsonObj.get("CONTAINER") != null && !jsonObj.get("CONTAINER").isJsonNull()) && !jsonObj.get("CONTAINER").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CONTAINER` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CONTAINER").toString()));
      }
      // validate the optional field `CONTAINER`
      if (jsonObj.get("CONTAINER") != null && !jsonObj.get("CONTAINER").isJsonNull()) {
        CONTAINEREnum.validateJsonElement(jsonObj.get("CONTAINER"));
      }
      if ((jsonObj.get("accountName") != null && !jsonObj.get("accountName").isJsonNull()) && !jsonObj.get("accountName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountName").toString()));
      }
      if ((jsonObj.get("accountNumber") != null && !jsonObj.get("accountNumber").isJsonNull()) && !jsonObj.get("accountNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountNumber").toString()));
      }
      if ((jsonObj.get("accountStatus") != null && !jsonObj.get("accountStatus").isJsonNull()) && !jsonObj.get("accountStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountStatus").toString()));
      }
      // validate the optional field `accountStatus`
      if (jsonObj.get("accountStatus") != null && !jsonObj.get("accountStatus").isJsonNull()) {
        AccountStatusEnum.validateJsonElement(jsonObj.get("accountStatus"));
      }
      if ((jsonObj.get("accountType") != null && !jsonObj.get("accountType").isJsonNull()) && !jsonObj.get("accountType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountType").toString()));
      }
      // validate the optional field `address`
      if (jsonObj.get("address") != null && !jsonObj.get("address").isJsonNull()) {
        AccountAddress.validateJsonElement(jsonObj.get("address"));
      }
      if ((jsonObj.get("aggregationSource") != null && !jsonObj.get("aggregationSource").isJsonNull()) && !jsonObj.get("aggregationSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aggregationSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aggregationSource").toString()));
      }
      // validate the optional field `aggregationSource`
      if (jsonObj.get("aggregationSource") != null && !jsonObj.get("aggregationSource").isJsonNull()) {
        AggregationSourceEnum.validateJsonElement(jsonObj.get("aggregationSource"));
      }
      // validate the optional field `amountDue`
      if (jsonObj.get("amountDue") != null && !jsonObj.get("amountDue").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("amountDue"));
      }
      // validate the optional field `annuityBalance`
      if (jsonObj.get("annuityBalance") != null && !jsonObj.get("annuityBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("annuityBalance"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("associatedProviderAccountId") != null && !jsonObj.get("associatedProviderAccountId").isJsonNull() && !jsonObj.get("associatedProviderAccountId").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `associatedProviderAccountId` to be an array in the JSON string but got `%s`", jsonObj.get("associatedProviderAccountId").toString()));
      }
      // validate the optional field `availableBalance`
      if (jsonObj.get("availableBalance") != null && !jsonObj.get("availableBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("availableBalance"));
      }
      // validate the optional field `availableCash`
      if (jsonObj.get("availableCash") != null && !jsonObj.get("availableCash").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("availableCash"));
      }
      // validate the optional field `availableCredit`
      if (jsonObj.get("availableCredit") != null && !jsonObj.get("availableCredit").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("availableCredit"));
      }
      // validate the optional field `balance`
      if (jsonObj.get("balance") != null && !jsonObj.get("balance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("balance"));
      }
      if (jsonObj.get("bankTransferCode") != null && !jsonObj.get("bankTransferCode").isJsonNull()) {
        JsonArray jsonArraybankTransferCode = jsonObj.getAsJsonArray("bankTransferCode");
        if (jsonArraybankTransferCode != null) {
          // ensure the json data is an array
          if (!jsonObj.get("bankTransferCode").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `bankTransferCode` to be an array in the JSON string but got `%s`", jsonObj.get("bankTransferCode").toString()));
          }

          // validate the optional field `bankTransferCode` (array)
          for (int i = 0; i < jsonArraybankTransferCode.size(); i++) {
            BankTransferCode.validateJsonElement(jsonArraybankTransferCode.get(i));
          };
        }
      }
      // validate the optional field `cash`
      if (jsonObj.get("cash") != null && !jsonObj.get("cash").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("cash"));
      }
      // validate the optional field `cashValue`
      if (jsonObj.get("cashValue") != null && !jsonObj.get("cashValue").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("cashValue"));
      }
      if ((jsonObj.get("classification") != null && !jsonObj.get("classification").isJsonNull()) && !jsonObj.get("classification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `classification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("classification").toString()));
      }
      // validate the optional field `classification`
      if (jsonObj.get("classification") != null && !jsonObj.get("classification").isJsonNull()) {
        ClassificationEnum.validateJsonElement(jsonObj.get("classification"));
      }
      if ((jsonObj.get("collateral") != null && !jsonObj.get("collateral").isJsonNull()) && !jsonObj.get("collateral").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `collateral` to be a primitive type in the JSON string but got `%s`", jsonObj.get("collateral").toString()));
      }
      if (jsonObj.get("coverage") != null && !jsonObj.get("coverage").isJsonNull()) {
        JsonArray jsonArraycoverage = jsonObj.getAsJsonArray("coverage");
        if (jsonArraycoverage != null) {
          // ensure the json data is an array
          if (!jsonObj.get("coverage").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `coverage` to be an array in the JSON string but got `%s`", jsonObj.get("coverage").toString()));
          }

          // validate the optional field `coverage` (array)
          for (int i = 0; i < jsonArraycoverage.size(); i++) {
            Coverage.validateJsonElement(jsonArraycoverage.get(i));
          };
        }
      }
      if ((jsonObj.get("createdDate") != null && !jsonObj.get("createdDate").isJsonNull()) && !jsonObj.get("createdDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdDate").toString()));
      }
      // validate the optional field `currentBalance`
      if (jsonObj.get("currentBalance") != null && !jsonObj.get("currentBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("currentBalance"));
      }
      if ((jsonObj.get("currentLevel") != null && !jsonObj.get("currentLevel").isJsonNull()) && !jsonObj.get("currentLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currentLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currentLevel").toString()));
      }
      if (jsonObj.get("dataset") != null && !jsonObj.get("dataset").isJsonNull()) {
        JsonArray jsonArraydataset = jsonObj.getAsJsonArray("dataset");
        if (jsonArraydataset != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dataset").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dataset` to be an array in the JSON string but got `%s`", jsonObj.get("dataset").toString()));
          }

          // validate the optional field `dataset` (array)
          for (int i = 0; i < jsonArraydataset.size(); i++) {
            AccountDataset.validateJsonElement(jsonArraydataset.get(i));
          };
        }
      }
      // validate the optional field `deathBenefit`
      if (jsonObj.get("deathBenefit") != null && !jsonObj.get("deathBenefit").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("deathBenefit"));
      }
      if ((jsonObj.get("displayedName") != null && !jsonObj.get("displayedName").isJsonNull()) && !jsonObj.get("displayedName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayedName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayedName").toString()));
      }
      if ((jsonObj.get("dueDate") != null && !jsonObj.get("dueDate").isJsonNull()) && !jsonObj.get("dueDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dueDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dueDate").toString()));
      }
      if ((jsonObj.get("enrollmentDate") != null && !jsonObj.get("enrollmentDate").isJsonNull()) && !jsonObj.get("enrollmentDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `enrollmentDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("enrollmentDate").toString()));
      }
      // validate the optional field `escrowBalance`
      if (jsonObj.get("escrowBalance") != null && !jsonObj.get("escrowBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("escrowBalance"));
      }
      if ((jsonObj.get("estimatedDate") != null && !jsonObj.get("estimatedDate").isJsonNull()) && !jsonObj.get("estimatedDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `estimatedDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("estimatedDate").toString()));
      }
      if ((jsonObj.get("expirationDate") != null && !jsonObj.get("expirationDate").isJsonNull()) && !jsonObj.get("expirationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expirationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expirationDate").toString()));
      }
      // validate the optional field `faceAmount`
      if (jsonObj.get("faceAmount") != null && !jsonObj.get("faceAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("faceAmount"));
      }
      if ((jsonObj.get("frequency") != null && !jsonObj.get("frequency").isJsonNull()) && !jsonObj.get("frequency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `frequency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("frequency").toString()));
      }
      // validate the optional field `frequency`
      if (jsonObj.get("frequency") != null && !jsonObj.get("frequency").isJsonNull()) {
        FrequencyEnum.validateJsonElement(jsonObj.get("frequency"));
      }
      if ((jsonObj.get("guarantor") != null && !jsonObj.get("guarantor").isJsonNull()) && !jsonObj.get("guarantor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `guarantor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("guarantor").toString()));
      }
      if ((jsonObj.get("homeInsuranceType") != null && !jsonObj.get("homeInsuranceType").isJsonNull()) && !jsonObj.get("homeInsuranceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `homeInsuranceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("homeInsuranceType").toString()));
      }
      // validate the optional field `homeInsuranceType`
      if (jsonObj.get("homeInsuranceType") != null && !jsonObj.get("homeInsuranceType").isJsonNull()) {
        HomeInsuranceTypeEnum.validateJsonElement(jsonObj.get("homeInsuranceType"));
      }
      // validate the optional field `homeValue`
      if (jsonObj.get("homeValue") != null && !jsonObj.get("homeValue").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("homeValue"));
      }
      // validate the optional field `interestPaidLastYear`
      if (jsonObj.get("interestPaidLastYear") != null && !jsonObj.get("interestPaidLastYear").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("interestPaidLastYear"));
      }
      // validate the optional field `interestPaidYTD`
      if (jsonObj.get("interestPaidYTD") != null && !jsonObj.get("interestPaidYTD").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("interestPaidYTD"));
      }
      if ((jsonObj.get("interestRateType") != null && !jsonObj.get("interestRateType").isJsonNull()) && !jsonObj.get("interestRateType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interestRateType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interestRateType").toString()));
      }
      // validate the optional field `interestRateType`
      if (jsonObj.get("interestRateType") != null && !jsonObj.get("interestRateType").isJsonNull()) {
        InterestRateTypeEnum.validateJsonElement(jsonObj.get("interestRateType"));
      }
      // validate the optional field `lastEmployeeContributionAmount`
      if (jsonObj.get("lastEmployeeContributionAmount") != null && !jsonObj.get("lastEmployeeContributionAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("lastEmployeeContributionAmount"));
      }
      if ((jsonObj.get("lastEmployeeContributionDate") != null && !jsonObj.get("lastEmployeeContributionDate").isJsonNull()) && !jsonObj.get("lastEmployeeContributionDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastEmployeeContributionDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastEmployeeContributionDate").toString()));
      }
      // validate the optional field `lastPayment`
      if (jsonObj.get("lastPayment") != null && !jsonObj.get("lastPayment").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("lastPayment"));
      }
      // validate the optional field `lastPaymentAmount`
      if (jsonObj.get("lastPaymentAmount") != null && !jsonObj.get("lastPaymentAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("lastPaymentAmount"));
      }
      if ((jsonObj.get("lastPaymentDate") != null && !jsonObj.get("lastPaymentDate").isJsonNull()) && !jsonObj.get("lastPaymentDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastPaymentDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastPaymentDate").toString()));
      }
      if ((jsonObj.get("lastUpdated") != null && !jsonObj.get("lastUpdated").isJsonNull()) && !jsonObj.get("lastUpdated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdated").toString()));
      }
      if ((jsonObj.get("lender") != null && !jsonObj.get("lender").isJsonNull()) && !jsonObj.get("lender").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lender` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lender").toString()));
      }
      if ((jsonObj.get("lifeInsuranceType") != null && !jsonObj.get("lifeInsuranceType").isJsonNull()) && !jsonObj.get("lifeInsuranceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lifeInsuranceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lifeInsuranceType").toString()));
      }
      // validate the optional field `lifeInsuranceType`
      if (jsonObj.get("lifeInsuranceType") != null && !jsonObj.get("lifeInsuranceType").isJsonNull()) {
        LifeInsuranceTypeEnum.validateJsonElement(jsonObj.get("lifeInsuranceType"));
      }
      if ((jsonObj.get("loanPayByDate") != null && !jsonObj.get("loanPayByDate").isJsonNull()) && !jsonObj.get("loanPayByDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `loanPayByDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("loanPayByDate").toString()));
      }
      // validate the optional field `loanPayoffAmount`
      if (jsonObj.get("loanPayoffAmount") != null && !jsonObj.get("loanPayoffAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("loanPayoffAmount"));
      }
      // validate the optional field `loanPayoffDetails`
      if (jsonObj.get("loanPayoffDetails") != null && !jsonObj.get("loanPayoffDetails").isJsonNull()) {
        LoanPayoffDetails.validateJsonElement(jsonObj.get("loanPayoffDetails"));
      }
      // validate the optional field `marginBalance`
      if (jsonObj.get("marginBalance") != null && !jsonObj.get("marginBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("marginBalance"));
      }
      // validate the optional field `maturityAmount`
      if (jsonObj.get("maturityAmount") != null && !jsonObj.get("maturityAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("maturityAmount"));
      }
      if ((jsonObj.get("maturityDate") != null && !jsonObj.get("maturityDate").isJsonNull()) && !jsonObj.get("maturityDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maturityDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maturityDate").toString()));
      }
      if ((jsonObj.get("memo") != null && !jsonObj.get("memo").isJsonNull()) && !jsonObj.get("memo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memo").toString()));
      }
      // validate the optional field `minimumAmountDue`
      if (jsonObj.get("minimumAmountDue") != null && !jsonObj.get("minimumAmountDue").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("minimumAmountDue"));
      }
      // validate the optional field `moneyMarketBalance`
      if (jsonObj.get("moneyMarketBalance") != null && !jsonObj.get("moneyMarketBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("moneyMarketBalance"));
      }
      if ((jsonObj.get("nextLevel") != null && !jsonObj.get("nextLevel").isJsonNull()) && !jsonObj.get("nextLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nextLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nextLevel").toString()));
      }
      if ((jsonObj.get("nickname") != null && !jsonObj.get("nickname").isJsonNull()) && !jsonObj.get("nickname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nickname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nickname").toString()));
      }
      if ((jsonObj.get("oauthMigrationStatus") != null && !jsonObj.get("oauthMigrationStatus").isJsonNull()) && !jsonObj.get("oauthMigrationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `oauthMigrationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("oauthMigrationStatus").toString()));
      }
      // validate the optional field `oauthMigrationStatus`
      if (jsonObj.get("oauthMigrationStatus") != null && !jsonObj.get("oauthMigrationStatus").isJsonNull()) {
        OauthMigrationStatusEnum.validateJsonElement(jsonObj.get("oauthMigrationStatus"));
      }
      // validate the optional field `originalLoanAmount`
      if (jsonObj.get("originalLoanAmount") != null && !jsonObj.get("originalLoanAmount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("originalLoanAmount"));
      }
      if ((jsonObj.get("originationDate") != null && !jsonObj.get("originationDate").isJsonNull()) && !jsonObj.get("originationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `originationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("originationDate").toString()));
      }
      // validate the optional field `overDraftLimit`
      if (jsonObj.get("overDraftLimit") != null && !jsonObj.get("overDraftLimit").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("overDraftLimit"));
      }
      if ((jsonObj.get("policyEffectiveDate") != null && !jsonObj.get("policyEffectiveDate").isJsonNull()) && !jsonObj.get("policyEffectiveDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `policyEffectiveDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("policyEffectiveDate").toString()));
      }
      if ((jsonObj.get("policyFromDate") != null && !jsonObj.get("policyFromDate").isJsonNull()) && !jsonObj.get("policyFromDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `policyFromDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("policyFromDate").toString()));
      }
      if ((jsonObj.get("policyStatus") != null && !jsonObj.get("policyStatus").isJsonNull()) && !jsonObj.get("policyStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `policyStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("policyStatus").toString()));
      }
      // validate the optional field `policyStatus`
      if (jsonObj.get("policyStatus") != null && !jsonObj.get("policyStatus").isJsonNull()) {
        PolicyStatusEnum.validateJsonElement(jsonObj.get("policyStatus"));
      }
      if ((jsonObj.get("policyTerm") != null && !jsonObj.get("policyTerm").isJsonNull()) && !jsonObj.get("policyTerm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `policyTerm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("policyTerm").toString()));
      }
      if ((jsonObj.get("policyToDate") != null && !jsonObj.get("policyToDate").isJsonNull()) && !jsonObj.get("policyToDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `policyToDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("policyToDate").toString()));
      }
      // validate the optional field `premium`
      if (jsonObj.get("premium") != null && !jsonObj.get("premium").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("premium"));
      }
      if ((jsonObj.get("premiumPaymentTerm") != null && !jsonObj.get("premiumPaymentTerm").isJsonNull()) && !jsonObj.get("premiumPaymentTerm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `premiumPaymentTerm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("premiumPaymentTerm").toString()));
      }
      if ((jsonObj.get("primaryRewardUnit") != null && !jsonObj.get("primaryRewardUnit").isJsonNull()) && !jsonObj.get("primaryRewardUnit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `primaryRewardUnit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("primaryRewardUnit").toString()));
      }
      // validate the optional field `principalBalance`
      if (jsonObj.get("principalBalance") != null && !jsonObj.get("principalBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("principalBalance"));
      }
      if ((jsonObj.get("providerId") != null && !jsonObj.get("providerId").isJsonNull()) && !jsonObj.get("providerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `providerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("providerId").toString()));
      }
      if ((jsonObj.get("providerName") != null && !jsonObj.get("providerName").isJsonNull()) && !jsonObj.get("providerName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `providerName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("providerName").toString()));
      }
      // validate the optional field `recurringPayment`
      if (jsonObj.get("recurringPayment") != null && !jsonObj.get("recurringPayment").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("recurringPayment"));
      }
      // validate the optional field `remainingBalance`
      if (jsonObj.get("remainingBalance") != null && !jsonObj.get("remainingBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("remainingBalance"));
      }
      if ((jsonObj.get("repaymentPlanType") != null && !jsonObj.get("repaymentPlanType").isJsonNull()) && !jsonObj.get("repaymentPlanType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `repaymentPlanType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("repaymentPlanType").toString()));
      }
      // validate the optional field `repaymentPlanType`
      if (jsonObj.get("repaymentPlanType") != null && !jsonObj.get("repaymentPlanType").isJsonNull()) {
        RepaymentPlanTypeEnum.validateJsonElement(jsonObj.get("repaymentPlanType"));
      }
      if (jsonObj.get("rewardBalance") != null && !jsonObj.get("rewardBalance").isJsonNull()) {
        JsonArray jsonArrayrewardBalance = jsonObj.getAsJsonArray("rewardBalance");
        if (jsonArrayrewardBalance != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rewardBalance").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rewardBalance` to be an array in the JSON string but got `%s`", jsonObj.get("rewardBalance").toString()));
          }

          // validate the optional field `rewardBalance` (array)
          for (int i = 0; i < jsonArrayrewardBalance.size(); i++) {
            RewardBalance.validateJsonElement(jsonArrayrewardBalance.get(i));
          };
        }
      }
      // validate the optional field `runningBalance`
      if (jsonObj.get("runningBalance") != null && !jsonObj.get("runningBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("runningBalance"));
      }
      // validate the optional field `shortBalance`
      if (jsonObj.get("shortBalance") != null && !jsonObj.get("shortBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("shortBalance"));
      }
      if ((jsonObj.get("sourceAccountStatus") != null && !jsonObj.get("sourceAccountStatus").isJsonNull()) && !jsonObj.get("sourceAccountStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceAccountStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceAccountStatus").toString()));
      }
      // validate the optional field `sourceAccountStatus`
      if (jsonObj.get("sourceAccountStatus") != null && !jsonObj.get("sourceAccountStatus").isJsonNull()) {
        SourceAccountStatusEnum.validateJsonElement(jsonObj.get("sourceAccountStatus"));
      }
      if ((jsonObj.get("sourceId") != null && !jsonObj.get("sourceId").isJsonNull()) && !jsonObj.get("sourceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceId").toString()));
      }
      if ((jsonObj.get("term") != null && !jsonObj.get("term").isJsonNull()) && !jsonObj.get("term").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `term` to be a primitive type in the JSON string but got `%s`", jsonObj.get("term").toString()));
      }
      // validate the optional field `totalCashLimit`
      if (jsonObj.get("totalCashLimit") != null && !jsonObj.get("totalCashLimit").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("totalCashLimit"));
      }
      // validate the optional field `totalCreditLimit`
      if (jsonObj.get("totalCreditLimit") != null && !jsonObj.get("totalCreditLimit").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("totalCreditLimit"));
      }
      // validate the optional field `totalCreditLine`
      if (jsonObj.get("totalCreditLine") != null && !jsonObj.get("totalCreditLine").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("totalCreditLine"));
      }
      // validate the optional field `totalUnvestedBalance`
      if (jsonObj.get("totalUnvestedBalance") != null && !jsonObj.get("totalUnvestedBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("totalUnvestedBalance"));
      }
      // validate the optional field `totalVestedBalance`
      if (jsonObj.get("totalVestedBalance") != null && !jsonObj.get("totalVestedBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("totalVestedBalance"));
      }
      if ((jsonObj.get("userClassification") != null && !jsonObj.get("userClassification").isJsonNull()) && !jsonObj.get("userClassification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userClassification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userClassification").toString()));
      }
      // validate the optional field `userClassification`
      if (jsonObj.get("userClassification") != null && !jsonObj.get("userClassification").isJsonNull()) {
        UserClassificationEnum.validateJsonElement(jsonObj.get("userClassification"));
      }
      if ((jsonObj.get("valuationType") != null && !jsonObj.get("valuationType").isJsonNull()) && !jsonObj.get("valuationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valuationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valuationType").toString()));
      }
      // validate the optional field `valuationType`
      if (jsonObj.get("valuationType") != null && !jsonObj.get("valuationType").isJsonNull()) {
        ValuationTypeEnum.validateJsonElement(jsonObj.get("valuationType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataExtractsAccount.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataExtractsAccount' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataExtractsAccount> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataExtractsAccount.class));

       return (TypeAdapter<T>) new TypeAdapter<DataExtractsAccount>() {
           @Override
           public void write(JsonWriter out, DataExtractsAccount value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataExtractsAccount read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DataExtractsAccount given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DataExtractsAccount
   * @throws IOException if the JSON string is invalid with respect to DataExtractsAccount
   */
  public static DataExtractsAccount fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataExtractsAccount.class);
  }

  /**
   * Convert an instance of DataExtractsAccount to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

