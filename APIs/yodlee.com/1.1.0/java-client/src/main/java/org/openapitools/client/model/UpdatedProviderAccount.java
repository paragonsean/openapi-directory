/*
 * Yodlee Core APIs
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee supports the Java SDK and it is available <a href=\"https://developer.yodlee.com/java-sdk-overview \">here</a>. You can generate a client SDK for Python, Java, JavaScript, PHP or other languages according to your development needs. For more details about the APIs, refer to <a href=\"https://developer.yodlee.com/docs/api/1.1/Overview\">Yodlee API v1.1 - Overview</a>.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developer@yodlee.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AccountDataset;
import org.openapitools.client.model.LoginForm;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdatedProviderAccount
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.041142-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdatedProviderAccount {
  /**
   * The source through which the providerAccount is added in the system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(AggregationSourceEnum.Adapter.class)
  public enum AggregationSourceEnum {
    SYSTEM("SYSTEM"),
    
    USER("USER");

    private String value;

    AggregationSourceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AggregationSourceEnum fromValue(String value) {
      for (AggregationSourceEnum b : AggregationSourceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AggregationSourceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AggregationSourceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AggregationSourceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AggregationSourceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AggregationSourceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AGGREGATION_SOURCE = "aggregationSource";
  @SerializedName(SERIALIZED_NAME_AGGREGATION_SOURCE)
  private AggregationSourceEnum aggregationSource;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private String createdDate;

  public static final String SERIALIZED_NAME_DATASET = "dataset";
  @SerializedName(SERIALIZED_NAME_DATASET)
  private List<AccountDataset> dataset = new ArrayList<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_IS_MANUAL = "isManual";
  @SerializedName(SERIALIZED_NAME_IS_MANUAL)
  private Boolean isManual;

  public static final String SERIALIZED_NAME_LAST_UPDATED = "lastUpdated";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED)
  private String lastUpdated;

  public static final String SERIALIZED_NAME_LOGIN_FORM = "loginForm";
  @SerializedName(SERIALIZED_NAME_LOGIN_FORM)
  private List<LoginForm> loginForm = new ArrayList<>();

  /**
   * Indicates the migration status of the provider account from screen-scraping provider to the Open Banking provider. &lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   */
  @JsonAdapter(OauthMigrationStatusEnum.Adapter.class)
  public enum OauthMigrationStatusEnum {
    IN_PROGRESS("IN_PROGRESS"),
    
    TO_BE_MIGRATED("TO_BE_MIGRATED"),
    
    COMPLETED("COMPLETED");

    private String value;

    OauthMigrationStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OauthMigrationStatusEnum fromValue(String value) {
      for (OauthMigrationStatusEnum b : OauthMigrationStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OauthMigrationStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OauthMigrationStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OauthMigrationStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OauthMigrationStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OauthMigrationStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OAUTH_MIGRATION_STATUS = "oauthMigrationStatus";
  @SerializedName(SERIALIZED_NAME_OAUTH_MIGRATION_STATUS)
  private OauthMigrationStatusEnum oauthMigrationStatus;

  public static final String SERIALIZED_NAME_PROVIDER_ID = "providerId";
  @SerializedName(SERIALIZED_NAME_PROVIDER_ID)
  private Long providerId;

  public static final String SERIALIZED_NAME_REQUEST_ID = "requestId";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  /**
   * The status of last update attempted for the account. &lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    LOGIN_IN_PROGRESS("LOGIN_IN_PROGRESS"),
    
    USER_INPUT_REQUIRED("USER_INPUT_REQUIRED"),
    
    IN_PROGRESS("IN_PROGRESS"),
    
    PARTIAL_SUCCESS("PARTIAL_SUCCESS"),
    
    SUCCESS("SUCCESS"),
    
    FAILED("FAILED"),
    
    MIGRATION_IN_PROGRESS("MIGRATION_IN_PROGRESS");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public UpdatedProviderAccount() {
  }

  public UpdatedProviderAccount(
     AggregationSourceEnum aggregationSource, 
     String createdDate, 
     List<AccountDataset> dataset, 
     Long id, 
     Boolean isManual, 
     String lastUpdated, 
     List<LoginForm> loginForm, 
     OauthMigrationStatusEnum oauthMigrationStatus, 
     Long providerId, 
     String requestId, 
     StatusEnum status
  ) {
    this();
    this.aggregationSource = aggregationSource;
    this.createdDate = createdDate;
    this.dataset = dataset;
    this.id = id;
    this.isManual = isManual;
    this.lastUpdated = lastUpdated;
    this.loginForm = loginForm;
    this.oauthMigrationStatus = oauthMigrationStatus;
    this.providerId = providerId;
    this.requestId = requestId;
    this.status = status;
  }

  /**
   * The source through which the providerAccount is added in the system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return aggregationSource
   */
  @javax.annotation.Nullable
  public AggregationSourceEnum getAggregationSource() {
    return aggregationSource;
  }



  /**
   * The date on when the provider account is created in the system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return createdDate
   */
  @javax.annotation.Nullable
  public String getCreatedDate() {
    return createdDate;
  }



  /**
   * Logical grouping of dataset attributes into datasets such as Basic Aggregation Data, Account Profile and Documents.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return dataset
   */
  @javax.annotation.Nullable
  public List<AccountDataset> getDataset() {
    return dataset;
  }



  /**
   * Unique identifier for the provider account resource. This is created during account addition.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return id
   */
  @javax.annotation.Nullable
  public Long getId() {
    return id;
  }



  /**
   * Indicates whether account is a manual or aggregated provider account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return isManual
   */
  @javax.annotation.Nullable
  public Boolean getIsManual() {
    return isManual;
  }



  /**
   * Indicate when the providerAccount is last updated successfully.&lt;br&gt;&lt;br&gt;&lt;b&gt;Account Type&lt;/b&gt;: Aggregated&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return lastUpdated
   */
  @javax.annotation.Nullable
  public String getLastUpdated() {
    return lastUpdated;
  }



  /**
   * This entity gets returned in the response for only MFA based provider accounts during the add/update account polling process. This indicates that the MFA information is expected from the user to complete the process. This represents the structure of MFA form that is displayed to the user in the provider site.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;/ul&gt;
   * @return loginForm
   */
  @javax.annotation.Nullable
  public List<LoginForm> getLoginForm() {
    return loginForm;
  }



  /**
   * Indicates the migration status of the provider account from screen-scraping provider to the Open Banking provider. &lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return oauthMigrationStatus
   */
  @javax.annotation.Nullable
  public OauthMigrationStatusEnum getOauthMigrationStatus() {
    return oauthMigrationStatus;
  }



  /**
   * Unique identifier for the provider resource. This denotes the provider for which the provider account id is generated by the user.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return providerId
   */
  @javax.annotation.Nullable
  public Long getProviderId() {
    return providerId;
  }



  /**
   * Unique id generated to indicate the request.&lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;/ul&gt;
   * @return requestId
   */
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }



  /**
   * The status of last update attempted for the account. &lt;br&gt;&lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;ul&gt;&lt;li&gt;GET providerAccounts&lt;/li&gt;&lt;li&gt;POST providerAccounts&lt;/li&gt;&lt;li&gt;PUT providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET providerAccounts/{providerAccountId}&lt;/li&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdatedProviderAccount updatedProviderAccount = (UpdatedProviderAccount) o;
    return Objects.equals(this.aggregationSource, updatedProviderAccount.aggregationSource) &&
        Objects.equals(this.createdDate, updatedProviderAccount.createdDate) &&
        Objects.equals(this.dataset, updatedProviderAccount.dataset) &&
        Objects.equals(this.id, updatedProviderAccount.id) &&
        Objects.equals(this.isManual, updatedProviderAccount.isManual) &&
        Objects.equals(this.lastUpdated, updatedProviderAccount.lastUpdated) &&
        Objects.equals(this.loginForm, updatedProviderAccount.loginForm) &&
        Objects.equals(this.oauthMigrationStatus, updatedProviderAccount.oauthMigrationStatus) &&
        Objects.equals(this.providerId, updatedProviderAccount.providerId) &&
        Objects.equals(this.requestId, updatedProviderAccount.requestId) &&
        Objects.equals(this.status, updatedProviderAccount.status);
  }

  @Override
  public int hashCode() {
    return Objects.hash(aggregationSource, createdDate, dataset, id, isManual, lastUpdated, loginForm, oauthMigrationStatus, providerId, requestId, status);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdatedProviderAccount {\n");
    sb.append("    aggregationSource: ").append(toIndentedString(aggregationSource)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    dataset: ").append(toIndentedString(dataset)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    isManual: ").append(toIndentedString(isManual)).append("\n");
    sb.append("    lastUpdated: ").append(toIndentedString(lastUpdated)).append("\n");
    sb.append("    loginForm: ").append(toIndentedString(loginForm)).append("\n");
    sb.append("    oauthMigrationStatus: ").append(toIndentedString(oauthMigrationStatus)).append("\n");
    sb.append("    providerId: ").append(toIndentedString(providerId)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("aggregationSource");
    openapiFields.add("createdDate");
    openapiFields.add("dataset");
    openapiFields.add("id");
    openapiFields.add("isManual");
    openapiFields.add("lastUpdated");
    openapiFields.add("loginForm");
    openapiFields.add("oauthMigrationStatus");
    openapiFields.add("providerId");
    openapiFields.add("requestId");
    openapiFields.add("status");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdatedProviderAccount
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdatedProviderAccount.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdatedProviderAccount is not found in the empty JSON string", UpdatedProviderAccount.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdatedProviderAccount.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdatedProviderAccount` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("aggregationSource") != null && !jsonObj.get("aggregationSource").isJsonNull()) && !jsonObj.get("aggregationSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aggregationSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aggregationSource").toString()));
      }
      // validate the optional field `aggregationSource`
      if (jsonObj.get("aggregationSource") != null && !jsonObj.get("aggregationSource").isJsonNull()) {
        AggregationSourceEnum.validateJsonElement(jsonObj.get("aggregationSource"));
      }
      if ((jsonObj.get("createdDate") != null && !jsonObj.get("createdDate").isJsonNull()) && !jsonObj.get("createdDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdDate").toString()));
      }
      if (jsonObj.get("dataset") != null && !jsonObj.get("dataset").isJsonNull()) {
        JsonArray jsonArraydataset = jsonObj.getAsJsonArray("dataset");
        if (jsonArraydataset != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dataset").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dataset` to be an array in the JSON string but got `%s`", jsonObj.get("dataset").toString()));
          }

          // validate the optional field `dataset` (array)
          for (int i = 0; i < jsonArraydataset.size(); i++) {
            AccountDataset.validateJsonElement(jsonArraydataset.get(i));
          };
        }
      }
      if ((jsonObj.get("lastUpdated") != null && !jsonObj.get("lastUpdated").isJsonNull()) && !jsonObj.get("lastUpdated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdated").toString()));
      }
      if (jsonObj.get("loginForm") != null && !jsonObj.get("loginForm").isJsonNull()) {
        JsonArray jsonArrayloginForm = jsonObj.getAsJsonArray("loginForm");
        if (jsonArrayloginForm != null) {
          // ensure the json data is an array
          if (!jsonObj.get("loginForm").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `loginForm` to be an array in the JSON string but got `%s`", jsonObj.get("loginForm").toString()));
          }

          // validate the optional field `loginForm` (array)
          for (int i = 0; i < jsonArrayloginForm.size(); i++) {
            LoginForm.validateJsonElement(jsonArrayloginForm.get(i));
          };
        }
      }
      if ((jsonObj.get("oauthMigrationStatus") != null && !jsonObj.get("oauthMigrationStatus").isJsonNull()) && !jsonObj.get("oauthMigrationStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `oauthMigrationStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("oauthMigrationStatus").toString()));
      }
      // validate the optional field `oauthMigrationStatus`
      if (jsonObj.get("oauthMigrationStatus") != null && !jsonObj.get("oauthMigrationStatus").isJsonNull()) {
        OauthMigrationStatusEnum.validateJsonElement(jsonObj.get("oauthMigrationStatus"));
      }
      if ((jsonObj.get("requestId") != null && !jsonObj.get("requestId").isJsonNull()) && !jsonObj.get("requestId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestId").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdatedProviderAccount.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdatedProviderAccount' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdatedProviderAccount> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdatedProviderAccount.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdatedProviderAccount>() {
           @Override
           public void write(JsonWriter out, UpdatedProviderAccount value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdatedProviderAccount read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdatedProviderAccount given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdatedProviderAccount
   * @throws IOException if the JSON string is invalid with respect to UpdatedProviderAccount
   */
  public static UpdatedProviderAccount fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdatedProviderAccount.class);
  }

  /**
   * Convert an instance of UpdatedProviderAccount to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

