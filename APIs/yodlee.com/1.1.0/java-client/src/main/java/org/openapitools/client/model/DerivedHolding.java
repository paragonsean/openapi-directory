/*
 * Yodlee Core APIs
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee supports the Java SDK and it is available <a href=\"https://developer.yodlee.com/java-sdk-overview \">here</a>. You can generate a client SDK for Python, Java, JavaScript, PHP or other languages according to your development needs. For more details about the APIs, refer to <a href=\"https://developer.yodlee.com/docs/api/1.1/Overview\">Yodlee API v1.1 - Overview</a>.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developer@yodlee.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AssetClassification;
import org.openapitools.client.model.Money;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * DerivedHolding
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.041142-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DerivedHolding {
  public static final String SERIALIZED_NAME_ACCOUNT_ID = "accountId";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  private Long accountId;

  public static final String SERIALIZED_NAME_ACCRUED_INCOME = "accruedIncome";
  @SerializedName(SERIALIZED_NAME_ACCRUED_INCOME)
  private Money accruedIncome;

  public static final String SERIALIZED_NAME_ACCRUED_INTEREST = "accruedInterest";
  @SerializedName(SERIALIZED_NAME_ACCRUED_INTEREST)
  private Money accruedInterest;

  public static final String SERIALIZED_NAME_ASSET_CLASSIFICATION = "assetClassification";
  @SerializedName(SERIALIZED_NAME_ASSET_CLASSIFICATION)
  private AssetClassification assetClassification;

  public static final String SERIALIZED_NAME_CONTRACT_QUANTITY = "contractQuantity";
  @SerializedName(SERIALIZED_NAME_CONTRACT_QUANTITY)
  private Double contractQuantity;

  public static final String SERIALIZED_NAME_COST_BASIS = "costBasis";
  @SerializedName(SERIALIZED_NAME_COST_BASIS)
  private Money costBasis;

  public static final String SERIALIZED_NAME_COUPON_RATE = "couponRate";
  @SerializedName(SERIALIZED_NAME_COUPON_RATE)
  private Double couponRate;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private String createdDate;

  public static final String SERIALIZED_NAME_CUSIP_NUMBER = "cusipNumber";
  @SerializedName(SERIALIZED_NAME_CUSIP_NUMBER)
  private String cusipNumber;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_ENRICHED_DESCRIPTION = "enrichedDescription";
  @SerializedName(SERIALIZED_NAME_ENRICHED_DESCRIPTION)
  private String enrichedDescription;

  public static final String SERIALIZED_NAME_EXERCISED_QUANTITY = "exercisedQuantity";
  @SerializedName(SERIALIZED_NAME_EXERCISED_QUANTITY)
  private Double exercisedQuantity;

  public static final String SERIALIZED_NAME_EXPIRATION_DATE = "expirationDate";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_DATE)
  private String expirationDate;

  public static final String SERIALIZED_NAME_GRANT_DATE = "grantDate";
  @SerializedName(SERIALIZED_NAME_GRANT_DATE)
  private String grantDate;

  /**
   * Type of holding&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   */
  @JsonAdapter(HoldingTypeEnum.Adapter.class)
  public enum HoldingTypeEnum {
    STOCK("stock"),
    
    MUTUAL_FUND("mutualFund"),
    
    BOND("bond"),
    
    CD("CD"),
    
    OPTION("option"),
    
    MONEY_MARKET_FUND("moneyMarketFund"),
    
    OTHER("other"),
    
    REMIC("remic"),
    
    FUTURE("future"),
    
    COMMODITY("commodity"),
    
    CURRENCY("currency"),
    
    UNIT_INVESTMENT_TRUST("unitInvestmentTrust"),
    
    EMPLOYEE_STOCK_OPTION("employeeStockOption"),
    
    INSURANCE_ANNUITY("insuranceAnnuity"),
    
    UNKNOWN("unknown"),
    
    PREFERRED_STOCK("preferredStock"),
    
    ETF("ETF"),
    
    WARRANTS("warrants"),
    
    ETN("ETN");

    private String value;

    HoldingTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HoldingTypeEnum fromValue(String value) {
      for (HoldingTypeEnum b : HoldingTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<HoldingTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HoldingTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HoldingTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return HoldingTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      HoldingTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_HOLDING_TYPE = "holdingType";
  @SerializedName(SERIALIZED_NAME_HOLDING_TYPE)
  private HoldingTypeEnum holdingType;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_INTEREST_RATE = "interestRate";
  @SerializedName(SERIALIZED_NAME_INTEREST_RATE)
  private Double interestRate;

  public static final String SERIALIZED_NAME_IS_SHORT = "isShort";
  @SerializedName(SERIALIZED_NAME_IS_SHORT)
  private Boolean isShort;

  public static final String SERIALIZED_NAME_ISIN = "isin";
  @SerializedName(SERIALIZED_NAME_ISIN)
  private String isin;

  public static final String SERIALIZED_NAME_LAST_UPDATED = "lastUpdated";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED)
  private String lastUpdated;

  public static final String SERIALIZED_NAME_MATCH_STATUS = "matchStatus";
  @SerializedName(SERIALIZED_NAME_MATCH_STATUS)
  private String matchStatus;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private String maturityDate;

  /**
   * The type of the option position (i.e., put or call).&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The option type field is only applicable to options.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(OptionTypeEnum.Adapter.class)
  public enum OptionTypeEnum {
    PUT("put"),
    
    CALL("call"),
    
    UNKNOWN("unknown"),
    
    OTHER("other");

    private String value;

    OptionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OptionTypeEnum fromValue(String value) {
      for (OptionTypeEnum b : OptionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OptionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OptionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OptionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OptionTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OptionTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OPTION_TYPE = "optionType";
  @SerializedName(SERIALIZED_NAME_OPTION_TYPE)
  private OptionTypeEnum optionType;

  public static final String SERIALIZED_NAME_PRICE = "price";
  @SerializedName(SERIALIZED_NAME_PRICE)
  private Money price;

  public static final String SERIALIZED_NAME_PROVIDER_ACCOUNT_ID = "providerAccountId";
  @SerializedName(SERIALIZED_NAME_PROVIDER_ACCOUNT_ID)
  private Long providerAccountId;

  public static final String SERIALIZED_NAME_QUANTITY = "quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  private Double quantity;

  public static final String SERIALIZED_NAME_SECURITY_STYLE = "securityStyle";
  @SerializedName(SERIALIZED_NAME_SECURITY_STYLE)
  private String securityStyle;

  public static final String SERIALIZED_NAME_SECURITY_TYPE = "securityType";
  @SerializedName(SERIALIZED_NAME_SECURITY_TYPE)
  private String securityType;

  public static final String SERIALIZED_NAME_SEDOL = "sedol";
  @SerializedName(SERIALIZED_NAME_SEDOL)
  private String sedol;

  public static final String SERIALIZED_NAME_SPREAD = "spread";
  @SerializedName(SERIALIZED_NAME_SPREAD)
  private Money spread;

  public static final String SERIALIZED_NAME_STRIKE_PRICE = "strikePrice";
  @SerializedName(SERIALIZED_NAME_STRIKE_PRICE)
  private Money strikePrice;

  public static final String SERIALIZED_NAME_SYMBOL = "symbol";
  @SerializedName(SERIALIZED_NAME_SYMBOL)
  private String symbol;

  public static final String SERIALIZED_NAME_TERM = "term";
  @SerializedName(SERIALIZED_NAME_TERM)
  private String term;

  public static final String SERIALIZED_NAME_UNVESTED_QUANTITY = "unvestedQuantity";
  @SerializedName(SERIALIZED_NAME_UNVESTED_QUANTITY)
  private Double unvestedQuantity;

  public static final String SERIALIZED_NAME_UNVESTED_VALUE = "unvestedValue";
  @SerializedName(SERIALIZED_NAME_UNVESTED_VALUE)
  private Money unvestedValue;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private Money value;

  public static final String SERIALIZED_NAME_VESTED_QUANTITY = "vestedQuantity";
  @SerializedName(SERIALIZED_NAME_VESTED_QUANTITY)
  private Double vestedQuantity;

  public static final String SERIALIZED_NAME_VESTED_SHARES_EXERCISABLE = "vestedSharesExercisable";
  @SerializedName(SERIALIZED_NAME_VESTED_SHARES_EXERCISABLE)
  private Double vestedSharesExercisable;

  public static final String SERIALIZED_NAME_VESTED_VALUE = "vestedValue";
  @SerializedName(SERIALIZED_NAME_VESTED_VALUE)
  private Money vestedValue;

  public static final String SERIALIZED_NAME_VESTING_DATE = "vestingDate";
  @SerializedName(SERIALIZED_NAME_VESTING_DATE)
  private String vestingDate;

  public DerivedHolding() {
  }

  public DerivedHolding(
     Long accountId, 
     Double contractQuantity, 
     Double couponRate, 
     String createdDate, 
     String cusipNumber, 
     String description, 
     String enrichedDescription, 
     Double exercisedQuantity, 
     String expirationDate, 
     String grantDate, 
     HoldingTypeEnum holdingType, 
     Long id, 
     Double interestRate, 
     Boolean isShort, 
     String isin, 
     String lastUpdated, 
     String matchStatus, 
     String maturityDate, 
     OptionTypeEnum optionType, 
     Long providerAccountId, 
     Double quantity, 
     String securityStyle, 
     String securityType, 
     String sedol, 
     String symbol, 
     String term, 
     Double unvestedQuantity, 
     Double vestedQuantity, 
     Double vestedSharesExercisable, 
     String vestingDate
  ) {
    this();
    this.accountId = accountId;
    this.contractQuantity = contractQuantity;
    this.couponRate = couponRate;
    this.createdDate = createdDate;
    this.cusipNumber = cusipNumber;
    this.description = description;
    this.enrichedDescription = enrichedDescription;
    this.exercisedQuantity = exercisedQuantity;
    this.expirationDate = expirationDate;
    this.grantDate = grantDate;
    this.holdingType = holdingType;
    this.id = id;
    this.interestRate = interestRate;
    this.isShort = isShort;
    this.isin = isin;
    this.lastUpdated = lastUpdated;
    this.matchStatus = matchStatus;
    this.maturityDate = maturityDate;
    this.optionType = optionType;
    this.providerAccountId = providerAccountId;
    this.quantity = quantity;
    this.securityStyle = securityStyle;
    this.securityType = securityType;
    this.sedol = sedol;
    this.symbol = symbol;
    this.term = term;
    this.unvestedQuantity = unvestedQuantity;
    this.vestedQuantity = vestedQuantity;
    this.vestedSharesExercisable = vestedSharesExercisable;
    this.vestingDate = vestingDate;
  }

  /**
   * Unique identifier of the account to which the security is linked.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return accountId
   */
  @javax.annotation.Nullable
  public Long getAccountId() {
    return accountId;
  }



  public DerivedHolding accruedIncome(Money accruedIncome) {
    this.accruedIncome = accruedIncome;
    return this;
  }

  /**
   * Get accruedIncome
   * @return accruedIncome
   */
  @javax.annotation.Nullable
  public Money getAccruedIncome() {
    return accruedIncome;
  }

  public void setAccruedIncome(Money accruedIncome) {
    this.accruedIncome = accruedIncome;
  }


  public DerivedHolding accruedInterest(Money accruedInterest) {
    this.accruedInterest = accruedInterest;
    return this;
  }

  /**
   * Get accruedInterest
   * @return accruedInterest
   */
  @javax.annotation.Nullable
  public Money getAccruedInterest() {
    return accruedInterest;
  }

  public void setAccruedInterest(Money accruedInterest) {
    this.accruedInterest = accruedInterest;
  }


  public DerivedHolding assetClassification(AssetClassification assetClassification) {
    this.assetClassification = assetClassification;
    return this;
  }

  /**
   * Get assetClassification
   * @return assetClassification
   */
  @javax.annotation.Nullable
  public AssetClassification getAssetClassification() {
    return assetClassification;
  }

  public void setAssetClassification(AssetClassification assetClassification) {
    this.assetClassification = assetClassification;
  }


  /**
   * The quantity of tradeable units in a contract.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The contract quantity field is only applicable to commodity and currency.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return contractQuantity
   */
  @javax.annotation.Nullable
  public Double getContractQuantity() {
    return contractQuantity;
  }



  public DerivedHolding costBasis(Money costBasis) {
    this.costBasis = costBasis;
    return this;
  }

  /**
   * Get costBasis
   * @return costBasis
   */
  @javax.annotation.Nullable
  public Money getCostBasis() {
    return costBasis;
  }

  public void setCostBasis(Money costBasis) {
    this.costBasis = costBasis;
  }


  /**
   * The stated interest rate for a bond.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return couponRate
   */
  @javax.annotation.Nullable
  public Double getCouponRate() {
    return couponRate;
  }



  /**
   * The date on which the holding is created in the Yodlee system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return createdDate
   */
  @javax.annotation.Nullable
  public String getCreatedDate() {
    return createdDate;
  }



  /**
   * The CUSIP (Committee on Uniform Securities Identification Procedures) identifies most the financial instruments in the United States and Canada.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return cusipNumber
   */
  @javax.annotation.Nullable
  public String getCusipNumber() {
    return cusipNumber;
  }



  /**
   * The description (name) for the holding (E.g., Cisco Systems)&lt;br&gt;For insurance container, the field is only applicable for insurance annuity and variable life insurance types. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }



  /**
   * The enrichedDescription is the security description of the normalized holding&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return enrichedDescription
   */
  @javax.annotation.Nullable
  public String getEnrichedDescription() {
    return enrichedDescription;
  }



  /**
   * The quantity of the employee stock options that are already exercised or bought by the employee.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: Once the employee stock options is exercised, they are either converted to cash value or equity positions depending on the FI. The exercised quantity field is only applicable to employee stock options.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return exercisedQuantity
   */
  @javax.annotation.Nullable
  public Double getExercisedQuantity() {
    return exercisedQuantity;
  }



  /**
   * The date on which an option, right or warrant expires.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The expiration date field is only applicable to options and employee stock options.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return expirationDate
   */
  @javax.annotation.Nullable
  public String getExpirationDate() {
    return expirationDate;
  }



  /**
   * The date on which equity awards like ESOP, RSU, etc., are issued or granted.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The grant date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return grantDate
   */
  @javax.annotation.Nullable
  public String getGrantDate() {
    return grantDate;
  }



  /**
   * Type of holding&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return holdingType
   */
  @javax.annotation.Nullable
  public HoldingTypeEnum getHoldingType() {
    return holdingType;
  }



  /**
   * Unique identifier for the security added in the system. This is the primary key of the holding resource.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return id
   */
  @javax.annotation.Nullable
  public Long getId() {
    return id;
  }



  /**
   * The interest rate on a CD.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The interest rate field is only applicable to CD.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return interestRate
   */
  @javax.annotation.Nullable
  public Double getInterestRate() {
    return interestRate;
  }



  /**
   * Indicates that the holding is a short trading.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return isShort
   */
  @javax.annotation.Nullable
  public Boolean getIsShort() {
    return isShort;
  }



  /**
   * The ISIN (International Securities Identification Number) is used worldwide to identify specific securities. It is equivalent to CUSIP for international markets.&lt;br&gt;&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The ISIN field is only applicable to the trade related transactions&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return isin
   */
  @javax.annotation.Nullable
  public String getIsin() {
    return isin;
  }



  /**
   * The date when the information was last updated in the system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return lastUpdated
   */
  @javax.annotation.Nullable
  public String getLastUpdated() {
    return lastUpdated;
  }



  /**
   * Indicates the security match status id of the investment option identified during security normalization.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return matchStatus
   */
  @javax.annotation.Nullable
  public String getMatchStatus() {
    return matchStatus;
  }



  /**
   * The stated maturity date of a bond or CD.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return maturityDate
   */
  @javax.annotation.Nullable
  public String getMaturityDate() {
    return maturityDate;
  }



  /**
   * The type of the option position (i.e., put or call).&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The option type field is only applicable to options.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return optionType
   */
  @javax.annotation.Nullable
  public OptionTypeEnum getOptionType() {
    return optionType;
  }



  public DerivedHolding price(Money price) {
    this.price = price;
    return this;
  }

  /**
   * Get price
   * @return price
   */
  @javax.annotation.Nullable
  public Money getPrice() {
    return price;
  }

  public void setPrice(Money price) {
    this.price = price;
  }


  /**
   * Unique identifier for the user&#39;s association with the provider.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return providerAccountId
   */
  @javax.annotation.Nullable
  public Long getProviderAccountId() {
    return providerAccountId;
  }



  /**
   * The quantity held for the holding.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: Only for bonds the quantity field indicates the normalized quantity and not the quantity aggregated from the site. The quantity field is only applicable to restricted stock units/awards, performance units, currency, and commodity.&lt;br&gt;For insurance container, the field is only applicable for insurance annuity and variable life insurance types.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return quantity
   */
  @javax.annotation.Nullable
  public Double getQuantity() {
    return quantity;
  }



  /**
   * Indicates the security style of holding identified through the security service.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return securityStyle
   */
  @javax.annotation.Nullable
  public String getSecurityStyle() {
    return securityStyle;
  }



  /**
   * Indicates the security type of holding identified through the security service.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment, insurance&lt;br&gt;
   * @return securityType
   */
  @javax.annotation.Nullable
  public String getSecurityType() {
    return securityType;
  }



  /**
   * The SEDOL (Stock Exchange Daily Official List) is a set of security identifiers used in the United Kingdom and Ireland for clearing purposes.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The SEDOL field is only applicable to the trade related transactions&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return sedol
   */
  @javax.annotation.Nullable
  public String getSedol() {
    return sedol;
  }



  public DerivedHolding spread(Money spread) {
    this.spread = spread;
    return this;
  }

  /**
   * Get spread
   * @return spread
   */
  @javax.annotation.Nullable
  public Money getSpread() {
    return spread;
  }

  public void setSpread(Money spread) {
    this.spread = spread;
  }


  public DerivedHolding strikePrice(Money strikePrice) {
    this.strikePrice = strikePrice;
    return this;
  }

  /**
   * Get strikePrice
   * @return strikePrice
   */
  @javax.annotation.Nullable
  public Money getStrikePrice() {
    return strikePrice;
  }

  public void setStrikePrice(Money strikePrice) {
    this.strikePrice = strikePrice;
  }


  /**
   * The symbol of the security.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return symbol
   */
  @javax.annotation.Nullable
  public String getSymbol() {
    return symbol;
  }



  /**
   * The fixed duration for which the bond or CD is issued.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The term field is only applicable to CD.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return term
   */
  @javax.annotation.Nullable
  public String getTerm() {
    return term;
  }



  /**
   * Indicates the number of unvested quantity or units.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The unvested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return unvestedQuantity
   */
  @javax.annotation.Nullable
  public Double getUnvestedQuantity() {
    return unvestedQuantity;
  }



  public DerivedHolding unvestedValue(Money unvestedValue) {
    this.unvestedValue = unvestedValue;
    return this;
  }

  /**
   * Get unvestedValue
   * @return unvestedValue
   */
  @javax.annotation.Nullable
  public Money getUnvestedValue() {
    return unvestedValue;
  }

  public void setUnvestedValue(Money unvestedValue) {
    this.unvestedValue = unvestedValue;
  }


  public DerivedHolding value(Money value) {
    this.value = value;
    return this;
  }

  /**
   * Get value
   * @return value
   */
  @javax.annotation.Nullable
  public Money getValue() {
    return value;
  }

  public void setValue(Money value) {
    this.value = value;
  }


  /**
   * The quantity of units or shares that are already vested on a vest date.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The vested quantity field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return vestedQuantity
   */
  @javax.annotation.Nullable
  public Double getVestedQuantity() {
    return vestedQuantity;
  }



  /**
   * The number of vested shares that can be exercised by the employee. It is usually equal to the vested quantity.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The vested shares exercisable field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return vestedSharesExercisable
   */
  @javax.annotation.Nullable
  public Double getVestedSharesExercisable() {
    return vestedSharesExercisable;
  }



  public DerivedHolding vestedValue(Money vestedValue) {
    this.vestedValue = vestedValue;
    return this;
  }

  /**
   * Get vestedValue
   * @return vestedValue
   */
  @javax.annotation.Nullable
  public Money getVestedValue() {
    return vestedValue;
  }

  public void setVestedValue(Money vestedValue) {
    this.vestedValue = vestedValue;
  }


  /**
   * The date on which a RSU, RSA, or an employee stock options become vested.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The vesting date field is only applicable to employee stock options, restricted stock units/awards, performance units, etc.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return vestingDate
   */
  @javax.annotation.Nullable
  public String getVestingDate() {
    return vestingDate;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DerivedHolding derivedHolding = (DerivedHolding) o;
    return Objects.equals(this.accountId, derivedHolding.accountId) &&
        Objects.equals(this.accruedIncome, derivedHolding.accruedIncome) &&
        Objects.equals(this.accruedInterest, derivedHolding.accruedInterest) &&
        Objects.equals(this.assetClassification, derivedHolding.assetClassification) &&
        Objects.equals(this.contractQuantity, derivedHolding.contractQuantity) &&
        Objects.equals(this.costBasis, derivedHolding.costBasis) &&
        Objects.equals(this.couponRate, derivedHolding.couponRate) &&
        Objects.equals(this.createdDate, derivedHolding.createdDate) &&
        Objects.equals(this.cusipNumber, derivedHolding.cusipNumber) &&
        Objects.equals(this.description, derivedHolding.description) &&
        Objects.equals(this.enrichedDescription, derivedHolding.enrichedDescription) &&
        Objects.equals(this.exercisedQuantity, derivedHolding.exercisedQuantity) &&
        Objects.equals(this.expirationDate, derivedHolding.expirationDate) &&
        Objects.equals(this.grantDate, derivedHolding.grantDate) &&
        Objects.equals(this.holdingType, derivedHolding.holdingType) &&
        Objects.equals(this.id, derivedHolding.id) &&
        Objects.equals(this.interestRate, derivedHolding.interestRate) &&
        Objects.equals(this.isShort, derivedHolding.isShort) &&
        Objects.equals(this.isin, derivedHolding.isin) &&
        Objects.equals(this.lastUpdated, derivedHolding.lastUpdated) &&
        Objects.equals(this.matchStatus, derivedHolding.matchStatus) &&
        Objects.equals(this.maturityDate, derivedHolding.maturityDate) &&
        Objects.equals(this.optionType, derivedHolding.optionType) &&
        Objects.equals(this.price, derivedHolding.price) &&
        Objects.equals(this.providerAccountId, derivedHolding.providerAccountId) &&
        Objects.equals(this.quantity, derivedHolding.quantity) &&
        Objects.equals(this.securityStyle, derivedHolding.securityStyle) &&
        Objects.equals(this.securityType, derivedHolding.securityType) &&
        Objects.equals(this.sedol, derivedHolding.sedol) &&
        Objects.equals(this.spread, derivedHolding.spread) &&
        Objects.equals(this.strikePrice, derivedHolding.strikePrice) &&
        Objects.equals(this.symbol, derivedHolding.symbol) &&
        Objects.equals(this.term, derivedHolding.term) &&
        Objects.equals(this.unvestedQuantity, derivedHolding.unvestedQuantity) &&
        Objects.equals(this.unvestedValue, derivedHolding.unvestedValue) &&
        Objects.equals(this.value, derivedHolding.value) &&
        Objects.equals(this.vestedQuantity, derivedHolding.vestedQuantity) &&
        Objects.equals(this.vestedSharesExercisable, derivedHolding.vestedSharesExercisable) &&
        Objects.equals(this.vestedValue, derivedHolding.vestedValue) &&
        Objects.equals(this.vestingDate, derivedHolding.vestingDate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountId, accruedIncome, accruedInterest, assetClassification, contractQuantity, costBasis, couponRate, createdDate, cusipNumber, description, enrichedDescription, exercisedQuantity, expirationDate, grantDate, holdingType, id, interestRate, isShort, isin, lastUpdated, matchStatus, maturityDate, optionType, price, providerAccountId, quantity, securityStyle, securityType, sedol, spread, strikePrice, symbol, term, unvestedQuantity, unvestedValue, value, vestedQuantity, vestedSharesExercisable, vestedValue, vestingDate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DerivedHolding {\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    accruedIncome: ").append(toIndentedString(accruedIncome)).append("\n");
    sb.append("    accruedInterest: ").append(toIndentedString(accruedInterest)).append("\n");
    sb.append("    assetClassification: ").append(toIndentedString(assetClassification)).append("\n");
    sb.append("    contractQuantity: ").append(toIndentedString(contractQuantity)).append("\n");
    sb.append("    costBasis: ").append(toIndentedString(costBasis)).append("\n");
    sb.append("    couponRate: ").append(toIndentedString(couponRate)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    cusipNumber: ").append(toIndentedString(cusipNumber)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    enrichedDescription: ").append(toIndentedString(enrichedDescription)).append("\n");
    sb.append("    exercisedQuantity: ").append(toIndentedString(exercisedQuantity)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("    grantDate: ").append(toIndentedString(grantDate)).append("\n");
    sb.append("    holdingType: ").append(toIndentedString(holdingType)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    interestRate: ").append(toIndentedString(interestRate)).append("\n");
    sb.append("    isShort: ").append(toIndentedString(isShort)).append("\n");
    sb.append("    isin: ").append(toIndentedString(isin)).append("\n");
    sb.append("    lastUpdated: ").append(toIndentedString(lastUpdated)).append("\n");
    sb.append("    matchStatus: ").append(toIndentedString(matchStatus)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    optionType: ").append(toIndentedString(optionType)).append("\n");
    sb.append("    price: ").append(toIndentedString(price)).append("\n");
    sb.append("    providerAccountId: ").append(toIndentedString(providerAccountId)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    securityStyle: ").append(toIndentedString(securityStyle)).append("\n");
    sb.append("    securityType: ").append(toIndentedString(securityType)).append("\n");
    sb.append("    sedol: ").append(toIndentedString(sedol)).append("\n");
    sb.append("    spread: ").append(toIndentedString(spread)).append("\n");
    sb.append("    strikePrice: ").append(toIndentedString(strikePrice)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    term: ").append(toIndentedString(term)).append("\n");
    sb.append("    unvestedQuantity: ").append(toIndentedString(unvestedQuantity)).append("\n");
    sb.append("    unvestedValue: ").append(toIndentedString(unvestedValue)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    vestedQuantity: ").append(toIndentedString(vestedQuantity)).append("\n");
    sb.append("    vestedSharesExercisable: ").append(toIndentedString(vestedSharesExercisable)).append("\n");
    sb.append("    vestedValue: ").append(toIndentedString(vestedValue)).append("\n");
    sb.append("    vestingDate: ").append(toIndentedString(vestingDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountId");
    openapiFields.add("accruedIncome");
    openapiFields.add("accruedInterest");
    openapiFields.add("assetClassification");
    openapiFields.add("contractQuantity");
    openapiFields.add("costBasis");
    openapiFields.add("couponRate");
    openapiFields.add("createdDate");
    openapiFields.add("cusipNumber");
    openapiFields.add("description");
    openapiFields.add("enrichedDescription");
    openapiFields.add("exercisedQuantity");
    openapiFields.add("expirationDate");
    openapiFields.add("grantDate");
    openapiFields.add("holdingType");
    openapiFields.add("id");
    openapiFields.add("interestRate");
    openapiFields.add("isShort");
    openapiFields.add("isin");
    openapiFields.add("lastUpdated");
    openapiFields.add("matchStatus");
    openapiFields.add("maturityDate");
    openapiFields.add("optionType");
    openapiFields.add("price");
    openapiFields.add("providerAccountId");
    openapiFields.add("quantity");
    openapiFields.add("securityStyle");
    openapiFields.add("securityType");
    openapiFields.add("sedol");
    openapiFields.add("spread");
    openapiFields.add("strikePrice");
    openapiFields.add("symbol");
    openapiFields.add("term");
    openapiFields.add("unvestedQuantity");
    openapiFields.add("unvestedValue");
    openapiFields.add("value");
    openapiFields.add("vestedQuantity");
    openapiFields.add("vestedSharesExercisable");
    openapiFields.add("vestedValue");
    openapiFields.add("vestingDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DerivedHolding
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DerivedHolding.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DerivedHolding is not found in the empty JSON string", DerivedHolding.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DerivedHolding.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DerivedHolding` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `accruedIncome`
      if (jsonObj.get("accruedIncome") != null && !jsonObj.get("accruedIncome").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("accruedIncome"));
      }
      // validate the optional field `accruedInterest`
      if (jsonObj.get("accruedInterest") != null && !jsonObj.get("accruedInterest").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("accruedInterest"));
      }
      // validate the optional field `assetClassification`
      if (jsonObj.get("assetClassification") != null && !jsonObj.get("assetClassification").isJsonNull()) {
        AssetClassification.validateJsonElement(jsonObj.get("assetClassification"));
      }
      // validate the optional field `costBasis`
      if (jsonObj.get("costBasis") != null && !jsonObj.get("costBasis").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("costBasis"));
      }
      if ((jsonObj.get("createdDate") != null && !jsonObj.get("createdDate").isJsonNull()) && !jsonObj.get("createdDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdDate").toString()));
      }
      if ((jsonObj.get("cusipNumber") != null && !jsonObj.get("cusipNumber").isJsonNull()) && !jsonObj.get("cusipNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cusipNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cusipNumber").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("enrichedDescription") != null && !jsonObj.get("enrichedDescription").isJsonNull()) && !jsonObj.get("enrichedDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `enrichedDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("enrichedDescription").toString()));
      }
      if ((jsonObj.get("expirationDate") != null && !jsonObj.get("expirationDate").isJsonNull()) && !jsonObj.get("expirationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expirationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expirationDate").toString()));
      }
      if ((jsonObj.get("grantDate") != null && !jsonObj.get("grantDate").isJsonNull()) && !jsonObj.get("grantDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `grantDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("grantDate").toString()));
      }
      if ((jsonObj.get("holdingType") != null && !jsonObj.get("holdingType").isJsonNull()) && !jsonObj.get("holdingType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `holdingType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("holdingType").toString()));
      }
      // validate the optional field `holdingType`
      if (jsonObj.get("holdingType") != null && !jsonObj.get("holdingType").isJsonNull()) {
        HoldingTypeEnum.validateJsonElement(jsonObj.get("holdingType"));
      }
      if ((jsonObj.get("isin") != null && !jsonObj.get("isin").isJsonNull()) && !jsonObj.get("isin").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `isin` to be a primitive type in the JSON string but got `%s`", jsonObj.get("isin").toString()));
      }
      if ((jsonObj.get("lastUpdated") != null && !jsonObj.get("lastUpdated").isJsonNull()) && !jsonObj.get("lastUpdated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdated").toString()));
      }
      if ((jsonObj.get("matchStatus") != null && !jsonObj.get("matchStatus").isJsonNull()) && !jsonObj.get("matchStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchStatus").toString()));
      }
      if ((jsonObj.get("maturityDate") != null && !jsonObj.get("maturityDate").isJsonNull()) && !jsonObj.get("maturityDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maturityDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maturityDate").toString()));
      }
      if ((jsonObj.get("optionType") != null && !jsonObj.get("optionType").isJsonNull()) && !jsonObj.get("optionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `optionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("optionType").toString()));
      }
      // validate the optional field `optionType`
      if (jsonObj.get("optionType") != null && !jsonObj.get("optionType").isJsonNull()) {
        OptionTypeEnum.validateJsonElement(jsonObj.get("optionType"));
      }
      // validate the optional field `price`
      if (jsonObj.get("price") != null && !jsonObj.get("price").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("price"));
      }
      if ((jsonObj.get("securityStyle") != null && !jsonObj.get("securityStyle").isJsonNull()) && !jsonObj.get("securityStyle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `securityStyle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("securityStyle").toString()));
      }
      if ((jsonObj.get("securityType") != null && !jsonObj.get("securityType").isJsonNull()) && !jsonObj.get("securityType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `securityType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("securityType").toString()));
      }
      if ((jsonObj.get("sedol") != null && !jsonObj.get("sedol").isJsonNull()) && !jsonObj.get("sedol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sedol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sedol").toString()));
      }
      // validate the optional field `spread`
      if (jsonObj.get("spread") != null && !jsonObj.get("spread").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("spread"));
      }
      // validate the optional field `strikePrice`
      if (jsonObj.get("strikePrice") != null && !jsonObj.get("strikePrice").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("strikePrice"));
      }
      if ((jsonObj.get("symbol") != null && !jsonObj.get("symbol").isJsonNull()) && !jsonObj.get("symbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `symbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("symbol").toString()));
      }
      if ((jsonObj.get("term") != null && !jsonObj.get("term").isJsonNull()) && !jsonObj.get("term").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `term` to be a primitive type in the JSON string but got `%s`", jsonObj.get("term").toString()));
      }
      // validate the optional field `unvestedValue`
      if (jsonObj.get("unvestedValue") != null && !jsonObj.get("unvestedValue").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("unvestedValue"));
      }
      // validate the optional field `value`
      if (jsonObj.get("value") != null && !jsonObj.get("value").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("value"));
      }
      // validate the optional field `vestedValue`
      if (jsonObj.get("vestedValue") != null && !jsonObj.get("vestedValue").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("vestedValue"));
      }
      if ((jsonObj.get("vestingDate") != null && !jsonObj.get("vestingDate").isJsonNull()) && !jsonObj.get("vestingDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vestingDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vestingDate").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DerivedHolding.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DerivedHolding' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DerivedHolding> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DerivedHolding.class));

       return (TypeAdapter<T>) new TypeAdapter<DerivedHolding>() {
           @Override
           public void write(JsonWriter out, DerivedHolding value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DerivedHolding read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DerivedHolding given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DerivedHolding
   * @throws IOException if the JSON string is invalid with respect to DerivedHolding
   */
  public static DerivedHolding fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DerivedHolding.class);
  }

  /**
   * Convert an instance of DerivedHolding to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

