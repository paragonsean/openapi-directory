/*
 * Yodlee Core APIs
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee supports the Java SDK and it is available <a href=\"https://developer.yodlee.com/java-sdk-overview \">here</a>. You can generate a client SDK for Python, Java, JavaScript, PHP or other languages according to your development needs. For more details about the APIs, refer to <a href=\"https://developer.yodlee.com/docs/api/1.1/Overview\">Yodlee API v1.1 - Overview</a>.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developer@yodlee.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Description;
import org.openapitools.client.model.Merchant;
import org.openapitools.client.model.Money;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * DataExtractsTransaction
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:58.041142-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DataExtractsTransaction {
  /**
   * The account&#39;s container.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(CONTAINEREnum.Adapter.class)
  public enum CONTAINEREnum {
    BANK("bank"),
    
    CREDIT_CARD("creditCard"),
    
    INVESTMENT("investment"),
    
    INSURANCE("insurance"),
    
    LOAN("loan"),
    
    REWARD("reward"),
    
    REAL_ESTATE("realEstate"),
    
    OTHER_ASSETS("otherAssets"),
    
    OTHER_LIABILITIES("otherLiabilities");

    private String value;

    CONTAINEREnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CONTAINEREnum fromValue(String value) {
      for (CONTAINEREnum b : CONTAINEREnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CONTAINEREnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CONTAINEREnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CONTAINEREnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CONTAINEREnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CONTAINEREnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_C_O_N_T_A_I_N_E_R = "CONTAINER";
  @SerializedName(SERIALIZED_NAME_C_O_N_T_A_I_N_E_R)
  private CONTAINEREnum CONTAINER;

  public static final String SERIALIZED_NAME_ACCOUNT_ID = "accountId";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  private Long accountId;

  public static final String SERIALIZED_NAME_AMOUNT = "amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private Money amount;

  /**
   * Indicates if the transaction appears as a debit or a credit transaction in the account. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(BaseTypeEnum.Adapter.class)
  public enum BaseTypeEnum {
    CREDIT("CREDIT"),
    
    DEBIT("DEBIT");

    private String value;

    BaseTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BaseTypeEnum fromValue(String value) {
      for (BaseTypeEnum b : BaseTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BaseTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BaseTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BaseTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BaseTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BaseTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BASE_TYPE = "baseType";
  @SerializedName(SERIALIZED_NAME_BASE_TYPE)
  private BaseTypeEnum baseType;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private String category;

  public static final String SERIALIZED_NAME_CATEGORY_ID = "categoryId";
  @SerializedName(SERIALIZED_NAME_CATEGORY_ID)
  private Long categoryId;

  /**
   * Indicates the source of the category, i.e., categories derived by the system or assigned/provided by the consumer. This is the source field of the transaction category resource. The supported values are provided by the GET transactions/categories.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(CategorySourceEnum.Adapter.class)
  public enum CategorySourceEnum {
    SYSTEM("SYSTEM"),
    
    USER("USER");

    private String value;

    CategorySourceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CategorySourceEnum fromValue(String value) {
      for (CategorySourceEnum b : CategorySourceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CategorySourceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CategorySourceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CategorySourceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CategorySourceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CategorySourceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CATEGORY_SOURCE = "categorySource";
  @SerializedName(SERIALIZED_NAME_CATEGORY_SOURCE)
  private CategorySourceEnum categorySource;

  /**
   * The categoryType of the category assigned to the transaction. This is the type field of the transaction category resource. The supported values are provided by the GET transactions/categories.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   */
  @JsonAdapter(CategoryTypeEnum.Adapter.class)
  public enum CategoryTypeEnum {
    TRANSFER("TRANSFER"),
    
    DEFERRED_COMPENSATION("DEFERRED_COMPENSATION"),
    
    UNCATEGORIZE("UNCATEGORIZE"),
    
    INCOME("INCOME"),
    
    EXPENSE("EXPENSE");

    private String value;

    CategoryTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CategoryTypeEnum fromValue(String value) {
      for (CategoryTypeEnum b : CategoryTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CategoryTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CategoryTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CategoryTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CategoryTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CategoryTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CATEGORY_TYPE = "categoryType";
  @SerializedName(SERIALIZED_NAME_CATEGORY_TYPE)
  private CategoryTypeEnum categoryType;

  public static final String SERIALIZED_NAME_CHECK_NUMBER = "checkNumber";
  @SerializedName(SERIALIZED_NAME_CHECK_NUMBER)
  private String checkNumber;

  public static final String SERIALIZED_NAME_COMMISSION = "commission";
  @SerializedName(SERIALIZED_NAME_COMMISSION)
  private Money commission;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private String createdDate;

  public static final String SERIALIZED_NAME_CUSIP_NUMBER = "cusipNumber";
  @SerializedName(SERIALIZED_NAME_CUSIP_NUMBER)
  private String cusipNumber;

  public static final String SERIALIZED_NAME_DATE = "date";
  @SerializedName(SERIALIZED_NAME_DATE)
  private String date;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private Description description;

  public static final String SERIALIZED_NAME_DETAIL_CATEGORY_ID = "detailCategoryId";
  @SerializedName(SERIALIZED_NAME_DETAIL_CATEGORY_ID)
  private Long detailCategoryId;

  public static final String SERIALIZED_NAME_HIGH_LEVEL_CATEGORY_ID = "highLevelCategoryId";
  @SerializedName(SERIALIZED_NAME_HIGH_LEVEL_CATEGORY_ID)
  private Long highLevelCategoryId;

  public static final String SERIALIZED_NAME_HOLDING_DESCRIPTION = "holdingDescription";
  @SerializedName(SERIALIZED_NAME_HOLDING_DESCRIPTION)
  private String holdingDescription;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_INTEREST = "interest";
  @SerializedName(SERIALIZED_NAME_INTEREST)
  private Money interest;

  public static final String SERIALIZED_NAME_IS_DELETED = "isDeleted";
  @SerializedName(SERIALIZED_NAME_IS_DELETED)
  private Boolean isDeleted;

  public static final String SERIALIZED_NAME_IS_MANUAL = "isManual";
  @SerializedName(SERIALIZED_NAME_IS_MANUAL)
  private Boolean isManual;

  public static final String SERIALIZED_NAME_ISIN = "isin";
  @SerializedName(SERIALIZED_NAME_ISIN)
  private String isin;

  public static final String SERIALIZED_NAME_LAST_UPDATED = "lastUpdated";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED)
  private String lastUpdated;

  public static final String SERIALIZED_NAME_MEMO = "memo";
  @SerializedName(SERIALIZED_NAME_MEMO)
  private String memo;

  public static final String SERIALIZED_NAME_MERCHANT = "merchant";
  @SerializedName(SERIALIZED_NAME_MERCHANT)
  private Merchant merchant;

  public static final String SERIALIZED_NAME_PARENT_CATEGORY_ID = "parentCategoryId";
  @SerializedName(SERIALIZED_NAME_PARENT_CATEGORY_ID)
  private Long parentCategoryId;

  public static final String SERIALIZED_NAME_POST_DATE = "postDate";
  @SerializedName(SERIALIZED_NAME_POST_DATE)
  private String postDate;

  public static final String SERIALIZED_NAME_PRICE = "price";
  @SerializedName(SERIALIZED_NAME_PRICE)
  private Money price;

  public static final String SERIALIZED_NAME_PRINCIPAL = "principal";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL)
  private Money principal;

  public static final String SERIALIZED_NAME_QUANTITY = "quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  private Double quantity;

  public static final String SERIALIZED_NAME_RUNNING_BALANCE = "runningBalance";
  @SerializedName(SERIALIZED_NAME_RUNNING_BALANCE)
  private Money runningBalance;

  public static final String SERIALIZED_NAME_SEDOL = "sedol";
  @SerializedName(SERIALIZED_NAME_SEDOL)
  private String sedol;

  public static final String SERIALIZED_NAME_SETTLE_DATE = "settleDate";
  @SerializedName(SERIALIZED_NAME_SETTLE_DATE)
  private String settleDate;

  public static final String SERIALIZED_NAME_SOURCE_ID = "sourceId";
  @SerializedName(SERIALIZED_NAME_SOURCE_ID)
  private String sourceId;

  /**
   * The source through which the transaction is added to the Yodlee system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loann&lt;br&gt;&lt;b&gt;Applicable Values:&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(SourceTypeEnum.Adapter.class)
  public enum SourceTypeEnum {
    AGGREGATED("AGGREGATED"),
    
    MANUAL("MANUAL");

    private String value;

    SourceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SourceTypeEnum fromValue(String value) {
      for (SourceTypeEnum b : SourceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SourceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SourceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SourceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SourceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SourceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SOURCE_TYPE = "sourceType";
  @SerializedName(SERIALIZED_NAME_SOURCE_TYPE)
  private SourceTypeEnum sourceType;

  /**
   * The status of the transaction: pending or posted.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: Most FI sites only display posted transactions. If the FI site displays transaction status, same will be aggregated.  &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    POSTED("POSTED"),
    
    PENDING("PENDING"),
    
    SCHEDULED("SCHEDULED"),
    
    FAILED("FAILED"),
    
    CLEARED("CLEARED");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  /**
   * The transaction subtype field provides a detailed transaction type. For example, purchase is a transaction type and the transaction subtype field indicates if the purchase was made using a debit or credit card.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The transaction subtype field is available only in the United States, Canada, United Kingdom, and India.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   */
  @JsonAdapter(SubTypeEnum.Adapter.class)
  public enum SubTypeEnum {
    AUTH_HOLD("AUTH_HOLD"),
    
    AUTH_REQUEST("AUTH_REQUEST"),
    
    OVERDRAFT_CHARGE("OVERDRAFT_CHARGE"),
    
    CREDIT_ADJUSTMENT("CREDIT_ADJUSTMENT"),
    
    PIN_DEBIT("PIN_DEBIT"),
    
    BANK_DIRECT_DEPOSIT("BANK_DIRECT_DEPOSIT"),
    
    DIVIDEND_DEPOSIT("DIVIDEND_DEPOSIT"),
    
    INTEREST_SAVINGS("INTEREST_SAVINGS"),
    
    INTEREST_ADJUSTMENT("INTEREST_ADJUSTMENT"),
    
    ONLINE_PURCHASE("ONLINE_PURCHASE"),
    
    PURCHASED_WITH_CHECK("PURCHASED_WITH_CHECK"),
    
    RECURRING_BILLING("RECURRING_BILLING"),
    
    TAX_PAYMENT("TAX_PAYMENT"),
    
    PAYMENT_BY_CHECK("PAYMENT_BY_CHECK"),
    
    PAYMENT_PLAN("PAYMENT_PLAN"),
    
    FEE_REFUND("FEE_REFUND"),
    
    WIRE_TRANSFER_CHARGE("WIRE_TRANSFER_CHARGE"),
    
    ACCOUNT_TO_ACCOUNT_TRANSFER("ACCOUNT_TO_ACCOUNT_TRANSFER"),
    
    BANK_TO_BANK_TRANSACTION("BANK_TO_BANK_TRANSACTION"),
    
    BANK_TO_NON_BANK_ACCOUNT_TRANSFER("BANK_TO_NON_BANK_ACCOUNT_TRANSFER"),
    
    CASH_WITHDRAWAL_AT_FI("CASH_WITHDRAWAL_AT_FI"),
    
    ATM_CASH_WITHDRAWAL("ATM_CASH_WITHDRAWAL"),
    
    AUTH_PROCESSING("AUTH_PROCESSING"),
    
    AUTH_RELEASE("AUTH_RELEASE"),
    
    PRE_AUTH("PRE_AUTH"),
    
    AUTH_COMPLETE("AUTH_COMPLETE"),
    
    AUTH_VOID("AUTH_VOID"),
    
    BALANCE_ENQUIRY("BALANCE_ENQUIRY"),
    
    ACCOUNT_VERIFICATION("ACCOUNT_VERIFICATION"),
    
    PRE_AUTH_COMPLETION("PRE_AUTH_COMPLETION"),
    
    SERVICE_CHARGE("SERVICE_CHARGE"),
    
    SERVICE_CHARGE_FEE_REFUND("SERVICE_CHARGE_FEE_REFUND"),
    
    RETURNED_CHECK_CHARGE("RETURNED_CHECK_CHARGE"),
    
    RETURNED_CHECK_REIMBURSEMENT("RETURNED_CHECK_REIMBURSEMENT"),
    
    CASH_ADVANCE("CASH_ADVANCE"),
    
    BILL_PAY_CHARGE("BILL_PAY_CHARGE"),
    
    CHECK_IMAGE_SERVICE_CHARGE("CHECK_IMAGE_SERVICE_CHARGE"),
    
    OVERDRAFT_PROTECTION_CHARGE("OVERDRAFT_PROTECTION_CHARGE"),
    
    STOP_PAYMENT_CHARGE("STOP_PAYMENT_CHARGE"),
    
    CHECKS_ORDERING_CHARGE("CHECKS_ORDERING_CHARGE"),
    
    MONTHLY_MAINTENANCE_CHARGE("MONTHLY_MAINTENANCE_CHARGE"),
    
    DEBIT_CARD_FEE("DEBIT_CARD_FEE"),
    
    CONVENIENCE_FEE("CONVENIENCE_FEE"),
    
    PERSONAL_LOAN_CREDIT("PERSONAL_LOAN_CREDIT"),
    
    CREDIT_CARD_CREDIT("CREDIT_CARD_CREDIT"),
    
    AUTO_LOAN("AUTO_LOAN"),
    
    HOME_LOAN_MORTGAGE("HOME_LOAN_MORTGAGE"),
    
    SHORT_TERM_CREDIT("SHORT_TERM_CREDIT"),
    
    SIGNATURE_DEBIT("SIGNATURE_DEBIT"),
    
    CONTACT_LESS_DEBIT("CONTACT_LESS_DEBIT"),
    
    DEFERRED_DEPOSIT("DEFERRED_DEPOSIT"),
    
    DEFERRED_BILL_PAY("DEFERRED_BILL_PAY"),
    
    INSTALLMENT_PAYMENT("INSTALLMENT_PAYMENT"),
    
    RECURRING_SUBSCRIPTION_PAYMENT("RECURRING_SUBSCRIPTION_PAYMENT"),
    
    HOLD_CHECK_PAYMENT("HOLD_CHECK_PAYMENT"),
    
    CAPITAL_GAINS_DISTIBUTION("CAPITAL_GAINS_DISTIBUTION"),
    
    CG_LONG_TERM_DEPOSIT("CG_LONG_TERM_DEPOSIT"),
    
    OPEN_SALE_DEPOSIT("OPEN_SALE_DEPOSIT"),
    
    INTEREST__CHECK("INTEREST__CHECK"),
    
    PURCHASE_VOID("PURCHASE_VOID"),
    
    PURCHASE_WITH_CREDIT_CARD("PURCHASE_WITH_CREDIT_CARD"),
    
    PURCHASE_WITH_DEBIT_CARD("PURCHASE_WITH_DEBIT_CARD"),
    
    CHARGE_A_REPEAT_CUSTOMER("CHARGE_A_REPEAT_CUSTOMER"),
    
    DOWN_PAYMENT_OR_ANNUITY_PAYMENT_OR_DIRECT_PAYMENT("DOWN_PAYMENT_OR_ANNUITY_PAYMENT_OR_DIRECT_PAYMENT"),
    
    FEE_PAYMENT("FEE_PAYMENT"),
    
    FINANCE_CHARGE_REFUND("FINANCE_CHARGE_REFUND"),
    
    TRANSACTION_VOID("TRANSACTION_VOID"),
    
    FEE_VOID("FEE_VOID"),
    
    DEBIT_CARD_WITHDRAWAL_AT_STORE("DEBIT_CARD_WITHDRAWAL_AT_STORE"),
    
    ELECTRONIC_PAYMENT("ELECTRONIC_PAYMENT"),
    
    ACH_DEBIT("ACH_DEBIT"),
    
    ATM_TELLER_DEPOSIT("ATM_TELLER_DEPOSIT"),
    
    POS_DEBIT("POS_DEBIT"),
    
    BANK_ADJUSTMENT("BANK_ADJUSTMENT"),
    
    CHARGES_FEES("CHARGES_FEES"),
    
    INTEREST("INTEREST"),
    
    DEPOSITS_CREDITS("DEPOSITS_CREDITS"),
    
    PAYMENT("PAYMENT"),
    
    PURCHASE("PURCHASE"),
    
    REFUND("REFUND"),
    
    TRANSFER("TRANSFER"),
    
    WITHDRAWAL("WITHDRAWAL"),
    
    OTHER_DEPOSITS("OTHER_DEPOSITS"),
    
    OTHER_WITHDRAWALS("OTHER_WITHDRAWALS"),
    
    ADJUSTMENT("ADJUSTMENT"),
    
    FINANCE_CHARGE("FINANCE_CHARGE"),
    
    OTHER_CHARGES_FEES("OTHER_CHARGES_FEES"),
    
    ANNUAL_FEE("ANNUAL_FEE"),
    
    DEPOSIT("DEPOSIT"),
    
    DIRECT_DEPOSIT_SALARY("DIRECT_DEPOSIT_SALARY"),
    
    INVESTMENT_INCOME_CASH("INVESTMENT_INCOME_CASH"),
    
    SSA("SSA"),
    
    REWARDS("REWARDS"),
    
    CHECK_DEPOSIT("CHECK_DEPOSIT"),
    
    MOBILE_REMOTE_DEPOSIT("MOBILE_REMOTE_DEPOSIT"),
    
    TELLER_DEPOSIT("TELLER_DEPOSIT"),
    
    TAX_REFUND("TAX_REFUND"),
    
    CREDIT_CARD_PAYMENT("CREDIT_CARD_PAYMENT"),
    
    INSURANCE_PAYMENT("INSURANCE_PAYMENT"),
    
    UTILITIES_PAYMENT("UTILITIES_PAYMENT"),
    
    CHILD_SUPPORT("CHILD_SUPPORT"),
    
    LOAN("LOAN"),
    
    PERSONAL_LOAN("PERSONAL_LOAN"),
    
    STUDENT_LOAN("STUDENT_LOAN"),
    
    SALES_TAX("SALES_TAX"),
    
    REIMBURSEMENT("REIMBURSEMENT"),
    
    BALANCE_TRANSFER("BALANCE_TRANSFER"),
    
    WIRE_TRANSFER("WIRE_TRANSFER"),
    
    OVERDRAFT_PROTECTION("OVERDRAFT_PROTECTION"),
    
    DEBIT("DEBIT"),
    
    CREDIT("CREDIT"),
    
    NSF_FEES("NSF_FEES");

    private String value;

    SubTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SubTypeEnum fromValue(String value) {
      for (SubTypeEnum b : SubTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SubTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SubTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SubTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SubTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SubTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SUB_TYPE = "subType";
  @SerializedName(SERIALIZED_NAME_SUB_TYPE)
  private SubTypeEnum subType;

  public static final String SERIALIZED_NAME_SYMBOL = "symbol";
  @SerializedName(SERIALIZED_NAME_SYMBOL)
  private String symbol;

  public static final String SERIALIZED_NAME_TRANSACTION_DATE = "transactionDate";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_DATE)
  private String transactionDate;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_VALOREN = "valoren";
  @SerializedName(SERIALIZED_NAME_VALOREN)
  private String valoren;

  public DataExtractsTransaction() {
  }

  public DataExtractsTransaction(
     CONTAINEREnum CONTAINER, 
     Long accountId, 
     BaseTypeEnum baseType, 
     String category, 
     Long categoryId, 
     CategorySourceEnum categorySource, 
     CategoryTypeEnum categoryType, 
     String checkNumber, 
     String createdDate, 
     String cusipNumber, 
     String date, 
     Long detailCategoryId, 
     Long highLevelCategoryId, 
     String holdingDescription, 
     Long id, 
     Boolean isDeleted, 
     Boolean isManual, 
     String isin, 
     String lastUpdated, 
     String memo, 
     Long parentCategoryId, 
     String postDate, 
     Double quantity, 
     String sedol, 
     String settleDate, 
     String sourceId, 
     SourceTypeEnum sourceType, 
     StatusEnum status, 
     SubTypeEnum subType, 
     String symbol, 
     String transactionDate, 
     String type, 
     String valoren
  ) {
    this();
    this.CONTAINER = CONTAINER;
    this.accountId = accountId;
    this.baseType = baseType;
    this.category = category;
    this.categoryId = categoryId;
    this.categorySource = categorySource;
    this.categoryType = categoryType;
    this.checkNumber = checkNumber;
    this.createdDate = createdDate;
    this.cusipNumber = cusipNumber;
    this.date = date;
    this.detailCategoryId = detailCategoryId;
    this.highLevelCategoryId = highLevelCategoryId;
    this.holdingDescription = holdingDescription;
    this.id = id;
    this.isDeleted = isDeleted;
    this.isManual = isManual;
    this.isin = isin;
    this.lastUpdated = lastUpdated;
    this.memo = memo;
    this.parentCategoryId = parentCategoryId;
    this.postDate = postDate;
    this.quantity = quantity;
    this.sedol = sedol;
    this.settleDate = settleDate;
    this.sourceId = sourceId;
    this.sourceType = sourceType;
    this.status = status;
    this.subType = subType;
    this.symbol = symbol;
    this.transactionDate = transactionDate;
    this.type = type;
    this.valoren = valoren;
  }

  /**
   * The account&#39;s container.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return CONTAINER
   */
  @javax.annotation.Nullable
  public CONTAINEREnum getCONTAINER() {
    return CONTAINER;
  }



  /**
   * The account from which the transaction was made. This is basically the primary key of the account resource. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return accountId
   */
  @javax.annotation.Nullable
  public Long getAccountId() {
    return accountId;
  }



  public DataExtractsTransaction amount(Money amount) {
    this.amount = amount;
    return this;
  }

  /**
   * Get amount
   * @return amount
   */
  @javax.annotation.Nullable
  public Money getAmount() {
    return amount;
  }

  public void setAmount(Money amount) {
    this.amount = amount;
  }


  /**
   * Indicates if the transaction appears as a debit or a credit transaction in the account. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return baseType
   */
  @javax.annotation.Nullable
  public BaseTypeEnum getBaseType() {
    return baseType;
  }



  /**
   * The name of the category assigned to the transaction. This is the category field of the transaction category resource. The supported values are provided by the GET transactions/categories.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return category
   */
  @javax.annotation.Nullable
  public String getCategory() {
    return category;
  }



  /**
   * The id of the category assigned to the transaction. This is the id field of the transaction category resource. The supported values are provided by the GET transactions/categories.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return categoryId
   */
  @javax.annotation.Nullable
  public Long getCategoryId() {
    return categoryId;
  }



  /**
   * Indicates the source of the category, i.e., categories derived by the system or assigned/provided by the consumer. This is the source field of the transaction category resource. The supported values are provided by the GET transactions/categories.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return categorySource
   */
  @javax.annotation.Nullable
  public CategorySourceEnum getCategorySource() {
    return categorySource;
  }



  /**
   * The categoryType of the category assigned to the transaction. This is the type field of the transaction category resource. The supported values are provided by the GET transactions/categories.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return categoryType
   */
  @javax.annotation.Nullable
  public CategoryTypeEnum getCategoryType() {
    return categoryType;
  }



  /**
   * The checkNumber of the transaction.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank&lt;br&gt;
   * @return checkNumber
   */
  @javax.annotation.Nullable
  public String getCheckNumber() {
    return checkNumber;
  }



  public DataExtractsTransaction commission(Money commission) {
    this.commission = commission;
    return this;
  }

  /**
   * Get commission
   * @return commission
   */
  @javax.annotation.Nullable
  public Money getCommission() {
    return commission;
  }

  public void setCommission(Money commission) {
    this.commission = commission;
  }


  /**
   * Get createdDate
   * @return createdDate
   */
  @javax.annotation.Nullable
  public String getCreatedDate() {
    return createdDate;
  }



  /**
   * The CUSIP (Committee on Uniform Securities Identification Procedures) identifies the financial instruments in the United States and Canada.&lt;br&gt;&lt;b&gt;&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;&lt;/b&gt;: The CUSIP number field applies only to trade related transactions.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return cusipNumber
   */
  @javax.annotation.Nullable
  public String getCusipNumber() {
    return cusipNumber;
  }



  /**
   * The value provided will be either postDate or transactionDate. postDate takes higher priority than transactionDate, except for the investment container as only transactionDate is available. The availability of postDate or transactionDate depends on the provider site.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return date
   */
  @javax.annotation.Nullable
  public String getDate() {
    return date;
  }



  public DataExtractsTransaction description(Description description) {
    this.description = description;
    return this;
  }

  /**
   * Get description
   * @return description
   */
  @javax.annotation.Nullable
  public Description getDescription() {
    return description;
  }

  public void setDescription(Description description) {
    this.description = description;
  }


  /**
   * The id of the detail category that is assigned to the transaction. The supported values are provided by GET transactions/categories.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard&lt;br&gt;
   * @return detailCategoryId
   */
  @javax.annotation.Nullable
  public Long getDetailCategoryId() {
    return detailCategoryId;
  }



  /**
   * The high level category assigned to the transaction. The supported values are provided by the GET transactions/categories. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return highLevelCategoryId
   */
  @javax.annotation.Nullable
  public Long getHighLevelCategoryId() {
    return highLevelCategoryId;
  }



  /**
   * For transactions involving securities, this captures the securities description.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return holdingDescription
   */
  @javax.annotation.Nullable
  public String getHoldingDescription() {
    return holdingDescription;
  }



  /**
   * An unique identifier for the transaction. The combination of the id and account container are unique in the system. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return id
   */
  @javax.annotation.Nullable
  public Long getId() {
    return id;
  }



  public DataExtractsTransaction interest(Money interest) {
    this.interest = interest;
    return this;
  }

  /**
   * Get interest
   * @return interest
   */
  @javax.annotation.Nullable
  public Money getInterest() {
    return interest;
  }

  public void setInterest(Money interest) {
    this.interest = interest;
  }


  /**
   * Indicates if the transaction is marked as deleted.&lt;b&gt;Applicable containers&lt;/b&gt;: All Containers&lt;br&gt;&lt;b&gt;Aggregated / Manual&lt;/b&gt;: Both &lt;br&gt;&lt;b&gt;Endpoints&lt;/b&gt;:&lt;br&gt;&lt;ul&gt;&lt;li&gt;GET dataExtracts/userData&lt;/li&gt;&lt;/ul&gt;
   * @return isDeleted
   */
  @javax.annotation.Nullable
  public Boolean getIsDeleted() {
    return isDeleted;
  }



  /**
   * Indicates if the transaction is aggregated from the FI site or the consumer has manually created the transaction using the application or an API. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return isManual
   */
  @javax.annotation.Nullable
  public Boolean getIsManual() {
    return isManual;
  }



  /**
   * International Securities Identification Number (ISIN) standard is used worldwide to identify specific securities.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return isin
   */
  @javax.annotation.Nullable
  public String getIsin() {
    return isin;
  }



  /**
   * Get lastUpdated
   * @return lastUpdated
   */
  @javax.annotation.Nullable
  public String getLastUpdated() {
    return lastUpdated;
  }



  /**
   * Additional notes provided by the user for a particular  transaction through application or API services. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return memo
   */
  @javax.annotation.Nullable
  public String getMemo() {
    return memo;
  }



  public DataExtractsTransaction merchant(Merchant merchant) {
    this.merchant = merchant;
    return this;
  }

  /**
   * Get merchant
   * @return merchant
   */
  @javax.annotation.Nullable
  public Merchant getMerchant() {
    return merchant;
  }

  public void setMerchant(Merchant merchant) {
    this.merchant = merchant;
  }


  /**
   * The parentCategoryId of the category assigned to the transaction.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: This field will be provided in the response if the transaction is assigned to a user-created category. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return parentCategoryId
   */
  @javax.annotation.Nullable
  public Long getParentCategoryId() {
    return parentCategoryId;
  }



  /**
   * The date on which the transaction is posted to the account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,insurance,loan&lt;br&gt;
   * @return postDate
   */
  @javax.annotation.Nullable
  public String getPostDate() {
    return postDate;
  }



  public DataExtractsTransaction price(Money price) {
    this.price = price;
    return this;
  }

  /**
   * Get price
   * @return price
   */
  @javax.annotation.Nullable
  public Money getPrice() {
    return price;
  }

  public void setPrice(Money price) {
    this.price = price;
  }


  public DataExtractsTransaction principal(Money principal) {
    this.principal = principal;
    return this;
  }

  /**
   * Get principal
   * @return principal
   */
  @javax.annotation.Nullable
  public Money getPrincipal() {
    return principal;
  }

  public void setPrincipal(Money principal) {
    this.principal = principal;
  }


  /**
   * The quantity associated with the transaction.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The quantity field applies only to trade-related transactions.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return quantity
   */
  @javax.annotation.Nullable
  public Double getQuantity() {
    return quantity;
  }



  public DataExtractsTransaction runningBalance(Money runningBalance) {
    this.runningBalance = runningBalance;
    return this;
  }

  /**
   * Get runningBalance
   * @return runningBalance
   */
  @javax.annotation.Nullable
  public Money getRunningBalance() {
    return runningBalance;
  }

  public void setRunningBalance(Money runningBalance) {
    this.runningBalance = runningBalance;
  }


  /**
   * SEDOL stands for Stock Exchange Daily Official List, a list of security identifiers used in the United Kingdom and Ireland for clearing purposes.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return sedol
   */
  @javax.annotation.Nullable
  public String getSedol() {
    return sedol;
  }



  /**
   * It is the date on which the transaction is finalized, that is, the date the ownership of the security is transferred to the buyer. The settlement date is usually few days after the transaction date.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return settleDate
   */
  @javax.annotation.Nullable
  public String getSettleDate() {
    return settleDate;
  }



  /**
   * A unique ID that the provider site has assigned to the transaction. The source ID is only available for the pre-populated accounts.&lt;br&gt;Pre-populated accounts are the accounts that the FI customers shares with Yodlee, so that the user does not have to add or aggregate those accounts.
   * @return sourceId
   */
  @javax.annotation.Nullable
  public String getSourceId() {
    return sourceId;
  }



  /**
   * The source through which the transaction is added to the Yodlee system.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loann&lt;br&gt;&lt;b&gt;Applicable Values:&lt;/b&gt;&lt;br&gt;
   * @return sourceType
   */
  @javax.annotation.Nullable
  public SourceTypeEnum getSourceType() {
    return sourceType;
  }



  /**
   * The status of the transaction: pending or posted.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: Most FI sites only display posted transactions. If the FI site displays transaction status, same will be aggregated.  &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;&lt;b&gt;Applicable Values&lt;/b&gt;&lt;br&gt;
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }



  /**
   * The transaction subtype field provides a detailed transaction type. For example, purchase is a transaction type and the transaction subtype field indicates if the purchase was made using a debit or credit card.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The transaction subtype field is available only in the United States, Canada, United Kingdom, and India.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return subType
   */
  @javax.annotation.Nullable
  public SubTypeEnum getSubType() {
    return subType;
  }



  /**
   * The symbol of the security being traded.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The settle date field applies only to trade-related transactions. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return symbol
   */
  @javax.annotation.Nullable
  public String getSymbol() {
    return symbol;
  }



  /**
   * The date the transaction happens in the account. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment,insurance,loan&lt;br&gt;
   * @return transactionDate
   */
  @javax.annotation.Nullable
  public String getTransactionDate() {
    return transactionDate;
  }



  /**
   * The nature of the transaction, i.e., deposit, refund, payment, etc.&lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: The transaction type field is available only for the United States, Canada, United Kingdom, and India based provider sites. &lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: bank,creditCard,investment&lt;br&gt;
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }



  /**
   * It is an identification number that is assigned to financial instruments such as stocks and bonds trading in Switzerland.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable containers&lt;/b&gt;: investment&lt;br&gt;
   * @return valoren
   */
  @javax.annotation.Nullable
  public String getValoren() {
    return valoren;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataExtractsTransaction dataExtractsTransaction = (DataExtractsTransaction) o;
    return Objects.equals(this.CONTAINER, dataExtractsTransaction.CONTAINER) &&
        Objects.equals(this.accountId, dataExtractsTransaction.accountId) &&
        Objects.equals(this.amount, dataExtractsTransaction.amount) &&
        Objects.equals(this.baseType, dataExtractsTransaction.baseType) &&
        Objects.equals(this.category, dataExtractsTransaction.category) &&
        Objects.equals(this.categoryId, dataExtractsTransaction.categoryId) &&
        Objects.equals(this.categorySource, dataExtractsTransaction.categorySource) &&
        Objects.equals(this.categoryType, dataExtractsTransaction.categoryType) &&
        Objects.equals(this.checkNumber, dataExtractsTransaction.checkNumber) &&
        Objects.equals(this.commission, dataExtractsTransaction.commission) &&
        Objects.equals(this.createdDate, dataExtractsTransaction.createdDate) &&
        Objects.equals(this.cusipNumber, dataExtractsTransaction.cusipNumber) &&
        Objects.equals(this.date, dataExtractsTransaction.date) &&
        Objects.equals(this.description, dataExtractsTransaction.description) &&
        Objects.equals(this.detailCategoryId, dataExtractsTransaction.detailCategoryId) &&
        Objects.equals(this.highLevelCategoryId, dataExtractsTransaction.highLevelCategoryId) &&
        Objects.equals(this.holdingDescription, dataExtractsTransaction.holdingDescription) &&
        Objects.equals(this.id, dataExtractsTransaction.id) &&
        Objects.equals(this.interest, dataExtractsTransaction.interest) &&
        Objects.equals(this.isDeleted, dataExtractsTransaction.isDeleted) &&
        Objects.equals(this.isManual, dataExtractsTransaction.isManual) &&
        Objects.equals(this.isin, dataExtractsTransaction.isin) &&
        Objects.equals(this.lastUpdated, dataExtractsTransaction.lastUpdated) &&
        Objects.equals(this.memo, dataExtractsTransaction.memo) &&
        Objects.equals(this.merchant, dataExtractsTransaction.merchant) &&
        Objects.equals(this.parentCategoryId, dataExtractsTransaction.parentCategoryId) &&
        Objects.equals(this.postDate, dataExtractsTransaction.postDate) &&
        Objects.equals(this.price, dataExtractsTransaction.price) &&
        Objects.equals(this.principal, dataExtractsTransaction.principal) &&
        Objects.equals(this.quantity, dataExtractsTransaction.quantity) &&
        Objects.equals(this.runningBalance, dataExtractsTransaction.runningBalance) &&
        Objects.equals(this.sedol, dataExtractsTransaction.sedol) &&
        Objects.equals(this.settleDate, dataExtractsTransaction.settleDate) &&
        Objects.equals(this.sourceId, dataExtractsTransaction.sourceId) &&
        Objects.equals(this.sourceType, dataExtractsTransaction.sourceType) &&
        Objects.equals(this.status, dataExtractsTransaction.status) &&
        Objects.equals(this.subType, dataExtractsTransaction.subType) &&
        Objects.equals(this.symbol, dataExtractsTransaction.symbol) &&
        Objects.equals(this.transactionDate, dataExtractsTransaction.transactionDate) &&
        Objects.equals(this.type, dataExtractsTransaction.type) &&
        Objects.equals(this.valoren, dataExtractsTransaction.valoren);
  }

  @Override
  public int hashCode() {
    return Objects.hash(CONTAINER, accountId, amount, baseType, category, categoryId, categorySource, categoryType, checkNumber, commission, createdDate, cusipNumber, date, description, detailCategoryId, highLevelCategoryId, holdingDescription, id, interest, isDeleted, isManual, isin, lastUpdated, memo, merchant, parentCategoryId, postDate, price, principal, quantity, runningBalance, sedol, settleDate, sourceId, sourceType, status, subType, symbol, transactionDate, type, valoren);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataExtractsTransaction {\n");
    sb.append("    CONTAINER: ").append(toIndentedString(CONTAINER)).append("\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    baseType: ").append(toIndentedString(baseType)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    categoryId: ").append(toIndentedString(categoryId)).append("\n");
    sb.append("    categorySource: ").append(toIndentedString(categorySource)).append("\n");
    sb.append("    categoryType: ").append(toIndentedString(categoryType)).append("\n");
    sb.append("    checkNumber: ").append(toIndentedString(checkNumber)).append("\n");
    sb.append("    commission: ").append(toIndentedString(commission)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    cusipNumber: ").append(toIndentedString(cusipNumber)).append("\n");
    sb.append("    date: ").append(toIndentedString(date)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    detailCategoryId: ").append(toIndentedString(detailCategoryId)).append("\n");
    sb.append("    highLevelCategoryId: ").append(toIndentedString(highLevelCategoryId)).append("\n");
    sb.append("    holdingDescription: ").append(toIndentedString(holdingDescription)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    interest: ").append(toIndentedString(interest)).append("\n");
    sb.append("    isDeleted: ").append(toIndentedString(isDeleted)).append("\n");
    sb.append("    isManual: ").append(toIndentedString(isManual)).append("\n");
    sb.append("    isin: ").append(toIndentedString(isin)).append("\n");
    sb.append("    lastUpdated: ").append(toIndentedString(lastUpdated)).append("\n");
    sb.append("    memo: ").append(toIndentedString(memo)).append("\n");
    sb.append("    merchant: ").append(toIndentedString(merchant)).append("\n");
    sb.append("    parentCategoryId: ").append(toIndentedString(parentCategoryId)).append("\n");
    sb.append("    postDate: ").append(toIndentedString(postDate)).append("\n");
    sb.append("    price: ").append(toIndentedString(price)).append("\n");
    sb.append("    principal: ").append(toIndentedString(principal)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    runningBalance: ").append(toIndentedString(runningBalance)).append("\n");
    sb.append("    sedol: ").append(toIndentedString(sedol)).append("\n");
    sb.append("    settleDate: ").append(toIndentedString(settleDate)).append("\n");
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    sourceType: ").append(toIndentedString(sourceType)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    subType: ").append(toIndentedString(subType)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    transactionDate: ").append(toIndentedString(transactionDate)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    valoren: ").append(toIndentedString(valoren)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("CONTAINER");
    openapiFields.add("accountId");
    openapiFields.add("amount");
    openapiFields.add("baseType");
    openapiFields.add("category");
    openapiFields.add("categoryId");
    openapiFields.add("categorySource");
    openapiFields.add("categoryType");
    openapiFields.add("checkNumber");
    openapiFields.add("commission");
    openapiFields.add("createdDate");
    openapiFields.add("cusipNumber");
    openapiFields.add("date");
    openapiFields.add("description");
    openapiFields.add("detailCategoryId");
    openapiFields.add("highLevelCategoryId");
    openapiFields.add("holdingDescription");
    openapiFields.add("id");
    openapiFields.add("interest");
    openapiFields.add("isDeleted");
    openapiFields.add("isManual");
    openapiFields.add("isin");
    openapiFields.add("lastUpdated");
    openapiFields.add("memo");
    openapiFields.add("merchant");
    openapiFields.add("parentCategoryId");
    openapiFields.add("postDate");
    openapiFields.add("price");
    openapiFields.add("principal");
    openapiFields.add("quantity");
    openapiFields.add("runningBalance");
    openapiFields.add("sedol");
    openapiFields.add("settleDate");
    openapiFields.add("sourceId");
    openapiFields.add("sourceType");
    openapiFields.add("status");
    openapiFields.add("subType");
    openapiFields.add("symbol");
    openapiFields.add("transactionDate");
    openapiFields.add("type");
    openapiFields.add("valoren");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DataExtractsTransaction
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DataExtractsTransaction.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataExtractsTransaction is not found in the empty JSON string", DataExtractsTransaction.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DataExtractsTransaction.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DataExtractsTransaction` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("CONTAINER") != null && !jsonObj.get("CONTAINER").isJsonNull()) && !jsonObj.get("CONTAINER").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CONTAINER` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CONTAINER").toString()));
      }
      // validate the optional field `CONTAINER`
      if (jsonObj.get("CONTAINER") != null && !jsonObj.get("CONTAINER").isJsonNull()) {
        CONTAINEREnum.validateJsonElement(jsonObj.get("CONTAINER"));
      }
      // validate the optional field `amount`
      if (jsonObj.get("amount") != null && !jsonObj.get("amount").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("amount"));
      }
      if ((jsonObj.get("baseType") != null && !jsonObj.get("baseType").isJsonNull()) && !jsonObj.get("baseType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseType").toString()));
      }
      // validate the optional field `baseType`
      if (jsonObj.get("baseType") != null && !jsonObj.get("baseType").isJsonNull()) {
        BaseTypeEnum.validateJsonElement(jsonObj.get("baseType"));
      }
      if ((jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull()) && !jsonObj.get("category").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be a primitive type in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
      if ((jsonObj.get("categorySource") != null && !jsonObj.get("categorySource").isJsonNull()) && !jsonObj.get("categorySource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `categorySource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("categorySource").toString()));
      }
      // validate the optional field `categorySource`
      if (jsonObj.get("categorySource") != null && !jsonObj.get("categorySource").isJsonNull()) {
        CategorySourceEnum.validateJsonElement(jsonObj.get("categorySource"));
      }
      if ((jsonObj.get("categoryType") != null && !jsonObj.get("categoryType").isJsonNull()) && !jsonObj.get("categoryType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `categoryType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("categoryType").toString()));
      }
      // validate the optional field `categoryType`
      if (jsonObj.get("categoryType") != null && !jsonObj.get("categoryType").isJsonNull()) {
        CategoryTypeEnum.validateJsonElement(jsonObj.get("categoryType"));
      }
      if ((jsonObj.get("checkNumber") != null && !jsonObj.get("checkNumber").isJsonNull()) && !jsonObj.get("checkNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkNumber").toString()));
      }
      // validate the optional field `commission`
      if (jsonObj.get("commission") != null && !jsonObj.get("commission").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("commission"));
      }
      if ((jsonObj.get("createdDate") != null && !jsonObj.get("createdDate").isJsonNull()) && !jsonObj.get("createdDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdDate").toString()));
      }
      if ((jsonObj.get("cusipNumber") != null && !jsonObj.get("cusipNumber").isJsonNull()) && !jsonObj.get("cusipNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cusipNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cusipNumber").toString()));
      }
      if ((jsonObj.get("date") != null && !jsonObj.get("date").isJsonNull()) && !jsonObj.get("date").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `date` to be a primitive type in the JSON string but got `%s`", jsonObj.get("date").toString()));
      }
      // validate the optional field `description`
      if (jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) {
        Description.validateJsonElement(jsonObj.get("description"));
      }
      if ((jsonObj.get("holdingDescription") != null && !jsonObj.get("holdingDescription").isJsonNull()) && !jsonObj.get("holdingDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `holdingDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("holdingDescription").toString()));
      }
      // validate the optional field `interest`
      if (jsonObj.get("interest") != null && !jsonObj.get("interest").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("interest"));
      }
      if ((jsonObj.get("isin") != null && !jsonObj.get("isin").isJsonNull()) && !jsonObj.get("isin").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `isin` to be a primitive type in the JSON string but got `%s`", jsonObj.get("isin").toString()));
      }
      if ((jsonObj.get("lastUpdated") != null && !jsonObj.get("lastUpdated").isJsonNull()) && !jsonObj.get("lastUpdated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdated").toString()));
      }
      if ((jsonObj.get("memo") != null && !jsonObj.get("memo").isJsonNull()) && !jsonObj.get("memo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memo").toString()));
      }
      // validate the optional field `merchant`
      if (jsonObj.get("merchant") != null && !jsonObj.get("merchant").isJsonNull()) {
        Merchant.validateJsonElement(jsonObj.get("merchant"));
      }
      if ((jsonObj.get("postDate") != null && !jsonObj.get("postDate").isJsonNull()) && !jsonObj.get("postDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postDate").toString()));
      }
      // validate the optional field `price`
      if (jsonObj.get("price") != null && !jsonObj.get("price").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("price"));
      }
      // validate the optional field `principal`
      if (jsonObj.get("principal") != null && !jsonObj.get("principal").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("principal"));
      }
      // validate the optional field `runningBalance`
      if (jsonObj.get("runningBalance") != null && !jsonObj.get("runningBalance").isJsonNull()) {
        Money.validateJsonElement(jsonObj.get("runningBalance"));
      }
      if ((jsonObj.get("sedol") != null && !jsonObj.get("sedol").isJsonNull()) && !jsonObj.get("sedol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sedol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sedol").toString()));
      }
      if ((jsonObj.get("settleDate") != null && !jsonObj.get("settleDate").isJsonNull()) && !jsonObj.get("settleDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `settleDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("settleDate").toString()));
      }
      if ((jsonObj.get("sourceId") != null && !jsonObj.get("sourceId").isJsonNull()) && !jsonObj.get("sourceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceId").toString()));
      }
      if ((jsonObj.get("sourceType") != null && !jsonObj.get("sourceType").isJsonNull()) && !jsonObj.get("sourceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceType").toString()));
      }
      // validate the optional field `sourceType`
      if (jsonObj.get("sourceType") != null && !jsonObj.get("sourceType").isJsonNull()) {
        SourceTypeEnum.validateJsonElement(jsonObj.get("sourceType"));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
      if ((jsonObj.get("subType") != null && !jsonObj.get("subType").isJsonNull()) && !jsonObj.get("subType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subType").toString()));
      }
      // validate the optional field `subType`
      if (jsonObj.get("subType") != null && !jsonObj.get("subType").isJsonNull()) {
        SubTypeEnum.validateJsonElement(jsonObj.get("subType"));
      }
      if ((jsonObj.get("symbol") != null && !jsonObj.get("symbol").isJsonNull()) && !jsonObj.get("symbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `symbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("symbol").toString()));
      }
      if ((jsonObj.get("transactionDate") != null && !jsonObj.get("transactionDate").isJsonNull()) && !jsonObj.get("transactionDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionDate").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if ((jsonObj.get("valoren") != null && !jsonObj.get("valoren").isJsonNull()) && !jsonObj.get("valoren").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valoren` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valoren").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataExtractsTransaction.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataExtractsTransaction' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataExtractsTransaction> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataExtractsTransaction.class));

       return (TypeAdapter<T>) new TypeAdapter<DataExtractsTransaction>() {
           @Override
           public void write(JsonWriter out, DataExtractsTransaction value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataExtractsTransaction read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DataExtractsTransaction given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DataExtractsTransaction
   * @throws IOException if the JSON string is invalid with respect to DataExtractsTransaction
   */
  public static DataExtractsTransaction fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataExtractsTransaction.class);
  }

  /**
   * Convert an instance of DataExtractsTransaction to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

