/**
 * Yodlee Core APIs
 * This file describes the Yodlee Platform APIs using the swagger notation. You can use this swagger file to generate client side SDKs to the Yodlee Platform APIs for many different programming languages. Yodlee supports the Java SDK and it is available <a href=\"https://developer.yodlee.com/java-sdk-overview \">here</a>. You can generate a client SDK for Python, Java, JavaScript, PHP or other languages according to your development needs. For more details about the APIs, refer to <a href=\"https://developer.yodlee.com/docs/api/1.1/Overview\">Yodlee API v1.1 - Overview</a>.
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: developer@yodlee.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIField.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIField::OAIField(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIField::OAIField() {
    this->initializeModel();
}

OAIField::~OAIField() {}

void OAIField::initializeModel() {

    m_id_isSet = false;
    m_id_isValid = false;

    m_image_isSet = false;
    m_image_isValid = false;

    m_is_optional_isSet = false;
    m_is_optional_isValid = false;

    m_is_value_provided_isSet = false;
    m_is_value_provided_isValid = false;

    m_max_length_isSet = false;
    m_max_length_isValid = false;

    m_min_length_isSet = false;
    m_min_length_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_option_isSet = false;
    m_option_isValid = false;

    m_prefix_isSet = false;
    m_prefix_isValid = false;

    m_suffix_isSet = false;
    m_suffix_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_value_isSet = false;
    m_value_isValid = false;

    m_value_editable_isSet = false;
    m_value_editable_isValid = false;
}

void OAIField::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIField::fromJsonObject(QJsonObject json) {

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_image_isValid = ::OpenAPI::fromJsonValue(m_image, json[QString("image")]);
    m_image_isSet = !json[QString("image")].isNull() && m_image_isValid;

    m_is_optional_isValid = ::OpenAPI::fromJsonValue(m_is_optional, json[QString("isOptional")]);
    m_is_optional_isSet = !json[QString("isOptional")].isNull() && m_is_optional_isValid;

    m_is_value_provided_isValid = ::OpenAPI::fromJsonValue(m_is_value_provided, json[QString("isValueProvided")]);
    m_is_value_provided_isSet = !json[QString("isValueProvided")].isNull() && m_is_value_provided_isValid;

    m_max_length_isValid = ::OpenAPI::fromJsonValue(m_max_length, json[QString("maxLength")]);
    m_max_length_isSet = !json[QString("maxLength")].isNull() && m_max_length_isValid;

    m_min_length_isValid = ::OpenAPI::fromJsonValue(m_min_length, json[QString("minLength")]);
    m_min_length_isSet = !json[QString("minLength")].isNull() && m_min_length_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_option_isValid = ::OpenAPI::fromJsonValue(m_option, json[QString("option")]);
    m_option_isSet = !json[QString("option")].isNull() && m_option_isValid;

    m_prefix_isValid = ::OpenAPI::fromJsonValue(m_prefix, json[QString("prefix")]);
    m_prefix_isSet = !json[QString("prefix")].isNull() && m_prefix_isValid;

    m_suffix_isValid = ::OpenAPI::fromJsonValue(m_suffix, json[QString("suffix")]);
    m_suffix_isSet = !json[QString("suffix")].isNull() && m_suffix_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_value_isValid = ::OpenAPI::fromJsonValue(m_value, json[QString("value")]);
    m_value_isSet = !json[QString("value")].isNull() && m_value_isValid;

    m_value_editable_isValid = ::OpenAPI::fromJsonValue(m_value_editable, json[QString("valueEditable")]);
    m_value_editable_isSet = !json[QString("valueEditable")].isNull() && m_value_editable_isValid;
}

QString OAIField::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIField::asJsonObject() const {
    QJsonObject obj;
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_image_isSet) {
        obj.insert(QString("image"), ::OpenAPI::toJsonValue(m_image));
    }
    if (m_is_optional_isSet) {
        obj.insert(QString("isOptional"), ::OpenAPI::toJsonValue(m_is_optional));
    }
    if (m_is_value_provided_isSet) {
        obj.insert(QString("isValueProvided"), ::OpenAPI::toJsonValue(m_is_value_provided));
    }
    if (m_max_length_isSet) {
        obj.insert(QString("maxLength"), ::OpenAPI::toJsonValue(m_max_length));
    }
    if (m_min_length_isSet) {
        obj.insert(QString("minLength"), ::OpenAPI::toJsonValue(m_min_length));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_option.size() > 0) {
        obj.insert(QString("option"), ::OpenAPI::toJsonValue(m_option));
    }
    if (m_prefix_isSet) {
        obj.insert(QString("prefix"), ::OpenAPI::toJsonValue(m_prefix));
    }
    if (m_suffix_isSet) {
        obj.insert(QString("suffix"), ::OpenAPI::toJsonValue(m_suffix));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_value_isSet) {
        obj.insert(QString("value"), ::OpenAPI::toJsonValue(m_value));
    }
    if (m_value_editable_isSet) {
        obj.insert(QString("valueEditable"), ::OpenAPI::toJsonValue(m_value_editable));
    }
    return obj;
}

QString OAIField::getId() const {
    return m_id;
}
void OAIField::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIField::is_id_Set() const{
    return m_id_isSet;
}

bool OAIField::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIField::getImage() const {
    return m_image;
}
void OAIField::setImage(const QString &image) {
    m_image = image;
    m_image_isSet = true;
}

bool OAIField::is_image_Set() const{
    return m_image_isSet;
}

bool OAIField::is_image_Valid() const{
    return m_image_isValid;
}

bool OAIField::isIsOptional() const {
    return m_is_optional;
}
void OAIField::setIsOptional(const bool &is_optional) {
    m_is_optional = is_optional;
    m_is_optional_isSet = true;
}

bool OAIField::is_is_optional_Set() const{
    return m_is_optional_isSet;
}

bool OAIField::is_is_optional_Valid() const{
    return m_is_optional_isValid;
}

bool OAIField::isIsValueProvided() const {
    return m_is_value_provided;
}
void OAIField::setIsValueProvided(const bool &is_value_provided) {
    m_is_value_provided = is_value_provided;
    m_is_value_provided_isSet = true;
}

bool OAIField::is_is_value_provided_Set() const{
    return m_is_value_provided_isSet;
}

bool OAIField::is_is_value_provided_Valid() const{
    return m_is_value_provided_isValid;
}

qint64 OAIField::getMaxLength() const {
    return m_max_length;
}
void OAIField::setMaxLength(const qint64 &max_length) {
    m_max_length = max_length;
    m_max_length_isSet = true;
}

bool OAIField::is_max_length_Set() const{
    return m_max_length_isSet;
}

bool OAIField::is_max_length_Valid() const{
    return m_max_length_isValid;
}

qint64 OAIField::getMinLength() const {
    return m_min_length;
}
void OAIField::setMinLength(const qint64 &min_length) {
    m_min_length = min_length;
    m_min_length_isSet = true;
}

bool OAIField::is_min_length_Set() const{
    return m_min_length_isSet;
}

bool OAIField::is_min_length_Valid() const{
    return m_min_length_isValid;
}

QString OAIField::getName() const {
    return m_name;
}
void OAIField::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIField::is_name_Set() const{
    return m_name_isSet;
}

bool OAIField::is_name_Valid() const{
    return m_name_isValid;
}

QList<OAIOption> OAIField::getOption() const {
    return m_option;
}
void OAIField::setOption(const QList<OAIOption> &option) {
    m_option = option;
    m_option_isSet = true;
}

bool OAIField::is_option_Set() const{
    return m_option_isSet;
}

bool OAIField::is_option_Valid() const{
    return m_option_isValid;
}

QString OAIField::getPrefix() const {
    return m_prefix;
}
void OAIField::setPrefix(const QString &prefix) {
    m_prefix = prefix;
    m_prefix_isSet = true;
}

bool OAIField::is_prefix_Set() const{
    return m_prefix_isSet;
}

bool OAIField::is_prefix_Valid() const{
    return m_prefix_isValid;
}

QString OAIField::getSuffix() const {
    return m_suffix;
}
void OAIField::setSuffix(const QString &suffix) {
    m_suffix = suffix;
    m_suffix_isSet = true;
}

bool OAIField::is_suffix_Set() const{
    return m_suffix_isSet;
}

bool OAIField::is_suffix_Valid() const{
    return m_suffix_isValid;
}

QString OAIField::getType() const {
    return m_type;
}
void OAIField::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIField::is_type_Set() const{
    return m_type_isSet;
}

bool OAIField::is_type_Valid() const{
    return m_type_isValid;
}

QString OAIField::getValue() const {
    return m_value;
}
void OAIField::setValue(const QString &value) {
    m_value = value;
    m_value_isSet = true;
}

bool OAIField::is_value_Set() const{
    return m_value_isSet;
}

bool OAIField::is_value_Valid() const{
    return m_value_isValid;
}

QString OAIField::getValueEditable() const {
    return m_value_editable;
}
void OAIField::setValueEditable(const QString &value_editable) {
    m_value_editable = value_editable;
    m_value_editable_isSet = true;
}

bool OAIField::is_value_editable_Set() const{
    return m_value_editable_isSet;
}

bool OAIField::is_value_editable_Valid() const{
    return m_value_editable_isValid;
}

bool OAIField::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_optional_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_value_provided_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_option.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_prefix_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_suffix_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_value_editable_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIField::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
