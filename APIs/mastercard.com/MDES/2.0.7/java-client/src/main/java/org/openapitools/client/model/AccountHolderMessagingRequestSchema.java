/*
 * MDES Customer Service
 * This API provides our Issuer partners with resources to help resolve consumer queries about payment accounts enabled through our digitization platform.
 *
 * The version of the OpenAPI document: 2.0.7
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AuditInfo;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * AccountHolderMessagingRequestSchema
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:09:16.587349-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AccountHolderMessagingRequestSchema {
  public static final String SERIALIZED_NAME_AUDIT_INFO = "AuditInfo";
  @SerializedName(SERIALIZED_NAME_AUDIT_INFO)
  private AuditInfo auditInfo;

  public static final String SERIALIZED_NAME_ISSUER_APPLICATION_MESSAGE_DISPLAY = "IssuerApplicationMessageDisplay";
  @SerializedName(SERIALIZED_NAME_ISSUER_APPLICATION_MESSAGE_DISPLAY)
  private String issuerApplicationMessageDisplay;

  public static final String SERIALIZED_NAME_MESSAGE_EXPIRATION = "MessageExpiration";
  @SerializedName(SERIALIZED_NAME_MESSAGE_EXPIRATION)
  private String messageExpiration;

  public static final String SERIALIZED_NAME_MESSAGE_IDENTIFIER = "MessageIdentifier";
  @SerializedName(SERIALIZED_NAME_MESSAGE_IDENTIFIER)
  private String messageIdentifier;

  public static final String SERIALIZED_NAME_MESSAGE_LANGUAGE_CODE = "MessageLanguageCode";
  @SerializedName(SERIALIZED_NAME_MESSAGE_LANGUAGE_CODE)
  private String messageLanguageCode;

  public static final String SERIALIZED_NAME_MESSAGE_TEXT = "MessageText";
  @SerializedName(SERIALIZED_NAME_MESSAGE_TEXT)
  private String messageText;

  public static final String SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE = "TokenUniqueReference";
  @SerializedName(SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE)
  private String tokenUniqueReference;

  public AccountHolderMessagingRequestSchema() {
  }

  public AccountHolderMessagingRequestSchema auditInfo(AuditInfo auditInfo) {
    this.auditInfo = auditInfo;
    return this;
  }

  /**
   * Get auditInfo
   * @return auditInfo
   */
  @javax.annotation.Nonnull
  public AuditInfo getAuditInfo() {
    return auditInfo;
  }

  public void setAuditInfo(AuditInfo auditInfo) {
    this.auditInfo = auditInfo;
  }


  public AccountHolderMessagingRequestSchema issuerApplicationMessageDisplay(String issuerApplicationMessageDisplay) {
    this.issuerApplicationMessageDisplay = issuerApplicationMessageDisplay;
    return this;
  }

  /**
   * This is the indicator if the message can be viewed in the Issuer Application using the MessageIdentifier. &lt;br&gt;Please refer to the Apple Card Notification Specification for Notification Deep Linking. Mandatory field.  Valid values are;&lt;br&gt;TRUE ? The message can be viewed in the issuer application&lt;br&gt;FALSE ? The message cannot be viewed in the issuer application.
   * @return issuerApplicationMessageDisplay
   */
  @javax.annotation.Nonnull
  public String getIssuerApplicationMessageDisplay() {
    return issuerApplicationMessageDisplay;
  }

  public void setIssuerApplicationMessageDisplay(String issuerApplicationMessageDisplay) {
    this.issuerApplicationMessageDisplay = issuerApplicationMessageDisplay;
  }


  public AccountHolderMessagingRequestSchema messageExpiration(String messageExpiration) {
    this.messageExpiration = messageExpiration;
    return this;
  }

  /**
   * Date and time after which the message is no longer valid.  Maximum value of 30 days in the future. Mandatory field.  __ISO 8601 format ? YYYY-MM-DDThh:mm:ssTZD__
   * @return messageExpiration
   */
  @javax.annotation.Nonnull
  public String getMessageExpiration() {
    return messageExpiration;
  }

  public void setMessageExpiration(String messageExpiration) {
    this.messageExpiration = messageExpiration;
  }


  public AccountHolderMessagingRequestSchema messageIdentifier(String messageIdentifier) {
    this.messageIdentifier = messageIdentifier;
    return this;
  }

  /**
   * This is the message identifier. This could be used for linking into the issuer application. Mandatory field.
   * @return messageIdentifier
   */
  @javax.annotation.Nonnull
  public String getMessageIdentifier() {
    return messageIdentifier;
  }

  public void setMessageIdentifier(String messageIdentifier) {
    this.messageIdentifier = messageIdentifier;
  }


  public AccountHolderMessagingRequestSchema messageLanguageCode(String messageLanguageCode) {
    this.messageLanguageCode = messageLanguageCode;
    return this;
  }

  /**
   * The language of the message.  Only messages with the requested language code will be presented to the account holder. Mandatory field.  &lt;br&gt;__ISO 639-1 format__
   * @return messageLanguageCode
   */
  @javax.annotation.Nonnull
  public String getMessageLanguageCode() {
    return messageLanguageCode;
  }

  public void setMessageLanguageCode(String messageLanguageCode) {
    this.messageLanguageCode = messageLanguageCode;
  }


  public AccountHolderMessagingRequestSchema messageText(String messageText) {
    this.messageText = messageText;
    return this;
  }

  /**
   * This is the message which will be displayed to the cardholder. Mandatory field.
   * @return messageText
   */
  @javax.annotation.Nonnull
  public String getMessageText() {
    return messageText;
  }

  public void setMessageText(String messageText) {
    this.messageText = messageText;
  }


  public AccountHolderMessagingRequestSchema tokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
    return this;
  }

  /**
   * When present, the search will return one specific matching token. Cannot be used together with any of the following search request parameters; AccountPan, Token, PaymentAppInstanceId, CommentId, or AlternateAccountIdentifier. Mandatory field.
   * @return tokenUniqueReference
   */
  @javax.annotation.Nonnull
  public String getTokenUniqueReference() {
    return tokenUniqueReference;
  }

  public void setTokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccountHolderMessagingRequestSchema accountHolderMessagingRequestSchema = (AccountHolderMessagingRequestSchema) o;
    return Objects.equals(this.auditInfo, accountHolderMessagingRequestSchema.auditInfo) &&
        Objects.equals(this.issuerApplicationMessageDisplay, accountHolderMessagingRequestSchema.issuerApplicationMessageDisplay) &&
        Objects.equals(this.messageExpiration, accountHolderMessagingRequestSchema.messageExpiration) &&
        Objects.equals(this.messageIdentifier, accountHolderMessagingRequestSchema.messageIdentifier) &&
        Objects.equals(this.messageLanguageCode, accountHolderMessagingRequestSchema.messageLanguageCode) &&
        Objects.equals(this.messageText, accountHolderMessagingRequestSchema.messageText) &&
        Objects.equals(this.tokenUniqueReference, accountHolderMessagingRequestSchema.tokenUniqueReference);
  }

  @Override
  public int hashCode() {
    return Objects.hash(auditInfo, issuerApplicationMessageDisplay, messageExpiration, messageIdentifier, messageLanguageCode, messageText, tokenUniqueReference);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccountHolderMessagingRequestSchema {\n");
    sb.append("    auditInfo: ").append(toIndentedString(auditInfo)).append("\n");
    sb.append("    issuerApplicationMessageDisplay: ").append(toIndentedString(issuerApplicationMessageDisplay)).append("\n");
    sb.append("    messageExpiration: ").append(toIndentedString(messageExpiration)).append("\n");
    sb.append("    messageIdentifier: ").append(toIndentedString(messageIdentifier)).append("\n");
    sb.append("    messageLanguageCode: ").append(toIndentedString(messageLanguageCode)).append("\n");
    sb.append("    messageText: ").append(toIndentedString(messageText)).append("\n");
    sb.append("    tokenUniqueReference: ").append(toIndentedString(tokenUniqueReference)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AuditInfo");
    openapiFields.add("IssuerApplicationMessageDisplay");
    openapiFields.add("MessageExpiration");
    openapiFields.add("MessageIdentifier");
    openapiFields.add("MessageLanguageCode");
    openapiFields.add("MessageText");
    openapiFields.add("TokenUniqueReference");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("AuditInfo");
    openapiRequiredFields.add("IssuerApplicationMessageDisplay");
    openapiRequiredFields.add("MessageExpiration");
    openapiRequiredFields.add("MessageIdentifier");
    openapiRequiredFields.add("MessageLanguageCode");
    openapiRequiredFields.add("MessageText");
    openapiRequiredFields.add("TokenUniqueReference");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AccountHolderMessagingRequestSchema
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AccountHolderMessagingRequestSchema.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AccountHolderMessagingRequestSchema is not found in the empty JSON string", AccountHolderMessagingRequestSchema.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AccountHolderMessagingRequestSchema.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AccountHolderMessagingRequestSchema` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : AccountHolderMessagingRequestSchema.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `AuditInfo`
      AuditInfo.validateJsonElement(jsonObj.get("AuditInfo"));
      if (!jsonObj.get("IssuerApplicationMessageDisplay").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `IssuerApplicationMessageDisplay` to be a primitive type in the JSON string but got `%s`", jsonObj.get("IssuerApplicationMessageDisplay").toString()));
      }
      if (!jsonObj.get("MessageExpiration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MessageExpiration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MessageExpiration").toString()));
      }
      if (!jsonObj.get("MessageIdentifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MessageIdentifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MessageIdentifier").toString()));
      }
      if (!jsonObj.get("MessageLanguageCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MessageLanguageCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MessageLanguageCode").toString()));
      }
      if (!jsonObj.get("MessageText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `MessageText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("MessageText").toString()));
      }
      if (!jsonObj.get("TokenUniqueReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenUniqueReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenUniqueReference").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AccountHolderMessagingRequestSchema.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AccountHolderMessagingRequestSchema' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AccountHolderMessagingRequestSchema> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AccountHolderMessagingRequestSchema.class));

       return (TypeAdapter<T>) new TypeAdapter<AccountHolderMessagingRequestSchema>() {
           @Override
           public void write(JsonWriter out, AccountHolderMessagingRequestSchema value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AccountHolderMessagingRequestSchema read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AccountHolderMessagingRequestSchema given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AccountHolderMessagingRequestSchema
   * @throws IOException if the JSON string is invalid with respect to AccountHolderMessagingRequestSchema
   */
  public static AccountHolderMessagingRequestSchema fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AccountHolderMessagingRequestSchema.class);
  }

  /**
   * Convert an instance of AccountHolderMessagingRequestSchema to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

