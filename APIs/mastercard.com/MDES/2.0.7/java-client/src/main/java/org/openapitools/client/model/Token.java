/*
 * MDES Customer Service
 * This API provides our Issuer partners with resources to help resolve consumer queries about payment accounts enabled through our digitization platform.
 *
 * The version of the OpenAPI document: 2.0.7
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Device;
import org.openapitools.client.model.Suspenders;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Token
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:09:16.587349-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Token {
  public static final String SERIALIZED_NAME_ACCOUNT_PAN_SEQUENCE_NUMBER = "AccountPanSequenceNumber";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_PAN_SEQUENCE_NUMBER)
  private String accountPanSequenceNumber;

  public static final String SERIALIZED_NAME_ACTIVATION_CODE_EXPIRATION_DATE_TIME = "ActivationCodeExpirationDateTime";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_CODE_EXPIRATION_DATE_TIME)
  private String activationCodeExpirationDateTime;

  public static final String SERIALIZED_NAME_CORRELATION_ID = "CorrelationId";
  @SerializedName(SERIALIZED_NAME_CORRELATION_ID)
  private String correlationId;

  public static final String SERIALIZED_NAME_CURRENT_STATUS_CODE = "CurrentStatusCode";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATUS_CODE)
  private String currentStatusCode;

  public static final String SERIALIZED_NAME_CURRENT_STATUS_DATE_TIME = "CurrentStatusDateTime";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATUS_DATE_TIME)
  private String currentStatusDateTime;

  public static final String SERIALIZED_NAME_CURRENT_STATUS_DESCRIPTION = "CurrentStatusDescription";
  @SerializedName(SERIALIZED_NAME_CURRENT_STATUS_DESCRIPTION)
  private String currentStatusDescription;

  public static final String SERIALIZED_NAME_DEVICE = "Device";
  @SerializedName(SERIALIZED_NAME_DEVICE)
  private Device device;

  public static final String SERIALIZED_NAME_DIGITIZATION_REQUEST_DATE_TIME = "DigitizationRequestDateTime";
  @SerializedName(SERIALIZED_NAME_DIGITIZATION_REQUEST_DATE_TIME)
  private String digitizationRequestDateTime;

  public static final String SERIALIZED_NAME_EXPIRATION_DATE = "ExpirationDate";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_DATE)
  private String expirationDate;

  public static final String SERIALIZED_NAME_FINAL_TOKENIZATION_DECISION = "FinalTokenizationDecision";
  @SerializedName(SERIALIZED_NAME_FINAL_TOKENIZATION_DECISION)
  private String finalTokenizationDecision;

  public static final String SERIALIZED_NAME_LAST_COMMENT_ID = "LastCommentId";
  @SerializedName(SERIALIZED_NAME_LAST_COMMENT_ID)
  private String lastCommentId;

  public static final String SERIALIZED_NAME_PAYMENT_APP_INSTANCE_ID = "PaymentAppInstanceId";
  @SerializedName(SERIALIZED_NAME_PAYMENT_APP_INSTANCE_ID)
  private String paymentAppInstanceId;

  public static final String SERIALIZED_NAME_PRIMARY_ACCOUNT_NUMBER_UNIQUE_REFERENCE = "PrimaryAccountNumberUniqueReference";
  @SerializedName(SERIALIZED_NAME_PRIMARY_ACCOUNT_NUMBER_UNIQUE_REFERENCE)
  private String primaryAccountNumberUniqueReference;

  public static final String SERIALIZED_NAME_PROVISIONING_STATUS_CODE = "ProvisioningStatusCode";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATUS_CODE)
  private String provisioningStatusCode;

  public static final String SERIALIZED_NAME_PROVISIONING_STATUS_DESCRIPTION = "ProvisioningStatusDescription";
  @SerializedName(SERIALIZED_NAME_PROVISIONING_STATUS_DESCRIPTION)
  private String provisioningStatusDescription;

  public static final String SERIALIZED_NAME_STORAGE_TECHNOLOGY = "StorageTechnology";
  @SerializedName(SERIALIZED_NAME_STORAGE_TECHNOLOGY)
  private String storageTechnology;

  public static final String SERIALIZED_NAME_SUSPENDERS = "Suspenders";
  @SerializedName(SERIALIZED_NAME_SUSPENDERS)
  private Suspenders suspenders;

  public static final String SERIALIZED_NAME_TOKEN_ACTIVATED_DATE_TIME = "TokenActivatedDateTime";
  @SerializedName(SERIALIZED_NAME_TOKEN_ACTIVATED_DATE_TIME)
  private String tokenActivatedDateTime;

  public static final String SERIALIZED_NAME_TOKEN_ASSURANCE_LEVEL = "TokenAssuranceLevel";
  @SerializedName(SERIALIZED_NAME_TOKEN_ASSURANCE_LEVEL)
  private String tokenAssuranceLevel;

  public static final String SERIALIZED_NAME_TOKEN_DELETED_FROM_CONSUMER_APP = "TokenDeletedFromConsumerApp";
  @SerializedName(SERIALIZED_NAME_TOKEN_DELETED_FROM_CONSUMER_APP)
  private String tokenDeletedFromConsumerApp;

  public static final String SERIALIZED_NAME_TOKEN_REQUESTOR_CONSUMER_FACING_ENTITY_NAME = "TokenRequestorConsumerFacingEntityName";
  @SerializedName(SERIALIZED_NAME_TOKEN_REQUESTOR_CONSUMER_FACING_ENTITY_NAME)
  private String tokenRequestorConsumerFacingEntityName;

  public static final String SERIALIZED_NAME_TOKEN_REQUESTOR_ID = "TokenRequestorId";
  @SerializedName(SERIALIZED_NAME_TOKEN_REQUESTOR_ID)
  private String tokenRequestorId;

  public static final String SERIALIZED_NAME_TOKEN_REQUESTOR_NAME = "TokenRequestorName";
  @SerializedName(SERIALIZED_NAME_TOKEN_REQUESTOR_NAME)
  private String tokenRequestorName;

  public static final String SERIALIZED_NAME_TOKEN_SUFFIX = "TokenSuffix";
  @SerializedName(SERIALIZED_NAME_TOKEN_SUFFIX)
  private String tokenSuffix;

  public static final String SERIALIZED_NAME_TOKEN_TYPE = "TokenType";
  @SerializedName(SERIALIZED_NAME_TOKEN_TYPE)
  private String tokenType;

  public static final String SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE = "TokenUniqueReference";
  @SerializedName(SERIALIZED_NAME_TOKEN_UNIQUE_REFERENCE)
  private String tokenUniqueReference;

  public static final String SERIALIZED_NAME_WALLET_ID = "WalletId";
  @SerializedName(SERIALIZED_NAME_WALLET_ID)
  private String walletId;

  public Token() {
  }

  public Token accountPanSequenceNumber(String accountPanSequenceNumber) {
    this.accountPanSequenceNumber = accountPanSequenceNumber;
    return this;
  }

  /**
   * The Account PAN Sequence Number associated with a specific token, as provided to MDES previously by the issuer. It may be used to distinguish between multiple cardholders for a single Account PAN, to represent an issuance number of a specific card, or to distinguish between different card products, such as debit or credit, that share the same Account PAN. Conditional field, present when successfully assigned. Supported values - 00 to 99.
   * @return accountPanSequenceNumber
   */
  @javax.annotation.Nullable
  public String getAccountPanSequenceNumber() {
    return accountPanSequenceNumber;
  }

  public void setAccountPanSequenceNumber(String accountPanSequenceNumber) {
    this.accountPanSequenceNumber = accountPanSequenceNumber;
  }


  public Token activationCodeExpirationDateTime(String activationCodeExpirationDateTime) {
    this.activationCodeExpirationDateTime = activationCodeExpirationDateTime;
    return this;
  }

  /**
   * Date and time when an Activation Code will expire. Conditional field, not present for CoF tokens, and only present when an Activation Code has been generated and activation has not yet occurred. The date and time may be in the future or past. string in ISO 8601 format ? YYYY-MM-DDThh:mm:ssTZD .
   * @return activationCodeExpirationDateTime
   */
  @javax.annotation.Nullable
  public String getActivationCodeExpirationDateTime() {
    return activationCodeExpirationDateTime;
  }

  public void setActivationCodeExpirationDateTime(String activationCodeExpirationDateTime) {
    this.activationCodeExpirationDateTime = activationCodeExpirationDateTime;
  }


  public Token correlationId(String correlationId) {
    this.correlationId = correlationId;
    return this;
  }

  /**
   * Value linking pre-digitization messages generated during provisioning. Conditional field, not present for CoF tokens.
   * @return correlationId
   */
  @javax.annotation.Nullable
  public String getCorrelationId() {
    return correlationId;
  }

  public void setCorrelationId(String correlationId) {
    this.correlationId = correlationId;
  }


  public Token currentStatusCode(String currentStatusCode) {
    this.currentStatusCode = currentStatusCode;
    return this;
  }

  /**
   * Current status of the Token. Valid values:&lt;br&gt; \&quot;U\&quot; - Unmapped. The token has not yet been linked to the Account PAN. The process of tokenization is ?In Progress.&#39;&lt;br&gt; \&quot;A\&quot; - Active. The token is linked to the Account PAN and may initiate new transactions to be authorized.&lt;br&gt; \&quot;S\&quot; - Suspended. The token is linked to the Account PAN but may not perform transactions at the request of one or more suspenders.&lt;br&gt; \&quot;D\&quot; - Deleted. The token is logically deleted but is still linked to the Account PAN for the purposes of post-authorization transaction processing.
   * @return currentStatusCode
   */
  @javax.annotation.Nullable
  public String getCurrentStatusCode() {
    return currentStatusCode;
  }

  public void setCurrentStatusCode(String currentStatusCode) {
    this.currentStatusCode = currentStatusCode;
  }


  public Token currentStatusDateTime(String currentStatusDateTime) {
    this.currentStatusDateTime = currentStatusDateTime;
    return this;
  }

  /**
   * Date and time the status was updated.  string, ISO 8601 format ? YYYY-MM-DDThh:mm:ssTZD .
   * @return currentStatusDateTime
   */
  @javax.annotation.Nullable
  public String getCurrentStatusDateTime() {
    return currentStatusDateTime;
  }

  public void setCurrentStatusDateTime(String currentStatusDateTime) {
    this.currentStatusDateTime = currentStatusDateTime;
  }


  public Token currentStatusDescription(String currentStatusDescription) {
    this.currentStatusDescription = currentStatusDescription;
    return this;
  }

  /**
   * Description of the current status.
   * @return currentStatusDescription
   */
  @javax.annotation.Nullable
  public String getCurrentStatusDescription() {
    return currentStatusDescription;
  }

  public void setCurrentStatusDescription(String currentStatusDescription) {
    this.currentStatusDescription = currentStatusDescription;
  }


  public Token device(Device device) {
    this.device = device;
    return this;
  }

  /**
   * Get device
   * @return device
   */
  @javax.annotation.Nullable
  public Device getDevice() {
    return device;
  }

  public void setDevice(Device device) {
    this.device = device;
  }


  public Token digitizationRequestDateTime(String digitizationRequestDateTime) {
    this.digitizationRequestDateTime = digitizationRequestDateTime;
    return this;
  }

  /**
   * Date and time of the initial request for digitization of the Account PAN for this token. Conditional field, not present for CoF tokens. string, in ISO 8601 format ? YYYY-MM-DDThh:mm:ssTZD .
   * @return digitizationRequestDateTime
   */
  @javax.annotation.Nullable
  public String getDigitizationRequestDateTime() {
    return digitizationRequestDateTime;
  }

  public void setDigitizationRequestDateTime(String digitizationRequestDateTime) {
    this.digitizationRequestDateTime = digitizationRequestDateTime;
  }


  public Token expirationDate(String expirationDate) {
    this.expirationDate = expirationDate;
    return this;
  }

  /**
   * Expiration date of token. Conditional field, present once the token has been designated for the digitization. Four digit string. Format \&quot;mmyy\&quot;.
   * @return expirationDate
   */
  @javax.annotation.Nullable
  public String getExpirationDate() {
    return expirationDate;
  }

  public void setExpirationDate(String expirationDate) {
    this.expirationDate = expirationDate;
  }


  public Token finalTokenizationDecision(String finalTokenizationDecision) {
    this.finalTokenizationDecision = finalTokenizationDecision;
    return this;
  }

  /**
   * Final decision related to the digitization of the Account PAN for this token. Valid values:&lt;br /&gt;    \&quot;D\&quot; - Digitization was declined&lt;br /&gt;    \&quot;A\&quot; - Digitization was approved&lt;br /&gt;    \&quot;R\&quot; - Digitization was approved but required authentication prior to activation.&lt;br /&gt;Conditional field, not present for CoF tokens.&lt;br&gt;&lt;br&gt;_Note:_this information is currently subject to archival processes and will be present for only 1 year following digitization.
   * @return finalTokenizationDecision
   */
  @javax.annotation.Nullable
  public String getFinalTokenizationDecision() {
    return finalTokenizationDecision;
  }

  public void setFinalTokenizationDecision(String finalTokenizationDecision) {
    this.finalTokenizationDecision = finalTokenizationDecision;
  }


  public Token lastCommentId(String lastCommentId) {
    this.lastCommentId = lastCommentId;
    return this;
  }

  /**
   * Identifier of the last comment associated with the token.
   * @return lastCommentId
   */
  @javax.annotation.Nullable
  public String getLastCommentId() {
    return lastCommentId;
  }

  public void setLastCommentId(String lastCommentId) {
    this.lastCommentId = lastCommentId;
  }


  public Token paymentAppInstanceId(String paymentAppInstanceId) {
    this.paymentAppInstanceId = paymentAppInstanceId;
    return this;
  }

  /**
   * Identifier of the Payment App instance within a device that will be provisioned with a token.&lt;br&gt;&lt;br&gt;_Note:_ This may contain the identifier of the Secure Element or a mobile device for some programs. Optional, not present for CoF tokens, and only present when supplied by the Payment App Provider.
   * @return paymentAppInstanceId
   */
  @javax.annotation.Nullable
  public String getPaymentAppInstanceId() {
    return paymentAppInstanceId;
  }

  public void setPaymentAppInstanceId(String paymentAppInstanceId) {
    this.paymentAppInstanceId = paymentAppInstanceId;
  }


  public Token primaryAccountNumberUniqueReference(String primaryAccountNumberUniqueReference) {
    this.primaryAccountNumberUniqueReference = primaryAccountNumberUniqueReference;
    return this;
  }

  /**
   * Unique reference to the Account PAN originally digitized. Conditional field, present when successfully assigned.
   * @return primaryAccountNumberUniqueReference
   */
  @javax.annotation.Nullable
  public String getPrimaryAccountNumberUniqueReference() {
    return primaryAccountNumberUniqueReference;
  }

  public void setPrimaryAccountNumberUniqueReference(String primaryAccountNumberUniqueReference) {
    this.primaryAccountNumberUniqueReference = primaryAccountNumberUniqueReference;
  }


  public Token provisioningStatusCode(String provisioningStatusCode) {
    this.provisioningStatusCode = provisioningStatusCode;
    return this;
  }

  /**
   * Current provisioning status of the token. Valid values:&lt;br /&gt;    \&quot;P\&quot; - Token being prepared&lt;br /&gt;    \&quot;T\&quot; - Awaiting cardholder acceptance of Terms and Conditions&lt;br /&gt;    \&quot;D\&quot; - Token being delivered to Wallet Provider or Device&lt;br /&gt;    \&quot;A\&quot; - Awaiting Activation&lt;br /&gt;    \&quot;S\&quot; - Provisioning successful&lt;br /&gt;    \&quot;F\&quot; - Provisioning failed.&lt;br /&gt;&lt;br&gt;&lt;br&gt;_Note:_ The order of the statuses above does not indicate any order of status transitions. Conditional field, not present for CoF tokens.
   * @return provisioningStatusCode
   */
  @javax.annotation.Nullable
  public String getProvisioningStatusCode() {
    return provisioningStatusCode;
  }

  public void setProvisioningStatusCode(String provisioningStatusCode) {
    this.provisioningStatusCode = provisioningStatusCode;
  }


  public Token provisioningStatusDescription(String provisioningStatusDescription) {
    this.provisioningStatusDescription = provisioningStatusDescription;
    return this;
  }

  /**
   * Description of the provisioning status. Conditional field, not present for CoF tokens.
   * @return provisioningStatusDescription
   */
  @javax.annotation.Nullable
  public String getProvisioningStatusDescription() {
    return provisioningStatusDescription;
  }

  public void setProvisioningStatusDescription(String provisioningStatusDescription) {
    this.provisioningStatusDescription = provisioningStatusDescription;
  }


  public Token storageTechnology(String storageTechnology) {
    this.storageTechnology = storageTechnology;
    return this;
  }

  /**
   * The architecture or technology used for token storage. Valid values:&lt;br /&gt;    \&quot;D\&quot; - Device memory&lt;br /&gt;    \&quot;P\&quot; - Device memory protected by Trusted Platform Module (TPM)&lt;br /&gt;    \&quot;H\&quot; - Server&lt;br /&gt;    \&quot;E\&quot; - Trusted Execution Environment (TEE)&lt;br /&gt;    \&quot;S\&quot; - Secure Element (SE)&lt;br /&gt;    \&quot;V\&quot; - Virtual Execution Environment (VEE).
   * @return storageTechnology
   */
  @javax.annotation.Nullable
  public String getStorageTechnology() {
    return storageTechnology;
  }

  public void setStorageTechnology(String storageTechnology) {
    this.storageTechnology = storageTechnology;
  }


  public Token suspenders(Suspenders suspenders) {
    this.suspenders = suspenders;
    return this;
  }

  /**
   * Get suspenders
   * @return suspenders
   */
  @javax.annotation.Nullable
  public Suspenders getSuspenders() {
    return suspenders;
  }

  public void setSuspenders(Suspenders suspenders) {
    this.suspenders = suspenders;
  }


  public Token tokenActivatedDateTime(String tokenActivatedDateTime) {
    this.tokenActivatedDateTime = tokenActivatedDateTime;
    return this;
  }

  /**
   * Date and time that the token was activated. Conditional field, present only once the Token has been activated. string in ISO 8601 format ? YYYY-MM-DDThh:mm:ssTZD .
   * @return tokenActivatedDateTime
   */
  @javax.annotation.Nullable
  public String getTokenActivatedDateTime() {
    return tokenActivatedDateTime;
  }

  public void setTokenActivatedDateTime(String tokenActivatedDateTime) {
    this.tokenActivatedDateTime = tokenActivatedDateTime;
  }


  public Token tokenAssuranceLevel(String tokenAssuranceLevel) {
    this.tokenAssuranceLevel = tokenAssuranceLevel;
    return this;
  }

  /**
   * Indicates the level of Identification and Verification performed to validate the Cardholder and the Cardholder&#39;s account at the time the Token was issued (or at any subsquent time post-issuance).  Only present when a token has a Token Assurance Level assigned.  Supported values are 0 (Not Authenticated) and non-zero (Authenticated).
   * @return tokenAssuranceLevel
   */
  @javax.annotation.Nullable
  public String getTokenAssuranceLevel() {
    return tokenAssuranceLevel;
  }

  public void setTokenAssuranceLevel(String tokenAssuranceLevel) {
    this.tokenAssuranceLevel = tokenAssuranceLevel;
  }


  public Token tokenDeletedFromConsumerApp(String tokenDeletedFromConsumerApp) {
    this.tokenDeletedFromConsumerApp = tokenDeletedFromConsumerApp;
    return this;
  }

  /**
   * Indicates whether or not a token has been deleted from the consumer app by the token requestor.&lt;br&gt;&lt;br&gt;_Note:_ This is a \&quot;soft delete\&quot; that does not affect the actual Token Status. The token may still be active in the system. Supported values - true, false.
   * @return tokenDeletedFromConsumerApp
   */
  @javax.annotation.Nullable
  public String getTokenDeletedFromConsumerApp() {
    return tokenDeletedFromConsumerApp;
  }

  public void setTokenDeletedFromConsumerApp(String tokenDeletedFromConsumerApp) {
    this.tokenDeletedFromConsumerApp = tokenDeletedFromConsumerApp;
  }


  public Token tokenRequestorConsumerFacingEntityName(String tokenRequestorConsumerFacingEntityName) {
    this.tokenRequestorConsumerFacingEntityName = tokenRequestorConsumerFacingEntityName;
    return this;
  }

  /**
   * The Token Service Provider name to be displayed to the consumer (consumer-facing name).
   * @return tokenRequestorConsumerFacingEntityName
   */
  @javax.annotation.Nullable
  public String getTokenRequestorConsumerFacingEntityName() {
    return tokenRequestorConsumerFacingEntityName;
  }

  public void setTokenRequestorConsumerFacingEntityName(String tokenRequestorConsumerFacingEntityName) {
    this.tokenRequestorConsumerFacingEntityName = tokenRequestorConsumerFacingEntityName;
  }


  public Token tokenRequestorId(String tokenRequestorId) {
    this.tokenRequestorId = tokenRequestorId;
    return this;
  }

  /**
   * Per EMV Co, the entity uniquely recognized by Mastercard as the Token Service Provider.
   * @return tokenRequestorId
   */
  @javax.annotation.Nullable
  public String getTokenRequestorId() {
    return tokenRequestorId;
  }

  public void setTokenRequestorId(String tokenRequestorId) {
    this.tokenRequestorId = tokenRequestorId;
  }


  public Token tokenRequestorName(String tokenRequestorName) {
    this.tokenRequestorName = tokenRequestorName;
    return this;
  }

  /**
   * The legal name of the token requestor. There can be more than one Token Requestor Id per Token Requester Name (legal name). So it is important to use both parameters to uniquely identify a token requestor.
   * @return tokenRequestorName
   */
  @javax.annotation.Nullable
  public String getTokenRequestorName() {
    return tokenRequestorName;
  }

  public void setTokenRequestorName(String tokenRequestorName) {
    this.tokenRequestorName = tokenRequestorName;
  }


  public Token tokenSuffix(String tokenSuffix) {
    this.tokenSuffix = tokenSuffix;
    return this;
  }

  /**
   * Last 4 digits of token in a 4 character string. Conditional field, present once the token has been designated for the digitization.
   * @return tokenSuffix
   */
  @javax.annotation.Nullable
  public String getTokenSuffix() {
    return tokenSuffix;
  }

  public void setTokenSuffix(String tokenSuffix) {
    this.tokenSuffix = tokenSuffix;
  }


  public Token tokenType(String tokenType) {
    this.tokenType = tokenType;
    return this;
  }

  /**
   * Type of token. Valid values:&lt;br /&gt;    \&quot;S\&quot; - Embedded Secure Element Token&lt;br /&gt;    \&quot;C\&quot; - Mastercard Cloud-Based Payments token.&lt;br /&gt;   F &#x3D; Static token (deprecated)
   * @return tokenType
   */
  @javax.annotation.Nullable
  public String getTokenType() {
    return tokenType;
  }

  public void setTokenType(String tokenType) {
    this.tokenType = tokenType;
  }


  public Token tokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
    return this;
  }

  /**
   * Unique reference to the token. Conditional field, present when successfully assigned.
   * @return tokenUniqueReference
   */
  @javax.annotation.Nullable
  public String getTokenUniqueReference() {
    return tokenUniqueReference;
  }

  public void setTokenUniqueReference(String tokenUniqueReference) {
    this.tokenUniqueReference = tokenUniqueReference;
  }


  public Token walletId(String walletId) {
    this.walletId = walletId;
    return this;
  }

  /**
   * Identifier of the Wallet Provider who requested the digitization or tokenization. Conditional field, not present for CoF tokens, and only present when supplied by the Payment App Provider.
   * @return walletId
   */
  @javax.annotation.Nullable
  public String getWalletId() {
    return walletId;
  }

  public void setWalletId(String walletId) {
    this.walletId = walletId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Token token = (Token) o;
    return Objects.equals(this.accountPanSequenceNumber, token.accountPanSequenceNumber) &&
        Objects.equals(this.activationCodeExpirationDateTime, token.activationCodeExpirationDateTime) &&
        Objects.equals(this.correlationId, token.correlationId) &&
        Objects.equals(this.currentStatusCode, token.currentStatusCode) &&
        Objects.equals(this.currentStatusDateTime, token.currentStatusDateTime) &&
        Objects.equals(this.currentStatusDescription, token.currentStatusDescription) &&
        Objects.equals(this.device, token.device) &&
        Objects.equals(this.digitizationRequestDateTime, token.digitizationRequestDateTime) &&
        Objects.equals(this.expirationDate, token.expirationDate) &&
        Objects.equals(this.finalTokenizationDecision, token.finalTokenizationDecision) &&
        Objects.equals(this.lastCommentId, token.lastCommentId) &&
        Objects.equals(this.paymentAppInstanceId, token.paymentAppInstanceId) &&
        Objects.equals(this.primaryAccountNumberUniqueReference, token.primaryAccountNumberUniqueReference) &&
        Objects.equals(this.provisioningStatusCode, token.provisioningStatusCode) &&
        Objects.equals(this.provisioningStatusDescription, token.provisioningStatusDescription) &&
        Objects.equals(this.storageTechnology, token.storageTechnology) &&
        Objects.equals(this.suspenders, token.suspenders) &&
        Objects.equals(this.tokenActivatedDateTime, token.tokenActivatedDateTime) &&
        Objects.equals(this.tokenAssuranceLevel, token.tokenAssuranceLevel) &&
        Objects.equals(this.tokenDeletedFromConsumerApp, token.tokenDeletedFromConsumerApp) &&
        Objects.equals(this.tokenRequestorConsumerFacingEntityName, token.tokenRequestorConsumerFacingEntityName) &&
        Objects.equals(this.tokenRequestorId, token.tokenRequestorId) &&
        Objects.equals(this.tokenRequestorName, token.tokenRequestorName) &&
        Objects.equals(this.tokenSuffix, token.tokenSuffix) &&
        Objects.equals(this.tokenType, token.tokenType) &&
        Objects.equals(this.tokenUniqueReference, token.tokenUniqueReference) &&
        Objects.equals(this.walletId, token.walletId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountPanSequenceNumber, activationCodeExpirationDateTime, correlationId, currentStatusCode, currentStatusDateTime, currentStatusDescription, device, digitizationRequestDateTime, expirationDate, finalTokenizationDecision, lastCommentId, paymentAppInstanceId, primaryAccountNumberUniqueReference, provisioningStatusCode, provisioningStatusDescription, storageTechnology, suspenders, tokenActivatedDateTime, tokenAssuranceLevel, tokenDeletedFromConsumerApp, tokenRequestorConsumerFacingEntityName, tokenRequestorId, tokenRequestorName, tokenSuffix, tokenType, tokenUniqueReference, walletId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Token {\n");
    sb.append("    accountPanSequenceNumber: ").append(toIndentedString(accountPanSequenceNumber)).append("\n");
    sb.append("    activationCodeExpirationDateTime: ").append(toIndentedString(activationCodeExpirationDateTime)).append("\n");
    sb.append("    correlationId: ").append(toIndentedString(correlationId)).append("\n");
    sb.append("    currentStatusCode: ").append(toIndentedString(currentStatusCode)).append("\n");
    sb.append("    currentStatusDateTime: ").append(toIndentedString(currentStatusDateTime)).append("\n");
    sb.append("    currentStatusDescription: ").append(toIndentedString(currentStatusDescription)).append("\n");
    sb.append("    device: ").append(toIndentedString(device)).append("\n");
    sb.append("    digitizationRequestDateTime: ").append(toIndentedString(digitizationRequestDateTime)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("    finalTokenizationDecision: ").append(toIndentedString(finalTokenizationDecision)).append("\n");
    sb.append("    lastCommentId: ").append(toIndentedString(lastCommentId)).append("\n");
    sb.append("    paymentAppInstanceId: ").append(toIndentedString(paymentAppInstanceId)).append("\n");
    sb.append("    primaryAccountNumberUniqueReference: ").append(toIndentedString(primaryAccountNumberUniqueReference)).append("\n");
    sb.append("    provisioningStatusCode: ").append(toIndentedString(provisioningStatusCode)).append("\n");
    sb.append("    provisioningStatusDescription: ").append(toIndentedString(provisioningStatusDescription)).append("\n");
    sb.append("    storageTechnology: ").append(toIndentedString(storageTechnology)).append("\n");
    sb.append("    suspenders: ").append(toIndentedString(suspenders)).append("\n");
    sb.append("    tokenActivatedDateTime: ").append(toIndentedString(tokenActivatedDateTime)).append("\n");
    sb.append("    tokenAssuranceLevel: ").append(toIndentedString(tokenAssuranceLevel)).append("\n");
    sb.append("    tokenDeletedFromConsumerApp: ").append(toIndentedString(tokenDeletedFromConsumerApp)).append("\n");
    sb.append("    tokenRequestorConsumerFacingEntityName: ").append(toIndentedString(tokenRequestorConsumerFacingEntityName)).append("\n");
    sb.append("    tokenRequestorId: ").append(toIndentedString(tokenRequestorId)).append("\n");
    sb.append("    tokenRequestorName: ").append(toIndentedString(tokenRequestorName)).append("\n");
    sb.append("    tokenSuffix: ").append(toIndentedString(tokenSuffix)).append("\n");
    sb.append("    tokenType: ").append(toIndentedString(tokenType)).append("\n");
    sb.append("    tokenUniqueReference: ").append(toIndentedString(tokenUniqueReference)).append("\n");
    sb.append("    walletId: ").append(toIndentedString(walletId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("AccountPanSequenceNumber");
    openapiFields.add("ActivationCodeExpirationDateTime");
    openapiFields.add("CorrelationId");
    openapiFields.add("CurrentStatusCode");
    openapiFields.add("CurrentStatusDateTime");
    openapiFields.add("CurrentStatusDescription");
    openapiFields.add("Device");
    openapiFields.add("DigitizationRequestDateTime");
    openapiFields.add("ExpirationDate");
    openapiFields.add("FinalTokenizationDecision");
    openapiFields.add("LastCommentId");
    openapiFields.add("PaymentAppInstanceId");
    openapiFields.add("PrimaryAccountNumberUniqueReference");
    openapiFields.add("ProvisioningStatusCode");
    openapiFields.add("ProvisioningStatusDescription");
    openapiFields.add("StorageTechnology");
    openapiFields.add("Suspenders");
    openapiFields.add("TokenActivatedDateTime");
    openapiFields.add("TokenAssuranceLevel");
    openapiFields.add("TokenDeletedFromConsumerApp");
    openapiFields.add("TokenRequestorConsumerFacingEntityName");
    openapiFields.add("TokenRequestorId");
    openapiFields.add("TokenRequestorName");
    openapiFields.add("TokenSuffix");
    openapiFields.add("TokenType");
    openapiFields.add("TokenUniqueReference");
    openapiFields.add("WalletId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Token
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Token.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Token is not found in the empty JSON string", Token.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Token.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Token` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("AccountPanSequenceNumber") != null && !jsonObj.get("AccountPanSequenceNumber").isJsonNull()) && !jsonObj.get("AccountPanSequenceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `AccountPanSequenceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("AccountPanSequenceNumber").toString()));
      }
      if ((jsonObj.get("ActivationCodeExpirationDateTime") != null && !jsonObj.get("ActivationCodeExpirationDateTime").isJsonNull()) && !jsonObj.get("ActivationCodeExpirationDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ActivationCodeExpirationDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ActivationCodeExpirationDateTime").toString()));
      }
      if ((jsonObj.get("CorrelationId") != null && !jsonObj.get("CorrelationId").isJsonNull()) && !jsonObj.get("CorrelationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CorrelationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CorrelationId").toString()));
      }
      if ((jsonObj.get("CurrentStatusCode") != null && !jsonObj.get("CurrentStatusCode").isJsonNull()) && !jsonObj.get("CurrentStatusCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentStatusCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentStatusCode").toString()));
      }
      if ((jsonObj.get("CurrentStatusDateTime") != null && !jsonObj.get("CurrentStatusDateTime").isJsonNull()) && !jsonObj.get("CurrentStatusDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentStatusDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentStatusDateTime").toString()));
      }
      if ((jsonObj.get("CurrentStatusDescription") != null && !jsonObj.get("CurrentStatusDescription").isJsonNull()) && !jsonObj.get("CurrentStatusDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `CurrentStatusDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("CurrentStatusDescription").toString()));
      }
      // validate the optional field `Device`
      if (jsonObj.get("Device") != null && !jsonObj.get("Device").isJsonNull()) {
        Device.validateJsonElement(jsonObj.get("Device"));
      }
      if ((jsonObj.get("DigitizationRequestDateTime") != null && !jsonObj.get("DigitizationRequestDateTime").isJsonNull()) && !jsonObj.get("DigitizationRequestDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DigitizationRequestDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DigitizationRequestDateTime").toString()));
      }
      if ((jsonObj.get("ExpirationDate") != null && !jsonObj.get("ExpirationDate").isJsonNull()) && !jsonObj.get("ExpirationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ExpirationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ExpirationDate").toString()));
      }
      if ((jsonObj.get("FinalTokenizationDecision") != null && !jsonObj.get("FinalTokenizationDecision").isJsonNull()) && !jsonObj.get("FinalTokenizationDecision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `FinalTokenizationDecision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("FinalTokenizationDecision").toString()));
      }
      if ((jsonObj.get("LastCommentId") != null && !jsonObj.get("LastCommentId").isJsonNull()) && !jsonObj.get("LastCommentId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `LastCommentId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("LastCommentId").toString()));
      }
      if ((jsonObj.get("PaymentAppInstanceId") != null && !jsonObj.get("PaymentAppInstanceId").isJsonNull()) && !jsonObj.get("PaymentAppInstanceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `PaymentAppInstanceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("PaymentAppInstanceId").toString()));
      }
      if ((jsonObj.get("PrimaryAccountNumberUniqueReference") != null && !jsonObj.get("PrimaryAccountNumberUniqueReference").isJsonNull()) && !jsonObj.get("PrimaryAccountNumberUniqueReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `PrimaryAccountNumberUniqueReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("PrimaryAccountNumberUniqueReference").toString()));
      }
      if ((jsonObj.get("ProvisioningStatusCode") != null && !jsonObj.get("ProvisioningStatusCode").isJsonNull()) && !jsonObj.get("ProvisioningStatusCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ProvisioningStatusCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ProvisioningStatusCode").toString()));
      }
      if ((jsonObj.get("ProvisioningStatusDescription") != null && !jsonObj.get("ProvisioningStatusDescription").isJsonNull()) && !jsonObj.get("ProvisioningStatusDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ProvisioningStatusDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ProvisioningStatusDescription").toString()));
      }
      if ((jsonObj.get("StorageTechnology") != null && !jsonObj.get("StorageTechnology").isJsonNull()) && !jsonObj.get("StorageTechnology").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `StorageTechnology` to be a primitive type in the JSON string but got `%s`", jsonObj.get("StorageTechnology").toString()));
      }
      // validate the optional field `Suspenders`
      if (jsonObj.get("Suspenders") != null && !jsonObj.get("Suspenders").isJsonNull()) {
        Suspenders.validateJsonElement(jsonObj.get("Suspenders"));
      }
      if ((jsonObj.get("TokenActivatedDateTime") != null && !jsonObj.get("TokenActivatedDateTime").isJsonNull()) && !jsonObj.get("TokenActivatedDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenActivatedDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenActivatedDateTime").toString()));
      }
      if ((jsonObj.get("TokenAssuranceLevel") != null && !jsonObj.get("TokenAssuranceLevel").isJsonNull()) && !jsonObj.get("TokenAssuranceLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenAssuranceLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenAssuranceLevel").toString()));
      }
      if ((jsonObj.get("TokenDeletedFromConsumerApp") != null && !jsonObj.get("TokenDeletedFromConsumerApp").isJsonNull()) && !jsonObj.get("TokenDeletedFromConsumerApp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenDeletedFromConsumerApp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenDeletedFromConsumerApp").toString()));
      }
      if ((jsonObj.get("TokenRequestorConsumerFacingEntityName") != null && !jsonObj.get("TokenRequestorConsumerFacingEntityName").isJsonNull()) && !jsonObj.get("TokenRequestorConsumerFacingEntityName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenRequestorConsumerFacingEntityName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenRequestorConsumerFacingEntityName").toString()));
      }
      if ((jsonObj.get("TokenRequestorId") != null && !jsonObj.get("TokenRequestorId").isJsonNull()) && !jsonObj.get("TokenRequestorId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenRequestorId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenRequestorId").toString()));
      }
      if ((jsonObj.get("TokenRequestorName") != null && !jsonObj.get("TokenRequestorName").isJsonNull()) && !jsonObj.get("TokenRequestorName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenRequestorName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenRequestorName").toString()));
      }
      if ((jsonObj.get("TokenSuffix") != null && !jsonObj.get("TokenSuffix").isJsonNull()) && !jsonObj.get("TokenSuffix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenSuffix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenSuffix").toString()));
      }
      if ((jsonObj.get("TokenType") != null && !jsonObj.get("TokenType").isJsonNull()) && !jsonObj.get("TokenType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenType").toString()));
      }
      if ((jsonObj.get("TokenUniqueReference") != null && !jsonObj.get("TokenUniqueReference").isJsonNull()) && !jsonObj.get("TokenUniqueReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TokenUniqueReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TokenUniqueReference").toString()));
      }
      if ((jsonObj.get("WalletId") != null && !jsonObj.get("WalletId").isJsonNull()) && !jsonObj.get("WalletId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `WalletId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("WalletId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Token.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Token' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Token> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Token.class));

       return (TypeAdapter<T>) new TypeAdapter<Token>() {
           @Override
           public void write(JsonWriter out, Token value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Token read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Token given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Token
   * @throws IOException if the JSON string is invalid with respect to Token
   */
  public static Token fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Token.class);
  }

  /**
   * Convert an instance of Token to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

