/**
 * Active Documentation for /v1
 * Our active docs provide the ability to test out your account and to see the responses to your queries. The services are RESTful, and are accessed using standard HTTP methods over a secure HTTPS channel. Requests and responses are currently sent in JSON format, and have a base URL of /v1.
 *
 * The version of the OpenAPI document: 1.1.7
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITopupsApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAITopupsApi::OAITopupsApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAITopupsApi::~OAITopupsApi() {
}

void OAITopupsApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.idtbeyond.com/v1"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("iatuTopupsPost", defaultConf);
    _serverIndices.insert("iatuTopupsPost", 0);
    _serverConfigs.insert("iatuTopupsReportsAllCsvGet", defaultConf);
    _serverIndices.insert("iatuTopupsReportsAllCsvGet", 0);
    _serverConfigs.insert("iatuTopupsReportsAllGet", defaultConf);
    _serverIndices.insert("iatuTopupsReportsAllGet", 0);
    _serverConfigs.insert("iatuTopupsReportsPost", defaultConf);
    _serverIndices.insert("iatuTopupsReportsPost", 0);
    _serverConfigs.insert("iatuTopupsReportsTotalsGet", defaultConf);
    _serverIndices.insert("iatuTopupsReportsTotalsGet", 0);
    _serverConfigs.insert("iatuTopupsReversePost", defaultConf);
    _serverIndices.insert("iatuTopupsReversePost", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAITopupsApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAITopupsApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAITopupsApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAITopupsApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAITopupsApi::setUsername(const QString &username) {
    _username = username;
}

void OAITopupsApi::setPassword(const QString &password) {
    _password = password;
}


void OAITopupsApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAITopupsApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAITopupsApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAITopupsApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITopupsApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITopupsApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAITopupsApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAITopupsApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAITopupsApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAITopupsApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAITopupsApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAITopupsApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAITopupsApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAITopupsApi::iatuTopupsPost(const QString &x_idt_beyond_app_id, const QString &x_idt_beyond_app_key, const OAITopups &body) {
    QString fullPath = QString(_serverConfigs["iatuTopupsPost"][_serverIndices.value("iatuTopupsPost")].URL()+"/iatu/topups");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_id).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-id", ::OpenAPI::toStringValue(x_idt_beyond_app_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_key).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-key", ::OpenAPI::toStringValue(x_idt_beyond_app_key));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITopupsApi::iatuTopupsPostCallback);
    connect(this, &OAITopupsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITopupsApi::iatuTopupsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT iatuTopupsPostSignal();
        Q_EMIT iatuTopupsPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT iatuTopupsPostSignalE(error_type, error_str);
        Q_EMIT iatuTopupsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT iatuTopupsPostSignalError(error_type, error_str);
        Q_EMIT iatuTopupsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITopupsApi::iatuTopupsReportsAllCsvGet(const QString &x_idt_beyond_app_id, const QString &x_idt_beyond_app_key, const QString &date_from, const QString &date_to) {
    QString fullPath = QString(_serverConfigs["iatuTopupsReportsAllCsvGet"][_serverIndices.value("iatuTopupsReportsAllCsvGet")].URL()+"/iatu/topups/reports/all.csv");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "date_from", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("date_from")).append(querySuffix).append(QUrl::toPercentEncoding(date_from));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "date_to", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("date_to")).append(querySuffix).append(QUrl::toPercentEncoding(date_to));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_id).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-id", ::OpenAPI::toStringValue(x_idt_beyond_app_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_key).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-key", ::OpenAPI::toStringValue(x_idt_beyond_app_key));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITopupsApi::iatuTopupsReportsAllCsvGetCallback);
    connect(this, &OAITopupsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITopupsApi::iatuTopupsReportsAllCsvGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT iatuTopupsReportsAllCsvGetSignal();
        Q_EMIT iatuTopupsReportsAllCsvGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT iatuTopupsReportsAllCsvGetSignalE(error_type, error_str);
        Q_EMIT iatuTopupsReportsAllCsvGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT iatuTopupsReportsAllCsvGetSignalError(error_type, error_str);
        Q_EMIT iatuTopupsReportsAllCsvGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITopupsApi::iatuTopupsReportsAllGet(const QString &x_idt_beyond_app_id, const QString &x_idt_beyond_app_key, const QString &date_from, const QString &date_to) {
    QString fullPath = QString(_serverConfigs["iatuTopupsReportsAllGet"][_serverIndices.value("iatuTopupsReportsAllGet")].URL()+"/iatu/topups/reports/all");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "date_from", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("date_from")).append(querySuffix).append(QUrl::toPercentEncoding(date_from));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "date_to", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("date_to")).append(querySuffix).append(QUrl::toPercentEncoding(date_to));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_id).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-id", ::OpenAPI::toStringValue(x_idt_beyond_app_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_key).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-key", ::OpenAPI::toStringValue(x_idt_beyond_app_key));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITopupsApi::iatuTopupsReportsAllGetCallback);
    connect(this, &OAITopupsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITopupsApi::iatuTopupsReportsAllGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT iatuTopupsReportsAllGetSignal();
        Q_EMIT iatuTopupsReportsAllGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT iatuTopupsReportsAllGetSignalE(error_type, error_str);
        Q_EMIT iatuTopupsReportsAllGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT iatuTopupsReportsAllGetSignalError(error_type, error_str);
        Q_EMIT iatuTopupsReportsAllGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITopupsApi::iatuTopupsReportsPost(const QString &x_idt_beyond_app_id, const QString &x_idt_beyond_app_key, const OAITopupsReports &body) {
    QString fullPath = QString(_serverConfigs["iatuTopupsReportsPost"][_serverIndices.value("iatuTopupsReportsPost")].URL()+"/iatu/topups/reports");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_id).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-id", ::OpenAPI::toStringValue(x_idt_beyond_app_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_key).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-key", ::OpenAPI::toStringValue(x_idt_beyond_app_key));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITopupsApi::iatuTopupsReportsPostCallback);
    connect(this, &OAITopupsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITopupsApi::iatuTopupsReportsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT iatuTopupsReportsPostSignal();
        Q_EMIT iatuTopupsReportsPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT iatuTopupsReportsPostSignalE(error_type, error_str);
        Q_EMIT iatuTopupsReportsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT iatuTopupsReportsPostSignalError(error_type, error_str);
        Q_EMIT iatuTopupsReportsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITopupsApi::iatuTopupsReportsTotalsGet(const QString &x_idt_beyond_app_id, const QString &x_idt_beyond_app_key, const QString &date_from, const QString &date_to) {
    QString fullPath = QString(_serverConfigs["iatuTopupsReportsTotalsGet"][_serverIndices.value("iatuTopupsReportsTotalsGet")].URL()+"/iatu/topups/reports/totals");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "date_from", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("date_from")).append(querySuffix).append(QUrl::toPercentEncoding(date_from));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "date_to", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("date_to")).append(querySuffix).append(QUrl::toPercentEncoding(date_to));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_id).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-id", ::OpenAPI::toStringValue(x_idt_beyond_app_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_key).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-key", ::OpenAPI::toStringValue(x_idt_beyond_app_key));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITopupsApi::iatuTopupsReportsTotalsGetCallback);
    connect(this, &OAITopupsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITopupsApi::iatuTopupsReportsTotalsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT iatuTopupsReportsTotalsGetSignal();
        Q_EMIT iatuTopupsReportsTotalsGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT iatuTopupsReportsTotalsGetSignalE(error_type, error_str);
        Q_EMIT iatuTopupsReportsTotalsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT iatuTopupsReportsTotalsGetSignalError(error_type, error_str);
        Q_EMIT iatuTopupsReportsTotalsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITopupsApi::iatuTopupsReversePost(const QString &x_idt_beyond_app_id, const QString &x_idt_beyond_app_key, const OAITopupsReversal &body) {
    QString fullPath = QString(_serverConfigs["iatuTopupsReversePost"][_serverIndices.value("iatuTopupsReversePost")].URL()+"/iatu/topups/reverse");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = body.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_id).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-id", ::OpenAPI::toStringValue(x_idt_beyond_app_id));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_idt_beyond_app_key).isEmpty()) {
            input.headers.insert("x-idt-beyond-app-key", ::OpenAPI::toStringValue(x_idt_beyond_app_key));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITopupsApi::iatuTopupsReversePostCallback);
    connect(this, &OAITopupsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITopupsApi::iatuTopupsReversePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT iatuTopupsReversePostSignal();
        Q_EMIT iatuTopupsReversePostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT iatuTopupsReversePostSignalE(error_type, error_str);
        Q_EMIT iatuTopupsReversePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT iatuTopupsReversePostSignalError(error_type, error_str);
        Q_EMIT iatuTopupsReversePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITopupsApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
