/*
 * Lyft
 * Drive your app to success with Lyft's API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api-support@lyft.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.RideTypeEnum;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A non-guaranteed estimate of price
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:28:02.435628-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CostEstimate {
  public static final String SERIALIZED_NAME_COST_TOKEN = "cost_token";
  @SerializedName(SERIALIZED_NAME_COST_TOKEN)
  private String costToken;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "display_name";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_ESTIMATED_COST_CENTS_MAX = "estimated_cost_cents_max";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_COST_CENTS_MAX)
  private Integer estimatedCostCentsMax;

  public static final String SERIALIZED_NAME_ESTIMATED_COST_CENTS_MIN = "estimated_cost_cents_min";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_COST_CENTS_MIN)
  private Integer estimatedCostCentsMin;

  public static final String SERIALIZED_NAME_ESTIMATED_DISTANCE_MILES = "estimated_distance_miles";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_DISTANCE_MILES)
  private Double estimatedDistanceMiles;

  public static final String SERIALIZED_NAME_ESTIMATED_DURATION_SECONDS = "estimated_duration_seconds";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_DURATION_SECONDS)
  private Integer estimatedDurationSeconds;

  public static final String SERIALIZED_NAME_IS_VALID_ESTIMATE = "is_valid_estimate";
  @SerializedName(SERIALIZED_NAME_IS_VALID_ESTIMATE)
  private Boolean isValidEstimate;

  public static final String SERIALIZED_NAME_PRIMETIME_CONFIRMATION_TOKEN = "primetime_confirmation_token";
  @SerializedName(SERIALIZED_NAME_PRIMETIME_CONFIRMATION_TOKEN)
  private String primetimeConfirmationToken;

  public static final String SERIALIZED_NAME_PRIMETIME_PERCENTAGE = "primetime_percentage";
  @SerializedName(SERIALIZED_NAME_PRIMETIME_PERCENTAGE)
  private String primetimePercentage;

  public static final String SERIALIZED_NAME_RIDE_TYPE = "ride_type";
  @SerializedName(SERIALIZED_NAME_RIDE_TYPE)
  private RideTypeEnum rideType;

  public CostEstimate() {
  }

  public CostEstimate costToken(String costToken) {
    this.costToken = costToken;
    return this;
  }

  /**
   * A token that confirms the user has accepted current Prime Time and/or fixed price charges. See &#39;Request a Lyft&#39; for more details
   * @return costToken
   */
  @javax.annotation.Nullable
  public String getCostToken() {
    return costToken;
  }

  public void setCostToken(String costToken) {
    this.costToken = costToken;
  }


  public CostEstimate currency(String currency) {
    this.currency = currency;
    return this;
  }

  /**
   * The ISO 4217 currency code for the amount (e.g. &#39;USD&#39;)
   * @return currency
   */
  @javax.annotation.Nullable
  public String getCurrency() {
    return currency;
  }

  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public CostEstimate displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * A human readable description of the ride type
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public CostEstimate estimatedCostCentsMax(Integer estimatedCostCentsMax) {
    this.estimatedCostCentsMax = estimatedCostCentsMax;
    return this;
  }

  /**
   * Estimated upper bound for trip cost, in minor units (cents). Estimates are not guaranteed, and only provide a reasonable range based on current conditions. 
   * @return estimatedCostCentsMax
   */
  @javax.annotation.Nullable
  public Integer getEstimatedCostCentsMax() {
    return estimatedCostCentsMax;
  }

  public void setEstimatedCostCentsMax(Integer estimatedCostCentsMax) {
    this.estimatedCostCentsMax = estimatedCostCentsMax;
  }


  public CostEstimate estimatedCostCentsMin(Integer estimatedCostCentsMin) {
    this.estimatedCostCentsMin = estimatedCostCentsMin;
    return this;
  }

  /**
   * Estimated lower bound for trip cost, in minor units (cents). Estimates are not guaranteed, and only provide a reasonable range based on current conditions. 
   * @return estimatedCostCentsMin
   */
  @javax.annotation.Nullable
  public Integer getEstimatedCostCentsMin() {
    return estimatedCostCentsMin;
  }

  public void setEstimatedCostCentsMin(Integer estimatedCostCentsMin) {
    this.estimatedCostCentsMin = estimatedCostCentsMin;
  }


  public CostEstimate estimatedDistanceMiles(Double estimatedDistanceMiles) {
    this.estimatedDistanceMiles = estimatedDistanceMiles;
    return this;
  }

  /**
   * Estimated distance for this trip 
   * @return estimatedDistanceMiles
   */
  @javax.annotation.Nullable
  public Double getEstimatedDistanceMiles() {
    return estimatedDistanceMiles;
  }

  public void setEstimatedDistanceMiles(Double estimatedDistanceMiles) {
    this.estimatedDistanceMiles = estimatedDistanceMiles;
  }


  public CostEstimate estimatedDurationSeconds(Integer estimatedDurationSeconds) {
    this.estimatedDurationSeconds = estimatedDurationSeconds;
    return this;
  }

  /**
   * Estimated time to get from the start location to the end. 
   * @return estimatedDurationSeconds
   */
  @javax.annotation.Nullable
  public Integer getEstimatedDurationSeconds() {
    return estimatedDurationSeconds;
  }

  public void setEstimatedDurationSeconds(Integer estimatedDurationSeconds) {
    this.estimatedDurationSeconds = estimatedDurationSeconds;
  }


  public CostEstimate isValidEstimate(Boolean isValidEstimate) {
    this.isValidEstimate = isValidEstimate;
    return this;
  }

  /**
   * The validity of the cost estimate returned
   * @return isValidEstimate
   */
  @javax.annotation.Nullable
  public Boolean getIsValidEstimate() {
    return isValidEstimate;
  }

  public void setIsValidEstimate(Boolean isValidEstimate) {
    this.isValidEstimate = isValidEstimate;
  }


  public CostEstimate primetimeConfirmationToken(String primetimeConfirmationToken) {
    this.primetimeConfirmationToken = primetimeConfirmationToken;
    return this;
  }

  /**
   * This token is needed when requesting rides. (Deprecated)
   * @return primetimeConfirmationToken
   */
  @javax.annotation.Nullable
  public String getPrimetimeConfirmationToken() {
    return primetimeConfirmationToken;
  }

  public void setPrimetimeConfirmationToken(String primetimeConfirmationToken) {
    this.primetimeConfirmationToken = primetimeConfirmationToken;
  }


  public CostEstimate primetimePercentage(String primetimePercentage) {
    this.primetimePercentage = primetimePercentage;
    return this;
  }

  /**
   * Current Prime Time Percentage. Prime Time adds a percentage to ride costs, prior to other applicable fees. When ride requests greatly outnumber available drivers, our system will automatically turn on Prime Time. If Prime Time is inactive, the value returned will be &#39;0%&#39;. Note: The returned estimate already has Prime Time factored in. The value is returned here for reference and to allow users to confirm/accept Prime Time prior to initiating a ride. 
   * @return primetimePercentage
   */
  @javax.annotation.Nullable
  public String getPrimetimePercentage() {
    return primetimePercentage;
  }

  public void setPrimetimePercentage(String primetimePercentage) {
    this.primetimePercentage = primetimePercentage;
  }


  public CostEstimate rideType(RideTypeEnum rideType) {
    this.rideType = rideType;
    return this;
  }

  /**
   * Get rideType
   * @return rideType
   */
  @javax.annotation.Nullable
  public RideTypeEnum getRideType() {
    return rideType;
  }

  public void setRideType(RideTypeEnum rideType) {
    this.rideType = rideType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CostEstimate costEstimate = (CostEstimate) o;
    return Objects.equals(this.costToken, costEstimate.costToken) &&
        Objects.equals(this.currency, costEstimate.currency) &&
        Objects.equals(this.displayName, costEstimate.displayName) &&
        Objects.equals(this.estimatedCostCentsMax, costEstimate.estimatedCostCentsMax) &&
        Objects.equals(this.estimatedCostCentsMin, costEstimate.estimatedCostCentsMin) &&
        Objects.equals(this.estimatedDistanceMiles, costEstimate.estimatedDistanceMiles) &&
        Objects.equals(this.estimatedDurationSeconds, costEstimate.estimatedDurationSeconds) &&
        Objects.equals(this.isValidEstimate, costEstimate.isValidEstimate) &&
        Objects.equals(this.primetimeConfirmationToken, costEstimate.primetimeConfirmationToken) &&
        Objects.equals(this.primetimePercentage, costEstimate.primetimePercentage) &&
        Objects.equals(this.rideType, costEstimate.rideType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(costToken, currency, displayName, estimatedCostCentsMax, estimatedCostCentsMin, estimatedDistanceMiles, estimatedDurationSeconds, isValidEstimate, primetimeConfirmationToken, primetimePercentage, rideType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CostEstimate {\n");
    sb.append("    costToken: ").append(toIndentedString(costToken)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    estimatedCostCentsMax: ").append(toIndentedString(estimatedCostCentsMax)).append("\n");
    sb.append("    estimatedCostCentsMin: ").append(toIndentedString(estimatedCostCentsMin)).append("\n");
    sb.append("    estimatedDistanceMiles: ").append(toIndentedString(estimatedDistanceMiles)).append("\n");
    sb.append("    estimatedDurationSeconds: ").append(toIndentedString(estimatedDurationSeconds)).append("\n");
    sb.append("    isValidEstimate: ").append(toIndentedString(isValidEstimate)).append("\n");
    sb.append("    primetimeConfirmationToken: ").append(toIndentedString(primetimeConfirmationToken)).append("\n");
    sb.append("    primetimePercentage: ").append(toIndentedString(primetimePercentage)).append("\n");
    sb.append("    rideType: ").append(toIndentedString(rideType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cost_token");
    openapiFields.add("currency");
    openapiFields.add("display_name");
    openapiFields.add("estimated_cost_cents_max");
    openapiFields.add("estimated_cost_cents_min");
    openapiFields.add("estimated_distance_miles");
    openapiFields.add("estimated_duration_seconds");
    openapiFields.add("is_valid_estimate");
    openapiFields.add("primetime_confirmation_token");
    openapiFields.add("primetime_percentage");
    openapiFields.add("ride_type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CostEstimate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CostEstimate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CostEstimate is not found in the empty JSON string", CostEstimate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CostEstimate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CostEstimate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("cost_token") != null && !jsonObj.get("cost_token").isJsonNull()) && !jsonObj.get("cost_token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cost_token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cost_token").toString()));
      }
      if ((jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) && !jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      if ((jsonObj.get("display_name") != null && !jsonObj.get("display_name").isJsonNull()) && !jsonObj.get("display_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `display_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("display_name").toString()));
      }
      if ((jsonObj.get("primetime_confirmation_token") != null && !jsonObj.get("primetime_confirmation_token").isJsonNull()) && !jsonObj.get("primetime_confirmation_token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `primetime_confirmation_token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("primetime_confirmation_token").toString()));
      }
      if ((jsonObj.get("primetime_percentage") != null && !jsonObj.get("primetime_percentage").isJsonNull()) && !jsonObj.get("primetime_percentage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `primetime_percentage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("primetime_percentage").toString()));
      }
      // validate the optional field `ride_type`
      if (jsonObj.get("ride_type") != null && !jsonObj.get("ride_type").isJsonNull()) {
        RideTypeEnum.validateJsonElement(jsonObj.get("ride_type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CostEstimate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CostEstimate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CostEstimate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CostEstimate.class));

       return (TypeAdapter<T>) new TypeAdapter<CostEstimate>() {
           @Override
           public void write(JsonWriter out, CostEstimate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CostEstimate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CostEstimate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CostEstimate
   * @throws IOException if the JSON string is invalid with respect to CostEstimate
   */
  public static CostEstimate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CostEstimate.class);
  }

  /**
   * Convert an instance of CostEstimate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

