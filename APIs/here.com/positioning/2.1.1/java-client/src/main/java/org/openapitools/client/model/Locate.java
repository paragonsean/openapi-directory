/*
 * HERE Network Positioning API v2
 * Positioning API accepts requests with radio network measurements and replies with corresponding location estimate. For more details and examples, see [Developer's Guide](https://developer.here.com/documentation/positioning). Cellular measurements are given in terms defined in 3GPP and 3GGP2 specifications, see the corresponsing documentation at http://www.3gpp.org.  Breaking changes from v1:   - JSON fields     `altaccuracy`, `baselat`, `baselng`, `cellparams`, `pilotpower`, `pnoffset`, `powrx`, `rxlevel`,     have been deprecated and replaced with     `altAccuracy`, `baseLat`, `baseLng`, `cellParams`, `pilotPower`, `pnOffset`, `rss`, `rxLevel`     respectively.   - Dependent parameters combined as a subobject.     - CDMA, GSM, WCDMA, TD-SCDMA and LTE local identification parameters for serving cell moved under `localId` property.     - GSM neighbor global ID: `lac` and `cid` for neighbor cell moved under `globalIdentity` property. 
 *
 * The version of the OpenAPI document: 2.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Cdma;
import org.openapitools.client.model.ClientInfo;
import org.openapitools.client.model.Gsm;
import org.openapitools.client.model.Lte;
import org.openapitools.client.model.Tdscdma;
import org.openapitools.client.model.Wcdma;
import org.openapitools.client.model.WlanLocate;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Object wrapping the location data submitted in a request for a position. At least one of &#x60;gsm&#x60;, &#x60;wcdma&#x60;, &#x60;tdscdma&#x60;, &#x60;lte&#x60;, &#x60;cdma&#x60;, or &#x60;wlan&#x60; elements is required. Array elements should be unique within the request. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:33:37.764847-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Locate {
  public static final String SERIALIZED_NAME_CDMA = "cdma";
  @SerializedName(SERIALIZED_NAME_CDMA)
  private List<Cdma> cdma = new ArrayList<>();

  public static final String SERIALIZED_NAME_CLIENT = "client";
  @SerializedName(SERIALIZED_NAME_CLIENT)
  private ClientInfo client;

  public static final String SERIALIZED_NAME_GSM = "gsm";
  @SerializedName(SERIALIZED_NAME_GSM)
  private List<Gsm> gsm = new ArrayList<>();

  public static final String SERIALIZED_NAME_LTE = "lte";
  @SerializedName(SERIALIZED_NAME_LTE)
  private List<Lte> lte = new ArrayList<>();

  public static final String SERIALIZED_NAME_TDSCDMA = "tdscdma";
  @SerializedName(SERIALIZED_NAME_TDSCDMA)
  private List<Tdscdma> tdscdma = new ArrayList<>();

  public static final String SERIALIZED_NAME_WCDMA = "wcdma";
  @SerializedName(SERIALIZED_NAME_WCDMA)
  private List<Wcdma> wcdma = new ArrayList<>();

  public static final String SERIALIZED_NAME_WLAN = "wlan";
  @SerializedName(SERIALIZED_NAME_WLAN)
  private List<WlanLocate> wlan = new ArrayList<>();

  public Locate() {
  }

  public Locate cdma(List<Cdma> cdma) {
    this.cdma = cdma;
    return this;
  }

  public Locate addCdmaItem(Cdma cdmaItem) {
    if (this.cdma == null) {
      this.cdma = new ArrayList<>();
    }
    this.cdma.add(cdmaItem);
    return this;
  }

  /**
   * CDMA cells (CDMA2000)
   * @return cdma
   */
  @javax.annotation.Nullable
  public List<Cdma> getCdma() {
    return cdma;
  }

  public void setCdma(List<Cdma> cdma) {
    this.cdma = cdma;
  }


  public Locate client(ClientInfo client) {
    this.client = client;
    return this;
  }

  /**
   * Get client
   * @return client
   */
  @javax.annotation.Nullable
  public ClientInfo getClient() {
    return client;
  }

  public void setClient(ClientInfo client) {
    this.client = client;
  }


  public Locate gsm(List<Gsm> gsm) {
    this.gsm = gsm;
    return this;
  }

  public Locate addGsmItem(Gsm gsmItem) {
    if (this.gsm == null) {
      this.gsm = new ArrayList<>();
    }
    this.gsm.add(gsmItem);
    return this;
  }

  /**
   * GSM cells (GERAN)
   * @return gsm
   */
  @javax.annotation.Nullable
  public List<Gsm> getGsm() {
    return gsm;
  }

  public void setGsm(List<Gsm> gsm) {
    this.gsm = gsm;
  }


  public Locate lte(List<Lte> lte) {
    this.lte = lte;
    return this;
  }

  public Locate addLteItem(Lte lteItem) {
    if (this.lte == null) {
      this.lte = new ArrayList<>();
    }
    this.lte.add(lteItem);
    return this;
  }

  /**
   * LTE cells (E-UTRA, 4G)
   * @return lte
   */
  @javax.annotation.Nullable
  public List<Lte> getLte() {
    return lte;
  }

  public void setLte(List<Lte> lte) {
    this.lte = lte;
  }


  public Locate tdscdma(List<Tdscdma> tdscdma) {
    this.tdscdma = tdscdma;
    return this;
  }

  public Locate addTdscdmaItem(Tdscdma tdscdmaItem) {
    if (this.tdscdma == null) {
      this.tdscdma = new ArrayList<>();
    }
    this.tdscdma.add(tdscdmaItem);
    return this;
  }

  /**
   * TD-SCDMA cells (UTRA-TDD, 3G UMTS TDD)
   * @return tdscdma
   */
  @javax.annotation.Nullable
  public List<Tdscdma> getTdscdma() {
    return tdscdma;
  }

  public void setTdscdma(List<Tdscdma> tdscdma) {
    this.tdscdma = tdscdma;
  }


  public Locate wcdma(List<Wcdma> wcdma) {
    this.wcdma = wcdma;
    return this;
  }

  public Locate addWcdmaItem(Wcdma wcdmaItem) {
    if (this.wcdma == null) {
      this.wcdma = new ArrayList<>();
    }
    this.wcdma.add(wcdmaItem);
    return this;
  }

  /**
   * WCDMA cells (UTRA-FDD, 3G UMTS)
   * @return wcdma
   */
  @javax.annotation.Nullable
  public List<Wcdma> getWcdma() {
    return wcdma;
  }

  public void setWcdma(List<Wcdma> wcdma) {
    this.wcdma = wcdma;
  }


  public Locate wlan(List<WlanLocate> wlan) {
    this.wlan = wlan;
    return this;
  }

  public Locate addWlanItem(WlanLocate wlanItem) {
    if (this.wlan == null) {
      this.wlan = new ArrayList<>();
    }
    this.wlan.add(wlanItem);
    return this;
  }

  /**
   * WLAN access positions. For privacy reasons positioning based on a single WLAN AP is not possible; there has to be at least one other matching wlan or cell. Alternatively, you can allow fallbacks to less accurate single WLAN AP location estimates by using the setting &#x60;fallback&#x3D;singleWifi&#x60;. 
   * @return wlan
   */
  @javax.annotation.Nullable
  public List<WlanLocate> getWlan() {
    return wlan;
  }

  public void setWlan(List<WlanLocate> wlan) {
    this.wlan = wlan;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Locate locate = (Locate) o;
    return Objects.equals(this.cdma, locate.cdma) &&
        Objects.equals(this.client, locate.client) &&
        Objects.equals(this.gsm, locate.gsm) &&
        Objects.equals(this.lte, locate.lte) &&
        Objects.equals(this.tdscdma, locate.tdscdma) &&
        Objects.equals(this.wcdma, locate.wcdma) &&
        Objects.equals(this.wlan, locate.wlan);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cdma, client, gsm, lte, tdscdma, wcdma, wlan);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Locate {\n");
    sb.append("    cdma: ").append(toIndentedString(cdma)).append("\n");
    sb.append("    client: ").append(toIndentedString(client)).append("\n");
    sb.append("    gsm: ").append(toIndentedString(gsm)).append("\n");
    sb.append("    lte: ").append(toIndentedString(lte)).append("\n");
    sb.append("    tdscdma: ").append(toIndentedString(tdscdma)).append("\n");
    sb.append("    wcdma: ").append(toIndentedString(wcdma)).append("\n");
    sb.append("    wlan: ").append(toIndentedString(wlan)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cdma");
    openapiFields.add("client");
    openapiFields.add("gsm");
    openapiFields.add("lte");
    openapiFields.add("tdscdma");
    openapiFields.add("wcdma");
    openapiFields.add("wlan");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Locate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Locate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Locate is not found in the empty JSON string", Locate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Locate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Locate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("cdma") != null && !jsonObj.get("cdma").isJsonNull()) {
        JsonArray jsonArraycdma = jsonObj.getAsJsonArray("cdma");
        if (jsonArraycdma != null) {
          // ensure the json data is an array
          if (!jsonObj.get("cdma").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `cdma` to be an array in the JSON string but got `%s`", jsonObj.get("cdma").toString()));
          }

          // validate the optional field `cdma` (array)
          for (int i = 0; i < jsonArraycdma.size(); i++) {
            Cdma.validateJsonElement(jsonArraycdma.get(i));
          };
        }
      }
      // validate the optional field `client`
      if (jsonObj.get("client") != null && !jsonObj.get("client").isJsonNull()) {
        ClientInfo.validateJsonElement(jsonObj.get("client"));
      }
      if (jsonObj.get("gsm") != null && !jsonObj.get("gsm").isJsonNull()) {
        JsonArray jsonArraygsm = jsonObj.getAsJsonArray("gsm");
        if (jsonArraygsm != null) {
          // ensure the json data is an array
          if (!jsonObj.get("gsm").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `gsm` to be an array in the JSON string but got `%s`", jsonObj.get("gsm").toString()));
          }

          // validate the optional field `gsm` (array)
          for (int i = 0; i < jsonArraygsm.size(); i++) {
            Gsm.validateJsonElement(jsonArraygsm.get(i));
          };
        }
      }
      if (jsonObj.get("lte") != null && !jsonObj.get("lte").isJsonNull()) {
        JsonArray jsonArraylte = jsonObj.getAsJsonArray("lte");
        if (jsonArraylte != null) {
          // ensure the json data is an array
          if (!jsonObj.get("lte").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `lte` to be an array in the JSON string but got `%s`", jsonObj.get("lte").toString()));
          }

          // validate the optional field `lte` (array)
          for (int i = 0; i < jsonArraylte.size(); i++) {
            Lte.validateJsonElement(jsonArraylte.get(i));
          };
        }
      }
      if (jsonObj.get("tdscdma") != null && !jsonObj.get("tdscdma").isJsonNull()) {
        JsonArray jsonArraytdscdma = jsonObj.getAsJsonArray("tdscdma");
        if (jsonArraytdscdma != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tdscdma").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tdscdma` to be an array in the JSON string but got `%s`", jsonObj.get("tdscdma").toString()));
          }

          // validate the optional field `tdscdma` (array)
          for (int i = 0; i < jsonArraytdscdma.size(); i++) {
            Tdscdma.validateJsonElement(jsonArraytdscdma.get(i));
          };
        }
      }
      if (jsonObj.get("wcdma") != null && !jsonObj.get("wcdma").isJsonNull()) {
        JsonArray jsonArraywcdma = jsonObj.getAsJsonArray("wcdma");
        if (jsonArraywcdma != null) {
          // ensure the json data is an array
          if (!jsonObj.get("wcdma").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `wcdma` to be an array in the JSON string but got `%s`", jsonObj.get("wcdma").toString()));
          }

          // validate the optional field `wcdma` (array)
          for (int i = 0; i < jsonArraywcdma.size(); i++) {
            Wcdma.validateJsonElement(jsonArraywcdma.get(i));
          };
        }
      }
      if (jsonObj.get("wlan") != null && !jsonObj.get("wlan").isJsonNull()) {
        JsonArray jsonArraywlan = jsonObj.getAsJsonArray("wlan");
        if (jsonArraywlan != null) {
          // ensure the json data is an array
          if (!jsonObj.get("wlan").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `wlan` to be an array in the JSON string but got `%s`", jsonObj.get("wlan").toString()));
          }

          // validate the optional field `wlan` (array)
          for (int i = 0; i < jsonArraywlan.size(); i++) {
            WlanLocate.validateJsonElement(jsonArraywlan.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Locate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Locate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Locate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Locate.class));

       return (TypeAdapter<T>) new TypeAdapter<Locate>() {
           @Override
           public void write(JsonWriter out, Locate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Locate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Locate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Locate
   * @throws IOException if the JSON string is invalid with respect to Locate
   */
  public static Locate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Locate.class);
  }

  /**
   * Convert an instance of Locate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

