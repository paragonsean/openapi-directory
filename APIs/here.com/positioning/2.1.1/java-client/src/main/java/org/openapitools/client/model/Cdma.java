/*
 * HERE Network Positioning API v2
 * Positioning API accepts requests with radio network measurements and replies with corresponding location estimate. For more details and examples, see [Developer's Guide](https://developer.here.com/documentation/positioning). Cellular measurements are given in terms defined in 3GPP and 3GGP2 specifications, see the corresponsing documentation at http://www.3gpp.org.  Breaking changes from v1:   - JSON fields     `altaccuracy`, `baselat`, `baselng`, `cellparams`, `pilotpower`, `pnoffset`, `powrx`, `rxlevel`,     have been deprecated and replaced with     `altAccuracy`, `baseLat`, `baseLng`, `cellParams`, `pilotPower`, `pnOffset`, `rss`, `rxLevel`     respectively.   - Dependent parameters combined as a subobject.     - CDMA, GSM, WCDMA, TD-SCDMA and LTE local identification parameters for serving cell moved under `localId` property.     - GSM neighbor global ID: `lac` and `cid` for neighbor cell moved under `globalIdentity` property. 
 *
 * The version of the OpenAPI document: 2.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CdmaLocalId;
import org.openapitools.client.model.CdmaNmr;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CDMA measurement
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:33:37.764847-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Cdma {
  public static final String SERIALIZED_NAME_BASE_LAT = "baseLat";
  @SerializedName(SERIALIZED_NAME_BASE_LAT)
  private BigDecimal baseLat;

  public static final String SERIALIZED_NAME_BASE_LNG = "baseLng";
  @SerializedName(SERIALIZED_NAME_BASE_LNG)
  private BigDecimal baseLng;

  public static final String SERIALIZED_NAME_BSID = "bsid";
  @SerializedName(SERIALIZED_NAME_BSID)
  private Integer bsid;

  public static final String SERIALIZED_NAME_LOCAL_ID = "localId";
  @SerializedName(SERIALIZED_NAME_LOCAL_ID)
  private CdmaLocalId localId;

  public static final String SERIALIZED_NAME_NID = "nid";
  @SerializedName(SERIALIZED_NAME_NID)
  private Integer nid;

  public static final String SERIALIZED_NAME_NMR = "nmr";
  @SerializedName(SERIALIZED_NAME_NMR)
  private List<CdmaNmr> nmr = new ArrayList<>();

  public static final String SERIALIZED_NAME_PILOT_POWER = "pilotPower";
  @SerializedName(SERIALIZED_NAME_PILOT_POWER)
  private Integer pilotPower;

  public static final String SERIALIZED_NAME_RZ = "rz";
  @SerializedName(SERIALIZED_NAME_RZ)
  private Integer rz;

  public static final String SERIALIZED_NAME_SID = "sid";
  @SerializedName(SERIALIZED_NAME_SID)
  private Integer sid;

  public Cdma() {
  }

  public Cdma baseLat(BigDecimal baseLat) {
    this.baseLat = baseLat;
    return this;
  }

  /**
   * Base station latitude
   * minimum: -90
   * maximum: 90
   * @return baseLat
   */
  @javax.annotation.Nullable
  public BigDecimal getBaseLat() {
    return baseLat;
  }

  public void setBaseLat(BigDecimal baseLat) {
    this.baseLat = baseLat;
  }


  public Cdma baseLng(BigDecimal baseLng) {
    this.baseLng = baseLng;
    return this;
  }

  /**
   * Base station longitude
   * minimum: -180
   * maximum: 180
   * @return baseLng
   */
  @javax.annotation.Nullable
  public BigDecimal getBaseLng() {
    return baseLng;
  }

  public void setBaseLng(BigDecimal baseLng) {
    this.baseLng = baseLng;
  }


  public Cdma bsid(Integer bsid) {
    this.bsid = bsid;
    return this;
  }

  /**
   * Base Station ID (CDMA BSID, BID)
   * minimum: 0
   * maximum: 65535
   * @return bsid
   */
  @javax.annotation.Nonnull
  public Integer getBsid() {
    return bsid;
  }

  public void setBsid(Integer bsid) {
    this.bsid = bsid;
  }


  public Cdma localId(CdmaLocalId localId) {
    this.localId = localId;
    return this;
  }

  /**
   * Get localId
   * @return localId
   */
  @javax.annotation.Nullable
  public CdmaLocalId getLocalId() {
    return localId;
  }

  public void setLocalId(CdmaLocalId localId) {
    this.localId = localId;
  }


  public Cdma nid(Integer nid) {
    this.nid = nid;
    return this;
  }

  /**
   * Network ID (NID)
   * minimum: 0
   * maximum: 65535
   * @return nid
   */
  @javax.annotation.Nonnull
  public Integer getNid() {
    return nid;
  }

  public void setNid(Integer nid) {
    this.nid = nid;
  }


  public Cdma nmr(List<CdmaNmr> nmr) {
    this.nmr = nmr;
    return this;
  }

  public Cdma addNmrItem(CdmaNmr nmrItem) {
    if (this.nmr == null) {
      this.nmr = new ArrayList<>();
    }
    this.nmr.add(nmrItem);
    return this;
  }

  /**
   * CDMA Network measurements
   * @return nmr
   */
  @javax.annotation.Nullable
  public List<CdmaNmr> getNmr() {
    return nmr;
  }

  public void setNmr(List<CdmaNmr> nmr) {
    this.nmr = nmr;
  }


  public Cdma pilotPower(Integer pilotPower) {
    this.pilotPower = pilotPower;
    return this;
  }

  /**
   * Pilot Power (dBm). If Pilot Power is not available directly, it needs to be calculated from Total Power in the band and Pilot Strength with respect to the Total Power. Pilot power less than -142dBm should be mapped to -142. Pilot power greater than -49dBm should be mapped to -49. 
   * minimum: -142
   * maximum: -49
   * @return pilotPower
   */
  @javax.annotation.Nullable
  public Integer getPilotPower() {
    return pilotPower;
  }

  public void setPilotPower(Integer pilotPower) {
    this.pilotPower = pilotPower;
  }


  public Cdma rz(Integer rz) {
    this.rz = rz;
    return this;
  }

  /**
   * CDMA Registration Zone (RZ)
   * minimum: 0
   * maximum: 4095
   * @return rz
   */
  @javax.annotation.Nullable
  public Integer getRz() {
    return rz;
  }

  public void setRz(Integer rz) {
    this.rz = rz;
  }


  public Cdma sid(Integer sid) {
    this.sid = sid;
    return this;
  }

  /**
   * System ID (SID)
   * minimum: 1
   * maximum: 32767
   * @return sid
   */
  @javax.annotation.Nonnull
  public Integer getSid() {
    return sid;
  }

  public void setSid(Integer sid) {
    this.sid = sid;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Cdma cdma = (Cdma) o;
    return Objects.equals(this.baseLat, cdma.baseLat) &&
        Objects.equals(this.baseLng, cdma.baseLng) &&
        Objects.equals(this.bsid, cdma.bsid) &&
        Objects.equals(this.localId, cdma.localId) &&
        Objects.equals(this.nid, cdma.nid) &&
        Objects.equals(this.nmr, cdma.nmr) &&
        Objects.equals(this.pilotPower, cdma.pilotPower) &&
        Objects.equals(this.rz, cdma.rz) &&
        Objects.equals(this.sid, cdma.sid);
  }

  @Override
  public int hashCode() {
    return Objects.hash(baseLat, baseLng, bsid, localId, nid, nmr, pilotPower, rz, sid);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Cdma {\n");
    sb.append("    baseLat: ").append(toIndentedString(baseLat)).append("\n");
    sb.append("    baseLng: ").append(toIndentedString(baseLng)).append("\n");
    sb.append("    bsid: ").append(toIndentedString(bsid)).append("\n");
    sb.append("    localId: ").append(toIndentedString(localId)).append("\n");
    sb.append("    nid: ").append(toIndentedString(nid)).append("\n");
    sb.append("    nmr: ").append(toIndentedString(nmr)).append("\n");
    sb.append("    pilotPower: ").append(toIndentedString(pilotPower)).append("\n");
    sb.append("    rz: ").append(toIndentedString(rz)).append("\n");
    sb.append("    sid: ").append(toIndentedString(sid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("baseLat");
    openapiFields.add("baseLng");
    openapiFields.add("bsid");
    openapiFields.add("localId");
    openapiFields.add("nid");
    openapiFields.add("nmr");
    openapiFields.add("pilotPower");
    openapiFields.add("rz");
    openapiFields.add("sid");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("bsid");
    openapiRequiredFields.add("nid");
    openapiRequiredFields.add("sid");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Cdma
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Cdma.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Cdma is not found in the empty JSON string", Cdma.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Cdma.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Cdma` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Cdma.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `localId`
      if (jsonObj.get("localId") != null && !jsonObj.get("localId").isJsonNull()) {
        CdmaLocalId.validateJsonElement(jsonObj.get("localId"));
      }
      if (jsonObj.get("nmr") != null && !jsonObj.get("nmr").isJsonNull()) {
        JsonArray jsonArraynmr = jsonObj.getAsJsonArray("nmr");
        if (jsonArraynmr != null) {
          // ensure the json data is an array
          if (!jsonObj.get("nmr").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `nmr` to be an array in the JSON string but got `%s`", jsonObj.get("nmr").toString()));
          }

          // validate the optional field `nmr` (array)
          for (int i = 0; i < jsonArraynmr.size(); i++) {
            CdmaNmr.validateJsonElement(jsonArraynmr.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Cdma.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Cdma' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Cdma> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Cdma.class));

       return (TypeAdapter<T>) new TypeAdapter<Cdma>() {
           @Override
           public void write(JsonWriter out, Cdma value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Cdma read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Cdma given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Cdma
   * @throws IOException if the JSON string is invalid with respect to Cdma
   */
  public static Cdma fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Cdma.class);
  }

  /**
   * Convert an instance of Cdma to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

