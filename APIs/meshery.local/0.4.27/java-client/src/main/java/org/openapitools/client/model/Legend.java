/*
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * for a graph panel
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:59:51.881749-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Legend {
  public static final String SERIALIZED_NAME_ALIGN_AS_TABLE = "alignAsTable";
  @SerializedName(SERIALIZED_NAME_ALIGN_AS_TABLE)
  private Boolean alignAsTable;

  public static final String SERIALIZED_NAME_AVG = "avg";
  @SerializedName(SERIALIZED_NAME_AVG)
  private Boolean avg;

  public static final String SERIALIZED_NAME_CURRENT = "current";
  @SerializedName(SERIALIZED_NAME_CURRENT)
  private Boolean current;

  public static final String SERIALIZED_NAME_HIDE_EMPTY = "hideEmpty";
  @SerializedName(SERIALIZED_NAME_HIDE_EMPTY)
  private Boolean hideEmpty;

  public static final String SERIALIZED_NAME_HIDE_ZERO = "hideZero";
  @SerializedName(SERIALIZED_NAME_HIDE_ZERO)
  private Boolean hideZero;

  public static final String SERIALIZED_NAME_MAX = "max";
  @SerializedName(SERIALIZED_NAME_MAX)
  private Boolean max;

  public static final String SERIALIZED_NAME_MIN = "min";
  @SerializedName(SERIALIZED_NAME_MIN)
  private Boolean min;

  public static final String SERIALIZED_NAME_RIGHT_SIDE = "rightSide";
  @SerializedName(SERIALIZED_NAME_RIGHT_SIDE)
  private Boolean rightSide;

  public static final String SERIALIZED_NAME_SHOW = "show";
  @SerializedName(SERIALIZED_NAME_SHOW)
  private Boolean show;

  public static final String SERIALIZED_NAME_SIDE_WIDTH = "sideWidth";
  @SerializedName(SERIALIZED_NAME_SIDE_WIDTH)
  private Integer sideWidth;

  public static final String SERIALIZED_NAME_TOTAL = "total";
  @SerializedName(SERIALIZED_NAME_TOTAL)
  private Boolean total;

  public static final String SERIALIZED_NAME_VALUES = "values";
  @SerializedName(SERIALIZED_NAME_VALUES)
  private Boolean values;

  public Legend() {
  }

  public Legend alignAsTable(Boolean alignAsTable) {
    this.alignAsTable = alignAsTable;
    return this;
  }

  /**
   * Get alignAsTable
   * @return alignAsTable
   */
  @javax.annotation.Nullable
  public Boolean getAlignAsTable() {
    return alignAsTable;
  }

  public void setAlignAsTable(Boolean alignAsTable) {
    this.alignAsTable = alignAsTable;
  }


  public Legend avg(Boolean avg) {
    this.avg = avg;
    return this;
  }

  /**
   * Get avg
   * @return avg
   */
  @javax.annotation.Nullable
  public Boolean getAvg() {
    return avg;
  }

  public void setAvg(Boolean avg) {
    this.avg = avg;
  }


  public Legend current(Boolean current) {
    this.current = current;
    return this;
  }

  /**
   * Get current
   * @return current
   */
  @javax.annotation.Nullable
  public Boolean getCurrent() {
    return current;
  }

  public void setCurrent(Boolean current) {
    this.current = current;
  }


  public Legend hideEmpty(Boolean hideEmpty) {
    this.hideEmpty = hideEmpty;
    return this;
  }

  /**
   * Get hideEmpty
   * @return hideEmpty
   */
  @javax.annotation.Nullable
  public Boolean getHideEmpty() {
    return hideEmpty;
  }

  public void setHideEmpty(Boolean hideEmpty) {
    this.hideEmpty = hideEmpty;
  }


  public Legend hideZero(Boolean hideZero) {
    this.hideZero = hideZero;
    return this;
  }

  /**
   * Get hideZero
   * @return hideZero
   */
  @javax.annotation.Nullable
  public Boolean getHideZero() {
    return hideZero;
  }

  public void setHideZero(Boolean hideZero) {
    this.hideZero = hideZero;
  }


  public Legend max(Boolean max) {
    this.max = max;
    return this;
  }

  /**
   * Get max
   * @return max
   */
  @javax.annotation.Nullable
  public Boolean getMax() {
    return max;
  }

  public void setMax(Boolean max) {
    this.max = max;
  }


  public Legend min(Boolean min) {
    this.min = min;
    return this;
  }

  /**
   * Get min
   * @return min
   */
  @javax.annotation.Nullable
  public Boolean getMin() {
    return min;
  }

  public void setMin(Boolean min) {
    this.min = min;
  }


  public Legend rightSide(Boolean rightSide) {
    this.rightSide = rightSide;
    return this;
  }

  /**
   * Get rightSide
   * @return rightSide
   */
  @javax.annotation.Nullable
  public Boolean getRightSide() {
    return rightSide;
  }

  public void setRightSide(Boolean rightSide) {
    this.rightSide = rightSide;
  }


  public Legend show(Boolean show) {
    this.show = show;
    return this;
  }

  /**
   * Get show
   * @return show
   */
  @javax.annotation.Nullable
  public Boolean getShow() {
    return show;
  }

  public void setShow(Boolean show) {
    this.show = show;
  }


  public Legend sideWidth(Integer sideWidth) {
    this.sideWidth = sideWidth;
    return this;
  }

  /**
   * Get sideWidth
   * @return sideWidth
   */
  @javax.annotation.Nullable
  public Integer getSideWidth() {
    return sideWidth;
  }

  public void setSideWidth(Integer sideWidth) {
    this.sideWidth = sideWidth;
  }


  public Legend total(Boolean total) {
    this.total = total;
    return this;
  }

  /**
   * Get total
   * @return total
   */
  @javax.annotation.Nullable
  public Boolean getTotal() {
    return total;
  }

  public void setTotal(Boolean total) {
    this.total = total;
  }


  public Legend values(Boolean values) {
    this.values = values;
    return this;
  }

  /**
   * Get values
   * @return values
   */
  @javax.annotation.Nullable
  public Boolean getValues() {
    return values;
  }

  public void setValues(Boolean values) {
    this.values = values;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Legend legend = (Legend) o;
    return Objects.equals(this.alignAsTable, legend.alignAsTable) &&
        Objects.equals(this.avg, legend.avg) &&
        Objects.equals(this.current, legend.current) &&
        Objects.equals(this.hideEmpty, legend.hideEmpty) &&
        Objects.equals(this.hideZero, legend.hideZero) &&
        Objects.equals(this.max, legend.max) &&
        Objects.equals(this.min, legend.min) &&
        Objects.equals(this.rightSide, legend.rightSide) &&
        Objects.equals(this.show, legend.show) &&
        Objects.equals(this.sideWidth, legend.sideWidth) &&
        Objects.equals(this.total, legend.total) &&
        Objects.equals(this.values, legend.values);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alignAsTable, avg, current, hideEmpty, hideZero, max, min, rightSide, show, sideWidth, total, values);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Legend {\n");
    sb.append("    alignAsTable: ").append(toIndentedString(alignAsTable)).append("\n");
    sb.append("    avg: ").append(toIndentedString(avg)).append("\n");
    sb.append("    current: ").append(toIndentedString(current)).append("\n");
    sb.append("    hideEmpty: ").append(toIndentedString(hideEmpty)).append("\n");
    sb.append("    hideZero: ").append(toIndentedString(hideZero)).append("\n");
    sb.append("    max: ").append(toIndentedString(max)).append("\n");
    sb.append("    min: ").append(toIndentedString(min)).append("\n");
    sb.append("    rightSide: ").append(toIndentedString(rightSide)).append("\n");
    sb.append("    show: ").append(toIndentedString(show)).append("\n");
    sb.append("    sideWidth: ").append(toIndentedString(sideWidth)).append("\n");
    sb.append("    total: ").append(toIndentedString(total)).append("\n");
    sb.append("    values: ").append(toIndentedString(values)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alignAsTable");
    openapiFields.add("avg");
    openapiFields.add("current");
    openapiFields.add("hideEmpty");
    openapiFields.add("hideZero");
    openapiFields.add("max");
    openapiFields.add("min");
    openapiFields.add("rightSide");
    openapiFields.add("show");
    openapiFields.add("sideWidth");
    openapiFields.add("total");
    openapiFields.add("values");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Legend
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Legend.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Legend is not found in the empty JSON string", Legend.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Legend.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Legend` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Legend.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Legend' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Legend> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Legend.class));

       return (TypeAdapter<T>) new TypeAdapter<Legend>() {
           @Override
           public void write(JsonWriter out, Legend value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Legend read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Legend given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Legend
   * @throws IOException if the JSON string is invalid with respect to Legend
   */
  public static Legend fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Legend.class);
  }

  /**
   * Convert an instance of Legend to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

