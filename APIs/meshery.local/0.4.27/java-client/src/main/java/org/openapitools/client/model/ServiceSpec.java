/*
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ServicePort;
import org.openapitools.client.model.SessionAffinityConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ServiceSpec
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:59:51.881749-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ServiceSpec {
  public static final String SERIALIZED_NAME_CLUSTER_I_P = "clusterIP";
  @SerializedName(SERIALIZED_NAME_CLUSTER_I_P)
  private String clusterIP;

  public static final String SERIALIZED_NAME_EXTERNAL_I_PS = "externalIPs";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_I_PS)
  private List<String> externalIPs = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXTERNAL_NAME = "externalName";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_NAME)
  private String externalName;

  public static final String SERIALIZED_NAME_EXTERNAL_TRAFFIC_POLICY = "externalTrafficPolicy";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_TRAFFIC_POLICY)
  private String externalTrafficPolicy;

  public static final String SERIALIZED_NAME_HEALTH_CHECK_NODE_PORT = "healthCheckNodePort";
  @SerializedName(SERIALIZED_NAME_HEALTH_CHECK_NODE_PORT)
  private Integer healthCheckNodePort;

  public static final String SERIALIZED_NAME_IP_FAMILY = "ipFamily";
  @SerializedName(SERIALIZED_NAME_IP_FAMILY)
  private String ipFamily;

  public static final String SERIALIZED_NAME_LOAD_BALANCER_I_P = "loadBalancerIP";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCER_I_P)
  private String loadBalancerIP;

  public static final String SERIALIZED_NAME_LOAD_BALANCER_SOURCE_RANGES = "loadBalancerSourceRanges";
  @SerializedName(SERIALIZED_NAME_LOAD_BALANCER_SOURCE_RANGES)
  private List<String> loadBalancerSourceRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_PORTS = "ports";
  @SerializedName(SERIALIZED_NAME_PORTS)
  private List<ServicePort> ports = new ArrayList<>();

  public static final String SERIALIZED_NAME_PUBLISH_NOT_READY_ADDRESSES = "publishNotReadyAddresses";
  @SerializedName(SERIALIZED_NAME_PUBLISH_NOT_READY_ADDRESSES)
  private Boolean publishNotReadyAddresses;

  public static final String SERIALIZED_NAME_SELECTOR = "selector";
  @SerializedName(SERIALIZED_NAME_SELECTOR)
  private Map<String, String> selector = new HashMap<>();

  public static final String SERIALIZED_NAME_SESSION_AFFINITY = "sessionAffinity";
  @SerializedName(SERIALIZED_NAME_SESSION_AFFINITY)
  private String sessionAffinity;

  public static final String SERIALIZED_NAME_SESSION_AFFINITY_CONFIG = "sessionAffinityConfig";
  @SerializedName(SERIALIZED_NAME_SESSION_AFFINITY_CONFIG)
  private SessionAffinityConfig sessionAffinityConfig;

  public static final String SERIALIZED_NAME_TOPOLOGY_KEYS = "topologyKeys";
  @SerializedName(SERIALIZED_NAME_TOPOLOGY_KEYS)
  private List<String> topologyKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public ServiceSpec() {
  }

  public ServiceSpec clusterIP(String clusterIP) {
    this.clusterIP = clusterIP;
    return this;
  }

  /**
   * clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \&quot;None\&quot;, empty string (\&quot;\&quot;), or a valid IP address. \&quot;None\&quot; can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies +optional
   * @return clusterIP
   */
  @javax.annotation.Nullable
  public String getClusterIP() {
    return clusterIP;
  }

  public void setClusterIP(String clusterIP) {
    this.clusterIP = clusterIP;
  }


  public ServiceSpec externalIPs(List<String> externalIPs) {
    this.externalIPs = externalIPs;
    return this;
  }

  public ServiceSpec addExternalIPsItem(String externalIPsItem) {
    if (this.externalIPs == null) {
      this.externalIPs = new ArrayList<>();
    }
    this.externalIPs.add(externalIPsItem);
    return this;
  }

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system. +optional
   * @return externalIPs
   */
  @javax.annotation.Nullable
  public List<String> getExternalIPs() {
    return externalIPs;
  }

  public void setExternalIPs(List<String> externalIPs) {
    this.externalIPs = externalIPs;
  }


  public ServiceSpec externalName(String externalName) {
    this.externalName = externalName;
    return this;
  }

  /**
   * externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName. +optional
   * @return externalName
   */
  @javax.annotation.Nullable
  public String getExternalName() {
    return externalName;
  }

  public void setExternalName(String externalName) {
    this.externalName = externalName;
  }


  public ServiceSpec externalTrafficPolicy(String externalTrafficPolicy) {
    this.externalTrafficPolicy = externalTrafficPolicy;
    return this;
  }

  /**
   * Service External Traffic Policy Type string
   * @return externalTrafficPolicy
   */
  @javax.annotation.Nullable
  public String getExternalTrafficPolicy() {
    return externalTrafficPolicy;
  }

  public void setExternalTrafficPolicy(String externalTrafficPolicy) {
    this.externalTrafficPolicy = externalTrafficPolicy;
  }


  public ServiceSpec healthCheckNodePort(Integer healthCheckNodePort) {
    this.healthCheckNodePort = healthCheckNodePort;
    return this;
  }

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local. +optional
   * @return healthCheckNodePort
   */
  @javax.annotation.Nullable
  public Integer getHealthCheckNodePort() {
    return healthCheckNodePort;
  }

  public void setHealthCheckNodePort(Integer healthCheckNodePort) {
    this.healthCheckNodePort = healthCheckNodePort;
  }


  public ServiceSpec ipFamily(String ipFamily) {
    this.ipFamily = ipFamily;
    return this;
  }

  /**
   * IPFamily represents the IP Family (IPv4 or IPv6). This type is used to express the family of an IP expressed by a type (i.e. service.Spec.IPFamily)
   * @return ipFamily
   */
  @javax.annotation.Nullable
  public String getIpFamily() {
    return ipFamily;
  }

  public void setIpFamily(String ipFamily) {
    this.ipFamily = ipFamily;
  }


  public ServiceSpec loadBalancerIP(String loadBalancerIP) {
    this.loadBalancerIP = loadBalancerIP;
    return this;
  }

  /**
   * Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature. +optional
   * @return loadBalancerIP
   */
  @javax.annotation.Nullable
  public String getLoadBalancerIP() {
    return loadBalancerIP;
  }

  public void setLoadBalancerIP(String loadBalancerIP) {
    this.loadBalancerIP = loadBalancerIP;
  }


  public ServiceSpec loadBalancerSourceRanges(List<String> loadBalancerSourceRanges) {
    this.loadBalancerSourceRanges = loadBalancerSourceRanges;
    return this;
  }

  public ServiceSpec addLoadBalancerSourceRangesItem(String loadBalancerSourceRangesItem) {
    if (this.loadBalancerSourceRanges == null) {
      this.loadBalancerSourceRanges = new ArrayList<>();
    }
    this.loadBalancerSourceRanges.add(loadBalancerSourceRangesItem);
    return this;
  }

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.\&quot; More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ +optional
   * @return loadBalancerSourceRanges
   */
  @javax.annotation.Nullable
  public List<String> getLoadBalancerSourceRanges() {
    return loadBalancerSourceRanges;
  }

  public void setLoadBalancerSourceRanges(List<String> loadBalancerSourceRanges) {
    this.loadBalancerSourceRanges = loadBalancerSourceRanges;
  }


  public ServiceSpec ports(List<ServicePort> ports) {
    this.ports = ports;
    return this;
  }

  public ServiceSpec addPortsItem(ServicePort portsItem) {
    if (this.ports == null) {
      this.ports = new ArrayList<>();
    }
    this.ports.add(portsItem);
    return this;
  }

  /**
   * The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies +patchMergeKey&#x3D;port +patchStrategy&#x3D;merge +listType&#x3D;map +listMapKey&#x3D;port +listMapKey&#x3D;protocol
   * @return ports
   */
  @javax.annotation.Nullable
  public List<ServicePort> getPorts() {
    return ports;
  }

  public void setPorts(List<ServicePort> ports) {
    this.ports = ports;
  }


  public ServiceSpec publishNotReadyAddresses(Boolean publishNotReadyAddresses) {
    this.publishNotReadyAddresses = publishNotReadyAddresses;
    return this;
  }

  /**
   * publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet&#39;s Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery. +optional
   * @return publishNotReadyAddresses
   */
  @javax.annotation.Nullable
  public Boolean getPublishNotReadyAddresses() {
    return publishNotReadyAddresses;
  }

  public void setPublishNotReadyAddresses(Boolean publishNotReadyAddresses) {
    this.publishNotReadyAddresses = publishNotReadyAddresses;
  }


  public ServiceSpec selector(Map<String, String> selector) {
    this.selector = selector;
    return this;
  }

  public ServiceSpec putSelectorItem(String key, String selectorItem) {
    if (this.selector == null) {
      this.selector = new HashMap<>();
    }
    this.selector.put(key, selectorItem);
    return this;
  }

  /**
   * Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/ +optional
   * @return selector
   */
  @javax.annotation.Nullable
  public Map<String, String> getSelector() {
    return selector;
  }

  public void setSelector(Map<String, String> selector) {
    this.selector = selector;
  }


  public ServiceSpec sessionAffinity(String sessionAffinity) {
    this.sessionAffinity = sessionAffinity;
    return this;
  }

  /**
   * Session Affinity Type string
   * @return sessionAffinity
   */
  @javax.annotation.Nullable
  public String getSessionAffinity() {
    return sessionAffinity;
  }

  public void setSessionAffinity(String sessionAffinity) {
    this.sessionAffinity = sessionAffinity;
  }


  public ServiceSpec sessionAffinityConfig(SessionAffinityConfig sessionAffinityConfig) {
    this.sessionAffinityConfig = sessionAffinityConfig;
    return this;
  }

  /**
   * Get sessionAffinityConfig
   * @return sessionAffinityConfig
   */
  @javax.annotation.Nullable
  public SessionAffinityConfig getSessionAffinityConfig() {
    return sessionAffinityConfig;
  }

  public void setSessionAffinityConfig(SessionAffinityConfig sessionAffinityConfig) {
    this.sessionAffinityConfig = sessionAffinityConfig;
  }


  public ServiceSpec topologyKeys(List<String> topologyKeys) {
    this.topologyKeys = topologyKeys;
    return this;
  }

  public ServiceSpec addTopologyKeysItem(String topologyKeysItem) {
    if (this.topologyKeys == null) {
      this.topologyKeys = new ArrayList<>();
    }
    this.topologyKeys.add(topologyKeysItem);
    return this;
  }

  /**
   * topologyKeys is a preference-order list of topology keys which implementations of services should use to preferentially sort endpoints when accessing this Service, it can not be used at the same time as externalTrafficPolicy&#x3D;Local. Topology keys must be valid label keys and at most 16 keys may be specified. Endpoints are chosen based on the first topology key with available backends. If this field is specified and all entries have no backends that match the topology of the client, the service has no backends for that client and connections should fail. The special value \&quot;*\&quot; may be used to mean \&quot;any topology\&quot;. This catch-all value, if used, only makes sense as the last value in the list. If this is not specified or empty, no topology constraints will be applied. +optional
   * @return topologyKeys
   */
  @javax.annotation.Nullable
  public List<String> getTopologyKeys() {
    return topologyKeys;
  }

  public void setTopologyKeys(List<String> topologyKeys) {
    this.topologyKeys = topologyKeys;
  }


  public ServiceSpec type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Service Type string describes ingress methods for a service
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServiceSpec serviceSpec = (ServiceSpec) o;
    return Objects.equals(this.clusterIP, serviceSpec.clusterIP) &&
        Objects.equals(this.externalIPs, serviceSpec.externalIPs) &&
        Objects.equals(this.externalName, serviceSpec.externalName) &&
        Objects.equals(this.externalTrafficPolicy, serviceSpec.externalTrafficPolicy) &&
        Objects.equals(this.healthCheckNodePort, serviceSpec.healthCheckNodePort) &&
        Objects.equals(this.ipFamily, serviceSpec.ipFamily) &&
        Objects.equals(this.loadBalancerIP, serviceSpec.loadBalancerIP) &&
        Objects.equals(this.loadBalancerSourceRanges, serviceSpec.loadBalancerSourceRanges) &&
        Objects.equals(this.ports, serviceSpec.ports) &&
        Objects.equals(this.publishNotReadyAddresses, serviceSpec.publishNotReadyAddresses) &&
        Objects.equals(this.selector, serviceSpec.selector) &&
        Objects.equals(this.sessionAffinity, serviceSpec.sessionAffinity) &&
        Objects.equals(this.sessionAffinityConfig, serviceSpec.sessionAffinityConfig) &&
        Objects.equals(this.topologyKeys, serviceSpec.topologyKeys) &&
        Objects.equals(this.type, serviceSpec.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clusterIP, externalIPs, externalName, externalTrafficPolicy, healthCheckNodePort, ipFamily, loadBalancerIP, loadBalancerSourceRanges, ports, publishNotReadyAddresses, selector, sessionAffinity, sessionAffinityConfig, topologyKeys, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServiceSpec {\n");
    sb.append("    clusterIP: ").append(toIndentedString(clusterIP)).append("\n");
    sb.append("    externalIPs: ").append(toIndentedString(externalIPs)).append("\n");
    sb.append("    externalName: ").append(toIndentedString(externalName)).append("\n");
    sb.append("    externalTrafficPolicy: ").append(toIndentedString(externalTrafficPolicy)).append("\n");
    sb.append("    healthCheckNodePort: ").append(toIndentedString(healthCheckNodePort)).append("\n");
    sb.append("    ipFamily: ").append(toIndentedString(ipFamily)).append("\n");
    sb.append("    loadBalancerIP: ").append(toIndentedString(loadBalancerIP)).append("\n");
    sb.append("    loadBalancerSourceRanges: ").append(toIndentedString(loadBalancerSourceRanges)).append("\n");
    sb.append("    ports: ").append(toIndentedString(ports)).append("\n");
    sb.append("    publishNotReadyAddresses: ").append(toIndentedString(publishNotReadyAddresses)).append("\n");
    sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
    sb.append("    sessionAffinity: ").append(toIndentedString(sessionAffinity)).append("\n");
    sb.append("    sessionAffinityConfig: ").append(toIndentedString(sessionAffinityConfig)).append("\n");
    sb.append("    topologyKeys: ").append(toIndentedString(topologyKeys)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("clusterIP");
    openapiFields.add("externalIPs");
    openapiFields.add("externalName");
    openapiFields.add("externalTrafficPolicy");
    openapiFields.add("healthCheckNodePort");
    openapiFields.add("ipFamily");
    openapiFields.add("loadBalancerIP");
    openapiFields.add("loadBalancerSourceRanges");
    openapiFields.add("ports");
    openapiFields.add("publishNotReadyAddresses");
    openapiFields.add("selector");
    openapiFields.add("sessionAffinity");
    openapiFields.add("sessionAffinityConfig");
    openapiFields.add("topologyKeys");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ServiceSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ServiceSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ServiceSpec is not found in the empty JSON string", ServiceSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ServiceSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ServiceSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("clusterIP") != null && !jsonObj.get("clusterIP").isJsonNull()) && !jsonObj.get("clusterIP").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterIP` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterIP").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("externalIPs") != null && !jsonObj.get("externalIPs").isJsonNull() && !jsonObj.get("externalIPs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalIPs` to be an array in the JSON string but got `%s`", jsonObj.get("externalIPs").toString()));
      }
      if ((jsonObj.get("externalName") != null && !jsonObj.get("externalName").isJsonNull()) && !jsonObj.get("externalName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalName").toString()));
      }
      if ((jsonObj.get("externalTrafficPolicy") != null && !jsonObj.get("externalTrafficPolicy").isJsonNull()) && !jsonObj.get("externalTrafficPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalTrafficPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalTrafficPolicy").toString()));
      }
      if ((jsonObj.get("ipFamily") != null && !jsonObj.get("ipFamily").isJsonNull()) && !jsonObj.get("ipFamily").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipFamily` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipFamily").toString()));
      }
      if ((jsonObj.get("loadBalancerIP") != null && !jsonObj.get("loadBalancerIP").isJsonNull()) && !jsonObj.get("loadBalancerIP").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `loadBalancerIP` to be a primitive type in the JSON string but got `%s`", jsonObj.get("loadBalancerIP").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("loadBalancerSourceRanges") != null && !jsonObj.get("loadBalancerSourceRanges").isJsonNull() && !jsonObj.get("loadBalancerSourceRanges").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `loadBalancerSourceRanges` to be an array in the JSON string but got `%s`", jsonObj.get("loadBalancerSourceRanges").toString()));
      }
      if (jsonObj.get("ports") != null && !jsonObj.get("ports").isJsonNull()) {
        JsonArray jsonArrayports = jsonObj.getAsJsonArray("ports");
        if (jsonArrayports != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ports").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ports` to be an array in the JSON string but got `%s`", jsonObj.get("ports").toString()));
          }

          // validate the optional field `ports` (array)
          for (int i = 0; i < jsonArrayports.size(); i++) {
            ServicePort.validateJsonElement(jsonArrayports.get(i));
          };
        }
      }
      if ((jsonObj.get("sessionAffinity") != null && !jsonObj.get("sessionAffinity").isJsonNull()) && !jsonObj.get("sessionAffinity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sessionAffinity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sessionAffinity").toString()));
      }
      // validate the optional field `sessionAffinityConfig`
      if (jsonObj.get("sessionAffinityConfig") != null && !jsonObj.get("sessionAffinityConfig").isJsonNull()) {
        SessionAffinityConfig.validateJsonElement(jsonObj.get("sessionAffinityConfig"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("topologyKeys") != null && !jsonObj.get("topologyKeys").isJsonNull() && !jsonObj.get("topologyKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `topologyKeys` to be an array in the JSON string but got `%s`", jsonObj.get("topologyKeys").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ServiceSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ServiceSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ServiceSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ServiceSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<ServiceSpec>() {
           @Override
           public void write(JsonWriter out, ServiceSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ServiceSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ServiceSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ServiceSpec
   * @throws IOException if the JSON string is invalid with respect to ServiceSpec
   */
  public static ServiceSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ServiceSpec.class);
  }

  /**
   * Convert an instance of ServiceSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

