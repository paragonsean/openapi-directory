/**
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIK8SNode.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIK8SNode::OAIK8SNode(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIK8SNode::OAIK8SNode() {
    this->initializeModel();
}

OAIK8SNode::~OAIK8SNode() {}

void OAIK8SNode::initializeModel() {

    m_allocatable_cpu_isSet = false;
    m_allocatable_cpu_isValid = false;

    m_allocatable_memory_isSet = false;
    m_allocatable_memory_isValid = false;

    m_architecture_isSet = false;
    m_architecture_isValid = false;

    m_capacity_cpu_isSet = false;
    m_capacity_cpu_isValid = false;

    m_capacity_memory_isSet = false;
    m_capacity_memory_isValid = false;

    m_container_runtime_version_isSet = false;
    m_container_runtime_version_isValid = false;

    m_hostname_isSet = false;
    m_hostname_isValid = false;

    m_internal_ip_isSet = false;
    m_internal_ip_isValid = false;

    m_kubelet_version_isSet = false;
    m_kubelet_version_isValid = false;

    m_kubeproxy_version_isSet = false;
    m_kubeproxy_version_isValid = false;

    m_operating_system_isSet = false;
    m_operating_system_isValid = false;

    m_os_image_isSet = false;
    m_os_image_isValid = false;
}

void OAIK8SNode::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIK8SNode::fromJsonObject(QJsonObject json) {

    m_allocatable_cpu_isValid = ::OpenAPI::fromJsonValue(m_allocatable_cpu, json[QString("allocatable_cpu")]);
    m_allocatable_cpu_isSet = !json[QString("allocatable_cpu")].isNull() && m_allocatable_cpu_isValid;

    m_allocatable_memory_isValid = ::OpenAPI::fromJsonValue(m_allocatable_memory, json[QString("allocatable_memory")]);
    m_allocatable_memory_isSet = !json[QString("allocatable_memory")].isNull() && m_allocatable_memory_isValid;

    m_architecture_isValid = ::OpenAPI::fromJsonValue(m_architecture, json[QString("architecture")]);
    m_architecture_isSet = !json[QString("architecture")].isNull() && m_architecture_isValid;

    m_capacity_cpu_isValid = ::OpenAPI::fromJsonValue(m_capacity_cpu, json[QString("capacity_cpu")]);
    m_capacity_cpu_isSet = !json[QString("capacity_cpu")].isNull() && m_capacity_cpu_isValid;

    m_capacity_memory_isValid = ::OpenAPI::fromJsonValue(m_capacity_memory, json[QString("capacity_memory")]);
    m_capacity_memory_isSet = !json[QString("capacity_memory")].isNull() && m_capacity_memory_isValid;

    m_container_runtime_version_isValid = ::OpenAPI::fromJsonValue(m_container_runtime_version, json[QString("container_runtime_version")]);
    m_container_runtime_version_isSet = !json[QString("container_runtime_version")].isNull() && m_container_runtime_version_isValid;

    m_hostname_isValid = ::OpenAPI::fromJsonValue(m_hostname, json[QString("hostname")]);
    m_hostname_isSet = !json[QString("hostname")].isNull() && m_hostname_isValid;

    m_internal_ip_isValid = ::OpenAPI::fromJsonValue(m_internal_ip, json[QString("internal_ip")]);
    m_internal_ip_isSet = !json[QString("internal_ip")].isNull() && m_internal_ip_isValid;

    m_kubelet_version_isValid = ::OpenAPI::fromJsonValue(m_kubelet_version, json[QString("kubelet_version")]);
    m_kubelet_version_isSet = !json[QString("kubelet_version")].isNull() && m_kubelet_version_isValid;

    m_kubeproxy_version_isValid = ::OpenAPI::fromJsonValue(m_kubeproxy_version, json[QString("kubeproxy_version")]);
    m_kubeproxy_version_isSet = !json[QString("kubeproxy_version")].isNull() && m_kubeproxy_version_isValid;

    m_operating_system_isValid = ::OpenAPI::fromJsonValue(m_operating_system, json[QString("operating_system")]);
    m_operating_system_isSet = !json[QString("operating_system")].isNull() && m_operating_system_isValid;

    m_os_image_isValid = ::OpenAPI::fromJsonValue(m_os_image, json[QString("os_image")]);
    m_os_image_isSet = !json[QString("os_image")].isNull() && m_os_image_isValid;
}

QString OAIK8SNode::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIK8SNode::asJsonObject() const {
    QJsonObject obj;
    if (m_allocatable_cpu_isSet) {
        obj.insert(QString("allocatable_cpu"), ::OpenAPI::toJsonValue(m_allocatable_cpu));
    }
    if (m_allocatable_memory_isSet) {
        obj.insert(QString("allocatable_memory"), ::OpenAPI::toJsonValue(m_allocatable_memory));
    }
    if (m_architecture_isSet) {
        obj.insert(QString("architecture"), ::OpenAPI::toJsonValue(m_architecture));
    }
    if (m_capacity_cpu_isSet) {
        obj.insert(QString("capacity_cpu"), ::OpenAPI::toJsonValue(m_capacity_cpu));
    }
    if (m_capacity_memory_isSet) {
        obj.insert(QString("capacity_memory"), ::OpenAPI::toJsonValue(m_capacity_memory));
    }
    if (m_container_runtime_version_isSet) {
        obj.insert(QString("container_runtime_version"), ::OpenAPI::toJsonValue(m_container_runtime_version));
    }
    if (m_hostname_isSet) {
        obj.insert(QString("hostname"), ::OpenAPI::toJsonValue(m_hostname));
    }
    if (m_internal_ip_isSet) {
        obj.insert(QString("internal_ip"), ::OpenAPI::toJsonValue(m_internal_ip));
    }
    if (m_kubelet_version_isSet) {
        obj.insert(QString("kubelet_version"), ::OpenAPI::toJsonValue(m_kubelet_version));
    }
    if (m_kubeproxy_version_isSet) {
        obj.insert(QString("kubeproxy_version"), ::OpenAPI::toJsonValue(m_kubeproxy_version));
    }
    if (m_operating_system_isSet) {
        obj.insert(QString("operating_system"), ::OpenAPI::toJsonValue(m_operating_system));
    }
    if (m_os_image_isSet) {
        obj.insert(QString("os_image"), ::OpenAPI::toJsonValue(m_os_image));
    }
    return obj;
}

QString OAIK8SNode::getAllocatableCpu() const {
    return m_allocatable_cpu;
}
void OAIK8SNode::setAllocatableCpu(const QString &allocatable_cpu) {
    m_allocatable_cpu = allocatable_cpu;
    m_allocatable_cpu_isSet = true;
}

bool OAIK8SNode::is_allocatable_cpu_Set() const{
    return m_allocatable_cpu_isSet;
}

bool OAIK8SNode::is_allocatable_cpu_Valid() const{
    return m_allocatable_cpu_isValid;
}

QString OAIK8SNode::getAllocatableMemory() const {
    return m_allocatable_memory;
}
void OAIK8SNode::setAllocatableMemory(const QString &allocatable_memory) {
    m_allocatable_memory = allocatable_memory;
    m_allocatable_memory_isSet = true;
}

bool OAIK8SNode::is_allocatable_memory_Set() const{
    return m_allocatable_memory_isSet;
}

bool OAIK8SNode::is_allocatable_memory_Valid() const{
    return m_allocatable_memory_isValid;
}

QString OAIK8SNode::getArchitecture() const {
    return m_architecture;
}
void OAIK8SNode::setArchitecture(const QString &architecture) {
    m_architecture = architecture;
    m_architecture_isSet = true;
}

bool OAIK8SNode::is_architecture_Set() const{
    return m_architecture_isSet;
}

bool OAIK8SNode::is_architecture_Valid() const{
    return m_architecture_isValid;
}

QString OAIK8SNode::getCapacityCpu() const {
    return m_capacity_cpu;
}
void OAIK8SNode::setCapacityCpu(const QString &capacity_cpu) {
    m_capacity_cpu = capacity_cpu;
    m_capacity_cpu_isSet = true;
}

bool OAIK8SNode::is_capacity_cpu_Set() const{
    return m_capacity_cpu_isSet;
}

bool OAIK8SNode::is_capacity_cpu_Valid() const{
    return m_capacity_cpu_isValid;
}

QString OAIK8SNode::getCapacityMemory() const {
    return m_capacity_memory;
}
void OAIK8SNode::setCapacityMemory(const QString &capacity_memory) {
    m_capacity_memory = capacity_memory;
    m_capacity_memory_isSet = true;
}

bool OAIK8SNode::is_capacity_memory_Set() const{
    return m_capacity_memory_isSet;
}

bool OAIK8SNode::is_capacity_memory_Valid() const{
    return m_capacity_memory_isValid;
}

QString OAIK8SNode::getContainerRuntimeVersion() const {
    return m_container_runtime_version;
}
void OAIK8SNode::setContainerRuntimeVersion(const QString &container_runtime_version) {
    m_container_runtime_version = container_runtime_version;
    m_container_runtime_version_isSet = true;
}

bool OAIK8SNode::is_container_runtime_version_Set() const{
    return m_container_runtime_version_isSet;
}

bool OAIK8SNode::is_container_runtime_version_Valid() const{
    return m_container_runtime_version_isValid;
}

QString OAIK8SNode::getHostname() const {
    return m_hostname;
}
void OAIK8SNode::setHostname(const QString &hostname) {
    m_hostname = hostname;
    m_hostname_isSet = true;
}

bool OAIK8SNode::is_hostname_Set() const{
    return m_hostname_isSet;
}

bool OAIK8SNode::is_hostname_Valid() const{
    return m_hostname_isValid;
}

QString OAIK8SNode::getInternalIp() const {
    return m_internal_ip;
}
void OAIK8SNode::setInternalIp(const QString &internal_ip) {
    m_internal_ip = internal_ip;
    m_internal_ip_isSet = true;
}

bool OAIK8SNode::is_internal_ip_Set() const{
    return m_internal_ip_isSet;
}

bool OAIK8SNode::is_internal_ip_Valid() const{
    return m_internal_ip_isValid;
}

QString OAIK8SNode::getKubeletVersion() const {
    return m_kubelet_version;
}
void OAIK8SNode::setKubeletVersion(const QString &kubelet_version) {
    m_kubelet_version = kubelet_version;
    m_kubelet_version_isSet = true;
}

bool OAIK8SNode::is_kubelet_version_Set() const{
    return m_kubelet_version_isSet;
}

bool OAIK8SNode::is_kubelet_version_Valid() const{
    return m_kubelet_version_isValid;
}

QString OAIK8SNode::getKubeproxyVersion() const {
    return m_kubeproxy_version;
}
void OAIK8SNode::setKubeproxyVersion(const QString &kubeproxy_version) {
    m_kubeproxy_version = kubeproxy_version;
    m_kubeproxy_version_isSet = true;
}

bool OAIK8SNode::is_kubeproxy_version_Set() const{
    return m_kubeproxy_version_isSet;
}

bool OAIK8SNode::is_kubeproxy_version_Valid() const{
    return m_kubeproxy_version_isValid;
}

QString OAIK8SNode::getOperatingSystem() const {
    return m_operating_system;
}
void OAIK8SNode::setOperatingSystem(const QString &operating_system) {
    m_operating_system = operating_system;
    m_operating_system_isSet = true;
}

bool OAIK8SNode::is_operating_system_Set() const{
    return m_operating_system_isSet;
}

bool OAIK8SNode::is_operating_system_Valid() const{
    return m_operating_system_isValid;
}

QString OAIK8SNode::getOsImage() const {
    return m_os_image;
}
void OAIK8SNode::setOsImage(const QString &os_image) {
    m_os_image = os_image;
    m_os_image_isSet = true;
}

bool OAIK8SNode::is_os_image_Set() const{
    return m_os_image_isSet;
}

bool OAIK8SNode::is_os_image_Valid() const{
    return m_os_image_isValid;
}

bool OAIK8SNode::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_allocatable_cpu_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_allocatable_memory_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_architecture_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_capacity_cpu_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_capacity_memory_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_container_runtime_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hostname_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_internal_ip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kubelet_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_kubeproxy_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_operating_system_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_os_image_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIK8SNode::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
