/**
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITarget.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITarget::OAITarget(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITarget::OAITarget() {
    this->initializeModel();
}

OAITarget::~OAITarget() {}

void OAITarget::initializeModel() {

    m_alias_isSet = false;
    m_alias_isValid = false;

    m_alias_by_isSet = false;
    m_alias_by_isValid = false;

    m_align_options_isSet = false;
    m_align_options_isValid = false;

    m_alignment_period_isSet = false;
    m_alignment_period_isValid = false;

    m_bucket_aggs_isSet = false;
    m_bucket_aggs_isValid = false;

    m_cross_series_reducer_isSet = false;
    m_cross_series_reducer_isValid = false;

    m_datasource_isSet = false;
    m_datasource_isValid = false;

    m_dimensions_isSet = false;
    m_dimensions_isValid = false;

    m_ds_type_isSet = false;
    m_ds_type_isValid = false;

    m_expr_isSet = false;
    m_expr_isValid = false;

    m_filters_isSet = false;
    m_filters_isValid = false;

    m_format_isSet = false;
    m_format_isValid = false;

    m_group_isSet = false;
    m_group_isValid = false;

    m_group_bys_isSet = false;
    m_group_bys_isValid = false;

    m_hide_isSet = false;
    m_hide_isValid = false;

    m_instant_isSet = false;
    m_instant_isValid = false;

    m_interval_isSet = false;
    m_interval_isValid = false;

    m_interval_factor_isSet = false;
    m_interval_factor_isValid = false;

    m_legend_format_isSet = false;
    m_legend_format_isValid = false;

    m_measurement_isSet = false;
    m_measurement_isValid = false;

    m_metric_column_isSet = false;
    m_metric_column_isValid = false;

    m_metric_kind_isSet = false;
    m_metric_kind_isValid = false;

    m_metric_name_isSet = false;
    m_metric_name_isValid = false;

    m_metric_type_isSet = false;
    m_metric_type_isValid = false;

    m_metrics_isSet = false;
    m_metrics_isValid = false;

    m_r_namespace_isSet = false;
    m_r_namespace_isValid = false;

    m_per_series_aligner_isSet = false;
    m_per_series_aligner_isValid = false;

    m_period_isSet = false;
    m_period_isValid = false;

    m_project_name_isSet = false;
    m_project_name_isValid = false;

    m_query_isSet = false;
    m_query_isValid = false;

    m_raw_query_isSet = false;
    m_raw_query_isValid = false;

    m_raw_sql_isSet = false;
    m_raw_sql_isValid = false;

    m_ref_id_isSet = false;
    m_ref_id_isValid = false;

    m_region_isSet = false;
    m_region_isValid = false;

    m_select_isSet = false;
    m_select_isValid = false;

    m_statistics_isSet = false;
    m_statistics_isValid = false;

    m_step_isSet = false;
    m_step_isValid = false;

    m_table_isSet = false;
    m_table_isValid = false;

    m_target_isSet = false;
    m_target_isValid = false;

    m_time_column_isSet = false;
    m_time_column_isValid = false;

    m_time_field_isSet = false;
    m_time_field_isValid = false;

    m_value_type_isSet = false;
    m_value_type_isValid = false;

    m_where_isSet = false;
    m_where_isValid = false;
}

void OAITarget::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITarget::fromJsonObject(QJsonObject json) {

    m_alias_isValid = ::OpenAPI::fromJsonValue(m_alias, json[QString("alias")]);
    m_alias_isSet = !json[QString("alias")].isNull() && m_alias_isValid;

    m_alias_by_isValid = ::OpenAPI::fromJsonValue(m_alias_by, json[QString("aliasBy")]);
    m_alias_by_isSet = !json[QString("aliasBy")].isNull() && m_alias_by_isValid;

    m_align_options_isValid = ::OpenAPI::fromJsonValue(m_align_options, json[QString("alignOptions")]);
    m_align_options_isSet = !json[QString("alignOptions")].isNull() && m_align_options_isValid;

    m_alignment_period_isValid = ::OpenAPI::fromJsonValue(m_alignment_period, json[QString("alignmentPeriod")]);
    m_alignment_period_isSet = !json[QString("alignmentPeriod")].isNull() && m_alignment_period_isValid;

    m_bucket_aggs_isValid = ::OpenAPI::fromJsonValue(m_bucket_aggs, json[QString("bucketAggs")]);
    m_bucket_aggs_isSet = !json[QString("bucketAggs")].isNull() && m_bucket_aggs_isValid;

    m_cross_series_reducer_isValid = ::OpenAPI::fromJsonValue(m_cross_series_reducer, json[QString("crossSeriesReducer")]);
    m_cross_series_reducer_isSet = !json[QString("crossSeriesReducer")].isNull() && m_cross_series_reducer_isValid;

    m_datasource_isValid = ::OpenAPI::fromJsonValue(m_datasource, json[QString("datasource")]);
    m_datasource_isSet = !json[QString("datasource")].isNull() && m_datasource_isValid;

    m_dimensions_isValid = ::OpenAPI::fromJsonValue(m_dimensions, json[QString("dimensions")]);
    m_dimensions_isSet = !json[QString("dimensions")].isNull() && m_dimensions_isValid;

    m_ds_type_isValid = ::OpenAPI::fromJsonValue(m_ds_type, json[QString("dsType")]);
    m_ds_type_isSet = !json[QString("dsType")].isNull() && m_ds_type_isValid;

    m_expr_isValid = ::OpenAPI::fromJsonValue(m_expr, json[QString("expr")]);
    m_expr_isSet = !json[QString("expr")].isNull() && m_expr_isValid;

    m_filters_isValid = ::OpenAPI::fromJsonValue(m_filters, json[QString("filters")]);
    m_filters_isSet = !json[QString("filters")].isNull() && m_filters_isValid;

    m_format_isValid = ::OpenAPI::fromJsonValue(m_format, json[QString("format")]);
    m_format_isSet = !json[QString("format")].isNull() && m_format_isValid;

    m_group_isValid = ::OpenAPI::fromJsonValue(m_group, json[QString("group")]);
    m_group_isSet = !json[QString("group")].isNull() && m_group_isValid;

    m_group_bys_isValid = ::OpenAPI::fromJsonValue(m_group_bys, json[QString("groupBys")]);
    m_group_bys_isSet = !json[QString("groupBys")].isNull() && m_group_bys_isValid;

    m_hide_isValid = ::OpenAPI::fromJsonValue(m_hide, json[QString("hide")]);
    m_hide_isSet = !json[QString("hide")].isNull() && m_hide_isValid;

    m_instant_isValid = ::OpenAPI::fromJsonValue(m_instant, json[QString("instant")]);
    m_instant_isSet = !json[QString("instant")].isNull() && m_instant_isValid;

    m_interval_isValid = ::OpenAPI::fromJsonValue(m_interval, json[QString("interval")]);
    m_interval_isSet = !json[QString("interval")].isNull() && m_interval_isValid;

    m_interval_factor_isValid = ::OpenAPI::fromJsonValue(m_interval_factor, json[QString("intervalFactor")]);
    m_interval_factor_isSet = !json[QString("intervalFactor")].isNull() && m_interval_factor_isValid;

    m_legend_format_isValid = ::OpenAPI::fromJsonValue(m_legend_format, json[QString("legendFormat")]);
    m_legend_format_isSet = !json[QString("legendFormat")].isNull() && m_legend_format_isValid;

    m_measurement_isValid = ::OpenAPI::fromJsonValue(m_measurement, json[QString("measurement")]);
    m_measurement_isSet = !json[QString("measurement")].isNull() && m_measurement_isValid;

    m_metric_column_isValid = ::OpenAPI::fromJsonValue(m_metric_column, json[QString("metricColumn")]);
    m_metric_column_isSet = !json[QString("metricColumn")].isNull() && m_metric_column_isValid;

    m_metric_kind_isValid = ::OpenAPI::fromJsonValue(m_metric_kind, json[QString("metricKind")]);
    m_metric_kind_isSet = !json[QString("metricKind")].isNull() && m_metric_kind_isValid;

    m_metric_name_isValid = ::OpenAPI::fromJsonValue(m_metric_name, json[QString("metricName")]);
    m_metric_name_isSet = !json[QString("metricName")].isNull() && m_metric_name_isValid;

    m_metric_type_isValid = ::OpenAPI::fromJsonValue(m_metric_type, json[QString("metricType")]);
    m_metric_type_isSet = !json[QString("metricType")].isNull() && m_metric_type_isValid;

    m_metrics_isValid = ::OpenAPI::fromJsonValue(m_metrics, json[QString("metrics")]);
    m_metrics_isSet = !json[QString("metrics")].isNull() && m_metrics_isValid;

    m_r_namespace_isValid = ::OpenAPI::fromJsonValue(m_r_namespace, json[QString("namespace")]);
    m_r_namespace_isSet = !json[QString("namespace")].isNull() && m_r_namespace_isValid;

    m_per_series_aligner_isValid = ::OpenAPI::fromJsonValue(m_per_series_aligner, json[QString("perSeriesAligner")]);
    m_per_series_aligner_isSet = !json[QString("perSeriesAligner")].isNull() && m_per_series_aligner_isValid;

    m_period_isValid = ::OpenAPI::fromJsonValue(m_period, json[QString("period")]);
    m_period_isSet = !json[QString("period")].isNull() && m_period_isValid;

    m_project_name_isValid = ::OpenAPI::fromJsonValue(m_project_name, json[QString("projectName")]);
    m_project_name_isSet = !json[QString("projectName")].isNull() && m_project_name_isValid;

    m_query_isValid = ::OpenAPI::fromJsonValue(m_query, json[QString("query")]);
    m_query_isSet = !json[QString("query")].isNull() && m_query_isValid;

    m_raw_query_isValid = ::OpenAPI::fromJsonValue(m_raw_query, json[QString("rawQuery")]);
    m_raw_query_isSet = !json[QString("rawQuery")].isNull() && m_raw_query_isValid;

    m_raw_sql_isValid = ::OpenAPI::fromJsonValue(m_raw_sql, json[QString("rawSql")]);
    m_raw_sql_isSet = !json[QString("rawSql")].isNull() && m_raw_sql_isValid;

    m_ref_id_isValid = ::OpenAPI::fromJsonValue(m_ref_id, json[QString("refId")]);
    m_ref_id_isSet = !json[QString("refId")].isNull() && m_ref_id_isValid;

    m_region_isValid = ::OpenAPI::fromJsonValue(m_region, json[QString("region")]);
    m_region_isSet = !json[QString("region")].isNull() && m_region_isValid;

    if(json["select"].isArray()){
        auto arr = json["select"].toArray();
        m_select_isValid = true;
        if(arr.count() > 0) {
            for (const QJsonValue jval : arr) {
                QList<OAITarget_group_inner> item;
                m_select_isValid &= ::OpenAPI::fromJsonValue(item, jval);
                m_select_isSet = !jval.isNull() && m_select_isValid;
                m_select.push_back(item);
            }
        }
    }

    m_statistics_isValid = ::OpenAPI::fromJsonValue(m_statistics, json[QString("statistics")]);
    m_statistics_isSet = !json[QString("statistics")].isNull() && m_statistics_isValid;

    m_step_isValid = ::OpenAPI::fromJsonValue(m_step, json[QString("step")]);
    m_step_isSet = !json[QString("step")].isNull() && m_step_isValid;

    m_table_isValid = ::OpenAPI::fromJsonValue(m_table, json[QString("table")]);
    m_table_isSet = !json[QString("table")].isNull() && m_table_isValid;

    m_target_isValid = ::OpenAPI::fromJsonValue(m_target, json[QString("target")]);
    m_target_isSet = !json[QString("target")].isNull() && m_target_isValid;

    m_time_column_isValid = ::OpenAPI::fromJsonValue(m_time_column, json[QString("timeColumn")]);
    m_time_column_isSet = !json[QString("timeColumn")].isNull() && m_time_column_isValid;

    m_time_field_isValid = ::OpenAPI::fromJsonValue(m_time_field, json[QString("timeField")]);
    m_time_field_isSet = !json[QString("timeField")].isNull() && m_time_field_isValid;

    m_value_type_isValid = ::OpenAPI::fromJsonValue(m_value_type, json[QString("valueType")]);
    m_value_type_isSet = !json[QString("valueType")].isNull() && m_value_type_isValid;

    m_where_isValid = ::OpenAPI::fromJsonValue(m_where, json[QString("where")]);
    m_where_isSet = !json[QString("where")].isNull() && m_where_isValid;
}

QString OAITarget::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITarget::asJsonObject() const {
    QJsonObject obj;
    if (m_alias_isSet) {
        obj.insert(QString("alias"), ::OpenAPI::toJsonValue(m_alias));
    }
    if (m_alias_by_isSet) {
        obj.insert(QString("aliasBy"), ::OpenAPI::toJsonValue(m_alias_by));
    }
    if (m_align_options.size() > 0) {
        obj.insert(QString("alignOptions"), ::OpenAPI::toJsonValue(m_align_options));
    }
    if (m_alignment_period_isSet) {
        obj.insert(QString("alignmentPeriod"), ::OpenAPI::toJsonValue(m_alignment_period));
    }
    if (m_bucket_aggs.size() > 0) {
        obj.insert(QString("bucketAggs"), ::OpenAPI::toJsonValue(m_bucket_aggs));
    }
    if (m_cross_series_reducer_isSet) {
        obj.insert(QString("crossSeriesReducer"), ::OpenAPI::toJsonValue(m_cross_series_reducer));
    }
    if (m_datasource_isSet) {
        obj.insert(QString("datasource"), ::OpenAPI::toJsonValue(m_datasource));
    }
    if (m_dimensions.size() > 0) {
        obj.insert(QString("dimensions"), ::OpenAPI::toJsonValue(m_dimensions));
    }
    if (m_ds_type_isSet) {
        obj.insert(QString("dsType"), ::OpenAPI::toJsonValue(m_ds_type));
    }
    if (m_expr_isSet) {
        obj.insert(QString("expr"), ::OpenAPI::toJsonValue(m_expr));
    }
    if (m_filters.size() > 0) {
        obj.insert(QString("filters"), ::OpenAPI::toJsonValue(m_filters));
    }
    if (m_format_isSet) {
        obj.insert(QString("format"), ::OpenAPI::toJsonValue(m_format));
    }
    if (m_group.size() > 0) {
        obj.insert(QString("group"), ::OpenAPI::toJsonValue(m_group));
    }
    if (m_group_bys.size() > 0) {
        obj.insert(QString("groupBys"), ::OpenAPI::toJsonValue(m_group_bys));
    }
    if (m_hide_isSet) {
        obj.insert(QString("hide"), ::OpenAPI::toJsonValue(m_hide));
    }
    if (m_instant_isSet) {
        obj.insert(QString("instant"), ::OpenAPI::toJsonValue(m_instant));
    }
    if (m_interval_isSet) {
        obj.insert(QString("interval"), ::OpenAPI::toJsonValue(m_interval));
    }
    if (m_interval_factor_isSet) {
        obj.insert(QString("intervalFactor"), ::OpenAPI::toJsonValue(m_interval_factor));
    }
    if (m_legend_format_isSet) {
        obj.insert(QString("legendFormat"), ::OpenAPI::toJsonValue(m_legend_format));
    }
    if (m_measurement_isSet) {
        obj.insert(QString("measurement"), ::OpenAPI::toJsonValue(m_measurement));
    }
    if (m_metric_column_isSet) {
        obj.insert(QString("metricColumn"), ::OpenAPI::toJsonValue(m_metric_column));
    }
    if (m_metric_kind_isSet) {
        obj.insert(QString("metricKind"), ::OpenAPI::toJsonValue(m_metric_kind));
    }
    if (m_metric_name_isSet) {
        obj.insert(QString("metricName"), ::OpenAPI::toJsonValue(m_metric_name));
    }
    if (m_metric_type_isSet) {
        obj.insert(QString("metricType"), ::OpenAPI::toJsonValue(m_metric_type));
    }
    if (m_metrics.size() > 0) {
        obj.insert(QString("metrics"), ::OpenAPI::toJsonValue(m_metrics));
    }
    if (m_r_namespace_isSet) {
        obj.insert(QString("namespace"), ::OpenAPI::toJsonValue(m_r_namespace));
    }
    if (m_per_series_aligner_isSet) {
        obj.insert(QString("perSeriesAligner"), ::OpenAPI::toJsonValue(m_per_series_aligner));
    }
    if (m_period_isSet) {
        obj.insert(QString("period"), ::OpenAPI::toJsonValue(m_period));
    }
    if (m_project_name_isSet) {
        obj.insert(QString("projectName"), ::OpenAPI::toJsonValue(m_project_name));
    }
    if (m_query_isSet) {
        obj.insert(QString("query"), ::OpenAPI::toJsonValue(m_query));
    }
    if (m_raw_query_isSet) {
        obj.insert(QString("rawQuery"), ::OpenAPI::toJsonValue(m_raw_query));
    }
    if (m_raw_sql_isSet) {
        obj.insert(QString("rawSql"), ::OpenAPI::toJsonValue(m_raw_sql));
    }
    if (m_ref_id_isSet) {
        obj.insert(QString("refId"), ::OpenAPI::toJsonValue(m_ref_id));
    }
    if (m_region_isSet) {
        obj.insert(QString("region"), ::OpenAPI::toJsonValue(m_region));
    }
    if (m_select.size() > 0) {
        
        obj.insert(QString("select"), toJsonValue(m_select));
    }
    if (m_statistics.size() > 0) {
        obj.insert(QString("statistics"), ::OpenAPI::toJsonValue(m_statistics));
    }
    if (m_step_isSet) {
        obj.insert(QString("step"), ::OpenAPI::toJsonValue(m_step));
    }
    if (m_table_isSet) {
        obj.insert(QString("table"), ::OpenAPI::toJsonValue(m_table));
    }
    if (m_target_isSet) {
        obj.insert(QString("target"), ::OpenAPI::toJsonValue(m_target));
    }
    if (m_time_column_isSet) {
        obj.insert(QString("timeColumn"), ::OpenAPI::toJsonValue(m_time_column));
    }
    if (m_time_field_isSet) {
        obj.insert(QString("timeField"), ::OpenAPI::toJsonValue(m_time_field));
    }
    if (m_value_type_isSet) {
        obj.insert(QString("valueType"), ::OpenAPI::toJsonValue(m_value_type));
    }
    if (m_where.size() > 0) {
        obj.insert(QString("where"), ::OpenAPI::toJsonValue(m_where));
    }
    return obj;
}

QString OAITarget::getAlias() const {
    return m_alias;
}
void OAITarget::setAlias(const QString &alias) {
    m_alias = alias;
    m_alias_isSet = true;
}

bool OAITarget::is_alias_Set() const{
    return m_alias_isSet;
}

bool OAITarget::is_alias_Valid() const{
    return m_alias_isValid;
}

QString OAITarget::getAliasBy() const {
    return m_alias_by;
}
void OAITarget::setAliasBy(const QString &alias_by) {
    m_alias_by = alias_by;
    m_alias_by_isSet = true;
}

bool OAITarget::is_alias_by_Set() const{
    return m_alias_by_isSet;
}

bool OAITarget::is_alias_by_Valid() const{
    return m_alias_by_isValid;
}

QList<OAIStackdriverAlignOptions> OAITarget::getAlignOptions() const {
    return m_align_options;
}
void OAITarget::setAlignOptions(const QList<OAIStackdriverAlignOptions> &align_options) {
    m_align_options = align_options;
    m_align_options_isSet = true;
}

bool OAITarget::is_align_options_Set() const{
    return m_align_options_isSet;
}

bool OAITarget::is_align_options_Valid() const{
    return m_align_options_isValid;
}

QString OAITarget::getAlignmentPeriod() const {
    return m_alignment_period;
}
void OAITarget::setAlignmentPeriod(const QString &alignment_period) {
    m_alignment_period = alignment_period;
    m_alignment_period_isSet = true;
}

bool OAITarget::is_alignment_period_Set() const{
    return m_alignment_period_isSet;
}

bool OAITarget::is_alignment_period_Valid() const{
    return m_alignment_period_isValid;
}

QList<OAITarget_bucketAggs_inner> OAITarget::getBucketAggs() const {
    return m_bucket_aggs;
}
void OAITarget::setBucketAggs(const QList<OAITarget_bucketAggs_inner> &bucket_aggs) {
    m_bucket_aggs = bucket_aggs;
    m_bucket_aggs_isSet = true;
}

bool OAITarget::is_bucket_aggs_Set() const{
    return m_bucket_aggs_isSet;
}

bool OAITarget::is_bucket_aggs_Valid() const{
    return m_bucket_aggs_isValid;
}

QString OAITarget::getCrossSeriesReducer() const {
    return m_cross_series_reducer;
}
void OAITarget::setCrossSeriesReducer(const QString &cross_series_reducer) {
    m_cross_series_reducer = cross_series_reducer;
    m_cross_series_reducer_isSet = true;
}

bool OAITarget::is_cross_series_reducer_Set() const{
    return m_cross_series_reducer_isSet;
}

bool OAITarget::is_cross_series_reducer_Valid() const{
    return m_cross_series_reducer_isValid;
}

QString OAITarget::getDatasource() const {
    return m_datasource;
}
void OAITarget::setDatasource(const QString &datasource) {
    m_datasource = datasource;
    m_datasource_isSet = true;
}

bool OAITarget::is_datasource_Set() const{
    return m_datasource_isSet;
}

bool OAITarget::is_datasource_Valid() const{
    return m_datasource_isValid;
}

QMap<QString, QString> OAITarget::getDimensions() const {
    return m_dimensions;
}
void OAITarget::setDimensions(const QMap<QString, QString> &dimensions) {
    m_dimensions = dimensions;
    m_dimensions_isSet = true;
}

bool OAITarget::is_dimensions_Set() const{
    return m_dimensions_isSet;
}

bool OAITarget::is_dimensions_Valid() const{
    return m_dimensions_isValid;
}

QString OAITarget::getDsType() const {
    return m_ds_type;
}
void OAITarget::setDsType(const QString &ds_type) {
    m_ds_type = ds_type;
    m_ds_type_isSet = true;
}

bool OAITarget::is_ds_type_Set() const{
    return m_ds_type_isSet;
}

bool OAITarget::is_ds_type_Valid() const{
    return m_ds_type_isValid;
}

QString OAITarget::getExpr() const {
    return m_expr;
}
void OAITarget::setExpr(const QString &expr) {
    m_expr = expr;
    m_expr_isSet = true;
}

bool OAITarget::is_expr_Set() const{
    return m_expr_isSet;
}

bool OAITarget::is_expr_Valid() const{
    return m_expr_isValid;
}

QList<QString> OAITarget::getFilters() const {
    return m_filters;
}
void OAITarget::setFilters(const QList<QString> &filters) {
    m_filters = filters;
    m_filters_isSet = true;
}

bool OAITarget::is_filters_Set() const{
    return m_filters_isSet;
}

bool OAITarget::is_filters_Valid() const{
    return m_filters_isValid;
}

QString OAITarget::getFormat() const {
    return m_format;
}
void OAITarget::setFormat(const QString &format) {
    m_format = format;
    m_format_isSet = true;
}

bool OAITarget::is_format_Set() const{
    return m_format_isSet;
}

bool OAITarget::is_format_Valid() const{
    return m_format_isValid;
}

QList<OAITarget_group_inner> OAITarget::getGroup() const {
    return m_group;
}
void OAITarget::setGroup(const QList<OAITarget_group_inner> &group) {
    m_group = group;
    m_group_isSet = true;
}

bool OAITarget::is_group_Set() const{
    return m_group_isSet;
}

bool OAITarget::is_group_Valid() const{
    return m_group_isValid;
}

QList<QString> OAITarget::getGroupBys() const {
    return m_group_bys;
}
void OAITarget::setGroupBys(const QList<QString> &group_bys) {
    m_group_bys = group_bys;
    m_group_bys_isSet = true;
}

bool OAITarget::is_group_bys_Set() const{
    return m_group_bys_isSet;
}

bool OAITarget::is_group_bys_Valid() const{
    return m_group_bys_isValid;
}

bool OAITarget::isHide() const {
    return m_hide;
}
void OAITarget::setHide(const bool &hide) {
    m_hide = hide;
    m_hide_isSet = true;
}

bool OAITarget::is_hide_Set() const{
    return m_hide_isSet;
}

bool OAITarget::is_hide_Valid() const{
    return m_hide_isValid;
}

bool OAITarget::isInstant() const {
    return m_instant;
}
void OAITarget::setInstant(const bool &instant) {
    m_instant = instant;
    m_instant_isSet = true;
}

bool OAITarget::is_instant_Set() const{
    return m_instant_isSet;
}

bool OAITarget::is_instant_Valid() const{
    return m_instant_isValid;
}

QString OAITarget::getInterval() const {
    return m_interval;
}
void OAITarget::setInterval(const QString &interval) {
    m_interval = interval;
    m_interval_isSet = true;
}

bool OAITarget::is_interval_Set() const{
    return m_interval_isSet;
}

bool OAITarget::is_interval_Valid() const{
    return m_interval_isValid;
}

qint64 OAITarget::getIntervalFactor() const {
    return m_interval_factor;
}
void OAITarget::setIntervalFactor(const qint64 &interval_factor) {
    m_interval_factor = interval_factor;
    m_interval_factor_isSet = true;
}

bool OAITarget::is_interval_factor_Set() const{
    return m_interval_factor_isSet;
}

bool OAITarget::is_interval_factor_Valid() const{
    return m_interval_factor_isValid;
}

QString OAITarget::getLegendFormat() const {
    return m_legend_format;
}
void OAITarget::setLegendFormat(const QString &legend_format) {
    m_legend_format = legend_format;
    m_legend_format_isSet = true;
}

bool OAITarget::is_legend_format_Set() const{
    return m_legend_format_isSet;
}

bool OAITarget::is_legend_format_Valid() const{
    return m_legend_format_isValid;
}

QString OAITarget::getMeasurement() const {
    return m_measurement;
}
void OAITarget::setMeasurement(const QString &measurement) {
    m_measurement = measurement;
    m_measurement_isSet = true;
}

bool OAITarget::is_measurement_Set() const{
    return m_measurement_isSet;
}

bool OAITarget::is_measurement_Valid() const{
    return m_measurement_isValid;
}

QString OAITarget::getMetricColumn() const {
    return m_metric_column;
}
void OAITarget::setMetricColumn(const QString &metric_column) {
    m_metric_column = metric_column;
    m_metric_column_isSet = true;
}

bool OAITarget::is_metric_column_Set() const{
    return m_metric_column_isSet;
}

bool OAITarget::is_metric_column_Valid() const{
    return m_metric_column_isValid;
}

QString OAITarget::getMetricKind() const {
    return m_metric_kind;
}
void OAITarget::setMetricKind(const QString &metric_kind) {
    m_metric_kind = metric_kind;
    m_metric_kind_isSet = true;
}

bool OAITarget::is_metric_kind_Set() const{
    return m_metric_kind_isSet;
}

bool OAITarget::is_metric_kind_Valid() const{
    return m_metric_kind_isValid;
}

QString OAITarget::getMetricName() const {
    return m_metric_name;
}
void OAITarget::setMetricName(const QString &metric_name) {
    m_metric_name = metric_name;
    m_metric_name_isSet = true;
}

bool OAITarget::is_metric_name_Set() const{
    return m_metric_name_isSet;
}

bool OAITarget::is_metric_name_Valid() const{
    return m_metric_name_isValid;
}

QString OAITarget::getMetricType() const {
    return m_metric_type;
}
void OAITarget::setMetricType(const QString &metric_type) {
    m_metric_type = metric_type;
    m_metric_type_isSet = true;
}

bool OAITarget::is_metric_type_Set() const{
    return m_metric_type_isSet;
}

bool OAITarget::is_metric_type_Valid() const{
    return m_metric_type_isValid;
}

QList<OAITarget_metrics_inner> OAITarget::getMetrics() const {
    return m_metrics;
}
void OAITarget::setMetrics(const QList<OAITarget_metrics_inner> &metrics) {
    m_metrics = metrics;
    m_metrics_isSet = true;
}

bool OAITarget::is_metrics_Set() const{
    return m_metrics_isSet;
}

bool OAITarget::is_metrics_Valid() const{
    return m_metrics_isValid;
}

QString OAITarget::getRNamespace() const {
    return m_r_namespace;
}
void OAITarget::setRNamespace(const QString &r_namespace) {
    m_r_namespace = r_namespace;
    m_r_namespace_isSet = true;
}

bool OAITarget::is_r_namespace_Set() const{
    return m_r_namespace_isSet;
}

bool OAITarget::is_r_namespace_Valid() const{
    return m_r_namespace_isValid;
}

QString OAITarget::getPerSeriesAligner() const {
    return m_per_series_aligner;
}
void OAITarget::setPerSeriesAligner(const QString &per_series_aligner) {
    m_per_series_aligner = per_series_aligner;
    m_per_series_aligner_isSet = true;
}

bool OAITarget::is_per_series_aligner_Set() const{
    return m_per_series_aligner_isSet;
}

bool OAITarget::is_per_series_aligner_Valid() const{
    return m_per_series_aligner_isValid;
}

QString OAITarget::getPeriod() const {
    return m_period;
}
void OAITarget::setPeriod(const QString &period) {
    m_period = period;
    m_period_isSet = true;
}

bool OAITarget::is_period_Set() const{
    return m_period_isSet;
}

bool OAITarget::is_period_Valid() const{
    return m_period_isValid;
}

QString OAITarget::getProjectName() const {
    return m_project_name;
}
void OAITarget::setProjectName(const QString &project_name) {
    m_project_name = project_name;
    m_project_name_isSet = true;
}

bool OAITarget::is_project_name_Set() const{
    return m_project_name_isSet;
}

bool OAITarget::is_project_name_Valid() const{
    return m_project_name_isValid;
}

QString OAITarget::getQuery() const {
    return m_query;
}
void OAITarget::setQuery(const QString &query) {
    m_query = query;
    m_query_isSet = true;
}

bool OAITarget::is_query_Set() const{
    return m_query_isSet;
}

bool OAITarget::is_query_Valid() const{
    return m_query_isValid;
}

bool OAITarget::isRawQuery() const {
    return m_raw_query;
}
void OAITarget::setRawQuery(const bool &raw_query) {
    m_raw_query = raw_query;
    m_raw_query_isSet = true;
}

bool OAITarget::is_raw_query_Set() const{
    return m_raw_query_isSet;
}

bool OAITarget::is_raw_query_Valid() const{
    return m_raw_query_isValid;
}

QString OAITarget::getRawSql() const {
    return m_raw_sql;
}
void OAITarget::setRawSql(const QString &raw_sql) {
    m_raw_sql = raw_sql;
    m_raw_sql_isSet = true;
}

bool OAITarget::is_raw_sql_Set() const{
    return m_raw_sql_isSet;
}

bool OAITarget::is_raw_sql_Valid() const{
    return m_raw_sql_isValid;
}

QString OAITarget::getRefId() const {
    return m_ref_id;
}
void OAITarget::setRefId(const QString &ref_id) {
    m_ref_id = ref_id;
    m_ref_id_isSet = true;
}

bool OAITarget::is_ref_id_Set() const{
    return m_ref_id_isSet;
}

bool OAITarget::is_ref_id_Valid() const{
    return m_ref_id_isValid;
}

QString OAITarget::getRegion() const {
    return m_region;
}
void OAITarget::setRegion(const QString &region) {
    m_region = region;
    m_region_isSet = true;
}

bool OAITarget::is_region_Set() const{
    return m_region_isSet;
}

bool OAITarget::is_region_Valid() const{
    return m_region_isValid;
}

QList<QList<OAITarget_group_inner>> OAITarget::getSelect() const {
    return m_select;
}
void OAITarget::setSelect(const QList<QList<OAITarget_group_inner>> &select) {
    m_select = select;
    m_select_isSet = true;
}

bool OAITarget::is_select_Set() const{
    return m_select_isSet;
}

bool OAITarget::is_select_Valid() const{
    return m_select_isValid;
}

QList<QString> OAITarget::getStatistics() const {
    return m_statistics;
}
void OAITarget::setStatistics(const QList<QString> &statistics) {
    m_statistics = statistics;
    m_statistics_isSet = true;
}

bool OAITarget::is_statistics_Set() const{
    return m_statistics_isSet;
}

bool OAITarget::is_statistics_Valid() const{
    return m_statistics_isValid;
}

qint64 OAITarget::getStep() const {
    return m_step;
}
void OAITarget::setStep(const qint64 &step) {
    m_step = step;
    m_step_isSet = true;
}

bool OAITarget::is_step_Set() const{
    return m_step_isSet;
}

bool OAITarget::is_step_Valid() const{
    return m_step_isValid;
}

QString OAITarget::getTable() const {
    return m_table;
}
void OAITarget::setTable(const QString &table) {
    m_table = table;
    m_table_isSet = true;
}

bool OAITarget::is_table_Set() const{
    return m_table_isSet;
}

bool OAITarget::is_table_Valid() const{
    return m_table_isValid;
}

QString OAITarget::getTarget() const {
    return m_target;
}
void OAITarget::setTarget(const QString &target) {
    m_target = target;
    m_target_isSet = true;
}

bool OAITarget::is_target_Set() const{
    return m_target_isSet;
}

bool OAITarget::is_target_Valid() const{
    return m_target_isValid;
}

QString OAITarget::getTimeColumn() const {
    return m_time_column;
}
void OAITarget::setTimeColumn(const QString &time_column) {
    m_time_column = time_column;
    m_time_column_isSet = true;
}

bool OAITarget::is_time_column_Set() const{
    return m_time_column_isSet;
}

bool OAITarget::is_time_column_Valid() const{
    return m_time_column_isValid;
}

QString OAITarget::getTimeField() const {
    return m_time_field;
}
void OAITarget::setTimeField(const QString &time_field) {
    m_time_field = time_field;
    m_time_field_isSet = true;
}

bool OAITarget::is_time_field_Set() const{
    return m_time_field_isSet;
}

bool OAITarget::is_time_field_Valid() const{
    return m_time_field_isValid;
}

QString OAITarget::getValueType() const {
    return m_value_type;
}
void OAITarget::setValueType(const QString &value_type) {
    m_value_type = value_type;
    m_value_type_isSet = true;
}

bool OAITarget::is_value_type_Set() const{
    return m_value_type_isSet;
}

bool OAITarget::is_value_type_Valid() const{
    return m_value_type_isValid;
}

QList<OAITarget_where_inner> OAITarget::getWhere() const {
    return m_where;
}
void OAITarget::setWhere(const QList<OAITarget_where_inner> &where) {
    m_where = where;
    m_where_isSet = true;
}

bool OAITarget::is_where_Set() const{
    return m_where_isSet;
}

bool OAITarget::is_where_Valid() const{
    return m_where_isValid;
}

bool OAITarget::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alias_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_alias_by_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_align_options.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_alignment_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bucket_aggs.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_cross_series_reducer_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_datasource_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dimensions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_ds_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expr_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_filters.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_format_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_group.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_group_bys.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_hide_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instant_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_factor_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_legend_format_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_measurement_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_kind_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metrics.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_namespace_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_per_series_aligner_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_project_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_query_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_raw_query_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_raw_sql_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ref_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_region_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_select.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_statistics.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_step_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_table_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_target_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_column_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_field_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_value_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_where.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITarget::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
