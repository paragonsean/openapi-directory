/**
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIColumnStyle.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIColumnStyle::OAIColumnStyle(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIColumnStyle::OAIColumnStyle() {
    this->initializeModel();
}

OAIColumnStyle::~OAIColumnStyle() {}

void OAIColumnStyle::initializeModel() {

    m_alias_isSet = false;
    m_alias_isValid = false;

    m_color_mode_isSet = false;
    m_color_mode_isValid = false;

    m_colors_isSet = false;
    m_colors_isValid = false;

    m_date_format_isSet = false;
    m_date_format_isValid = false;

    m_decimals_isSet = false;
    m_decimals_isValid = false;

    m_link_isSet = false;
    m_link_isValid = false;

    m_link_target_blank_isSet = false;
    m_link_target_blank_isValid = false;

    m_link_tooltip_isSet = false;
    m_link_tooltip_isValid = false;

    m_link_url_isSet = false;
    m_link_url_isValid = false;

    m_mapping_type_isSet = false;
    m_mapping_type_isValid = false;

    m_pattern_isSet = false;
    m_pattern_isValid = false;

    m_thresholds_isSet = false;
    m_thresholds_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_unit_isSet = false;
    m_unit_isValid = false;

    m_value_maps_isSet = false;
    m_value_maps_isValid = false;
}

void OAIColumnStyle::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIColumnStyle::fromJsonObject(QJsonObject json) {

    m_alias_isValid = ::OpenAPI::fromJsonValue(m_alias, json[QString("alias")]);
    m_alias_isSet = !json[QString("alias")].isNull() && m_alias_isValid;

    m_color_mode_isValid = ::OpenAPI::fromJsonValue(m_color_mode, json[QString("colorMode")]);
    m_color_mode_isSet = !json[QString("colorMode")].isNull() && m_color_mode_isValid;

    m_colors_isValid = ::OpenAPI::fromJsonValue(m_colors, json[QString("colors")]);
    m_colors_isSet = !json[QString("colors")].isNull() && m_colors_isValid;

    m_date_format_isValid = ::OpenAPI::fromJsonValue(m_date_format, json[QString("dateFormat")]);
    m_date_format_isSet = !json[QString("dateFormat")].isNull() && m_date_format_isValid;

    m_decimals_isValid = ::OpenAPI::fromJsonValue(m_decimals, json[QString("decimals")]);
    m_decimals_isSet = !json[QString("decimals")].isNull() && m_decimals_isValid;

    m_link_isValid = ::OpenAPI::fromJsonValue(m_link, json[QString("link")]);
    m_link_isSet = !json[QString("link")].isNull() && m_link_isValid;

    m_link_target_blank_isValid = ::OpenAPI::fromJsonValue(m_link_target_blank, json[QString("linkTargetBlank")]);
    m_link_target_blank_isSet = !json[QString("linkTargetBlank")].isNull() && m_link_target_blank_isValid;

    m_link_tooltip_isValid = ::OpenAPI::fromJsonValue(m_link_tooltip, json[QString("linkTooltip")]);
    m_link_tooltip_isSet = !json[QString("linkTooltip")].isNull() && m_link_tooltip_isValid;

    m_link_url_isValid = ::OpenAPI::fromJsonValue(m_link_url, json[QString("linkUrl")]);
    m_link_url_isSet = !json[QString("linkUrl")].isNull() && m_link_url_isValid;

    m_mapping_type_isValid = ::OpenAPI::fromJsonValue(m_mapping_type, json[QString("mappingType")]);
    m_mapping_type_isSet = !json[QString("mappingType")].isNull() && m_mapping_type_isValid;

    m_pattern_isValid = ::OpenAPI::fromJsonValue(m_pattern, json[QString("pattern")]);
    m_pattern_isSet = !json[QString("pattern")].isNull() && m_pattern_isValid;

    m_thresholds_isValid = ::OpenAPI::fromJsonValue(m_thresholds, json[QString("thresholds")]);
    m_thresholds_isSet = !json[QString("thresholds")].isNull() && m_thresholds_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_unit_isValid = ::OpenAPI::fromJsonValue(m_unit, json[QString("unit")]);
    m_unit_isSet = !json[QString("unit")].isNull() && m_unit_isValid;

    m_value_maps_isValid = ::OpenAPI::fromJsonValue(m_value_maps, json[QString("valueMaps")]);
    m_value_maps_isSet = !json[QString("valueMaps")].isNull() && m_value_maps_isValid;
}

QString OAIColumnStyle::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIColumnStyle::asJsonObject() const {
    QJsonObject obj;
    if (m_alias_isSet) {
        obj.insert(QString("alias"), ::OpenAPI::toJsonValue(m_alias));
    }
    if (m_color_mode_isSet) {
        obj.insert(QString("colorMode"), ::OpenAPI::toJsonValue(m_color_mode));
    }
    if (m_colors.size() > 0) {
        obj.insert(QString("colors"), ::OpenAPI::toJsonValue(m_colors));
    }
    if (m_date_format_isSet) {
        obj.insert(QString("dateFormat"), ::OpenAPI::toJsonValue(m_date_format));
    }
    if (m_decimals_isSet) {
        obj.insert(QString("decimals"), ::OpenAPI::toJsonValue(m_decimals));
    }
    if (m_link_isSet) {
        obj.insert(QString("link"), ::OpenAPI::toJsonValue(m_link));
    }
    if (m_link_target_blank_isSet) {
        obj.insert(QString("linkTargetBlank"), ::OpenAPI::toJsonValue(m_link_target_blank));
    }
    if (m_link_tooltip_isSet) {
        obj.insert(QString("linkTooltip"), ::OpenAPI::toJsonValue(m_link_tooltip));
    }
    if (m_link_url_isSet) {
        obj.insert(QString("linkUrl"), ::OpenAPI::toJsonValue(m_link_url));
    }
    if (m_mapping_type_isSet) {
        obj.insert(QString("mappingType"), ::OpenAPI::toJsonValue(m_mapping_type));
    }
    if (m_pattern_isSet) {
        obj.insert(QString("pattern"), ::OpenAPI::toJsonValue(m_pattern));
    }
    if (m_thresholds.size() > 0) {
        obj.insert(QString("thresholds"), ::OpenAPI::toJsonValue(m_thresholds));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_unit_isSet) {
        obj.insert(QString("unit"), ::OpenAPI::toJsonValue(m_unit));
    }
    if (m_value_maps.size() > 0) {
        obj.insert(QString("valueMaps"), ::OpenAPI::toJsonValue(m_value_maps));
    }
    return obj;
}

QString OAIColumnStyle::getAlias() const {
    return m_alias;
}
void OAIColumnStyle::setAlias(const QString &alias) {
    m_alias = alias;
    m_alias_isSet = true;
}

bool OAIColumnStyle::is_alias_Set() const{
    return m_alias_isSet;
}

bool OAIColumnStyle::is_alias_Valid() const{
    return m_alias_isValid;
}

QString OAIColumnStyle::getColorMode() const {
    return m_color_mode;
}
void OAIColumnStyle::setColorMode(const QString &color_mode) {
    m_color_mode = color_mode;
    m_color_mode_isSet = true;
}

bool OAIColumnStyle::is_color_mode_Set() const{
    return m_color_mode_isSet;
}

bool OAIColumnStyle::is_color_mode_Valid() const{
    return m_color_mode_isValid;
}

QList<QString> OAIColumnStyle::getColors() const {
    return m_colors;
}
void OAIColumnStyle::setColors(const QList<QString> &colors) {
    m_colors = colors;
    m_colors_isSet = true;
}

bool OAIColumnStyle::is_colors_Set() const{
    return m_colors_isSet;
}

bool OAIColumnStyle::is_colors_Valid() const{
    return m_colors_isValid;
}

QString OAIColumnStyle::getDateFormat() const {
    return m_date_format;
}
void OAIColumnStyle::setDateFormat(const QString &date_format) {
    m_date_format = date_format;
    m_date_format_isSet = true;
}

bool OAIColumnStyle::is_date_format_Set() const{
    return m_date_format_isSet;
}

bool OAIColumnStyle::is_date_format_Valid() const{
    return m_date_format_isValid;
}

qint32 OAIColumnStyle::getDecimals() const {
    return m_decimals;
}
void OAIColumnStyle::setDecimals(const qint32 &decimals) {
    m_decimals = decimals;
    m_decimals_isSet = true;
}

bool OAIColumnStyle::is_decimals_Set() const{
    return m_decimals_isSet;
}

bool OAIColumnStyle::is_decimals_Valid() const{
    return m_decimals_isValid;
}

bool OAIColumnStyle::isLink() const {
    return m_link;
}
void OAIColumnStyle::setLink(const bool &link) {
    m_link = link;
    m_link_isSet = true;
}

bool OAIColumnStyle::is_link_Set() const{
    return m_link_isSet;
}

bool OAIColumnStyle::is_link_Valid() const{
    return m_link_isValid;
}

bool OAIColumnStyle::isLinkTargetBlank() const {
    return m_link_target_blank;
}
void OAIColumnStyle::setLinkTargetBlank(const bool &link_target_blank) {
    m_link_target_blank = link_target_blank;
    m_link_target_blank_isSet = true;
}

bool OAIColumnStyle::is_link_target_blank_Set() const{
    return m_link_target_blank_isSet;
}

bool OAIColumnStyle::is_link_target_blank_Valid() const{
    return m_link_target_blank_isValid;
}

QString OAIColumnStyle::getLinkTooltip() const {
    return m_link_tooltip;
}
void OAIColumnStyle::setLinkTooltip(const QString &link_tooltip) {
    m_link_tooltip = link_tooltip;
    m_link_tooltip_isSet = true;
}

bool OAIColumnStyle::is_link_tooltip_Set() const{
    return m_link_tooltip_isSet;
}

bool OAIColumnStyle::is_link_tooltip_Valid() const{
    return m_link_tooltip_isValid;
}

QString OAIColumnStyle::getLinkUrl() const {
    return m_link_url;
}
void OAIColumnStyle::setLinkUrl(const QString &link_url) {
    m_link_url = link_url;
    m_link_url_isSet = true;
}

bool OAIColumnStyle::is_link_url_Set() const{
    return m_link_url_isSet;
}

bool OAIColumnStyle::is_link_url_Valid() const{
    return m_link_url_isValid;
}

qint64 OAIColumnStyle::getMappingType() const {
    return m_mapping_type;
}
void OAIColumnStyle::setMappingType(const qint64 &mapping_type) {
    m_mapping_type = mapping_type;
    m_mapping_type_isSet = true;
}

bool OAIColumnStyle::is_mapping_type_Set() const{
    return m_mapping_type_isSet;
}

bool OAIColumnStyle::is_mapping_type_Valid() const{
    return m_mapping_type_isValid;
}

QString OAIColumnStyle::getPattern() const {
    return m_pattern;
}
void OAIColumnStyle::setPattern(const QString &pattern) {
    m_pattern = pattern;
    m_pattern_isSet = true;
}

bool OAIColumnStyle::is_pattern_Set() const{
    return m_pattern_isSet;
}

bool OAIColumnStyle::is_pattern_Valid() const{
    return m_pattern_isValid;
}

QList<QString> OAIColumnStyle::getThresholds() const {
    return m_thresholds;
}
void OAIColumnStyle::setThresholds(const QList<QString> &thresholds) {
    m_thresholds = thresholds;
    m_thresholds_isSet = true;
}

bool OAIColumnStyle::is_thresholds_Set() const{
    return m_thresholds_isSet;
}

bool OAIColumnStyle::is_thresholds_Valid() const{
    return m_thresholds_isValid;
}

QString OAIColumnStyle::getType() const {
    return m_type;
}
void OAIColumnStyle::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIColumnStyle::is_type_Set() const{
    return m_type_isSet;
}

bool OAIColumnStyle::is_type_Valid() const{
    return m_type_isValid;
}

QString OAIColumnStyle::getUnit() const {
    return m_unit;
}
void OAIColumnStyle::setUnit(const QString &unit) {
    m_unit = unit;
    m_unit_isSet = true;
}

bool OAIColumnStyle::is_unit_Set() const{
    return m_unit_isSet;
}

bool OAIColumnStyle::is_unit_Valid() const{
    return m_unit_isValid;
}

QList<OAIValueMap> OAIColumnStyle::getValueMaps() const {
    return m_value_maps;
}
void OAIColumnStyle::setValueMaps(const QList<OAIValueMap> &value_maps) {
    m_value_maps = value_maps;
    m_value_maps_isSet = true;
}

bool OAIColumnStyle::is_value_maps_Set() const{
    return m_value_maps_isSet;
}

bool OAIColumnStyle::is_value_maps_Valid() const{
    return m_value_maps_isValid;
}

bool OAIColumnStyle::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alias_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_colors.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_format_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_decimals_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_link_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_link_target_blank_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_link_tooltip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_link_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mapping_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pattern_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_thresholds.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_unit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_value_maps.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIColumnStyle::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
