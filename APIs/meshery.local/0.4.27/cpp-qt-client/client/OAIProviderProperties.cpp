/**
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIProviderProperties.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIProviderProperties::OAIProviderProperties(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIProviderProperties::OAIProviderProperties() {
    this->initializeModel();
}

OAIProviderProperties::~OAIProviderProperties() {}

void OAIProviderProperties::initializeModel() {

    m_capabilities_isSet = false;
    m_capabilities_isValid = false;

    m_extensions_isSet = false;
    m_extensions_isValid = false;

    m_package_url_isSet = false;
    m_package_url_isValid = false;

    m_package_version_isSet = false;
    m_package_version_isValid = false;

    m_provider_description_isSet = false;
    m_provider_description_isValid = false;

    m_provider_name_isSet = false;
    m_provider_name_isValid = false;

    m_provider_type_isSet = false;
    m_provider_type_isValid = false;

    m_provider_url_isSet = false;
    m_provider_url_isValid = false;
}

void OAIProviderProperties::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIProviderProperties::fromJsonObject(QJsonObject json) {

    m_capabilities_isValid = ::OpenAPI::fromJsonValue(m_capabilities, json[QString("capabilities")]);
    m_capabilities_isSet = !json[QString("capabilities")].isNull() && m_capabilities_isValid;

    m_extensions_isValid = ::OpenAPI::fromJsonValue(m_extensions, json[QString("extensions")]);
    m_extensions_isSet = !json[QString("extensions")].isNull() && m_extensions_isValid;

    m_package_url_isValid = ::OpenAPI::fromJsonValue(m_package_url, json[QString("package_url")]);
    m_package_url_isSet = !json[QString("package_url")].isNull() && m_package_url_isValid;

    m_package_version_isValid = ::OpenAPI::fromJsonValue(m_package_version, json[QString("package_version")]);
    m_package_version_isSet = !json[QString("package_version")].isNull() && m_package_version_isValid;

    m_provider_description_isValid = ::OpenAPI::fromJsonValue(m_provider_description, json[QString("provider_description")]);
    m_provider_description_isSet = !json[QString("provider_description")].isNull() && m_provider_description_isValid;

    m_provider_name_isValid = ::OpenAPI::fromJsonValue(m_provider_name, json[QString("provider_name")]);
    m_provider_name_isSet = !json[QString("provider_name")].isNull() && m_provider_name_isValid;

    m_provider_type_isValid = ::OpenAPI::fromJsonValue(m_provider_type, json[QString("provider_type")]);
    m_provider_type_isSet = !json[QString("provider_type")].isNull() && m_provider_type_isValid;

    m_provider_url_isValid = ::OpenAPI::fromJsonValue(m_provider_url, json[QString("provider_url")]);
    m_provider_url_isSet = !json[QString("provider_url")].isNull() && m_provider_url_isValid;
}

QString OAIProviderProperties::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIProviderProperties::asJsonObject() const {
    QJsonObject obj;
    if (m_capabilities.size() > 0) {
        obj.insert(QString("capabilities"), ::OpenAPI::toJsonValue(m_capabilities));
    }
    if (m_extensions.isSet()) {
        obj.insert(QString("extensions"), ::OpenAPI::toJsonValue(m_extensions));
    }
    if (m_package_url_isSet) {
        obj.insert(QString("package_url"), ::OpenAPI::toJsonValue(m_package_url));
    }
    if (m_package_version_isSet) {
        obj.insert(QString("package_version"), ::OpenAPI::toJsonValue(m_package_version));
    }
    if (m_provider_description.size() > 0) {
        obj.insert(QString("provider_description"), ::OpenAPI::toJsonValue(m_provider_description));
    }
    if (m_provider_name_isSet) {
        obj.insert(QString("provider_name"), ::OpenAPI::toJsonValue(m_provider_name));
    }
    if (m_provider_type_isSet) {
        obj.insert(QString("provider_type"), ::OpenAPI::toJsonValue(m_provider_type));
    }
    if (m_provider_url_isSet) {
        obj.insert(QString("provider_url"), ::OpenAPI::toJsonValue(m_provider_url));
    }
    return obj;
}

QList<OAICapability> OAIProviderProperties::getCapabilities() const {
    return m_capabilities;
}
void OAIProviderProperties::setCapabilities(const QList<OAICapability> &capabilities) {
    m_capabilities = capabilities;
    m_capabilities_isSet = true;
}

bool OAIProviderProperties::is_capabilities_Set() const{
    return m_capabilities_isSet;
}

bool OAIProviderProperties::is_capabilities_Valid() const{
    return m_capabilities_isValid;
}

OAIExtensions OAIProviderProperties::getExtensions() const {
    return m_extensions;
}
void OAIProviderProperties::setExtensions(const OAIExtensions &extensions) {
    m_extensions = extensions;
    m_extensions_isSet = true;
}

bool OAIProviderProperties::is_extensions_Set() const{
    return m_extensions_isSet;
}

bool OAIProviderProperties::is_extensions_Valid() const{
    return m_extensions_isValid;
}

QString OAIProviderProperties::getPackageUrl() const {
    return m_package_url;
}
void OAIProviderProperties::setPackageUrl(const QString &package_url) {
    m_package_url = package_url;
    m_package_url_isSet = true;
}

bool OAIProviderProperties::is_package_url_Set() const{
    return m_package_url_isSet;
}

bool OAIProviderProperties::is_package_url_Valid() const{
    return m_package_url_isValid;
}

QString OAIProviderProperties::getPackageVersion() const {
    return m_package_version;
}
void OAIProviderProperties::setPackageVersion(const QString &package_version) {
    m_package_version = package_version;
    m_package_version_isSet = true;
}

bool OAIProviderProperties::is_package_version_Set() const{
    return m_package_version_isSet;
}

bool OAIProviderProperties::is_package_version_Valid() const{
    return m_package_version_isValid;
}

QList<QString> OAIProviderProperties::getProviderDescription() const {
    return m_provider_description;
}
void OAIProviderProperties::setProviderDescription(const QList<QString> &provider_description) {
    m_provider_description = provider_description;
    m_provider_description_isSet = true;
}

bool OAIProviderProperties::is_provider_description_Set() const{
    return m_provider_description_isSet;
}

bool OAIProviderProperties::is_provider_description_Valid() const{
    return m_provider_description_isValid;
}

QString OAIProviderProperties::getProviderName() const {
    return m_provider_name;
}
void OAIProviderProperties::setProviderName(const QString &provider_name) {
    m_provider_name = provider_name;
    m_provider_name_isSet = true;
}

bool OAIProviderProperties::is_provider_name_Set() const{
    return m_provider_name_isSet;
}

bool OAIProviderProperties::is_provider_name_Valid() const{
    return m_provider_name_isValid;
}

QString OAIProviderProperties::getProviderType() const {
    return m_provider_type;
}
void OAIProviderProperties::setProviderType(const QString &provider_type) {
    m_provider_type = provider_type;
    m_provider_type_isSet = true;
}

bool OAIProviderProperties::is_provider_type_Set() const{
    return m_provider_type_isSet;
}

bool OAIProviderProperties::is_provider_type_Valid() const{
    return m_provider_type_isValid;
}

QString OAIProviderProperties::getProviderUrl() const {
    return m_provider_url;
}
void OAIProviderProperties::setProviderUrl(const QString &provider_url) {
    m_provider_url = provider_url;
    m_provider_url_isSet = true;
}

bool OAIProviderProperties::is_provider_url_Set() const{
    return m_provider_url_isSet;
}

bool OAIProviderProperties::is_provider_url_Valid() const{
    return m_provider_url_isValid;
}

bool OAIProviderProperties::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_capabilities.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_extensions.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_provider_description.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_provider_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_provider_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_provider_url_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIProviderProperties::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
