/**
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVolume.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVolume::OAIVolume(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVolume::OAIVolume() {
    this->initializeModel();
}

OAIVolume::~OAIVolume() {}

void OAIVolume::initializeModel() {

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_driver_isSet = false;
    m_driver_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_mountpoint_isSet = false;
    m_mountpoint_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_options_isSet = false;
    m_options_isValid = false;

    m_scope_isSet = false;
    m_scope_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_usage_data_isSet = false;
    m_usage_data_isValid = false;
}

void OAIVolume::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVolume::fromJsonObject(QJsonObject json) {

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("CreatedAt")]);
    m_created_at_isSet = !json[QString("CreatedAt")].isNull() && m_created_at_isValid;

    m_driver_isValid = ::OpenAPI::fromJsonValue(m_driver, json[QString("Driver")]);
    m_driver_isSet = !json[QString("Driver")].isNull() && m_driver_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("Labels")]);
    m_labels_isSet = !json[QString("Labels")].isNull() && m_labels_isValid;

    m_mountpoint_isValid = ::OpenAPI::fromJsonValue(m_mountpoint, json[QString("Mountpoint")]);
    m_mountpoint_isSet = !json[QString("Mountpoint")].isNull() && m_mountpoint_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("Name")]);
    m_name_isSet = !json[QString("Name")].isNull() && m_name_isValid;

    m_options_isValid = ::OpenAPI::fromJsonValue(m_options, json[QString("Options")]);
    m_options_isSet = !json[QString("Options")].isNull() && m_options_isValid;

    m_scope_isValid = ::OpenAPI::fromJsonValue(m_scope, json[QString("Scope")]);
    m_scope_isSet = !json[QString("Scope")].isNull() && m_scope_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("Status")]);
    m_status_isSet = !json[QString("Status")].isNull() && m_status_isValid;

    m_usage_data_isValid = ::OpenAPI::fromJsonValue(m_usage_data, json[QString("UsageData")]);
    m_usage_data_isSet = !json[QString("UsageData")].isNull() && m_usage_data_isValid;
}

QString OAIVolume::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVolume::asJsonObject() const {
    QJsonObject obj;
    if (m_created_at_isSet) {
        obj.insert(QString("CreatedAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_driver_isSet) {
        obj.insert(QString("Driver"), ::OpenAPI::toJsonValue(m_driver));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("Labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_mountpoint_isSet) {
        obj.insert(QString("Mountpoint"), ::OpenAPI::toJsonValue(m_mountpoint));
    }
    if (m_name_isSet) {
        obj.insert(QString("Name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_options.size() > 0) {
        obj.insert(QString("Options"), ::OpenAPI::toJsonValue(m_options));
    }
    if (m_scope_isSet) {
        obj.insert(QString("Scope"), ::OpenAPI::toJsonValue(m_scope));
    }
    if (m_status.size() > 0) {
        obj.insert(QString("Status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_usage_data.isSet()) {
        obj.insert(QString("UsageData"), ::OpenAPI::toJsonValue(m_usage_data));
    }
    return obj;
}

QString OAIVolume::getCreatedAt() const {
    return m_created_at;
}
void OAIVolume::setCreatedAt(const QString &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAIVolume::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAIVolume::is_created_at_Valid() const{
    return m_created_at_isValid;
}

QString OAIVolume::getDriver() const {
    return m_driver;
}
void OAIVolume::setDriver(const QString &driver) {
    m_driver = driver;
    m_driver_isSet = true;
}

bool OAIVolume::is_driver_Set() const{
    return m_driver_isSet;
}

bool OAIVolume::is_driver_Valid() const{
    return m_driver_isValid;
}

QMap<QString, QString> OAIVolume::getLabels() const {
    return m_labels;
}
void OAIVolume::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAIVolume::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAIVolume::is_labels_Valid() const{
    return m_labels_isValid;
}

QString OAIVolume::getMountpoint() const {
    return m_mountpoint;
}
void OAIVolume::setMountpoint(const QString &mountpoint) {
    m_mountpoint = mountpoint;
    m_mountpoint_isSet = true;
}

bool OAIVolume::is_mountpoint_Set() const{
    return m_mountpoint_isSet;
}

bool OAIVolume::is_mountpoint_Valid() const{
    return m_mountpoint_isValid;
}

QString OAIVolume::getName() const {
    return m_name;
}
void OAIVolume::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIVolume::is_name_Set() const{
    return m_name_isSet;
}

bool OAIVolume::is_name_Valid() const{
    return m_name_isValid;
}

QMap<QString, QString> OAIVolume::getOptions() const {
    return m_options;
}
void OAIVolume::setOptions(const QMap<QString, QString> &options) {
    m_options = options;
    m_options_isSet = true;
}

bool OAIVolume::is_options_Set() const{
    return m_options_isSet;
}

bool OAIVolume::is_options_Valid() const{
    return m_options_isValid;
}

QString OAIVolume::getScope() const {
    return m_scope;
}
void OAIVolume::setScope(const QString &scope) {
    m_scope = scope;
    m_scope_isSet = true;
}

bool OAIVolume::is_scope_Set() const{
    return m_scope_isSet;
}

bool OAIVolume::is_scope_Valid() const{
    return m_scope_isValid;
}

QMap<QString, OAIObject> OAIVolume::getStatus() const {
    return m_status;
}
void OAIVolume::setStatus(const QMap<QString, OAIObject> &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIVolume::is_status_Set() const{
    return m_status_isSet;
}

bool OAIVolume::is_status_Valid() const{
    return m_status_isValid;
}

OAIVolumeUsageData OAIVolume::getUsageData() const {
    return m_usage_data;
}
void OAIVolume::setUsageData(const OAIVolumeUsageData &usage_data) {
    m_usage_data = usage_data;
    m_usage_data_isSet = true;
}

bool OAIVolume::is_usage_data_Set() const{
    return m_usage_data_isSet;
}

bool OAIVolume::is_usage_data_Valid() const{
    return m_usage_data_isValid;
}

bool OAIVolume::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_driver_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_mountpoint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_options.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_scope_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_usage_data.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVolume::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_driver_isValid && m_labels_isValid && m_mountpoint_isValid && m_name_isValid && m_options_isValid && m_scope_isValid && true;
}

} // namespace OpenAPI
