/**
 * Meshery API.
 * the purpose of this application is to provide an application that is using plain go code to define an API  This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec
 *
 * The version of the OpenAPI document: 0.4.27
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIServiceSpec.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIServiceSpec::OAIServiceSpec(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIServiceSpec::OAIServiceSpec() {
    this->initializeModel();
}

OAIServiceSpec::~OAIServiceSpec() {}

void OAIServiceSpec::initializeModel() {

    m_cluster_ip_isSet = false;
    m_cluster_ip_isValid = false;

    m_external_ips_isSet = false;
    m_external_ips_isValid = false;

    m_external_name_isSet = false;
    m_external_name_isValid = false;

    m_external_traffic_policy_isSet = false;
    m_external_traffic_policy_isValid = false;

    m_health_check_node_port_isSet = false;
    m_health_check_node_port_isValid = false;

    m_ip_family_isSet = false;
    m_ip_family_isValid = false;

    m_load_balancer_ip_isSet = false;
    m_load_balancer_ip_isValid = false;

    m_load_balancer_source_ranges_isSet = false;
    m_load_balancer_source_ranges_isValid = false;

    m_ports_isSet = false;
    m_ports_isValid = false;

    m_publish_not_ready_addresses_isSet = false;
    m_publish_not_ready_addresses_isValid = false;

    m_selector_isSet = false;
    m_selector_isValid = false;

    m_session_affinity_isSet = false;
    m_session_affinity_isValid = false;

    m_session_affinity_config_isSet = false;
    m_session_affinity_config_isValid = false;

    m_topology_keys_isSet = false;
    m_topology_keys_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIServiceSpec::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIServiceSpec::fromJsonObject(QJsonObject json) {

    m_cluster_ip_isValid = ::OpenAPI::fromJsonValue(m_cluster_ip, json[QString("clusterIP")]);
    m_cluster_ip_isSet = !json[QString("clusterIP")].isNull() && m_cluster_ip_isValid;

    m_external_ips_isValid = ::OpenAPI::fromJsonValue(m_external_ips, json[QString("externalIPs")]);
    m_external_ips_isSet = !json[QString("externalIPs")].isNull() && m_external_ips_isValid;

    m_external_name_isValid = ::OpenAPI::fromJsonValue(m_external_name, json[QString("externalName")]);
    m_external_name_isSet = !json[QString("externalName")].isNull() && m_external_name_isValid;

    m_external_traffic_policy_isValid = ::OpenAPI::fromJsonValue(m_external_traffic_policy, json[QString("externalTrafficPolicy")]);
    m_external_traffic_policy_isSet = !json[QString("externalTrafficPolicy")].isNull() && m_external_traffic_policy_isValid;

    m_health_check_node_port_isValid = ::OpenAPI::fromJsonValue(m_health_check_node_port, json[QString("healthCheckNodePort")]);
    m_health_check_node_port_isSet = !json[QString("healthCheckNodePort")].isNull() && m_health_check_node_port_isValid;

    m_ip_family_isValid = ::OpenAPI::fromJsonValue(m_ip_family, json[QString("ipFamily")]);
    m_ip_family_isSet = !json[QString("ipFamily")].isNull() && m_ip_family_isValid;

    m_load_balancer_ip_isValid = ::OpenAPI::fromJsonValue(m_load_balancer_ip, json[QString("loadBalancerIP")]);
    m_load_balancer_ip_isSet = !json[QString("loadBalancerIP")].isNull() && m_load_balancer_ip_isValid;

    m_load_balancer_source_ranges_isValid = ::OpenAPI::fromJsonValue(m_load_balancer_source_ranges, json[QString("loadBalancerSourceRanges")]);
    m_load_balancer_source_ranges_isSet = !json[QString("loadBalancerSourceRanges")].isNull() && m_load_balancer_source_ranges_isValid;

    m_ports_isValid = ::OpenAPI::fromJsonValue(m_ports, json[QString("ports")]);
    m_ports_isSet = !json[QString("ports")].isNull() && m_ports_isValid;

    m_publish_not_ready_addresses_isValid = ::OpenAPI::fromJsonValue(m_publish_not_ready_addresses, json[QString("publishNotReadyAddresses")]);
    m_publish_not_ready_addresses_isSet = !json[QString("publishNotReadyAddresses")].isNull() && m_publish_not_ready_addresses_isValid;

    m_selector_isValid = ::OpenAPI::fromJsonValue(m_selector, json[QString("selector")]);
    m_selector_isSet = !json[QString("selector")].isNull() && m_selector_isValid;

    m_session_affinity_isValid = ::OpenAPI::fromJsonValue(m_session_affinity, json[QString("sessionAffinity")]);
    m_session_affinity_isSet = !json[QString("sessionAffinity")].isNull() && m_session_affinity_isValid;

    m_session_affinity_config_isValid = ::OpenAPI::fromJsonValue(m_session_affinity_config, json[QString("sessionAffinityConfig")]);
    m_session_affinity_config_isSet = !json[QString("sessionAffinityConfig")].isNull() && m_session_affinity_config_isValid;

    m_topology_keys_isValid = ::OpenAPI::fromJsonValue(m_topology_keys, json[QString("topologyKeys")]);
    m_topology_keys_isSet = !json[QString("topologyKeys")].isNull() && m_topology_keys_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIServiceSpec::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIServiceSpec::asJsonObject() const {
    QJsonObject obj;
    if (m_cluster_ip_isSet) {
        obj.insert(QString("clusterIP"), ::OpenAPI::toJsonValue(m_cluster_ip));
    }
    if (m_external_ips.size() > 0) {
        obj.insert(QString("externalIPs"), ::OpenAPI::toJsonValue(m_external_ips));
    }
    if (m_external_name_isSet) {
        obj.insert(QString("externalName"), ::OpenAPI::toJsonValue(m_external_name));
    }
    if (m_external_traffic_policy_isSet) {
        obj.insert(QString("externalTrafficPolicy"), ::OpenAPI::toJsonValue(m_external_traffic_policy));
    }
    if (m_health_check_node_port_isSet) {
        obj.insert(QString("healthCheckNodePort"), ::OpenAPI::toJsonValue(m_health_check_node_port));
    }
    if (m_ip_family_isSet) {
        obj.insert(QString("ipFamily"), ::OpenAPI::toJsonValue(m_ip_family));
    }
    if (m_load_balancer_ip_isSet) {
        obj.insert(QString("loadBalancerIP"), ::OpenAPI::toJsonValue(m_load_balancer_ip));
    }
    if (m_load_balancer_source_ranges.size() > 0) {
        obj.insert(QString("loadBalancerSourceRanges"), ::OpenAPI::toJsonValue(m_load_balancer_source_ranges));
    }
    if (m_ports.size() > 0) {
        obj.insert(QString("ports"), ::OpenAPI::toJsonValue(m_ports));
    }
    if (m_publish_not_ready_addresses_isSet) {
        obj.insert(QString("publishNotReadyAddresses"), ::OpenAPI::toJsonValue(m_publish_not_ready_addresses));
    }
    if (m_selector.size() > 0) {
        obj.insert(QString("selector"), ::OpenAPI::toJsonValue(m_selector));
    }
    if (m_session_affinity_isSet) {
        obj.insert(QString("sessionAffinity"), ::OpenAPI::toJsonValue(m_session_affinity));
    }
    if (m_session_affinity_config.isSet()) {
        obj.insert(QString("sessionAffinityConfig"), ::OpenAPI::toJsonValue(m_session_affinity_config));
    }
    if (m_topology_keys.size() > 0) {
        obj.insert(QString("topologyKeys"), ::OpenAPI::toJsonValue(m_topology_keys));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QString OAIServiceSpec::getClusterIp() const {
    return m_cluster_ip;
}
void OAIServiceSpec::setClusterIp(const QString &cluster_ip) {
    m_cluster_ip = cluster_ip;
    m_cluster_ip_isSet = true;
}

bool OAIServiceSpec::is_cluster_ip_Set() const{
    return m_cluster_ip_isSet;
}

bool OAIServiceSpec::is_cluster_ip_Valid() const{
    return m_cluster_ip_isValid;
}

QList<QString> OAIServiceSpec::getExternalIps() const {
    return m_external_ips;
}
void OAIServiceSpec::setExternalIps(const QList<QString> &external_ips) {
    m_external_ips = external_ips;
    m_external_ips_isSet = true;
}

bool OAIServiceSpec::is_external_ips_Set() const{
    return m_external_ips_isSet;
}

bool OAIServiceSpec::is_external_ips_Valid() const{
    return m_external_ips_isValid;
}

QString OAIServiceSpec::getExternalName() const {
    return m_external_name;
}
void OAIServiceSpec::setExternalName(const QString &external_name) {
    m_external_name = external_name;
    m_external_name_isSet = true;
}

bool OAIServiceSpec::is_external_name_Set() const{
    return m_external_name_isSet;
}

bool OAIServiceSpec::is_external_name_Valid() const{
    return m_external_name_isValid;
}

QString OAIServiceSpec::getExternalTrafficPolicy() const {
    return m_external_traffic_policy;
}
void OAIServiceSpec::setExternalTrafficPolicy(const QString &external_traffic_policy) {
    m_external_traffic_policy = external_traffic_policy;
    m_external_traffic_policy_isSet = true;
}

bool OAIServiceSpec::is_external_traffic_policy_Set() const{
    return m_external_traffic_policy_isSet;
}

bool OAIServiceSpec::is_external_traffic_policy_Valid() const{
    return m_external_traffic_policy_isValid;
}

qint32 OAIServiceSpec::getHealthCheckNodePort() const {
    return m_health_check_node_port;
}
void OAIServiceSpec::setHealthCheckNodePort(const qint32 &health_check_node_port) {
    m_health_check_node_port = health_check_node_port;
    m_health_check_node_port_isSet = true;
}

bool OAIServiceSpec::is_health_check_node_port_Set() const{
    return m_health_check_node_port_isSet;
}

bool OAIServiceSpec::is_health_check_node_port_Valid() const{
    return m_health_check_node_port_isValid;
}

QString OAIServiceSpec::getIpFamily() const {
    return m_ip_family;
}
void OAIServiceSpec::setIpFamily(const QString &ip_family) {
    m_ip_family = ip_family;
    m_ip_family_isSet = true;
}

bool OAIServiceSpec::is_ip_family_Set() const{
    return m_ip_family_isSet;
}

bool OAIServiceSpec::is_ip_family_Valid() const{
    return m_ip_family_isValid;
}

QString OAIServiceSpec::getLoadBalancerIp() const {
    return m_load_balancer_ip;
}
void OAIServiceSpec::setLoadBalancerIp(const QString &load_balancer_ip) {
    m_load_balancer_ip = load_balancer_ip;
    m_load_balancer_ip_isSet = true;
}

bool OAIServiceSpec::is_load_balancer_ip_Set() const{
    return m_load_balancer_ip_isSet;
}

bool OAIServiceSpec::is_load_balancer_ip_Valid() const{
    return m_load_balancer_ip_isValid;
}

QList<QString> OAIServiceSpec::getLoadBalancerSourceRanges() const {
    return m_load_balancer_source_ranges;
}
void OAIServiceSpec::setLoadBalancerSourceRanges(const QList<QString> &load_balancer_source_ranges) {
    m_load_balancer_source_ranges = load_balancer_source_ranges;
    m_load_balancer_source_ranges_isSet = true;
}

bool OAIServiceSpec::is_load_balancer_source_ranges_Set() const{
    return m_load_balancer_source_ranges_isSet;
}

bool OAIServiceSpec::is_load_balancer_source_ranges_Valid() const{
    return m_load_balancer_source_ranges_isValid;
}

QList<OAIServicePort> OAIServiceSpec::getPorts() const {
    return m_ports;
}
void OAIServiceSpec::setPorts(const QList<OAIServicePort> &ports) {
    m_ports = ports;
    m_ports_isSet = true;
}

bool OAIServiceSpec::is_ports_Set() const{
    return m_ports_isSet;
}

bool OAIServiceSpec::is_ports_Valid() const{
    return m_ports_isValid;
}

bool OAIServiceSpec::isPublishNotReadyAddresses() const {
    return m_publish_not_ready_addresses;
}
void OAIServiceSpec::setPublishNotReadyAddresses(const bool &publish_not_ready_addresses) {
    m_publish_not_ready_addresses = publish_not_ready_addresses;
    m_publish_not_ready_addresses_isSet = true;
}

bool OAIServiceSpec::is_publish_not_ready_addresses_Set() const{
    return m_publish_not_ready_addresses_isSet;
}

bool OAIServiceSpec::is_publish_not_ready_addresses_Valid() const{
    return m_publish_not_ready_addresses_isValid;
}

QMap<QString, QString> OAIServiceSpec::getSelector() const {
    return m_selector;
}
void OAIServiceSpec::setSelector(const QMap<QString, QString> &selector) {
    m_selector = selector;
    m_selector_isSet = true;
}

bool OAIServiceSpec::is_selector_Set() const{
    return m_selector_isSet;
}

bool OAIServiceSpec::is_selector_Valid() const{
    return m_selector_isValid;
}

QString OAIServiceSpec::getSessionAffinity() const {
    return m_session_affinity;
}
void OAIServiceSpec::setSessionAffinity(const QString &session_affinity) {
    m_session_affinity = session_affinity;
    m_session_affinity_isSet = true;
}

bool OAIServiceSpec::is_session_affinity_Set() const{
    return m_session_affinity_isSet;
}

bool OAIServiceSpec::is_session_affinity_Valid() const{
    return m_session_affinity_isValid;
}

OAISessionAffinityConfig OAIServiceSpec::getSessionAffinityConfig() const {
    return m_session_affinity_config;
}
void OAIServiceSpec::setSessionAffinityConfig(const OAISessionAffinityConfig &session_affinity_config) {
    m_session_affinity_config = session_affinity_config;
    m_session_affinity_config_isSet = true;
}

bool OAIServiceSpec::is_session_affinity_config_Set() const{
    return m_session_affinity_config_isSet;
}

bool OAIServiceSpec::is_session_affinity_config_Valid() const{
    return m_session_affinity_config_isValid;
}

QList<QString> OAIServiceSpec::getTopologyKeys() const {
    return m_topology_keys;
}
void OAIServiceSpec::setTopologyKeys(const QList<QString> &topology_keys) {
    m_topology_keys = topology_keys;
    m_topology_keys_isSet = true;
}

bool OAIServiceSpec::is_topology_keys_Set() const{
    return m_topology_keys_isSet;
}

bool OAIServiceSpec::is_topology_keys_Valid() const{
    return m_topology_keys_isValid;
}

QString OAIServiceSpec::getType() const {
    return m_type;
}
void OAIServiceSpec::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIServiceSpec::is_type_Set() const{
    return m_type_isSet;
}

bool OAIServiceSpec::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIServiceSpec::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cluster_ip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_external_ips.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_external_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_external_traffic_policy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_health_check_node_port_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_family_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_load_balancer_ip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_load_balancer_source_ranges.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_ports.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_publish_not_ready_addresses_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_selector.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_session_affinity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_session_affinity_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_topology_keys.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIServiceSpec::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
