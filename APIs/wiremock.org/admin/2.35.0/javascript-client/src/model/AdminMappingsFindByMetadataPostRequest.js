/**
 * WireMock
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import JSONEquals from './JSONEquals';
import JSONPathMatch from './JSONPathMatch';
import NegativeRegularExpressionMatch from './NegativeRegularExpressionMatch';
import RegularExpressionMatch from './RegularExpressionMatch';
import StringContains from './StringContains';
import StringEquals from './StringEquals';
import XMLEquality from './XMLEquality';
import XPathMatch from './XPathMatch';

/**
 * The AdminMappingsFindByMetadataPostRequest model module.
 * @module model/AdminMappingsFindByMetadataPostRequest
 * @version 2.35.0
 */
class AdminMappingsFindByMetadataPostRequest {
    /**
     * Constructs a new <code>AdminMappingsFindByMetadataPostRequest</code>.
     * @alias module:model/AdminMappingsFindByMetadataPostRequest
     * @param {(module:model/JSONEquals|module:model/JSONPathMatch|module:model/NegativeRegularExpressionMatch|module:model/RegularExpressionMatch|module:model/StringContains|module:model/StringEquals|module:model/XMLEquality|module:model/XPathMatch)} instance The actual instance to initialize AdminMappingsFindByMetadataPostRequest.
     */
    constructor(instance = null) {
        if (instance === null) {
            this.actualInstance = null;
            return;
        }
        var match = 0;
        var errorMessages = [];
        try {
            if (typeof instance === "StringEquals") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                StringEquals.validateJSON(instance); // throw an exception if no match
                // create StringEquals from JS object
                this.actualInstance = StringEquals.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into StringEquals
            errorMessages.push("Failed to construct StringEquals: " + err)
        }

        try {
            if (typeof instance === "StringContains") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                StringContains.validateJSON(instance); // throw an exception if no match
                // create StringContains from JS object
                this.actualInstance = StringContains.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into StringContains
            errorMessages.push("Failed to construct StringContains: " + err)
        }

        try {
            if (typeof instance === "RegularExpressionMatch") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                RegularExpressionMatch.validateJSON(instance); // throw an exception if no match
                // create RegularExpressionMatch from JS object
                this.actualInstance = RegularExpressionMatch.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into RegularExpressionMatch
            errorMessages.push("Failed to construct RegularExpressionMatch: " + err)
        }

        try {
            if (typeof instance === "NegativeRegularExpressionMatch") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                NegativeRegularExpressionMatch.validateJSON(instance); // throw an exception if no match
                // create NegativeRegularExpressionMatch from JS object
                this.actualInstance = NegativeRegularExpressionMatch.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into NegativeRegularExpressionMatch
            errorMessages.push("Failed to construct NegativeRegularExpressionMatch: " + err)
        }

        try {
            if (typeof instance === "JSONEquals") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                JSONEquals.validateJSON(instance); // throw an exception if no match
                // create JSONEquals from JS object
                this.actualInstance = JSONEquals.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into JSONEquals
            errorMessages.push("Failed to construct JSONEquals: " + err)
        }

        try {
            if (typeof instance === "JSONPathMatch") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                JSONPathMatch.validateJSON(instance); // throw an exception if no match
                // create JSONPathMatch from JS object
                this.actualInstance = JSONPathMatch.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into JSONPathMatch
            errorMessages.push("Failed to construct JSONPathMatch: " + err)
        }

        try {
            if (typeof instance === "XMLEquality") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                XMLEquality.validateJSON(instance); // throw an exception if no match
                // create XMLEquality from JS object
                this.actualInstance = XMLEquality.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into XMLEquality
            errorMessages.push("Failed to construct XMLEquality: " + err)
        }

        try {
            if (typeof instance === "XPathMatch") {
                this.actualInstance = instance;
            } else {
                // plain JS object
                // validate the object
                XPathMatch.validateJSON(instance); // throw an exception if no match
                // create XPathMatch from JS object
                this.actualInstance = XPathMatch.constructFromObject(instance);
            }
            match++;
        } catch(err) {
            // json data failed to deserialize into XPathMatch
            errorMessages.push("Failed to construct XPathMatch: " + err)
        }

        if (match > 1) {
            throw new Error("Multiple matches found constructing `AdminMappingsFindByMetadataPostRequest` with oneOf schemas JSONEquals, JSONPathMatch, NegativeRegularExpressionMatch, RegularExpressionMatch, StringContains, StringEquals, XMLEquality, XPathMatch. Input: " + JSON.stringify(instance));
        } else if (match === 0) {
            this.actualInstance = null; // clear the actual instance in case there are multiple matches
            throw new Error("No match found constructing `AdminMappingsFindByMetadataPostRequest` with oneOf schemas JSONEquals, JSONPathMatch, NegativeRegularExpressionMatch, RegularExpressionMatch, StringContains, StringEquals, XMLEquality, XPathMatch. Details: " +
                            errorMessages.join(", "));
        } else { // only 1 match
            // the input is valid
        }
    }

    /**
     * Constructs a <code>AdminMappingsFindByMetadataPostRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/AdminMappingsFindByMetadataPostRequest} obj Optional instance to populate.
     * @return {module:model/AdminMappingsFindByMetadataPostRequest} The populated <code>AdminMappingsFindByMetadataPostRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        return new AdminMappingsFindByMetadataPostRequest(data);
    }

    /**
     * Gets the actual instance, which can be <code>JSONEquals</code>, <code>JSONPathMatch</code>, <code>NegativeRegularExpressionMatch</code>, <code>RegularExpressionMatch</code>, <code>StringContains</code>, <code>StringEquals</code>, <code>XMLEquality</code>, <code>XPathMatch</code>.
     * @return {(module:model/JSONEquals|module:model/JSONPathMatch|module:model/NegativeRegularExpressionMatch|module:model/RegularExpressionMatch|module:model/StringContains|module:model/StringEquals|module:model/XMLEquality|module:model/XPathMatch)} The actual instance.
     */
    getActualInstance() {
        return this.actualInstance;
    }

    /**
     * Sets the actual instance, which can be <code>JSONEquals</code>, <code>JSONPathMatch</code>, <code>NegativeRegularExpressionMatch</code>, <code>RegularExpressionMatch</code>, <code>StringContains</code>, <code>StringEquals</code>, <code>XMLEquality</code>, <code>XPathMatch</code>.
     * @param {(module:model/JSONEquals|module:model/JSONPathMatch|module:model/NegativeRegularExpressionMatch|module:model/RegularExpressionMatch|module:model/StringContains|module:model/StringEquals|module:model/XMLEquality|module:model/XPathMatch)} obj The actual instance.
     */
    setActualInstance(obj) {
       this.actualInstance = AdminMappingsFindByMetadataPostRequest.constructFromObject(obj).getActualInstance();
    }

    /**
     * Returns the JSON representation of the actual instance.
     * @return {string}
     */
    toJSON = function(){
        return this.getActualInstance();
    }

    /**
     * Create an instance of AdminMappingsFindByMetadataPostRequest from a JSON string.
     * @param {string} json_string JSON string.
     * @return {module:model/AdminMappingsFindByMetadataPostRequest} An instance of AdminMappingsFindByMetadataPostRequest.
     */
    static fromJSON = function(json_string){
        return AdminMappingsFindByMetadataPostRequest.constructFromObject(JSON.parse(json_string));
    }
}

/**
 * @member {Boolean} caseInsensitive
 */
AdminMappingsFindByMetadataPostRequest.prototype['caseInsensitive'] = undefined;

/**
 * @member {Boolean} equalTo
 */
AdminMappingsFindByMetadataPostRequest.prototype['equalTo'] = undefined;

/**
 * @member {String} contains
 */
AdminMappingsFindByMetadataPostRequest.prototype['contains'] = undefined;

/**
 * @member {String} matches
 */
AdminMappingsFindByMetadataPostRequest.prototype['matches'] = undefined;

/**
 * @member {String} doesNotMatch
 */
AdminMappingsFindByMetadataPostRequest.prototype['doesNotMatch'] = undefined;

/**
 * @member {String} equalToJson
 */
AdminMappingsFindByMetadataPostRequest.prototype['equalToJson'] = undefined;

/**
 * @member {Boolean} ignoreArrayOrder
 */
AdminMappingsFindByMetadataPostRequest.prototype['ignoreArrayOrder'] = undefined;

/**
 * @member {Boolean} ignoreExtraElements
 */
AdminMappingsFindByMetadataPostRequest.prototype['ignoreExtraElements'] = undefined;

/**
 * @member {String} matchesJsonPath
 */
AdminMappingsFindByMetadataPostRequest.prototype['matchesJsonPath'] = undefined;

/**
 * @member {String} equalToXml
 */
AdminMappingsFindByMetadataPostRequest.prototype['equalToXml'] = undefined;

/**
 * @member {String} matchesXpath
 */
AdminMappingsFindByMetadataPostRequest.prototype['matchesXpath'] = undefined;

/**
 * @member {Object} namespaces
 */
AdminMappingsFindByMetadataPostRequest.prototype['namespaces'] = undefined;

/**
 * @member {Object} valuePattern
 */
AdminMappingsFindByMetadataPostRequest.prototype['valuePattern'] = undefined;


AdminMappingsFindByMetadataPostRequest.OneOf = ["JSONEquals", "JSONPathMatch", "NegativeRegularExpressionMatch", "RegularExpressionMatch", "StringContains", "StringEquals", "XMLEquality", "XPathMatch"];

export default AdminMappingsFindByMetadataPostRequest;

