/*
 * Storecove API
 * Storecove API
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: apisupport@storecove.nl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PurchaseInvoiceUbl
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:44.175207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PurchaseInvoiceUbl {
  public static final String SERIALIZED_NAME_EXTERNAL_KEY = "external_key";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_KEY)
  private String externalKey;

  public static final String SERIALIZED_NAME_EXTERNAL_USER_ID = "external_user_id";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_USER_ID)
  private String externalUserId;

  public static final String SERIALIZED_NAME_GUID = "guid";
  @SerializedName(SERIALIZED_NAME_GUID)
  private UUID guid;

  public static final String SERIALIZED_NAME_LEGAL_ENTITY_ID = "legal_entity_id";
  @SerializedName(SERIALIZED_NAME_LEGAL_ENTITY_ID)
  private Long legalEntityId;

  public static final String SERIALIZED_NAME_SYSTEM_GENERATED_PRIMARY_IMAGE = "system_generated_primary_image";
  @SerializedName(SERIALIZED_NAME_SYSTEM_GENERATED_PRIMARY_IMAGE)
  private Boolean systemGeneratedPrimaryImage;

  public static final String SERIALIZED_NAME_TAX_SYSTEM = "tax_system";
  @SerializedName(SERIALIZED_NAME_TAX_SYSTEM)
  private String taxSystem;

  public static final String SERIALIZED_NAME_UBL = "ubl";
  @SerializedName(SERIALIZED_NAME_UBL)
  private String ubl;

  public PurchaseInvoiceUbl() {
  }

  public PurchaseInvoiceUbl externalKey(String externalKey) {
    this.externalKey = externalKey;
    return this;
  }

  /**
   * Used for accountants. The id you specified for the organization.
   * @return externalKey
   */
  @javax.annotation.Nullable
  public String getExternalKey() {
    return externalKey;
  }

  public void setExternalKey(String externalKey) {
    this.externalKey = externalKey;
  }


  public PurchaseInvoiceUbl externalUserId(String externalUserId) {
    this.externalUserId = externalUserId;
    return this;
  }

  /**
   * Used for the embedded portal retrieval service. The external_user_id you provided when the ShopAccount was created.
   * @return externalUserId
   */
  @javax.annotation.Nullable
  public String getExternalUserId() {
    return externalUserId;
  }

  public void setExternalUserId(String externalUserId) {
    this.externalUserId = externalUserId;
  }


  public PurchaseInvoiceUbl guid(UUID guid) {
    this.guid = guid;
    return this;
  }

  /**
   * The GUID of the invoice
   * @return guid
   */
  @javax.annotation.Nullable
  public UUID getGuid() {
    return guid;
  }

  public void setGuid(UUID guid) {
    this.guid = guid;
  }


  public PurchaseInvoiceUbl legalEntityId(Long legalEntityId) {
    this.legalEntityId = legalEntityId;
    return this;
  }

  /**
   * The id of the LegalEntity the invoice was received for.
   * @return legalEntityId
   */
  @javax.annotation.Nullable
  public Long getLegalEntityId() {
    return legalEntityId;
  }

  public void setLegalEntityId(Long legalEntityId) {
    this.legalEntityId = legalEntityId;
  }


  public PurchaseInvoiceUbl systemGeneratedPrimaryImage(Boolean systemGeneratedPrimaryImage) {
    this.systemGeneratedPrimaryImage = systemGeneratedPrimaryImage;
    return this;
  }

  /**
   * Whether or not the document image (PDF) was generated by Storecove. If true, it means the invoice was received without any attachments and Storecove generated one for you. If false, the invoice will contain at least one attachment, which was received from the invoice sender.
   * @return systemGeneratedPrimaryImage
   */
  @javax.annotation.Nullable
  public Boolean getSystemGeneratedPrimaryImage() {
    return systemGeneratedPrimaryImage;
  }

  public void setSystemGeneratedPrimaryImage(Boolean systemGeneratedPrimaryImage) {
    this.systemGeneratedPrimaryImage = systemGeneratedPrimaryImage;
  }


  public PurchaseInvoiceUbl taxSystem(String taxSystem) {
    this.taxSystem = taxSystem;
    return this;
  }

  /**
   * The tax system of the invoice. Either tax_line_percentages or tax_line_amounts. The first tax system means the invoice lines contain only the tax percentages and the tax amounts are included only in the tax subtotals at the invoice level and so are only calculated at the invoice level. The tax system tax_line_amounts means that in addition to the percentage, each invoice line also contains the tax amount. The tax subtotals at the invoice level are calculated as the sum of the tax of the invoice lines. The distinction between the two tax systems has has implications for rounding.
   * @return taxSystem
   */
  @javax.annotation.Nullable
  public String getTaxSystem() {
    return taxSystem;
  }

  public void setTaxSystem(String taxSystem) {
    this.taxSystem = taxSystem;
  }


  public PurchaseInvoiceUbl ubl(String ubl) {
    this.ubl = ubl;
    return this;
  }

  /**
   * The Base64 encoded UBL invoice.
   * @return ubl
   */
  @javax.annotation.Nullable
  public String getUbl() {
    return ubl;
  }

  public void setUbl(String ubl) {
    this.ubl = ubl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PurchaseInvoiceUbl purchaseInvoiceUbl = (PurchaseInvoiceUbl) o;
    return Objects.equals(this.externalKey, purchaseInvoiceUbl.externalKey) &&
        Objects.equals(this.externalUserId, purchaseInvoiceUbl.externalUserId) &&
        Objects.equals(this.guid, purchaseInvoiceUbl.guid) &&
        Objects.equals(this.legalEntityId, purchaseInvoiceUbl.legalEntityId) &&
        Objects.equals(this.systemGeneratedPrimaryImage, purchaseInvoiceUbl.systemGeneratedPrimaryImage) &&
        Objects.equals(this.taxSystem, purchaseInvoiceUbl.taxSystem) &&
        Objects.equals(this.ubl, purchaseInvoiceUbl.ubl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(externalKey, externalUserId, guid, legalEntityId, systemGeneratedPrimaryImage, taxSystem, ubl);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PurchaseInvoiceUbl {\n");
    sb.append("    externalKey: ").append(toIndentedString(externalKey)).append("\n");
    sb.append("    externalUserId: ").append(toIndentedString(externalUserId)).append("\n");
    sb.append("    guid: ").append(toIndentedString(guid)).append("\n");
    sb.append("    legalEntityId: ").append(toIndentedString(legalEntityId)).append("\n");
    sb.append("    systemGeneratedPrimaryImage: ").append(toIndentedString(systemGeneratedPrimaryImage)).append("\n");
    sb.append("    taxSystem: ").append(toIndentedString(taxSystem)).append("\n");
    sb.append("    ubl: ").append(toIndentedString(ubl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("external_key");
    openapiFields.add("external_user_id");
    openapiFields.add("guid");
    openapiFields.add("legal_entity_id");
    openapiFields.add("system_generated_primary_image");
    openapiFields.add("tax_system");
    openapiFields.add("ubl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PurchaseInvoiceUbl
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PurchaseInvoiceUbl.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PurchaseInvoiceUbl is not found in the empty JSON string", PurchaseInvoiceUbl.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PurchaseInvoiceUbl.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PurchaseInvoiceUbl` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("external_key") != null && !jsonObj.get("external_key").isJsonNull()) && !jsonObj.get("external_key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `external_key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("external_key").toString()));
      }
      if ((jsonObj.get("external_user_id") != null && !jsonObj.get("external_user_id").isJsonNull()) && !jsonObj.get("external_user_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `external_user_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("external_user_id").toString()));
      }
      if ((jsonObj.get("guid") != null && !jsonObj.get("guid").isJsonNull()) && !jsonObj.get("guid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `guid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("guid").toString()));
      }
      if ((jsonObj.get("tax_system") != null && !jsonObj.get("tax_system").isJsonNull()) && !jsonObj.get("tax_system").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tax_system` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tax_system").toString()));
      }
      if ((jsonObj.get("ubl") != null && !jsonObj.get("ubl").isJsonNull()) && !jsonObj.get("ubl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ubl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ubl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PurchaseInvoiceUbl.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PurchaseInvoiceUbl' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PurchaseInvoiceUbl> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PurchaseInvoiceUbl.class));

       return (TypeAdapter<T>) new TypeAdapter<PurchaseInvoiceUbl>() {
           @Override
           public void write(JsonWriter out, PurchaseInvoiceUbl value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PurchaseInvoiceUbl read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PurchaseInvoiceUbl given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PurchaseInvoiceUbl
   * @throws IOException if the JSON string is invalid with respect to PurchaseInvoiceUbl
   */
  public static PurchaseInvoiceUbl fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PurchaseInvoiceUbl.class);
  }

  /**
   * Convert an instance of PurchaseInvoiceUbl to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

