/*
 * Storecove API
 * Storecove API
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: apisupport@storecove.nl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AllowanceCharge;
import org.openapitools.client.model.Attachment;
import org.openapitools.client.model.CurrencyCode;
import org.openapitools.client.model.Delivery;
import org.openapitools.client.model.DeliveryTerms;
import org.openapitools.client.model.OrderLine;
import org.openapitools.client.model.PaymentTerms;
import org.openapitools.client.model.Reference;
import org.openapitools.client.model.SellerSupplierParty;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The order to send.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:44.175207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DocumentOrder {
  public static final String SERIALIZED_NAME_ACCOUNTING_COST = "accountingCost";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_COST)
  private String accountingCost;

  public static final String SERIALIZED_NAME_ALLOWANCE_CHARGES = "allowanceCharges";
  @SerializedName(SERIALIZED_NAME_ALLOWANCE_CHARGES)
  private List<AllowanceCharge> allowanceCharges = new ArrayList<>();

  public static final String SERIALIZED_NAME_AMOUNT_INCLUDING_TAX = "amountIncludingTax";
  @SerializedName(SERIALIZED_NAME_AMOUNT_INCLUDING_TAX)
  private BigDecimal amountIncludingTax;

  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  private List<Attachment> attachments = new ArrayList<>();

  public static final String SERIALIZED_NAME_DELIVERY = "delivery";
  @SerializedName(SERIALIZED_NAME_DELIVERY)
  private Delivery delivery;

  public static final String SERIALIZED_NAME_DELIVERY_TERMS = "deliveryTerms";
  @SerializedName(SERIALIZED_NAME_DELIVERY_TERMS)
  private DeliveryTerms deliveryTerms;

  public static final String SERIALIZED_NAME_DOCUMENT_CURRENCY_CODE = "documentCurrencyCode";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_CURRENCY_CODE)
  private CurrencyCode documentCurrencyCode;

  public static final String SERIALIZED_NAME_DOCUMENT_NUMBER = "documentNumber";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_NUMBER)
  private String documentNumber;

  public static final String SERIALIZED_NAME_ISSUE_DATE = "issueDate";
  @SerializedName(SERIALIZED_NAME_ISSUE_DATE)
  private String issueDate;

  public static final String SERIALIZED_NAME_ISSUE_TIME = "issueTime";
  @SerializedName(SERIALIZED_NAME_ISSUE_TIME)
  private String issueTime;

  public static final String SERIALIZED_NAME_NOTE = "note";
  @SerializedName(SERIALIZED_NAME_NOTE)
  private String note;

  public static final String SERIALIZED_NAME_ORDER_LINES = "orderLines";
  @SerializedName(SERIALIZED_NAME_ORDER_LINES)
  private List<OrderLine> orderLines = new ArrayList<>();

  /**
   * The type of this order.
   */
  @JsonAdapter(OrderTypeEnum.Adapter.class)
  public enum OrderTypeEnum {
    REGULAR("regular"),
    
    CONSIGNMENT("consignment");

    private String value;

    OrderTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OrderTypeEnum fromValue(String value) {
      for (OrderTypeEnum b : OrderTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OrderTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OrderTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OrderTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OrderTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OrderTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ORDER_TYPE = "orderType";
  @SerializedName(SERIALIZED_NAME_ORDER_TYPE)
  private OrderTypeEnum orderType = OrderTypeEnum.REGULAR;

  public static final String SERIALIZED_NAME_PAYMENT_TERMS = "paymentTerms";
  @SerializedName(SERIALIZED_NAME_PAYMENT_TERMS)
  private PaymentTerms paymentTerms;

  public static final String SERIALIZED_NAME_REFERENCES = "references";
  @SerializedName(SERIALIZED_NAME_REFERENCES)
  private List<Reference> references = new ArrayList<>();

  public static final String SERIALIZED_NAME_SELLER_SUPPLIER_PARTY = "sellerSupplierParty";
  @SerializedName(SERIALIZED_NAME_SELLER_SUPPLIER_PARTY)
  private SellerSupplierParty sellerSupplierParty;

  /**
   * The tax system used for the invoice. The system &#39;tax_line_percentages&#39; is the only one currently supported.
   */
  @JsonAdapter(TaxSystemEnum.Adapter.class)
  public enum TaxSystemEnum {
    TAX_LINE_PERCENTAGES("tax_line_percentages");

    private String value;

    TaxSystemEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TaxSystemEnum fromValue(String value) {
      for (TaxSystemEnum b : TaxSystemEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TaxSystemEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TaxSystemEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TaxSystemEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TaxSystemEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TaxSystemEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TAX_SYSTEM = "taxSystem";
  @SerializedName(SERIALIZED_NAME_TAX_SYSTEM)
  private TaxSystemEnum taxSystem = TaxSystemEnum.TAX_LINE_PERCENTAGES;

  public static final String SERIALIZED_NAME_TIME_ZONE = "timeZone";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE)
  private String timeZone;

  public static final String SERIALIZED_NAME_VALIDITY_PERIOD = "validityPeriod";
  @SerializedName(SERIALIZED_NAME_VALIDITY_PERIOD)
  private String validityPeriod;

  public DocumentOrder() {
  }

  public DocumentOrder accountingCost(String accountingCost) {
    this.accountingCost = accountingCost;
    return this;
  }

  /**
   * The buyer&#39;s accounting cost centre for this document.
   * @return accountingCost
   */
  @javax.annotation.Nullable
  public String getAccountingCost() {
    return accountingCost;
  }

  public void setAccountingCost(String accountingCost) {
    this.accountingCost = accountingCost;
  }


  public DocumentOrder allowanceCharges(List<AllowanceCharge> allowanceCharges) {
    this.allowanceCharges = allowanceCharges;
    return this;
  }

  public DocumentOrder addAllowanceChargesItem(AllowanceCharge allowanceChargesItem) {
    if (this.allowanceCharges == null) {
      this.allowanceCharges = new ArrayList<>();
    }
    this.allowanceCharges.add(allowanceChargesItem);
    return this;
  }

  /**
   * An array of allowance charges.
   * @return allowanceCharges
   */
  @javax.annotation.Nullable
  public List<AllowanceCharge> getAllowanceCharges() {
    return allowanceCharges;
  }

  public void setAllowanceCharges(List<AllowanceCharge> allowanceCharges) {
    this.allowanceCharges = allowanceCharges;
  }


  public DocumentOrder amountIncludingTax(BigDecimal amountIncludingTax) {
    this.amountIncludingTax = amountIncludingTax;
    return this;
  }

  /**
   * Total amount including Tax.
   * @return amountIncludingTax
   */
  @javax.annotation.Nonnull
  public BigDecimal getAmountIncludingTax() {
    return amountIncludingTax;
  }

  public void setAmountIncludingTax(BigDecimal amountIncludingTax) {
    this.amountIncludingTax = amountIncludingTax;
  }


  public DocumentOrder attachments(List<Attachment> attachments) {
    this.attachments = attachments;
    return this;
  }

  public DocumentOrder addAttachmentsItem(Attachment attachmentsItem) {
    if (this.attachments == null) {
      this.attachments = new ArrayList<>();
    }
    this.attachments.add(attachmentsItem);
    return this;
  }

  /**
   * An array of attachments. You may provide up to 10 attchments, but the total size must not exceed 10MB after Base64 encoding.
   * @return attachments
   */
  @javax.annotation.Nullable
  public List<Attachment> getAttachments() {
    return attachments;
  }

  public void setAttachments(List<Attachment> attachments) {
    this.attachments = attachments;
  }


  public DocumentOrder delivery(Delivery delivery) {
    this.delivery = delivery;
    return this;
  }

  /**
   * Get delivery
   * @return delivery
   */
  @javax.annotation.Nullable
  public Delivery getDelivery() {
    return delivery;
  }

  public void setDelivery(Delivery delivery) {
    this.delivery = delivery;
  }


  public DocumentOrder deliveryTerms(DeliveryTerms deliveryTerms) {
    this.deliveryTerms = deliveryTerms;
    return this;
  }

  /**
   * Get deliveryTerms
   * @return deliveryTerms
   */
  @javax.annotation.Nullable
  public DeliveryTerms getDeliveryTerms() {
    return deliveryTerms;
  }

  public void setDeliveryTerms(DeliveryTerms deliveryTerms) {
    this.deliveryTerms = deliveryTerms;
  }


  public DocumentOrder documentCurrencyCode(CurrencyCode documentCurrencyCode) {
    this.documentCurrencyCode = documentCurrencyCode;
    return this;
  }

  /**
   * Get documentCurrencyCode
   * @return documentCurrencyCode
   */
  @javax.annotation.Nullable
  public CurrencyCode getDocumentCurrencyCode() {
    return documentCurrencyCode;
  }

  public void setDocumentCurrencyCode(CurrencyCode documentCurrencyCode) {
    this.documentCurrencyCode = documentCurrencyCode;
  }


  public DocumentOrder documentNumber(String documentNumber) {
    this.documentNumber = documentNumber;
    return this;
  }

  /**
   * The number you assigned to the document.
   * @return documentNumber
   */
  @javax.annotation.Nonnull
  public String getDocumentNumber() {
    return documentNumber;
  }

  public void setDocumentNumber(String documentNumber) {
    this.documentNumber = documentNumber;
  }


  public DocumentOrder issueDate(String issueDate) {
    this.issueDate = issueDate;
    return this;
  }

  /**
   * Format: yyyy-mm-dd.
   * @return issueDate
   */
  @javax.annotation.Nonnull
  public String getIssueDate() {
    return issueDate;
  }

  public void setIssueDate(String issueDate) {
    this.issueDate = issueDate;
  }


  public DocumentOrder issueTime(String issueTime) {
    this.issueTime = issueTime;
    return this;
  }

  /**
   * Format: hh:mm:ss±zzzz 
   * @return issueTime
   */
  @javax.annotation.Nullable
  public String getIssueTime() {
    return issueTime;
  }

  public void setIssueTime(String issueTime) {
    this.issueTime = issueTime;
  }


  public DocumentOrder note(String note) {
    this.note = note;
    return this;
  }

  /**
   * A note to add to the document
   * @return note
   */
  @javax.annotation.Nullable
  public String getNote() {
    return note;
  }

  public void setNote(String note) {
    this.note = note;
  }


  public DocumentOrder orderLines(List<OrderLine> orderLines) {
    this.orderLines = orderLines;
    return this;
  }

  public DocumentOrder addOrderLinesItem(OrderLine orderLinesItem) {
    if (this.orderLines == null) {
      this.orderLines = new ArrayList<>();
    }
    this.orderLines.add(orderLinesItem);
    return this;
  }

  /**
   * An array of order lines.
   * @return orderLines
   */
  @javax.annotation.Nonnull
  public List<OrderLine> getOrderLines() {
    return orderLines;
  }

  public void setOrderLines(List<OrderLine> orderLines) {
    this.orderLines = orderLines;
  }


  public DocumentOrder orderType(OrderTypeEnum orderType) {
    this.orderType = orderType;
    return this;
  }

  /**
   * The type of this order.
   * @return orderType
   */
  @javax.annotation.Nullable
  public OrderTypeEnum getOrderType() {
    return orderType;
  }

  public void setOrderType(OrderTypeEnum orderType) {
    this.orderType = orderType;
  }


  public DocumentOrder paymentTerms(PaymentTerms paymentTerms) {
    this.paymentTerms = paymentTerms;
    return this;
  }

  /**
   * Get paymentTerms
   * @return paymentTerms
   */
  @javax.annotation.Nullable
  public PaymentTerms getPaymentTerms() {
    return paymentTerms;
  }

  public void setPaymentTerms(PaymentTerms paymentTerms) {
    this.paymentTerms = paymentTerms;
  }


  public DocumentOrder references(List<Reference> references) {
    this.references = references;
    return this;
  }

  public DocumentOrder addReferencesItem(Reference referencesItem) {
    if (this.references == null) {
      this.references = new ArrayList<>();
    }
    this.references.add(referencesItem);
    return this;
  }

  /**
   * An array of references to other documents. Note that many syntaxes do not support multiple references of the same type in which case they will be concatenated with &#39;,&#39;. Also, not all syntaxes and doucments support all documentTypes.
   * @return references
   */
  @javax.annotation.Nullable
  public List<Reference> getReferences() {
    return references;
  }

  public void setReferences(List<Reference> references) {
    this.references = references;
  }


  public DocumentOrder sellerSupplierParty(SellerSupplierParty sellerSupplierParty) {
    this.sellerSupplierParty = sellerSupplierParty;
    return this;
  }

  /**
   * Get sellerSupplierParty
   * @return sellerSupplierParty
   */
  @javax.annotation.Nonnull
  public SellerSupplierParty getSellerSupplierParty() {
    return sellerSupplierParty;
  }

  public void setSellerSupplierParty(SellerSupplierParty sellerSupplierParty) {
    this.sellerSupplierParty = sellerSupplierParty;
  }


  public DocumentOrder taxSystem(TaxSystemEnum taxSystem) {
    this.taxSystem = taxSystem;
    return this;
  }

  /**
   * The tax system used for the invoice. The system &#39;tax_line_percentages&#39; is the only one currently supported.
   * @return taxSystem
   */
  @javax.annotation.Nullable
  public TaxSystemEnum getTaxSystem() {
    return taxSystem;
  }

  public void setTaxSystem(TaxSystemEnum taxSystem) {
    this.taxSystem = taxSystem;
  }


  public DocumentOrder timeZone(String timeZone) {
    this.timeZone = timeZone;
    return this;
  }

  /**
   * Format: ±zzzz, where ±zzzz is the difference from UTC, e.g. +0100 or -0900 etc. The timezone will also apply to the document issue date if this field is provided.
   * @return timeZone
   */
  @javax.annotation.Nullable
  public String getTimeZone() {
    return timeZone;
  }

  public void setTimeZone(String timeZone) {
    this.timeZone = timeZone;
  }


  public DocumentOrder validityPeriod(String validityPeriod) {
    this.validityPeriod = validityPeriod;
    return this;
  }

  /**
   * The period (or specific date) to which the invoice applies. Format: yyyy-mm-dd - yyyy-mm-dd.
   * @return validityPeriod
   */
  @javax.annotation.Nullable
  public String getValidityPeriod() {
    return validityPeriod;
  }

  public void setValidityPeriod(String validityPeriod) {
    this.validityPeriod = validityPeriod;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentOrder documentOrder = (DocumentOrder) o;
    return Objects.equals(this.accountingCost, documentOrder.accountingCost) &&
        Objects.equals(this.allowanceCharges, documentOrder.allowanceCharges) &&
        Objects.equals(this.amountIncludingTax, documentOrder.amountIncludingTax) &&
        Objects.equals(this.attachments, documentOrder.attachments) &&
        Objects.equals(this.delivery, documentOrder.delivery) &&
        Objects.equals(this.deliveryTerms, documentOrder.deliveryTerms) &&
        Objects.equals(this.documentCurrencyCode, documentOrder.documentCurrencyCode) &&
        Objects.equals(this.documentNumber, documentOrder.documentNumber) &&
        Objects.equals(this.issueDate, documentOrder.issueDate) &&
        Objects.equals(this.issueTime, documentOrder.issueTime) &&
        Objects.equals(this.note, documentOrder.note) &&
        Objects.equals(this.orderLines, documentOrder.orderLines) &&
        Objects.equals(this.orderType, documentOrder.orderType) &&
        Objects.equals(this.paymentTerms, documentOrder.paymentTerms) &&
        Objects.equals(this.references, documentOrder.references) &&
        Objects.equals(this.sellerSupplierParty, documentOrder.sellerSupplierParty) &&
        Objects.equals(this.taxSystem, documentOrder.taxSystem) &&
        Objects.equals(this.timeZone, documentOrder.timeZone) &&
        Objects.equals(this.validityPeriod, documentOrder.validityPeriod);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountingCost, allowanceCharges, amountIncludingTax, attachments, delivery, deliveryTerms, documentCurrencyCode, documentNumber, issueDate, issueTime, note, orderLines, orderType, paymentTerms, references, sellerSupplierParty, taxSystem, timeZone, validityPeriod);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentOrder {\n");
    sb.append("    accountingCost: ").append(toIndentedString(accountingCost)).append("\n");
    sb.append("    allowanceCharges: ").append(toIndentedString(allowanceCharges)).append("\n");
    sb.append("    amountIncludingTax: ").append(toIndentedString(amountIncludingTax)).append("\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    delivery: ").append(toIndentedString(delivery)).append("\n");
    sb.append("    deliveryTerms: ").append(toIndentedString(deliveryTerms)).append("\n");
    sb.append("    documentCurrencyCode: ").append(toIndentedString(documentCurrencyCode)).append("\n");
    sb.append("    documentNumber: ").append(toIndentedString(documentNumber)).append("\n");
    sb.append("    issueDate: ").append(toIndentedString(issueDate)).append("\n");
    sb.append("    issueTime: ").append(toIndentedString(issueTime)).append("\n");
    sb.append("    note: ").append(toIndentedString(note)).append("\n");
    sb.append("    orderLines: ").append(toIndentedString(orderLines)).append("\n");
    sb.append("    orderType: ").append(toIndentedString(orderType)).append("\n");
    sb.append("    paymentTerms: ").append(toIndentedString(paymentTerms)).append("\n");
    sb.append("    references: ").append(toIndentedString(references)).append("\n");
    sb.append("    sellerSupplierParty: ").append(toIndentedString(sellerSupplierParty)).append("\n");
    sb.append("    taxSystem: ").append(toIndentedString(taxSystem)).append("\n");
    sb.append("    timeZone: ").append(toIndentedString(timeZone)).append("\n");
    sb.append("    validityPeriod: ").append(toIndentedString(validityPeriod)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountingCost");
    openapiFields.add("allowanceCharges");
    openapiFields.add("amountIncludingTax");
    openapiFields.add("attachments");
    openapiFields.add("delivery");
    openapiFields.add("deliveryTerms");
    openapiFields.add("documentCurrencyCode");
    openapiFields.add("documentNumber");
    openapiFields.add("issueDate");
    openapiFields.add("issueTime");
    openapiFields.add("note");
    openapiFields.add("orderLines");
    openapiFields.add("orderType");
    openapiFields.add("paymentTerms");
    openapiFields.add("references");
    openapiFields.add("sellerSupplierParty");
    openapiFields.add("taxSystem");
    openapiFields.add("timeZone");
    openapiFields.add("validityPeriod");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("amountIncludingTax");
    openapiRequiredFields.add("documentNumber");
    openapiRequiredFields.add("issueDate");
    openapiRequiredFields.add("orderLines");
    openapiRequiredFields.add("sellerSupplierParty");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DocumentOrder
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DocumentOrder.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DocumentOrder is not found in the empty JSON string", DocumentOrder.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DocumentOrder.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DocumentOrder` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DocumentOrder.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accountingCost") != null && !jsonObj.get("accountingCost").isJsonNull()) && !jsonObj.get("accountingCost").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountingCost` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountingCost").toString()));
      }
      if (jsonObj.get("allowanceCharges") != null && !jsonObj.get("allowanceCharges").isJsonNull()) {
        JsonArray jsonArrayallowanceCharges = jsonObj.getAsJsonArray("allowanceCharges");
        if (jsonArrayallowanceCharges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("allowanceCharges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `allowanceCharges` to be an array in the JSON string but got `%s`", jsonObj.get("allowanceCharges").toString()));
          }

          // validate the optional field `allowanceCharges` (array)
          for (int i = 0; i < jsonArrayallowanceCharges.size(); i++) {
            AllowanceCharge.validateJsonElement(jsonArrayallowanceCharges.get(i));
          };
        }
      }
      if (jsonObj.get("attachments") != null && !jsonObj.get("attachments").isJsonNull()) {
        JsonArray jsonArrayattachments = jsonObj.getAsJsonArray("attachments");
        if (jsonArrayattachments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("attachments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `attachments` to be an array in the JSON string but got `%s`", jsonObj.get("attachments").toString()));
          }

          // validate the optional field `attachments` (array)
          for (int i = 0; i < jsonArrayattachments.size(); i++) {
            Attachment.validateJsonElement(jsonArrayattachments.get(i));
          };
        }
      }
      // validate the optional field `delivery`
      if (jsonObj.get("delivery") != null && !jsonObj.get("delivery").isJsonNull()) {
        Delivery.validateJsonElement(jsonObj.get("delivery"));
      }
      // validate the optional field `deliveryTerms`
      if (jsonObj.get("deliveryTerms") != null && !jsonObj.get("deliveryTerms").isJsonNull()) {
        DeliveryTerms.validateJsonElement(jsonObj.get("deliveryTerms"));
      }
      // validate the optional field `documentCurrencyCode`
      if (jsonObj.get("documentCurrencyCode") != null && !jsonObj.get("documentCurrencyCode").isJsonNull()) {
        CurrencyCode.validateJsonElement(jsonObj.get("documentCurrencyCode"));
      }
      if (!jsonObj.get("documentNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentNumber").toString()));
      }
      if (!jsonObj.get("issueDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("issueDate").toString()));
      }
      if ((jsonObj.get("issueTime") != null && !jsonObj.get("issueTime").isJsonNull()) && !jsonObj.get("issueTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("issueTime").toString()));
      }
      if ((jsonObj.get("note") != null && !jsonObj.get("note").isJsonNull()) && !jsonObj.get("note").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `note` to be a primitive type in the JSON string but got `%s`", jsonObj.get("note").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("orderLines").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderLines` to be an array in the JSON string but got `%s`", jsonObj.get("orderLines").toString()));
      }

      JsonArray jsonArrayorderLines = jsonObj.getAsJsonArray("orderLines");
      // validate the required field `orderLines` (array)
      for (int i = 0; i < jsonArrayorderLines.size(); i++) {
        OrderLine.validateJsonElement(jsonArrayorderLines.get(i));
      };
      if ((jsonObj.get("orderType") != null && !jsonObj.get("orderType").isJsonNull()) && !jsonObj.get("orderType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderType").toString()));
      }
      // validate the optional field `orderType`
      if (jsonObj.get("orderType") != null && !jsonObj.get("orderType").isJsonNull()) {
        OrderTypeEnum.validateJsonElement(jsonObj.get("orderType"));
      }
      // validate the optional field `paymentTerms`
      if (jsonObj.get("paymentTerms") != null && !jsonObj.get("paymentTerms").isJsonNull()) {
        PaymentTerms.validateJsonElement(jsonObj.get("paymentTerms"));
      }
      if (jsonObj.get("references") != null && !jsonObj.get("references").isJsonNull()) {
        JsonArray jsonArrayreferences = jsonObj.getAsJsonArray("references");
        if (jsonArrayreferences != null) {
          // ensure the json data is an array
          if (!jsonObj.get("references").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `references` to be an array in the JSON string but got `%s`", jsonObj.get("references").toString()));
          }

          // validate the optional field `references` (array)
          for (int i = 0; i < jsonArrayreferences.size(); i++) {
            Reference.validateJsonElement(jsonArrayreferences.get(i));
          };
        }
      }
      // validate the required field `sellerSupplierParty`
      SellerSupplierParty.validateJsonElement(jsonObj.get("sellerSupplierParty"));
      if ((jsonObj.get("taxSystem") != null && !jsonObj.get("taxSystem").isJsonNull()) && !jsonObj.get("taxSystem").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taxSystem` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taxSystem").toString()));
      }
      // validate the optional field `taxSystem`
      if (jsonObj.get("taxSystem") != null && !jsonObj.get("taxSystem").isJsonNull()) {
        TaxSystemEnum.validateJsonElement(jsonObj.get("taxSystem"));
      }
      if ((jsonObj.get("timeZone") != null && !jsonObj.get("timeZone").isJsonNull()) && !jsonObj.get("timeZone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeZone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeZone").toString()));
      }
      if ((jsonObj.get("validityPeriod") != null && !jsonObj.get("validityPeriod").isJsonNull()) && !jsonObj.get("validityPeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `validityPeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("validityPeriod").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DocumentOrder.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DocumentOrder' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DocumentOrder> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DocumentOrder.class));

       return (TypeAdapter<T>) new TypeAdapter<DocumentOrder>() {
           @Override
           public void write(JsonWriter out, DocumentOrder value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DocumentOrder read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DocumentOrder given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DocumentOrder
   * @throws IOException if the JSON string is invalid with respect to DocumentOrder
   */
  public static DocumentOrder fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DocumentOrder.class);
  }

  /**
   * Convert an instance of DocumentOrder to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

