/*
 * Storecove API
 * Storecove API
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: apisupport@storecove.nl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AccountingCustomerParty;
import org.openapitools.client.model.AccountingSupplierParty;
import org.openapitools.client.model.AllowanceCharge;
import org.openapitools.client.model.Attachment;
import org.openapitools.client.model.CurrencyCode;
import org.openapitools.client.model.Delivery;
import org.openapitools.client.model.InvoiceLine;
import org.openapitools.client.model.PaymentMeans;
import org.openapitools.client.model.PaymentTerms;
import org.openapitools.client.model.Reference;
import org.openapitools.client.model.Tax;
import org.openapitools.client.model.TaxSubtotal;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The invoice to send. Provide either invoice, or invoiceData, but not both.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:44.175207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Invoice {
  public static final String SERIALIZED_NAME_ACCOUNTING_COST = "accountingCost";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_COST)
  private String accountingCost;

  public static final String SERIALIZED_NAME_ACCOUNTING_CURRENCY_TAX_AMOUNT = "accountingCurrencyTaxAmount";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_CURRENCY_TAX_AMOUNT)
  private BigDecimal accountingCurrencyTaxAmount;

  public static final String SERIALIZED_NAME_ACCOUNTING_CURRENCY_TAX_AMOUNT_CURRENCY = "accountingCurrencyTaxAmountCurrency";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_CURRENCY_TAX_AMOUNT_CURRENCY)
  private CurrencyCode accountingCurrencyTaxAmountCurrency;

  public static final String SERIALIZED_NAME_ACCOUNTING_CUSTOMER_PARTY = "accountingCustomerParty";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_CUSTOMER_PARTY)
  private AccountingCustomerParty accountingCustomerParty;

  public static final String SERIALIZED_NAME_ACCOUNTING_SUPPLIER_PARTY = "accountingSupplierParty";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_SUPPLIER_PARTY)
  private AccountingSupplierParty accountingSupplierParty;

  public static final String SERIALIZED_NAME_ALLOWANCE_CHARGES = "allowanceCharges";
  @SerializedName(SERIALIZED_NAME_ALLOWANCE_CHARGES)
  private List<AllowanceCharge> allowanceCharges = new ArrayList<>();

  public static final String SERIALIZED_NAME_AMOUNT_INCLUDING_VAT = "amountIncludingVat";
  @SerializedName(SERIALIZED_NAME_AMOUNT_INCLUDING_VAT)
  private BigDecimal amountIncludingVat;

  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  private List<Attachment> attachments = new ArrayList<>();

  public static final String SERIALIZED_NAME_BILLING_REFERENCE = "billingReference";
  @SerializedName(SERIALIZED_NAME_BILLING_REFERENCE)
  private String billingReference;

  public static final String SERIALIZED_NAME_BUYER_REFERENCE = "buyerReference";
  @SerializedName(SERIALIZED_NAME_BUYER_REFERENCE)
  private String buyerReference;

  public static final String SERIALIZED_NAME_CONSUMER_TAX_MODE = "consumerTaxMode";
  @SerializedName(SERIALIZED_NAME_CONSUMER_TAX_MODE)
  private Boolean consumerTaxMode = false;

  public static final String SERIALIZED_NAME_CONTRACT_DOCUMENT_REFERENCE = "contractDocumentReference";
  @SerializedName(SERIALIZED_NAME_CONTRACT_DOCUMENT_REFERENCE)
  private String contractDocumentReference;

  public static final String SERIALIZED_NAME_DELIVERY = "delivery";
  @SerializedName(SERIALIZED_NAME_DELIVERY)
  private Delivery delivery;

  public static final String SERIALIZED_NAME_DOCUMENT_CURRENCY_CODE = "documentCurrencyCode";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_CURRENCY_CODE)
  private CurrencyCode documentCurrencyCode;

  public static final String SERIALIZED_NAME_DUE_DATE = "dueDate";
  @SerializedName(SERIALIZED_NAME_DUE_DATE)
  private String dueDate;

  public static final String SERIALIZED_NAME_INVOICE_LINES = "invoiceLines";
  @SerializedName(SERIALIZED_NAME_INVOICE_LINES)
  private List<InvoiceLine> invoiceLines = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVOICE_NUMBER = "invoiceNumber";
  @SerializedName(SERIALIZED_NAME_INVOICE_NUMBER)
  private String invoiceNumber;

  public static final String SERIALIZED_NAME_INVOICE_PERIOD = "invoicePeriod";
  @SerializedName(SERIALIZED_NAME_INVOICE_PERIOD)
  private String invoicePeriod;

  /**
   * DEPRECATED. Do not use. This field is available for legacy reasons only. If you want to send a regular invoice (aka UBL type &#39;380&#39;), make sure you have a positive invoice amount. For a credit note (aka UBL type &#39;381&#39;), simply provide a negative invoice amount. If you, in addition to a negative invoice amount, also specify a billingReferences, your invoice will become a corrective invoice (aka UBL type &#39;384&#39;). If your invoice is not sent in the UBL syntax, Storecove will provide the appropriate type for the syntax the invoice is sent in.
   */
  @JsonAdapter(InvoiceTypeEnum.Adapter.class)
  public enum InvoiceTypeEnum {
    _380("380"),
    
    _381("381"),
    
    _384("384");

    private String value;

    InvoiceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InvoiceTypeEnum fromValue(String value) {
      for (InvoiceTypeEnum b : InvoiceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InvoiceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InvoiceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InvoiceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InvoiceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InvoiceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INVOICE_TYPE = "invoiceType";
  @SerializedName(SERIALIZED_NAME_INVOICE_TYPE)
  private InvoiceTypeEnum invoiceType = InvoiceTypeEnum._380;

  public static final String SERIALIZED_NAME_ISSUE_DATE = "issueDate";
  @SerializedName(SERIALIZED_NAME_ISSUE_DATE)
  private String issueDate;

  public static final String SERIALIZED_NAME_ISSUE_REASONS = "issueReasons";
  @SerializedName(SERIALIZED_NAME_ISSUE_REASONS)
  private List<String> issueReasons = new ArrayList<>();

  public static final String SERIALIZED_NAME_NOTE = "note";
  @SerializedName(SERIALIZED_NAME_NOTE)
  private String note;

  public static final String SERIALIZED_NAME_ORDER_REFERENCE = "orderReference";
  @SerializedName(SERIALIZED_NAME_ORDER_REFERENCE)
  private String orderReference;

  public static final String SERIALIZED_NAME_PAYMENT_MEANS_ARRAY = "paymentMeansArray";
  @SerializedName(SERIALIZED_NAME_PAYMENT_MEANS_ARRAY)
  private List<PaymentMeans> paymentMeansArray = new ArrayList<>();

  public static final String SERIALIZED_NAME_PAYMENT_MEANS_BIC = "paymentMeansBic";
  @SerializedName(SERIALIZED_NAME_PAYMENT_MEANS_BIC)
  private String paymentMeansBic;

  /**
   * DEPRECATED. Use paymentMeansArray. How the invoice has been / will be paid. Use only online_payment_service (payment will be made or has been made by an online payment service), bank_card (e.g. debit card, credit card), direct_debit (the amount has been / will be taken out of the client&#39;s bank account), standing_agreement (an unspecified payment means known to both buyer and seller) or credit_transfer (the buyer will do / has done a bank transfer). The numeric codes are for legacy purposes, they should not be used.
   */
  @JsonAdapter(PaymentMeansCodeEnum.Adapter.class)
  public enum PaymentMeansCodeEnum {
    ONLINE_PAYMENT_SERVICE("online_payment_service"),
    
    BANK_CARD("bank_card"),
    
    DIRECT_DEBIT("direct_debit"),
    
    STANDING_AGREEMENT("standing_agreement"),
    
    CREDIT_TRANSFER("credit_transfer"),
    
    SE_BANKGIRO("se_bankgiro"),
    
    SE_PLUSGIRO("se_plusgiro"),
    
    AUNZ_NPP("aunz_npp"),
    
    EMPTY(""),
    
    _1("1"),
    
    _30("30"),
    
    _31("31"),
    
    _42("42"),
    
    _48("48"),
    
    _49("49"),
    
    _57("57"),
    
    _58("58");

    private String value;

    PaymentMeansCodeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PaymentMeansCodeEnum fromValue(String value) {
      for (PaymentMeansCodeEnum b : PaymentMeansCodeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PaymentMeansCodeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PaymentMeansCodeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PaymentMeansCodeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PaymentMeansCodeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PaymentMeansCodeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PAYMENT_MEANS_CODE = "paymentMeansCode";
  @SerializedName(SERIALIZED_NAME_PAYMENT_MEANS_CODE)
  private PaymentMeansCodeEnum paymentMeansCode;

  public static final String SERIALIZED_NAME_PAYMENT_MEANS_IBAN = "paymentMeansIban";
  @SerializedName(SERIALIZED_NAME_PAYMENT_MEANS_IBAN)
  private String paymentMeansIban;

  public static final String SERIALIZED_NAME_PAYMENT_MEANS_PAYMENT_ID = "paymentMeansPaymentId";
  @SerializedName(SERIALIZED_NAME_PAYMENT_MEANS_PAYMENT_ID)
  private String paymentMeansPaymentId;

  public static final String SERIALIZED_NAME_PAYMENT_TERMS = "paymentTerms";
  @SerializedName(SERIALIZED_NAME_PAYMENT_TERMS)
  private PaymentTerms paymentTerms;

  /**
   * In auto mode, the choice between invoice or creditnote is made by Storecove based on what is appropriate for the receiver and the receiver country, in combination with the invoice amount sign. If you wish to state a preference, use this field. It is not guaranteed that the preference will be used, since it depends also on the receiver&#39;s document capabilities.
   */
  @JsonAdapter(PreferredInvoiceTypeEnum.Adapter.class)
  public enum PreferredInvoiceTypeEnum {
    AUTODETECT("prefer_autodetect"),
    
    INVOICE("prefer_invoice"),
    
    CREDITNOTE("prefer_creditnote");

    private String value;

    PreferredInvoiceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PreferredInvoiceTypeEnum fromValue(String value) {
      for (PreferredInvoiceTypeEnum b : PreferredInvoiceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PreferredInvoiceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PreferredInvoiceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PreferredInvoiceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PreferredInvoiceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PreferredInvoiceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PREFERRED_INVOICE_TYPE = "preferredInvoiceType";
  @SerializedName(SERIALIZED_NAME_PREFERRED_INVOICE_TYPE)
  private PreferredInvoiceTypeEnum preferredInvoiceType = PreferredInvoiceTypeEnum.AUTODETECT;

  public static final String SERIALIZED_NAME_PREPAID_AMOUNT = "prepaidAmount";
  @SerializedName(SERIALIZED_NAME_PREPAID_AMOUNT)
  private BigDecimal prepaidAmount;

  /**
   * The price mode. This is used to determine whether the prices are net or gross. Price Mode &#39;price_mode_gross&#39; can only be used for \&quot;x2y\&quot;: \&quot;b2c\&quot;, sender countries ES, IT and PT, \&quot;clearWithoutSending\&quot;: true and \&quot;taxSystem\&quot;: \&quot;tax_line_percentages\&quot;
   */
  @JsonAdapter(PriceModeEnum.Adapter.class)
  public enum PriceModeEnum {
    NET("price_mode_net"),
    
    GROSS("price_mode_gross");

    private String value;

    PriceModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PriceModeEnum fromValue(String value) {
      for (PriceModeEnum b : PriceModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PriceModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PriceModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PriceModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PriceModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PriceModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PRICE_MODE = "priceMode";
  @SerializedName(SERIALIZED_NAME_PRICE_MODE)
  private PriceModeEnum priceMode = PriceModeEnum.NET;

  public static final String SERIALIZED_NAME_PROJECT_REFERENCE = "projectReference";
  @SerializedName(SERIALIZED_NAME_PROJECT_REFERENCE)
  private String projectReference;

  public static final String SERIALIZED_NAME_REFERENCES = "references";
  @SerializedName(SERIALIZED_NAME_REFERENCES)
  private List<Reference> references = new ArrayList<>();

  public static final String SERIALIZED_NAME_SALES_ORDER_ID = "salesOrderId";
  @SerializedName(SERIALIZED_NAME_SALES_ORDER_ID)
  private String salesOrderId;

  public static final String SERIALIZED_NAME_SELF_BILLING_MODE = "selfBillingMode";
  @SerializedName(SERIALIZED_NAME_SELF_BILLING_MODE)
  private Boolean selfBillingMode = false;

  /**
   * DEPRECATED. Use Tax/category and specify this per invoice line. If you do specify this field, it will be applied to all invoice lines and it is an error to specify a Tax/category at the invoice line level. This field holds the reason no tax is present in the invoice. Note that this is an invoice level field and you cannot specify it per invoice line. This field is mandatory unless tax is present in the invoice.
   */
  @JsonAdapter(TaxExemptReasonEnum.Adapter.class)
  public enum TaxExemptReasonEnum {
    EXPORT("export"),
    
    REVERSE_CHARGE("reverse_charge"),
    
    ZERO_RATED("zero_rated"),
    
    EXEMPT("exempt"),
    
    OUTSIDE_SCOPE("outside_scope"),
    
    INTRA_COMMUNITY("intra_community");

    private String value;

    TaxExemptReasonEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TaxExemptReasonEnum fromValue(String value) {
      for (TaxExemptReasonEnum b : TaxExemptReasonEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TaxExemptReasonEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TaxExemptReasonEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TaxExemptReasonEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TaxExemptReasonEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TaxExemptReasonEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TAX_EXEMPT_REASON = "taxExemptReason";
  @SerializedName(SERIALIZED_NAME_TAX_EXEMPT_REASON)
  private TaxExemptReasonEnum taxExemptReason;

  public static final String SERIALIZED_NAME_TAX_POINT_DATE = "taxPointDate";
  @SerializedName(SERIALIZED_NAME_TAX_POINT_DATE)
  private String taxPointDate;

  public static final String SERIALIZED_NAME_TAX_SUBTOTALS = "taxSubtotals";
  @SerializedName(SERIALIZED_NAME_TAX_SUBTOTALS)
  private List<TaxSubtotal> taxSubtotals = new ArrayList<>();

  /**
   * The tax system used for the invoice. The system &#39;tax_line_percentages&#39; is preferred, but for historic purposes &#39;tax_line_amounts&#39; is supported and the default. Since not all invoice formats that we are required to send support &#39;tax_line_amounts&#39; we will need to convert the invoice to the &#39;tax_line_percentags&#39; system if we are forced to send the invoice in that tax system. Note that an invoice must always contain tax information, even if that is 0% or an item or sender is exempt or tax is completely outside scope. In that case, use the correct tax categories (see &lt;&lt;_openapi_tax&gt;&gt;)
   */
  @JsonAdapter(TaxSystemEnum.Adapter.class)
  public enum TaxSystemEnum {
    AMOUNTS("tax_line_amounts"),
    
    PERCENTAGES("tax_line_percentages");

    private String value;

    TaxSystemEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TaxSystemEnum fromValue(String value) {
      for (TaxSystemEnum b : TaxSystemEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TaxSystemEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TaxSystemEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TaxSystemEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TaxSystemEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TaxSystemEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TAX_SYSTEM = "taxSystem";
  @SerializedName(SERIALIZED_NAME_TAX_SYSTEM)
  private TaxSystemEnum taxSystem = TaxSystemEnum.AMOUNTS;

  public static final String SERIALIZED_NAME_TAXES_DUTIES_FEES = "taxesDutiesFees";
  @SerializedName(SERIALIZED_NAME_TAXES_DUTIES_FEES)
  private List<Tax> taxesDutiesFees = new ArrayList<>();

  /**
   * The type of transaction. Currently used only for India.
   */
  @JsonAdapter(TransactionTypeEnum.Adapter.class)
  public enum TransactionTypeEnum {
    B2B("b2b"),
    
    SEZWP("sezwp"),
    
    SEZWOP("sezwop"),
    
    EXPWP("expwp"),
    
    EXPWOP("expwop"),
    
    DEXP("dexp");

    private String value;

    TransactionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TransactionTypeEnum fromValue(String value) {
      for (TransactionTypeEnum b : TransactionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TransactionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TransactionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TransactionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TransactionTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TransactionTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRANSACTION_TYPE = "transactionType";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_TYPE)
  private TransactionTypeEnum transactionType;

  public static final String SERIALIZED_NAME_UBL_EXTENSIONS = "ublExtensions";
  @SerializedName(SERIALIZED_NAME_UBL_EXTENSIONS)
  private List<String> ublExtensions = new ArrayList<>();

  public static final String SERIALIZED_NAME_VAT_REVERSE_CHARGE = "vatReverseCharge";
  @SerializedName(SERIALIZED_NAME_VAT_REVERSE_CHARGE)
  private Boolean vatReverseCharge = false;

  /**
   * The type of entities the document is sent from/to: b2b (business-to-business), b2g (business-to-government) or b2c (business-to-consumer). This field does not have a default, but it in mose cases it will be treated as b2b. Only when you explicitly specify b2g or b2c OR when it is clear from the context will a different value be used. For instance, when we see the document is being routed to DE:LWID or NL:OINO number, this tells us it is b2g. But in many cases we are unable to determine this and so it is best to always specify this field. Note that b2b_sez is for use inside India only.
   */
  @JsonAdapter(X2yEnum.Adapter.class)
  public enum X2yEnum {
    B2B("b2b"),
    
    B2G("b2g"),
    
    B2C("b2c"),
    
    B2B_SEZ("b2b_sez");

    private String value;

    X2yEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static X2yEnum fromValue(String value) {
      for (X2yEnum b : X2yEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<X2yEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final X2yEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public X2yEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return X2yEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      X2yEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_X2Y = "x2y";
  @SerializedName(SERIALIZED_NAME_X2Y)
  private X2yEnum x2y = X2yEnum.B2B;

  public Invoice() {
  }

  public Invoice accountingCost(String accountingCost) {
    this.accountingCost = accountingCost;
    return this;
  }

  /**
   * The buyer&#39;s accounting cost centre for this invoice, expressed as text.
   * @return accountingCost
   */
  @javax.annotation.Nullable
  public String getAccountingCost() {
    return accountingCost;
  }

  public void setAccountingCost(String accountingCost) {
    this.accountingCost = accountingCost;
  }


  public Invoice accountingCurrencyTaxAmount(BigDecimal accountingCurrencyTaxAmount) {
    this.accountingCurrencyTaxAmount = accountingCurrencyTaxAmount;
    return this;
  }

  /**
   * The total amount of tax in the accounting currency. If included, must be non-zero.
   * @return accountingCurrencyTaxAmount
   */
  @javax.annotation.Nullable
  public BigDecimal getAccountingCurrencyTaxAmount() {
    return accountingCurrencyTaxAmount;
  }

  public void setAccountingCurrencyTaxAmount(BigDecimal accountingCurrencyTaxAmount) {
    this.accountingCurrencyTaxAmount = accountingCurrencyTaxAmount;
  }


  public Invoice accountingCurrencyTaxAmountCurrency(CurrencyCode accountingCurrencyTaxAmountCurrency) {
    this.accountingCurrencyTaxAmountCurrency = accountingCurrencyTaxAmountCurrency;
    return this;
  }

  /**
   * Get accountingCurrencyTaxAmountCurrency
   * @return accountingCurrencyTaxAmountCurrency
   */
  @javax.annotation.Nullable
  public CurrencyCode getAccountingCurrencyTaxAmountCurrency() {
    return accountingCurrencyTaxAmountCurrency;
  }

  public void setAccountingCurrencyTaxAmountCurrency(CurrencyCode accountingCurrencyTaxAmountCurrency) {
    this.accountingCurrencyTaxAmountCurrency = accountingCurrencyTaxAmountCurrency;
  }


  public Invoice accountingCustomerParty(AccountingCustomerParty accountingCustomerParty) {
    this.accountingCustomerParty = accountingCustomerParty;
    return this;
  }

  /**
   * Get accountingCustomerParty
   * @return accountingCustomerParty
   */
  @javax.annotation.Nonnull
  public AccountingCustomerParty getAccountingCustomerParty() {
    return accountingCustomerParty;
  }

  public void setAccountingCustomerParty(AccountingCustomerParty accountingCustomerParty) {
    this.accountingCustomerParty = accountingCustomerParty;
  }


  public Invoice accountingSupplierParty(AccountingSupplierParty accountingSupplierParty) {
    this.accountingSupplierParty = accountingSupplierParty;
    return this;
  }

  /**
   * Get accountingSupplierParty
   * @return accountingSupplierParty
   */
  @javax.annotation.Nullable
  public AccountingSupplierParty getAccountingSupplierParty() {
    return accountingSupplierParty;
  }

  public void setAccountingSupplierParty(AccountingSupplierParty accountingSupplierParty) {
    this.accountingSupplierParty = accountingSupplierParty;
  }


  public Invoice allowanceCharges(List<AllowanceCharge> allowanceCharges) {
    this.allowanceCharges = allowanceCharges;
    return this;
  }

  public Invoice addAllowanceChargesItem(AllowanceCharge allowanceChargesItem) {
    if (this.allowanceCharges == null) {
      this.allowanceCharges = new ArrayList<>();
    }
    this.allowanceCharges.add(allowanceChargesItem);
    return this;
  }

  /**
   * An array of allowance charges.
   * @return allowanceCharges
   */
  @javax.annotation.Nullable
  public List<AllowanceCharge> getAllowanceCharges() {
    return allowanceCharges;
  }

  public void setAllowanceCharges(List<AllowanceCharge> allowanceCharges) {
    this.allowanceCharges = allowanceCharges;
  }


  public Invoice amountIncludingVat(BigDecimal amountIncludingVat) {
    this.amountIncludingVat = amountIncludingVat;
    return this;
  }

  /**
   * amountIncludingVat is important because of rounding differences. In many invoices, the sum of the line item amounts excluding VAT and the VAT amounts is not equal to first summing the line items without VAT, and then applying VAT. The difference is automatically calculated and included in the electronic invoice, so the receiving accounting package can process the electronic invoice without problems.
   * @return amountIncludingVat
   */
  @javax.annotation.Nonnull
  public BigDecimal getAmountIncludingVat() {
    return amountIncludingVat;
  }

  public void setAmountIncludingVat(BigDecimal amountIncludingVat) {
    this.amountIncludingVat = amountIncludingVat;
  }


  public Invoice attachments(List<Attachment> attachments) {
    this.attachments = attachments;
    return this;
  }

  public Invoice addAttachmentsItem(Attachment attachmentsItem) {
    if (this.attachments == null) {
      this.attachments = new ArrayList<>();
    }
    this.attachments.add(attachmentsItem);
    return this;
  }

  /**
   * An array of attachments. You may provide up to 10 attchments, but the total size must not exceed 10MB after Base64 encoding.
   * @return attachments
   */
  @javax.annotation.Nullable
  public List<Attachment> getAttachments() {
    return attachments;
  }

  public void setAttachments(List<Attachment> attachments) {
    this.attachments = attachments;
  }


  public Invoice billingReference(String billingReference) {
    this.billingReference = billingReference;
    return this;
  }

  /**
   * DEPRECATED. Use a reference object with a documentType &#39;billing&#39;. A reference to a commercial invoice or corrective invoice of which the current invoice is a correction. This field is mandatory when sending invoiceType 384.
   * @return billingReference
   */
  @javax.annotation.Nullable
  public String getBillingReference() {
    return billingReference;
  }

  public void setBillingReference(String billingReference) {
    this.billingReference = billingReference;
  }


  public Invoice buyerReference(String buyerReference) {
    this.buyerReference = buyerReference;
    return this;
  }

  /**
   * DEPRECATED. Use a reference object with a documentType &#39;buyer_reference&#39;. A reference provided by the buyer used for internal routing of the document.
   * @return buyerReference
   */
  @javax.annotation.Nullable
  public String getBuyerReference() {
    return buyerReference;
  }

  public void setBuyerReference(String buyerReference) {
    this.buyerReference = buyerReference;
  }


  public Invoice consumerTaxMode(Boolean consumerTaxMode) {
    this.consumerTaxMode = consumerTaxMode;
    return this;
  }

  /**
   * Whether or not to process the invoice in consumer tax mode. In this mode, the VAT identifier of the sender will not be the default VAT identifier, but the one that matches with the country of the receiving consumer, if that additional VAT identifier for that country is available. These additional VAT identifiers need to be added to the sending LegalEntity by Storecove, so if you need to send invoices in this mode, please contact us.
   * @return consumerTaxMode
   */
  @javax.annotation.Nullable
  public Boolean getConsumerTaxMode() {
    return consumerTaxMode;
  }

  public void setConsumerTaxMode(Boolean consumerTaxMode) {
    this.consumerTaxMode = consumerTaxMode;
  }


  public Invoice contractDocumentReference(String contractDocumentReference) {
    this.contractDocumentReference = contractDocumentReference;
    return this;
  }

  /**
   * DEPRECATED. Use a reference object with a documentType &#39;contract&#39;. A reference to a contract or framework agreement that this invoice relates to.
   * @return contractDocumentReference
   */
  @javax.annotation.Nullable
  public String getContractDocumentReference() {
    return contractDocumentReference;
  }

  public void setContractDocumentReference(String contractDocumentReference) {
    this.contractDocumentReference = contractDocumentReference;
  }


  public Invoice delivery(Delivery delivery) {
    this.delivery = delivery;
    return this;
  }

  /**
   * Get delivery
   * @return delivery
   */
  @javax.annotation.Nullable
  public Delivery getDelivery() {
    return delivery;
  }

  public void setDelivery(Delivery delivery) {
    this.delivery = delivery;
  }


  public Invoice documentCurrencyCode(CurrencyCode documentCurrencyCode) {
    this.documentCurrencyCode = documentCurrencyCode;
    return this;
  }

  /**
   * Get documentCurrencyCode
   * @return documentCurrencyCode
   */
  @javax.annotation.Nullable
  public CurrencyCode getDocumentCurrencyCode() {
    return documentCurrencyCode;
  }

  public void setDocumentCurrencyCode(CurrencyCode documentCurrencyCode) {
    this.documentCurrencyCode = documentCurrencyCode;
  }


  public Invoice dueDate(String dueDate) {
    this.dueDate = dueDate;
    return this;
  }

  /**
   * Format: yyyy-mm-dd.
   * @return dueDate
   */
  @javax.annotation.Nullable
  public String getDueDate() {
    return dueDate;
  }

  public void setDueDate(String dueDate) {
    this.dueDate = dueDate;
  }


  public Invoice invoiceLines(List<InvoiceLine> invoiceLines) {
    this.invoiceLines = invoiceLines;
    return this;
  }

  public Invoice addInvoiceLinesItem(InvoiceLine invoiceLinesItem) {
    if (this.invoiceLines == null) {
      this.invoiceLines = new ArrayList<>();
    }
    this.invoiceLines.add(invoiceLinesItem);
    return this;
  }

  /**
   * An array of invoice lines.
   * @return invoiceLines
   */
  @javax.annotation.Nonnull
  public List<InvoiceLine> getInvoiceLines() {
    return invoiceLines;
  }

  public void setInvoiceLines(List<InvoiceLine> invoiceLines) {
    this.invoiceLines = invoiceLines;
  }


  public Invoice invoiceNumber(String invoiceNumber) {
    this.invoiceNumber = invoiceNumber;
    return this;
  }

  /**
   * The invoice number you assigned to the invoice. The invoiceNumber should be unique for the legalEntityId and year of the issueDate. This means invoice numbers can be reused in different years, as is customary in some countries.
   * @return invoiceNumber
   */
  @javax.annotation.Nonnull
  public String getInvoiceNumber() {
    return invoiceNumber;
  }

  public void setInvoiceNumber(String invoiceNumber) {
    this.invoiceNumber = invoiceNumber;
  }


  public Invoice invoicePeriod(String invoicePeriod) {
    this.invoicePeriod = invoicePeriod;
    return this;
  }

  /**
   * The period (or specific date) to which the invoice applies. Format: yyyy-mm-dd - yyyy-mm-dd.
   * @return invoicePeriod
   */
  @javax.annotation.Nullable
  public String getInvoicePeriod() {
    return invoicePeriod;
  }

  public void setInvoicePeriod(String invoicePeriod) {
    this.invoicePeriod = invoicePeriod;
  }


  public Invoice invoiceType(InvoiceTypeEnum invoiceType) {
    this.invoiceType = invoiceType;
    return this;
  }

  /**
   * DEPRECATED. Do not use. This field is available for legacy reasons only. If you want to send a regular invoice (aka UBL type &#39;380&#39;), make sure you have a positive invoice amount. For a credit note (aka UBL type &#39;381&#39;), simply provide a negative invoice amount. If you, in addition to a negative invoice amount, also specify a billingReferences, your invoice will become a corrective invoice (aka UBL type &#39;384&#39;). If your invoice is not sent in the UBL syntax, Storecove will provide the appropriate type for the syntax the invoice is sent in.
   * @return invoiceType
   */
  @javax.annotation.Nullable
  public InvoiceTypeEnum getInvoiceType() {
    return invoiceType;
  }

  public void setInvoiceType(InvoiceTypeEnum invoiceType) {
    this.invoiceType = invoiceType;
  }


  public Invoice issueDate(String issueDate) {
    this.issueDate = issueDate;
    return this;
  }

  /**
   * Format: yyyy-mm-dd.
   * @return issueDate
   */
  @javax.annotation.Nonnull
  public String getIssueDate() {
    return issueDate;
  }

  public void setIssueDate(String issueDate) {
    this.issueDate = issueDate;
  }


  public Invoice issueReasons(List<String> issueReasons) {
    this.issueReasons = issueReasons;
    return this;
  }

  public Invoice addIssueReasonsItem(String issueReasonsItem) {
    if (this.issueReasons == null) {
      this.issueReasons = new ArrayList<>();
    }
    this.issueReasons.add(issueReasonsItem);
    return this;
  }

  /**
   * An array reasons for issuing the invoice.
   * @return issueReasons
   */
  @javax.annotation.Nullable
  public List<String> getIssueReasons() {
    return issueReasons;
  }

  public void setIssueReasons(List<String> issueReasons) {
    this.issueReasons = issueReasons;
  }


  public Invoice note(String note) {
    this.note = note;
    return this;
  }

  /**
   * A note to add to the invoice
   * @return note
   */
  @javax.annotation.Nullable
  public String getNote() {
    return note;
  }

  public void setNote(String note) {
    this.note = note;
  }


  public Invoice orderReference(String orderReference) {
    this.orderReference = orderReference;
    return this;
  }

  /**
   * DEPRECATED. Use a reference object with a documentType &#39;purchase_order&#39;. A reference to an order for this invoice, assigned by the buyer. Note that this often is a key field, since many receivers of invoices will use this field to automatically match the invoice to an order they placed. Many receivers refuse invoices that cannot be automatically matched, in particular government agencies. So it is highly recommended to fill this field whenever possible.
   * @return orderReference
   */
  @javax.annotation.Nullable
  public String getOrderReference() {
    return orderReference;
  }

  public void setOrderReference(String orderReference) {
    this.orderReference = orderReference;
  }


  public Invoice paymentMeansArray(List<PaymentMeans> paymentMeansArray) {
    this.paymentMeansArray = paymentMeansArray;
    return this;
  }

  public Invoice addPaymentMeansArrayItem(PaymentMeans paymentMeansArrayItem) {
    if (this.paymentMeansArray == null) {
      this.paymentMeansArray = new ArrayList<>();
    }
    this.paymentMeansArray.add(paymentMeansArrayItem);
    return this;
  }

  /**
   * An array of payment means (ways to pay the invoice).
   * @return paymentMeansArray
   */
  @javax.annotation.Nullable
  public List<PaymentMeans> getPaymentMeansArray() {
    return paymentMeansArray;
  }

  public void setPaymentMeansArray(List<PaymentMeans> paymentMeansArray) {
    this.paymentMeansArray = paymentMeansArray;
  }


  public Invoice paymentMeansBic(String paymentMeansBic) {
    this.paymentMeansBic = paymentMeansBic;
    return this;
  }

  /**
   * DEPRECATED. Use paymentMeansArray. The BIC (Swift) of the bank where the amount payable should be transferred to
   * @return paymentMeansBic
   */
  @javax.annotation.Nullable
  public String getPaymentMeansBic() {
    return paymentMeansBic;
  }

  public void setPaymentMeansBic(String paymentMeansBic) {
    this.paymentMeansBic = paymentMeansBic;
  }


  public Invoice paymentMeansCode(PaymentMeansCodeEnum paymentMeansCode) {
    this.paymentMeansCode = paymentMeansCode;
    return this;
  }

  /**
   * DEPRECATED. Use paymentMeansArray. How the invoice has been / will be paid. Use only online_payment_service (payment will be made or has been made by an online payment service), bank_card (e.g. debit card, credit card), direct_debit (the amount has been / will be taken out of the client&#39;s bank account), standing_agreement (an unspecified payment means known to both buyer and seller) or credit_transfer (the buyer will do / has done a bank transfer). The numeric codes are for legacy purposes, they should not be used.
   * @return paymentMeansCode
   */
  @javax.annotation.Nullable
  public PaymentMeansCodeEnum getPaymentMeansCode() {
    return paymentMeansCode;
  }

  public void setPaymentMeansCode(PaymentMeansCodeEnum paymentMeansCode) {
    this.paymentMeansCode = paymentMeansCode;
  }


  public Invoice paymentMeansIban(String paymentMeansIban) {
    this.paymentMeansIban = paymentMeansIban;
    return this;
  }

  /**
   * DEPRECATED. Use paymentMeansArray. The IBAN the amount payable should be transferred to
   * @return paymentMeansIban
   */
  @javax.annotation.Nullable
  public String getPaymentMeansIban() {
    return paymentMeansIban;
  }

  public void setPaymentMeansIban(String paymentMeansIban) {
    this.paymentMeansIban = paymentMeansIban;
  }


  public Invoice paymentMeansPaymentId(String paymentMeansPaymentId) {
    this.paymentMeansPaymentId = paymentMeansPaymentId;
    return this;
  }

  /**
   * DEPRECATED. Use the paymentId in the individual PaymentMeans object. The payment id that you will use to match the payment against the invoice.
   * @return paymentMeansPaymentId
   */
  @javax.annotation.Nullable
  public String getPaymentMeansPaymentId() {
    return paymentMeansPaymentId;
  }

  public void setPaymentMeansPaymentId(String paymentMeansPaymentId) {
    this.paymentMeansPaymentId = paymentMeansPaymentId;
  }


  public Invoice paymentTerms(PaymentTerms paymentTerms) {
    this.paymentTerms = paymentTerms;
    return this;
  }

  /**
   * Get paymentTerms
   * @return paymentTerms
   */
  @javax.annotation.Nullable
  public PaymentTerms getPaymentTerms() {
    return paymentTerms;
  }

  public void setPaymentTerms(PaymentTerms paymentTerms) {
    this.paymentTerms = paymentTerms;
  }


  public Invoice preferredInvoiceType(PreferredInvoiceTypeEnum preferredInvoiceType) {
    this.preferredInvoiceType = preferredInvoiceType;
    return this;
  }

  /**
   * In auto mode, the choice between invoice or creditnote is made by Storecove based on what is appropriate for the receiver and the receiver country, in combination with the invoice amount sign. If you wish to state a preference, use this field. It is not guaranteed that the preference will be used, since it depends also on the receiver&#39;s document capabilities.
   * @return preferredInvoiceType
   */
  @javax.annotation.Nullable
  public PreferredInvoiceTypeEnum getPreferredInvoiceType() {
    return preferredInvoiceType;
  }

  public void setPreferredInvoiceType(PreferredInvoiceTypeEnum preferredInvoiceType) {
    this.preferredInvoiceType = preferredInvoiceType;
  }


  public Invoice prepaidAmount(BigDecimal prepaidAmount) {
    this.prepaidAmount = prepaidAmount;
    return this;
  }

  /**
   * The amount already paid.
   * @return prepaidAmount
   */
  @javax.annotation.Nullable
  public BigDecimal getPrepaidAmount() {
    return prepaidAmount;
  }

  public void setPrepaidAmount(BigDecimal prepaidAmount) {
    this.prepaidAmount = prepaidAmount;
  }


  public Invoice priceMode(PriceModeEnum priceMode) {
    this.priceMode = priceMode;
    return this;
  }

  /**
   * The price mode. This is used to determine whether the prices are net or gross. Price Mode &#39;price_mode_gross&#39; can only be used for \&quot;x2y\&quot;: \&quot;b2c\&quot;, sender countries ES, IT and PT, \&quot;clearWithoutSending\&quot;: true and \&quot;taxSystem\&quot;: \&quot;tax_line_percentages\&quot;
   * @return priceMode
   */
  @javax.annotation.Nullable
  public PriceModeEnum getPriceMode() {
    return priceMode;
  }

  public void setPriceMode(PriceModeEnum priceMode) {
    this.priceMode = priceMode;
  }


  public Invoice projectReference(String projectReference) {
    this.projectReference = projectReference;
    return this;
  }

  /**
   * DEPRECATED. Information about the project this invoice relates to.
   * @return projectReference
   */
  @javax.annotation.Nullable
  public String getProjectReference() {
    return projectReference;
  }

  public void setProjectReference(String projectReference) {
    this.projectReference = projectReference;
  }


  public Invoice references(List<Reference> references) {
    this.references = references;
    return this;
  }

  public Invoice addReferencesItem(Reference referencesItem) {
    if (this.references == null) {
      this.references = new ArrayList<>();
    }
    this.references.add(referencesItem);
    return this;
  }

  /**
   * An array of references to other documents. Note that many syntaxes do not support multiple references of the same type in which case they will be concatenated with &#39;,&#39;. Also, not all syntaxes support all documentTypes.
   * @return references
   */
  @javax.annotation.Nullable
  public List<Reference> getReferences() {
    return references;
  }

  public void setReferences(List<Reference> references) {
    this.references = references;
  }


  public Invoice salesOrderId(String salesOrderId) {
    this.salesOrderId = salesOrderId;
    return this;
  }

  /**
   * DEPRECATED. Use a reference object with a documentType &#39;sales_order&#39;. A reference to an order for this invoice, assigned by the seller.
   * @return salesOrderId
   */
  @javax.annotation.Nullable
  public String getSalesOrderId() {
    return salesOrderId;
  }

  public void setSalesOrderId(String salesOrderId) {
    this.salesOrderId = salesOrderId;
  }


  public Invoice selfBillingMode(Boolean selfBillingMode) {
    this.selfBillingMode = selfBillingMode;
    return this;
  }

  /**
   * In self billing mode, the AccountingCustomerParty and the AccountingSupplierParty are be switched. Such an invoice can only be sent via email. Also, your account will need to allow the use of this mode, so before trying to use this please first contact Storecove.
   * @return selfBillingMode
   */
  @javax.annotation.Nullable
  public Boolean getSelfBillingMode() {
    return selfBillingMode;
  }

  public void setSelfBillingMode(Boolean selfBillingMode) {
    this.selfBillingMode = selfBillingMode;
  }


  public Invoice taxExemptReason(TaxExemptReasonEnum taxExemptReason) {
    this.taxExemptReason = taxExemptReason;
    return this;
  }

  /**
   * DEPRECATED. Use Tax/category and specify this per invoice line. If you do specify this field, it will be applied to all invoice lines and it is an error to specify a Tax/category at the invoice line level. This field holds the reason no tax is present in the invoice. Note that this is an invoice level field and you cannot specify it per invoice line. This field is mandatory unless tax is present in the invoice.
   * @return taxExemptReason
   */
  @javax.annotation.Nullable
  public TaxExemptReasonEnum getTaxExemptReason() {
    return taxExemptReason;
  }

  public void setTaxExemptReason(TaxExemptReasonEnum taxExemptReason) {
    this.taxExemptReason = taxExemptReason;
  }


  public Invoice taxPointDate(String taxPointDate) {
    this.taxPointDate = taxPointDate;
    return this;
  }

  /**
   * The tax date is the date on which the supply of goods or of services was made or completed or the date on which the payment on account was made insofar as that date can be determined and differs from the date of the issue of the invoice. EU 2006-112 Article 226 Point 7. Note: For the Dutch TAX authorities the tac date should be the same as the issue date.
   * @return taxPointDate
   */
  @javax.annotation.Nullable
  public String getTaxPointDate() {
    return taxPointDate;
  }

  public void setTaxPointDate(String taxPointDate) {
    this.taxPointDate = taxPointDate;
  }


  public Invoice taxSubtotals(List<TaxSubtotal> taxSubtotals) {
    this.taxSubtotals = taxSubtotals;
    return this;
  }

  public Invoice addTaxSubtotalsItem(TaxSubtotal taxSubtotalsItem) {
    if (this.taxSubtotals == null) {
      this.taxSubtotals = new ArrayList<>();
    }
    this.taxSubtotals.add(taxSubtotalsItem);
    return this;
  }

  /**
   * An array of tax subtotals. This element is mandatory for taxSystem &#39;tax_line_percentages&#39;.
   * @return taxSubtotals
   */
  @javax.annotation.Nullable
  public List<TaxSubtotal> getTaxSubtotals() {
    return taxSubtotals;
  }

  public void setTaxSubtotals(List<TaxSubtotal> taxSubtotals) {
    this.taxSubtotals = taxSubtotals;
  }


  public Invoice taxSystem(TaxSystemEnum taxSystem) {
    this.taxSystem = taxSystem;
    return this;
  }

  /**
   * The tax system used for the invoice. The system &#39;tax_line_percentages&#39; is preferred, but for historic purposes &#39;tax_line_amounts&#39; is supported and the default. Since not all invoice formats that we are required to send support &#39;tax_line_amounts&#39; we will need to convert the invoice to the &#39;tax_line_percentags&#39; system if we are forced to send the invoice in that tax system. Note that an invoice must always contain tax information, even if that is 0% or an item or sender is exempt or tax is completely outside scope. In that case, use the correct tax categories (see &lt;&lt;_openapi_tax&gt;&gt;)
   * @return taxSystem
   */
  @javax.annotation.Nullable
  public TaxSystemEnum getTaxSystem() {
    return taxSystem;
  }

  public void setTaxSystem(TaxSystemEnum taxSystem) {
    this.taxSystem = taxSystem;
  }


  public Invoice taxesDutiesFees(List<Tax> taxesDutiesFees) {
    this.taxesDutiesFees = taxesDutiesFees;
    return this;
  }

  public Invoice addTaxesDutiesFeesItem(Tax taxesDutiesFeesItem) {
    if (this.taxesDutiesFees == null) {
      this.taxesDutiesFees = new ArrayList<>();
    }
    this.taxesDutiesFees.add(taxesDutiesFeesItem);
    return this;
  }

  /**
   * An array of taxes, duties and fees for this invoice. At this moment, the only invoice level tax allowed is the Italian &#39;€2 bollo virtuale&#39;
   * @return taxesDutiesFees
   */
  @javax.annotation.Nullable
  public List<Tax> getTaxesDutiesFees() {
    return taxesDutiesFees;
  }

  public void setTaxesDutiesFees(List<Tax> taxesDutiesFees) {
    this.taxesDutiesFees = taxesDutiesFees;
  }


  public Invoice transactionType(TransactionTypeEnum transactionType) {
    this.transactionType = transactionType;
    return this;
  }

  /**
   * The type of transaction. Currently used only for India.
   * @return transactionType
   */
  @javax.annotation.Nullable
  public TransactionTypeEnum getTransactionType() {
    return transactionType;
  }

  public void setTransactionType(TransactionTypeEnum transactionType) {
    this.transactionType = transactionType;
  }


  public Invoice ublExtensions(List<String> ublExtensions) {
    this.ublExtensions = ublExtensions;
    return this;
  }

  public Invoice addUblExtensionsItem(String ublExtensionsItem) {
    if (this.ublExtensions == null) {
      this.ublExtensions = new ArrayList<>();
    }
    this.ublExtensions.add(ublExtensionsItem);
    return this;
  }

  /**
   * An array of ubl extensions.
   * @return ublExtensions
   */
  @javax.annotation.Nullable
  public List<String> getUblExtensions() {
    return ublExtensions;
  }

  public void setUblExtensions(List<String> ublExtensions) {
    this.ublExtensions = ublExtensions;
  }


  public Invoice vatReverseCharge(Boolean vatReverseCharge) {
    this.vatReverseCharge = vatReverseCharge;
    return this;
  }

  /**
   * DEPRECATED. Use taxExemptReason.
   * @return vatReverseCharge
   */
  @javax.annotation.Nullable
  public Boolean getVatReverseCharge() {
    return vatReverseCharge;
  }

  public void setVatReverseCharge(Boolean vatReverseCharge) {
    this.vatReverseCharge = vatReverseCharge;
  }


  public Invoice x2y(X2yEnum x2y) {
    this.x2y = x2y;
    return this;
  }

  /**
   * The type of entities the document is sent from/to: b2b (business-to-business), b2g (business-to-government) or b2c (business-to-consumer). This field does not have a default, but it in mose cases it will be treated as b2b. Only when you explicitly specify b2g or b2c OR when it is clear from the context will a different value be used. For instance, when we see the document is being routed to DE:LWID or NL:OINO number, this tells us it is b2g. But in many cases we are unable to determine this and so it is best to always specify this field. Note that b2b_sez is for use inside India only.
   * @return x2y
   */
  @javax.annotation.Nullable
  public X2yEnum getX2y() {
    return x2y;
  }

  public void setX2y(X2yEnum x2y) {
    this.x2y = x2y;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Invoice invoice = (Invoice) o;
    return Objects.equals(this.accountingCost, invoice.accountingCost) &&
        Objects.equals(this.accountingCurrencyTaxAmount, invoice.accountingCurrencyTaxAmount) &&
        Objects.equals(this.accountingCurrencyTaxAmountCurrency, invoice.accountingCurrencyTaxAmountCurrency) &&
        Objects.equals(this.accountingCustomerParty, invoice.accountingCustomerParty) &&
        Objects.equals(this.accountingSupplierParty, invoice.accountingSupplierParty) &&
        Objects.equals(this.allowanceCharges, invoice.allowanceCharges) &&
        Objects.equals(this.amountIncludingVat, invoice.amountIncludingVat) &&
        Objects.equals(this.attachments, invoice.attachments) &&
        Objects.equals(this.billingReference, invoice.billingReference) &&
        Objects.equals(this.buyerReference, invoice.buyerReference) &&
        Objects.equals(this.consumerTaxMode, invoice.consumerTaxMode) &&
        Objects.equals(this.contractDocumentReference, invoice.contractDocumentReference) &&
        Objects.equals(this.delivery, invoice.delivery) &&
        Objects.equals(this.documentCurrencyCode, invoice.documentCurrencyCode) &&
        Objects.equals(this.dueDate, invoice.dueDate) &&
        Objects.equals(this.invoiceLines, invoice.invoiceLines) &&
        Objects.equals(this.invoiceNumber, invoice.invoiceNumber) &&
        Objects.equals(this.invoicePeriod, invoice.invoicePeriod) &&
        Objects.equals(this.invoiceType, invoice.invoiceType) &&
        Objects.equals(this.issueDate, invoice.issueDate) &&
        Objects.equals(this.issueReasons, invoice.issueReasons) &&
        Objects.equals(this.note, invoice.note) &&
        Objects.equals(this.orderReference, invoice.orderReference) &&
        Objects.equals(this.paymentMeansArray, invoice.paymentMeansArray) &&
        Objects.equals(this.paymentMeansBic, invoice.paymentMeansBic) &&
        Objects.equals(this.paymentMeansCode, invoice.paymentMeansCode) &&
        Objects.equals(this.paymentMeansIban, invoice.paymentMeansIban) &&
        Objects.equals(this.paymentMeansPaymentId, invoice.paymentMeansPaymentId) &&
        Objects.equals(this.paymentTerms, invoice.paymentTerms) &&
        Objects.equals(this.preferredInvoiceType, invoice.preferredInvoiceType) &&
        Objects.equals(this.prepaidAmount, invoice.prepaidAmount) &&
        Objects.equals(this.priceMode, invoice.priceMode) &&
        Objects.equals(this.projectReference, invoice.projectReference) &&
        Objects.equals(this.references, invoice.references) &&
        Objects.equals(this.salesOrderId, invoice.salesOrderId) &&
        Objects.equals(this.selfBillingMode, invoice.selfBillingMode) &&
        Objects.equals(this.taxExemptReason, invoice.taxExemptReason) &&
        Objects.equals(this.taxPointDate, invoice.taxPointDate) &&
        Objects.equals(this.taxSubtotals, invoice.taxSubtotals) &&
        Objects.equals(this.taxSystem, invoice.taxSystem) &&
        Objects.equals(this.taxesDutiesFees, invoice.taxesDutiesFees) &&
        Objects.equals(this.transactionType, invoice.transactionType) &&
        Objects.equals(this.ublExtensions, invoice.ublExtensions) &&
        Objects.equals(this.vatReverseCharge, invoice.vatReverseCharge) &&
        Objects.equals(this.x2y, invoice.x2y);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountingCost, accountingCurrencyTaxAmount, accountingCurrencyTaxAmountCurrency, accountingCustomerParty, accountingSupplierParty, allowanceCharges, amountIncludingVat, attachments, billingReference, buyerReference, consumerTaxMode, contractDocumentReference, delivery, documentCurrencyCode, dueDate, invoiceLines, invoiceNumber, invoicePeriod, invoiceType, issueDate, issueReasons, note, orderReference, paymentMeansArray, paymentMeansBic, paymentMeansCode, paymentMeansIban, paymentMeansPaymentId, paymentTerms, preferredInvoiceType, prepaidAmount, priceMode, projectReference, references, salesOrderId, selfBillingMode, taxExemptReason, taxPointDate, taxSubtotals, taxSystem, taxesDutiesFees, transactionType, ublExtensions, vatReverseCharge, x2y);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Invoice {\n");
    sb.append("    accountingCost: ").append(toIndentedString(accountingCost)).append("\n");
    sb.append("    accountingCurrencyTaxAmount: ").append(toIndentedString(accountingCurrencyTaxAmount)).append("\n");
    sb.append("    accountingCurrencyTaxAmountCurrency: ").append(toIndentedString(accountingCurrencyTaxAmountCurrency)).append("\n");
    sb.append("    accountingCustomerParty: ").append(toIndentedString(accountingCustomerParty)).append("\n");
    sb.append("    accountingSupplierParty: ").append(toIndentedString(accountingSupplierParty)).append("\n");
    sb.append("    allowanceCharges: ").append(toIndentedString(allowanceCharges)).append("\n");
    sb.append("    amountIncludingVat: ").append(toIndentedString(amountIncludingVat)).append("\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    billingReference: ").append(toIndentedString(billingReference)).append("\n");
    sb.append("    buyerReference: ").append(toIndentedString(buyerReference)).append("\n");
    sb.append("    consumerTaxMode: ").append(toIndentedString(consumerTaxMode)).append("\n");
    sb.append("    contractDocumentReference: ").append(toIndentedString(contractDocumentReference)).append("\n");
    sb.append("    delivery: ").append(toIndentedString(delivery)).append("\n");
    sb.append("    documentCurrencyCode: ").append(toIndentedString(documentCurrencyCode)).append("\n");
    sb.append("    dueDate: ").append(toIndentedString(dueDate)).append("\n");
    sb.append("    invoiceLines: ").append(toIndentedString(invoiceLines)).append("\n");
    sb.append("    invoiceNumber: ").append(toIndentedString(invoiceNumber)).append("\n");
    sb.append("    invoicePeriod: ").append(toIndentedString(invoicePeriod)).append("\n");
    sb.append("    invoiceType: ").append(toIndentedString(invoiceType)).append("\n");
    sb.append("    issueDate: ").append(toIndentedString(issueDate)).append("\n");
    sb.append("    issueReasons: ").append(toIndentedString(issueReasons)).append("\n");
    sb.append("    note: ").append(toIndentedString(note)).append("\n");
    sb.append("    orderReference: ").append(toIndentedString(orderReference)).append("\n");
    sb.append("    paymentMeansArray: ").append(toIndentedString(paymentMeansArray)).append("\n");
    sb.append("    paymentMeansBic: ").append(toIndentedString(paymentMeansBic)).append("\n");
    sb.append("    paymentMeansCode: ").append(toIndentedString(paymentMeansCode)).append("\n");
    sb.append("    paymentMeansIban: ").append(toIndentedString(paymentMeansIban)).append("\n");
    sb.append("    paymentMeansPaymentId: ").append(toIndentedString(paymentMeansPaymentId)).append("\n");
    sb.append("    paymentTerms: ").append(toIndentedString(paymentTerms)).append("\n");
    sb.append("    preferredInvoiceType: ").append(toIndentedString(preferredInvoiceType)).append("\n");
    sb.append("    prepaidAmount: ").append(toIndentedString(prepaidAmount)).append("\n");
    sb.append("    priceMode: ").append(toIndentedString(priceMode)).append("\n");
    sb.append("    projectReference: ").append(toIndentedString(projectReference)).append("\n");
    sb.append("    references: ").append(toIndentedString(references)).append("\n");
    sb.append("    salesOrderId: ").append(toIndentedString(salesOrderId)).append("\n");
    sb.append("    selfBillingMode: ").append(toIndentedString(selfBillingMode)).append("\n");
    sb.append("    taxExemptReason: ").append(toIndentedString(taxExemptReason)).append("\n");
    sb.append("    taxPointDate: ").append(toIndentedString(taxPointDate)).append("\n");
    sb.append("    taxSubtotals: ").append(toIndentedString(taxSubtotals)).append("\n");
    sb.append("    taxSystem: ").append(toIndentedString(taxSystem)).append("\n");
    sb.append("    taxesDutiesFees: ").append(toIndentedString(taxesDutiesFees)).append("\n");
    sb.append("    transactionType: ").append(toIndentedString(transactionType)).append("\n");
    sb.append("    ublExtensions: ").append(toIndentedString(ublExtensions)).append("\n");
    sb.append("    vatReverseCharge: ").append(toIndentedString(vatReverseCharge)).append("\n");
    sb.append("    x2y: ").append(toIndentedString(x2y)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountingCost");
    openapiFields.add("accountingCurrencyTaxAmount");
    openapiFields.add("accountingCurrencyTaxAmountCurrency");
    openapiFields.add("accountingCustomerParty");
    openapiFields.add("accountingSupplierParty");
    openapiFields.add("allowanceCharges");
    openapiFields.add("amountIncludingVat");
    openapiFields.add("attachments");
    openapiFields.add("billingReference");
    openapiFields.add("buyerReference");
    openapiFields.add("consumerTaxMode");
    openapiFields.add("contractDocumentReference");
    openapiFields.add("delivery");
    openapiFields.add("documentCurrencyCode");
    openapiFields.add("dueDate");
    openapiFields.add("invoiceLines");
    openapiFields.add("invoiceNumber");
    openapiFields.add("invoicePeriod");
    openapiFields.add("invoiceType");
    openapiFields.add("issueDate");
    openapiFields.add("issueReasons");
    openapiFields.add("note");
    openapiFields.add("orderReference");
    openapiFields.add("paymentMeansArray");
    openapiFields.add("paymentMeansBic");
    openapiFields.add("paymentMeansCode");
    openapiFields.add("paymentMeansIban");
    openapiFields.add("paymentMeansPaymentId");
    openapiFields.add("paymentTerms");
    openapiFields.add("preferredInvoiceType");
    openapiFields.add("prepaidAmount");
    openapiFields.add("priceMode");
    openapiFields.add("projectReference");
    openapiFields.add("references");
    openapiFields.add("salesOrderId");
    openapiFields.add("selfBillingMode");
    openapiFields.add("taxExemptReason");
    openapiFields.add("taxPointDate");
    openapiFields.add("taxSubtotals");
    openapiFields.add("taxSystem");
    openapiFields.add("taxesDutiesFees");
    openapiFields.add("transactionType");
    openapiFields.add("ublExtensions");
    openapiFields.add("vatReverseCharge");
    openapiFields.add("x2y");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("accountingCustomerParty");
    openapiRequiredFields.add("amountIncludingVat");
    openapiRequiredFields.add("invoiceLines");
    openapiRequiredFields.add("invoiceNumber");
    openapiRequiredFields.add("issueDate");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Invoice
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Invoice.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Invoice is not found in the empty JSON string", Invoice.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Invoice.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Invoice` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Invoice.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accountingCost") != null && !jsonObj.get("accountingCost").isJsonNull()) && !jsonObj.get("accountingCost").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountingCost` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountingCost").toString()));
      }
      // validate the optional field `accountingCurrencyTaxAmountCurrency`
      if (jsonObj.get("accountingCurrencyTaxAmountCurrency") != null && !jsonObj.get("accountingCurrencyTaxAmountCurrency").isJsonNull()) {
        CurrencyCode.validateJsonElement(jsonObj.get("accountingCurrencyTaxAmountCurrency"));
      }
      // validate the required field `accountingCustomerParty`
      AccountingCustomerParty.validateJsonElement(jsonObj.get("accountingCustomerParty"));
      // validate the optional field `accountingSupplierParty`
      if (jsonObj.get("accountingSupplierParty") != null && !jsonObj.get("accountingSupplierParty").isJsonNull()) {
        AccountingSupplierParty.validateJsonElement(jsonObj.get("accountingSupplierParty"));
      }
      if (jsonObj.get("allowanceCharges") != null && !jsonObj.get("allowanceCharges").isJsonNull()) {
        JsonArray jsonArrayallowanceCharges = jsonObj.getAsJsonArray("allowanceCharges");
        if (jsonArrayallowanceCharges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("allowanceCharges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `allowanceCharges` to be an array in the JSON string but got `%s`", jsonObj.get("allowanceCharges").toString()));
          }

          // validate the optional field `allowanceCharges` (array)
          for (int i = 0; i < jsonArrayallowanceCharges.size(); i++) {
            AllowanceCharge.validateJsonElement(jsonArrayallowanceCharges.get(i));
          };
        }
      }
      if (jsonObj.get("attachments") != null && !jsonObj.get("attachments").isJsonNull()) {
        JsonArray jsonArrayattachments = jsonObj.getAsJsonArray("attachments");
        if (jsonArrayattachments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("attachments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `attachments` to be an array in the JSON string but got `%s`", jsonObj.get("attachments").toString()));
          }

          // validate the optional field `attachments` (array)
          for (int i = 0; i < jsonArrayattachments.size(); i++) {
            Attachment.validateJsonElement(jsonArrayattachments.get(i));
          };
        }
      }
      if ((jsonObj.get("billingReference") != null && !jsonObj.get("billingReference").isJsonNull()) && !jsonObj.get("billingReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `billingReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("billingReference").toString()));
      }
      if ((jsonObj.get("buyerReference") != null && !jsonObj.get("buyerReference").isJsonNull()) && !jsonObj.get("buyerReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `buyerReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("buyerReference").toString()));
      }
      if ((jsonObj.get("contractDocumentReference") != null && !jsonObj.get("contractDocumentReference").isJsonNull()) && !jsonObj.get("contractDocumentReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contractDocumentReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contractDocumentReference").toString()));
      }
      // validate the optional field `delivery`
      if (jsonObj.get("delivery") != null && !jsonObj.get("delivery").isJsonNull()) {
        Delivery.validateJsonElement(jsonObj.get("delivery"));
      }
      // validate the optional field `documentCurrencyCode`
      if (jsonObj.get("documentCurrencyCode") != null && !jsonObj.get("documentCurrencyCode").isJsonNull()) {
        CurrencyCode.validateJsonElement(jsonObj.get("documentCurrencyCode"));
      }
      if ((jsonObj.get("dueDate") != null && !jsonObj.get("dueDate").isJsonNull()) && !jsonObj.get("dueDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dueDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dueDate").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("invoiceLines").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `invoiceLines` to be an array in the JSON string but got `%s`", jsonObj.get("invoiceLines").toString()));
      }

      JsonArray jsonArrayinvoiceLines = jsonObj.getAsJsonArray("invoiceLines");
      // validate the required field `invoiceLines` (array)
      for (int i = 0; i < jsonArrayinvoiceLines.size(); i++) {
        InvoiceLine.validateJsonElement(jsonArrayinvoiceLines.get(i));
      };
      if (!jsonObj.get("invoiceNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `invoiceNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("invoiceNumber").toString()));
      }
      if ((jsonObj.get("invoicePeriod") != null && !jsonObj.get("invoicePeriod").isJsonNull()) && !jsonObj.get("invoicePeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `invoicePeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("invoicePeriod").toString()));
      }
      if ((jsonObj.get("invoiceType") != null && !jsonObj.get("invoiceType").isJsonNull()) && !jsonObj.get("invoiceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `invoiceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("invoiceType").toString()));
      }
      // validate the optional field `invoiceType`
      if (jsonObj.get("invoiceType") != null && !jsonObj.get("invoiceType").isJsonNull()) {
        InvoiceTypeEnum.validateJsonElement(jsonObj.get("invoiceType"));
      }
      if (!jsonObj.get("issueDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("issueDate").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("issueReasons") != null && !jsonObj.get("issueReasons").isJsonNull() && !jsonObj.get("issueReasons").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueReasons` to be an array in the JSON string but got `%s`", jsonObj.get("issueReasons").toString()));
      }
      if ((jsonObj.get("note") != null && !jsonObj.get("note").isJsonNull()) && !jsonObj.get("note").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `note` to be a primitive type in the JSON string but got `%s`", jsonObj.get("note").toString()));
      }
      if ((jsonObj.get("orderReference") != null && !jsonObj.get("orderReference").isJsonNull()) && !jsonObj.get("orderReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderReference").toString()));
      }
      if (jsonObj.get("paymentMeansArray") != null && !jsonObj.get("paymentMeansArray").isJsonNull()) {
        JsonArray jsonArraypaymentMeansArray = jsonObj.getAsJsonArray("paymentMeansArray");
        if (jsonArraypaymentMeansArray != null) {
          // ensure the json data is an array
          if (!jsonObj.get("paymentMeansArray").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `paymentMeansArray` to be an array in the JSON string but got `%s`", jsonObj.get("paymentMeansArray").toString()));
          }

          // validate the optional field `paymentMeansArray` (array)
          for (int i = 0; i < jsonArraypaymentMeansArray.size(); i++) {
            PaymentMeans.validateJsonElement(jsonArraypaymentMeansArray.get(i));
          };
        }
      }
      if ((jsonObj.get("paymentMeansBic") != null && !jsonObj.get("paymentMeansBic").isJsonNull()) && !jsonObj.get("paymentMeansBic").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentMeansBic` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paymentMeansBic").toString()));
      }
      if ((jsonObj.get("paymentMeansCode") != null && !jsonObj.get("paymentMeansCode").isJsonNull()) && !jsonObj.get("paymentMeansCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentMeansCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paymentMeansCode").toString()));
      }
      // validate the optional field `paymentMeansCode`
      if (jsonObj.get("paymentMeansCode") != null && !jsonObj.get("paymentMeansCode").isJsonNull()) {
        PaymentMeansCodeEnum.validateJsonElement(jsonObj.get("paymentMeansCode"));
      }
      if ((jsonObj.get("paymentMeansIban") != null && !jsonObj.get("paymentMeansIban").isJsonNull()) && !jsonObj.get("paymentMeansIban").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentMeansIban` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paymentMeansIban").toString()));
      }
      if ((jsonObj.get("paymentMeansPaymentId") != null && !jsonObj.get("paymentMeansPaymentId").isJsonNull()) && !jsonObj.get("paymentMeansPaymentId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentMeansPaymentId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paymentMeansPaymentId").toString()));
      }
      // validate the optional field `paymentTerms`
      if (jsonObj.get("paymentTerms") != null && !jsonObj.get("paymentTerms").isJsonNull()) {
        PaymentTerms.validateJsonElement(jsonObj.get("paymentTerms"));
      }
      if ((jsonObj.get("preferredInvoiceType") != null && !jsonObj.get("preferredInvoiceType").isJsonNull()) && !jsonObj.get("preferredInvoiceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preferredInvoiceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preferredInvoiceType").toString()));
      }
      // validate the optional field `preferredInvoiceType`
      if (jsonObj.get("preferredInvoiceType") != null && !jsonObj.get("preferredInvoiceType").isJsonNull()) {
        PreferredInvoiceTypeEnum.validateJsonElement(jsonObj.get("preferredInvoiceType"));
      }
      if ((jsonObj.get("priceMode") != null && !jsonObj.get("priceMode").isJsonNull()) && !jsonObj.get("priceMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priceMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priceMode").toString()));
      }
      // validate the optional field `priceMode`
      if (jsonObj.get("priceMode") != null && !jsonObj.get("priceMode").isJsonNull()) {
        PriceModeEnum.validateJsonElement(jsonObj.get("priceMode"));
      }
      if ((jsonObj.get("projectReference") != null && !jsonObj.get("projectReference").isJsonNull()) && !jsonObj.get("projectReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `projectReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("projectReference").toString()));
      }
      if (jsonObj.get("references") != null && !jsonObj.get("references").isJsonNull()) {
        JsonArray jsonArrayreferences = jsonObj.getAsJsonArray("references");
        if (jsonArrayreferences != null) {
          // ensure the json data is an array
          if (!jsonObj.get("references").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `references` to be an array in the JSON string but got `%s`", jsonObj.get("references").toString()));
          }

          // validate the optional field `references` (array)
          for (int i = 0; i < jsonArrayreferences.size(); i++) {
            Reference.validateJsonElement(jsonArrayreferences.get(i));
          };
        }
      }
      if ((jsonObj.get("salesOrderId") != null && !jsonObj.get("salesOrderId").isJsonNull()) && !jsonObj.get("salesOrderId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `salesOrderId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("salesOrderId").toString()));
      }
      if ((jsonObj.get("taxExemptReason") != null && !jsonObj.get("taxExemptReason").isJsonNull()) && !jsonObj.get("taxExemptReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taxExemptReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taxExemptReason").toString()));
      }
      // validate the optional field `taxExemptReason`
      if (jsonObj.get("taxExemptReason") != null && !jsonObj.get("taxExemptReason").isJsonNull()) {
        TaxExemptReasonEnum.validateJsonElement(jsonObj.get("taxExemptReason"));
      }
      if ((jsonObj.get("taxPointDate") != null && !jsonObj.get("taxPointDate").isJsonNull()) && !jsonObj.get("taxPointDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taxPointDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taxPointDate").toString()));
      }
      if (jsonObj.get("taxSubtotals") != null && !jsonObj.get("taxSubtotals").isJsonNull()) {
        JsonArray jsonArraytaxSubtotals = jsonObj.getAsJsonArray("taxSubtotals");
        if (jsonArraytaxSubtotals != null) {
          // ensure the json data is an array
          if (!jsonObj.get("taxSubtotals").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `taxSubtotals` to be an array in the JSON string but got `%s`", jsonObj.get("taxSubtotals").toString()));
          }

          // validate the optional field `taxSubtotals` (array)
          for (int i = 0; i < jsonArraytaxSubtotals.size(); i++) {
            TaxSubtotal.validateJsonElement(jsonArraytaxSubtotals.get(i));
          };
        }
      }
      if ((jsonObj.get("taxSystem") != null && !jsonObj.get("taxSystem").isJsonNull()) && !jsonObj.get("taxSystem").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taxSystem` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taxSystem").toString()));
      }
      // validate the optional field `taxSystem`
      if (jsonObj.get("taxSystem") != null && !jsonObj.get("taxSystem").isJsonNull()) {
        TaxSystemEnum.validateJsonElement(jsonObj.get("taxSystem"));
      }
      if (jsonObj.get("taxesDutiesFees") != null && !jsonObj.get("taxesDutiesFees").isJsonNull()) {
        JsonArray jsonArraytaxesDutiesFees = jsonObj.getAsJsonArray("taxesDutiesFees");
        if (jsonArraytaxesDutiesFees != null) {
          // ensure the json data is an array
          if (!jsonObj.get("taxesDutiesFees").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `taxesDutiesFees` to be an array in the JSON string but got `%s`", jsonObj.get("taxesDutiesFees").toString()));
          }

          // validate the optional field `taxesDutiesFees` (array)
          for (int i = 0; i < jsonArraytaxesDutiesFees.size(); i++) {
            Tax.validateJsonElement(jsonArraytaxesDutiesFees.get(i));
          };
        }
      }
      if ((jsonObj.get("transactionType") != null && !jsonObj.get("transactionType").isJsonNull()) && !jsonObj.get("transactionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionType").toString()));
      }
      // validate the optional field `transactionType`
      if (jsonObj.get("transactionType") != null && !jsonObj.get("transactionType").isJsonNull()) {
        TransactionTypeEnum.validateJsonElement(jsonObj.get("transactionType"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ublExtensions") != null && !jsonObj.get("ublExtensions").isJsonNull() && !jsonObj.get("ublExtensions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ublExtensions` to be an array in the JSON string but got `%s`", jsonObj.get("ublExtensions").toString()));
      }
      if ((jsonObj.get("x2y") != null && !jsonObj.get("x2y").isJsonNull()) && !jsonObj.get("x2y").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `x2y` to be a primitive type in the JSON string but got `%s`", jsonObj.get("x2y").toString()));
      }
      // validate the optional field `x2y`
      if (jsonObj.get("x2y") != null && !jsonObj.get("x2y").isJsonNull()) {
        X2yEnum.validateJsonElement(jsonObj.get("x2y"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Invoice.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Invoice' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Invoice> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Invoice.class));

       return (TypeAdapter<T>) new TypeAdapter<Invoice>() {
           @Override
           public void write(JsonWriter out, Invoice value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Invoice read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Invoice given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Invoice
   * @throws IOException if the JSON string is invalid with respect to Invoice
   */
  public static Invoice fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Invoice.class);
  }

  /**
   * Convert an instance of Invoice to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

