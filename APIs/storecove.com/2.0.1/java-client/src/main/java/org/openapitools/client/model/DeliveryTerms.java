/*
 * Storecove API
 * Storecove API
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: apisupport@storecove.nl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * DeliveryTerms
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:44.175207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DeliveryTerms {
  public static final String SERIALIZED_NAME_DELIVERY_LOCATION_ID = "deliveryLocationId";
  @SerializedName(SERIALIZED_NAME_DELIVERY_LOCATION_ID)
  private String deliveryLocationId;

  /**
   * The incoterms: ++++ &lt;ul&gt;    &lt;li&gt;        &lt;strong&gt;EXW – Ex Works&lt;/strong&gt;&lt;br/&gt;        The seller must give the buyer access to goods at an agreed location. From that moment, the buyer bears almost all costs and risks during the entire shipping process.&lt;br/&gt;    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;FCA – Free Carrier&lt;/strong&gt;&lt;br/&gt;        The seller must make the goods available at his own risk and expense at his own premises or at an agreed place. In both cases, the seller is responsible for the clearance of the goods for export. It can be agreed that the buyer must instruct the carrier to transfer a “Bill of Lading (BL)” with a note on board to the seller.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CPT – Carriage Paid To&lt;/strong&gt;&lt;br/&gt;        The seller has the same responsibilities as with FCA, but in this case also pays the delivery costs.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CIP – Carriage Insurance Paid To&lt;/strong&gt;&lt;br/&gt;        The same seller responsibilities as with CPT, only in this case the seller is obliged to pay the insurance with a high coverage ratio. Parties can agree separately to apply limited coverage.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;DAP – Delivered At Place&lt;/strong&gt;&lt;br/&gt;        The seller bears the costs and risks during the transport of the goods to an agreed address. As soon as the goods have arrived at this address and are ready for unloading, the risk passes to the buyer.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;DPU – Delivered at Place Unloaded&lt;/strong&gt;&lt;br/&gt;        The seller is responsible for the costs and risks of delivering goods to an agreed destination where goods can be unloaded for further transport. The selling party arranges customs and unloads the goods at the agreed place. The buyer arranges the customs clearance and any associated rights.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;DDP – Delivered Duty Paid&lt;/strong&gt;&lt;br/&gt;        The seller bears the costs and risks of transport, carries out the export and import responsibilities and pays any import duties. As soon as the goods have arrived at the address and are ready for unloading, the risk passes to the buyer.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;FAS – Free Alongside Ship&lt;/strong&gt;&lt;br/&gt;        The seller bears all costs and risks until the goods are delivered next to the ship. From that point, the risk is for the buyer and he also arranges the export clearance and import clearance.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;FOB – Free On Board&lt;/strong&gt;&lt;br/&gt;        The seller bears all costs and risks until the goods are on board the ship and also arranges the export clearance. As soon as the goods have been delivered to the ship, the buyer bears all responsibilities.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CFR – Cost And Freight&lt;/strong&gt;&lt;br/&gt;        The same applies to the seller and buyer as with FOB, but in this case, the seller must also pay for the transport of the goods to the port.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CIF – Cost, Insurance, and Freight&lt;/strong&gt;&lt;br/&gt;        The seller has the same obligations as with CFR but also pays the (minimum) insurance costs. The buyer must pay for more comprehensive insurance.    &lt;/li&gt;&lt;/ul&gt; ++++
   */
  @JsonAdapter(IncotermsEnum.Adapter.class)
  public enum IncotermsEnum {
    EXW("EXW"),
    
    FCA("FCA"),
    
    CPT("CPT"),
    
    CIP("CIP"),
    
    DAP("DAP"),
    
    DPU("DPU"),
    
    DDP("DDP"),
    
    FAS("FAS"),
    
    FOB("FOB"),
    
    CFR("CFR"),
    
    CIF("CIF");

    private String value;

    IncotermsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IncotermsEnum fromValue(String value) {
      for (IncotermsEnum b : IncotermsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IncotermsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IncotermsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IncotermsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IncotermsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IncotermsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INCOTERMS = "incoterms";
  @SerializedName(SERIALIZED_NAME_INCOTERMS)
  private IncotermsEnum incoterms;

  public static final String SERIALIZED_NAME_SPECIAL_TERMS = "specialTerms";
  @SerializedName(SERIALIZED_NAME_SPECIAL_TERMS)
  private String specialTerms;

  public DeliveryTerms() {
  }

  public DeliveryTerms deliveryLocationId(String deliveryLocationId) {
    this.deliveryLocationId = deliveryLocationId;
    return this;
  }

  /**
   * The location to which the delivery terms refer.
   * @return deliveryLocationId
   */
  @javax.annotation.Nullable
  public String getDeliveryLocationId() {
    return deliveryLocationId;
  }

  public void setDeliveryLocationId(String deliveryLocationId) {
    this.deliveryLocationId = deliveryLocationId;
  }


  public DeliveryTerms incoterms(IncotermsEnum incoterms) {
    this.incoterms = incoterms;
    return this;
  }

  /**
   * The incoterms: ++++ &lt;ul&gt;    &lt;li&gt;        &lt;strong&gt;EXW – Ex Works&lt;/strong&gt;&lt;br/&gt;        The seller must give the buyer access to goods at an agreed location. From that moment, the buyer bears almost all costs and risks during the entire shipping process.&lt;br/&gt;    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;FCA – Free Carrier&lt;/strong&gt;&lt;br/&gt;        The seller must make the goods available at his own risk and expense at his own premises or at an agreed place. In both cases, the seller is responsible for the clearance of the goods for export. It can be agreed that the buyer must instruct the carrier to transfer a “Bill of Lading (BL)” with a note on board to the seller.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CPT – Carriage Paid To&lt;/strong&gt;&lt;br/&gt;        The seller has the same responsibilities as with FCA, but in this case also pays the delivery costs.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CIP – Carriage Insurance Paid To&lt;/strong&gt;&lt;br/&gt;        The same seller responsibilities as with CPT, only in this case the seller is obliged to pay the insurance with a high coverage ratio. Parties can agree separately to apply limited coverage.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;DAP – Delivered At Place&lt;/strong&gt;&lt;br/&gt;        The seller bears the costs and risks during the transport of the goods to an agreed address. As soon as the goods have arrived at this address and are ready for unloading, the risk passes to the buyer.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;DPU – Delivered at Place Unloaded&lt;/strong&gt;&lt;br/&gt;        The seller is responsible for the costs and risks of delivering goods to an agreed destination where goods can be unloaded for further transport. The selling party arranges customs and unloads the goods at the agreed place. The buyer arranges the customs clearance and any associated rights.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;DDP – Delivered Duty Paid&lt;/strong&gt;&lt;br/&gt;        The seller bears the costs and risks of transport, carries out the export and import responsibilities and pays any import duties. As soon as the goods have arrived at the address and are ready for unloading, the risk passes to the buyer.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;FAS – Free Alongside Ship&lt;/strong&gt;&lt;br/&gt;        The seller bears all costs and risks until the goods are delivered next to the ship. From that point, the risk is for the buyer and he also arranges the export clearance and import clearance.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;FOB – Free On Board&lt;/strong&gt;&lt;br/&gt;        The seller bears all costs and risks until the goods are on board the ship and also arranges the export clearance. As soon as the goods have been delivered to the ship, the buyer bears all responsibilities.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CFR – Cost And Freight&lt;/strong&gt;&lt;br/&gt;        The same applies to the seller and buyer as with FOB, but in this case, the seller must also pay for the transport of the goods to the port.    &lt;/li&gt;    &lt;li&gt;        &lt;strong&gt;CIF – Cost, Insurance, and Freight&lt;/strong&gt;&lt;br/&gt;        The seller has the same obligations as with CFR but also pays the (minimum) insurance costs. The buyer must pay for more comprehensive insurance.    &lt;/li&gt;&lt;/ul&gt; ++++
   * @return incoterms
   */
  @javax.annotation.Nullable
  public IncotermsEnum getIncoterms() {
    return incoterms;
  }

  public void setIncoterms(IncotermsEnum incoterms) {
    this.incoterms = incoterms;
  }


  public DeliveryTerms specialTerms(String specialTerms) {
    this.specialTerms = specialTerms;
    return this;
  }

  /**
   * A description of special conditions relating to the delivery terms.
   * @return specialTerms
   */
  @javax.annotation.Nullable
  public String getSpecialTerms() {
    return specialTerms;
  }

  public void setSpecialTerms(String specialTerms) {
    this.specialTerms = specialTerms;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DeliveryTerms deliveryTerms = (DeliveryTerms) o;
    return Objects.equals(this.deliveryLocationId, deliveryTerms.deliveryLocationId) &&
        Objects.equals(this.incoterms, deliveryTerms.incoterms) &&
        Objects.equals(this.specialTerms, deliveryTerms.specialTerms);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deliveryLocationId, incoterms, specialTerms);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DeliveryTerms {\n");
    sb.append("    deliveryLocationId: ").append(toIndentedString(deliveryLocationId)).append("\n");
    sb.append("    incoterms: ").append(toIndentedString(incoterms)).append("\n");
    sb.append("    specialTerms: ").append(toIndentedString(specialTerms)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("deliveryLocationId");
    openapiFields.add("incoterms");
    openapiFields.add("specialTerms");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DeliveryTerms
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DeliveryTerms.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DeliveryTerms is not found in the empty JSON string", DeliveryTerms.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DeliveryTerms.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DeliveryTerms` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("deliveryLocationId") != null && !jsonObj.get("deliveryLocationId").isJsonNull()) && !jsonObj.get("deliveryLocationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deliveryLocationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deliveryLocationId").toString()));
      }
      if ((jsonObj.get("incoterms") != null && !jsonObj.get("incoterms").isJsonNull()) && !jsonObj.get("incoterms").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `incoterms` to be a primitive type in the JSON string but got `%s`", jsonObj.get("incoterms").toString()));
      }
      // validate the optional field `incoterms`
      if (jsonObj.get("incoterms") != null && !jsonObj.get("incoterms").isJsonNull()) {
        IncotermsEnum.validateJsonElement(jsonObj.get("incoterms"));
      }
      if ((jsonObj.get("specialTerms") != null && !jsonObj.get("specialTerms").isJsonNull()) && !jsonObj.get("specialTerms").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `specialTerms` to be a primitive type in the JSON string but got `%s`", jsonObj.get("specialTerms").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DeliveryTerms.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DeliveryTerms' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DeliveryTerms> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DeliveryTerms.class));

       return (TypeAdapter<T>) new TypeAdapter<DeliveryTerms>() {
           @Override
           public void write(JsonWriter out, DeliveryTerms value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DeliveryTerms read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DeliveryTerms given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DeliveryTerms
   * @throws IOException if the JSON string is invalid with respect to DeliveryTerms
   */
  public static DeliveryTerms fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DeliveryTerms.class);
  }

  /**
   * Convert an instance of DeliveryTerms to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

