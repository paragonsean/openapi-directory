/*
 * Storecove API
 * Storecove API
 *
 * The version of the OpenAPI document: 2.0.1
 * Contact: apisupport@storecove.nl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Rea
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:44.175207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Rea {
  public static final String SERIALIZED_NAME_CAPITAL = "capital";
  @SerializedName(SERIALIZED_NAME_CAPITAL)
  private BigDecimal capital;

  public static final String SERIALIZED_NAME_IDENTIFIER = "identifier";
  @SerializedName(SERIALIZED_NAME_IDENTIFIER)
  private String identifier;

  /**
   * The liquidation status of the company.
   */
  @JsonAdapter(LiquidationStatusEnum.Adapter.class)
  public enum LiquidationStatusEnum {
    LN("LN"),
    
    LS("LS");

    private String value;

    LiquidationStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LiquidationStatusEnum fromValue(String value) {
      for (LiquidationStatusEnum b : LiquidationStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LiquidationStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LiquidationStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LiquidationStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LiquidationStatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LiquidationStatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LIQUIDATION_STATUS = "liquidation_status";
  @SerializedName(SERIALIZED_NAME_LIQUIDATION_STATUS)
  private LiquidationStatusEnum liquidationStatus;

  /**
   * The number of partners.
   */
  @JsonAdapter(PartnersEnum.Adapter.class)
  public enum PartnersEnum {
    SU("SU"),
    
    SM("SM");

    private String value;

    PartnersEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PartnersEnum fromValue(String value) {
      for (PartnersEnum b : PartnersEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PartnersEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PartnersEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PartnersEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PartnersEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PartnersEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PARTNERS = "partners";
  @SerializedName(SERIALIZED_NAME_PARTNERS)
  private PartnersEnum partners;

  /**
   * The provincia of the ufficio that issued the identifier.
   */
  @JsonAdapter(ProvinceEnum.Adapter.class)
  public enum ProvinceEnum {
    AG("AG"),
    
    AL("AL"),
    
    AN("AN"),
    
    AO("AO"),
    
    AQ("AQ"),
    
    AR("AR"),
    
    AP("AP"),
    
    AT("AT"),
    
    AV("AV"),
    
    BA("BA"),
    
    BT("BT"),
    
    BL("BL"),
    
    BN("BN"),
    
    BG("BG"),
    
    BI("BI"),
    
    BO("BO"),
    
    BZ("BZ"),
    
    BS("BS"),
    
    BR("BR"),
    
    CA("CA"),
    
    CL("CL"),
    
    CB("CB"),
    
    CI("CI"),
    
    CE("CE"),
    
    CT("CT"),
    
    CZ("CZ"),
    
    CH("CH"),
    
    CO("CO"),
    
    CS("CS"),
    
    CR("CR"),
    
    KR("KR"),
    
    CN("CN"),
    
    EN("EN"),
    
    FM("FM"),
    
    FE("FE"),
    
    FI("FI"),
    
    FG("FG"),
    
    FC("FC"),
    
    FR("FR"),
    
    GE("GE"),
    
    GO("GO"),
    
    GR("GR"),
    
    IM("IM"),
    
    IS("IS"),
    
    SP("SP"),
    
    LT("LT"),
    
    LE("LE"),
    
    LC("LC"),
    
    LI("LI"),
    
    LO("LO"),
    
    LU("LU"),
    
    MC("MC"),
    
    MN("MN"),
    
    MS("MS"),
    
    MT("MT"),
    
    VS("VS"),
    
    ME("ME"),
    
    MI("MI"),
    
    MO("MO"),
    
    MB("MB"),
    
    NA("NA"),
    
    FALSE("false"),
    
    NU("NU"),
    
    OG("OG"),
    
    OT("OT"),
    
    OR("OR"),
    
    PD("PD"),
    
    PA("PA"),
    
    PR("PR"),
    
    PV("PV"),
    
    PG("PG"),
    
    PU("PU"),
    
    PE("PE"),
    
    PC("PC"),
    
    PI("PI"),
    
    PT("PT"),
    
    PN("PN"),
    
    PZ("PZ"),
    
    PO("PO"),
    
    RG("RG"),
    
    RA("RA"),
    
    RC("RC"),
    
    RE("RE"),
    
    RI("RI"),
    
    RN("RN"),
    
    RO("RO"),
    
    SA("SA"),
    
    SS("SS"),
    
    SV("SV"),
    
    SI("SI"),
    
    SR("SR"),
    
    SO("SO"),
    
    TA("TA"),
    
    TE("TE"),
    
    TR("TR"),
    
    TO("TO"),
    
    TP("TP"),
    
    TN("TN"),
    
    TV("TV"),
    
    TS("TS"),
    
    UD("UD"),
    
    VA("VA"),
    
    VE("VE"),
    
    VB("VB"),
    
    VC("VC"),
    
    VR("VR"),
    
    VV("VV"),
    
    VI("VI"),
    
    VT("VT");

    private String value;

    ProvinceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProvinceEnum fromValue(String value) {
      for (ProvinceEnum b : ProvinceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProvinceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProvinceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProvinceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProvinceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProvinceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROVINCE = "province";
  @SerializedName(SERIALIZED_NAME_PROVINCE)
  private ProvinceEnum province;

  public Rea() {
  }

  public Rea capital(BigDecimal capital) {
    this.capital = capital;
    return this;
  }

  /**
   * The captial for the company.
   * @return capital
   */
  @javax.annotation.Nullable
  public BigDecimal getCapital() {
    return capital;
  }

  public void setCapital(BigDecimal capital) {
    this.capital = capital;
  }


  public Rea identifier(String identifier) {
    this.identifier = identifier;
    return this;
  }

  /**
   * The identifier.
   * @return identifier
   */
  @javax.annotation.Nullable
  public String getIdentifier() {
    return identifier;
  }

  public void setIdentifier(String identifier) {
    this.identifier = identifier;
  }


  public Rea liquidationStatus(LiquidationStatusEnum liquidationStatus) {
    this.liquidationStatus = liquidationStatus;
    return this;
  }

  /**
   * The liquidation status of the company.
   * @return liquidationStatus
   */
  @javax.annotation.Nullable
  public LiquidationStatusEnum getLiquidationStatus() {
    return liquidationStatus;
  }

  public void setLiquidationStatus(LiquidationStatusEnum liquidationStatus) {
    this.liquidationStatus = liquidationStatus;
  }


  public Rea partners(PartnersEnum partners) {
    this.partners = partners;
    return this;
  }

  /**
   * The number of partners.
   * @return partners
   */
  @javax.annotation.Nullable
  public PartnersEnum getPartners() {
    return partners;
  }

  public void setPartners(PartnersEnum partners) {
    this.partners = partners;
  }


  public Rea province(ProvinceEnum province) {
    this.province = province;
    return this;
  }

  /**
   * The provincia of the ufficio that issued the identifier.
   * @return province
   */
  @javax.annotation.Nullable
  public ProvinceEnum getProvince() {
    return province;
  }

  public void setProvince(ProvinceEnum province) {
    this.province = province;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Rea rea = (Rea) o;
    return Objects.equals(this.capital, rea.capital) &&
        Objects.equals(this.identifier, rea.identifier) &&
        Objects.equals(this.liquidationStatus, rea.liquidationStatus) &&
        Objects.equals(this.partners, rea.partners) &&
        Objects.equals(this.province, rea.province);
  }

  @Override
  public int hashCode() {
    return Objects.hash(capital, identifier, liquidationStatus, partners, province);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Rea {\n");
    sb.append("    capital: ").append(toIndentedString(capital)).append("\n");
    sb.append("    identifier: ").append(toIndentedString(identifier)).append("\n");
    sb.append("    liquidationStatus: ").append(toIndentedString(liquidationStatus)).append("\n");
    sb.append("    partners: ").append(toIndentedString(partners)).append("\n");
    sb.append("    province: ").append(toIndentedString(province)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("capital");
    openapiFields.add("identifier");
    openapiFields.add("liquidation_status");
    openapiFields.add("partners");
    openapiFields.add("province");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Rea
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Rea.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Rea is not found in the empty JSON string", Rea.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Rea.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Rea` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("identifier") != null && !jsonObj.get("identifier").isJsonNull()) && !jsonObj.get("identifier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `identifier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("identifier").toString()));
      }
      if ((jsonObj.get("liquidation_status") != null && !jsonObj.get("liquidation_status").isJsonNull()) && !jsonObj.get("liquidation_status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `liquidation_status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("liquidation_status").toString()));
      }
      // validate the optional field `liquidation_status`
      if (jsonObj.get("liquidation_status") != null && !jsonObj.get("liquidation_status").isJsonNull()) {
        LiquidationStatusEnum.validateJsonElement(jsonObj.get("liquidation_status"));
      }
      if ((jsonObj.get("partners") != null && !jsonObj.get("partners").isJsonNull()) && !jsonObj.get("partners").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partners` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partners").toString()));
      }
      // validate the optional field `partners`
      if (jsonObj.get("partners") != null && !jsonObj.get("partners").isJsonNull()) {
        PartnersEnum.validateJsonElement(jsonObj.get("partners"));
      }
      if ((jsonObj.get("province") != null && !jsonObj.get("province").isJsonNull()) && !jsonObj.get("province").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `province` to be a primitive type in the JSON string but got `%s`", jsonObj.get("province").toString()));
      }
      // validate the optional field `province`
      if (jsonObj.get("province") != null && !jsonObj.get("province").isJsonNull()) {
        ProvinceEnum.validateJsonElement(jsonObj.get("province"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Rea.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Rea' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Rea> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Rea.class));

       return (TypeAdapter<T>) new TypeAdapter<Rea>() {
           @Override
           public void write(JsonWriter out, Rea value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Rea read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Rea given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Rea
   * @throws IOException if the JSON string is invalid with respect to Rea
   */
  public static Rea fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Rea.class);
  }

  /**
   * Convert an instance of Rea to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

