# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class DiscoveredParticipant(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, code: str=None, email: bool=None):
        """DiscoveredParticipant - a model defined in OpenAPI

        :param code: The code of this DiscoveredParticipant.
        :param email: The email of this DiscoveredParticipant.
        """
        self.openapi_types = {
            'code': str,
            'email': bool
        }

        self.attribute_map = {
            'code': 'code',
            'email': 'email'
        }

        self._code = code
        self._email = email

    @classmethod
    def from_dict(cls, dikt: dict) -> 'DiscoveredParticipant':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The DiscoveredParticipant of this DiscoveredParticipant.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def code(self):
        """Gets the code of this DiscoveredParticipant.

        The response code.

        :return: The code of this DiscoveredParticipant.
        :rtype: str
        """
        return self._code

    @code.setter
    def code(self, code):
        """Sets the code of this DiscoveredParticipant.

        The response code.

        :param code: The code of this DiscoveredParticipant.
        :type code: str
        """
        allowed_values = ["OK", "NOK"]  # noqa: E501
        if code not in allowed_values:
            raise ValueError(
                "Invalid value for `code` ({0}), must be one of {1}"
                .format(code, allowed_values)
            )

        self._code = code

    @property
    def email(self):
        """Gets the email of this DiscoveredParticipant.

        Whether or not an 'OK' response means the document will be sent via Peppol, but delivered by email. This happens in the Belgian Hermes system where all identifiers have been registered, but if the receiver hasn't registered with a service provider, the Hermes system will send a PDF created from the electronic invoice and email that. The electronic document will itself not be emailed. Also see https://einvoice.belgium.be/en/article/send-structured-invoices-all-your-customers-hermes[Hermes^].

        :return: The email of this DiscoveredParticipant.
        :rtype: bool
        """
        return self._email

    @email.setter
    def email(self, email):
        """Sets the email of this DiscoveredParticipant.

        Whether or not an 'OK' response means the document will be sent via Peppol, but delivered by email. This happens in the Belgian Hermes system where all identifiers have been registered, but if the receiver hasn't registered with a service provider, the Hermes system will send a PDF created from the electronic invoice and email that. The electronic document will itself not be emailed. Also see https://einvoice.belgium.be/en/article/send-structured-invoices-all-your-customers-hermes[Hermes^].

        :param email: The email of this DiscoveredParticipant.
        :type email: bool
        """

        self._email = email
