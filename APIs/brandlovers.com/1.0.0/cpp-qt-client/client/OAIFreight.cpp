/**
 * BrandLovers Marketplace API V1
 * Allows sellers to: 1) Load products definitions to the BrandLovers marktplace. 2) Receive and update orders status. 3) Receive and update shipping information. 4) Receive and update customer tickets. All requests consume and return application/json content. All request must be authenticated and use HTTPS.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFreight.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFreight::OAIFreight(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFreight::OAIFreight() {
    this->initializeModel();
}

OAIFreight::~OAIFreight() {}

void OAIFreight::initializeModel() {

    m_eta_isSet = false;
    m_eta_isValid = false;

    m_additional_info_isSet = false;
    m_additional_info_isValid = false;

    m_charged_amount_isSet = false;
    m_charged_amount_isValid = false;

    m_cross_docking_time_isSet = false;
    m_cross_docking_time_isValid = false;

    m_default_amount_isSet = false;
    m_default_amount_isValid = false;

    m_scheduled_period_isSet = false;
    m_scheduled_period_isValid = false;

    m_transit_time_isSet = false;
    m_transit_time_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIFreight::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFreight::fromJsonObject(QJsonObject json) {

    m_eta_isValid = ::OpenAPI::fromJsonValue(m_eta, json[QString("ETA")]);
    m_eta_isSet = !json[QString("ETA")].isNull() && m_eta_isValid;

    m_additional_info_isValid = ::OpenAPI::fromJsonValue(m_additional_info, json[QString("additionalInfo")]);
    m_additional_info_isSet = !json[QString("additionalInfo")].isNull() && m_additional_info_isValid;

    m_charged_amount_isValid = ::OpenAPI::fromJsonValue(m_charged_amount, json[QString("chargedAmount")]);
    m_charged_amount_isSet = !json[QString("chargedAmount")].isNull() && m_charged_amount_isValid;

    m_cross_docking_time_isValid = ::OpenAPI::fromJsonValue(m_cross_docking_time, json[QString("crossDockingTime")]);
    m_cross_docking_time_isSet = !json[QString("crossDockingTime")].isNull() && m_cross_docking_time_isValid;

    m_default_amount_isValid = ::OpenAPI::fromJsonValue(m_default_amount, json[QString("defaultAmount")]);
    m_default_amount_isSet = !json[QString("defaultAmount")].isNull() && m_default_amount_isValid;

    m_scheduled_period_isValid = ::OpenAPI::fromJsonValue(m_scheduled_period, json[QString("scheduledPeriod")]);
    m_scheduled_period_isSet = !json[QString("scheduledPeriod")].isNull() && m_scheduled_period_isValid;

    m_transit_time_isValid = ::OpenAPI::fromJsonValue(m_transit_time, json[QString("transitTime")]);
    m_transit_time_isSet = !json[QString("transitTime")].isNull() && m_transit_time_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIFreight::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFreight::asJsonObject() const {
    QJsonObject obj;
    if (m_eta_isSet) {
        obj.insert(QString("ETA"), ::OpenAPI::toJsonValue(m_eta));
    }
    if (m_additional_info_isSet) {
        obj.insert(QString("additionalInfo"), ::OpenAPI::toJsonValue(m_additional_info));
    }
    if (m_charged_amount_isSet) {
        obj.insert(QString("chargedAmount"), ::OpenAPI::toJsonValue(m_charged_amount));
    }
    if (m_cross_docking_time_isSet) {
        obj.insert(QString("crossDockingTime"), ::OpenAPI::toJsonValue(m_cross_docking_time));
    }
    if (m_default_amount_isSet) {
        obj.insert(QString("defaultAmount"), ::OpenAPI::toJsonValue(m_default_amount));
    }
    if (m_scheduled_period_isSet) {
        obj.insert(QString("scheduledPeriod"), ::OpenAPI::toJsonValue(m_scheduled_period));
    }
    if (m_transit_time_isSet) {
        obj.insert(QString("transitTime"), ::OpenAPI::toJsonValue(m_transit_time));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QDateTime OAIFreight::getEta() const {
    return m_eta;
}
void OAIFreight::setEta(const QDateTime &eta) {
    m_eta = eta;
    m_eta_isSet = true;
}

bool OAIFreight::is_eta_Set() const{
    return m_eta_isSet;
}

bool OAIFreight::is_eta_Valid() const{
    return m_eta_isValid;
}

QString OAIFreight::getAdditionalInfo() const {
    return m_additional_info;
}
void OAIFreight::setAdditionalInfo(const QString &additional_info) {
    m_additional_info = additional_info;
    m_additional_info_isSet = true;
}

bool OAIFreight::is_additional_info_Set() const{
    return m_additional_info_isSet;
}

bool OAIFreight::is_additional_info_Valid() const{
    return m_additional_info_isValid;
}

qint32 OAIFreight::getChargedAmount() const {
    return m_charged_amount;
}
void OAIFreight::setChargedAmount(const qint32 &charged_amount) {
    m_charged_amount = charged_amount;
    m_charged_amount_isSet = true;
}

bool OAIFreight::is_charged_amount_Set() const{
    return m_charged_amount_isSet;
}

bool OAIFreight::is_charged_amount_Valid() const{
    return m_charged_amount_isValid;
}

qint32 OAIFreight::getCrossDockingTime() const {
    return m_cross_docking_time;
}
void OAIFreight::setCrossDockingTime(const qint32 &cross_docking_time) {
    m_cross_docking_time = cross_docking_time;
    m_cross_docking_time_isSet = true;
}

bool OAIFreight::is_cross_docking_time_Set() const{
    return m_cross_docking_time_isSet;
}

bool OAIFreight::is_cross_docking_time_Valid() const{
    return m_cross_docking_time_isValid;
}

qint32 OAIFreight::getDefaultAmount() const {
    return m_default_amount;
}
void OAIFreight::setDefaultAmount(const qint32 &default_amount) {
    m_default_amount = default_amount;
    m_default_amount_isSet = true;
}

bool OAIFreight::is_default_amount_Set() const{
    return m_default_amount_isSet;
}

bool OAIFreight::is_default_amount_Valid() const{
    return m_default_amount_isValid;
}

QString OAIFreight::getScheduledPeriod() const {
    return m_scheduled_period;
}
void OAIFreight::setScheduledPeriod(const QString &scheduled_period) {
    m_scheduled_period = scheduled_period;
    m_scheduled_period_isSet = true;
}

bool OAIFreight::is_scheduled_period_Set() const{
    return m_scheduled_period_isSet;
}

bool OAIFreight::is_scheduled_period_Valid() const{
    return m_scheduled_period_isValid;
}

qint32 OAIFreight::getTransitTime() const {
    return m_transit_time;
}
void OAIFreight::setTransitTime(const qint32 &transit_time) {
    m_transit_time = transit_time;
    m_transit_time_isSet = true;
}

bool OAIFreight::is_transit_time_Set() const{
    return m_transit_time_isSet;
}

bool OAIFreight::is_transit_time_Valid() const{
    return m_transit_time_isValid;
}

QString OAIFreight::getType() const {
    return m_type;
}
void OAIFreight::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIFreight::is_type_Set() const{
    return m_type_isSet;
}

bool OAIFreight::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIFreight::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_eta_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_additional_info_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_charged_amount_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cross_docking_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_amount_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scheduled_period_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transit_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFreight::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_additional_info_isValid && m_charged_amount_isValid && m_cross_docking_time_isValid && m_default_amount_isValid && m_transit_time_isValid && true;
}

} // namespace OpenAPI
