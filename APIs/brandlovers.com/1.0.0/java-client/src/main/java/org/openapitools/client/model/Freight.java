/*
 * BrandLovers Marketplace API V1
 * Allows sellers to: 1) Load products definitions to the BrandLovers marktplace. 2) Receive and update orders status. 3) Receive and update shipping information. 4) Receive and update customer tickets. All requests consume and return application/json content. All request must be authenticated and use HTTPS.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Freight
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:32:33.374218-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Freight {
  public static final String SERIALIZED_NAME_E_T_A = "ETA";
  @SerializedName(SERIALIZED_NAME_E_T_A)
  private OffsetDateTime ETA;

  public static final String SERIALIZED_NAME_ADDITIONAL_INFO = "additionalInfo";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_INFO)
  private String additionalInfo;

  public static final String SERIALIZED_NAME_CHARGED_AMOUNT = "chargedAmount";
  @SerializedName(SERIALIZED_NAME_CHARGED_AMOUNT)
  private Integer chargedAmount;

  public static final String SERIALIZED_NAME_CROSS_DOCKING_TIME = "crossDockingTime";
  @SerializedName(SERIALIZED_NAME_CROSS_DOCKING_TIME)
  private Integer crossDockingTime;

  public static final String SERIALIZED_NAME_DEFAULT_AMOUNT = "defaultAmount";
  @SerializedName(SERIALIZED_NAME_DEFAULT_AMOUNT)
  private Integer defaultAmount;

  public static final String SERIALIZED_NAME_SCHEDULED_PERIOD = "scheduledPeriod";
  @SerializedName(SERIALIZED_NAME_SCHEDULED_PERIOD)
  private String scheduledPeriod;

  public static final String SERIALIZED_NAME_TRANSIT_TIME = "transitTime";
  @SerializedName(SERIALIZED_NAME_TRANSIT_TIME)
  private Integer transitTime;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public Freight() {
  }

  public Freight ETA(OffsetDateTime ETA) {
    this.ETA = ETA;
    return this;
  }

  /**
   * Estimated time of arrival
   * @return ETA
   */
  @javax.annotation.Nullable
  public OffsetDateTime getETA() {
    return ETA;
  }

  public void setETA(OffsetDateTime ETA) {
    this.ETA = ETA;
  }


  public Freight additionalInfo(String additionalInfo) {
    this.additionalInfo = additionalInfo;
    return this;
  }

  /**
   * Aditional information for the courier
   * @return additionalInfo
   */
  @javax.annotation.Nonnull
  public String getAdditionalInfo() {
    return additionalInfo;
  }

  public void setAdditionalInfo(String additionalInfo) {
    this.additionalInfo = additionalInfo;
  }


  public Freight chargedAmount(Integer chargedAmount) {
    this.chargedAmount = chargedAmount;
    return this;
  }

  /**
   * Shipment cost. Must be informed in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. Same as $1,2345.67 must be informed solely as 1234567
   * @return chargedAmount
   */
  @javax.annotation.Nonnull
  public Integer getChargedAmount() {
    return chargedAmount;
  }

  public void setChargedAmount(Integer chargedAmount) {
    this.chargedAmount = chargedAmount;
  }


  public Freight crossDockingTime(Integer crossDockingTime) {
    this.crossDockingTime = crossDockingTime;
    return this;
  }

  /**
   * Time it will take to manufacture, prepare or setup this product. Time must be provided in seconds. For example 1 day should be informed as 86400. This time will be included in the product ETA informed to the customer
   * @return crossDockingTime
   */
  @javax.annotation.Nonnull
  public Integer getCrossDockingTime() {
    return crossDockingTime;
  }

  public void setCrossDockingTime(Integer crossDockingTime) {
    this.crossDockingTime = crossDockingTime;
  }


  public Freight defaultAmount(Integer defaultAmount) {
    this.defaultAmount = defaultAmount;
    return this;
  }

  /**
   * Default value of this shippment.
   * @return defaultAmount
   */
  @javax.annotation.Nonnull
  public Integer getDefaultAmount() {
    return defaultAmount;
  }

  public void setDefaultAmount(Integer defaultAmount) {
    this.defaultAmount = defaultAmount;
  }


  public Freight scheduledPeriod(String scheduledPeriod) {
    this.scheduledPeriod = scheduledPeriod;
    return this;
  }

  /**
   * Scheduled period
   * @return scheduledPeriod
   */
  @javax.annotation.Nullable
  public String getScheduledPeriod() {
    return scheduledPeriod;
  }

  public void setScheduledPeriod(String scheduledPeriod) {
    this.scheduledPeriod = scheduledPeriod;
  }


  public Freight transitTime(Integer transitTime) {
    this.transitTime = transitTime;
    return this;
  }

  /**
   * Deliver time in seconds. Time must be provided in seconds. For example 1 day should be informed as 86400. This time will be included in the product ETA informed to the customer
   * @return transitTime
   */
  @javax.annotation.Nonnull
  public Integer getTransitTime() {
    return transitTime;
  }

  public void setTransitTime(Integer transitTime) {
    this.transitTime = transitTime;
  }


  public Freight type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Freight type
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Freight freight = (Freight) o;
    return Objects.equals(this.ETA, freight.ETA) &&
        Objects.equals(this.additionalInfo, freight.additionalInfo) &&
        Objects.equals(this.chargedAmount, freight.chargedAmount) &&
        Objects.equals(this.crossDockingTime, freight.crossDockingTime) &&
        Objects.equals(this.defaultAmount, freight.defaultAmount) &&
        Objects.equals(this.scheduledPeriod, freight.scheduledPeriod) &&
        Objects.equals(this.transitTime, freight.transitTime) &&
        Objects.equals(this.type, freight.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ETA, additionalInfo, chargedAmount, crossDockingTime, defaultAmount, scheduledPeriod, transitTime, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Freight {\n");
    sb.append("    ETA: ").append(toIndentedString(ETA)).append("\n");
    sb.append("    additionalInfo: ").append(toIndentedString(additionalInfo)).append("\n");
    sb.append("    chargedAmount: ").append(toIndentedString(chargedAmount)).append("\n");
    sb.append("    crossDockingTime: ").append(toIndentedString(crossDockingTime)).append("\n");
    sb.append("    defaultAmount: ").append(toIndentedString(defaultAmount)).append("\n");
    sb.append("    scheduledPeriod: ").append(toIndentedString(scheduledPeriod)).append("\n");
    sb.append("    transitTime: ").append(toIndentedString(transitTime)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ETA");
    openapiFields.add("additionalInfo");
    openapiFields.add("chargedAmount");
    openapiFields.add("crossDockingTime");
    openapiFields.add("defaultAmount");
    openapiFields.add("scheduledPeriod");
    openapiFields.add("transitTime");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("additionalInfo");
    openapiRequiredFields.add("chargedAmount");
    openapiRequiredFields.add("crossDockingTime");
    openapiRequiredFields.add("defaultAmount");
    openapiRequiredFields.add("transitTime");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Freight
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Freight.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Freight is not found in the empty JSON string", Freight.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Freight.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Freight` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Freight.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("additionalInfo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `additionalInfo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("additionalInfo").toString()));
      }
      if ((jsonObj.get("scheduledPeriod") != null && !jsonObj.get("scheduledPeriod").isJsonNull()) && !jsonObj.get("scheduledPeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scheduledPeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scheduledPeriod").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Freight.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Freight' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Freight> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Freight.class));

       return (TypeAdapter<T>) new TypeAdapter<Freight>() {
           @Override
           public void write(JsonWriter out, Freight value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Freight read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Freight given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Freight
   * @throws IOException if the JSON string is invalid with respect to Freight
   */
  public static Freight fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Freight.class);
  }

  /**
   * Convert an instance of Freight to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

