/*
 * BrandLovers Marketplace API V1
 * Allows sellers to: 1) Load products definitions to the BrandLovers marktplace. 2) Receive and update orders status. 3) Receive and update shipping information. 4) Receive and update customer tickets. All requests consume and return application/json content. All request must be authenticated and use HTTPS.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Invoice
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:32:33.374218-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Invoice {
  public static final String SERIALIZED_NAME_ACCESS_KEY = "accessKey";
  @SerializedName(SERIALIZED_NAME_ACCESS_KEY)
  private String accessKey;

  public static final String SERIALIZED_NAME_CNPJ = "cnpj";
  @SerializedName(SERIALIZED_NAME_CNPJ)
  private String cnpj;

  public static final String SERIALIZED_NAME_ISSUED_AT = "issuedAt";
  @SerializedName(SERIALIZED_NAME_ISSUED_AT)
  private OffsetDateTime issuedAt;

  public static final String SERIALIZED_NAME_LINK_DANFE = "linkDanfe";
  @SerializedName(SERIALIZED_NAME_LINK_DANFE)
  private String linkDanfe;

  public static final String SERIALIZED_NAME_LINK_XML = "linkXml";
  @SerializedName(SERIALIZED_NAME_LINK_XML)
  private String linkXml;

  public static final String SERIALIZED_NAME_NUMBER = "number";
  @SerializedName(SERIALIZED_NAME_NUMBER)
  private String number;

  public static final String SERIALIZED_NAME_SERIE = "serie";
  @SerializedName(SERIALIZED_NAME_SERIE)
  private String serie;

  public Invoice() {
  }

  public Invoice accessKey(String accessKey) {
    this.accessKey = accessKey;
    return this;
  }

  /**
   * Número da chave de acesso à nota fiscal. A chave possui 44 dígitos e contém todas as informações da DANFE
   * @return accessKey
   */
  @javax.annotation.Nonnull
  public String getAccessKey() {
    return accessKey;
  }

  public void setAccessKey(String accessKey) {
    this.accessKey = accessKey;
  }


  public Invoice cnpj(String cnpj) {
    this.cnpj = cnpj;
    return this;
  }

  /**
   * CNPJ responsável pelo envio dos produtos. Pode ser diferente caso a empresa possua diversos Centros de Distribuição (CDs)
   * @return cnpj
   */
  @javax.annotation.Nullable
  public String getCnpj() {
    return cnpj;
  }

  public void setCnpj(String cnpj) {
    this.cnpj = cnpj;
  }


  public Invoice issuedAt(OffsetDateTime issuedAt) {
    this.issuedAt = issuedAt;
    return this;
  }

  /**
   * Data de emissão da Nota Fiscal
   * @return issuedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getIssuedAt() {
    return issuedAt;
  }

  public void setIssuedAt(OffsetDateTime issuedAt) {
    this.issuedAt = issuedAt;
  }


  public Invoice linkDanfe(String linkDanfe) {
    this.linkDanfe = linkDanfe;
    return this;
  }

  /**
   * Url para consulta da DANFE
   * @return linkDanfe
   */
  @javax.annotation.Nullable
  public String getLinkDanfe() {
    return linkDanfe;
  }

  public void setLinkDanfe(String linkDanfe) {
    this.linkDanfe = linkDanfe;
  }


  public Invoice linkXml(String linkXml) {
    this.linkXml = linkXml;
    return this;
  }

  /**
   * Url para consulta da NFE
   * @return linkXml
   */
  @javax.annotation.Nullable
  public String getLinkXml() {
    return linkXml;
  }

  public void setLinkXml(String linkXml) {
    this.linkXml = linkXml;
  }


  public Invoice number(String number) {
    this.number = number;
    return this;
  }

  /**
   * Número da Nota Fiscal
   * @return number
   */
  @javax.annotation.Nonnull
  public String getNumber() {
    return number;
  }

  public void setNumber(String number) {
    this.number = number;
  }


  public Invoice serie(String serie) {
    this.serie = serie;
    return this;
  }

  /**
   * Número de serie da Nota Fiscal
   * @return serie
   */
  @javax.annotation.Nonnull
  public String getSerie() {
    return serie;
  }

  public void setSerie(String serie) {
    this.serie = serie;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Invoice invoice = (Invoice) o;
    return Objects.equals(this.accessKey, invoice.accessKey) &&
        Objects.equals(this.cnpj, invoice.cnpj) &&
        Objects.equals(this.issuedAt, invoice.issuedAt) &&
        Objects.equals(this.linkDanfe, invoice.linkDanfe) &&
        Objects.equals(this.linkXml, invoice.linkXml) &&
        Objects.equals(this.number, invoice.number) &&
        Objects.equals(this.serie, invoice.serie);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessKey, cnpj, issuedAt, linkDanfe, linkXml, number, serie);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Invoice {\n");
    sb.append("    accessKey: ").append(toIndentedString(accessKey)).append("\n");
    sb.append("    cnpj: ").append(toIndentedString(cnpj)).append("\n");
    sb.append("    issuedAt: ").append(toIndentedString(issuedAt)).append("\n");
    sb.append("    linkDanfe: ").append(toIndentedString(linkDanfe)).append("\n");
    sb.append("    linkXml: ").append(toIndentedString(linkXml)).append("\n");
    sb.append("    number: ").append(toIndentedString(number)).append("\n");
    sb.append("    serie: ").append(toIndentedString(serie)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessKey");
    openapiFields.add("cnpj");
    openapiFields.add("issuedAt");
    openapiFields.add("linkDanfe");
    openapiFields.add("linkXml");
    openapiFields.add("number");
    openapiFields.add("serie");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("accessKey");
    openapiRequiredFields.add("number");
    openapiRequiredFields.add("serie");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Invoice
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Invoice.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Invoice is not found in the empty JSON string", Invoice.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Invoice.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Invoice` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Invoice.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("accessKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accessKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accessKey").toString()));
      }
      if ((jsonObj.get("cnpj") != null && !jsonObj.get("cnpj").isJsonNull()) && !jsonObj.get("cnpj").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cnpj` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cnpj").toString()));
      }
      if ((jsonObj.get("linkDanfe") != null && !jsonObj.get("linkDanfe").isJsonNull()) && !jsonObj.get("linkDanfe").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `linkDanfe` to be a primitive type in the JSON string but got `%s`", jsonObj.get("linkDanfe").toString()));
      }
      if ((jsonObj.get("linkXml") != null && !jsonObj.get("linkXml").isJsonNull()) && !jsonObj.get("linkXml").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `linkXml` to be a primitive type in the JSON string but got `%s`", jsonObj.get("linkXml").toString()));
      }
      if (!jsonObj.get("number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("number").toString()));
      }
      if (!jsonObj.get("serie").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serie` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serie").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Invoice.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Invoice' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Invoice> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Invoice.class));

       return (TypeAdapter<T>) new TypeAdapter<Invoice>() {
           @Override
           public void write(JsonWriter out, Invoice value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Invoice read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Invoice given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Invoice
   * @throws IOException if the JSON string is invalid with respect to Invoice
   */
  public static Invoice fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Invoice.class);
  }

  /**
   * Convert an instance of Invoice to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

